post_cb({"13792750": {"ParentId": "13792648", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>There are three takes on this:</p>\n<ul>\n<li><p>Formally<br>\nwell, who knows. I could find out for you by using quite some time on it, but then, so could you. Or any reader. And it's not like that's very practically useful.<br>\n<strong>EDIT</strong>: OK, looking it up, since you don't seem happy about me mentioning the formal without looking it up for you. Formally you're out of luck:<br>\n<b>N3280 (C++11) \u00a75.7/5</b> <i>\u201cIf both the pointer operand and the result point to elements of the same array object, or one past\nthe last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.\u201d</i><br>\nTwo situations where this can produce undesired behavior: (1) computing an address beyond the end of a segment, and (2) computing an address beyond an array that the compiler knows the size of, with debug checks enabled.</br></br></br></br></p></li>\n<li><p>Technically<br>\nyou're probably OK as long as you avoid any lvalue-to-rvalue conversion, because if the references are implemented as pointers, then it's as safe as pointers, and if the compiler chooses to implement them as aliases, well, that's also ok.</br></p></li>\n<li><p>Economically<br>\nrelying needlessly on a subtlety wastes your time, and then also the time of others dealing with the code. So, <em>not a good idea</em>. Instead, declare the names when it's guaranteed that what they refer to, exists.</br></p></li>\n</ul>\n", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2012-12-09T23:09:34.670", "Id": "13792750", "Score": "5", "CreationDate": "2012-12-09T22:54:04.823", "LastActivityDate": "2012-12-09T23:09:34.670"}, "13792648": {"CommentCount": "6", "ViewCount": "172", "PostTypeId": "1", "LastEditorUserId": "1073695", "CreationDate": "2012-12-09T22:41:20.740", "LastActivityDate": "2012-12-09T23:16:07.027", "Title": "Can I safely create references to possibly invalid memory as long as I don't use it?", "AcceptedAnswerId": "13792750", "LastEditDate": "2012-12-09T22:46:40.920", "Id": "13792648", "Score": "8", "Body": "<p>I want to parse UTF-8 in C++. When parsing a new character, I don't know in advance if it is an ASCII byte or the leader of a multibyte character, and also I don't know if my input string is sufficiently long to contain the remaining characters.</p>\n<p>For simplicity, I'd like to name the four next bytes <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code>, and because I am in C++, I want to do it using references.</p>\n<p>Is it valid to define those references at the beginning of a function as long as I don't access them before I know that access is safe? Example:</p>\n<pre><code>void parse_utf8_character(const string s) {\n    for (size_t i = 0; i &lt; s.size();) {\n        const char &amp;a = s[i];\n        const char &amp;b = s[i + 1];\n        const char &amp;c = s[i + 2];\n        const char &amp;d = s[i + 3];\n\n        if (is_ascii(a)) {\n            i += 1;\n            do_something_only_with(a);\n        } else if (is_twobyte_leader(a)) {\n            i += 2;\n            if (is_safe_to_access_b()) {\n                do_something_only_with(a, b);\n            }\n        }\n        ...\n     }\n}\n</code></pre>\n<p>The above example shows what I want to do semantically. It doesn't illustrate why I want to do this, but obviously real code will be more involved, so defining b,c,d only when I know that access is safe and I need them would be too verbose.</p>\n", "Tags": "<c++>", "OwnerUserId": "1073695", "AnswerCount": "3"}, "13792845": {"ParentId": "13792648", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Before going into the legality of references to unaccessible memory, you have another problem in your code. Your call to <code>s[i+x]</code> might call <code>string::operator[]</code> with a parameter bigger then <code>s.size()</code>. The C++11 standard says about <code>string::operator[]</code> (<strong>[string.access], \u00a721.4.5</strong>):  </p>\n<blockquote>\n<p id=\"so_13792648_13792845_0\">Requires: pos &lt;= size().</p>\n<p id=\"so_13792648_13792845_1\">Returns: *(begin()+pos) if pos &lt; size(), otherwise a reference to an object of type T with value charT(); the referenced value shall not be modi\ufb01ed.</p>\n</blockquote>\n<p>This means that calling <code>s[x]</code> for <code>x &gt; s.size()</code> is undefined behaviour, so the implementation could very well terminate your program, e.g. by means of an assertion,  for that. </p>\n<p>Since <code>string</code> is now guaranteed to be continous, you could go around that problem using &amp;s[i]+x to get an address. In praxis this will probably work.</p>\n<p>However, strictly speaking doing this is still illegal unfortunately. The reason for this is that the standard allows pointer arithmetic only as long as the pointer stays inside the same array, or one past the end of the array. The relevant part of the (C++11) standard is in [expr.add], \u00a75.7.5:</p>\n<blockquote>\n<p id=\"so_13792648_13792845_2\">If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an over\ufb02ow; otherwise, the behavior is unde\ufb01ned.</p>\n</blockquote>\n<p>Therefore generating references or pointers to invalid memory locations might work on most implementations, but it is technically undefined behaviour, even if you never dereference the pointer/use the reference. Relying on UB is almost <strong>never</strong> a good idea , because even if it works for all targeted systems, there are no guarantees about it continuing to work in the future.</p>\n", "OwnerUserId": "201270", "LastEditorUserId": "201270", "LastEditDate": "2012-12-09T23:16:07.027", "Id": "13792845", "Score": "4", "CreationDate": "2012-12-09T23:09:13.570", "LastActivityDate": "2012-12-09T23:16:07.027"}, "13792729": {"ParentId": "13792648", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>In principle, the idea of taking a reference for a possibly illegal memory address is itself perfectly legal.  The reference is only a pointer under the hood, and pointer arithmetic is legal until dereferencing occurs.</p>\n<p>EDIT: This claim is a practical one, not one covered by the published standard.  There are many corners of the published standard which are formally undefined behaviour, but don't produce any kind of unexpected behaviour in practice.</p>\n<p>Take for example to possibility of computing a pointer to the second item after the end of an array (as @DanielTrebbien suggests).  The standard says overflow may result in undefined behaviour.  In practice, the overflow would only occur if the upper end of the array is just short of the space addressable by a pointer.  Not a likely scenario.  Even when if it does happen, nothing bad would happen on most architectures.  What is violated are certain guarantees about pointer differences, which don't apply here.</p>\n<p>@JoSo If you were working with a character array, you can avoid some of the uncertainty about reference semantics by replacing the const-references with const-pointers in your code.  That way you can be certain no compiler will alias the values.</p>\n", "OwnerUserId": "588948", "LastEditorUserId": "588948", "LastEditDate": "2012-12-09T23:15:23.803", "Id": "13792729", "Score": "2", "CreationDate": "2012-12-09T22:51:00.653", "LastActivityDate": "2012-12-09T23:15:23.803"}, "bq_ids": {"n4140": {"so_13792648_13792845_2": {"section_id": 6142, "quality": 0.9047619047619048, "length": 19}, "so_13792648_13792845_1": {"section_id": 1617, "quality": 0.5384615384615384, "length": 7}}, "n3337": {"so_13792648_13792845_2": {"section_id": 5906, "quality": 0.9047619047619048, "length": 19}, "so_13792648_13792845_1": {"section_id": 1613, "quality": 0.5384615384615384, "length": 7}}, "n4659": {"so_13792648_13792845_1": {"section_id": 1770, "quality": 0.6153846153846154, "length": 8}}}});