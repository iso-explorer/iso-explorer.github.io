post_cb({"29224988": {"Id": "29224988", "PostTypeId": "2", "Body": "<h3>[C] Static function with file scope.</h3>\n<pre><code>static void bar() { ... }\n</code></pre>\n<p>This will create a function named <code>bar</code> that has internal linkage.</p>\n<h3>[C++] Static function with file scope</h3>\n<pre><code>static void bar() { ... }\n</code></pre>\n<p>This will create a function named <code>bar</code> that has internal linkage.</p>\n<h3>[C++] Unnamed namespace</h3>\n<pre><code>namespace {\n    void bar() { ... }\n}\n</code></pre>\n<p>This will create a function named <code>bar</code> that has internal linkage.</p>\n<h1>Conclusions</h1>\n<p>They are all <strong>identical</strong>. I'd probably recommend using the unnamed namespace in C++, because it gets rid of some of the overloading of the <code>static</code> keyword. But from the perspective of what your code does, it doesn't matter.</p>\n<h1>Sidebar: What does internal linkage mean?</h1>\n<p>In C and C++, we have three kinds of linkage: <strong>External</strong>, <strong>Internal</strong> and <strong>No linkage</strong>. To define these, I'm going to quote from C++ 2011 Section 3.5 Paragraph 2:</p>\n<blockquote>\n<p id=\"so_29224679_29224988_0\">A name is said to have linkage when it might denote the same object, reference, function, type, template, namespace or value as a name introduced by a declaration in another scope:</p>\n<ul>\n<li>When a name has external linkage , the entity it denotes can be referred to by names from scopes of other translation units or from other scopes of the same translation unit.</li>\n<li>When a name has internal linkage , the entity it denotes can be referred to by names from other scopes in the same translation unit.</li>\n<li>When a name has no linkage , the entity it denotes cannot be referred to by names from other scopes.</li>\n</ul>\n</blockquote>\n<p>C 2011 has similar language at Section 6.2.2 Paragraph 2:</p>\n<blockquote>\n<p id=\"so_29224679_29224988_1\">In the set of translation units and libraries that constitutes an entire program, each declaration of a particular identifier with external linkage denotes the same object or function. Within one translation unit, each declaration of an identifier with internal linkage denotes the same object or function. Each declaration of an identifier with no linkage denotes a unique entity.</p>\n</blockquote>\n<p>So names that have internal linkage are only visible in the translation unit that they were found in.</p>\n<h3>Sidebar: Let's include an example of how internal linkage works in practice:</h3>\n<p>Let's create 2 c++ files. <strong>bar.cc</strong> will contain just a function with internal linkage:</p>\n<pre><code>static void bar() {}\n</code></pre>\n<p>We'll also create <strong>main.cc</strong>, which will try to use that <code>bar()</code>.</p>\n<pre><code>extern void bar();\n\nint main() {\n    bar();\n}\n</code></pre>\n<p>If we compile this, our linker will complain. there is no function named <code>bar</code> that we can find from the main.cc translation unit. This is the expected behavior of internal linkage.</p>\n<pre><code>Undefined symbols for architecture x86_64:\n  \"bar()\", referenced from:\n      _main in main-c16bef.o\nld: symbol(s) not found for architecture x86_64\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre>\n", "LastEditorUserId": "47453", "LastActivityDate": "2015-03-24T04:50:35.610", "Score": "9", "CreationDate": "2015-03-24T04:22:37.043", "ParentId": "29224679", "CommentCount": "18", "OwnerUserId": "47453", "LastEditDate": "2015-03-24T04:50:35.610"}, "bq_ids": {"n4140": {"so_29224679_29224988_0": {"length": 19, "quality": 0.95, "section_id": 7135}}, "n3337": {"so_29224679_29224988_0": {"length": 19, "quality": 0.95, "section_id": 6879}}, "n4659": {"so_29224679_29224988_0": {"length": 19, "quality": 0.95, "section_id": 8636}}}, "29224679": {"ViewCount": "702", "Body": "<p>What is the C++ equvalent for translation unit local <code>static</code> function in C?<br>\nFor example having the following in <code>bar.c</code>:</br></p>\n<pre><code>static void bar() {\n    // ...\n}\n</code></pre>\n<p>In C++, would this be written as a a private member function like</p>\n<pre><code>class foo {\n    void bar();\n};\n\nvoid foo::bar() {\n    // ...\n}\n</code></pre>\n<p>A private member function implicitly introduces the <code>this</code> pointer as parameter, so it's not really comparable to the C style <code>static</code> function. But even a <code>private static</code> member function <code>bar()</code> would be seen in the public interface (and staying accessible for the linker), and isn't comparable as well.  </p>\n<p>While accessible scope of those functions seems to be similar, these options don't look like good replacements for the mentioned C style <code>static</code> function syntax.</p>\n<p>Is the equivalent a function in an unnamed namespace, that's visible to the current translation unit only?</p>\n<pre><code>namespace {\n    void bar() {\n       // ...\n    }\n}\n</code></pre>\n", "AcceptedAnswerId": "29224988", "Title": "C static keyword vs C++ private scope?", "CreationDate": "2015-03-24T03:45:18.287", "Id": "29224679", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-05-20T18:05:27.653", "LastEditorUserId": "1413395", "LastActivityDate": "2016-05-20T18:05:27.653", "Score": "-3", "OwnerUserId": "1413395", "Tags": "<c++><c>", "AnswerCount": "1"}});