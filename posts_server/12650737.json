post_cb({"12650941": {"ParentId": "12650737", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>C++11 14.7.2/10 \"Explicit instantiation\" says:</p>\n<blockquote>\n<p id=\"so_12650737_12650941_0\">Except for inline functions and class template specializations,\n  explicit instantiation declarations have the effect of suppressing the\n  implicit instantiation of the entity to which they refer.</p>\n</blockquote>\n<p>And the constructor in you class template <code>Foo&lt;T&gt;</code> is inline.  VS2012 will work the way that you expect if you structure the header like so:</p>\n<pre><code>//header.h\ntemplate &lt;class T&gt;\nclass Foo\n{\npublic:\n  Foo(T t);\n  T t;\n};\n\ntemplate &lt;class T&gt;\nFoo&lt;T&gt;::Foo(T t) : t(t) \n{\n}\n</code></pre>\n<p>so that the constructor isn't inline.</p>\n<p>The paragraph from the standard I quoted above does include the following note:</p>\n<blockquote>\n<p id=\"so_12650737_12650941_1\">[ Note: The intent is that an inline function that is the subject of\n  an explicit instantiation declaration will still be implicitly\n  instantiated when odr-used (3.2) so that the body can be considered\n  for inlining, but that no out-of-line copy of the inline function\n  would be generated in the translation unit. \u2014 end note ]</p>\n</blockquote>\n<p>Looking at the assembly code created when the ctor is inlined, an out-of-line copy of the ctor is placed in the object file (even though the ctor is never even called if you compile the example with optimizations on), so MSVC doesn't appear to be following the intent of the standard. However, notes are not normative, so I believe that MSVC's behavior is conforming.</p>\n<hr>\n<p>Regarding your side question about dumping symbols from object files built with MSVC, you can use the <code>dumpbin</code> utility:</p>\n<p>When compiling the example with the non-inline constructor:</p>\n<pre><code>dumpbin /symbols test.obj\n\n...\n\n008 00000000 UNDEF  notype ()    External     | ??0?$Foo@H@@QAE@H@Z (public: __thiscall Foo&lt;int&gt;::Foo&lt;int&gt;(int))\n             ^^^^^\n...\n</code></pre>\n<p>Compiling the example with the ctor inlined:</p>\n<pre><code>00A 00000000 SECT4  notype ()    External     | ??0?$Foo@H@@QAE@H@Z (public: __thiscall Foo&lt;int&gt;::Foo&lt;int&gt;(int))\n             ^^^^^\n</code></pre>\n</hr>", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2012-09-29T08:08:37.453", "Id": "12650941", "Score": "14", "CreationDate": "2012-09-29T07:49:20.863", "LastActivityDate": "2012-09-29T08:08:37.453"}, "bq_ids": {"n4140": {"so_12650737_12650941_1": {"section_id": 259, "quality": 0.8620689655172413, "length": 25}, "so_12650737_12650941_0": {"section_id": 259, "quality": 1.0, "length": 17}}, "n3337": {"so_12650737_12650941_1": {"section_id": 250, "quality": 0.8620689655172413, "length": 25}, "so_12650737_12650941_0": {"section_id": 250, "quality": 1.0, "length": 17}}, "n4659": {"so_12650737_12650941_1": {"section_id": 266, "quality": 0.8620689655172413, "length": 25}, "so_12650737_12650941_0": {"section_id": 266, "quality": 1.0, "length": 17}}}, "12650737": {"CommentCount": "0", "AcceptedAnswerId": "12650941", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2012-09-29T07:11:59.133", "LastActivityDate": "2012-10-02T00:59:15.217", "LastEditDate": "2012-10-02T00:59:15.217", "ViewCount": "1774", "FavoriteCount": "2", "Title": "Is there a bug with extern template in Visual C++?", "Id": "12650737", "Score": "5", "Body": "<p>Given this code:</p>\n<pre><code>//header.h\ntemplate &lt;class T&gt;\nclass Foo\n{\npublic:\n  Foo(T t) : t(t) {}\n  T t;\n};\n\n//source1.cpp:\n#include \"header.h\"\nextern template class Foo&lt;int&gt;;\nint main()\n{\n  Foo&lt;int&gt; f(42);\n}\n</code></pre>\n<p>By my understanding, this program should not link, since there should be no definition of <code>class Foo&lt;int&gt;</code> anywhere (<code>extern template</code> should prevent this). With VC++ 11 (Visual Studio 2012), this does however compile and link. In GCC, it doesn't:</p>\n<pre><code>source1.cpp:(.text+0x15): undefined reference to `Foo&lt;int&gt;::Foo(int)'\n</code></pre>\n<p>If I link with source2.cpp however, it works (as I expect i should) :</p>\n<pre><code>#include \"header.h\"\ntemplate class Foo&lt;int&gt;;\n</code></pre>\n<p>According to this blog post, extern template should have been supported since VC10.\n<a href=\"http://blogs.msdn.com/b/vcblog/archive/2011/09/12/10209291.aspx\" rel=\"nofollow\">http://blogs.msdn.com/b/vcblog/archive/2011/09/12/10209291.aspx</a></p>\n<p>On a side note, is there a way to list the names in an object file on Windows / Visual Studio? On Linux I would do:</p>\n<pre><code>$ nm source1.o\nU _ZN3FooIiEC1Ei      &lt;- \"U\" means that this symbol is undefined.\n0000000000000000 T main\n</code></pre>\n", "Tags": "<c++><visual-c++><c++11><visual-studio-2012>", "OwnerUserId": "7084", "AnswerCount": "1"}});