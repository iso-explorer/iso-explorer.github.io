post_cb({"12773640": {"CommentCount": "0", "AcceptedAnswerId": "12773681", "PostTypeId": "1", "LastEditorUserId": "168868", "CreationDate": "2012-10-07T23:07:43.817", "LastActivityDate": "2012-10-08T01:09:19.967", "LastEditDate": "2012-10-08T01:09:19.967", "ViewCount": "532", "FavoriteCount": "1", "Title": "Value representation of non-trivially copyable types", "Id": "12773640", "Score": "3", "Body": "<p>I'm intrigued by the following paragraph from the standard (\u00a73.9/4 of <em>ISO/IEC 14882:2011(E)</em>):</p>\n<blockquote>\n<p id=\"so_12773640_12773640_0\">The <em>object representation</em> of an object of type <code>T</code> is the sequence of <em>N</em> <code>unsigned char</code> objects taken up by the object of type <code>T</code>, where <em>N</em> equals <code>sizeof(T)</code>. The <em>value representation</em> of an object is the set of bits that hold the value of type <code>T</code>. For trivially copyable types, the value representation is a set of bits in the object representation that determines a <em>value</em>, which is one discrete element of an implementation-defined set of values.<sup>42</sup></p>\n</blockquote>\n<p>I understand that the <em>object representation</em> and <em>value representation</em> are distinct to allow some of the object representation to not take part in the value of the object (for example, padding). I don't quite get the point about trivially copyable types though. Do non-trivially copyable types not have values? Can part of the value representation of a non-trivially copyable type exist outside its object representation?</p>\n<p>Note 42 explains:</p>\n<blockquote>\n<p id=\"so_12773640_12773640_1\">The intent is that the memory model of C++ is compatible with that of ISO/IEC 9899 Programming Language C.</p>\n</blockquote>\n<p>I still don't understand why the previous statement is specifically for trivially copyable types only though. What is the significance of this?</p>\n", "Tags": "<c++><object><memory-model>", "OwnerUserId": "150634", "AnswerCount": "1"}, "12773681": {"ParentId": "12773640", "CommentCount": "0", "CreationDate": "2012-10-07T23:18:08.520", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "12773681", "Score": "6", "Body": "<p>The standard example is a class that manages a resource:</p>\n<pre><code>struct Foo\n{\n    Bar * p;\n\n    Foo() : p(new Bar) { }\n    ~Foo() { delete p; }\n\n    // copy, assign\n};\n</code></pre>\n<p>An object of type <code>Foo</code> has a value, but that value is not copyable by copying the object representation (which is just the value of <code>p</code> in this case). Copying an object of type <code>Foo</code> requires copying the <em>se\u00adman\u00adtics</em> of the class, which say \"an object <em>owns</em> the pointee\". A suitable copy thus requires an appropriate, user-defined copy constructor:</p>\n<pre><code>Foo::Foo(Foo const &amp; rhs) : p(new Bar(*rhs.p)) { }\n</code></pre>\n<p>Now the object representation of an object of type <code>Foo</code> is different from the object representation of a copy of such an object, although they have the same value.</p>\n<p>By contrast, the value of an <code>int</code> is the same as that of another <code>int</code> as soon as the object representations coincide. (This is a sufficient, though not necessary, condition, due to padding.)</p>\n", "LastActivityDate": "2012-10-07T23:18:08.520"}, "bq_ids": {"n4140": {"so_12773640_12773640_0": {"section_id": 7202, "quality": 0.8095238095238095, "length": 34}, "so_12773640_12773640_1": {"section_id": 7202, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_12773640_12773640_0": {"section_id": 6946, "quality": 0.8095238095238095, "length": 34}, "so_12773640_12773640_1": {"section_id": 6946, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_12773640_12773640_0": {"section_id": 8711, "quality": 0.8095238095238095, "length": 34}, "so_12773640_12773640_1": {"section_id": 8711, "quality": 0.8888888888888888, "length": 8}}}});