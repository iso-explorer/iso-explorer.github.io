post_cb({"bq_ids": {"n4140": {"so_19205125_19205206_1": {"length": 14, "quality": 1.0, "section_id": 7213}, "so_19205125_19205206_0": {"length": 13, "quality": 1.0, "section_id": 5937}}, "n3337": {"so_19205125_19205206_1": {"length": 14, "quality": 1.0, "section_id": 6957}, "so_19205125_19205206_0": {"length": 13, "quality": 1.0, "section_id": 5709}}, "n4659": {"so_19205125_19205206_1": {"length": 14, "quality": 1.0, "section_id": 8722}, "so_19205125_19205206_0": {"length": 13, "quality": 1.0, "section_id": 7421}}}, "19205206": {"Id": "19205206", "PostTypeId": "2", "Body": "<p>This is a quote from 5 [expr] paragraph 4:</p>\n<blockquote>\n<p id=\"so_19205125_19205206_0\">If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined.</p>\n</blockquote>\n<p>What makes overflow for unsigned integers work is defined in 3.9.1 [basic.fundamental] paragraph 4:</p>\n<blockquote>\n<p id=\"so_19205125_19205206_1\">Unsigned integers shall obey the laws of arithmetic modulo 2<sup>n</sup> where n is the number of bits in the value representation of that particular size of integer.</p>\n</blockquote>\n<p>Basically this says that you shall not overflow when using signed integer arithmetic. If you do, all bets are off. This implies that signed integers do not form an Abelian group in C++.</p>\n", "LastEditorUserId": "525872", "LastActivityDate": "2015-03-17T21:20:31.353", "Score": "7", "CreationDate": "2013-10-06T03:46:40.717", "ParentId": "19205125", "CommentCount": "2", "OwnerUserId": "1120273", "LastEditDate": "2015-03-17T21:20:31.353"}, "19205125": {"ViewCount": "194", "Body": "<p>Two 32 bit integer values A and B, are processed to give the 32 bit integers C and D as per the following rules. Which of the rule(s) is(are) reversible?\ni.e.  is it possible to obtain A and B given c and D in all condition?</p>\n<p>A.   C = (int32)(A+B), D = (int32)(A-B)</p>\n<p>B.   C = (int32)(A+B),  D= (int32)((A-B)&gt;&gt;1)</p>\n<p>C.   C = (int32)(A+B),  D = B</p>\n<p>D.   C = (int32)(A+B), D = (int32)(A+2*B)</p>\n<p>E.   C = (int32)(A*B),  D = (int32)(A/B)</p>\n<p>A few questions about the integer arithmetic. Modular addition forms amathematical structure known as an <em>abelian group</em>. <strong>How about signed addition?</strong> It's also commutative (that\u2019s where the \u201cabelian\u201d part comes in) and associative, <strong>is this forms a n an <em>abelian group</em></strong>?</p>\n<p>Given that integer addition is commutative and associative, C is apparently true, because we can retrieve A by (A+(B-B)). <strong>What about D?</strong> Can we assume that <code>2 * B = B + B</code> st. <code>B = A+B+B-(A+B)</code>?</p>\n<p>And multiplication is more complicated, but I know that it can not be retrieve A if there is an overflow.</p>\n", "Title": "Integer arithmetic when overflow exists", "CreationDate": "2013-10-06T03:30:30.590", "LastActivityDate": "2015-03-17T21:23:55.183", "CommentCount": "6", "LastEditDate": "2015-03-17T21:23:55.183", "PostTypeId": "1", "LastEditorUserId": "47453", "Id": "19205125", "Score": "0", "OwnerUserId": "1547399", "Tags": "<c++><c><integer-arithmetic>", "AnswerCount": "1"}});