post_cb({"23140119": {"ParentId": "22952480", "LastEditDate": "2017-05-23T11:50:59.357", "CommentCount": "0", "CreationDate": "2014-04-17T17:54:10.747", "OwnerUserId": "1137388", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "23140119", "Score": "2", "Body": "<p><strong>The syntax:</strong></p>\n<p>Syntactically, you can achieve this through a type alias (or <code>typedef</code>):</p>\n<pre><code>using function_t = void(int); // or typedef void (function_t)(int);\n\nclass dummy {\npublic:\n    const function_t&amp; member;\n    dummy(const function_t&amp; func)\n         : member{func}{}\n\n};\n</code></pre>\n<p><strong>The semantics:</strong></p>\n<p>However, the \"correct syntax\" doesn't buy you anything: <code>dummy</code> is the same as</p>\n<pre><code>class dummy {\npublic:\n    function_t&amp; member;\n    dummy(function_t&amp; func)\n         : member{func}{}\n\n};\n</code></pre>\n<p>(which, in turn is the same as the OP's definition) because the <code>const</code> qualifiers are ignored as per C++11 8.3.5/6:</p>\n<blockquote>\n<blockquote>\n<p id=\"so_22952480_23140119_1\">The effect of a cv-qualifier-seq in a function declarator is not the same as adding cv-qualification on top of the function type. <strong>In the latter case, the cv-qualifiers are ignored</strong>. [ Note: a function type that has a cv-qualifier-seq is not a cv-qualified type; <strong>there are no cv-qualified function types</strong>. \u2014end note ]</p>\n</blockquote>\n</blockquote>\n<p><strong>What about rvalues?</strong></p>\n<p>As far as I undestand (from a comment to <a href=\"https://stackoverflow.com/users/657267/user657267\">user657267</a>'s <a href=\"https://stackoverflow.com/a/22952659/1137388\">answer</a>) the motivation for taking the argument as reference to <code>const</code> was to enable passing rvalues (temporaries):</p>\n<pre><code>void f(int) { }\n\nfunction_t make_function() { return f; }\n\ndummy d1(f);\ndummy d2(make_function());\n</code></pre>\n<p>However, this doesn't compile, not because of <code>dummy</code>, but because <code>make_function</code> returns a function which is forbiden by C++11 8.3.5/8</p>\n<blockquote>\n<blockquote>\n<p id=\"so_22952480_23140119_3\">If the type of a parameter includes a type of the form \u201cpointer to array of unknown bound of <code>T</code>\u201d or \u201creference to array of unknown bound of <code>T</code>,\u201d the program is ill-formed.<sup>99</sup> <strong>Functions shall not have a return type of type array or function</strong>, although they may have a return type of type pointer or reference to such things. There shall be no arrays of functions, although there can be arrays of pointers to functions.</p>\n</blockquote>\n</blockquote>\n<p>A natural \"solution\" would be returning a reference:</p>\n<pre><code>function&amp; make_function() { return f; }\n</code></pre>\n<p>or</p>\n<pre><code>function&amp;&amp; make_function() { return f; }\n</code></pre>\n<p>In both cases, the type of the expression <code>make_function()</code> is an lvalue (which defies the purpose of <code>dummy</code> using reference to <code>const</code> to enable passing rvalues) as per C++11 5.2.2/10</p>\n<blockquote>\n<blockquote>\n<p id=\"so_22952480_23140119_5\"><strong>A function call is an lvalue if the result type is an lvalue reference type or an rvalue reference to function type</strong>, an xvalue if the result type is an rvalue reference to object type, and a prvalue otherwise.</p>\n</blockquote>\n</blockquote>\n<p>Actually, value category is not an issue here. With any legal declaration of <code>make_function</code> and any definition of <code>dummy</code> seem above the declarations of <code>d1</code> and <code>d2</code> work fine.</p>\n<p>Nevertheless, the mentioned comment to <a href=\"https://stackoverflow.com/users/657267/user657267\">user657267</a>'s <a href=\"https://stackoverflow.com/a/22952659/1137388\">answer</a> talks about passing a lambda but a reference to function cannot bind to lambda expression because it has a different type:</p>\n<pre><code>dummy d3([](int){}); // Error!\n</code></pre>\n<p><strong>The suggested solution</strong></p>\n<p>Instead of references use pointers:</p>\n<pre><code>using function_t = void(int); // or typedef void (function_t)(int);\n\nclass dummy {\npublic:\n    function_t* member;\n    dummy(function_t* func)\n         : member{func}{}\n\n};\n\nvoid f(int) { }\n\nfunction_t&amp; make_function() { return f; }\n\ndummy d1(f);               // OK\ndummy d2(make_function()); // OK\ndummy d3([](int){});       // OK\n</code></pre>\n<p>Final remarks:</p>\n<ol>\n<li><p>Again, declaring <code>const function_t* member</code> and <code>dummy(const function_t* func)</code> doesn't buy you anything because, as per references, the <code>const</code> qualifiers are ignored.</p></li>\n<li><p>The initialization of <code>d1</code> and <code>d2</code> work because functions are implicitly converted to pointer to functions (see C++ 4.3/1).</p></li>\n<li><p>If a function argument is of function type, the compiler changes its type to a pointer to function. Hence, <code>dummy</code>'s constructor can be declared as <code>dummy(function_t func);</code>.</p></li>\n<li><p>The initialization of <code>d3</code> works because captureless lambdas are implicitly converted to pointer to functions. It wouldn't work for lambdas with captures.</p></li>\n</ol>\n", "LastActivityDate": "2014-04-17T17:54:10.747"}, "22952480": {"CommentCount": "3", "ViewCount": "107", "PostTypeId": "1", "LastEditorUserId": "1137388", "CreationDate": "2014-04-09T03:55:11.707", "LastActivityDate": "2014-04-17T17:55:40.100", "Title": "How to write a constant function reference", "AcceptedAnswerId": "23140119", "LastEditDate": "2014-04-17T17:55:40.100", "Id": "22952480", "Score": "0", "Body": "<p>At the moment I have a class defined similar to this:</p>\n<pre><code>class dummy{\n    public:\n        dummy(void(&amp;func)(int))\n            : member{func}{}\n\n        void(&amp;member)(int);\n};\n</code></pre>\n<p>but I want to have <code>member</code> defined as a <code>const</code> function reference. I'm not sure exactly how to write this or if it is even possible.</p>\n<p>P.S. PLEASE don't recommend me <code>std::function</code> I'm not oblivious to it's existence and have no objection to it, I just want to know whether something like this is doable.</p>\n", "Tags": "<c++><c++11><function-pointers>", "OwnerUserId": "2297448", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_22952480_23140119_5": {"section_id": 5997, "quality": 1.0, "length": 21}, "so_22952480_23140119_2": {"section_id": 3244, "quality": 0.975609756097561, "length": 40}, "so_22952480_23140119_0": {"section_id": 3242, "quality": 0.8518518518518519, "length": 23}, "so_22952480_23140119_3": {"section_id": 3244, "quality": 0.975609756097561, "length": 40}, "so_22952480_23140119_4": {"section_id": 5997, "quality": 1.0, "length": 21}, "so_22952480_23140119_1": {"section_id": 3242, "quality": 0.8518518518518519, "length": 23}}, "n3337": {"so_22952480_23140119_2": {"section_id": 3117, "quality": 0.975609756097561, "length": 40}, "so_22952480_23140119_5": {"section_id": 5765, "quality": 1.0, "length": 21}, "so_22952480_23140119_0": {"section_id": 3115, "quality": 0.8518518518518519, "length": 23}, "so_22952480_23140119_3": {"section_id": 3117, "quality": 0.975609756097561, "length": 40}, "so_22952480_23140119_4": {"section_id": 5765, "quality": 1.0, "length": 21}, "so_22952480_23140119_1": {"section_id": 3115, "quality": 0.8518518518518519, "length": 23}}, "n4659": {"so_22952480_23140119_5": {"section_id": 7498, "quality": 1.0, "length": 21}, "so_22952480_23140119_2": {"section_id": 4002, "quality": 0.7073170731707317, "length": 29}, "so_22952480_23140119_0": {"section_id": 3999, "quality": 0.8518518518518519, "length": 23}, "so_22952480_23140119_3": {"section_id": 4002, "quality": 0.7073170731707317, "length": 29}, "so_22952480_23140119_4": {"section_id": 7498, "quality": 1.0, "length": 21}, "so_22952480_23140119_1": {"section_id": 3999, "quality": 0.8518518518518519, "length": 23}}}});