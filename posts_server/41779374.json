post_cb({"41779932": {"ParentId": "41779374", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>As it turns out, gcc is not correct here. In N4141 (C++14), we have:</p>\n<blockquote>\n<p id=\"so_41779374_41779932_0\">If the\n  new-expression creates an array of objects of class type, the destructor is potentially invoked (12.4).</p>\n</blockquote>\n<p>(5.3.4/19 [expr.new]) and</p>\n<blockquote>\n<p id=\"so_41779374_41779932_1\">A\n  program is ill-formed if a destructor that is potentially invoked is deleted or not accessible from the context\n  of the invocation.</p>\n</blockquote>\n<p>(12.4/11 [class.dtor]). <strong>So both array cases should be rejected.</strong> (Clang does get that right, <a href=\"http://melpon.org/wandbox/permlink/kHR1ru1EV8m495Jb\">live</a>.)</p>\n<p>The reason for that is, as mentioned by others and by my old, incorrect answer, that the construction of elements of class type can potentially fail with an exception. When that happens, the destructor of all fully constructed elements must be invoked, and thus the destructor must be accessible.</p>\n<p>That limitation does not apply when allocating a single element with <code>operator new</code> (without the <code>[]</code>), because there can be no fully constructed instance of the class if the single constructor call fails.</p>\n", "OwnerUserId": "3002139", "LastEditorUserId": "3150802", "LastEditDate": "2017-01-21T14:17:26.333", "Id": "41779932", "Score": "10", "CreationDate": "2017-01-21T13:26:21.510", "LastActivityDate": "2017-01-21T14:17:26.333"}, "41779863": {"ParentId": "41779374", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Rejecting an array-<code>new</code> with a protected destructor is correct, as per C++11, \u00a75.3.4 \u00b617:</p>\n<blockquote>\n<p id=\"so_41779374_41779863_0\">If the new-expression creates an object or an array of objects of class type, access and ambiguity control are done for the allocation function, the deallocation function (12.5), and the constructor (12.1). <strong>If the new expression creates an array of objects of class type, access and ambiguity control are done for the destructor (12.4).</strong></p>\n</blockquote>\n<p>(emphasis added; almost exactly the same wording is used in C++03, \u00a75.3.4 \u00b616; C++14 moves some stuff around, but that doesn't seem to change the core of the issue - see <em>@Baum mit Augen</em>'s answer)</p>\n<p>That comes from the fact that <code>new[]</code> succeeds only if only all the elements have been constructed, and wants to avoid leaking objects in case one of the costructor calls fails; thus, if it manages to construct - say - the first 9 objects but the 10th fails with an exception, it has to destruct the first 9 before propagating the exception.</p>\n<p>Notice that this restriction logically wouldn't be required if the constructor was declared as <code>noexcept</code>, but still the standard doesn't seem to have any exception in this regard.</p>\n<hr>\n<p>So, here gcc is technically wrong in the first case, which, as far as the standard is concerned, should be rejected as well, although I'd argue that \"morally\" gcc does the right thing (as in practice there's no way that the default constructor of <code>A</code> can ever throw).</p>\n</hr>", "OwnerUserId": "214671", "LastEditorUserId": "214671", "LastEditDate": "2017-01-21T14:01:38.370", "Id": "41779863", "Score": "17", "CreationDate": "2017-01-21T13:19:00.583", "LastActivityDate": "2017-01-21T14:01:38.370"}, "41779374": {"CommentCount": "2", "ViewCount": "930", "PostTypeId": "1", "LastEditorUserId": "1023390", "CreationDate": "2017-01-21T12:30:40.447", "LastActivityDate": "2017-01-21T14:17:26.333", "Title": "Dynamic allocation of class array with protected destructor", "AcceptedAnswerId": "41779863", "LastEditDate": "2017-01-21T13:17:18.073", "Id": "41779374", "Score": "34", "Body": "<p>If I have a class defined like</p>\n<pre><code>class A {\nprotected:\n    ~A(){ }\n};\n</code></pre>\n<p>then I can dynamically allocate the individual as well as array of objects like</p>\n<pre><code>A* ptr1 = new A;\nA* ptr2 = new A[10];\n</code></pre>\n<p>However when I define the constructor for this class</p>\n<pre><code>class A {\npublic:\n    A(){}\nprotected:\n    ~A(){ }\n};\n</code></pre>\n<p>then I can create individual objects with</p>\n<pre><code>A* ptr = new A;\n</code></pre>\n<p>but when I try to dynamically allocate the array of object with</p>\n<pre><code>A* ptr = new A[10];\n</code></pre>\n<p>compiler(gcc-5.1 and Visual Studio 2015) starts complaining that A::~A() is inaccessible.</p>\n<p>Can anyone explain about:-</p>\n<p>1- Why is the difference in behavior with constructor being defined and not defined.</p>\n<p>2- When the constructor is defined why I am allowed to create individual object and not array of object.</p>\n", "Tags": "<c++><c++11><visual-c++><language-lawyer>", "OwnerUserId": "4699294", "AnswerCount": "3"}, "41779814": {"ParentId": "41779374", "CommentCount": "0", "Body": "<p>I'm not a language lawyer (very familiar with the standard), but suspect the answer is along the lines of that given earlier by Baum mit Augen (deleted, so only those with sufficient reputation can see it).</p>\n<p>If the construction of subsequent array elements fails and throws an exception, then the already constructed elements will need to be deleted, requiring access to the destructor.</p>\n<p>However, if the constructor is <code>noexcept</code>, this can be ruled out and access to the destructor is not required. The fact that gcc and clang both still complain even in this case, may well be a <strong>compiler bug</strong>. That is, the compiler fails to take into account that the constructor is <code>noexcept</code>. Alternatively, the compilers may be within the standard, in which case, this smells like a <strong>defect in the standard</strong>.</p>\n", "OwnerUserId": "1023390", "PostTypeId": "2", "Id": "41779814", "Score": "3", "CreationDate": "2017-01-21T13:14:32.817", "LastActivityDate": "2017-01-21T13:14:32.817"}, "bq_ids": {"n4140": {"so_41779374_41779863_0": {"section_id": 6100, "quality": 0.7096774193548387, "length": 22}, "so_41779374_41779932_1": {"section_id": 407, "quality": 1.0, "length": 8}, "so_41779374_41779932_0": {"section_id": 6100, "quality": 0.9, "length": 9}}, "n3337": {"so_41779374_41779863_0": {"section_id": 5866, "quality": 0.9032258064516129, "length": 28}, "so_41779374_41779932_0": {"section_id": 5866, "quality": 0.7, "length": 7}}, "n4659": {"so_41779374_41779863_0": {"section_id": 7597, "quality": 0.7096774193548387, "length": 22}, "so_41779374_41779932_1": {"section_id": 425, "quality": 1.0, "length": 8}, "so_41779374_41779932_0": {"section_id": 7597, "quality": 0.9, "length": 9}}}});