post_cb({"13746300": {"Id": "13746300", "PostTypeId": "2", "Body": "<p>It's an interesting question.  I think the intent of the\nstandard was that this should work.  On reading the standard\n(C++03, \u00a71.9/6,7) however:</p>\n<blockquote>\n<p id=\"so_13744760_13746300_0\">The observable behavior of the abstract machine is its sequence\n  of reads and writes to volatile data and calls to library I/O\n  functions.</p>\n<p id=\"so_13744760_13746300_1\">Accessing an object designated by a volatile lvalue, modifying\n  an object, calling a library I/O function, or calling\n  a function that does any of those operations are all side\n  effects, which are changes in the state of the execution\n  environment.  Evaluation of an expression might produce side\n  effects. At certain specified points in the execution sequence\n  called sequence points, all side effects of previous\n  evaluations shall be complete and no side effects of\n  subsequent evaluations shall have taken place.</p>\n</blockquote>\n<p>The difference in wording in the two paragraphs would seem to be\nsignificant: the \"observable behavior\" is the sequence of reads\nand writes volatile <em>data</em>.  In your case, <code>buffer</code> is <em>not</em>\nvolatile data, so the compiler is, presumably, free to optimize\nthe accesses away.  I don't think that this is the intent, but\nthat seems to be what it says.</p>\n<p>In your case, the optimization would be particularly simple,\nsince the conversion to volatile occurs in the function itself.\nThe compiler can easily determine that <code>vptr</code> doesn't point to\ndata that is actually volatile.  If you change the parameter\ntype to <code>void volatile*</code>, then the compiler would have to see\nboth the call site and the function at the same time in order to\nsafely do the optimization. </p>\n<p>And finally, regardless of what the standard says, compilers\nhave their own interpretations of <code>volatile</code>.  In practice,\nmost, if not all compilers, will assume that you are using\n<code>volatile</code> for a reason, and will generate the machine\ninstructions to do the writes.  (In practice, that is all that\nthey will do, which means that the order that the writes become\nvisible outside of the thread the code in which the thread is\nrunning remains undefined.  This isn't a problem for your use,\nbut it is for a lot of other uses.)</p>\n", "LastActivityDate": "2012-12-06T14:58:23.920", "CommentCount": "2", "CreationDate": "2012-12-06T14:58:23.920", "ParentId": "13744760", "Score": "4", "OwnerUserId": "649665"}, "bq_ids": {"n4140": {"so_13744760_13744760_0": {"length": 9, "quality": 0.9, "section_id": 6064}}, "n3337": {"so_13744760_13744760_0": {"length": 9, "quality": 0.9, "section_id": 5832}}, "n4659": {"so_13744760_13744760_0": {"length": 8, "quality": 0.8, "section_id": 7560}}}, "13744760": {"ViewCount": "285", "Body": "<p>This is basically a continuation of <a href=\"https://stackoverflow.com/q/13268657/57428\">this question</a>. So far it looks like that if I have a function like this:</p>\n<pre><code>void SecureZeroMemory( void* ptr, size_t cnt )\n{\n   volatile char *vptr = (volatile char *)ptr;\n   while (cnt) {\n       *vptr = 0;\n       vptr++;\n       cnt--;\n   }\n}\n</code></pre>\n<p>and call it like this:</p>\n<pre><code>{\n    char buffer[size];\n    SecureZeroMemory( buffer, size );\n}\n</code></pre>\n<p>then since <code>buffer</code> is not declared volatile it doesn't matter that a pointer to volatile is used - the data itself is not volatile, so write to the variable do not constitute observable behavior (1.9/6) and the compiler is allowed to optimize them away.</p>\n<p>However recently I've come across a statement that it's only the pointer declaration that matters. Specifically C++03 5.3.1/1 describes indirection (*) like this:</p>\n<blockquote>\n<p id=\"so_13744760_13744760_0\">The unary * operator performs indirection [...] If the type of the expression is \u201cpointer to T,\u201d the type of the result is \u201cT.\u201d</p>\n</blockquote>\n<p>So the claim is that because of using indirection on a <code>volatile char*</code> we get <code>volatile char</code> and writes to those do constitute observable behavior and it no longer matters how the actual data is declared.</p>\n<p>Does the C++03 5.3.1/1 description of indirection really guarantee that overwriting memory using a <code>volatile T*</code> pointer as in the sample above constitute observable behavior and is disallowed to be optimized away?</p>\n", "AcceptedAnswerId": "13746154", "Title": "Does C++ Standard description of indirection operator guarantee memory writes are not optimized away?", "CreationDate": "2012-12-06T13:35:37.113", "Id": "13744760", "CommentCount": "2", "LastEditDate": "2017-05-23T11:55:57.397", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2012-12-06T15:38:44.233", "Score": "13", "OwnerUserId": "57428", "Tags": "<c++><optimization><compiler-construction><compiler-optimization><indirection>", "AnswerCount": "2"}, "13746154": {"Id": "13746154", "PostTypeId": "2", "Body": "<p>I'm pretty sure all that \"new\" quote adds is that <code>*vptr</code> is an lvalue expression with type <code>volatile char</code>.</p>\n<p>The type of the lvalue doesn't affect the type of the object to which that lvalue expression refers, for the same reason that a pointer-to-const that points at a non-const object doesn't somehow make the object const. So the original analysis isn't affected  this quote -- the <em>object</em> still doesn't have volatile-qualified type.</p>\n<p>In normal parlance we'd say that the type of <code>*vptr</code> is <code>volatile char &amp;</code>, but 5/5 says, \"If an expression initially has the type \u201creference to T\u201d the type is adjusted to T prior to any further analysis\". That's the reason why <code>*vptr</code> is said to have type <code>volatile char</code>, not <code>volatile char &amp;</code> -- before analysing any expression you remove the reference from the type, even if it's an lvalue.</p>\n<p>[Edit: my answer used to have some text about cv-qualifications being insignificant for non-object values of integer type. It was true (lvalue-to-rvalue conversions of non-class types discard cv-qualifiers, 4.1/1) but irrelevant (I mistakenly thought that because the text you quoted mentioned a non-reference type it was talking about the type after this conversion)]</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2012-12-06T15:38:44.233", "Score": "4", "CreationDate": "2012-12-06T14:51:04.963", "ParentId": "13744760", "CommentCount": "11", "OwnerUserId": "13005", "LastEditDate": "2012-12-06T15:38:44.233"}});