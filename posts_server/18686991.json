post_cb({"18687162": {"ParentId": "18686991", "PostTypeId": "2", "CommentCount": "11", "CreationDate": "2013-09-08T18:26:45.173", "Score": "8", "LastEditorUserId": "87234", "LastEditDate": "2013-09-08T18:32:33.087", "Id": "18687162", "OwnerUserId": "87234", "Body": "<p>In the general case, this is undefined behavior, unfortunately. At \u00a78.5.4/5, emphasis mine:</p>\n<blockquote>\n<p id=\"so_18686991_18687162_0\">An object of type <code>std::initializer_list&lt;E&gt;</code> is constructed from an initializer list <strong>as if the implementation allocated a temporary array of <code>N</code> elements of type <code>const E</code></strong>, where <code>N</code> is the number of elements in the initializer list. Each element of that array is copy-initialized with the corresponding element of the initializer list,\n  and the <code>std::initializer_list&lt;E&gt;</code> object is constructed to refer to that array.</p>\n</blockquote>\n<p>Where you see a <code>std::initializer_list&lt;E&gt;</code>, you can act as if it's a <code>const E[N]</code>.</p>\n<p>So when you <code>const_cast</code> away the <code>const</code>, you're looking at a mutable reference to a <code>const</code> object. Any modification to a <code>const</code> object is undefined behavior.</p>\n<p>When you move that <code>std::string</code>, you're modifying a <code>const</code> object. Unfortunately , one of the behaviors of undefined behavior is seemingly correct behavior. But this is technically undefined.</p>\n<p>Note that when you <code>std::move(int)</code> into another, <em>that</em> is well-defined because <code>int</code>\n's can only be copied, so the move does nothing and no <code>const</code> objects are modified. But in general, it's undefined.</p>\n", "LastActivityDate": "2013-09-08T18:32:33.087"}, "18691694": {"ParentId": "18686991", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2013-09-09T04:56:10.693", "Score": "1", "LastEditorUserId": "2760292", "LastEditDate": "2013-09-09T09:49:49.093", "Id": "18691694", "OwnerUserId": "2760292", "Body": "<p>You can reduce the specializations by one. This \"universal reference\" specialization should also cover the lvalue reference, in which case <code>std::move</code> will do nothing.</p>\n<pre><code>template &lt;typename Output_t, typename First_t&gt;\ninline Output_t&amp; Compact(Output_t&amp; aOutput, First_t&amp;&amp; aFirst){\n    aOutput.emplace_back(std::forward&lt;First_t&gt;(aFirst));\n    return aOutput;\n}\n</code></pre>\n<p>Source: Scott Meyers talk at GoingNative2013; finely detailed in <a href=\"http://accu.org/var/uploads/journals/Overload111.pdf\" rel=\"nofollow\">this accu article</a></p>\n", "LastActivityDate": "2013-09-09T09:49:49.093"}, "18686991": {"CommentCount": "10", "CreationDate": "2013-09-08T18:08:50.977", "PostTypeId": "1", "AcceptedAnswerId": "18687162", "LastEditorUserId": "-1", "LastActivityDate": "2013-09-09T12:10:48.530", "LastEditDate": "2017-05-23T12:15:20.423", "ViewCount": "511", "FavoriteCount": "3", "Title": "Any risk to moving const_cast elements out of a std::initializer_list?", "Id": "18686991", "Score": "12", "Body": "<p><strong>This question builds on this <a href=\"https://stackoverflow.com/questions/8193102/initializer-list-and-move-semantics\">@FredOverflow's question</a>.</strong></p>\n<blockquote>\n<p id=\"so_18686991_18686991_0\"><strong>CLARIFICATION</strong>: <code>initializer_list</code> approach is required as the <a href=\"http://connect.microsoft.com/VisualStudio/feedback/details/773505\" rel=\"nofollow noreferrer\"><em>VC++2012 has a bug</em></a> the prevents forwarded expansion of namespaced arguments. <code>_MSC_VER &lt;= 1700</code> has the bug.</p>\n</blockquote>\n<p>I've written a variadic template function that collapses any number of arguments in a typed container. I use the type's constructor to convert the variadic arguments into consumable values. E.g. <code>_variant_t</code> :)</p>\n<p>I need this for my <code>MySql</code> C++ library when pushing arguments to prepared statements in one strike, while my <code>MySqlVariant</code> converts the input data to <code>MYSQL_BIND</code>s. As I may work with <code>BLOB</code>s, I'd like to avoid copy-construct as much as possible when I can <code>move&amp;&amp;</code> the large containers around.</p>\n<p>I've done a simple test and noticed that the <code>initialize_list</code> does <code>copy-construct</code> for the stored elements and destroys them when it goes out of scope. Perfect... Then I tried to move the data out of the <code>initializer_list</code> and, to my surprise, it used <code>lvalues</code> not <code>rvalues</code> as I expected with <code>std::move</code>.</p>\n<blockquote>\n<p id=\"so_18686991_18686991_1\">Funny as this happens just after <a href=\"http://channel9.msdn.com/Events/GoingNative/2013\" rel=\"nofollow noreferrer\"><strong>Going Native 2013</strong></a> clearly warned me that <strong>move does not move, forward does not forward</strong>... <strong>be like water, my friend</strong> - to stay on the deep end of thinking.</p>\n</blockquote>\n<p><strong>But that did not stop me :)</strong> I decided to <code>const_cast</code> the <code>initializer_list</code> values and still move them out. An eviction order needs to be enforced. And this is <strong>my implementation</strong>:</p>\n<pre><code>template &lt;typename Output_t, typename ...Input_t&gt;\ninline Output_t&amp; Compact(Output_t&amp; aOutput, Input_t&amp;&amp; ...aInput){\n    // should I do this? makes sense...\n    if(!sizeof...(aInput)){\n        return aOutput;\n    }\n\n    // I like typedefs as they shorten the code :)\n    typedef Output_t::value_type Type_t;\n\n    // can be either lvalues or rvalues in the initializer_list when it's populated.\n    std::initializer_list&lt;Type_t&gt; vInput = { std::forward&lt;Input_t&gt;(aInput)... };\n\n    // now move the initializer_list into the vector.\n    aOutput.reserve(aOutput.size() + vInput.size());\n    for(auto vIter(vInput.begin()), vEnd(vInput.end()); vIter != vEnd; ++vIter){\n        // move (don't copy) out the lvalue or rvalue out of the initializer_list.\n        // aOutput.emplace_back(std::move(const_cast&lt;Type_t&amp;&gt;(*vIter))); // &lt;- BAD!\n        // the answer points out that the above is undefined so, use the below\n        aOutput.emplace_back(*vIter); // &lt;- THIS is STANDARD LEGAL (copy ctor)!\n    }\n\n    // done! :)\n    return aOutput;\n}\n</code></pre>\n<p><strong>Using it</strong> is easy:</p>\n<pre><code>// You need to pre-declare the container as you could use a vector or a list...\n// as long as .emplace_back is on duty!\nstd::vector&lt;MySqlVariant&gt; vParams;\nCompact(vParams, 1, 1.5, 1.6F, \"string\", L\"wstring\",\n    std::move(aBlob), aSystemTime); // MySql params :)\n</code></pre>\n<p><strong>I've also uploaded a full test</strong> <a href=\"http://ideone.com/kTn2BC\" rel=\"nofollow noreferrer\"><strong>on IDEone ^</strong></a> that shows as the memory of a <code>std::string</code> moves properly with this function. <em>(I would paste it all here but it's slightly long...)</em></p>\n<p>As long as the <code>_variant_t</code> <em>(or whatever final wrapping object)</em> has the right constructors, it's great. And if the data can be moved out, it's even better. And it pretty much works as I tested it and things <code>std::move</code> in the right direction :)</p>\n<p><strong>My questions are simple:</strong></p>\n<ul>\n<li><strong>Am I doing this right standard-wise?</strong></li>\n<li><strong>Is the fact that it's working right intended or just a side effect?</strong></li>\n<li><strong>If <code>std::move</code> does not work by default on <code>initializer_list</code>, is what I'm doing here: <em>illegal, immoral, hacky... or just plain wrong</em>?</strong></li>\n</ul>\n<p><strong><em>PS</em></strong>: I'm a self-taught <code>Windows Native C++</code> developer, ignorant of the standards.<br>\n^ my excuse if I'm doing really non-standard things here.</br></p>\n<p><strong>UPDATE</strong></p>\n<p>Thanks everyone, I have both the answer and the solution <em>(a short and long one)</em> now.</p>\n<blockquote>\n<p id=\"so_18686991_18686991_2\"><strong>And I love the C++11 side of SO.</strong> <em>Many knowledgeable people here...</em></p>\n</blockquote>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1451110", "AnswerCount": "3"}, "18687534": {"ParentId": "18686991", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2013-09-08T19:06:38.097", "Score": "1", "LastEditorUserId": "1451110", "LastEditDate": "2013-09-09T12:10:48.530", "Id": "18687534", "OwnerUserId": "1451110", "Body": "<p><strong>Found an alternative solution, for anyone sharing my pain:</strong></p>\n<pre><code>#if _MCS_VER &lt;= 1700\n// Use the code in the OP!\n// VS 2012- stuff comes here.\n#else\n// VS 2013+ stuff comes here.\ntemplate &lt;typename Output_t&gt;\ninline Output_t&amp; Compact(Output_t&amp; aOutput){\n    return aOutput;\n}\n\ntemplate &lt;typename Output_t, typename First_t&gt;\ninline Output_t&amp; Compact(Output_t&amp; aOutput, const First_t&amp; aFirst){\n    aOutput.emplace_back(aFirst);\n    return aOutput;\n}\n\ntemplate &lt;typename Output_t, typename First_t&gt;\ninline Output_t&amp; Compact(Output_t&amp; aOutput, First_t&amp;&amp; aFirst){\n    aOutput.emplace_back(std::move(aFirst));\n    return aOutput;\n}\n\ntemplate &lt;typename Output_t, typename First_t, typename ...Next_t&gt;\ninline Output_t&amp; Compact(Output_t&amp; aOutput, const First_t&amp; aFirst, Next_t&amp;&amp; ...aNext){\n    aOutput.emplace_back(aFirst);\n    return Compact(aOutput, std::forward&lt;Next_t&gt;(aNext)...);\n}\n\ntemplate &lt;typename Output_t, typename First_t, typename ...Next_t&gt;\ninline Output_t&amp; Compact(Output_t&amp; aOutput, First_t&amp;&amp; aFirst, Next_t&amp;&amp; ...aNext){\n    aOutput.emplace_back(std::move(aFirst));\n    return Compact(aOutput, std::forward&lt;Next_t&gt;(aNext)...);\n}\n#endif // _MCS_VER &lt;= 1700\n</code></pre>\n<p><strong>PS</strong>: <strong>VC++2012 CTPnov2012 has a BUG that prevents this from working on <a href=\"http://connect.microsoft.com/VisualStudio/feedback/details/773505\" rel=\"nofollow\">namespaced classes</a>.</strong> So, the initial solution without the <code>const_cast</code>has to do. <em>All my code is namespaced.</em> VC2013 has this fixed in theory... so will switch the code when I upgrade.</p>\n", "LastActivityDate": "2013-09-09T12:10:48.530"}, "bq_ids": {"n4140": {"so_18686991_18687162_0": {"section_id": 3327, "quality": 1.0, "length": 31}}, "n3337": {"so_18686991_18687162_0": {"section_id": 3197, "quality": 0.9354838709677419, "length": 29}}, "n4659": {"so_18686991_18687162_0": {"section_id": 4093, "quality": 0.8709677419354839, "length": 27}}}});