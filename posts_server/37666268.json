post_cb({"37666268": {"CommentCount": "2", "ViewCount": "158", "CreationDate": "2016-06-06T20:24:47.850", "LastActivityDate": "2016-06-06T21:53:01.303", "Title": "GCC: Function wrapper template troubles", "PostTypeId": "1", "Id": "37666268", "Score": "4", "Body": "<p>I am on <code>GCC 5.3</code> trying to get some function wrapper code to work which works fine on <code>clang</code>. Here is a boiled down example:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt;class Sig, Sig F&gt;\nstruct FunctionWrapper;\n\n\ntemplate&lt;class Ret, class... Args, Ret (*Func)(Args...)&gt;\nstruct FunctionWrapper&lt;Ret(Args...), Func&gt;\n{\n};\n\nstatic int testFunc(int _a, int _b)\n{\n    return _a + _b;\n}\n\n\nint main() {\n    FunctionWrapper&lt;int(int, int), testFunc&gt; wrapper;\n    return 0;\n}\n</code></pre>\n<p>The error I get on gcc is the following:</p>\n<blockquote>\n<p id=\"so_37666268_37666268_0\">prog.cpp:9:46: error: 'Ret(Args ...)' is not a valid type for a template non-type parameter\n       struct FunctionWrapper\n                                                ^\n  prog.cpp: In function 'int main()':\n  prog.cpp:20:45: error: 'int(int, int)' is not a valid type for a template non-type parameter\n        FunctionWrapper wrapper;</p>\n</blockquote>\n<p>Any ideas about how to make this work on both, <code>clang</code> and <code>gcc</code>?</p>\n<p>Thanks!</p>\n", "Tags": "<c++><templates><c++11><gcc><clang>", "OwnerUserId": "300713", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_37666268_37666686_0": {"section_id": 61, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_37666268_37666686_0": {"section_id": 56, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_37666268_37666686_0": {"section_id": 63, "quality": 1.0, "length": 9}}}, "37666686": {"ParentId": "37666268", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>I think this is a gcc bug. According to [temp.param]:</p>\n<blockquote>\n<p id=\"so_37666268_37666686_0\">A non-type template-parameter of type \u201carray of <code>T</code>\u201d or of function type <code>T</code> is adjusted to be of type \u201cpointer to <code>T</code>\u201d.</p>\n</blockquote>\n<p>Having <code>Ret(Args...)</code> as a template non-type parameter is equivalent to having <code>Ret(*)(Args...)</code> as a template non-type parameter. </p>\n<p>Note that gcc does [correctly] compile the following example, which is basically the same idea as your original version:</p>\n<pre><code>static int testFunc(int _a, int _b)\n{\n    return _a + _b;\n}\n\ntemplate &lt;int F(int, int)&gt;\nstruct Foo { };\n\n\nint main() {\n    Foo&lt;testFunc&gt; wrapper;\n    return 0;\n}\n</code></pre>\n<hr/>\n<p>As a workaround, simply forcing the non-type argument to be a pointer is allowed by both compilers:</p>\n<pre><code>template&lt;class Sig, Sig* F&gt;\nstruct FunctionWrapper;\n\n\ntemplate&lt;class Ret, class... Args, Ret (*Func)(Args...)&gt;\nstruct FunctionWrapper&lt;Ret(Args...), Func&gt;\n{ };\n</code></pre>\n<p>but I don't believe that this should have been necessary.</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2016-06-06T21:08:44.150", "Id": "37666686", "Score": "6", "CreationDate": "2016-06-06T20:50:32.503", "LastActivityDate": "2016-06-06T21:08:44.150"}});