post_cb({"17848983": {"ViewCount": "859", "Body": "<p>From \u00a7 8.3.5.11 of ISO/IEC 14882:2011(E):</p>\n<blockquote>\n<p id=\"so_17848983_17848983_0\">A typedef of function type may be used to declare a function but shall not be used to de\ufb01ne a function</p>\n</blockquote>\n<p>The standard goes on to give this example:</p>\n<pre><code>typedef void F();\nF fv; // OK: equivalent to void fv();\nF fv { } // ill-formed\nvoid fv() { } // OK: de\ufb01nition of fv\n</code></pre>\n<p>What motivates this rule? It seems to limit the potential expressive usefulness of function typedefs.</p>\n", "AcceptedAnswerId": "17849424", "Title": "Why can't a typedef of a function be used to define a function?", "CreationDate": "2013-07-25T04:25:58.390", "Id": "17848983", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-10-23T08:07:43.500", "Score": "10", "OwnerUserId": "636917", "Tags": "<c++><typedef><function-declaration>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_17848983_17848983_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 3246}}, "n3337": {"so_17848983_17848983_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 3119}}, "n4659": {"so_17848983_17848983_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 4004}}}, "17849049": {"Id": "17849049", "PostTypeId": "2", "Body": "<p>The rule is as you quoted - <code>typedef of function type shall not be used to define a function</code>. In the 3rd line of the example, you are trying to define a function with function type <code>F</code>. This is not allowed by the standard.</p>\n<hr>\n<p><em><strong>EDIT</strong></em></p></hr><br>\nAs you pointed out, I try to explain more on it.</br>\n<p>For the 3rd line, if it were legal, then you could replace F with the typedef definition:<br>\n<code>void fv { }()</code>. This is not a legal definition or declaration in C++.  </br></p>\n<p>I think the key point is that <code>typedef</code> is just creating an alias for simplification, and you can replace your typedef type like replacement of <code>#define</code> during compilation.</p>\n", "LastEditorUserId": "2336707", "LastActivityDate": "2013-07-25T04:40:12.923", "Score": "-4", "CreationDate": "2013-07-25T04:33:14.987", "ParentId": "17848983", "CommentCount": "9", "OwnerUserId": "2336707", "LastEditDate": "2013-07-25T04:40:12.923"}, "17849424": {"Id": "17849424", "PostTypeId": "2", "Body": "<p>Though this question is about C++, but since C++ inherits <code>typedef</code> and function pointer from C, so an explanation of the same question in C can be used in here. There's a formal explanation for C.</p>\n<blockquote>\n<h3><a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf\" rel=\"nofollow\">Rationale for International Standard - Programming Languages C</a> \u00a76.9.1 <em>Function definitions</em></h3>\n<p id=\"so_17848983_17849424_0\">An argument list must be explicitly present in the declarator; it cannot be inherited from a <code>typedef</code> (see \u00a76.7.5.3). That is to say, given the definition:</p>\n<pre><code>typedef int p(int q, int r);\n</code></pre>\n<p id=\"so_17848983_17849424_1\">the following fragment is invalid:</p>\n<pre><code>p funk // weird\n{ return q + r ; }\n</code></pre>\n<p id=\"so_17848983_17849424_2\">Some current implementations rewrite the type of, for instance, a <code>char</code> parameter as if it were declared <code>int</code>, since the argument is known to be passed as an <code>int</code> in the absence of a prototype. The Standard requires, however, that the received argument be converted as if by assignment upon function entry. Type rewriting is thus no longer permissible.</p>\n</blockquote>\n", "LastEditorUserId": "1009479", "LastActivityDate": "2013-10-23T08:07:43.500", "Score": "12", "CreationDate": "2013-07-25T05:05:09.543", "ParentId": "17848983", "CommentCount": "3", "OwnerUserId": "1009479", "LastEditDate": "2013-10-23T08:07:43.500"}, "17852671": {"Id": "17852671", "PostTypeId": "2", "Body": "<p>Let me put a few words. Consider a statement:</p>\n<pre><code>typedef void F(int p1, char* p2);\n</code></pre>\n<p>This statement assigns name <code>F</code> to a function signature <code>void (int, char*);</code> This is definition of an alias to the function signature. After that the statement:</p>\n<pre><code>F fv;\n</code></pre>\n<p>tells that there is a function <code>fv</code>. It has the signature that was mentioned above and it has its body somewhere. Look at the C/C++ syntax of the function definition:</p>\n<pre><code>retType  funcName(params) { body }\n</code></pre>\n<p>There are actually 2 names used <code>retType</code> and <code>funcName</code>. None of them are the same to the name <code>F</code> from the initial typedef. The name <code>F</code> has meaning of both names. If language would allow something like:</p>\n<pre><code>F { body }\n</code></pre>\n<p>this will associate body with the function type. But this leads a problem:</p>\n<p>The meaning of <code>F</code> would be not clear. Is it an \"alias to the function signature\" or is it a \"name of the entry point into a code\"?</p>\n<p>Plus the syntax of the last example would be weird to millions of C/C++ programmers.</p>\n", "LastActivityDate": "2013-07-25T08:20:27.277", "CommentCount": "0", "CreationDate": "2013-07-25T08:20:27.277", "ParentId": "17848983", "Score": "1", "OwnerUserId": "1459996"}, "17849188": {"Id": "17849188", "PostTypeId": "2", "Body": "<p>It's probably mostly historical reasons. <code>typedef</code> was a relatively late addition to C, and was tacked onto the existing language (and caused a few problems for the parsing phase of compilers).</p>\n<p>Also, a function <em>definition</em> has to define the names of the parameters, if any. A function <em>type</em> includes the function's return type and parameter types, but not its parameter names. For example, these:</p>\n<pre><code>void (int)\nvoid (int x)\nvoid (int y)\n</code></pre>\n<p>are three ways of writing the same function type. If you had:</p>\n<pre><code>typedef void func_t(int);\n</code></pre>\n<p>then this hypothetical definition:</p>\n<pre><code>func_t some_func { }\n</code></pre>\n<p>wouldn't define a name for its <code>int</code> parameter. I'm not sure how that could have been resolved in a reasonable manner. It would be possible, I suppose, but it was never done.</p>\n<p>But the bottom line is probably just that Dennis Ritchie either didn't think it was worth the effort to define how a <code>typedef</code> could be used in a function definition, or he simply didn't think of it.</p>\n", "LastActivityDate": "2013-07-25T04:45:46.593", "CommentCount": "3", "CreationDate": "2013-07-25T04:45:46.593", "ParentId": "17848983", "Score": "7", "OwnerUserId": "827263"}});