post_cb({"21392743": {"Id": "21392743", "PostTypeId": "2", "Body": "<p>If I'm understanding this right, you want to be able to access a variable that is captured within a lambda. But according to the top answer on <a href=\"https://stackoverflow.com/a/19976680/1508519\">Get captured variables from lambda?</a>, it's not possible.</p>\n<blockquote>\n<p id=\"so_21390608_21392743_0\">It's not possible <em>by design</em></p>\n<blockquote>\n<p id=\"so_21390608_21392743_5\">5.1.2 [expr.prim.lambda] </p>\n<p id=\"so_21390608_21392743_6\">15 [...] For each entity captured by copy, <b>an unnamed non-static data member is declared in the closure type.</b> The declaration order of these members is unspecified. [...] </p>\n<p id=\"so_21390608_21392743_7\">16 [...] It is unspecified whether additional unnamed non-static data members are\n    declared in the closure type for entities captured by reference.</p>\n</blockquote>\n<p id=\"so_21390608_21392743_4\"><b>Captured variables are unnamed (or at least have names that are\n  unspeakable by mortals)</b> and their declaration order is deliberately\n  unspecified. By-reference captures <em>may not even exist</em> in the closure\n  type.</p>\n</blockquote>\n<p>Bold emphasis mine.</p>\n", "OwnerDisplayName": "user1508519", "LastEditorUserId": "-1", "LastActivityDate": "2014-01-27T22:09:31.233", "Score": "5", "CreationDate": "2014-01-27T22:09:31.233", "ParentId": "21390608", "CommentCount": "2", "LastEditDate": "2017-05-23T12:09:30.367"}, "bq_ids": {"n4140": {"so_21390608_21588021_1": {"length": 14, "quality": 1.0, "section_id": 5970}, "so_21390608_21392743_3": {"length": 13, "quality": 1.0, "section_id": 5975}, "so_21390608_21392743_6": {"length": 15, "quality": 0.8823529411764706, "section_id": 5974}, "so_21390608_21392743_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 5974}, "so_21390608_21392743_7": {"length": 13, "quality": 1.0, "section_id": 5975}}, "n3337": {"so_21390608_21392743_3": {"length": 13, "quality": 1.0, "section_id": 5743}, "so_21390608_21392743_6": {"length": 15, "quality": 0.8823529411764706, "section_id": 5742}, "so_21390608_21392743_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 5742}, "so_21390608_21392743_7": {"length": 13, "quality": 1.0, "section_id": 5743}}, "n4659": {"so_21390608_21392743_6": {"length": 15, "quality": 0.8823529411764706, "section_id": 7473}, "so_21390608_21392743_3": {"length": 13, "quality": 1.0, "section_id": 7475}, "so_21390608_21392743_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 7473}, "so_21390608_21392743_7": {"length": 13, "quality": 1.0, "section_id": 7475}, "so_21390608_21588021_1": {"length": 14, "quality": 1.0, "section_id": 7469}}}, "21390608": {"ViewCount": "989", "Body": "<p>AFAIK, C++11/14 does not allow in-place definition of a new return type while defining a lambda. However, it seems a C++14 lambda capture expression essentially creates an anonymous type with one or more \"members\" and an operator (). So, why is that the compiler does not allow access to the captured members from <strong>outside</strong> the lambda. My feeble mind cannot handle the complexities of C++ but does it sound like a reasonable language extension to you? Here is an example.</p>\n<pre><code>vector&lt;string&gt; words = { \"Stack\", \"Overflow\" };\nauto l = [w = words](){}; // almost like a C# anonymous type\ncout &lt;&lt; l.w[0]; // does not work. \n</code></pre>\n", "Title": "Access C++14 lambda captures like struct members", "CreationDate": "2014-01-27T20:08:29.047", "LastActivityDate": "2014-02-05T20:39:49.420", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-01-27T20:21:10.820", "LastEditorUserId": "25014", "Id": "21390608", "Score": "10", "OwnerUserId": "25014", "Tags": "<c++><lambda><capture><c++14>", "AnswerCount": "2"}, "21588021": {"Id": "21588021", "PostTypeId": "2", "Body": "<p><strong>The status quo</strong></p>\n<p>This was discussed when lambda <em>init-captures</em> were added to the language. The current working draft of the standard (N3797) says (in <strong>[expr.prim.lambda]p11</strong>):</p>\n<blockquote>\n<p id=\"so_21390608_21588021_0\">For every <em>init-capture</em> a non-static data member named by the <em>identifier</em> of the <em>init-capture</em> is declared in the closure type.</p>\n</blockquote>\n<p>The standard does <em>not</em> specify the access of that member, making it unclear whether this is valid:</p>\n<pre><code>auto x = [n(0)] {};\nint k = x.n; // ok?\n</code></pre>\n<p>This and some other specification problems with <em>init-captures</em> led to national body comment GB3 on the standard draft, which is handled by the C++ core working group as <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1760\">core issue 1760</a>. In discussion of that issue, the core working group decided that the lambda's <em>init-captures</em> should <em>not</em> be accessible members of the closure object.</p>\n<p>The resolution for issue 1760 (which is approved by CWG but not yet by the full committee) changes the specification to instead say:</p>\n<blockquote>\n<p id=\"so_21390608_21588021_1\">An <em>init-capture</em> behaves as if it declares and explicitly captures a variable of the form <code>\u201cauto init-capture ;\u201d</code> whose declarative region is the <em>lambda-expression</em>'s <em>compound-statement</em> [...]</p>\n</blockquote>\n<p>This new wording makes it clear that the <em>init-capture</em> does not add a nameable member of the closure object, and it instead acts like any other lambda capture.</p>\n<p><strong>As a language extension</strong></p>\n<p>Making <em>init-captures</em> be accessible members of the closure type is certainly possible (and my initial implementation of <em>init-captures</em> in clang did that, before I implemented the resolution of issue 1760). It also seems like a useful feature, but it would also allow violation of the encapsulation of <em>lambda-expressions</em> in the common case where the <em>init-captures</em> should not be visible.</p>\n", "LastActivityDate": "2014-02-05T20:39:49.420", "CommentCount": "0", "CreationDate": "2014-02-05T20:39:49.420", "ParentId": "21390608", "Score": "17", "OwnerUserId": "1041090"}});