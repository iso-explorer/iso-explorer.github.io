post_cb({"33655055": {"CommentCount": "4", "ViewCount": "284", "CreationDate": "2015-11-11T16:24:47.753", "LastActivityDate": "2015-11-11T16:48:22.833", "Title": "How STL ordered containers know their end?", "PostTypeId": "1", "Id": "33655055", "Score": "15", "Body": "<p>I know that the standard doesn't dictate the way that STL containers must be implemented, but rather it mandates a set of requirements for each one of them.</p>\n<p>However, it is widely known that STL ordered containers are usually implemented as <a href=\"https://en.wikipedia.org/wiki/Red%E2%80%93black_tree\" rel=\"noreferrer\">red\u2013black trees</a>.</p>\n<p>You can iterate through the elements of a <code>std::set</code> or a <code>std::map</code> using their respective iterators, or since C++11 using ranged loops.</p>\n<p>What puzzles me however, is how an ordered container in STL \"knows\"\nits \"end\". Or put it another way, since they're implemented as trees,\nhow the end of the container is implemented or could it be\nimplemented?</p>\n<p>I know that the standard dictates <em>\u00a723.2.1/c General container requirements</em> (<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_33655055_33655055_0\">begin() returns an iterator referring to the first element in the\n  container. <strong>end() returns an iterator which is the past-the-end value\n  for the container.</strong> If the container is empty, then begin() == end();</p>\n</blockquote>\n<p>OK, for contiguous containers this is easy, but how this \"past-the-end\" could be materialized for trees?</p>\n", "Tags": "<c++><c++11><stl><stdmap><stdset>", "OwnerUserId": "2352671", "AnswerCount": "2"}, "33655120": {"ParentId": "33655055", "CommentCount": "3", "Body": "<p>All of the \"list-like\" containers like this need to have some kind of sentinel node for the end, because the user can get <code>end()</code>, insert something into the container, decrement the iterator, and the decremented <code>end()</code> must point to that inserted element. My understanding is that some implementations will dynamically allocate for this, and some will put the dynamic sentinel node inside the container itself.</p>\n", "OwnerUserId": "82320", "PostTypeId": "2", "Id": "33655120", "Score": "3", "CreationDate": "2015-11-11T16:28:05.663", "LastActivityDate": "2015-11-11T16:28:05.663"}, "bq_ids": {"n4140": {"so_33655055_33655055_0": {"section_id": 707, "quality": 1.0, "length": 18}}, "n3337": {"so_33655055_33655055_0": {"section_id": 697, "quality": 1.0, "length": 18}}, "n4659": {"so_33655055_33655055_0": {"section_id": 736, "quality": 1.0, "length": 18}}}, "33655525": {"ParentId": "33655055", "CommentCount": "0", "Body": "<p>I have just inspected the implementation of <code>map</code> container in Visual Studio 2013 STL, and here is how <code>end</code> is implemented. When <code>map</code> is constructed, a head element of the RB tree is allocated and this element is declared to be the end of the container. </p>\n<p>When you traverse the container via a valid iterator, <code>operator++</code> and <code>operator--</code> simply skip the head element. And when you reach the last element of the tree and increment an iterator, it climbs upwards (looking for a right subtree) and eventually reaches the head of the tree, which is <code>end</code>.</p>\n", "OwnerUserId": "5546661", "PostTypeId": "2", "Id": "33655525", "Score": "9", "CreationDate": "2015-11-11T16:47:38.480", "LastActivityDate": "2015-11-11T16:47:38.480"}});