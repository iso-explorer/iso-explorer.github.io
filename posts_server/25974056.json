post_cb({"25974400": {"Id": "25974400", "PostTypeId": "2", "Body": "<p>Your <code>StaticCall</code> has undefined behavior (\u00a79.3.1 [class.mfct.non-static]/p2):</p>\n<blockquote>\n<p id=\"so_25974056_25974400_0\">If a non-static member function of a class <code>X</code> is called for an object\n  that is not of type <code>X</code>, or of a type derived from <code>X</code>, the behavior\n  is undefined.</p>\n</blockquote>\n<p><code>data</code> is pure storage; it's neither an object of type <code>ClassT</code> nor an object of a type derived from <code>ClassT</code>. It doesn't matter whether your non-static member function actually uses a member of that class. You are in UB land as soon as you make the call.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-09-22T20:46:39.243", "Score": "3", "CreationDate": "2014-09-22T12:40:45.543", "ParentId": "25974056", "CommentCount": "5", "OwnerUserId": "2756719", "LastEditDate": "2014-09-22T20:46:39.243"}, "bq_ids": {"n4140": {"so_25974056_25974400_0": {"length": 11, "quality": 1.0, "section_id": 5890}}, "n3337": {"so_25974056_25974400_0": {"length": 11, "quality": 1.0, "section_id": 5661}}, "n4659": {"so_25974056_25974400_0": {"length": 11, "quality": 1.0, "section_id": 7373}}}, "25974056": {"ViewCount": "116", "Body": "<p>I have some example code shown below that calls a class member function from a static context without first creating a proper instance of the object to call on.</p>\n<p>I know this code seems strange and I don't want to go into a whole lot of side tracks discussing the reasoning behind where it came from unless it becomes relevant to answering the question. </p>\n<p><strong>My questions are:</strong></p>\n<ol>\n<li>Is the code below \"correctly formed\" according to the C++ spec? </li>\n<li>If it is not correctly formed, then in what circumstances could I\nexpect this code to not work as expected (see sample output for an\nexample of expected outcome)?</li>\n</ol>\n<p>I believe the following are some limitations with this:</p>\n<ul>\n<li>Referencing \"members\" from a virtual base may cause undefined behavior </li>\n<li>Actually making use of the \"members\" when called statically may cause\nundefined behavior</li>\n</ul>\n<p>The key thing to look at with regards to this question is the function: StaticCall(). Note that when calling using StaticCall(), I expect that none of the members will actually be used. It is primarily to enumerate type information about the available members without implementing a nearly duplicate second function.</p>\n<p>Sample code:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nclass Serializer;\n\ntemplate &lt;typename ClassT&gt; void StaticCall(Serializer&amp; s)\n{\n    // First create aligned storage for a \"fake\" this pointer for the member function call\n    //\n    // This allows us to de-reference obj and access addresses of members so long as we\n    // don't actually try and use the members as they are pointing to uninitialized memory\n    typename std::aligned_storage&lt;sizeof(ClassT), __alignof(ClassT)&gt;::type data;\n    ClassT* fake_obj = static_cast&lt;ClassT*&gt;(static_cast&lt;void*&gt;(&amp;data));\n    fake_obj-&gt;ClassT::Serialize(s);\n}\n\ntemplate &lt;typename ClassT&gt; void VirtualCall(ClassT&amp; obj, Serializer&amp; s)\n{\n    obj.Serialize(s);\n}\n\ntemplate &lt;typename ClassT&gt; void MemberCall(ClassT&amp; obj, Serializer&amp; s)\n{\n    obj.ClassT::Serialize(s);\n}\n\nclass Serializer\n{\npublic:\n    enum Mode\n    {\n        MODE_STRUCTURE\n        , MODE_CONTENT\n    } mode;\n\n    template &lt;typename TypeT&gt; void DisplayStructure()\n    {\n        mode = MODE_STRUCTURE;\n        StaticCall&lt;TypeT&gt;(*this);\n    }\n\n    template &lt;typename TypeT&gt; void DisplayContentVirtual(TypeT&amp; obj)\n    {\n        mode = MODE_CONTENT;\n        VirtualCall(obj, *this);\n    }\n\n    template &lt;typename ThisT&gt; void Type(ThisT* obj, const char* obj_name)\n    {\n        std::cerr &lt;&lt; \"Type: \" &lt;&lt; obj_name &lt;&lt; std::endl;\n    }\n\n    template &lt;typename ParentT, typename ThisT&gt; void TypeWithBase(ThisT* obj, const char* obj_name)\n    {\n        std::cerr &lt;&lt; \"Parent \";\n        if (mode == MODE_STRUCTURE)\n            StaticCall&lt;ParentT&gt;(*this);\n\n        else if (mode == MODE_CONTENT)\n            MemberCall(static_cast&lt;ParentT&amp;&gt;(*obj), *this);\n\n        std::cerr &lt;&lt; \"Type: \" &lt;&lt; obj_name &lt;&lt; std::endl;\n    }\n\n    template &lt;typename MemberT&gt; void Member(MemberT&amp; member, const char* member_name)\n    {\n        std::cerr &lt;&lt; \"Member: \" &lt;&lt; member_name;\n        if (mode == MODE_CONTENT)\n            std::cerr &lt;&lt; \" : \" &lt;&lt; member;\n\n        std::cerr &lt;&lt; std::endl;\n    }\n};\n\n// Example usage\nclass Parent\n{\npublic:\n    Parent(int i) : pmem_int(i), pmem_str(\"Hello\") {}\n    virtual void Serialize(Serializer&amp; s)\n    {\n        s.Type(this, \"Parent\");\n        s.Member(pmem_int, \"pmem_int\");\n        s.Member(pmem_str, \"pmem_str\");\n    }\n\n    virtual void Thing() = 0;\n\n    int pmem_int;\n    std::string pmem_str;\n};\n\nclass Child : public Parent\n{\npublic:\n    float cmem_float;\n    Child() : Parent(1234), cmem_float(334.0f) {}\n\n    virtual void Thing() {}\n\n    virtual void Serialize(Serializer&amp; s)\n    {\n        s.TypeWithBase&lt;Parent&gt;(this, \"Child\");\n        s.Member(cmem_float, \"cmem_float\");\n    }\n};\n\n\nint main(int argc, char* argv[])\n{\n    Serializer s;\n    std::cerr &lt;&lt; \"Parent structure: \" &lt;&lt; std::endl;\n    s.DisplayStructure&lt;Parent&gt;();\n\n    std::cerr &lt;&lt; \"\\nChild structure: \" &lt;&lt; std::endl;\n    s.DisplayStructure&lt;Child&gt;();\n\n    Child c;\n    Parent* p = &amp;c;\n    std::cerr &lt;&lt; \"\\nContent: \" &lt;&lt; std::endl;\n    s.DisplayContentVirtual(*p);\n\n    return 0;\n}\n</code></pre>\n<p>Expected output produced:</p>\n<pre><code>Parent structure:\nType: Parent\nMember: pmem_int\nMember: pmem_str\n\nChild structure:\nParent Type: Parent\nMember: pmem_int\nMember: pmem_str\nType: Child\nMember: cmem_float\n\nContent:\nParent Type: Parent\nMember: pmem_int : 1234\nMember: pmem_str : Hello\nType: Child\nMember: cmem_float : 334\n</code></pre>\n", "AcceptedAnswerId": "25974400", "Title": "C++ class method that can be called using virtual dispatch or like a static function with no object context", "CreationDate": "2014-09-22T12:24:51.353", "Id": "25974056", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-09-22T20:46:39.243", "Score": "2", "OwnerUserId": "1265365", "Tags": "<c++>", "AnswerCount": "1"}});