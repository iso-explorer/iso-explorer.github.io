post_cb({"844768": {"CommentCount": "0", "AcceptedAnswerId": "844779", "CreationDate": "2009-05-10T05:32:49.460", "LastActivityDate": "2009-10-19T09:21:24.103", "Title": "How is STL iterator equality established?", "ViewCount": "6267", "FavoriteCount": "2", "PostTypeId": "1", "Id": "844768", "OwnerUserId": "20426", "Body": "<p>I was wondering, how is equality (==) established for STL iterators?\nIs it a simple pointer comparison (and thus based on addresses) or something more fancy?</p>\n<p>If I have two iterators from two different list objects and I compare them, will the result always be false? </p>\n<p>What about if I compare a valid value with one that's out of range? Is that always false?</p>\n", "Tags": "<c++><stl>", "Score": "9", "AnswerCount": "4"}, "845022": {"ParentId": "844768", "CommentCount": "0", "Body": "<p>The equality test is specific to the type of iterator you are using, or may not exist at all.  If you really want to know, you can always check the source code of the implementation of STL you are using, look for operator==() in the iterator class.</p>\n<p>Iterators are NOT always pointers, and indeed in some \"safe\" versions of the STL, are never pointers.  Iterators for vectors and strings are commonly implemented as pointers because they can be.  Iterators for deques, lists, sets and maps cannot be pointers in any half efficient implementation.</p>\n<p>What iterators are is a type of smart pointer.  They follow the generic principle that if they look and behave like a pointer, then they <em>are</em> a pointer as far as the user is concerned.</p>\n", "OwnerUserId": "104107", "PostTypeId": "2", "Id": "845022", "Score": "1", "CreationDate": "2009-05-10T09:48:20.923", "LastActivityDate": "2009-05-10T09:48:20.923"}, "844779": {"ParentId": "844768", "CommentCount": "2", "Body": "<p>Iterator classes can define overloaded == operators, if they want. So the result depends on the implementation of <code>operator==</code>.</p>\n<p>You're not really supposed to compare iterators from different containers. I think some debug STL implementations will signal a warning if you do this, which will help you catch cases of this erroneous usage in your code.</p>\n", "OwnerUserId": "13", "PostTypeId": "2", "Id": "844779", "Score": "11", "CreationDate": "2009-05-10T05:38:43.580", "LastActivityDate": "2009-05-10T05:38:43.580"}, "1587701": {"ParentId": "844768", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_844768_1587701_0\"><b>Daniel asked:</b>\n  I was wondering, how is equality (==) established for STL iterators? Is it a simple pointer comparison (and thus based on addresses) or something more fancy?</p>\n</blockquote>\n<p>It depends on implementation. Right now, on Visual C++ 2008, I see the following code (for the list iterator):</p>\n<pre><code>bool operator==(const _Myt_iter&amp; _Right) const\n{   // test for iterator equality\n\n#if _HAS_ITERATOR_DEBUGGING\n    _Compat(_Right);\n#else\n    _SCL_SECURE_TRAITS_VALIDATE(this-&gt;_Has_container() &amp;&amp; this-&gt;_Same_container(_Right));\n#endif /* _HAS_ITERATOR_DEBUGGING */\n\n    return (_Ptr == _Right._Ptr);\n}\n</code></pre>\n<p>You'll see above that there is both code for verification of iterator validity, and <code>_Ptr</code> being a pointer to a list node.</p>\n<p>So I guess there is both verification, and simple, raw pointer comparison.</p>\n<blockquote>\n<p id=\"so_844768_1587701_1\"><b>Daniel asked:</b>\n  If I have two iterators from two different list objects and I compare them, will the result always be false?</p>\n</blockquote>\n<p>Until now, it appears the standard was somewhat unclear on the subject. Apparently, they will explicitly write that this kind of operation has undefined results:</p>\n<p>Quoting: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#446\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#446</a></p>\n<blockquote>\n<p id=\"so_844768_1587701_2\"><b>The result of using any iterator operation</b> (24.2.1 [input.iterators], 24.2.2 [output.iterators], 24.2.3 [forward.iterators], 24.2.4 [bidirectional.iterators], 24.2.5 [random.access.iterators]) <b>that uses two iterator values as arguments</b> (footnote) <b>which were obtained from two different ranges</b> r1 and r2 (including their past-the-end values) which are not subranges of one common range <b>is undefined</b>, unless explicitly described otherwise.</p>\n<p id=\"so_844768_1587701_3\">footnote) Among others these operations are ==, &lt;, binary -, and copy assignment</p>\n</blockquote>\n<p>So I guess it is evil to compare iterator from different containers...\n^_^</p>\n<blockquote>\n<p id=\"so_844768_1587701_4\"><b>Daniel asked:</b>\n  What about if I compare a valid value with one that's out of range? Is that always false?</p>\n</blockquote>\n<p>Same as above.</p>\n", "OwnerUserId": "14089", "PostTypeId": "2", "Id": "1587701", "Score": "3", "CreationDate": "2009-10-19T09:21:24.103", "LastActivityDate": "2009-10-19T09:21:24.103"}, "844863": {"ParentId": "844768", "PostTypeId": "2", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_844768_844863_0\">I was wondering, how is equality (==) established for STL iterators? </p>\n</blockquote>\n<p>Not all iterators can be compared (e.g. Output Iterators are not required to provide <code>op==</code>). You can use the <code>operator==</code> when the concept of a range is well-defined for the iterator category under consideration.</p>\n<blockquote>\n<p id=\"so_844768_844863_1\">Is it a simple pointer comparison (and thus based on addresses) or something more fancy?</p>\n</blockquote>\n<p>Iterators are always implemented with pointers. Edit: I say <strong>implemented with</strong>  -- which refers not to a Standard requirement but rather to the practice of using poitners as the underlying construct. Implementations (like VS) may have special validation checks inserted though.</p>\n<blockquote>\n<p id=\"so_844768_844863_2\">If I have two iterators from two different list objects and I compare them, will the result always be false? </p>\n</blockquote>\n<p>You are invoking Undefined Behavior.</p>\n<blockquote>\n<p id=\"so_844768_844863_3\">What about if I compare a valid value with one that's out of range? Is that always false?</p>\n</blockquote>\n<p>Again, you will be invoking UB. The only valid comparison are between two iterators in the same range or between one in the range and another to one past the last element. Note, you can only compare against the iterator to one-past the last element, dereferencing the same leads to UB.</p>\n", "OwnerUserId": "66692", "LastEditorUserId": "66692", "LastEditDate": "2009-05-10T21:37:02.320", "Id": "844863", "Score": "2", "CreationDate": "2009-05-10T07:16:58.913", "LastActivityDate": "2009-05-10T21:37:02.320"}, "bq_ids": {"n4659": {"so_844768_844863_3": {"section_id": 802, "quality": 0.5454545454545454, "length": 6}}}});