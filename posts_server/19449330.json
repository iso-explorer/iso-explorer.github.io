post_cb({"19449432": {"ParentId": "19449330", "CommentCount": "0", "CreationDate": "2013-10-18T12:14:56.440", "OwnerUserId": "1312406", "PostTypeId": "2", "Id": "19449432", "Score": "1", "Body": "<p>The value of <code>test</code> is <em>uninitialised</em> and you shouldn't worry what it is.</p>\n", "LastActivityDate": "2013-10-18T12:14:56.440"}, "19449408": {"ParentId": "19449330", "CommentCount": "0", "CreationDate": "2013-10-18T12:13:47.220", "OwnerUserId": "2704585", "PostTypeId": "2", "Id": "19449408", "Score": "1", "Body": "<p>Studio is treating <code>test</code> as a C string, an array of characters terminated by <code>\\0</code>. It will not impact the functioning of your program, it is just the debugger trying to be smart.</p>\n", "LastActivityDate": "2013-10-18T12:13:47.220"}, "19449422": {"ParentId": "19449330", "CommentCount": "0", "CreationDate": "2013-10-18T12:14:25.813", "OwnerUserId": "2845714", "PostTypeId": "2", "Id": "19449422", "Score": "1", "Body": "<p>Because your visualiser works with your array as it was array of chars. It tries to display it as a string which is supposed to end with '\\0'.</p>\n<p>So what you see is uninitialized memory.</p>\n", "LastActivityDate": "2013-10-18T12:14:25.813"}, "19449441": {"ParentId": "19449330", "CommentCount": "0", "CreationDate": "2013-10-18T12:15:17.647", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "19449441", "Score": "2", "Body": "<p>I don't know what \"the Watch\" is (something in your debugger perhaps?), but given just a pointer it has no way of knowing how much memory you've allocated. Probably, it assumes that the pointer refers to a C-style string of printable characters followed by a zero terminator, and displays all the memory it finds until it reaches a zero-valued byte.</p>\n", "LastActivityDate": "2013-10-18T12:15:17.647"}, "19450808": {"ParentId": "19449330", "LastEditDate": "2013-10-18T17:48:55.907", "CommentCount": "2", "CreationDate": "2013-10-18T13:23:29.583", "Score": "1", "LastEditorUserId": "2436697", "PostTypeId": "2", "Id": "19450808", "OwnerUserId": "2436697", "Body": "<h2>Why the unexpected amount of symbols seen after dynamic memory allocation of array?</h2>\n<p><code>test</code> refers to <code>c-string</code>. End of <code>c-string</code> is marked by <code>\\0</code>. </p>\n<p><code>test</code> isn't explicitly initialized in the program posted in the question. <code>test</code> has <em>indeterminate value</em> and so you can't expect <code>\\0</code> to be present exactly after the end of <code>c-string</code>.\nThe extra characters that you see in your debugger are those that exist between <em>the last character pointed to by <code>test</code></em> and the first <em><code>\\0</code></em> that the debugger found.</p>\n<hr>\n<h2>Why it is said that <code>test</code> has indeterminate value?</h2>\n<p>When you use <code>new</code> as in below statement,</p>\n<pre><code>unsigned char *p_dynamic_alloc = new unsigned char[8];\n</code></pre>\n<p>a pointer to <code>unsigned char</code> is returned, which points to the address of the first element of the array. Dynamic memory of size: <code>8 * sizeof (unsigned char)</code> is allocated. Initializer is not mentioned. </p>\n<p>Lets understand how <code>new</code> handles dynamic allocation without the initializer: </p>\n<blockquote>\n<p id=\"so_19449330_19450808_0\">[C++11: \u00a75.3.4/15]: A <em>new-expression</em> that creates an object of type T initializes \n      that object as follows:</p>\n<ul>\n<li>If the <em>new-initializer</em> is omitted, the object is default-initialized (8.5); <strong>if no initialization is performed, the object has indeterminate value.</strong></li>\n<li>Otherwise, the <em>new-initializer</em> is interpreted according to the initialization rules of 8.5 for direct-initialization.</li>\n</ul>\n</blockquote>\n<p>Lets understand if it is really default initialized or if no initialization is performed.</p>\n<p>Default initialization (of an <code>unsigned char*</code>) is stated as,</p>\n<blockquote>\n<p id=\"so_19449330_19450808_1\">[C++11: \u00a78.5/7]:To default-initialize an object of type T means:</p>\n<ul>\n<li>if T is a (possibly cv-quali\ufb01ed) class type (Clause 9), the default constructor (12.1) or T is called (and the initialization is ill-formed  if T has no default constructor or overload resolution (13.3) results in an ambiguity or in a function that is deleted or inaccessible from the context of the initialization);</li>\n<li>if T is an array type, each element is default-initialized;</li>\n<li><strong>otherwise, no initialization is performed.</strong></li>\n</ul>\n</blockquote>\n<p>which means as pointed out earlier, <strong>the object has indeterminate value.</strong></p>\n<hr>\n<h2>Solution</h2>\n<p>Properly initialize your dynamic byte array:</p>\n<pre><code>byte *test = new byte[8]();\n</code></pre>\n</hr></hr>", "LastActivityDate": "2013-10-18T17:48:55.907"}, "19449453": {"ParentId": "19449330", "LastEditDate": "2017-05-23T12:05:15.183", "CommentCount": "1", "CreationDate": "2013-10-18T12:15:53.657", "Score": "3", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "19449453", "OwnerUserId": "671366", "Body": "<p>Since you allocated the array dynamically, the debugger doesn't know from the type how big the array is. Some compilers (e.g. Visual Studio) allow special expressions to interpret a pointer as an array (see e.g. <a href=\"https://stackoverflow.com/questions/972511/view-array-in-visual-studio-debugger\">View array in Visual Studio debugger?</a>), in your case, you could try</p>\n<pre><code>test,8\n</code></pre>\n<p>And you should see only the 8 values of test. However, the shown values won't make more sense, since they're still uninitialized after the snippet you show.</p>\n", "LastActivityDate": "2013-10-18T12:15:53.657"}, "19449330": {"CommentCount": "1", "ViewCount": "132", "CreationDate": "2013-10-18T12:08:46.960", "LastActivityDate": "2013-10-18T17:48:55.907", "Title": "Unexpected amount of symbols in watch after creating byte array dynamicly", "AcceptedAnswerId": "19450808", "PostTypeId": "1", "Id": "19449330", "Score": "0", "Body": "<p>Could you please explain me, how should I understand following behavior:</p>\n<pre><code>typedef unsigned char byte;    \nbyte * test = new byte[8];\n</code></pre>\n<p>Here is the value of test I can see in the Watch: \u00cd\u00cd\u00cd\u00cd\u00cd\u00cd\u00cd\u00cd\u00fd\u00fd\u00fd\u00fd\u00ab\u00ab\u00ab\u00ab\u00ab\u00ab\u00ab\u00ab\u00ee\u00fe\u00ee\u00fe</p>\n<p>Why is it happening? Why I see 24 symbols, not 8?</p>\n", "Tags": "<c++><bytearray>", "OwnerUserId": "2783836", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_19449330_19450808_0": {"section_id": 6098, "quality": 0.7777777777777778, "length": 7}, "so_19449330_19450808_1": {"section_id": 3286, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_19449330_19450808_0": {"section_id": 5864, "quality": 0.7777777777777778, "length": 7}, "so_19449330_19450808_1": {"section_id": 3156, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_19449330_19450808_0": {"section_id": 7595, "quality": 0.7777777777777778, "length": 7}}}});