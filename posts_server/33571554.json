post_cb({"33571554": {"CommentCount": "6", "ViewCount": "145", "PostTypeId": "1", "LastEditorUserId": "2430189", "CreationDate": "2015-11-06T16:42:11.160", "LastActivityDate": "2015-11-06T19:00:22.167", "Title": "gcc instantiates template with long instead of __int128", "AcceptedAnswerId": "33573507", "LastEditDate": "2015-11-06T17:33:53.830", "Id": "33571554", "Score": "3", "Body": "<p>I am dazed and confused. What is happening here in the second call to my <code>big</code> template?</p>\n<pre><code>template &lt;class T&gt; void big(T t) {  }\n\nint main()\n{\n    big(9223372036854775808);                        // calls big&lt;__int128&gt;\n    big(941832094813209483120);                      // calls big&lt;long&gt;\n    big(239120938091238093219203810293801923832019); // calls big&lt;__int128&gt;\n}\n</code></pre>\n<p>Why is a <strong>long template</strong> instantiated for <code>941832094813209483120</code>, while the two other values get a <strong>__int128 template</strong>.</p>\n<p>This value obviously does <strong>not</strong> fit inside the <code>long</code> and seems to result in an overflow (see full gdb session below):</p>\n<pre><code>big&lt;long&gt; (t=1048147054022350704) at blob.cpp:1\n</code></pre>\n<p>I observe this with <code>gcc-5.2.0</code> as well as <code>gcc-4.9.2</code>, while I use <code>gdb-7.7.1</code> for debugging.</p>\n<p>This is my full <code>gdb</code> session:</p>\n<pre><code>Breakpoint 1, main () at blob.cpp:5\n(gdb) s \nbig&lt;__int128&gt; (t=0x00000000000000008000000000000000) at blob.cpp:1\n(gdb)  \nmain () at blob.cpp:6\n(gdb)  \nbig&lt;long&gt; (t=1048147054022350704) at blob.cpp:1\n(gdb)  \nmain () at blob.cpp:7\n(gdb)  \nbig&lt;__int128&gt; (t=0x0000000000000000d90567828f8ae8d3) at blob.cpp:1\n(gdb)\n</code></pre>\n", "Tags": "<c++><c++11><gcc><gdb>", "OwnerUserId": "2430189", "AnswerCount": "1"}, "33573507": {"ParentId": "33571554", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Since the OP has confirmed that long long is 64bit on their system we can see that the <a href=\"https://gcc.gnu.org/onlinedocs/gcc/_005f_005fint128.html\" rel=\"nofollow\">gcc docs on 128-bit Integers</a> says:</p>\n<blockquote>\n<p id=\"so_33571554_33573507_0\">There is no support in GCC for expressing an integer constant of type __int128 for targets with long long integer less than 128 bits wide. </p>\n</blockquote>\n<p>So while I agree the behavior is odd, it is technically not a bug since gcc does not support this scenario and explicitly documents this.</p>\n<p>Compilers may support extended signed integers, from the draft C++11 standard section 3.9.1:</p>\n<blockquote>\n<p id=\"so_33571554_33573507_1\">There may also be implementation-defined extended signed integer types</p>\n</blockquote>\n<p>but they are implementation-defined and wording for integer literals in section 2.14.2 says:</p>\n<blockquote>\n<p id=\"so_33571554_33573507_2\">If an integer literal cannot be represented by any type in its list and an extended integer type (3.9.1) can\n  represent its value, it <strong>may</strong> have that extended integer type [...]</p>\n</blockquote>\n<p>with emphasis on <em>may</em>.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-11-06T19:00:22.167", "Id": "33573507", "Score": "1", "CreationDate": "2015-11-06T18:42:02.577", "LastActivityDate": "2015-11-06T19:00:22.167"}, "bq_ids": {"n4140": {"so_33571554_33573507_1": {"section_id": 7211, "quality": 0.875, "length": 7}, "so_33571554_33573507_2": {"section_id": 5342, "quality": 0.95, "length": 19}}, "n3337": {"so_33571554_33573507_1": {"section_id": 6955, "quality": 0.875, "length": 7}, "so_33571554_33573507_2": {"section_id": 5139, "quality": 0.95, "length": 19}}, "n4659": {"so_33571554_33573507_1": {"section_id": 8720, "quality": 0.875, "length": 7}, "so_33571554_33573507_2": {"section_id": 6763, "quality": 0.95, "length": 19}}}});