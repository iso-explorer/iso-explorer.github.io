post_cb({"bq_ids": {"n4140": {"so_49200770_49200770_4": {"length": 16, "quality": 1.0, "section_id": 6169}, "so_49200770_49200770_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 6172}, "so_49200770_49200770_7": {"length": 32, "quality": 1.0, "section_id": 6169}, "so_49200770_49200770_5": {"length": 13, "quality": 1.0, "section_id": 6169}, "so_49200770_49200770_3": {"length": 19, "quality": 0.95, "section_id": 6169}, "so_49200770_49200770_6": {"length": 39, "quality": 1.0, "section_id": 6169}, "so_49200770_49200770_2": {"length": 43, "quality": 0.9772727272727273, "section_id": 6169}, "so_49200770_49200770_8": {"length": 29, "quality": 1.0, "section_id": 6169}, "so_49200770_49200770_0": {"length": 12, "quality": 0.5454545454545454, "section_id": 6172}}, "n3337": {"so_49200770_49200770_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 5933}, "so_49200770_49200770_7": {"length": 32, "quality": 1.0, "section_id": 5930}, "so_49200770_49200770_5": {"length": 13, "quality": 1.0, "section_id": 5930}, "so_49200770_49200770_3": {"length": 19, "quality": 0.95, "section_id": 5930}, "so_49200770_49200770_6": {"length": 39, "quality": 1.0, "section_id": 5930}, "so_49200770_49200770_4": {"length": 16, "quality": 1.0, "section_id": 5930}, "so_49200770_49200770_2": {"length": 43, "quality": 0.9772727272727273, "section_id": 5930}, "so_49200770_49200770_8": {"length": 29, "quality": 1.0, "section_id": 5930}, "so_49200770_49200770_0": {"length": 12, "quality": 0.5454545454545454, "section_id": 5933}}, "n4659": {"so_49200770_49200770_4": {"length": 9, "quality": 0.5625, "section_id": 7667}, "so_49200770_49200770_5": {"length": 11, "quality": 0.8461538461538461, "section_id": 7667}, "so_49200770_49200770_3": {"length": 11, "quality": 0.55, "section_id": 7667}, "so_49200770_49200770_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 7670}, "so_49200770_49200770_2": {"length": 35, "quality": 0.7954545454545454, "section_id": 7667}, "so_49200770_49200770_8": {"length": 15, "quality": 0.5172413793103449, "section_id": 7667}, "so_49200770_49200770_0": {"length": 12, "quality": 0.5454545454545454, "section_id": 7670}}}, "49200770": {"ViewCount": "143", "Body": "<p>In short, I have the following code:</p>\n<pre><code>float x = cond ? 0 : x_option;\n</code></pre>\n<p>Where <code>x_option</code> is a <code>template&lt;float&gt;</code>, which has an <code>operator float()</code> (and no other automatic cast operators. Note the types of the expression after this conversion:</p>\n<pre><code>bool ? int : float;\n</code></pre>\n<p>I would expect the result of this expression to be a <code>float</code>:</p>\n<hr>\n<p>C11:</p>\n<blockquote>\n<p id=\"so_49200770_49200770_0\">If both the second and third operands have arithmetic type, the result type that would be\n  determined by the usual arithmetic conversions, were they applied to those two operands,\n  is the type of the result.</p>\n</blockquote>\n<p>So it follows the same rules as for example <code>float + int</code>.</p>\n<hr>\n<p>C++11:</p>\n<blockquote>\n<p id=\"so_49200770_49200770_1\">The second and third operands have arithmetic or enumeration type; the usual arithmetic conversions\n  are performed to bring them to a common type, and the result is of that type.</p>\n</blockquote>\n<p>Same rule.</p>\n<hr>\n<p><strong>However</strong>, both clang and cl.exe generate a <code>vcvttss2si</code> instruction in the path leading to the evaluation of the 3rd argument, i.e. they decide that the result of <code>bool ? int : float</code> is an <code>int</code>, not a <code>float</code>!</p>\n<p>To be fair, C++11 has some rules that should apply before the one I quoted, and to be honest, the rules are not the easiest to understand, although from what I can make of it, conversion to <code>int</code> shouldn't be possible:</p>\n<p>C++11:</p>\n<blockquote>\n<p id=\"so_49200770_49200770_2\">Otherwise, if the second and third operand have different types and either has (possibly cv-qualified) class type, or if both are glvalues of the same value category and the same type except for cv-qualification, an attempt is made to convert each of those operands to the type of the other. The process for determining whether an operand expression E1 of type T1 can be converted to match an operand expression E2 of type T2 is defined as follows:</p>\n<p id=\"so_49200770_49200770_3\">\u2014 If E2 is an lvalue: E1 can be converted to match E2 if E1 can be implicitly converted (Clause 4) to the type \u201clvalue reference to T2\u201d, subject to the constraint that in the conversion the reference must bind directly (8.5.3) to an lvalue.</p>\n<p id=\"so_49200770_49200770_4\">\u2014 If E2 is an xvalue: E1 can be converted to match E2 if E1 can be implicitly converted to the type \u201crvalue reference to T2\u201d, subject to the constraint that the reference must bind directly.</p>\n<p id=\"so_49200770_49200770_5\">\u2014 If E2 is an rvalue or if neither of the conversions above can be done and at least one of the operands has (possibly cv-qualified) class type:</p>\n<ul>\n<li><p id=\"so_49200770_49200770_6\">if E1 and E2 have class type, and the underlying class types are the same or one is a base class of the other: E1 can be converted to match E2 if the class of T2 is the same type as, or a base class of, the class of T1, and the cv-qualification of T2 is the same cv-qualification as, or a greater cv-qualification than, the cv-qualification of T1. If the conversion is applied, E1 is changed to a prvalue of type T2 by copy-initializing a temporary of type T2 from E1 and using that temporary as the converted operand.</p></li>\n<li><p id=\"so_49200770_49200770_7\">Otherwise (i.e., if E1 or E2 has a nonclass type, or if they both have class types but the underlying classes are not either the same or one a base class of the other): E1 can be converted to match E2 if E1 can be implicitly converted to the type that expression E2 would have if E2 were converted to a prvalue (or the type it has, if E2 is a prvalue).</p></li>\n</ul>\n<p id=\"so_49200770_49200770_8\">Using this process, it is determined whether the second operand can be converted to match the third operand, and whether the third operand can be converted to match the second operand. If both can be converted, or one can be converted but the conversion is ambiguous, the program is ill-formed.</p>\n</blockquote>\n<p>From what I understand in the above, this falls into the second case of the third case (last bullet point of the last bullet point), so E1 (of type <code>int</code>) should be converted to the type of E2 (<code>float</code>). The standard later says if the conversion can be done both ways, the program is ill-formed.</p>\n<p>What's the ruling here? Am I in the realm of undefined behavior? Or is the standard dictating the conversion I am seeing?</p>\n</hr></hr></hr>", "AcceptedAnswerId": "49200934", "Title": "Result of ternary operator on `int` and `float`", "CreationDate": "2018-03-09T19:24:04.827", "LastActivityDate": "2018-03-09T19:34:56.907", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-03-09T19:34:56.907", "LastEditorUserId": "2756719", "Id": "49200770", "Score": "7", "OwnerUserId": "912144", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "1"}, "49200934": {"Id": "49200934", "PostTypeId": "2", "Body": "<p><code>bool ? int : float</code> is a float. </p>\n<p><code>bool ? int : some_type_convertible_to_float</code> isn't: the third operand can be converted to <code>int</code> (by converting first to <code>float</code> then to <code>int</code>); the <code>int</code> (probably) can't be converted to <code>some_type_convertible_to_float</code>. So by the rules you cited, you get an <code>int</code>.</p>\n", "LastActivityDate": "2018-03-09T19:34:51.517", "Score": "8", "CreationDate": "2018-03-09T19:34:51.517", "ParentId": "49200770", "CommentCount": "2", "OwnerUserId": "2756719"}});