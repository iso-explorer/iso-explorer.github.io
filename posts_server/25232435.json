post_cb({"25232525": {"ParentId": "25232435", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The reason this works is that the <code>for</code> loop effectively<sup>1</sup> uses <code>std::begin</code> and <code>std::end</code>. Those, in turn, work, because they provide overloads specifically for built-in arrays, something like this:</p>\n<pre><code>template &lt;class T, size_t N&gt;\nT *begin(T (&amp;array)[N]) {\n    return array;\n}\n\ntemplate &lt;class T, size_t N&gt;\nT *end(T (&amp;array)[N]) {\n    return array+N;\n}\n</code></pre>\n<p>Although it (apparently) hadn't been realized before the original (1998) C++ standard was published, this technique doesn't require any language features beyond those available in C++98. C++11 codified the technique and puts it to use.</p>\n<p>Since, in this case, the parameter is specified as a reference to an array, type deduction will only succeed when the parameter really is an array. In the case of <code>std::begin</code>, there are also versions that support other parameter types and use (for example) the <code>begin()</code> and <code>end()</code> members of collections, if that type is matched.</p>\n<hr>\n<p><sub>\n1. \"Effectively\" in this case meaning there are some circumstances in which a range-based for loop uses <code>begin</code> and <code>end</code>, and others in which they're not. If you're into technicalities, they're not used for arrays, but a similar computation is done directly. Likewise, for container types that have <code>begin</code> and <code>end</code> members, those are used directly. If neither of those is true, then <code>begin(range)</code> and <code>end(range)</code> are used, which can use either <code>std::begin</code>/<code>std::end</code>, or a <code>begin(x)</code>/<code>end(x)</code> pair found by argument dependent lookup.\n</sub></p>\n</hr>", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2014-08-10T20:10:46.863", "Id": "25232525", "Score": "4", "CreationDate": "2014-08-10T20:04:23.337", "LastActivityDate": "2014-08-10T20:10:46.863"}, "25232501": {"ParentId": "25232435", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>You're under a misconception that a ranged-for needs to know the number of iterations (the \"length\") in advance.  It does not.</p>\n<p>It does need a termination condition, which has the form <code>it != __end</code> where <code>__end = x.end()</code> or <code>__end = end(x)</code>.</p>\n<p>Of course, arrays can't change their size, so in this one case detecting the end and knowing the length are equivalent (length can be gotten from begin, end, and pointer subtraction).</p>\n<p>As Oli mentioned in the comments, the type of an array does contain length information, and <code>std::end</code> uses an array reference for its parameter, to avoid the decay to pointer which loses this information.</p>\n<p>The definition is basically:</p>\n<pre><code>namespace std\n{\n    template&lt;typename T, size_t N&gt; \n    T* end(T (&amp;array)[N])\n    {\n        return array + N;\n        // or if you want to be cute\n        // return 1[&amp;array];\n    }\n}\n</code></pre>\n<p>When the bound in an array reference is a non-type template parameter, it is deducible.  Use this to your advantage when writing functions that accept arrays.</p>\n<p>(The compiler actually has the <code>array + N</code> calculation for the end built-in for arrays, it doesn't use <code>std::end()</code> for that.  But there would be no difference after inlining anyway, and it's useful to see how you can play the same trick the compiler does.)</p>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2014-08-10T21:05:37.353", "Id": "25232501", "Score": "3", "CreationDate": "2014-08-10T20:01:01.787", "LastActivityDate": "2014-08-10T21:05:37.353"}, "25232435": {"CommentCount": "7", "AcceptedAnswerId": "25232501", "PostTypeId": "1", "LastEditorUserId": "2848483", "CreationDate": "2014-08-10T19:53:08.437", "LastActivityDate": "2014-08-11T01:43:21.013", "LastEditDate": "2014-08-11T01:43:21.013", "ViewCount": "618", "FavoriteCount": "1", "Title": "How does a \"for each\" loop in C++ know the length of an array", "Id": "25232435", "Score": "5", "Body": "<p>I was looking at the following example from <a href=\"http://www.cplusplus.com/doc/tutorial/arrays/\" rel=\"nofollow\">http://www.cplusplus.com/doc/tutorial/arrays/</a> and I couldn't figure out how the 2nd for loop worked. How can the for loop know when the array ends. If it can figure this out why does the first loop not use a similar approach? It was my impression that the length of an array could not be determined. I'm not sure how to reconcile these notions. Thanks!  </p>\n<p><strong>Edit: Thanks for all the great answers!</strong></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n  int myarray[3] = {10,20,30};\n\n  for (int i=0; i&lt;3; ++i)\n    ++myarray[i];\n\n  for (int elem : myarray)\n    cout &lt;&lt; elem &lt;&lt; '\\n';\n}\n</code></pre>\n", "Tags": "<c++><arrays><for-loop><foreach>", "OwnerUserId": "2848483", "AnswerCount": "4"}, "25232492": {"ParentId": "25232435", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The compiler knows the number of elements of the array due to the array definition. So it uses expressions <code>myarray</code> and <code>myarray + 3</code> to traverse the array.</p>\n<p>In fact the loop looks the following way</p>\n<pre><code>for ( auto first = myarray, last = myarray + 3; first != last; ++first )\n{\n   auto elem = *first;\n   cout &lt;&lt; elem &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Take into account that the range-based for statement <strong>use neither std::begin() nor std::end() for arrays</strong> as others wrote here.:)</p>\n<p>According to the C++ Standard</p>\n<blockquote>\n<p id=\"so_25232435_25232492_0\">\u2014 if <strong>_RangeT is an array type</strong>, begin-expr and end-expr are\n  <strong>__range</strong> and <strong>__range + __bound</strong>, respectively, where __bound is the array bound. If _RangeT is an array of unknown size or an array of\n  incomplete type, the program is ill-formed;</p>\n</blockquote>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2014-08-10T20:40:10.043", "Id": "25232492", "Score": "3", "CreationDate": "2014-08-10T20:00:01.697", "LastActivityDate": "2014-08-10T20:40:10.043"}, "25232675": {"ParentId": "25232435", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The compiler knows the actual type of the array and uses a standard iterator-based loop with <code>array</code> (equivalent to <code>array + 0</code>) and <code>array + length</code> (equivalent to <code>*(&amp;array + 1)</code>) as start respective end of the range.</p>\n<p>For a non-array, it first looks for <code>begin</code> and <code>end</code> in the given range, then finally uses ADL to find free functions.</p>\n<p>All but using ADL to find free functions will be done equally by <code>std::begin</code> and <code>std::end</code>, thus if you use <code>using std::begin;</code> and <code>using std::end;</code> in your code, unqualified name-lookup will mimic the rules of the ranged-for-loop.</p>\n<p>The proper section from C++1y:</p>\n<blockquote>\n<h3>6.5.4 The range-based for statement [stmt.ranged]</h3>\n<p id=\"so_25232435_25232675_0\">1 For a range-based <code>for</code> statement of the form</p>\n<pre><code>for ( for-range-declaration : expression ) statement\n</code></pre>\n<p id=\"so_25232435_25232675_1\">let <code>range-init</code> be equivalent to the <code>expression</code> surrounded by parentheses<sub>90</sub> <code>( expression )</code> and for a range-based for statement of the form</p>\n<pre><code>for ( for-range-declaration : braced-init-list ) statement\n</code></pre>\n<p id=\"so_25232435_25232675_2\">let <code>range-init</code> be equivalent to the <code>braced-init-list</code>. In each case, a range-based <code>for</code> statement is equivalent to</p>\n<pre><code>{\n    auto &amp;&amp; __range = range-init;\n    for ( auto __begin = begin-expr, __end = end-expr;\n              __begin != __end; ++__begin ) {\n        for-range-declaration = *__begin;\n        statement\n    }\n}\n</code></pre>\n<p id=\"so_25232435_25232675_3\">where <code>__range</code>, <code>__begin</code>, and <code>__end</code> are variables defined for exposition only, and <code>_RangeT</code> is the type of the expression, and <code>begin-expr</code> and <code>end-expr</code> are determined as follows:</p>\n<ul>\n<li>if <code>_RangeT</code> is an array type, <code>begin-expr</code> and <code>end-expr</code> are <code>__range</code> and <code>__range + __bound</code>, respectively, where <code>__bound</code> is the array bound. If <code>_RangeT</code> is an array of unknown size or an array of incomplete type, the program is ill-formed;</li>\n<li>if <code>_RangeT</code> is a class type, the unqualified-ids <code>begin</code> and <code>end</code> are looked up in the scope of class <code>_RangeT</code> as if by class member access lookup (3.4.5), and if either (or both) finds at least one declaration, <code>beginexpr</code> and <code>end-expr</code> are <code>__range.begin()</code> and <code>__range.end()</code>, respectively;</li>\n<li>otherwise, <code>begin-expr</code> and <code>end-expr</code> are <code>begin(__range)</code> and <code>end(__range)</code>, respectively, where <code>begin</code> and <code>end</code> are looked up in the associated namespaces (3.4.2). <em>[ Note: Ordinary unqualified lookup (3.4.1) is not performed. \u2014end note ]</em></li>\n</ul>\n<p id=\"so_25232435_25232675_4\">2 In the <em>decl-specifier-seq</em> of a <em>for-range-declaration</em>, each <em>decl-specifier</em> shall be either a <em>type-specifier</em> or <em>constexpr</em>.</p>\n</blockquote>\n", "OwnerUserId": "3204551", "LastEditorUserId": "3204551", "LastEditDate": "2014-08-10T20:56:19.787", "Id": "25232675", "Score": "4", "CreationDate": "2014-08-10T20:24:34.850", "LastActivityDate": "2014-08-10T20:56:19.787"}, "bq_ids": {"n4140": {"so_25232435_25232675_2": {"section_id": 3906, "quality": 0.8888888888888888, "length": 8}, "so_25232435_25232675_1": {"section_id": 3906, "quality": 0.8, "length": 8}, "so_25232435_25232675_3": {"section_id": 3906, "quality": 0.7857142857142857, "length": 11}, "so_25232435_25232675_4": {"section_id": 3907, "quality": 1.0, "length": 7}, "so_25232435_25232492_0": {"section_id": 3906, "quality": 0.9047619047619048, "length": 19}}, "n3337": {"so_25232435_25232675_2": {"section_id": 3766, "quality": 0.8888888888888888, "length": 8}, "so_25232435_25232675_1": {"section_id": 3766, "quality": 0.8, "length": 8}, "so_25232435_25232675_3": {"section_id": 3766, "quality": 0.7857142857142857, "length": 11}, "so_25232435_25232675_4": {"section_id": 3767, "quality": 1.0, "length": 7}, "so_25232435_25232492_0": {"section_id": 3766, "quality": 0.9047619047619048, "length": 19}}, "n4659": {"so_25232435_25232675_4": {"section_id": 4793, "quality": 1.0, "length": 7}, "so_25232435_25232675_3": {"section_id": 4792, "quality": 0.6428571428571429, "length": 9}, "so_25232435_25232492_0": {"section_id": 4792, "quality": 0.7619047619047619, "length": 16}}}});