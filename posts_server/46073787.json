post_cb({"bq_ids": {"n4140": {"so_46073787_46075199_0": {"length": 19, "quality": 0.6551724137931034, "section_id": 5485}, "so_46073787_46075199_1": {"length": 25, "quality": 0.6097560975609756, "section_id": 5485}, "so_46073787_46073787_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 5485}, "so_46073787_46073787_4": {"length": 35, "quality": 0.9210526315789473, "section_id": 5485}}, "n3337": {"so_46073787_46075199_0": {"length": 18, "quality": 0.6206896551724138, "section_id": 5271}, "so_46073787_46075199_1": {"length": 24, "quality": 0.5853658536585366, "section_id": 5271}, "so_46073787_46073787_1": {"length": 27, "quality": 0.7105263157894737, "section_id": 5271}, "so_46073787_46073787_4": {"length": 27, "quality": 0.7105263157894737, "section_id": 5271}}, "n4659": {"so_46073787_46075199_0": {"length": 16, "quality": 0.5517241379310345, "section_id": 6920}, "so_46073787_46075199_1": {"length": 25, "quality": 0.6097560975609756, "section_id": 6920}, "so_46073787_46073787_1": {"length": 28, "quality": 0.7368421052631579, "section_id": 6920}, "so_46073787_46073787_4": {"length": 28, "quality": 0.7368421052631579, "section_id": 6920}}}, "46073787": {"ViewCount": "180", "Body": "<p>I was reading this <a href=\"http://b.atch.se/posts/non-constant-constant-expressions/#friends\" rel=\"noreferrer\">blog post section</a>, and I tried to play around with the snippet that was provided.</p>\n<pre><code>namespace N {\n// 2\nclass A {\nfriend void f(A) {} // 1\n};\n}\n</code></pre>\n<p>If I understood correctly, the definition in <code>// 1</code> will inject the name <code>f</code> where <code>// 2</code> is located.\nHowever it will only be available via argument-dependent lookup. Fine.</p>\n<p>There is a sentence in the post that caught my attention:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p id=\"so_46073787_46073787_5\">7.3.1.2/3 Namespace member definitions [namespace.memdef]p3</p>\n</blockquote>\n<p id=\"so_46073787_46073787_4\">Every name first declared in a namespace is a member of that namespace. If a friend declaration in a non-local class first declares a class, function, class template or function template the friend is a member of the innermost enclosing namespace. The friend declaration does not by itself make the name visible to unqualified lookup (3.4.1) or qualified lookup (3.4.3).</p>\n</blockquote>\n<p id=\"so_46073787_46073787_2\">Notice that nowhere is it stated that the name introduced by a friend-declaration must have any particular relation to name of the class it is declared and/or defined in, or any particular relation to the class at all (for that matter).</p>\n</blockquote>\n<p>From this, I thought the following snippet would have been valid:</p>\n<pre><code>namespace N {\nstruct A {\n};\n\nstruct B {\n  friend void f(A) {\n}\n};\n\nint main() {\n  N::A a;\n  f(a);\n}\n</code></pre>\n<p>But it's rejected by both GCC7 and Clang 4.</p>\n<blockquote>\n<p id=\"so_46073787_46073787_6\">t.cpp:19:3: error: \u2018f\u2019 was not declared in this scope</p>\n</blockquote>\n<p>The funny thing is that, when I try to call <code>f</code> with a <code>N::B</code> object, I get the following error:</p>\n<blockquote>\n<p id=\"so_46073787_46073787_7\">t.cpp:12:6: error: could not convert \u2018b\u2019 from \u2018N::B\u2019 to \u2018N::A\u2019</p>\n</blockquote>\n<p>So here's my question:</p>\n<p>Shouldn't <code>f(A)</code> be detected via ADL? Since both classes are in the namespace I don't see why this fails. I looked in the standard the section about friends, but failed to find a relevant section.</p>\n<p>I wonder in which scope <code>f(A)</code> was injected, since GCC is able to find it when I try to give the wrong argument type via calling <code>f(B)</code>.</p>\n", "AcceptedAnswerId": "46075199", "Title": "Regarding friend function definition and namespace scopes", "CreationDate": "2017-09-06T11:15:04.313", "Id": "46073787", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-09-06T11:21:16.457", "LastEditorUserId": "4116453", "LastActivityDate": "2017-09-06T13:15:37.523", "Score": "8", "OwnerUserId": "4116453", "Tags": "<c++><friend><argument-dependent-lookup>", "AnswerCount": "1"}, "46075199": {"Id": "46075199", "PostTypeId": "2", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/language/friend\" rel=\"nofollow noreferrer\"><code>cppreference/cpp/language/friend</code></a>:</p>\n<blockquote>\n<p id=\"so_46073787_46075199_0\">A name first declared in a friend declaration within class or class template <code>X</code> becomes a member of the innermost enclosing namespace of <code>X</code>, but is not accessible for lookup (except argument-dependent lookup that considers <code>X</code>) unless a matching declaration at the namespace scope is provided - see <a href=\"http://en.cppreference.com/w/cpp/language/namespace#Namespaces\" rel=\"nofollow noreferrer\">namespaces</a> for details.</p>\n</blockquote>\n<hr>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/language/namespace#Namespaces\" rel=\"nofollow noreferrer\"><code>cppreference/cpp/language/namespace</code></a>:</p>\n<blockquote>\n<p id=\"so_46073787_46075199_1\">Names introduced by friend declarations within a non-local class <code>X</code> become members of the innermost enclosing namespace of <code>X</code>, but they do not become visible to lookup (neither unqualified nor qualified) unless a matching declaration is provided at namespace scope, either before or after the class definition. Such name may be found through ADL which considers both namespaces and classes.</p>\n</blockquote>\n<hr>\n<p>This is consistent with your example - <code>f</code> takes an <code>A</code>, which is not the same type as the enclosing class.</p>\n<p>If you change your example to...</p>\n<pre><code>namespace N {\nstruct A {\n};\n\nstruct B {\n  friend void f(B) {\n}\n};\n\nint main() {\n  N::B b;\n  f(b);\n}\n</code></pre>\n<p>...it will compile.</p>\n<hr>\n<p>Related standard quote:</p>\n<blockquote>\n<p id=\"so_46073787_46075199_2\"><a href=\"http://eel.is/c++draft/class.friend#7\" rel=\"nofollow noreferrer\">$14.3 [class.friend]</a></p>\n<blockquote>\n<p id=\"so_46073787_46075199_4\">A friend of a class is a function or class that is given permission to use the private and protected member names from the class. [...] A function can be defined in a friend declaration of a class if and only if the class is a non-local class ([class.local]), the function name is unqualified, and the function has namespace scope. [...] Such a function is implicitly an inline function. <strong>A friend function defined in a class is in the (lexical) scope of the class in which it is defined.</strong> A friend function defined outside the class is not ([basic.lookup.unqual]).</p>\n</blockquote>\n</blockquote>\n</hr></hr></hr>", "LastEditorUserId": "598696", "LastActivityDate": "2017-09-06T13:15:37.523", "Score": "2", "CreationDate": "2017-09-06T12:26:00.880", "ParentId": "46073787", "CommentCount": "3", "OwnerUserId": "598696", "LastEditDate": "2017-09-06T13:15:37.523"}});