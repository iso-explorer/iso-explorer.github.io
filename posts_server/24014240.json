post_cb({"24637543": {"LastActivityDate": "2014-07-08T17:22:55.090", "CommentCount": "0", "Body": "<p>I would be tempted to make the <code>Create()</code> function a static member of Base and then just make all the derived classes friends of Base:</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/f738a131521e7e21\" rel=\"nofollow\">Run This</a></p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Base {\n\npublic:\n    virtual ~Base() {}\n\n    // Factory for Base class\n\n    template&lt;class T&gt;\n    static T* Create(int i) {\n        static_assert(std::is_base_of&lt;Base, T&gt;::value, \"Needs to be derived from Base\");\n        return new T(i);\n    }\n\n    virtual void say() = 0;\n\nprotected:\n    Base(int i): i(i) { }\n    int i;\n};\n\nclass A: public Base {\n\n    friend Base; // Allow Base to construct\n\npublic:\n    using Base::Base;\n\n    void say() { cout &lt;&lt; \"I am A and have a value of \" &lt;&lt; i &lt;&lt; endl; }\n};\n\nclass B: public Base {\n\n    friend Base; // Allow Base to construct\n\npublic:\n    using Base::Base;\n\n    void say() { cout &lt;&lt; \"I am B and have a value of \" &lt;&lt; i &lt;&lt; endl; }\n};\n\nint main(){\n    cout &lt;&lt; \"I'm creating A.\" &lt;&lt; endl;\n    A* a = Base::Create&lt;A&gt;(1);\n    a-&gt;say();\n\n    cout &lt;&lt; \"I'm creating B.\" &lt;&lt; endl;\n    B* b = Base::Create&lt;B&gt;(2);\n    b-&gt;say();\n\n    return 0;\n}\n</code></pre>\n<p><strong>EDIT:</strong> Added static_assert</p>\n<p><strong>EDIT:</strong> Added link to run code</p>\n", "CreationDate": "2014-07-08T16:56:15.297", "LastEditDate": "2014-07-08T17:22:55.090", "ParentId": "24014240", "Id": "24637543", "LastEditorUserId": "3807729", "PostTypeId": "2", "Score": "1", "OwnerUserId": "3807729"}, "bq_ids": {"n4140": {"so_24014240_24015931_0": {"length": 6, "quality": 1.0, "section_id": 485}}, "n3337": {"so_24014240_24015931_0": {"length": 6, "quality": 1.0, "section_id": 476}}}, "24014240": {"CreationDate": "2014-06-03T11:39:59.093", "ViewCount": "1353", "FavoriteCount": "1", "Id": "24014240", "AcceptedAnswerId": "24015931", "Score": "8", "Title": "C++11 Declaring factory a friend of base class", "CommentCount": "10", "Body": "<p>I'm trying to create a factory for derived classes. I only want the factory to be able to create instances of the derived classes so I've made the base constructor <code>protected</code>; the derived classes just use the base class constructors so their constructors are <code>protected</code> also.</p>\n<p>I tried to declare the factory as a friend of the base class so that it could access the <code>protected</code> constructor. When I compile using this command</p>\n<pre><code>clang++ -std=c++11 -stdlib=libc++ Friends.cpp -o Friends\n</code></pre>\n<p>I get this error:</p>\n<pre><code>Friends.cpp:23:20: error: calling a protected constructor of class 'A'\n        return new T(i);\n               ^\nFriends.cpp:42:16: note: in instantiation of function template specialization 'Create&lt;A&gt;' requested\n      here\n        A* a = Create&lt;A&gt;(1);\n           ^\nFriends.cpp:30:25: note: declared protected here\n             using Base::Base;\n                    ^\n</code></pre>\n<p>Along with a similar error for derived class <code>B</code>. </p>\n<p>I get the feeling from reading other questions on stackoverflow.com, that this isn't possible in C++11, but I'm not sure why. Can someone explain why this won't work and perhaps an alternative? </p>\n<p>Example code</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n// Forward declaration\ntemplate&lt;class T&gt; T* Create(int i);\n\nclass Base {\n    public:\n        template&lt;class T&gt;\n        friend T* Create(int);\n        virtual void say() = 0;\n\n    protected:\n        Base(int i): i(i) { }   // This won't compile\n        int i;\n};\n\n// Factory for Base class\ntemplate&lt;class T&gt;\nT* Create(int i){\n    return new T(i);\n}\n\nclass A: public Base {\n    public:\n        using Base::Base;\n        void say() { cout &lt;&lt; \"I am A and have a value of \" &lt;&lt; i &lt;&lt; endl; }\n};\n\nclass B: public Base{\n    public:\n        using Base::Base;\n        void say() { cout &lt;&lt; \"I am B and have a value of \" &lt;&lt; i &lt;&lt; endl; }\n};\n\nint main(){\n    cout &lt;&lt; \"I'm creating A.\" &lt;&lt; endl;\n    A* a = Create&lt;A&gt;(1);\n    a-&gt;say();\n\n    cout &lt;&lt; \"I'm creating B.\" &lt;&lt; endl;\n    B* b = Create&lt;B&gt;(2);\n    b-&gt;say();\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><inheritance><c++11><factory><friend>", "LastActivityDate": "2014-07-08T17:22:55.090", "PostTypeId": "1", "AnswerCount": "3", "OwnerUserId": "633318"}, "24015335": {"LastActivityDate": "2014-06-03T12:35:48.913", "CommentCount": "3", "Body": "<p>Friendship <a href=\"https://stackoverflow.com/questions/3561648/why-does-c-not-allow-inherited-friendship\">does not go down the inheritance tree</a>. Create is friend of Base, and therefore can not access the protected A::A(int) and B::B(int).</p>\n<p>Possible solutions include:</p>\n<ul>\n<li>Make new friendships (A, B and further child classes should be friends of <code>Create</code>)</li>\n<li>Use public constructors as mentioned by @Snps</li>\n<li>Use an external class that only <code>Base</code> (and therefore also its friend, <code>Create</code>) can create and the rest can only copy. Idea from <a href=\"https://stackoverflow.com/questions/23993264/c-using-a-key-class-as-a-key-of-access-for-a-group-of-classes\">here</a>.</li>\n</ul>\n<p>Code for last solution:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n// Forward declaration\ntemplate&lt;class T&gt; T* Create(int i);\n\nclass Base {\n\n        class AccessKey {\n            friend class Base;\n            AccessKey() {};\n        public:\n            AccessKey(const AccessKey&amp; o) {}\n\n        };\n        static AccessKey getAccessKey() { return AccessKey(); }\n\n    public:\n        template&lt;class T&gt;\n        friend T* Create(int);\n        virtual void say() = 0;\n\n        Base(int i, AccessKey k): i(i) { }   // This can be public as it can be called without and AccessKey object\n\n    protected:\n        int i;\n};\n\n// Factory for Base class\ntemplate&lt;class T&gt;\nT* Create(int i){\n    return new T(i, Base::getAccessKey());\n}\n\nclass A: public Base {\n    public:\n        using Base::Base;\n        void say() { cout &lt;&lt; \"I am A and have a value of \" &lt;&lt; i &lt;&lt; endl; }\n};\n\nclass B: public Base{\n    public:\n        using Base::Base;\n        void say() { cout &lt;&lt; \"I am B and have a value of \" &lt;&lt; i &lt;&lt; endl; }\n};\n\nint main(){\n    cout &lt;&lt; \"I'm creating A.\" &lt;&lt; endl;\n    A* a = Create&lt;A&gt;(1);\n    a-&gt;say();\n\n    cout &lt;&lt; \"I'm creating B.\" &lt;&lt; endl;\n    B* b = Create&lt;B&gt;(2);\n    b-&gt;say();\n\n    return 0;\n}\n</code></pre>\n", "CreationDate": "2014-06-03T12:35:48.913", "LastEditDate": "2017-05-23T12:09:44.893", "ParentId": "24014240", "Id": "24015335", "LastEditorUserId": "-1", "PostTypeId": "2", "Score": "3", "OwnerUserId": "680982"}, "24015931": {"LastActivityDate": "2014-06-03T14:30:00.753", "CommentCount": "4", "Body": "<p>When you inherit a constructor from a base class it retains the access of the original constructor, regardless of where you place the <code>using</code> declaration in the derived class.</p>\n<p>From <em>\u00a712.9/4 [class.inhctor]</em></p>\n<blockquote>\n<p id=\"so_24014240_24015931_0\">A constructor so declared has the same access as the corresponding constructor in <code>X</code>. ...</p>\n</blockquote>\n<p>You can fix the error if you explicitly add constructors to derived classes instead of inheriting them from <code>Base</code>.</p>\n<pre><code>A(int i) : Base(i) {}\n</code></pre>\n<p>and </p>\n<pre><code>B(int i) : Base(i) {}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/5f03ba73e7b6f7c1\" rel=\"nofollow\">Live demo</a></p>\n<p>Another solution, of course, is to make <code>Base</code>'s constructor <code>public</code>. You could also make its destructor <code>protected</code>, but it's not necessary since the class cannot be instantiated anyway due to the pure virtual member function.</p>\n<pre><code>class Base {\n    public:\n        template&lt;class T&gt;\n        friend T* Create(int);\n        virtual void say() = 0;\n\n        Base(int i): i(i) { }   // This won't compile\n        int i;\n    protected:\n        ~Base() {}\n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/bc566216cca71cc5\" rel=\"nofollow\">Live demo</a></p>\n", "CreationDate": "2014-06-03T13:02:30.050", "LastEditDate": "2014-06-03T14:30:00.753", "ParentId": "24014240", "Id": "24015931", "LastEditorUserId": "241631", "PostTypeId": "2", "Score": "5", "OwnerUserId": "241631"}});