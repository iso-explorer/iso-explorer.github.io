post_cb({"32812663": {"CommentCount": "3", "AcceptedAnswerId": "32813409", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-09-27T20:46:03.170", "LastActivityDate": "2015-09-28T19:50:44.480", "LastEditDate": "2015-09-28T01:34:44.487", "ViewCount": "520", "FavoriteCount": "4", "Title": "In class static const ODR", "Id": "32812663", "Score": "8", "Body": "<p>I am a bit confused by the <code>static</code> in-class initialization of a <code>const</code> member. For example, in the code below:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Foo\n{\n    const static int n = 42;\n};\n\n// const int Foo::n; // No ODR\n\nvoid f(const int&amp; param)\n{\n    std::cout &lt;&lt; param &lt;&lt; std::endl;\n}\n\nint g(const int&amp; param)\n{\n    return param;\n}\n\ntemplate&lt;int N&gt;\nvoid h()\n{\n    std::cout &lt;&lt; N &lt;&lt; std::endl;\n}\n\nint main()\n{\n    // f(Foo::n); // linker error, both g++/clang++\n    std::cout &lt;&lt; g(Foo::n) &lt;&lt; std::endl; // OK in g++ only with -O(1,2 or 3) flag, why?!\n    h&lt;Foo::n&gt;(); // this should be fine\n}\n</code></pre>\n<p><kbd><a href=\"http://coliru.stacked-crooked.com/a/1af2cb53dc649007\" rel=\"nofollow\">Live example</a></kbd></p>\n<p>I do not define <code>Foo::n</code> (the line is commented). So, I expect the call <code>f(Foo::n)</code> to fail at link time, and indeed it does. However, the following line <code>std::cout &lt;&lt; g(Foo::n) &lt;&lt; std::endl;</code> compiles and links fine only by gcc (clang still emits a linker error) whenever I use an optimization flag such as <code>-O1/2/3</code>. </p>\n<ol>\n<li>Why does gcc (tried with gcc5.2.0 and gcc 4.9.3) compile <strong>and link</strong> the code when the optimization is turned on? </li>\n<li>And am I correct to say that <strong>the only usage of in-class static const members is in constant expressions</strong>, such as template parameters like in the <code>h&lt;Foo::n&gt;</code> call, in which case the code should link?</li>\n</ol>\n", "Tags": "<c++><gcc><linker><one-definition-rule>", "OwnerUserId": "3093378", "AnswerCount": "4"}, "32812827": {"ParentId": "32812663", "CommentCount": "2", "Body": "<p>I suppose that the compiler performs the following actions during the optimization:</p>\n<ul>\n<li><p>The value <code>const static int n</code> is inlined everywhere. No memory is allocated for the variable <code>n</code>, references to it becomes invalid. The function <code>f()</code> need a reference to <code>n</code> so the program is not compiled.</p></li>\n<li><p>The function <code>g</code> is short and simple. It is effectively inlined and optimized. After the optimization, the function <code>g</code> does not need a reference to <code>n</code>, it just returns constant value 42.</p></li>\n</ul>\n<p>The solution is to define the variable outside the class:</p>\n<pre><code>struct Foo\n{\n    const static int n;\n};\n\nconst int Foo::n = 42;\n</code></pre>\n", "OwnerUserId": "5380314", "PostTypeId": "2", "Id": "32812827", "Score": "4", "CreationDate": "2015-09-27T21:05:23.507", "LastActivityDate": "2015-09-27T21:05:23.507"}, "32813409": {"ParentId": "32812663", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>ODR violations do not require a diagnostic, from the draft C++ standard standard section <code>3.2</code> [basic.def.odr] (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_32812663_32813409_0\">Every program shall contain exactly one definition of every non-inline\n  function or variable that is odr-used in that program; <strong>no diagnostic\n  required</strong>.</p>\n</blockquote>\n<p>So inconsistent behavior at different optimization levels is perfectly conformant behavior. </p>\n<p>Informally a variable is <a href=\"http://en.cppreference.com/w/cpp/language/definition#ODR-use\" rel=\"nofollow noreferrer\">odr-used</a> if:</p>\n<blockquote>\n<p id=\"so_32812663_32813409_1\">its address is taken, or a reference is bound to it, and a function is odr-used if a function call to it is made or its address is taken. If an object or a function is odr-used, its definition must exist somewhere in the program; a violation of that is a link-time error.</p>\n</blockquote>\n<p>So both <code>f</code> and <code>g</code> will be odr-uses and require a definition.</p>\n<p>The relevant C++14 quote on odr-use would be from section <em>[basic.def.odr]</em>:</p>\n<blockquote>\n<p id=\"so_32812663_32813409_2\">A variable x whose name appears as a potentially-evaluated expression ex is <strong>odr-used by ex unless</strong> applying\n  the lvalue-to-rvalue conversion (4.1) to x yields a constant expression (5.19) that does not invoke any nontrivial\n  functions and, <strong>if x is an object, ex is an element of the set of potential results of an expression e,\n  where either the lvalue-to-rvalue conversion (4.1) is applied to e, or e is a discarded-value expression</strong> [...]</p>\n</blockquote>\n<p>The wording in C++11 is similar, the changes from C++11 to C++14 are reflected in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#712\" rel=\"nofollow noreferrer\">defect report 712</a>.</p>\n<p>Before C++11 it is <a href=\"https://stackoverflow.com/questions/31565836/does-potentially-evaluated-means-the-same-as-odr-used-in-c03\">a bit more complicated but in principle the same for this case</a>.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:59:37.443", "Id": "32813409", "Score": "4", "CreationDate": "2015-09-27T22:14:54.457", "LastActivityDate": "2015-09-28T19:50:44.480"}, "32812749": {"ParentId": "32812663", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>There is no definition at all. GCC 4.9.2 doesn't compile and link that with any flags.</p>\n<p>Note, that:</p>\n<pre><code>const static int n = 42;\n</code></pre>\n<p>is a <em>declaration</em> and <em>initializer</em>, but not a <em>definition</em>.</p>\n", "OwnerUserId": "2842166", "LastEditorUserId": "1708801", "LastEditDate": "2015-09-28T09:18:24.997", "Id": "32812749", "Score": "2", "CreationDate": "2015-09-27T20:56:25.707", "LastActivityDate": "2015-09-28T09:18:24.997"}, "bq_ids": {"n4140": {"so_32812663_32813409_0": {"section_id": 7041, "quality": 1.0, "length": 12}, "so_32812663_32813409_2": {"section_id": 7040, "quality": 0.9354838709677419, "length": 29}}, "n3337": {"so_32812663_32813409_0": {"section_id": 6786, "quality": 1.0, "length": 12}}, "n4659": {"so_32812663_32813409_0": {"section_id": 8538, "quality": 1.0, "length": 12}, "so_32812663_32813409_2": {"section_id": 8537, "quality": 0.9354838709677419, "length": 29}}}, "32813081": {"ParentId": "32812663", "CommentCount": "0", "Body": "<p>Formally, ODR violations are <em>undefined behaviour</em>, so the compiler may exhibit any behaviour it likes. That's why the behaviour changes with optimization level and compiler- the compiler has no obligation to maintain a particular behaviour.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "32813081", "Score": "4", "CreationDate": "2015-09-27T21:33:51.427", "LastActivityDate": "2015-09-27T21:33:51.427"}});