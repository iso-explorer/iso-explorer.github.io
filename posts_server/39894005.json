post_cb({"39894005": {"CommentCount": "5", "ViewCount": "66", "PostTypeId": "1", "ClosedDate": "2016-10-06T11:03:03.957", "LastEditorUserId": "464581", "CreationDate": "2016-10-06T10:49:24.957", "LastActivityDate": "2016-10-06T22:49:52.523", "Title": "What effect does a const have for effect before the return type in a function?", "AcceptedAnswerId": "39894089", "LastEditDate": "2016-10-06T10:54:26.297", "Id": "39894005", "Score": "-2", "Body": "<p>I have the following code:</p>\n<pre><code>const string getConstString()\n{\n    return \"MyConstString\";\n}\n\nint main()\n{\n    string str1 = getConstString();\n    cout &lt;&lt; str1 &lt;&lt; endl;\n}\n</code></pre>\n<p>What effect does the const keyword have here?</p>\n", "Tags": "<c++>", "OwnerUserId": "1059992", "AnswerCount": "1"}, "39894089": {"ParentId": "39894005", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2016-10-06T10:53:44.347", "Score": "4", "LastEditorUserId": "464581", "LastEditDate": "2016-10-06T22:49:52.523", "Id": "39894089", "OwnerUserId": "464581", "Body": "<p>One notable effect is that you can't <em>move</em> from a <code>const</code> result.</p>\n<p>Before C++ gained direct support for move semantics in C++11, a not uncommon advice was to make return types <code>const</code> in order force client code to only use the result in meaningful ways, as a value (and not as a mutable object).</p>\n<p>After C++11 the advice is the opposite: don't make a return value <code>const</code>, because that prevents moving.</p>\n<hr>\n<p>Example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nauto m() -&gt; string { return {}; }\nauto c() -&gt; const string { return {}; }\n\nvoid check( string&amp;&amp; ) { cout &lt;&lt; \"mutable\\n\"; }\nvoid check( string const&amp;&amp; ) { cout &lt;&lt; \"const\\n\"; }\n\nauto main()\n    -&gt; int\n{\n    check( m() );\n    check( c() );\n}\n</code></pre>\n<p>This outputs</p>\n<pre>\nmutable\nconst\n</pre>\n<p>\u2026 showing that the <code>const</code> on the result for function <code>c</code>, is very much noticeable to the calling code.</p>\n<hr>\n<p>With <code>int</code> instead of <code>string</code> the output is instead 2 \u00d7 \u201c<code>mutable</code>\u201d, showing a subtle and surprising difference in treatment of built-in types and class types: that top-level <code>const</code> is ignored for a result that is of a built-in type such as <code>int</code>.</p>\n<i>C++11 \u00a73.10/4 (basic.lval/4):</i>\n<blockquote>\n<p id=\"so_39894005_39894089_0\"><strong>\u201d</strong> Class prvalues can have cv-qualified types; non-class prvalues always have cv-unqualified types.</p>\n</blockquote>\n<p>It's worth noting that this is a rule for <em>the type of prvalue expressions</em>, and not a rewrite rule for function declarations like the decay to pointer type of an array or function type formal argument. I.e., the type of the function is not affected. The <code>const</code> is there still in the type:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;      // std::is_same\nusing namespace std;\n\n#define STATIC_ASSERT( e ) static_assert( e, #e \" &lt;- is needed.\" )\n\nauto c() -&gt; const int{ return {}; }\n\nauto main()\n    -&gt; int\n{\n    // Function type:\n    STATIC_ASSERT(( is_same&lt;decltype( c ), auto()-&gt;const int&gt;::value ));\n    STATIC_ASSERT(( not is_same&lt;decltype( c ), auto()-&gt;int&gt;::value ));\n\n    // prvalue type:\n    STATIC_ASSERT(( is_same&lt;decltype( c() ), int&gt;::value ));\n    STATIC_ASSERT(( not is_same&lt;decltype( c() ), int const&gt;::value ));\n}\n</code></pre>\n</hr></hr>", "LastActivityDate": "2016-10-06T22:49:52.523"}, "bq_ids": {"n4140": {"so_39894005_39894089_0": {"section_id": 7233, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_39894005_39894089_0": {"section_id": 6977, "quality": 1.0, "length": 12}}, "n4659": {"so_39894005_39894089_0": {"section_id": 8746, "quality": 0.9166666666666666, "length": 11}}}});