post_cb({"bq_ids": {"n4140": {"so_26217260_26217456_2": {"length": 11, "quality": 0.7857142857142857, "section_id": 6946}, "so_26217260_26217456_1": {"length": 16, "quality": 0.7619047619047619, "section_id": 6952}}, "n3337": {"so_26217260_26217456_2": {"length": 11, "quality": 0.7857142857142857, "section_id": 6694}, "so_26217260_26217456_1": {"length": 16, "quality": 0.7619047619047619, "section_id": 6699}}, "n4659": {"so_26217260_26217456_2": {"length": 11, "quality": 0.7857142857142857, "section_id": 8443}, "so_26217260_26217456_1": {"length": 11, "quality": 0.5238095238095238, "section_id": 8449}}}, "26217456": {"Id": "26217456", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_26217260_26217456_0\">N3337 [except.nested]/5,6</p>\n<pre><code>[[noreturn]] template &lt;class T&gt; void throw_with_nested(T&amp;&amp; t);\n</code></pre>\n<p id=\"so_26217260_26217456_1\">Let <code>U</code> be <code>remove_reference&lt;T&gt;::type</code>. <br> 5. Requires: <code>U</code> shall be\n  <code>CopyConstructible</code>. <br> 6. Throws: if <code>U</code> is a non-union class type not\n  derived from <code>nested_exception</code>, an exception of un-specified type that is publicly derived from both <code>U</code> and <code>nested_exception</code> and constructed from <code>std::forward&lt;T&gt;(t)</code>, otherwise <code>std::forward&lt;T&gt;(t)</code>.</br></br></p>\n</blockquote>\n<p>Also consider that <code>nested_exception</code> is polymorphic as it has a virtual destructor ([except.nested]/2):</p>\n<blockquote>\n<p id=\"so_26217260_26217456_2\">[ Note: <code>nested_exception</code> has a virtual destructor to make it a\n  polymorphic class. Its presence can be tested for with <code>dynamic_cast</code>.\n  \u2014 end note ]</p>\n</blockquote>\n<p>The  exception-type that is actually thrown is always polymorphic. <code>U</code> doesn't have to be, though - just <code>CopyConstructible</code>, as noted by the Requires-section.</p>\n<p>So libstdc++ has an invalid implementation. It should internally specialize for types for which <code>is_base_of&lt;nested_exception, U&gt;::value</code> is <code>false</code>.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-10-06T13:45:23.470", "Score": "3", "CreationDate": "2014-10-06T13:37:37.730", "ParentId": "26217260", "CommentCount": "2", "OwnerUserId": "3647361", "LastEditDate": "2014-10-06T13:45:23.470"}, "26217260": {"ViewCount": "126", "Body": "<p>consider the following (I think illegal) code:</p>\n<pre><code>#include &lt;exception&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n    try {\n        try {\n            throw string (\"x\");\n        }\n        catch(string&amp; x)\n        {\n            throw_with_nested(string(\"xx\"));\n        }\n    }\n    catch(...)\n    {\n        auto ep = current_exception();\n    }\n\n    return 0;\n}\n</code></pre>\n<p>with clang++ compiled against libc++ this code compiles.</p>\n<p>with g++ against libstdc++:</p>\n<pre><code>In file included from /usr/local/gcc-4.8.1/include/c++/4.8.1/exception:153:0,\n                 from main.cpp:1:\n/usr/local/gcc-4.8.1/include/c++/4.8.1/bits/nested_exception.h: In instantiation of \u00e2\ufffd\ufffdstatic const std::nested_exception* std::__get_nested_helper&lt;_Ex&gt;::_S_get(const _Ex&amp;) [with _Ex = std::basic_string&lt;char&gt;]\u00e2\ufffd\ufffd:\n/usr/local/gcc-4.8.1/include/c++/4.8.1/bits/nested_exception.h:104:51:   required from \u00e2\ufffd\ufffdconst std::nested_exception* std::__get_nested_exception(const _Ex&amp;) [with _Ex = std::basic_string&lt;char&gt;]\u00e2\ufffd\ufffd\n/usr/local/gcc-4.8.1/include/c++/4.8.1/bits/nested_exception.h:138:38:   required from \u00e2\ufffd\ufffdvoid std::throw_with_nested(_Ex) [with _Ex = std::basic_string&lt;char&gt;]\u00e2\ufffd\ufffd\nmain.cpp:15:43:   required from here\n/usr/local/gcc-4.8.1/include/c++/4.8.1/bits/nested_exception.h:90:59: error: cannot dynamic_cast \u00e2\ufffd\ufffd&amp; __ex\u00e2\ufffd\ufffd (of type \u00e2\ufffd\ufffdconst class std::basic_string&lt;char&gt;*\u00e2\ufffd\ufffd) to type \u00e2\ufffd\ufffdconst class std::nested_exception*\u00e2\ufffd\ufffd (source type is not polymorphic)\n       { return dynamic_cast&lt;const nested_exception*&gt;(&amp;__ex); }\n                                                           ^\n</code></pre>\n<p>As I understand it, <code>std::throw_with_nested&lt;T&gt;</code> requires that T is polymorphic, and std::string is not polymorphic. So libstdc++ is doing the Right Thing(tm) here. </p>\n<p>Anyone have anything to offer here?</p>\n", "AcceptedAnswerId": "26217456", "Title": "libstdc++ std::throw_with_nested() requires polymorphic types", "CreationDate": "2014-10-06T13:27:37.133", "LastActivityDate": "2014-10-06T14:17:17.167", "CommentCount": "5", "LastEditDate": "2014-10-06T14:17:17.167", "PostTypeId": "1", "Tags": "<c++><gcc><c++11><clang><libc++>", "Id": "26217260", "AnswerCount": "1", "Score": "0", "OwnerUserId": "2015579", "ClosedDate": "2014-10-06T13:37:59.267", "LastEditorUserId": "2756719"}});