post_cb({"36040814": {"ViewCount": "484", "Body": "<p><code>dlopen()</code> is a C function used for dynamically loading shared libraries at runtime. The pattern, in case you're not familiar, is thus:</p>\n<ul>\n<li>Call <code>dlopen(\"libpath\", flag)</code> to get a <code>void *handle</code> to the library</li>\n<li>Call <code>dlsym(handle, \"object_name\")</code> to get a <code>void *object</code> to the thing you want from the library</li>\n<li>Do what you want with <code>object</code></li>\n<li>Call <code>dlclose (handle)</code> to unload the library.</li>\n</ul>\n<p>This is, in C++, a perfect use-case for the so-called <em>aliasing constructor</em> of <code>std::shared_ptr</code>. The pattern becomes:</p>\n<ul>\n<li>Construct a <code>std::shared_ptr&lt;void&gt; handle</code> from <code>dlopen(\"libpath\", flag)</code> that will call <code>dlclose()</code> when its destructor is called</li>\n<li>Construct a <code>std::shared_ptr&lt;void&gt; object</code> from <code>handle</code> and <code>dlsym(handle, \"object_name\")</code></li>\n<li>Now we can pass <code>object</code> wherever we want, and completely forget about <code>handle</code>; when <code>object</code>'s destructor is called, whenever that happens to be, <code>dlclose()</code> will be called automagically</li>\n</ul>\n<p>Brilliant pattern, and it works beautifully. One small problem, though. The pattern above requires a cast from <code>void*</code> to <code>whatever_type_object_is*</code>. If <code>\"object_name\"</code> refers to a function (which most of the time it does, considering the use-case), this is undefined behavior.</p>\n<p>In C, there is a hack to get around this. From the <code>dlopen</code> man page:</p>\n<pre><code>// ...\nvoid *handle;    \ndouble (*cosine)(double);\n// ...\nhandle = dlopen(\"libm.so\", RTLD_LAZY);\n// ...\n\n/* Writing: cosine = double (*)(double)) dlsym(handle, \"cos\");\n   would seem more natural, but the C99 standard leaves\n   casting from \"void *\" to a function pointer undefined.\n   The assignment used below is the POSIX.1-2003 (Technical\n   Corrigendum 1) workaround; see the Rationale for the\n   POSIX specification of dlsym(). */\n\n*(void **) (&amp;cosine) = dlsym(handle, \"cos\");\n// ...\n</code></pre>\n<p>which obviously works just fine, in C. But is there an easy way to do this with <code>std::shared_ptr</code>?</p>\n", "AcceptedAnswerId": "36043591", "Title": "std::shared_ptr and dlopen(), avoiding undefined behavior", "CreationDate": "2016-03-16T15:57:49.867", "Id": "36040814", "CommentCount": "6", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-03-16T19:04:47.343", "Score": "8", "OwnerUserId": "2209270", "Tags": "<c++><c++11><shared-libraries><shared-ptr><undefined-behavior>", "AnswerCount": "3"}, "36041699": {"Id": "36041699", "PostTypeId": "2", "Body": "<p>You can make a struct to have your pointer to function and handle to library:</p>\n<pre><code>template&lt;typename T&gt;\nstruct dlsymbol {\n   dlsymbol( const std::string &amp;name, std::shared_ptr&lt;void&gt; handle ) :\n      m_handle( std::move( handle ) )\n   {\n       *(void **)(&amp;m_func) = dlsym( handle.get(), name.c_str );\n   }\n\n   std::shared_ptr&lt;void&gt; m_handle;\n   T *m_func;\n};\n\nauto cosine = std::make_shared&lt;dlsymbol&lt;double(double)&gt;&gt;( \"cos\", handle );\nauto d = cosine-&gt;m_func( 1.0 );\n</code></pre>\n<p>I did not compile it, but I think it is sufficient to show the idea.</p>\n", "LastActivityDate": "2016-03-16T16:36:45.387", "CommentCount": "0", "CreationDate": "2016-03-16T16:36:45.387", "ParentId": "36040814", "Score": "0", "OwnerUserId": "432358"}, "bq_ids": {"n4140": {"so_36040814_36043591_1": {"length": 32, "quality": 0.9411764705882353, "section_id": 6047}}, "n3337": {"so_36040814_36043591_1": {"length": 32, "quality": 0.9411764705882353, "section_id": 5815}}, "n4659": {"so_36040814_36043591_1": {"length": 32, "quality": 0.9411764705882353, "section_id": 7546}}}, "36043866": {"Id": "36043866", "PostTypeId": "2", "Body": "<p>Something like this?</p>\n<pre><code>struct dlib\n{\npublic:\n  template&lt;class T&gt;\n  std::shared_ptr&lt;T&gt; sym(const char* name) const {\n    if (!handle) return {};\n    void* sym = dlsym(handle-&gt;get(), name);\n    if (!sym) return {};\n    return {reinterpret_cast&lt;T*&gt;(sym), handle};\n  }\n  // returns a smart pointer pointing at a function for name:\n  template&lt;class Sig&gt;\n  std::shared_ptr&lt;Sig*&gt; pfunc(const char* name) const {\n    if (!handle) return {};\n    void* sym = dlsym(handle-&gt;get(), name);\n    if (!sym) return {};\n    Sig* ret = 0;\n    // apparently approved hack to convert void* to function pointer\n    // in some silly compilers:\n    *reinterpret_cast&lt;void**&gt;(&amp;ret) = sym;\n    return {ret, handle};\n  }\n  // returns a std::function&lt;Sig&gt; for a name:\n  template&lt;class Sig&gt;\n  std::function&lt;Sig&gt; function(const char* name) const {\n    // shared pointer to a function pointer:\n    auto pf = pfunc(name);\n    if (!pf) return {};\n    return [pf=std::move(pf)](auto&amp;&amp;...args)-&gt;decltype(auto){\n      return (*pf)(decltype(args)(args)...);\n    };\n  }\n  dlib() = default;\n  dlib(dlib const&amp;)=default;\n  dlib(dlib &amp;&amp;)=default;\n  dlib&amp; operator=(dlib const&amp;)=default;\n  dlib&amp; operator=(dlib &amp;&amp;)=default;\n\n  dlib(const char* name, int flag) {\n    void* h = dlopen(name, flag);\n    if (h)\n    {\n      // set handle to cleanup the dlopen:\n      handle=std::shared_ptr&lt;void&gt;(\n        h,\n        [](void* handle){\n          int r = dlclose(handle);\n          ASSERT(r==0);\n        }\n      );\n    }\n  }\n  explicit operator bool() const { return (bool)handle; }\nprivate:\n  std::shared_ptr&lt;void&gt; handle;\n};\n</code></pre>\n<p>I doubt that hack is needed.  As @sbabbi noted, the round-trip to <code>void*</code> is conditionally supported.  On a system using <code>dlsym</code> to return function pointers, it better be supported.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2016-03-16T19:04:47.343", "Score": "1", "CreationDate": "2016-03-16T18:18:08.173", "ParentId": "36040814", "CommentCount": "2", "OwnerUserId": "1774667", "LastEditDate": "2016-03-16T19:04:47.343"}, "36043591": {"Id": "36043591", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_36040814_36043591_0\">The pattern above requires a cast from void* to whatever_type_object_is*. If \"object_name\" refers to a function (which most of the time it does, considering the use-case), this is undefined behavior.</p>\n</blockquote>\n<p>Well this is not entirely true, at least in C++ it is just conditionally-supported.</p>\n<p><strong>5.2.10.8</strong> says:</p>\n<blockquote>\n<p id=\"so_36040814_36043591_1\">Converting a function pointer to an object pointer type or vice versa is conditionally-supported. The meaning\n  of such a conversion is implementation-defined, except that if an implementation supports conversions in\n  both directions, converting a prvalue of one type to the other type and back, possibly with different cvqualification,\n  shall yield the original pointer value.</p>\n</blockquote>\n<p>So assuming that what <code>dlsym</code> does internally is casting a function pointer to a <code>void*</code>, I believe that you are ok if you just cast it back to a function pointer.</p>\n", "LastActivityDate": "2016-03-16T18:05:39.027", "CommentCount": "2", "CreationDate": "2016-03-16T18:05:39.027", "ParentId": "36040814", "Score": "4", "OwnerUserId": "666785"}});