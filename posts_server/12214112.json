post_cb({"12214231": {"Id": "12214231", "PostTypeId": "2", "Body": "<p>This works because <code>[basic.def.odr]/5</code> explicitly allowed templates to be duplicated:</p>\n<blockquote>\n<p id=\"so_12214112_12214231_0\">There can be more than one definition of a class type (Clause 9), enumeration type (7.2), inline function with external linkage (7.1.2), class template (Clause 14), non-static function template (14.5.6), static data member of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for which some template parameters are not specified (14.7, 14.5.5) in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. ...</p>\n</blockquote>\n<p>The requirements are quite lengthy, so I won't duplicate them here, but essentially they state that each duplicate definition must be identical (otherwise the program has undefined behaviour).</p>\n", "LastActivityDate": "2012-08-31T11:17:14.050", "CommentCount": "0", "CreationDate": "2012-08-31T11:17:14.050", "ParentId": "12214112", "Score": "12", "OwnerUserId": "485561"}, "bq_ids": {"n4140": {"so_12214112_12214231_0": {"length": 48, "quality": 0.8888888888888888, "section_id": 7043}}, "n3337": {"so_12214112_12214231_0": {"length": 48, "quality": 0.8888888888888888, "section_id": 6788}}, "n4659": {"so_12214112_12214231_0": {"length": 48, "quality": 0.8888888888888888, "section_id": 8540}}}, "12214112": {"ViewCount": "1689", "Body": "<p>Consider the following construct:</p>\n<pre><code>//! Templated singleton.\n/*!\n    Template wrapper enforcing the singleton behavior.\n*/\ntemplate &lt;class T&gt;\nclass TSingleton\n{\nprivate:    \n    //! Singleton instance pointer.\n    static T* instance;\n    //! private constructor.\n    TSingleton() { }\n    //! private empty copy constructor.\n    TSingleton(const TSingleton&lt;T&gt;&amp; sourceObject) {}\n\npublic:\n    //! Static singleton instance getter.\n    static T* GetInstance()\n    {\n        if (instance == 0)\n            instance = new T();\n        return instance;\n    }\n\n};\n\ntemplate &lt;class T&gt; T* TSingleton&lt;T&gt;::instance = 0;\n</code></pre>\n<p>This template class and the definition of the static instance are written in the same header file. For a non-template class, this <em>causes a link-time error due to multiple symbols being defined for the instance static member</em>. It seems intuitive for this to happen with templates as well, thus one must separate the definition and put it in a .cpp file. But templates are usually declared and defined in header-like files. <strong><em>What is it that allows this syntax to be valid and functional for template classes?</em></strong> </p>\n<p>There a <a href=\"http://en.wikipedia.org/wiki/One_definition_rule\">wikipedia</a> link on this, but it does not provide a clear explanation on what happens in case of template classes.</p>\n", "AcceptedAnswerId": "12214231", "Title": "C++ templates and static members - definition in the header", "CreationDate": "2012-08-31T11:09:03.613", "Id": "12214112", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2012-08-31T11:17:14.050", "Score": "7", "OwnerUserId": "1256811", "Tags": "<c++><templates><static-members>", "AnswerCount": "1"}});