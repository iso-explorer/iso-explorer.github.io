post_cb({"70880": {"CommentCount": "0", "AcceptedAnswerId": "70905", "PostTypeId": "1", "LastEditorUserId": "4618308", "CreationDate": "2008-09-16T10:01:00.747", "LastActivityDate": "2016-12-24T01:40:43.023", "AnswerCount": "10", "LastEditDate": "2016-12-24T01:40:43.023", "ViewCount": "1423", "FavoriteCount": "1", "Title": "deleting a buffer through a different type of pointer?", "Id": "70880", "Score": "10", "Body": "<p>Say I have the following C++:</p>\n<pre><code>char *p = new char[cb];\nSOME_STRUCT *pSS = (SOME_STRUCT *) p;\ndelete pSS;\n</code></pre>\n<p>Is this safe according to the C++ standard? Do I need to cast back to a <code>char*</code> and then use <code>delete[]</code>? I know it'll work in most C++ compilers, because it's plain-ordinary-data, with no destructors. Is it guaranteed to be safe?</p>\n", "Tags": "<c++><pointers><memory-management>", "OwnerUserId": "8446", "OwnerDisplayName": "Roger Lipscombe"}, "70910": {"ParentId": "70880", "CommentCount": "0", "Body": "<p>While this <em>should</em> work, I don't think you can guarantee it to be safe because the SOME_STRUCT is not a char* (unless it's merely a typedef).</p>\n<p>Additionally, since you're using different types of references, if you continue to use the *p access, and the memory has been deleted, you will get a runtime error.</p>\n", "OwnerUserId": "4418", "Id": "70910", "PostTypeId": "2", "OwnerDisplayName": "origamigumby", "Score": "0", "CreationDate": "2008-09-16T10:07:19.577", "LastActivityDate": "2008-09-16T10:07:19.577"}, "70904": {"CommentCount": "0", "CreationDate": "2008-09-16T10:06:32.527", "LastEditorUserId": "-1", "LastActivityDate": "2008-09-16T10:13:46.037", "ParentId": "70880", "PostTypeId": "2", "LastEditorDisplayName": "Daniel James", "LastEditDate": "2017-05-23T11:46:01.567", "Id": "70904", "Score": "6", "Body": "<p>No, it's undefined behaviour - a compiler could plausibly do something different, and as the C++ FAQ entry that <a href=\"https://stackoverflow.com/questions/70880/deleting-a-buffer-through-a-different-type-of-pointer#70905\">thudbang</a>  linked to says, <code>operator delete[]</code> might be overloaded to do something different to <code>operator delete</code>. You can sometimes get away with it, but it's also good practice to get into the habit of matching delete[] with new[] for the cases where you can't.</p>\n", "OwnerUserId": "2434", "OwnerDisplayName": "Daniel James"}, "71090": {"ParentId": "70880", "CommentCount": "0", "Body": "<p>This will work OK if the memory being pointed to <strong>and</strong> the pointer you are pointing with are both POD. In this case, no destructor would be called anyhow, and the memory allocator does not know or care about the type stored within the memory.</p>\n<p>The only case this is OK with non-POD types, is if the pointee is a subtype of the pointer, (e.g. You are pointing at a Car with a Vehicle*) and the pointer's destructor has been declared virtual.</p>\n", "OwnerUserId": "11521", "PostTypeId": "2", "Id": "71090", "Score": "0", "CreationDate": "2008-09-16T10:38:24.387", "LastActivityDate": "2008-09-16T10:38:24.387"}, "72444": {"ParentId": "70880", "CommentCount": "0", "Body": "<p>I've changed the code to use malloc/free. While I know how MSVC implements new/delete for plain-old-data (and SOME_STRUCT in this case was a Win32 structure, so simple C), I just wanted to know if it was a portable technique.</p>\n<p>It's not, so I'll use something that is.</p>\n", "OwnerUserId": "8446", "Id": "72444", "PostTypeId": "2", "OwnerDisplayName": "Roger Lipscombe", "Score": "0", "CreationDate": "2008-09-16T13:51:53.673", "LastActivityDate": "2008-09-16T13:51:53.673"}, "bq_ids": {"n4140": {"so_70880_70941_0": {"section_id": 6106, "quality": 0.7857142857142857, "length": 77}}, "n3337": {"so_70880_70941_0": {"section_id": 5872, "quality": 0.7857142857142857, "length": 77}}, "n4659": {"so_70880_70941_0": {"section_id": 7603, "quality": 0.7857142857142857, "length": 77}}}, "70941": {"ParentId": "70880", "CommentCount": "0", "Body": "<p>C++ Standard [5.3.5.2] declares:</p>\n<blockquote>\n<p id=\"so_70880_70941_0\">If the operand has a class type, the operand is converted to a pointer type by calling the above-mentioned conversion\n  function, and the converted operand is used in place of the original operand for the remainder of this section. In either\n  alternative, the value of the operand of delete may be a null pointer value. <strong>If it is not a null pointer value, in the first\n  alternative (delete object), the value of the operand of delete shall be a pointer to a non-array object or a pointer to a\n  subobject (1.8) representing a base class of such an object (clause 10). If not, the behavior is undefined. In the second\n  alternative (delete array), the value of the operand of delete shall be the pointer value which resulted from a previous\n  array new-expression.77) If not, the behavior is undefined. [ Note: this means that the syntax of the delete-expression\n  must match the type of the object allocated by new, not the syntax of the new-expression. \u2014end note ]</strong> [ Note: a pointer\n  to a const type can be the operand of a delete-expression; it is not necessary to cast away the constness (5.2.11) of the\n  pointer expression before it is used as the operand of the delete-expression. \u2014end note ]</p>\n</blockquote>\n", "OwnerUserId": "11401", "PostTypeId": "2", "Id": "70941", "Score": "2", "CreationDate": "2008-09-16T10:13:33.370", "LastActivityDate": "2008-09-16T10:13:33.370"}, "71442": {"ParentId": "70880", "CommentCount": "0", "Body": "<p>This isn't safe, and non of the responses so far have emphasized enough the madness of doing this. Simply don't do it, if you consider yourself a real programmer, or ever want to work as a professional programmer in a team. You can only say that your struct contains non destructor <em>at the moment</em>, however you are laying a nasty possibly compiler and system specific trap for the future. Also, your code is unlikely to work as expected. The very best you can hope for is it doesn't crash. However I suspect you will slowly get a memory leak, as array allocations via new very often allocate extra memory in the bytes <em>prior</em> to the returned pointer. You won't be freeing the memory you think you are. A good memory allocation routine should pick up this mismatch, as would tools like Lint etc. </p>\n<p>Simply don't do that, and purge from your mind whatever thinking process led you to even consider such nonsense.</p>\n", "Id": "71442", "PostTypeId": "2", "OwnerDisplayName": "solo", "Score": "0", "CreationDate": "2008-09-16T11:41:17.793", "LastActivityDate": "2008-09-16T11:41:17.793"}, "70942": {"ParentId": "70880", "CommentCount": "0", "Body": "<p>I highly doubt it.</p>\n<p>There are a lot of questionable ways of freeing memory, for example you can use <code>delete</code> on your <code>char</code> array (rather than <code>delete[]</code>) and it will likely work fine. I <a href=\"http://www.byteclub.net/blog/zooba/?p=77\" rel=\"nofollow noreferrer\">blogged</a> in detail about this (apologies for the self-link, but it's easier than rewriting it all).</p>\n<p>The compiler is not so much the issue as the platform. Most libraries will use the allocation methods of the underlying operating system, which means the same code could behave differently on Mac vs. Windows vs. Linux. I have seen examples of this and every single one was questionable code.</p>\n<p>The safest approach is to always allocate and free memory using the same data type. If you are allocating <code>char</code>s and returning them to other code, you may be better off providing specific allocate/deallocate methods:</p>\n<pre><code>SOME_STRUCT* Allocate()\n{\n    size_t cb; // Initialised to something\n    return (SOME_STRUCT*)(new char[cb]);\n}\n</code></pre>\n<p>\u00a0</p>\n<pre><code>void Free(SOME_STRUCT* obj)\n{\n    delete[] (char*)obj;\n}\n</code></pre>\n<p>(Overloading the <code>new</code> and <code>delete</code> operators may also be an option, but I have never liked doing this.)</p>\n", "OwnerUserId": "891", "Id": "70942", "PostTypeId": "2", "OwnerDisplayName": "Zooba", "Score": "4", "CreationDate": "2008-09-16T10:13:36.770", "LastActivityDate": "2008-09-16T10:13:36.770"}, "70905": {"CommentCount": "0", "CreationDate": "2008-09-16T10:06:34.073", "LastEditorUserId": "1032277", "LastActivityDate": "2016-12-23T15:49:03.950", "ParentId": "70880", "LastEditDate": "2016-12-23T15:49:03.950", "OwnerDisplayName": "thudbang", "PostTypeId": "2", "Id": "70905", "Score": "9", "Body": "<p>It's not guaranteed to be safe.  Here's a relevant link in the C++ FAQ lite:</p>\n<p>[16.13] Can I drop the <code>[]</code> when deleting array of some built-in type (<code>char</code>, <code>int</code>, etc.)?</p>\n<p><a href=\"https://isocpp.org/wiki/faq/freestore-mgmt#delete-array-built-ins\" rel=\"nofollow noreferrer\">http://www.parashift.com/c++-faq-lite/freestore-mgmt.html#faq-16.13</a></p>\n", "OwnerUserId": "11661"}, "78368": {"ParentId": "70880", "CommentCount": "0", "Body": "<p>If you use malloc/free instead of new/delete, malloc and free won't care about the type.</p>\n<p>So if you're using a C-like POD (plain old data, like a build-in type, or a struct), you can malloc some type, and free another. <strong>note that this is poor style even if it works</strong>.</p>\n", "OwnerUserId": "14089", "PostTypeId": "2", "Id": "78368", "Score": "0", "CreationDate": "2008-09-16T23:33:06.053", "LastActivityDate": "2008-09-16T23:33:06.053"}, "108579": {"CommentCount": "0", "CreationDate": "2008-09-20T16:05:54.867", "LastEditorUserId": "-1", "LastActivityDate": "2008-09-20T16:05:54.867", "ParentId": "70880", "LastEditDate": "2017-05-23T11:59:59.827", "OwnerDisplayName": "Charles Bailey", "PostTypeId": "2", "Id": "108579", "Score": "2", "Body": "<p>This is a very similar question to the one that I answered here: <a href=\"https://stackoverflow.com/questions/73134/will-this-c-code-cause-a-memory-leak-casting-vector-new#108454\">link text</a></p>\n<p>In short, no, it's not safe according to the C++ standard. If, for some reason, you need a SOME_STRUCT object allocated in an area of memory that has a size difference from <code>size_of(SOME_STRUCT)</code> (and it had better be bigger!), then you are better off using a raw allocation function like global <code>operator new</code> to perform the allocation and then creating the object instance in raw memory with a placement <code>new</code>. Placement <code>new</code> will be extremely cheap if the object type has no constructor.</p>\n<pre><code>void* p = ::operator new( cb );\nSOME_STRUCT* pSS = new (p) SOME_STRUCT;\n\n// ...\n\ndelete pSS;\n</code></pre>\n<p>This will work most of the time. It should always work if <code>SOME_STRUCT</code> is a POD-struct. It will also work in other cases if <code>SOME_STRUCT</code>'s constructor does not throw and if <code>SOME_STRUCT</code> does not have a custom operator delete. This technique also removes the need for any casts.</p>\n<p><code>::operator new</code> and <code>::operator delete</code> are C++'s closest equivalent to <code>malloc</code> and <code>free</code> and as these (in the absence of class overrides) are called as appropriate by <code>new</code> and <code>delete</code> expressions they can (with care!) be used in combination.</p>\n", "OwnerUserId": "19563"}});