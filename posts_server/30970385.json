post_cb({"bq_ids": {"n4140": {"so_30970385_30970518_2": {"length": 16, "quality": 0.8421052631578947, "section_id": 2111}}, "n3337": {"so_30970385_30970518_2": {"length": 16, "quality": 0.8421052631578947, "section_id": 2099}}, "n4659": {"so_30970385_30970518_2": {"length": 16, "quality": 0.8421052631578947, "section_id": 2384}}}, "30970385": {"ViewCount": "257", "Body": "<p>I'm trying to write a scoped object to redirect output from <code>std::cout</code> and call a function when it's underlying buffer is flushed. </p>\n<p>My implementation borrows heavily from the following SO answer:</p>\n<p><a href=\"https://stackoverflow.com/questions/12826751/c-execute-function-any-time-a-stream-is-written-to\">c++ execute function any time a stream is written to</a></p>\n<p>I have it partially working, but the callback function is only called when I explicity call <code>flush</code> on <code>std::cout</code>. However, I want it to call the callback function whenever <em>anything</em> is written to the stream.</p>\n<p><strong>NOTE</strong>: I am compiling aginst MSVC++11.</p>\n<pre><code>struct stream_redirect\n{\n    stream_redirect(std::ostream&amp; stream, std::streambuf* rdbuf) :\n        stream(stream),\n        rdbuf_old(stream.rdbuf())\n    {\n        stream.set_rdbuf(rdbuf);\n    }\n\n    ~stream_redirect()\n    {\n        stream.set_rdbuf(rdbuf_old);\n    }\n\nprivate:\n    stream_redirect(const stream_redirect&amp;) = delete;\n    stream_redirect&amp; operator = (const stream_redirect&amp;) = delete;\n\n    std::ostream&amp; stream;\n    std::streambuf* rdbuf_old;\n};\n\nstruct functionbuf : public std::streambuf\n{\n    typedef std::function&lt;void(std::string)&gt; function_type;\n\n    functionbuf(const function_type&amp; function)\n        : function(function)\n    {\n        setp(buffer, buffer + sizeof(buffer) - 1);\n    }\n\nprivate:\n    char buffer[1024];\n    function_type function;\n\n    virtual int_type overflow(int_type c) override\n    {\n        if (!traits_type::eq_int_type(c, traits_type::eof()))\n        {\n            *this-&gt;pptr() = traits_type::to_char_type(c);\n            pbump(1);\n        }\n\n        return sync() ? traits_type::not_eof(c) : traits_type::eof();\n    }\n\n    virtual int_type sync() override\n    {\n        if (pbase() != pptr())\n        {\n            function(std::string(pbase(), pptr()));\n\n            setp(pbase(), epptr());\n        }\n\n        return 0;\n    }\n};\n\nstruct ofunctionstream :\n    private virtual functionbuf,\n    public std::ostream\n{\n    ofunctionstream(const function_type&amp; function) :\n        functionbuf(function),\n        std::ostream(static_cast&lt;std::streambuf*&gt;(this))\n    {\n        setf(std::ios_base::unitbuf);\n    }\n};\n</code></pre>\n<p>Now a usage example:</p>\n<pre><code>void callback(std::string string)\n{\n    printf(\"callback(%s)\\n\", string.c_str());\n}\n\nint main()\n{\n    ofunctionstream fs(&amp;callback);\n    stream_redirect sr(std::cout, fs.rdbuf());\n\n    printf(\"sending string to cout...\");\n    std::cout &lt;&lt; \"hello!\";\n    printf(\"string sent to cout\");\n\n    //this is necessary to \n    printf(\"flushing cout...\");\n    std::cout.flush();\n    printf(\"cout flushed\");\n}\n</code></pre>\n<p>I get the following output:</p>\n<pre><code>sending string to cout...\nstring sent to cout\nflushing cout...\ncallback(hello!)\ncout flushed\n</code></pre>\n<p>Again, I want that callback function to be called as soon as <code>std::cout &lt;&lt; \"hello!\";</code> is called.  I assumed this would happen since I am calling <code>setf(std::ios_base::unitbuf)</code> (<a href=\"http://en.cppreference.com/w/cpp/io/manip/unitbuf\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/io/manip/unitbuf</a>) on the <code>ofunctionstream</code> object in it's constructor.</p>\n<p>Any help is greatly appreciated!</p>\n", "AcceptedAnswerId": "30970518", "Title": "Capturing and raising events on std::cout flush events", "CreationDate": "2015-06-21T23:38:07.323", "Id": "30970385", "CommentCount": "0", "LastEditDate": "2017-05-23T10:26:43.170", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-06-22T00:01:58.093", "Score": "3", "OwnerUserId": "2209008", "Tags": "<c++><c++11><iostream>", "AnswerCount": "1"}, "30970518": {"Id": "30970518", "PostTypeId": "2", "Body": "<p>If you examine how the callback that you're using works, it works by subclassing <code>std::streambuf</code> and by overriding <code>overflow()</code>. That's important to note.</p>\n<p>Quoting the relevant parts of the C++ standard library:</p>\n<blockquote>\n<p id=\"so_30970385_30970518_0\">27.6.3.2.5 Put area                        [streambuf.pub.put]</p>\n<p id=\"so_30970385_30970518_1\">int_type sputc(char_type c);</p>\n<p id=\"so_30970385_30970518_2\">Returns: If the output sequence write position is not available,\n  returns overflow(traits::to_int_- type(c)). Otherwise, stores c at the\n  next pointer for the output sequence, increments the pointer, and\n  returns traits::to_int_type(c)</p>\n</blockquote>\n<p><code>std::ostream</code>, a.k.a. formatted output, writes to the stream buffer using sputc(). So, the only time <code>overflow()</code> gets invoked is when the output buffer is exhausted. Or explicitly via <code>std::flush</code>.</p>\n<p>So, your options are, unfortunately, somewhat limited. Either deal with the current behavior, or jury-rig the <code>std::streambuf</code> subclass to have no write buffer at all, so that <em>every</em> character that ends up getting written via <code>sputc()</code> is going to get punted to <code>overflow()</code>, and invoke your subclass implementation.</p>\n<p>Unfortunately, stream operations do not carry out any explicit action after every formatting operation, that can be intercepted by the <code>std::streambuf</code>. They just write the formatted output, one character at a time, via <code>sputc()</code>, so that the output gets collected in the streambuf's write buffer, which gets flushed out only when it's full, or when <code>std::flush</code> gets explicitly used.</p>\n<p>So, that's how it works.</p>\n", "LastActivityDate": "2015-06-22T00:01:58.093", "CommentCount": "0", "CreationDate": "2015-06-22T00:01:58.093", "ParentId": "30970385", "Score": "3", "OwnerUserId": "3943312"}});