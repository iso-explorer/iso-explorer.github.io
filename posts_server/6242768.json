post_cb({"6242768": {"CommentCount": "2", "AcceptedAnswerId": "6242777", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-06-05T12:01:56.493", "LastActivityDate": "2011-12-22T23:00:22.483", "LastEditDate": "2017-05-23T10:31:25.977", "ViewCount": "15569", "FavoriteCount": "50", "Title": "Is the safe-bool idiom obsolete in C++11?", "Id": "6242768", "Score": "159", "Body": "<p><a href=\"https://stackoverflow.com/questions/6242296/conversion-function-for-error-checking-considered-good/6242355#6242355\">This answer of @R. Martinho Fernandes</a> shows, that the safe-bool idiom is apperently deprecated in C++11, as it can be replaced by a simple</p>\n<pre><code>explicit operator bool() const;\n</code></pre>\n<p>according to the standard quote in the answer <code>\u00a74 [conv] p3</code>:</p>\n<blockquote>\n<p id=\"so_6242768_6242768_0\">An expression e can be implicitly converted to a type <code>T</code> if and only if the declaration <code>T t=e;</code> is well-formed, for some invented temporary variable <code>t</code> (\u00a78.5). Certain language constructs require that an expression be converted to a Boolean value. An expression <code>e</code> appearing in such a context is said to be <strong>contextually converted</strong> to <code>bool</code> and <strong>is well-formed if and only if the declaration <code>bool t(e);</code> is well-formed</strong>, for some invented temporary variable t (\u00a78.5).</p>\n</blockquote>\n<p>The highlighted part clearly shows the \"implicit explicit cast\" (called \"contextual conversion\" in the standard) as @R. Martinho put it.</p>\n<p>The \"certain language constructs\" that require that \"implicit explicit cast\" seem to be the following:</p>\n<ul>\n<li><code>if</code>, <code>while</code>, <code>for</code> (<code>\u00a76.4 [stmt.select] p4</code>)</li>\n<li>binary logical operators <code>&amp;&amp;</code> and <code>||</code> (<code>\u00a75.14 [expr.log.and/or] p1</code> for both)</li>\n<li>the logical negation operator <code>!</code> (<code>\u00a75.3.1 [expr.unary.op] p9</code>)</li>\n<li>conditional operator <code>?:</code> (<code>\u00a75.14 [expr.cond] p1</code>)</li>\n<li><code>static_assert</code> (<code>\u00a77 [dcl.dcl] p4</code>)</li>\n<li><code>noexcept</code> (<code>\u00a715.4 [except.spec] p2</code>)</li>\n</ul>\n<p>Is our assumption in the title correct? I hope we didn't overlook any potential drawbacks.</p>\n", "Tags": "<c++><c++11><deprecated><c++-faq><safe-bool-idiom>", "OwnerUserId": "500104", "AnswerCount": "2"}, "6242777": {"ParentId": "6242768", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes. This is <em>the</em> example for problems with only having implicit user-defined conversions and explicit user-defined conversion operators were practically <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2333.html\">invented because of this problem</a> and to replace all the safe-bool stuff with something a lot cleaner and more logical.</p>\n", "OwnerUserId": "298661", "LastEditorUserId": "298661", "LastEditDate": "2011-06-05T12:12:26.137", "Id": "6242777", "Score": "114", "CreationDate": "2011-06-05T12:03:46.730", "LastActivityDate": "2011-06-05T12:12:26.137"}, "8554219": {"ParentId": "6242768", "CommentCount": "7", "Body": "<p>I wouldn't call it \"obsolete\". Not everyone is taking the leap to C++11 (not even <strong>1 year</strong> old) as of yet. And even if the a good amount of coders were, the ability to keep the code backwards compatible would be a must, considering this kind of idiom seems more sensible for libraries than for programs proper.</p>\n", "OwnerUserId": "399580", "PostTypeId": "2", "Id": "8554219", "Score": "2", "CreationDate": "2011-12-18T19:32:08.687", "LastActivityDate": "2011-12-18T19:32:08.687"}, "bq_ids": {"n4140": {"so_6242768_6242768_0": {"section_id": 3, "quality": 0.6571428571428571, "length": 23}}, "n3337": {"so_6242768_6242768_0": {"section_id": 2, "quality": 0.9428571428571428, "length": 33}}, "n4659": {"so_6242768_6242768_0": {"section_id": 3, "quality": 0.6571428571428571, "length": 23}}}});