post_cb({"16927687": {"ParentId": "16926855", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><a href=\"http://coliru.stacked-crooked.com/view?id=b694c6cc3a52e0c14bedd6a26790d99d-e54ee7a04e4b807da0930236d4cc94dc\" rel=\"nofollow\">http://coliru.stacked-crooked.com/view?id=b694c6cc3a52e0c14bedd6a26790d99d-e54ee7a04e4b807da0930236d4cc94dc</a> </p>\n<p>It can be done, if poorly.  I recommend not doing this.  Basically, the key part is since you can't have a pointer or a reference to a bitfield, you instead use a <em>lambda</em> which sets the bitfield for you.</p>\n<p>I dislike macros as much as the next guy, but it's the only way I could think of to avoid requiring callers to put in a lambda at the callsite.</p>\n<pre><code>template&lt;class assigner_type&gt;\nstruct bitfieldref_type {\n    bitfieldref_type(bool value, assigner_type&amp;&amp; assign) :value(value), assign(std::move(assign)) {}\n    operator bool() const {return value;}\n    bitfieldref_type&amp; operator=(bool v) {assign(v); value=v; return *this;}\nprivate:\n    bool value;\n    assigner_type assign;\n};\ntemplate&lt;class assigner_type&gt;\nbitfieldref_type&lt;assigner_type&gt; make_bitfieldref(bool value,  assigner_type&amp;&amp; assign)\n{return {value, std::move(assign)};}\n//macro is optional\n#define bitfieldref(X) make_bitfieldref(X, [&amp;](bool v)-&gt;void{X=v;})\n</code></pre>\n<p>usage:</p>\n<pre><code>template &lt;class T, typename... Args&gt; void proof_it_works(T&amp;&amp; first) \n{first = 0;}\ntemplate &lt;class T, typename... Args&gt; void proof_it_works(T&amp;&amp; first, Args &amp;&amp;...args) {\n    first = 0;\n    proof_it_works(std::forward&lt;Args&gt;(args)...);\n}    \ntemplate &lt;typename... Args&gt; void f(Args &amp;&amp;...args) {proof_it_works(std::forward&lt;Args&gt;(args)...);}\n\nint main() {\n    struct bits { unsigned int foo:1; };\n    bits b{1};\n    int a = -1;\n    float c = 3.14;\n    f(a, bitfieldref(b.foo), c);\n    std::cout &lt;&lt; a &lt;&lt; b.foo &lt;&lt; c;\n    return 0;\n}\n</code></pre>\n<p>I just noticed that my <code>bitfieldref_type</code> assumes the value is a <code>bool</code>, instead of a <code>unsigned int</code>, but I'll leave fixing that as an excersize for the user.</p>\n", "OwnerUserId": "845092", "LastEditorUserId": "845092", "LastEditDate": "2013-06-05T22:49:02.680", "Id": "16927687", "Score": "2", "CreationDate": "2013-06-04T21:21:00.887", "LastActivityDate": "2013-06-05T22:49:02.680"}, "40229305": {"ParentId": "16926855", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is the best answer I can come up with:</p>\n<pre><code>template &lt;typename... Args&gt; void f(Args &amp;&amp;...args) { }\n\nstruct bits { unsigned int foo:1; };\n\ntemplate &lt;typename T&gt; const T constipate(T v)\n{ return(static_cast&lt;const T&gt;(v)); }\n\nvoid bar()\n{\nbits b{1};\nf(constipate(b.foo));\n}\n</code></pre>\n<p>EDIT:  There's an easier solution, that eliminates the need for the 'constipate' template:</p>\n<pre><code>void bar()\n{\nbits b{1};\nf(b.foo + 0);\n}\n</code></pre>\n", "OwnerUserId": "2793551", "LastEditorUserId": "2793551", "LastEditDate": "2016-10-25T01:26:45.783", "Id": "40229305", "Score": "0", "CreationDate": "2016-10-24T23:51:58.883", "LastActivityDate": "2016-10-25T01:26:45.783"}, "16926855": {"CommentCount": "3", "ViewCount": "777", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-06-04T20:27:25.960", "LastActivityDate": "2016-10-25T01:26:45.783", "Title": "Perfect forwarding workaround for bit-fields", "AcceptedAnswerId": "16927687", "LastEditDate": "2017-05-23T12:33:21.937", "Id": "16926855", "Score": "2", "Body": "<p>I\u2019m looking for a workaround for <a href=\"https://stackoverflow.com/questions/14026202/bit-field-in-overload-resolution-for-template\">bit-field in overload resolution for template</a>.</p>\n<p>I have a function that I templated for perfect forwarding of its arguments:</p>\n<pre><code>template &lt;typename... Args&gt; void f(Args &amp;&amp;...args) { }\n</code></pre>\n<p>If I try to use it with a bit-field argument, like this:</p>\n<pre><code>struct bits { unsigned int foo:1; };\nbits b{1};\nf(b.foo);\n</code></pre>\n<p>\u2026it fails to compile:</p>\n<pre>main.cpp:26:7: error: non-const reference cannot bind to bit-field 'foo'\n    f(b.foo);\n      ^~~~~</pre>\n<p><strong>Is there a way to overload <code>f()</code> such that it takes bit-fields by value but still takes other arguments by reference in the common case?</strong></p>\n<p>So far I haven't been able to. For instance, if I add an overload that takes arguments by value\u2026</p>\n<pre>main.cpp:27:5: error: call to 'f' is ambiguous\n    f(b.foo);\n    ^</pre>\n", "Tags": "<c++><templates><c++11><bit-fields><perfect-forwarding>", "OwnerUserId": "84745", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_16926855_16927215_0": {"section_id": 628, "quality": 0.8360655737704918, "length": 51}}, "n3337": {"so_16926855_16927215_0": {"section_id": 618, "quality": 0.8360655737704918, "length": 51}}, "n4659": {"so_16926855_16927215_0": {"section_id": 654, "quality": 0.8360655737704918, "length": 51}}}, "16927215": {"ParentId": "16926855", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It cannot be done (at least not how you tried it) because the Standard says so (bold emphasis mine):</p>\n<p><strong>13.3.3.1.4 Reference binding [over.ics.ref]</strong></p>\n<blockquote>\n<p id=\"so_16926855_16927215_0\">4 Other restrictions on binding a reference to a particular argument\n  that are not based on the types of the reference and the argument do\n  not a\ufb00ect the formation of a standard conversion sequence, however.\n  [Example: a function with an \u201clvalue reference to int\u201d parameter can\n  be a viable candidate even if the corresponding argument is an int\n  bit-\ufb01eld. The formation of implicit conversion sequences treats the\n  int bit-\ufb01eld as an int lvalue and \ufb01nds an exact match with the\n  parameter. <strong>If the function is selected by overload resolution, the\n  call will nonetheless be ill-formed because of the prohibition on\n  binding a non-const lvalue reference to a bit-\ufb01eld</strong> (8.5.3). \u2014 end\n  example ]</p>\n</blockquote>\n<p>This explains why </p>\n<ul>\n<li>the original example fails to compile, because the reference cannot bind to a bit-field</li>\n<li>adding an overload <code>template&lt;typename... Arg&gt; f(Args.. args)</code> gave you the ambiguity: overload resoution ended in a tie, and the reference-binding-to-bitfield prohibition never came into play.</li>\n</ul>\n", "OwnerUserId": "819272", "LastEditorUserId": "819272", "LastEditDate": "2013-06-04T20:55:33.880", "Id": "16927215", "Score": "2", "CreationDate": "2013-06-04T20:49:11.303", "LastActivityDate": "2013-06-04T20:55:33.880"}});