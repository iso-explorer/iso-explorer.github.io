post_cb({"44942904": {"CommentCount": "2", "ViewCount": "121", "CreationDate": "2017-07-06T07:53:57.380", "LastActivityDate": "2017-07-06T08:10:43.323", "Title": "Why can't have I a pure virtual assignment operator?", "AcceptedAnswerId": "44943049", "PostTypeId": "1", "Id": "44942904", "Score": "3", "Body": "<p>I'm a bit lost in C++ operators. I'd like to enforce the assignment operator for two different classes, i.e. so one can assign one to each other:</p>\n<pre><code>class A {\npublic:\n    virtual A &amp;operator =(const A &amp;a) = 0;\n};\n\nclass B : public A {\npublic:\n    virtual A &amp;operator =(const A &amp;a) override {\n        std::cout &lt;&lt; \"B\" &lt;&lt; std::endl;\n        return *this;\n    }\n};\n\nclass C : public A {\npublic:\n    virtual A &amp;operator =(const A &amp;a) override {\n        std::cout &lt;&lt; \"C\" &lt;&lt; std::endl;\n        return *this;\n    }\n};\n\nint main(int argc, char *argv[])\n{\n    B b;\n    C c;\n    b = c;\n\n    // leads to a linker error: undefined reference to `A::operator=(A const&amp;)'\n    //B b2;\n    //b = b2;\n}\n</code></pre>\n<p>The first assignment seems to do the job, \"B\" is called. Similarly, for \"c = b\", \"C\" is called. However when I uncomment the second part, I get the linker error. If I define A's operator like:</p>\n<pre><code>virtual A &amp;operator =(const A &amp;a) {\n        std::cout &lt;&lt; \"A\" &lt;&lt; std::endl;\n        return *this;\n} \n</code></pre>\n<p>I get \"B\", \"A\". Huh? Can somebody explain why \"A\" is needed when two B's are assigned but not when B &lt;- C is?</p>\n", "Tags": "<c++><operator-overloading><assignment-operator>", "OwnerUserId": "21009", "AnswerCount": "3"}, "44943252": {"ParentId": "44942904", "CommentCount": "0", "CreationDate": "2017-07-06T08:10:43.323", "OwnerUserId": "7860670", "PostTypeId": "2", "Id": "44943252", "Score": "1", "Body": "<p>According to standard overriding virtual assignment operator of base class in derived class does not prevent generation of default copy assignment operator which is being invoked in your case. This default copy assignment operator of class <code>B</code> will directly call copy assignment operator of class <code>A</code> hence you are getting <code>undefined reference</code> error.</p>\n<blockquote>\n<p id=\"so_44942904_44943252_0\"><strong>13.5.3 Assignment [over.ass]</strong></p>\n<p id=\"so_44942904_44943252_1\">2 Any assignment operator, even the copy and move assignment operators, can be virtual. [Note: For a derived class D with a base class B for which a virtual copy/move assignment has been declared, the copy/move assignment operator in D does not override B\u2019s virtual copy/move assignment operator. [Example:</p>\n</blockquote>\n<pre><code>struct B {\n    virtual int operator= (int);\n    virtual B&amp; operator= (const B&amp;);\n};\n\nstruct D : B {\n    virtual int operator= (int);\n    virtual D&amp; operator= (const B&amp;);\n};\n\nD dobj1;\nD dobj2;\nB* bptr = &amp;dobj1;\n\nvoid f()\n{\n    bptr-&gt;operator=(99); // calls D::operator=(int)\n    *bptr = 99; // ditto\n    bptr-&gt;operator=(dobj2); // calls D::operator=(const B&amp;)\n    *bptr = dobj2; // ditto\n    dobj1 = dobj2; // calls implicitly-declared D::operator=(const D&amp;)\n}\n</code></pre>\n", "LastActivityDate": "2017-07-06T08:10:43.323"}, "44943109": {"ParentId": "44942904", "CommentCount": "0", "CreationDate": "2017-07-06T08:04:39.977", "OwnerUserId": "1030870", "PostTypeId": "2", "Id": "44943109", "Score": "2", "Body": "<p>When you assign <code>b = b2;</code>, it tries to call B's default (implicit) assignment.\nAnd the default assignment will invoke base class's default assignment, so it will eventually call <code>A::operator=(const A &amp;a)</code>, which is pure virtual.</p>\n<p>And so you get the link error.</p>\n", "LastActivityDate": "2017-07-06T08:04:39.977"}, "bq_ids": {"n4140": {"so_44942904_44943252_1": {"section_id": 661, "quality": 0.8709677419354839, "length": 27}}, "n3337": {"so_44942904_44943252_1": {"section_id": 651, "quality": 0.8709677419354839, "length": 27}}, "n4659": {"so_44942904_44943252_1": {"section_id": 689, "quality": 0.8709677419354839, "length": 27}}}, "44943049": {"ParentId": "44942904", "CommentCount": "3", "CreationDate": "2017-07-06T08:01:16.220", "OwnerUserId": "493106", "PostTypeId": "2", "Id": "44943049", "Score": "2", "Body": "<p>The compiler generates an implicit copy-assignment operator that is being selected when you do a B = B assignment.   That is not selected when you do a B = C assignment.   </p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/copy_assignment\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/copy_assignment</a></p>\n<p><a href=\"https://wandbox.org/permlink/CM5tQU656rnwtrKl\" rel=\"nofollow noreferrer\">https://wandbox.org/permlink/CM5tQU656rnwtrKl</a></p>\n<p>If you look at your error message: </p>\n<pre><code>/tmp/cctHhd0D.o: In function `B::operator=(B const&amp;)':\nprog.cc:(.text._ZN1BaSERKS_[_ZN1BaSERKS_]+0x1f): undefined reference to `A::operator=(A const&amp;)'\ncollect2: error: ld returned 1 exit status\n</code></pre>\n<p>You can see that the linker error is from inside <code>B::operator=(B const&amp;)</code>, which, since you didn't define one, means it must be auto-generated.</p>\n", "LastActivityDate": "2017-07-06T08:01:16.220"}});