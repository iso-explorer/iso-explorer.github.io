post_cb({"bq_ids": {"n4140": {"so_17687459_17687568_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 179}}, "n3337": {"so_17687459_17687568_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 173}}, "n4659": {"so_17687459_17687568_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 184}}}, "17687459": {"ViewCount": "1459", "Body": "<p>I'm getting compilation errors when trying to call the base class constructor in derived initialization list when using a template template parameter with CRTP.</p>\n<p><strong>Problem can be replicated with this snippet of code:</strong></p>\n<pre><code>template &lt;template&lt;class&gt; class Derived, class T&gt;\nstruct base\n{\n};\n\ntemplate &lt;class T&gt;\nstruct derived : public base&lt;derived, T&gt;\n{\n    derived()\n        : base&lt;derived, T&gt;()\n    { }\n};\n</code></pre>\n<p><strong>The offending error messsage:</strong></p>\n<pre><code>bug.cpp:10:16: error: template argument for template template parameter must be a class template or type alias template\n        : base&lt;derived, T&gt;()\n               ^\nbug.cpp:10:11: error: expected class member or base class name\n        : base&lt;derived, T&gt;()\n          ^\nbug.cpp:10:11: error: expected '{' or ','\n3 errors generated.\n</code></pre>\n<p>This problem only appears to happen on clang (3.4), not g++ (4.8, 4.7, 4.6). I'm compiling with -std=c++11 also.</p>\n<p>This is the first time I've needed to use CRTP with template template parameter. Am I doing this okay and it's a problem with clang++ or not?</p>\n<p>I've grown to trust clang++ error messages more than g++ of late!</p>\n", "AcceptedAnswerId": "17687568", "Title": "clang++ not accepting use of template template parameter when using CRTP", "CreationDate": "2013-07-16T21:37:31.927", "Id": "17687459", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2013-07-16T21:56:14.727", "Score": "19", "OwnerUserId": "269469", "Tags": "<c++><templates><c++11><clang><crtp>", "AnswerCount": "1"}, "17687568": {"Id": "17687568", "PostTypeId": "2", "Body": "<p>Your code is legal.</p>\n<p>From the C++11 Standard, section 14.6.1:</p>\n<blockquote>\n<p id=\"so_17687459_17687568_0\">Like normal (non-template) classes, class templates have an injected-class-name (Clause 9). <strong>The injected-class-name can be used as a template-name</strong> or a type-name. <strong>When it is used</strong> with a template-argument-list, <strong>as a template-argument for a template template-parameter</strong>, or as the final identi\ufb01er in the elaborated-type- speci\ufb01er of a friend class template declaration, <strong>it refers to the class template itself</strong>.</p>\n</blockquote>\n<p>Looks like your version of <code>clang</code> is still implementing the old rule.  Based on your additional comments, it might be doing so only in the <em>ctor-initializer-list</em>.</p>\n<hr>\n<p>User <a href=\"https://stackoverflow.com/users/36565/david-rodriguez-dribeas\">David Rodr\u00edguez - dribeas</a> provided a workaround for compilers that haven't fully implemented the C++11 injected-class-name rule.  Use any name of the class that isn't unqualified, for example:</p>\n<pre><code>derived()\n    : base&lt; ::derived, T &gt;()\n//          ^^ qualified with global namespace\n{ }\n</code></pre>\n<p>Some compilers may require this in the inheritance list also:</p>\n<pre><code>template &lt;class T&gt;\nstruct derived : public base&lt; ::derived, T &gt;\n//                            ^^\n</code></pre>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-07-16T21:56:14.727", "Score": "17", "CreationDate": "2013-07-16T21:45:03.937", "ParentId": "17687459", "CommentCount": "11", "OwnerUserId": "103167", "LastEditDate": "2017-05-23T12:00:49.750"}});