post_cb({"bq_ids": {"n4140": {"so_30927196_30927196_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 142}}, "n3337": {"so_30927196_30927196_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 136}}, "n4659": {"so_30927196_30927196_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 98}}}, "30928309": {"Id": "30928309", "PostTypeId": "2", "Body": "<p>A bug report (filed as <a href=\"https://llvm.org/bugs/show_bug.cgi?id=5559\" rel=\"nofollow noreferrer\">PR5559</a>) from a much older version of clang discusses the issue as well. The problem is that gcc and clang both have discrepancies when it comes to whether multiple template declarations are valid during an explicit specialization. Quoth <a href=\"https://llvm.org/bugs/show_bug.cgi?id=5559#c2\" rel=\"nofollow noreferrer\">Gabor Greif</a>:</p>\n<blockquote>\n<p id=\"so_30927196_30928309_0\">The first error is actually none, clang correctly diagnoses that only one \"<code>template &lt;&gt;</code>\" is needed. But because g++ accepts this and several people (like me) may have the misconception that the number of \"<code>template &lt;&gt;</code>\"s is governed by nesting instead of the number of levels being specialized, it may be interesting to reduce the error to a warning and possibly emit a fixit hint.</p>\n</blockquote>\n<p>The disparity could also be caused by the standard's cyclic definition of an explicit specilization (as noted by <a href=\"https://stackoverflow.com/users/657267/user657267\">@user657267</a>). </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-06-19T01:00:36.140", "Score": "2", "CreationDate": "2015-06-19T01:00:36.140", "ParentId": "30927196", "CommentCount": "0", "OwnerUserId": "701092", "LastEditDate": "2017-05-23T11:45:19.553"}, "30927988": {"Id": "30927988", "PostTypeId": "2", "Body": "<p>Because the grammar allows it, and there doesn't seem to be anything under the template specialization section that prohibits it:</p>\n<p>From [gram.temp]</p>\n<blockquote>\n<p id=\"so_30927196_30927988_0\"><em>explicit-specialization</em>:</p>\n<p id=\"so_30927196_30927988_1\"><code>template &lt; &gt;</code> <em>declaration</em></p>\n</blockquote>\n<p>From [gram.dcl]</p>\n<blockquote>\n<p id=\"so_30927196_30927988_2\"><em>declaration</em>:</p>\n<p id=\"so_30927196_30927988_3\">[...]</p>\n<p id=\"so_30927196_30927988_4\"><em>explicit-specialization</em></p>\n</blockquote>\n<p>The fact that the grammar is too lax has been in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#293\" rel=\"nofollow\">active issues list</a> (#293) since 2001.</p>\n", "LastEditorUserId": "657267", "LastActivityDate": "2015-06-19T00:39:20.360", "Score": "4", "CreationDate": "2015-06-19T00:18:06.567", "ParentId": "30927196", "CommentCount": "0", "OwnerUserId": "657267", "LastEditDate": "2015-06-19T00:39:20.360"}, "30927196": {"ViewCount": "652", "Body": "<p>Why does the code below compile? I am not specializing a template member function of a template class, so only one <code>template&lt;&gt;</code> should be used. However, g++ compiles it with no warnings whatsoever, clang++ gives only a warning</p>\n<blockquote>\n<p id=\"so_30927196_30927196_0\">warning: extraneous template parameter list in template\n        specialization</p>\n</blockquote>\n<pre><code>template&lt;typename T&gt;\nstruct S{};\n\ntemplate&lt;&gt; template&lt;&gt; // why can we do this? \nstruct S&lt;int&gt;{};\n\nint main()\n{\n\n}\n</code></pre>\n", "AcceptedAnswerId": "30927988", "Title": "Double template<> in template specialization", "CreationDate": "2015-06-18T22:57:00.077", "Id": "30927196", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2015-06-19T01:00:36.140", "Score": "9", "OwnerUserId": "3093378", "Tags": "<c++><templates>", "AnswerCount": "2"}});