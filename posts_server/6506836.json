post_cb({"6507120": {"ParentId": "6506836", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>If an exception is thrown, it is thrown. The object that failed to destruct is obviously not <em>properly</em> destroyed, and neither are the ones remaining in the array.</p>\n<p>If you use a vector, the problem is the same, just not in your code. :-)</p>\n<p>So, throwing destructors is just a Bad Idea(tm).</p>\n<hr>\n<p>Like @Martin shows below, the object that did thrown is formally non-existent as soon as we enter the destructor. The others might have their memory reclaimed as well.</p>\n<p>However, it obviously contained some complicated things that were not properly of flusher flushed. If that object, and the others following it in the array, contained some mutex locks, open files, database caches, or shared_ptrs, and none of those had <strong>their</strong> destructors run, we are likely in BIG trouble. </p>\n<p>Having std::terminate called at that point, to put the program out of its misery, seems like something you would wish for!</p>\n</hr>", "OwnerUserId": "597607", "LastEditorUserId": "597607", "LastEditDate": "2011-06-28T19:50:35.450", "Id": "6507120", "Score": "0", "CreationDate": "2011-06-28T13:22:17.760", "LastActivityDate": "2011-06-28T19:50:35.450"}, "6510893": {"ParentId": "6506836", "CommentCount": "1", "Body": "<p>Okay, here is some experimental code:</p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;cstdlib&gt;\n#include &lt;new&gt;\n#include &lt;iostream&gt;\n\nvoid* operator new[](size_t size) throw (std::bad_alloc)\n{\n    std::cout &lt;&lt; \"allocating \" &lt;&lt; size &lt;&lt; \" bytes\" &lt;&lt; std::endl;\n    return malloc(size);\n}\n\nvoid operator delete[](void* payload) throw ()\n{\n    std::cout &lt;&lt; \"releasing memory at \" &lt;&lt; payload &lt;&lt; std::endl;\n    free(payload);\n}\n\nstruct X\n{\n    bool throw_during_destruction;\n\n    ~X()\n    {\n        std::cout &lt;&lt; \"destructing \" &lt;&lt; (void*)this &lt;&lt; std::endl;\n        if (throw_during_destruction) throw 42;\n    }\n};\n\nint main()\n{\n    X* p = new X[10]();\n    p[5].throw_during_destruction = true;\n    p[1].throw_during_destruction = true;\n    delete[] p;\n}\n</code></pre>\n<p>Running the code gave the following output on g++ 4.6.0:</p>\n<pre><code>allocating 14 bytes\ndestructing 0x3e2475\ndestructing 0x3e2474\ndestructing 0x3e2473\ndestructing 0x3e2472\ndestructing 0x3e2471\nterminate called after throwing an instance of 'int'\n\nThis application has requested the Runtime to terminate it in an unusual way.\nPlease contact the application's support team for more information.\n</code></pre>\n<p>So it would seem that <code>std::terminate</code> is called immediately as soon as the first destructor throws. The other elements are not destructed, and the memory is not released. Can anyone confirm this?</p>\n", "OwnerUserId": "252000", "PostTypeId": "2", "Id": "6510893", "Score": "2", "CreationDate": "2011-06-28T17:50:58.747", "LastActivityDate": "2011-06-28T17:50:58.747"}, "6507139": {"ParentId": "6506836", "CommentCount": "6", "Body": "<blockquote>\n<p id=\"so_6506836_6507139_0\">5.3.5.7 If the value of the operand of the\n  delete-expression is not a null\n  pointer value, the delete-expression\n  will call a deallocation function\n  (3.7.3.2). Otherwise, it is unspeci\ufb01ed\n  whether the deallocation function will\n  be called. [ Note: The deallocation\n  function is called regardless of\n  whether the destructor for the object\n  or some element of the array throws an\n  exception. \u2014 end note ]</p>\n</blockquote>\n<p>Couldn't find anything about destructors except for </p>\n<blockquote>\n<p id=\"so_6506836_6507139_1\">In the case of an array, the elements will be\n  destroyed in order of decreasing address (that is, in reverse order of the completion of their constructor; see 12.6.2).</p>\n</blockquote>\n<p>I guess that after throwing no more destructors are called, but I'm not sure.</p>\n", "OwnerUserId": "113662", "PostTypeId": "2", "Id": "6507139", "Score": "5", "CreationDate": "2011-06-28T13:23:33.460", "LastActivityDate": "2011-06-28T13:23:33.460"}, "6510356": {"ParentId": "6506836", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I can not see it explicitly called out in the standard:</p>\n<p>Just that they will be called in reverse order of creation</p>\n<h3>5.3.5 Delete [expr.delete]</h3>\n<blockquote>\n<p id=\"so_6506836_6510356_0\">6  If the value of the operand of the delete-expression is not a null pointer value, the delete-expression will invoke the destructor (if any) for the object or the elements of the array being deleted. In the case of an array, the elements will be <strong>destroyed in order of decreasing address</strong> (that is, in reverse order of the completion of their constructor; see 12.6.2).</p>\n</blockquote>\n<p>And that the memory deallocation will be done even if the exception is thrown:</p>\n<blockquote>\n<p id=\"so_6506836_6510356_1\">7  If the value of the operand of the delete-expression is not a null pointer value, the delete-expression will call a deallocation function (3.7.4.2). Otherwise, it is unspecified whether the deallocation function will be called. [ <strong>Note: The deallocation function is called regardless of whether the destructor for the object or some element of the array throws an exception. \u2014 end note</strong> ]</p>\n</blockquote>\n<p>I tried the following code in G++ and it shows that that no more destructors get called after the exception:</p>\n<pre><code>#include &lt;iostream&gt;\nint id = 0;\nclass X\n{\n    public:\n         X() {   me = id++; std::cout &lt;&lt; \"C: Start\" &lt;&lt; me &lt;&lt; \"\\n\";}\n        ~X() {   std::cout &lt;&lt; \"C: Done \" &lt;&lt; me &lt;&lt; \"\\n\";\n                 if (me == 5) {throw int(1);}\n             }\n    private:\n        int me;\n};\n\nint main()\n{\n    try\n    {\n        X       data[10];\n    }\n    catch(...)\n    {\n        std::cout &lt;&lt; \"Finished\\n\";\n    }\n}\n</code></pre>\n<p>Execute:</p>\n<pre><code>&gt; g++ de.cpp\n&gt; ./a.out\nC: Start0\nC: Start1\nC: Start2\nC: Start3\nC: Start4\nC: Start5\nC: Start6\nC: Start7\nC: Start8\nC: Start9\nC: Done 9\nC: Done 8\nC: Done 7\nC: Done 6\nC: Done 5\nFinished\n</code></pre>\n<p>Which all leads back to this (very old answer):<br>\n<a href=\"https://stackoverflow.com/questions/130117/throwing-exceptions-out-of-a-destructor/130123#130123\">throwing exceptions out of a destructor</a></br></p>\n", "OwnerUserId": "14065", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:44:13.897", "Id": "6510356", "Score": "6", "CreationDate": "2011-06-28T17:05:29.233", "LastActivityDate": "2011-06-28T17:05:29.233"}, "6506865": {"ParentId": "6506836", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Never do that. If there is already an active exception, <code>std::terminate</code> will be called: <a href=\"http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.9\" rel=\"nofollow\">\"Bang, you're dead\"</a>. Your destructor must. Not. Throw. Resist.</p>\n<hr>\n<p>edit: Relevant section from the Standard (14882 2003), <em>15.2</em> Constructors and Destructors <code>[except.dtor]</code> :</p>\n<blockquote>\n<p id=\"so_6506836_6506865_0\"><em>15.2.3</em>  The process of calling destructors for automatic objects constructed on the path from a try block to a\n    throw-expression is called \u201cstack unwinding.\u201d [Note: <strong>If a destructor called during stack unwinding exits with an exception, terminate is called (15.5.1)</strong>. So <strong>destructors should generally catch exceptions and\n    not let them propagate out</strong> of the destructor. \u2014end note]</p>\n</blockquote>\n<hr>\n<p>Testcase for playing around (<em>in real life, throw something that is derived from <code>std::exception</code>, never throw int or something else!</em>):</p>\n<pre><code>    #include &lt;iostream&gt;\n    int main() {\n        struct Foo {\n            ~Foo() {\n                throw 0; // ... fore, std::terminate is called.\n            }\n        };\n\n        try {\n            Foo f;\n            throw 0; // First one, will be the active exception once Foo::~Foo()\n                     // is executed, there- ...\n        } catch (int) {\n            std::cout &lt;&lt; \"caught something\" &lt;&lt; std::endl;\n        }\n    }\n</code></pre>\n</hr></hr>", "OwnerUserId": "76722", "LastEditorUserId": "76722", "LastEditDate": "2011-06-28T14:37:22.783", "Id": "6506865", "Score": "5", "CreationDate": "2011-06-28T13:03:49.230", "LastActivityDate": "2011-06-28T14:37:22.783"}, "6506836": {"CommentCount": "6", "AcceptedAnswerId": "6510356", "PostTypeId": "1", "LastEditorUserId": "252000", "CreationDate": "2011-06-28T13:01:22.817", "LastActivityDate": "2011-06-28T19:50:35.450", "LastEditDate": "2011-06-28T15:54:50.780", "ViewCount": "1632", "FavoriteCount": "4", "Title": "What happens if delete[] p fails?", "Id": "6506836", "Score": "20", "Body": "<p>Suppose I have a pointer to a dynamically allocated array of 10 elements:</p>\n<pre><code>T* p = new T[10];\n</code></pre>\n<p>Later, I want to release that array:</p>\n<pre><code>delete[] p;\n</code></pre>\n<p>What happens if one of the <code>T</code> destructors throws an exception? Do the other elements still get destructed? Will the memory be released? Will the exception be propagated, or will program execution be terminated?</p>\n<p>Similarly, what happens when a <code>std::vector&lt;T&gt;</code> is destroyed and one of the <code>T</code> destructors throws?</p>\n", "Tags": "<c++><arrays><exception><memory-leaks><resource-management>", "OwnerUserId": "252000", "AnswerCount": "6"}, "6506867": {"ParentId": "6506836", "CommentCount": "1", "Body": "<p>To answer your second question, if you used std::vector instead, there wouldn't be any need for a call to delete, you're not using pointers (the vector class is internally I believe, but this is not up to you to manage).</p>\n", "OwnerUserId": "647242", "PostTypeId": "2", "Id": "6506867", "Score": "2", "CreationDate": "2011-06-28T13:03:56.827", "LastActivityDate": "2011-06-28T13:03:56.827"}, "bq_ids": {"n4140": {"so_6506836_6510356_0": {"section_id": 6110, "quality": 0.9666666666666667, "length": 29}, "so_6506836_6507139_1": {"section_id": 6110, "quality": 0.9333333333333333, "length": 14}, "so_6506836_6506865_0": {"section_id": 3345, "quality": 0.7567567567567568, "length": 28}, "so_6506836_6507139_0": {"section_id": 6111, "quality": 0.7777777777777778, "length": 28}, "so_6506836_6510356_1": {"section_id": 6111, "quality": 0.8285714285714286, "length": 29}}, "n3337": {"so_6506836_6510356_1": {"section_id": 5877, "quality": 0.8285714285714286, "length": 29}, "so_6506836_6507139_1": {"section_id": 5876, "quality": 0.9333333333333333, "length": 14}, "so_6506836_6506865_0": {"section_id": 3215, "quality": 0.7837837837837838, "length": 29}, "so_6506836_6507139_0": {"section_id": 5877, "quality": 0.7777777777777778, "length": 28}, "so_6506836_6510356_0": {"section_id": 5876, "quality": 0.9666666666666667, "length": 29}}, "n4659": {"so_6506836_6510356_1": {"section_id": 7608, "quality": 0.7142857142857143, "length": 25}, "so_6506836_6507139_1": {"section_id": 7607, "quality": 0.9333333333333333, "length": 14}, "so_6506836_6507139_0": {"section_id": 7608, "quality": 0.6944444444444444, "length": 25}, "so_6506836_6510356_0": {"section_id": 7607, "quality": 0.9666666666666667, "length": 29}}}});