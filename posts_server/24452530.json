post_cb({"24452815": {"ParentId": "24452530", "CommentCount": "3", "Body": "<p>There is clearly undefined behavior here, supposing the argument\nnames mean what they seem to mean, but it is in the callers\ncode.  There is no such thing as an iterator before first, and\njust attempting to create one is undefined behavior.  The\nundefined behavior doesn't come from attempting to dereference\nthe iterator; it comes from its very existance.  (Of course,\n<code>std::adjacent_find</code> <em>will</em> dereference it, before calling your\nlambda, so if the iterator exists, and is not dereferenceable,\nthat is also undefined behavior.) </p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "24452815", "Score": "0", "CreationDate": "2014-06-27T13:16:10.677", "LastActivityDate": "2014-06-27T13:16:10.677"}, "24454652": {"ParentId": "24452530", "CommentCount": "0", "Body": "<p><code>before_begin()</code> yields a non-dereferenceable iterator; one for which applying unary <code>*</code> has undefined behavior, so certainly the above code has undefined behavior:</p>\n<blockquote>\n<h3>1.3.24 <strong>[defns.undefined]</strong><br/></h3>\n<p id=\"so_24452530_24454652_0\"><strong>undefined behavior</strong><br/>\n  behavior for which this International Standard imposes no requirements</p>\n</blockquote>\n<p>Now, it is certainly true that for some implementations of the library, it would be possible for the above code to have defined behavior; for example, in a simple implementation of <code>forward_list</code>, <code>operator*</code> on its iterator could have the effect of forming a <code>T&amp;</code> reference to an uninitialised area of aligned storage:</p>\n<pre><code>template&lt;typename T&gt; struct forward_list {\n    struct Node {\n        Node* next = nullptr;\n        typename aligned_storage&lt;sizeof(T), alignof(T)&gt;::type buf;\n    };\n    struct iterator {\n        Node* node;\n        T&amp; operator*() { return *static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(node-&gt;buf)); }\n    };\n    Node head;\n    iterator before_begin() { return {&amp;head}; }\n};\n</code></pre>\n<p>In this scenario <code>*(list.before_begin())</code> has defined behavior, as long as the result is only used in the \"limited ways\" allowed by 3.8p6.</p>\n<p>However, any small change to this scenario could result in <code>*(list.before_begin())</code> becoming undefined; for example, optimising for space an implementation could use a <code>Node_base</code> that omits storage and derive from it for the concrete list nodes. Or perhaps the aligned storage could contain an object wrapping <code>T</code>, so accessing the wrapped <code>T</code> falls foul of 3.8p6. Alternatively, a debug implementation could check for dereferencing the before-begin iterator and terminate your program.</p>\n<p>By the as-if rule, the implementation is permitted to eliminate evaluations that have no visible side effects, but that doesn't result in your code having defined behavior. If the implementation debug-checks the dereference, program termination is certainly a side effect so is not eliminable.</p>\n<p>More interestingly, if an operation with undefined behavior occurs on the way to forming a <code>T&amp;</code> reference, then an optimising compiler is likely to use this to infer that the code paths leading up to the undefined behavior cannot occur.  Per the reference implementation of <code>adjacent_find</code>, eliminating the code paths leading to the offending <code>*first</code> give the result that <code>find_before</code> will <em>always</em> return <code>last</code>.</p>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "24454652", "Score": "1", "CreationDate": "2014-06-27T14:44:26.157", "LastActivityDate": "2014-06-27T14:44:26.157"}, "24452530": {"CommentCount": "17", "AcceptedAnswerId": "24454652", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-06-27T13:03:33.870", "LastActivityDate": "2014-06-30T11:57:02.620", "LastEditDate": "2017-05-23T11:49:24.813", "ViewCount": "132", "FavoriteCount": "1", "Title": "Undefined behavior when the offending expression is not used?", "Id": "24452530", "Score": "1", "Body": "<p>In a <a href=\"https://stackoverflow.com/questions/19375403/how-do-i-efficiently-remove-if-only-a-single-element-from-a-forward-list/19375586#comment37592189_19375586\">comment</a> by @MarcvanLeeuwen to <a href=\"https://stackoverflow.com/a/19375586/819272\">another Q&amp;A</a>, it was suggested that the following is undefined behavior (UB):</p>\n<pre><code>template&lt;class FwdIt, class T&gt;\nFwdIt find_before(FwdIt before_first, FwdIt last, T const&amp; value)\n{\n    return std::adjacent_find(before_first, last, \n        [&amp;](auto const&amp; /* L */, auto const&amp; R) { \n        // note that the left argument of the lambda is not evaluated\n        return R == value; \n    });\n}\n\nauto list = std::forward_list&lt;int&gt; { 1, 2 };\nauto it = find_before(list.before_begin(), list.end(), 1); // undefined behavior!?\n</code></pre>\n<p>The UB comes from the fact that the <code>BinaryPredicate</code> that is supplied to <code>std::adjacent_find</code> will dereference two adjacent iterators at a time, the first pair being <code>list.before_begin()</code> and <code>list.begin()</code>. Since <code>before_begin()</code> is not dereferencable, this could entail UB. On the other hand, the left argument is never used inside the lambda. One might argue that under the \"as-if\" rule it is unobservable whether the derefence actually took place, so that an optimizing compiler might elide it altogether.</p>\n<p><strong>Question</strong>: what does the Standard say about dereferencing an undereferencable iterator <code>it</code>, when the expression <code>*it</code> is not actually used and could be optimized away? (or more generally, is it UB when the offending expression is not used?)</p>\n<p><strong>NOTE</strong>: the offending code is easy to remedy by special casing the first iterator (as is done in the updated original Q&amp;A).</p>\n", "Tags": "<c++><c++11><iterator><language-lawyer><undefined-behavior>", "OwnerUserId": "819272", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_24452530_24454652_0": {"section_id": 5768, "quality": 0.7142857142857143, "length": 5}, "so_24452530_24489607_0": {"section_id": 837, "quality": 0.5714285714285714, "length": 8}}, "n3337": {"so_24452530_24454652_0": {"section_id": 5541, "quality": 0.7142857142857143, "length": 5}, "so_24452530_24489607_0": {"section_id": 828, "quality": 0.5714285714285714, "length": 8}}, "n4659": {"so_24452530_24454652_0": {"section_id": 7225, "quality": 0.7142857142857143, "length": 5}, "so_24452530_24489607_0": {"section_id": 897, "quality": 0.5714285714285714, "length": 8}}}, "24489607": {"ParentId": "24452530", "CommentCount": "1", "Body": "<blockquote>\n<h3>23.3.4.3 forward_list iterators [forwardlist.iter]</h3>\n<pre><code>iterator before_begin() noexcept;\nconst_iterator before_begin() const noexcept;\nconst_iterator cbefore_begin() const noexcept;\n</code></pre>\n<p id=\"so_24452530_24489607_0\">1 Returns: A non-dereferenceable iterator that, when incremented, is equal to the iterator returned by begin().<br>\n  3 Remarks: before_begin() == end() shall equal false.</br></p>\n</blockquote>\n<p>With sentence 3 in mind, if you call <code>adjacent_find</code> like you do it will dereference the first iterator if there is at least one element in the list (elem1: before_begin(), elem2: begin(), end: end()).</p>\n<p>Sentence 1 says that the iterator returned by <code>before_begin</code> is not dereferencable. Not. In any case. Without any if or when. It is undefined behavior to dereference the iterator, the standard is not saying you can dereference the iterator and throw away the return value of <code>*before_begin()</code>. Keep in mind that <code>adjacant_find</code> needs to dereference the iterator so it can pass whatever the dereferencing returns to your predicate.</p>\n<p>As always with undefined behavior the compiler is free to do whatever he wants. If the compiler sees in an optimization stage that he can inline your predicate and if the thinks that the left iterator does not need to be dereferenced because you do not use the returned value, he might generate code that just does so and hence does not crash. Generating code that works like you expect is one possibility in the case of undefined behavior, but you cannot count on it.</p>\n<p>BTW, why would you want to <code>adjacent_find</code> with a predicate that looks only at the right side? Wouldn't you use a <code>find</code>then?</p>\n", "OwnerUserId": "1023911", "PostTypeId": "2", "Id": "24489607", "Score": "1", "CreationDate": "2014-06-30T11:57:02.620", "LastActivityDate": "2014-06-30T11:57:02.620"}});