post_cb({"11340165": {"Id": "11340165", "PostTypeId": "2", "Body": "<p>9.0.7</p>\n<blockquote>\n<p id=\"so_11340028_11340165_0\">A standard-layout class is a class that: \u2014 has no non-static data\n  members of type non-standard-layout class (or array of such types) or\n  reference, \u2014 has no virtual functions (10.3) and no virtual base\n  classes (10.1), \u2014 has the same access control (Clause 11) for all\n  non-static data members, \u2014 has no non-standard-layout base classes, \u2014\n  either has no non-static data members in the most derived class and at\n  most one base class with non-static data members, or has no base\n  classes with non-static data members, and \u2014 has no base classes of the\n  same type as the first non-static data member.108</p>\n</blockquote>\n<p>9.2.14</p>\n<blockquote>\n<p id=\"so_11340028_11340165_1\">Nonstatic data members of a (non-union) class with the same access\n  control (Clause 11) are allocated so that later members have higher\n  addresses within a class object. The order of allocation of non-static\n  data members with different access control is unspecified (11).\n  Implementation alignment requirements might cause two adjacent members\n  not to be allocated immediately after each other; so might\n  requirements for space for managing virtual functions (10.3) and\n  virtual base classes (10.1).</p>\n</blockquote>\n<p>9.2.20</p>\n<blockquote>\n<p id=\"so_11340028_11340165_2\">A pointer to a standard-layout struct object, suitably converted using\n  a reinterpret_cast, points to its initial member (or if that member is\n  a bit-field, then to the unit in which it resides) and vice versa. [\n  Note: There might therefore be unnamed padding within a\n  standard-layout struct object, but not at its beginning, as necessary\n  to achieve appropriate alignment. \u2014 end note ]</p>\n</blockquote>\n", "LastEditorUserId": "673730", "LastActivityDate": "2012-07-05T08:03:02.167", "Score": "6", "CreationDate": "2012-07-05T08:01:55.427", "ParentId": "11340028", "CommentCount": "1", "OwnerUserId": "1498580", "LastEditDate": "2012-07-05T08:03:02.167"}, "11340537": {"Id": "11340537", "PostTypeId": "2", "Body": "<p>C99 and C++ differ a bit on this.  </p>\n<p>The C99 standard guarantees that the fields of a struct will be laid out in memory in the order they are declared, and that the fields of two identical structs will have the same offsets.  See <a href=\"https://stackoverflow.com/questions/2748995/c-struct-memory-layout\">this question</a> for the relevant sections of the C99 standard.  To summarize: the offset of the first field is specified to be zero, but the offsets after that are not specified by the standard.  This is to allow C compilers to adjust the offsets of each field so the field will satisfy any memory alignment requirements of the architecture.  Because this is implementation-dependent, C provides a standard way to determine the offset of each field using the <a href=\"http://en.wikipedia.org/wiki/Offsetof\" rel=\"nofollow noreferrer\"><code>offsetof</code></a> macro.</p>\n<p>C++ offers this guarantee only for <a href=\"http://en.wikipedia.org/wiki/Plain_old_data_structure\" rel=\"nofollow noreferrer\">Plain old data (POD)</a>.  C++ classes that are not plain old data cannot be treated like this.  The standard gives the C++ compiler quite a bit of freedom in how it organizes a class when the class uses multiple inheritance, has non-public fields or members, or contains virtual members.</p>\n<p>What this means for your examples:</p>\n<pre><code>dataType1 firstMemberInsideStruct = (dataType1)(*instance2);\n</code></pre>\n<p>This line is okay <em>only if</em> dataType1, dataType2, and dataType3 are plain old data.  If any of them are not, then the customType struct may not have a trivial constructor (or destructor) and this assumption may not hold.</p>\n<pre><code>dataType1 firstMemberInTheObject = (dataType1) (*pointerToAnObject);\n</code></pre>\n<p>This line is not safe regardless of whether <code>dataType1</code>, <code>dataType2</code>, and <code>dataType3</code> are POD, because the <code>CustomType</code> class has private instance variables.  This makes it <em>not</em> a POD class, and so you cannot assume that its first instance variable will be ordered in a particular way.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-07-05T08:28:01.053", "Score": "4", "CreationDate": "2012-07-05T08:28:01.053", "ParentId": "11340028", "CommentCount": "0", "OwnerUserId": "1430833", "LastEditDate": "2017-05-23T11:56:20.593"}, "11340076": {"Id": "11340076", "PostTypeId": "2", "Body": "<p>It's not always safe to do so. If the classes have <code>virtual</code> methods, it most definitely is not. Data members are guaranteed to appear in the same order for the same access level chunk, but these groups can be reordered.</p>\n<p><strong>In order to be safe with these type of casts, you should provide a conversion constructor or a cast operator, and not rely on implementation details.</strong></p>\n", "LastActivityDate": "2012-07-05T07:55:27.753", "CommentCount": "0", "CreationDate": "2012-07-05T07:55:27.753", "ParentId": "11340028", "Score": "1", "OwnerUserId": "673730"}, "bq_ids": {"n4140": {"so_11340028_11340165_2": {"length": 20, "quality": 0.5263157894736842, "section_id": 5879}, "so_11340028_11340165_1": {"length": 49, "quality": 0.9423076923076923, "section_id": 5873}, "so_11340028_11340165_0": {"length": 55, "quality": 0.9482758620689655, "section_id": 5851}}, "n3337": {"so_11340028_11340165_0": {"length": 55, "quality": 0.9482758620689655, "section_id": 5621}, "so_11340028_11340165_1": {"length": 49, "quality": 0.9423076923076923, "section_id": 5644}, "so_11340028_11340165_2": {"length": 35, "quality": 0.9210526315789473, "section_id": 5650}}, "n4659": {"so_11340028_11340165_0": {"length": 41, "quality": 0.7068965517241379, "section_id": 7330}, "so_11340028_11340165_1": {"length": 49, "quality": 0.9423076923076923, "section_id": 7356}, "so_11340028_11340165_2": {"length": 20, "quality": 0.5263157894736842, "section_id": 7363}}}, "11340028": {"ViewCount": "1287", "Body": "<p>Consider these two cases : </p>\n<pre><code>struct customType\n{\n   dataType1 var1; \n   dataType2 var2;\n   dataType3 var3;\n} ;\n\ncustomType instance1;\n// Assume var1, var2 and var3 were initialized to some valid values.\n\ncustomType * instance2 = &amp;instance1;    \ndataType1 firstMemberInsideStruct = (dataType1)(*instance2);\n</code></pre>\n<hr>\n<pre><code>class CustomType\n{\n   public:\n       dataType1 member1;\n       dataType2 member2;\n\n       retrunType1 memberFunction1();\n\n   private:\n       dataType3 member3;\n       dataType4 member4;\n\n       retrunType2 memberFunction2();\n};\n\ncustomType object;\n// Assume member1, member2, member3 and member4 were initialized to some valid values.\n\ncustomType *pointerToAnObject = &amp;object ;\ndataType1 firstMemberInTheObject = (dataType1) (*pointerToAnObject);\n</code></pre>\n<p>Is it <em>always</em> safe to do this ?</p>\n<p>I want to know if standard specifies any order of storage among - </p>\n<ol>\n<li>The elements inside a C structure. </li>\n<li>Data members inside an object of a C++ class. </li>\n</ol>\n</hr>", "AcceptedAnswerId": "11340537", "Title": "Order of storage inside a structure / object", "CreationDate": "2012-07-05T07:52:09.203", "Id": "11340028", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2012-07-05T08:28:01.053", "Score": "3", "OwnerUserId": "1093223", "Tags": "<c++><c><class><pointers><structure>", "AnswerCount": "4"}, "11340046": {"Id": "11340046", "PostTypeId": "2", "Body": "<p>Typically in a C struct members are stored in the order that they are declared. However the elements must be aligned properly. Wikipedia has a good example of <a href=\"http://en.wikipedia.org/wiki/Data_structure_alignment#Typical_alignment_of_C_structs_on_x86\" rel=\"nofollow\">how this works</a>.</p>\n<p>I will re-iterate here:</p>\n<p>If you have the following struct</p>\n<pre><code>struct MixedData\n{\n    char Data1;\n    short Data2;\n    int Data3;\n    char Data4;\n};\n</code></pre>\n<p>padding will be inserted in between differing data types in order to assure the proper byte-alignment. <code>char</code>s are 1-byte aligned, <code>short</code>s are 2-byte aligned, <code>int</code>s are 4-byte aligned, etc.</p>\n<p>Thus to make <code>Data2</code> 2-byte aligned, there will be a 1-byte padding inserted between <code>Data1</code> and <code>Data2</code>.</p>\n<p>It is also worth mentioning that there are mechanisms that can change the packing alignment. See <a href=\"http://msdn.microsoft.com/en-us/library/2e70t5y1%28v=vs.80%29.aspx\" rel=\"nofollow\">#pragma pack</a>.</p>\n", "LastEditorUserId": "811001", "LastActivityDate": "2012-07-05T07:59:35.610", "Score": "0", "CreationDate": "2012-07-05T07:53:49.030", "ParentId": "11340028", "CommentCount": "2", "OwnerUserId": "811001", "LastEditDate": "2012-07-05T07:59:35.610"}});