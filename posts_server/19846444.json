post_cb({"bq_ids": {"n4140": {"so_19846444_19846444_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 4295}, "so_19846444_19846444_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 4380}, "so_19846444_19846444_3": {"length": 9, "quality": 0.8181818181818182, "section_id": 4383}}, "n3337": {"so_19846444_19846444_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 4136}, "so_19846444_19846444_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 4217}, "so_19846444_19846444_3": {"length": 9, "quality": 0.8181818181818182, "section_id": 4220}}, "n4659": {"so_19846444_19846444_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 5553}, "so_19846444_19846444_0": {"length": 8, "quality": 0.5333333333333333, "section_id": 5645}, "so_19846444_19846444_3": {"length": 9, "quality": 0.8181818181818182, "section_id": 5648}}}, "19846697": {"Id": "19846697", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_19846444_19846697_0\"><strong>Question: Where is this required?</strong></p>\n</blockquote>\n<p>If it wasn't required the destructor would have undefined behaviour, and the standard is not in the habit of requiring undefined behaviour :-)</p>\n<p>If you meet the preconditions of the constructor, then the destructor will not invoke undefined behaviour. How the implementation ensures that is unspecified, but you can assume it gets it right, and you don't need to know how.  If the implementation wasn't expected to Do The Right Thing then the destructor would have a precondition.</p>\n<blockquote>\n<p id=\"so_19846444_19846697_1\">(Or am I just too nit-picky and it's obvious somehow that the implementations are required to use a \"owner object\"?)</p>\n</blockquote>\n<p>Yes, there has to be some additional object created to own the pointer, because the reference counts (or other bookkeeping data) must be on the heap and not part of any specific <code>shared_ptr</code> instance, because it might need to out-live any specific instance.  So yes, there is an extra object, which owns the pointer, which you can call an owner object. If no deleter is supplied by the user then that owner object just calls <code>delete</code>. For example:</p>\n<pre><code>template&lt;typename T&gt;\nstruct SpOwner {\n  long count;\n  long weak_count;\n  T* ptr;\n  virtual void dispose() { delete ptr; }\n  // ...\n};\n\ntemplate&lt;typename T, typename Del&gt;\nstruct SpOwnerWithDeleter : SpOwner&lt;T&gt; {\n  Del del;\n  virtual void dispose() { del(this-&gt;ptr); }\n  // ...\n};\n</code></pre>\n<p>Now a <code>shared_ptr</code> has a <code>SpOwner*</code> and when the count drops to zero it invokes the virtual function <code>dispose()</code> which either calls <code>delete</code> or invokes the deleter, depending on how the object was constructed.  The decision of whether to construct an <code>SpOwner</code> or an <code>SpOwnerWithDeleter</code> is made when the <code>shared_ptr</code> is constructed, and that type is still the same when the <code>shared_ptr</code> is destroyed, so if it needs to dispose of the owned pointer then it will Do The Right Thing.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2013-11-07T21:42:41.940", "Score": "5", "CreationDate": "2013-11-07T21:06:00.310", "ParentId": "19846444", "CommentCount": "8", "OwnerUserId": "981959", "LastEditDate": "2013-11-07T21:42:41.940"}, "19846444": {"ViewCount": "238", "Body": "<p><a href=\"https://stackoverflow.com/q/3899790/420683\">It's</a> <a href=\"https://stackoverflow.com/a/17650101/420683\">widely</a> <a href=\"https://stackoverflow.com/a/6378121/420683\">known</a> that you can use a <code>shared_ptr</code> to store a pointer to an incomplete type, as long as the pointer can be deleted (with well-defined behaviour) during the construction of the <code>shared_ptr</code>. For example, the PIMPL technique:</p>\n<pre><code>struct interface\n{\n    interface();                 // out-of-line definition required\n    ~interface() = default;   // public inline member, even if implicitly defined\n    void foo();\nprivate:\n    struct impl;                 // incomplete type\n    std::shared_ptr&lt;impl&gt; pimpl; // pointer to incomplete type\n};\n</code></pre>\n<p>[main.cpp]</p>\n<pre><code>int main()\n{\n    interface i;\n    i.foo();\n}\n</code></pre>\n<p>[interface.cpp]</p>\n<pre><code>struct interface::impl\n{\n    void foo()\n    {\n        std::cout &lt;&lt; \"woof!\\n\";\n    }\n};\n\ninterface::interface()\n    : pimpl( new impl ) // `delete impl` is well-formed at this point\n{}\n\nvoid interface::foo()\n{\n    pimpl-&gt;foo();\n}\n</code></pre>\n<p>This works as an <strike>\"deleter object\"</strike> \"owner object\" (*) is created during the construction of the <code>shared_ptr</code> in <code>pimpl( new impl )</code>, and stored after type erasure inside the <code>shared_ptr</code>. This \"owner object\" is later used to destroy the object pointed to. That's why it should be safe to provide an <em>inline</em> destructor of <code>interface</code>.</p>\n<p><strong><em>Question:</em> Where does the Standard guarantee that it's safe?</strong></p>\n<p><sub>(*) Not a deleter in terms of the Standard, see below, but it does either call the custom deleter or invokes the delete-expression. This object is typically stored as part of the bookkeeping object, applying type erasure and invoking the custom deleter / delete-expression in a virtual function. At this point, the delete-expression should be well-formed as well.</sub></p>\n<hr>\n<p>Referring to the latest draft in the github repository (94c8fc71, revising N3797), [util.smartptr.shared.const]</p>\n<blockquote>\n<pre><code>template&lt;class Y&gt; explicit shared_ptr(Y* p);\n</code></pre>\n<p id=\"so_19846444_19846444_0\">3 \u00a0\u00a0 Requires: <code>p</code> shall be\n  convertible to <code>T*</code>. <code>Y</code> shall be a complete type. The expression <code>delete p</code>\n  shall be well formed, shall have well defined behavior, and shall not\n  throw exceptions.</p>\n<p id=\"so_19846444_19846444_1\">4 \u00a0\u00a0 Effects: Constructs a <code>shared_ptr</code> object that owns\n  the pointer <code>p</code>.</p>\n<p id=\"so_19846444_19846444_2\">5 \u00a0\u00a0 Postconditions: <code>use_count() == 1 &amp;&amp; get() == p</code>.</p>\n<p id=\"so_19846444_19846444_3\">6 \u00a0\u00a0 Throws: <code>bad_alloc</code>, or an implementation-defined exception when a\n  resource other than memory could not be obtained.</p>\n</blockquote>\n<p><em>Note:</em> For this ctor, <code>shared_ptr</code> <em>is not required to own a deleter</em>. By <em>deleter</em>, the Standard seems to mean <em>custom deleter</em>, such as you provide during the construction as an additional parameter (or the <code>shared_ptr</code> acquires/shares one from another <code>shared_ptr</code>, e.g. through copy-assignment). Also see (also see [util.smartptr.shared.const]/9). The implementations (boost, libstdc++, MSVC, and I guess every sane implementation) always store an \"owner object\".</p>\n<p>As a <em>deleter</em> is a <em>custom deleter</em>, the destructor of <code>shared_ptr</code> is defined in terms of <code>delete</code> (delete-expression) if there's no custom deleter:</p>\n<p>[util.smartptr.shared.dest]</p>\n<blockquote>\n<pre><code>~shared_ptr();\n</code></pre>\n<p id=\"so_19846444_19846444_4\">1 \u00a0\u00a0 Effects:</p>\n<ul>\n<li>If <code>*this</code> is <em>empty</em> or shares ownership with\n  another <code>shared_ptr</code> instance (<code>use_count() &gt; 1</code>), there are no side\n  effects.</li>\n<li>Otherwise, if <code>*this</code> <em>owns</em> an object <code>p</code> and a deleter <code>d</code>, <code>d(p)</code>\n  is called.</li>\n<li>Otherwise, <code>*this</code> <em>owns</em> a pointer <code>p</code>, and <code>delete p</code> is\n  called.</li>\n</ul>\n</blockquote>\n<p>I'll assume the <em>intent</em> is that an implementation is required to correctly delete the stored pointer even if in the scope of the <code>shared_ptr</code> dtor, the delete-expression is ill-formed or would invoke UB. (The delete-expression must be well-formed and have well-defined behaviour in the ctor.) So, the question is</p>\n<p><strong><em>Question:</em> Where is this required?</strong></p>\n<p>(Or am I just too nit-picky and it's obvious somehow that the implementations are required to use an \"owner object\"?)</p>\n</hr>", "AcceptedAnswerId": "19846697", "Title": "Does shared_ptr's dtor require the use of a \"deleter\"?", "CreationDate": "2013-11-07T20:51:32.700", "Id": "19846444", "CommentCount": "1", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:13:03.233", "LastEditorUserId": "-1", "LastActivityDate": "2013-11-07T21:42:41.940", "Score": "6", "OwnerUserId": "420683", "Tags": "<c++><c++11><shared-ptr><language-lawyer>", "AnswerCount": "1"}});