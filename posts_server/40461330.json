post_cb({"bq_ids": {"n4140": {"so_40461330_40461330_1": {"length": 19, "quality": 1.0, "section_id": 3876}, "so_40461330_40461330_2": {"length": 20, "quality": 1.0, "section_id": 3876}, "so_40461330_40461330_0": {"length": 6, "quality": 1.0, "section_id": 3876}, "so_40461330_40461330_3": {"length": 10, "quality": 1.0, "section_id": 3876}}, "n3337": {"so_40461330_40461330_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 3736}, "so_40461330_40461330_2": {"length": 18, "quality": 0.9, "section_id": 3736}, "so_40461330_40461330_0": {"length": 6, "quality": 1.0, "section_id": 3736}, "so_40461330_40461330_3": {"length": 7, "quality": 0.7, "section_id": 3736}}, "n4659": {"so_40461330_40461330_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 4690}, "so_40461330_40461330_2": {"length": 18, "quality": 0.9, "section_id": 4690}, "so_40461330_40461330_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 4690}, "so_40461330_40461330_3": {"length": 10, "quality": 1.0, "section_id": 4690}}}, "40461330": {"ViewCount": "101", "Body": "<p>I have a question for overload resolution of <code>modf</code>.</p>\n<p>Consider the code below.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;climits&gt;\n#include &lt;cmath&gt;\n\nint main()\n{\n    unsigned long ul = ULONG_MAX;\n    long double ipart;\n    long double fpart = std::modf(ul, &amp;ipart);\n\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(0)\n        &lt;&lt; ul &lt;&lt; \", \" &lt;&lt; ipart &lt;&lt; \", \" &lt;&lt; fpart &lt;&lt; '\\n'\n        &lt;&lt; static_cast&lt;double&gt;(ul) &lt;&lt; '\\n';\n}\n</code></pre>\n<p>On my test environment, the code outputs...</p>\n<pre><code>18446744073709551615, 18446744073709551615, 0\n18446744073709551616\n</code></pre>\n<p>cf. <a href=\"http://melpon.org/wandbox/permlink/7ZF2CwqEwBRU5hg4\" rel=\"nofollow noreferrer\">http://melpon.org/wandbox/permlink/7ZF2CwqEwBRU5hg4</a></p>\n<p>C++14 standard 26.8[c.math] p.11 says,</p>\n<blockquote>\n<p id=\"so_40461330_40461330_0\">Moreover, there shall be additional overloads sufficient to ensure:</p>\n<ol>\n<li><p id=\"so_40461330_40461330_1\">If any arithmetic argument corresponding to a <code>double</code> parameter has type <code>long double</code>, then all arithmetic arguments corresponding to\n  <code>double</code> parameters are effectively cast to <code>long double</code>.</p></li>\n<li><p id=\"so_40461330_40461330_2\">Otherwise, if any arithmetic argument corresponding to a <code>double</code> parameter has type <code>double</code> or an integer type, then all arithmetic\n  arguments corresponding to <code>double</code> parameters are effectively cast to\n  <code>double</code>.</p></li>\n<li><p id=\"so_40461330_40461330_3\">Otherwise, all arithmetic arguments corresponding to <code>double</code> parameters have type <code>float</code>.</p></li>\n</ol>\n</blockquote>\n<p>The variable <code>ul</code> does not have type <code>long double</code> but integer type, so I think <code>ul</code> should be cast to\n<code>double</code>, then <code>ipart</code> should be <code>18446744073709551616</code>.\n(That is, GCC's behavior is wrong.)</p>\n<p>Do I have a misunderstanding about this behavior?\n(Of course, I think the GCC's behavior is more preferable.)</p>\n", "Title": "Overload resolution of modf", "CreationDate": "2016-11-07T09:03:52.193", "LastActivityDate": "2016-11-07T09:23:44.960", "CommentCount": "1", "PostTypeId": "1", "Id": "40461330", "Score": "2", "OwnerUserId": "1873224", "Tags": "<c++><gcc>", "AnswerCount": "1"}, "40461664": {"Id": "40461664", "PostTypeId": "2", "Body": "<p>You misunderstood what is happening here.</p>\n<p>First of all let's check what <code>ul</code> is going to be cast to, by passing it as the only parameter into <code>std::modf</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;climits&gt;\n#include &lt;cmath&gt;\n\nint main()\n{\n    unsigned long ul = ULONG_MAX;\n    auto fpart = std::modf(ul, nullptr);\n\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(0)\n        &lt;&lt; ul &lt;&lt; \", \" &lt;&lt; ipart;\n}\n</code></pre>\n<p>This fails to compile:</p>\n<pre><code>prog.cc:9:46: error: call of overloaded 'modf(long unsigned int&amp;, std::nullptr_t)' is ambiguous\n...\n/usr/local/gcc-head/include/c++/7.0.0/cmath:376:3: note: candidate: float std::modf(float, float*)\n...\n/usr/include/x86_64-linux-gnu/bits/mathcalls.h:116:1: note: candidate: double modf(double, double*)\n...\n/usr/local/gcc-head/include/c++/7.0.0/cmath:380:3: note: candidate: long double std::modf(long double, long double*)\n...\n</code></pre>\n<p>As you can see the compiler can't decide which of the 3 overloaded functions to call, as it doesn't know which one you want from the parameters you pass.</p>\n<p>So why does you example compile?</p>\n<p>Check out the second paremeter you pass: A pointer to <code>long double ipart;</code>.\nSo that`s something the compiler can work with.</p>\n<p>Is there any function taking a <code>long double *</code> as second parameter? Yes there is:</p>\n<p><code>long double modf( long double x, long double* iptr );</code></p>\n<p>So what your code does here is more or less something like this:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;climits&gt;\n#include &lt;cmath&gt;\n\nint main()\n{\n    unsigned long ul = ULONG_MAX;\n    long double ipart;\n    long double fpart = std::modf(static_cast&lt;long double&gt;(ul), &amp;ipart);\n\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(0)\n        &lt;&lt; ul &lt;&lt; \", \" &lt;&lt; ipart &lt;&lt; \", \" &lt;&lt; fpart &lt;&lt; '\\n'\n        &lt;&lt; static_cast&lt;double&gt;(ul) &lt;&lt; '\\n';\n}\n</code></pre>\n<p>As you can see now is that you are comparing <code>static_cast&lt;long double&gt;(ul)</code> with <code>static_cast&lt;double&gt;(ul)</code>.</p>\n", "LastActivityDate": "2016-11-07T09:23:44.960", "CommentCount": "8", "CreationDate": "2016-11-07T09:23:44.960", "ParentId": "40461330", "Score": "2", "OwnerUserId": "4181011"}});