post_cb({"8111892": {"Id": "8111892", "PostTypeId": "2", "Body": "<p>Not everything about it is good, in my opinion. People, including compiler vendors, have been insulting it because of its sometimes unfortunate behavior. </p>\n<p>ADL is responsible for a major overhaul of the for-range loop in C++11. To understand why ADL can sometimes have unintended effects, consider that not only the namespaces where the arguments are defined are considered, but also the arguments of template arguments of the arguments, of parameter types of function types / pointee types of pointer types of those arguments, and so on and forth. </p>\n<p>An example using boost</p>\n<pre><code>std::vector&lt;boost::shared_ptr&lt;int&gt;&gt; v;\nauto x = begin(v);\n</code></pre>\n<p>This resulted in an ambiguity if the user uses the boost.range library, because both <code>std::begin</code> is found (by ADL using <code>std::vector</code>) and <code>boost::begin</code> is found (by ADL using <code>boost::shared_ptr</code>). </p>\n", "LastActivityDate": "2011-11-13T13:33:40.680", "CommentCount": "4", "CreationDate": "2011-11-13T13:33:40.680", "ParentId": "8111677", "Score": "15", "OwnerUserId": "34509"}, "8111734": {"Id": "8111734", "PostTypeId": "2", "Body": "<p>In Koenig Lookup, if a function is called without specifying it's namespace, then the name of a function is <em>also</em> search in namespace(s) in which the type of the  argument(s) is defined. That is why it is also known as <a href=\"http://en.wikipedia.org/wiki/Argument-dependent_name_lookup\" rel=\"noreferrer\">Argument-Dependent name Lookup</a>, in short simply <a href=\"http://en.wikipedia.org/wiki/Argument-dependent_name_lookup\" rel=\"noreferrer\">ADL</a>.</p>\n<p>It is because of Koenig Lookup, we can write this:</p>\n<pre><code>std::cout &lt;&lt; \"Hello World!\" &lt;&lt; \"\\n\";\n</code></pre>\n<p>Otherwise, in the absense of Koenig Lookup, we have to write:</p>\n<pre><code>std::operator&lt;&lt;(std::operator&lt;&lt;(std::cout, \"Hello World!\"), \"\\n\");\n</code></pre>\n<p>which is really too much typying and the code looks really ugly!</p>\n<p>In other words, in the absence of Koenig Lookup, even a <em>Hello World</em> program looks complicated.</p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2015-07-16T07:03:31.300", "Score": "41", "CreationDate": "2011-11-13T13:07:53.860", "ParentId": "8111677", "CommentCount": "11", "OwnerUserId": "415784", "LastEditDate": "2015-07-16T07:03:31.300"}, "bq_ids": {"n4140": {"so_8111677_8111750_0": {"length": 34, "quality": 0.8947368421052632, "section_id": 7103}}, "n3337": {"so_8111677_8111750_0": {"length": 34, "quality": 0.8947368421052632, "section_id": 6847}}, "n4659": {"so_8111677_8111750_0": {"length": 34, "quality": 0.8947368421052632, "section_id": 8604}}}, "8111677": {"ViewCount": "15247", "Body": "<p>What are some good explanations on what argument dependent lookup is? Many people also call it Koenig Lookup as well.</p>\n<p>Preferably I'd like to know:</p>\n<ul>\n<li>Why is it a good thing?</li>\n<li>Why is it a bad thing?</li>\n<li>How does it work?</li>\n</ul>\n<p><sub>\n<em>(Note: This is meant to be an entry to <a href=\"https://stackoverflow.com/questions/tagged/c++-faq\">Stack Overflow's C++ FAQ</a>.)</em>\n</sub></p>\n", "AcceptedAnswerId": "8111750", "Title": "What is \"Argument-Dependent Lookup\" (aka ADL, or \"Koenig Lookup\")?", "CreationDate": "2011-11-13T12:58:43.800", "Id": "8111677", "CommentCount": "3", "FavoriteCount": "69", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:09:56.303", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-16T08:49:00.213", "Score": "105", "OwnerUserId": "965369", "Tags": "<c++><c++-faq>", "AnswerCount": "4"}, "8111750": {"Id": "8111750", "PostTypeId": "2", "Body": "<p><strong>Koenig Lookup</strong> is also commonly known as <strong><a href=\"http://en.wikipedia.org/wiki/Argument-dependent_name_lookup\">Argument Dependent Lookup</a></strong> in C++ and most of the Standard C++ compilers support it.     </p>\n<p>The C++11 standard \u00a7 3.4.2/1 states:</p>\n<blockquote>\n<p id=\"so_8111677_8111750_0\">When the postfix-expression in a function call (5.2.2) is an unqualified-id, other namespaces not considered during the usual unqualified lookup (3.4.1) may be searched, and in those namespaces, namespace-scope friend function declarations (11.3) not otherwise visible may be found. These modifications to the search depend on the types of the arguments (and for template template arguments, the namespace of the template\n  argument).</p>\n</blockquote>\n<p>In simpler terms Nicolai Josuttis states<sup>1</sup>:    </p>\n<blockquote>\n<p id=\"so_8111677_8111750_1\">You don\u2019t have to qualify the namespace for functions if one or more argument types are defined in the namespace of the function. </p>\n</blockquote>\n<p>A simple code example:     </p>\n<pre><code>namespace MyNamespace\n{\n    class MyClass {};\n    void doSomething(MyClass);\n}\n\nMyNamespace::MyClass obj; // global object\n\n\nint main()\n{\n    doSomething(obj); // Works Fine - MyNamespace::doSomething() is called.\n}\n</code></pre>\n<p>In the above example there is neither a <code>using-declaration</code> nor a <code>using-directive</code> but still the compiler correctly identifies the unqualified name <code>doSomething()</code> as the function declared in namespace <code>MyNamespace</code> by applying the <em>Koenig algorithm</em>.    </p>\n<p><strong>How does it work?</strong><br>\nThe algorithm tells the compiler to not just look at local scope, but also the namespaces that contain the argument's type. Thus, in the above code, the compiler finds that the object <code>obj</code>, which is the argument of the function <code>doSomething()</code>, belongs to the namespace <code>MyNamespace</code>. So, it looks at that namespace to locate the declaration of <code>doSomething()</code>.   </br></p>\n<p><strong>What is the advantage of <code>Koenig Lookup</code>?</strong><br>\nAs the simple code example above demonstrates above the Koenig Algorithm provides convenience and ease of usage to the programmer. Without Koenig Algorithm there would be an overhead on the programmer, to repeatedly specify the fully qualified names, or instead, use numerous using-declarations.   </br></p>\n<p><strong>Why the criticism of <code>Koenig Algorithm</code>?</strong><br>\nOver dependence on Koenig Algorithm can lead to semantic problems,and catch the programmer off guard sometimes.     </br></p>\n<p>Consider the example of <strong><a href=\"http://en.cppreference.com/w/cpp/algorithm/swap\">std::swap</a></strong>, which is a standard library algorithm to swap two values. With the Koenig algorithm one would have to be cautious while using this algorithm because:      </p>\n<pre><code>std::swap(obj1,obj2);    \n</code></pre>\n<p>may not show the same behavior as: </p>\n<pre><code>using std::swap;\nswap(obj1, obj2);\n</code></pre>\n<p>With ADL, which version of <code>swap</code> function gets called would depend on the namespace of the arguments passed to it.<br>\nIf there exists an namespace <code>A</code> and if <code>A::obj1</code>, <code>A::obj2</code> &amp; <code>A::swap()</code> exist then the second example will result in a call to <code>A::swap()</code> which might not be what the user wanted.</br></p>\n<p>Further, if for some reason both:<br>\n<code>A::swap(A::MyClass&amp;, A::MyClass&amp;)</code> and <code>std::swap(A::MyClass&amp;, A::MyClass&amp;)</code> are defined, then the first example will call <code>std::swap(A::MyClass&amp;, A::MyClass&amp;)</code> but the second will not compile because <code>swap(obj1, obj2)</code> would be ambiguous.</br></p>\n<p><strong>Trivia:</strong><br>\n<strong>Why is it called <code>Koenig Lookup</code>?</strong><br>\nBecause it was devised by  former AT&amp;T and Bell Labs researcher and programmer,<strong><a href=\"http://en.wikipedia.org/wiki/Andrew_Koenig_%28programmer%29\">Andrew Koenig</a></strong>.</br></br></p>\n<hr>\n<p>Good Reads:    </p>\n<p><strong><a href=\"http://www.gotw.ca/gotw/030.htm\">Herb Sutter's Name Lookup on GotW</a></strong><br>\n<strong>Standard C++03/11 [basic.lookup.argdep]: 3.4.2 Argument-dependent name lookup.</strong></br></p>\n<hr>\n<p><sub>\n<strong><sup>1</sup></strong> The definition of Koenig Algorithm is as defined in Josuttis's book, <strong>The C++ Standard Library: A Tutorial and Reference</strong>.<br>\n</br></sub></p>\n</hr></hr>", "LastEditorUserId": "1381108", "LastActivityDate": "2014-06-09T00:15:33.870", "Score": "148", "CreationDate": "2011-11-13T13:12:02.043", "ParentId": "8111677", "CommentCount": "5", "OwnerUserId": "452307", "LastEditDate": "2014-06-09T00:15:33.870"}, "8111881": {"Id": "8111881", "PostTypeId": "2", "Body": "<p>Maybe it is best to start with the why, and only then go to the how.</p>\n<p>When namespaces were introduced, the idea was to have everything defined in namespaces, so that separate libraries don't interfere with each other. However that introduced a problem with operators. Look for example at the following code:</p>\n<pre><code>namespace N\n{\n  class X {};\n  void f(X);\n  X&amp; operator++(X&amp;);\n}\n\nint main()\n{\n  // define an object of type X\n  N::X x;\n\n  // apply f to it\n  N::f(x);\n\n  // apply operator++ to it\n  ???\n}\n</code></pre>\n<p>Of course you could have written <code>N::operator++(x)</code>, but that would have defeated the whole point of operator overloading. Therefore a solution had to be found which allowed the compiler to find <code>operator++(X&amp;)</code> despite the fact that it was not in scope. On the other hand, it still should not find another <code>operator++</code> defined in another, unrelated namespace which might make the call ambiguous (in this simple example, you wouldn't get ambiguity, but in more complex examples, you might). The solution was Argument Dependent Lookup (ADL), called that way since the lookup depends on the argument (more exactly, on the argument's type). Since the scheme was invented by Andrew R. Koenig, it is also often called Koenig lookup.</p>\n<p>The trick is that for function calls, in addition to normal name lookup (which finds names in scope at the point of use), there is done a second lookup in the scopes of the types of any arguments given to the function. So in the above example, if you write <code>x++</code> in main, it looks for <code>operator++</code> not only in global scope, but additionally in the scope where the type of <code>x</code>, <code>N::X</code>, was defined, i.e. in <code>namespace N</code>. And there it finds a matching <code>operator++</code>, and therefore <code>x++</code> just works. Another <code>operator++</code> defined in another namespace, say <code>N2</code>, will not be found, however. Since ADL is not restricted to namespaces, you also can use <code>f(x)</code> instead of <code>N::f(x)</code> in <code>main()</code>.</p>\n", "LastEditorUserId": "509868", "LastActivityDate": "2015-07-16T08:49:00.213", "Score": "20", "CreationDate": "2011-11-13T13:32:12.790", "ParentId": "8111677", "CommentCount": "1", "OwnerUserId": "1032073", "LastEditDate": "2015-07-16T08:49:00.213"}});