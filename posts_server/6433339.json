post_cb({"6433339": {"ViewCount": "1679", "Body": "<p>Example from MSVC's implementation:</p>\n<pre><code>#define offsetof(s,m) \\\n    (size_t)&amp;reinterpret_cast&lt;const volatile char&amp;&gt;((((s *)0)-&gt;m))\n//                                                   ^^^^^^^^^^^\n</code></pre>\n<p>As can be seen, it dereferences a null pointer, which normally invokes undefined behaviour. Is this an exception to the rule or what is going on?</p>\n", "AcceptedAnswerId": "6433724", "Title": "Does the 'offsetof' macro from <stddef.h> invoke undefined behaviour?", "CreationDate": "2011-06-21T23:48:58.367", "Id": "6433339", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-08-09T19:55:34.647", "Score": "16", "OwnerUserId": "500104", "Tags": "<c++><undefined-behavior><offsetof>", "AnswerCount": "5"}, "6433792": {"Id": "6433792", "PostTypeId": "2", "Body": "<p>The notion of \"undefined behavior\" is not applicable to the implementation of the Standard Library, regardless of whether it is a macro, a function or anything else. </p>\n<p>In general case, the Standard Library should not be seen as implemented in C++ (or C) language. That applies to standard header files as well. The Standard Library should conform to its external specification, but everything else is an implementation detail, exempt from all and any other requirements of the language. The Standard Library should be always thought of as implemented in some \"internal\" language, which might closely resemble C++ or C, but still is not C++ or C.</p>\n<p>In other words, the macro you quoted does not produce undefined behavior, as long as it is specifically the <code>offsetof</code> macro defined in the Standard Library. But if you do exactly the same thing in your code (like define your own macro in the very same way), it will indeed result in undefined behavior. \"Quod licet Jovi, non licet bovi\".</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2011-06-22T01:11:44.853", "Score": "12", "CreationDate": "2011-06-22T01:06:08.773", "ParentId": "6433339", "CommentCount": "13", "OwnerUserId": "187690", "LastEditDate": "2011-06-22T01:11:44.853"}, "bq_ids": {"n4140": {"so_6433339_6434112_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 3222}}, "n3337": {"so_6433339_6434112_0": {"length": 21, "quality": 1.0, "section_id": 3096}}, "n4659": {"so_6433339_6434112_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 3979}}}, "6434112": {"Id": "6434112", "PostTypeId": "2", "Body": "<p>This is basically equivalent to asking whether this is UB:</p>\n<pre><code>s* p = 0;\nvolatile auto&amp; r = p-&gt;m;\n</code></pre>\n<p>Clearly no memory access is generated to the target of <code>r</code>, because it's <code>volatile</code> and the compiler is prohibited from generating spurious accesses to <code>volatile</code> variables.  But <code>*s</code> is not volatile, so the compiler could possibly generate an access to it.  Neither the address-of operator nor casting to reference type creates an <em>unevaluated context</em> according to the standard.</p>\n<p>So, I don't see any reason for the <code>volatile</code>, and I agree with the others that this is undefined behavior according to the standard.  Of course, any compiler is permitted to define behavior where the standard leaves it implementation-specified or undefined.</p>\n<p>Finally, a note in section <code>[dcl.ref]</code> says </p>\n<blockquote>\n<p id=\"so_6433339_6434112_0\">in particular, a null reference cannot exist in a well-defined program, because the only way to create such a reference would be to bind it to the \"object\" obtained by dereferencing a null pointer, which causes undefined behavior.</p>\n</blockquote>\n", "LastActivityDate": "2011-06-22T02:03:33.457", "CommentCount": "1", "CreationDate": "2011-06-22T02:03:33.457", "ParentId": "6433339", "Score": "1", "OwnerUserId": "103167"}, "31908253": {"Id": "31908253", "PostTypeId": "2", "Body": "<p>When the C Standard specifies that certain actions invoke Undefined Behavior, that does has not generally meant that such actions were forbidden, but rather that implementations were free to specify the consequent behaviors or not as they see fit.  Consequently, implementations would be free to perform such actions in cases where the Standard requires defined behavior, <em>if and only if the implementations can guarantee that the behaviors for those actions will be consistent with what the Standard requires</em>.  Consider, for example, the following implementation of strcpy:</p>\n<pre><code>char *strcpy(char *dest, char const *src)\n{\n  ptrdiff_t diff = dest-src-1;\n  int ch;\n  while((ch = *src++) != 0)\n    src[diff] = ch;\n  return dest;\n}\n</code></pre>\n<p>If <code>src</code> and <code>dest</code> are unrelated pointers, the computation of <code>dest-src</code> would yield Undefined Behavior.  On some platforms, however, the relation between <code>char*</code> and <code>ptrdiff_t</code> is such that given any <code>char* p1, p2</code>, the computation <code>p1 + (p2-p1);</code> will always equal <code>p2</code>.  On platforms which make that guarantee, the above implementation of <code>strcpy</code> would be legitimate (and on some such platforms might be faster than any plausible alternative).  On some other platforms, however, such a function might always fail except when both strings are part of the same allocated object.</p>\n<p>The same principle applies to the <code>offsetof</code> macro.  There is no requirement that compilers offer any way to get behavior equivalent to <code>offsetof</code> (other than by actually using that macro)  If a compiler's model for pointer arithmetic makes it possible to get the required <code>offsetof</code> behavior by using the <code>-&gt;</code> operator on a null pointer, then its <code>offsetof</code> macro can do that.  If a compiler wouldn't support any efforts to use <code>-&gt;</code> on something other than a legitimate pointer to an instance of the type, then it may need to define an intrinsic which can compute a field offset and define the <code>offsetof</code> macro to use that.  What's important is not that the Standard define the behaviors of actions performed using standard-library macros and functions, but rather than the implementation ensures that behaviors of such macros and functions match requirements.</p>\n", "LastActivityDate": "2015-08-09T19:55:34.647", "CommentCount": "0", "CreationDate": "2015-08-09T19:55:34.647", "ParentId": "6433339", "Score": "2", "OwnerUserId": "363751"}, "6433724": {"Id": "6433724", "PostTypeId": "2", "Body": "<p>Where the language standard says \"undefined behavior\", any given compiler can define the behavior. Implementation code in the standard library typically relies on that. So there are two questions:</p>\n<p>(1) Is the code UB with respect to the C++ standard?</p>\n<p>That's a really hard question, because it's a well known almost-defect that the C++98/03 standard never says right out in normative text that in general it's UB to dereference a nullpointer. It is <em>implied</em> by the exception for <code>typeid</code>, where it's <em>not</em> UB.</p>\n<p>What you can say decidedly is that it's UB to use <code>offsetof</code> with a non-POD type.</p>\n<p>(2) Is the code UB with respect to the compiler that it's written for?</p>\n<p>No, of course not.</p>\n<p>A compiler vendor's code for a given compiler can use any feature of that compiler.</p>\n<p>Cheers &amp; hth.,</p>\n", "LastActivityDate": "2011-06-22T00:54:21.840", "CommentCount": "6", "CreationDate": "2011-06-22T00:54:21.840", "ParentId": "6433339", "Score": "23", "OwnerUserId": "464581"}, "6433378": {"Id": "6433378", "PostTypeId": "2", "Body": "<p>No, this is NOT undefined behaviour.  The expression is resolved at runtime.</p>\n<p>Note that it is taking the address of the member <code>m</code> from a null pointer.  It is NOT dereferencing the null pointer.</p>\n", "LastActivityDate": "2011-06-21T23:55:35.137", "CommentCount": "17", "CreationDate": "2011-06-21T23:55:35.137", "ParentId": "6433339", "Score": "-2", "OwnerUserId": "431359"}});