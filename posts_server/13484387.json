post_cb({"13484458": {"ParentId": "13484387", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>There's no real advantage to adding such a feature to the language.  Features generally don't get added unless there's demand.</p>\n<p>What would namespaces inside classes buy you?  Would you really rather say <code>binary_tree::iterator::left_depth</code> instead of simply <code>binary_tree::left_depth</code>?  Perhaps if you had multiple namespaces inside, you use them to distinguish say <code>binary_tree::depth_iterator::left</code> and <code>binary_tree::breadth_iterator::right</code>.</p>\n<p>In any event, you can achieve the desired result using internal classes as a poor-programmer's namespace, which is even more reason why there isn't demand for true namespaces inside classes.</p>\n", "OwnerUserId": "1386054", "LastEditorUserId": "1386054", "LastEditDate": "2016-11-17T18:56:38.800", "Id": "13484458", "Score": "3", "CreationDate": "2012-11-21T00:20:10.773", "LastActivityDate": "2016-11-17T18:56:38.800"}, "13484387": {"CommentCount": "3", "AcceptedAnswerId": "13484458", "CreationDate": "2012-11-21T00:10:57.217", "LastActivityDate": "2017-10-05T14:57:55.870", "PostTypeId": "1", "ViewCount": "22485", "FavoriteCount": "2", "Title": "Why can't we declare a namespace within a class?", "Id": "13484387", "Score": "29", "Body": "<p>Declaring a class within a class is valid. (Nested classes)</p>\n<p>Declaring a namespace within a class is invalid.</p>\n<p>The question is: is there any good reason (other than c++ grammar/syntax problems) to forbid the declaration of a namespace within a class ?</p>\n<hr>\n<p>As for why would i want to do that, here is an exemple :</p>\n<p>Let's have a basic delcaration of a binary tree container</p>\n<pre><code>template&lt;typename Data&gt;\nclass binary_tree\n{\n public:\n  ... stuff ....     \n\n private:\n  ... iterators class declaration ...\n\n public:\n  typedef left_depth_iterator_impl     left_depth_iterator;\n  typedef right_depth_iterator_impl    right_depth_iterator;\n  typedef left_breadth_iterator_impl   left_breadth_iterator;\n  typedef right_breadth_iterator_impl  right_breadth_iterator;\n\n  ... stuff ....     \n\n private:\n  Data         data;\n  binary_tree* left;\n  binary_tree* right;\n};\n</code></pre>\n<p>Now i notice that there are a lot of iterators in my class, so i would like to regroup them within the same namespace like this :</p>\n<pre><code>template&lt;typename Data&gt;\nclass binary_tree\n{\n public:\n  ... stuff ....     \n\n private:\n  ... iterators class declaration ...\n\n public:\n  namespace iterator\n  {\n    typedef left_depth_iterator_impl     left_depth;\n    typedef right_depth_iterator_impl    right_depth;\n    typedef left_breadth_iterator_impl   left_breadth;\n    typedef right_breadth_iterator_impl  right_breadth;\n  }\n\n  ... stuff ....     \n\n private:\n  Data         data;\n  binary_tree* left;\n  binary_tree* right;\n};\n</code></pre>\n<p>This would allow a simple usage :</p>\n<pre><code>void  function()\n{\n  binary_tree::iterator::left_depth   it;\n\n  ...stuff...\n}\n</code></pre>\n<p>This works if i use a class instead of a namespace, but i am then forced to declare a class that will never be instantiated which is quite a namespace.</p>\n<p>Why allow nested classes and forbid nested namespaces within classes ? is it historical ?</p>\n<hr>\n<p>Answers with semantic reasons that do not only quote part of the standard(especially syntax parts) will be apreciated :)</p>\n</hr></hr>", "Tags": "<c++><class><namespaces>", "OwnerUserId": "1147772", "AnswerCount": "4"}, "13484417": {"ParentId": "13484387", "CommentCount": "0", "Body": "<p>This is just not the point of namespaces.  Namespaces are meant to exist closer to the top level of code so that if two different companies (or code bases) can mix code with each other.  At a more micro level, I code with both IMAP for email access and SMTP for email sending and (could, I am simplifying greatly) have classes in either module called <code>Email</code> that are quite different, but I could have an application, say a mail client, that wants to use both from the same class, e.g. perhaps it forwards mails from one account to another.  Namespaces / package names / etc. permit this.</p>\n<p>What you have proposed simply isn't what namespaces are for - within one file you are able to give things different names since the author has global knowledge of the file, although this isn't true when two companies want to share code or two applications that didn't know they would be colliding at any point.</p>\n", "OwnerUserId": "1339987", "PostTypeId": "2", "Id": "13484417", "Score": "4", "CreationDate": "2012-11-21T00:15:24.727", "LastActivityDate": "2012-11-21T00:15:24.727"}, "45087567": {"ParentId": "13484387", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I'm going to disagree with others here. I wouldn't say there's no real advantage. Sometimes I'd just like to segregate code without extra implications. As an example, I was working in a multithreaded ringbuffer module and wanted to split the state members, some of which are atomic and/or memory-aligned, into namespaces for the producer and the consumer.</p>\n<p>By just naming everything with <code>producer</code> or <code>consumer</code> prefixes (which is my current annoying implementation), I'm adding pollution that makes code harder to read. E.g. when everything owned by the producer starts with <code>producer</code>, it's easier for your brain when reading it to accidentally autocorrect <code>producerProducerTimer</code> (producer copy of a producer timer) as <code>producerConsumerTimer</code> (producer shadow of a consumer timer) or <code>consumerProducerTimer</code> (consumer shadow of a producer timer). Debugging that takes way longer than it needs to because the code is no longer skimmable.</p>\n<p>By creating a nested class/struct:</p>\n<ul>\n<li>I could be giving the next developer who maintains this code the idea that more than one of these could/should be instantiated, copied, and assigned to one another within a context, so now instead of just worrying about naming I also have to <code>= delete</code> these things.</li>\n<li>I could be adding memory footprint to the context with structural alignment padding that might not otherwise be necessary.</li>\n<li>Making all members static isn't an option, since more than one context can be instantiated that will need its own producer/consumer state variables.</li>\n<li>Functions of such a struct no longer have access to other member data or functions, such as constants or functions that are shared by both sides, but instead have to take these things as arguments.</li>\n</ul>\n<p>Ideally, I'd like to be able to change things like this:</p>\n<pre><code>rbptr producerPosition;\nrbptr consumerPosition;\n</code></pre>\n<p>to this:</p>\n<pre><code>namespace producer\n{\n    rbptr position;\n}\nnamespace consumer\n{\n    rbptr position;\n}\n</code></pre>\n<p>Then, functions that should only touch consumer members can use the consumer namespace, functions that should only touch the producer members can use the producer namespace, and functions that need to touch both have to explicitly qualify them. There'd be no way to accidentally touch a consumer variable in a function that's only using the producer namespace.</p>\n<p>In this case, the desire is purely for reducing naming collisions between producer and consumer copies of things, and reducing naming collisions are what namespaces exist for. For that reason, I support the proposal to be able to declare namespaces inside classes.</p>\n", "OwnerUserId": "6136292", "LastEditorUserId": "6136292", "LastEditDate": "2017-10-05T14:57:55.870", "Id": "45087567", "Score": "2", "CreationDate": "2017-07-13T17:38:47.497", "LastActivityDate": "2017-10-05T14:57:55.870"}, "bq_ids": {"n4140": {"so_13484387_13484574_2": {"section_id": 5471, "quality": 0.875, "length": 28}, "so_13484387_13484574_1": {"section_id": 5862, "quality": 0.9487179487179487, "length": 37}, "so_13484387_13484574_0": {"section_id": 5476, "quality": 0.7, "length": 7}}, "n3337": {"so_13484387_13484574_2": {"section_id": 5257, "quality": 0.875, "length": 28}, "so_13484387_13484574_1": {"section_id": 5632, "quality": 0.9487179487179487, "length": 37}, "so_13484387_13484574_0": {"section_id": 5262, "quality": 0.7, "length": 7}}, "n4659": {"so_13484387_13484574_0": {"section_id": 6908, "quality": 0.7, "length": 7}, "so_13484387_13484574_1": {"section_id": 7345, "quality": 0.8205128205128205, "length": 32}, "so_13484387_13484574_2": {"section_id": 6906, "quality": 0.875, "length": 28}}}, "13484574": {"ParentId": "13484387", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Since you asked which parts of the standard mandate namespace location, we hit that up first:</p>\n<blockquote>\n<p id=\"so_13484387_13484574_0\"><strong>C++11 7.3-p4:</strong> Every namespace-definition shall appear in the global scope or in a namespace scope (3.3.6).</p>\n</blockquote>\n<p>Regarding class definitions and the proposition of declaring a namespace within, I bring you to...</p>\n<blockquote>\n<p id=\"so_13484387_13484574_1\"><strong>C++11 9.2-p2:</strong> A class is considered a completely-defined object type (3.9) (or complete type) at the closing } of the class-specifier. Within the class member-specification, the class is regarded as complete within function bodies, default arguments, exception-specifications, and brace-or-equal-initializers for non-static data members (including such things in nested classes). Otherwise it is regarded as incomplete within its own class member-specification.</p>\n</blockquote>\n<p>Ergo, a class definition is finite once the closing curly is reached. It cannot be opened back up and extended (derivation is something different, but it is NOT extending <em>the class just defined</em>).</p>\n<p>But lurking at the very beginning of the standard definition of a namespace is the ability to extend it; to expand it for lack of a better term:</p>\n<blockquote>\n<p id=\"so_13484387_13484574_2\"><strong>C++ 7.3-p1:</strong> A namespace is an optionally-named declarative region. The name of a namespace can be used to access entities declared in that namespace; that is, the members of the namespace. <strong>Unlike other declarative regions, the definition of a namespace can be split over several parts of one or more translation units.</strong> (emphasis added).</p>\n</blockquote>\n<p>Therefore, a namespace within a class would violate the definition in 7.3-p4. Assuming that was not present, it would be <em>possible</em> to declare a namespace anywhere, including in a class, but since the definition of a class is formalized once it is closed, you would be left with only the ability to do the following if you maintained compliance with 7.3-p1:</p>\n<pre><code>class Foo\n{\n   namespace bar\n   {\n       ..stuff..\n   }\n\n   .. more stuff ..\n\n   namespace bar\n   {\n       ..still more stuff..\n   }\n};\n</code></pre>\n<p>The usefulness of this <em>feature</em> was likely debated for about 3-full-seconds before 7.3-p4 was established to settle it.</p>\n", "OwnerUserId": "1322972", "LastEditorUserId": "1322972", "LastEditDate": "2014-05-13T17:52:30.227", "Id": "13484574", "Score": "34", "CreationDate": "2012-11-21T00:35:16.157", "LastActivityDate": "2014-05-13T17:52:30.227"}});