post_cb({"29794514": {"CommentCount": "3", "ViewCount": "155", "PostTypeId": "1", "LastEditorUserId": "3367929", "CreationDate": "2015-04-22T10:21:10.003", "LastActivityDate": "2015-04-22T19:05:16.923", "Title": "Defining macro improving syntax of specific function", "AcceptedAnswerId": "29795139", "LastEditDate": "2015-04-22T10:27:22.937", "Id": "29794514", "Score": "3", "Body": "<p>I've created a function declared as:</p>\n<pre><code>template &lt;typename Container, typename Task&gt;\nvoid parallel_for_each(Container &amp;container, Task task,\n                       unsigned number_of_threads = std::thread::hardware_concurrency())\n</code></pre>\n<p>It's not difficult to guess what it is supposed to do. I'd like to create a macro simplifying the syntax of this function and making the its syntax \"loop-like\". I've come up with an idea:</p>\n<pre><code>#define in ,\n#define pforeach(Z,X,Y) parallel_for_each(X,[](Z)-&gt;void{Y;})\n</code></pre>\n<p>Where usage as:</p>\n<pre><code>pforeach(double &amp;element, vec,\n    {\n     element *= 2;\n    });\n</code></pre>\n<p>works as expected, but this one: </p>\n<pre><code>pforeach(double &amp;element in vec,\n    {\n     element *= 2;\n     element /= 2;\n    });\n</code></pre>\n<p>gives an error </p>\n<blockquote>\n<p id=\"so_29794514_29794514_0\">macro \"pforeach\" requires 3 arguments, but only 2 given</p>\n</blockquote>\n<p>Do you have any idea how to write a macro allowing even \"nicer\" syntax? Why \"in\" doesn't stand for comma in my code?</p>\n", "Tags": "<c++><c++11><macros>", "OwnerUserId": "3367929", "AnswerCount": "4"}, "29795139": {"ParentId": "29794514", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The reason that <code>in</code> is not replaced is that it appears inside an argument to your function-like macro, but for it to be replaced, those arguments have to be propagated to another macro first: Try</p>\n<pre><code>#define in ,\n#define pforeach_(Z,X,Y) parallel_for_each(X,[](Z)-&gt;void{Y;})\n#define pforeach(Z,X,Y) pforeach_(Z,X,Y)\n</code></pre>\n<p><strong>Note</strong>: Defining <code>in</code> as <code>,</code> is not gonna end well!</p>\n<hr>\n<p>An idea to add \"nicer\" syntax:</p>\n<pre><code>template &lt;typename Container&gt;\nstruct Helper {\n    Container&amp;&amp; c;\n    template &lt;typename Arg&gt;\n    void operator=(Arg&amp;&amp; arg) {\n        parallel_for_each(std::forward&lt;Container&gt;(c), std::forward&lt;Arg&gt;(arg));\n    }\n};\n\n#define CONCAT_(a,b) a##b\n#define CONCAT(a,b) CONCAT_(a,b)\n// Easier with Boost.PP\n#define DEC_1 0\n#define DEC_2 1\n#define DEC_3 2\n#define DEC_4 3\n#define DEC_5 4\n#define DEC_6 5\n#define DEC_7 6\n#define DEC_8 7\n#define DEC(i) CONCAT(DEC_,i)\n\n#define pforeach(Z, ...) \\\n  Helper&lt;decltype((__VA_ARGS__))&gt; CONCAT(_unused_obj, __COUNTER__){__VA_ARGS__}; \\\n  CONCAT(_unused_obj, DEC(__COUNTER__))=[](Z)\n</code></pre>\n<p>Usable as</p>\n<pre><code>int a[] = {1, 2, 3};\npforeach(int i, a) {\n    std::cout &lt;&lt; i &lt;&lt; \", \";\n};\n\npforeach(int i, std::vector&lt;int&gt;{1, 2, 3}) {\n    std::cout &lt;&lt; -i &lt;&lt; \", \";\n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/c61547b11bcb1d50\" rel=\"nofollow\"><strong>Demo</strong></a>.<br>\nHas several disadvantages though. I'd just stick with what you've got so far.</br></p>\n</hr>", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-04-22T12:24:08.177", "Id": "29795139", "Score": "4", "CreationDate": "2015-04-22T10:46:57.483", "LastActivityDate": "2015-04-22T12:24:08.177"}, "29806693": {"ParentId": "29794514", "CommentCount": "0", "Body": "<p>Trying to improve the idea of @Columbo :</p>\n<pre><code>template &lt;typename Container&gt;\nstruct __pforeach__helper {\n    Container &amp;&amp;c;\n    template &lt;typename Arg&gt;\n    void operator=(Arg&amp;&amp; arg) {\n        parallel_for_each(std::forward&lt;Container&gt;(c), std::forward&lt;Arg&gt;(arg));\n    }\n};\n\n//additional helper function\ntemplate &lt;typename Container&gt;\n__pforeach__helper&lt;Container&gt; __create__pforeach__helper(Container &amp;&amp;c)\n{\n    return __pforeach__helper&lt;Container&gt;(__pforeach__helper&lt;Container&gt;{c});\n}\n\n#define pforeach(Z,C) \\\n  __create__pforeach__helper(C)=[](Z)\n</code></pre>\n<p>It doesn't rely on <code>__COUNTER__</code> and doesn't require defining <code>DEC_x</code> macros. Any feedback is most welcome!</p>\n", "OwnerUserId": "3367929", "PostTypeId": "2", "Id": "29806693", "Score": "0", "CreationDate": "2015-04-22T19:05:16.923", "LastActivityDate": "2015-04-22T19:05:16.923"}, "29795026": {"ParentId": "29794514", "CommentCount": "0", "Body": "<p>There is no macro langugae. Macros are handled by the C/C++ preprocessor. The implementation of the preprocessors may vary.</p>\n<p>Most preprocessors expect that you pass the exact number of parameters. I found that the GNU preprocessor has a less strict checking of parameters what allows a kind of variadic list. But in general a macro won't help you with your task.</p>\n<p>I recommend to write the short statement in a function instead of a macro. An inline function is as fast and short as a macro, but type safe.\nFurther the function allows default parameter values. So you can skip something.</p>\n", "OwnerUserId": "266487", "PostTypeId": "2", "Id": "29795026", "Score": "0", "CreationDate": "2015-04-22T10:42:25.833", "LastActivityDate": "2015-04-22T10:42:25.833"}, "29795045": {"ParentId": "29794514", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_29794514_29795045_0\">Why \"in\" doesn't stand for comma in my code?</p>\n</blockquote>\n<p>Because that replacement is performed <strong>after</strong> macro arguments are determined. Quoting standard draft N3797, \u00a7 16.3.1 Argument substitution:</p>\n<blockquote>\n<p id=\"so_29794514_29795045_1\">After the arguments for the invocation of a function-like macro have been identified, argument substitution takes place. ... Before being substituted, each argument\u2019s preprocessing tokens are completely macro replaced as if they formed the rest of the preprocessing file; no other preprocessing tokens\n  are available.</p>\n</blockquote>\n<p>So preprocessor identifies <code>pforeach(double &amp;element in vec, {})</code> as a function-like macro call with two arguments:</p>\n<ol>\n<li>First consists of tokens <code>double</code>, <code>&amp;</code>, <code>in</code> and <code>vec</code> and bound to argument <code>Z</code></li>\n<li>Second consists of tokens <code>{</code> and <code>}</code> and bound to argument <code>X</code></li>\n</ol>\n<p>You're obviously miss argument <code>Y</code></p>\n<blockquote>\n<p id=\"so_29794514_29795045_2\">Do you have any idea how to write a macro allowing even \"nicer\" syntax? </p>\n</blockquote>\n<p>It is hard to answer and it is matter of taste. Anyway, C++ has rich capabilities of patching syntax with operator overload, but you can't build DSL with that, so it is better to use default syntax, it is not that ugly (and also makes it easy to read):</p>\n<pre><code> parallel_for_each(vec, [](double&amp; el){ el *= 2; })\n</code></pre>\n", "OwnerUserId": "2709018", "LastEditorUserId": "2709018", "LastEditDate": "2015-04-22T10:50:17.000", "Id": "29795045", "Score": "1", "CreationDate": "2015-04-22T10:43:18.267", "LastActivityDate": "2015-04-22T10:50:17.000"}, "bq_ids": {"n4140": {"so_29794514_29795045_1": {"section_id": 523, "quality": 1.0, "length": 31}}, "n3337": {"so_29794514_29795045_1": {"section_id": 514, "quality": 1.0, "length": 31}}, "n4659": {"so_29794514_29795045_1": {"section_id": 544, "quality": 1.0, "length": 31}}}});