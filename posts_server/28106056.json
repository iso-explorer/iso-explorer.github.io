post_cb({"28106465": {"ParentId": "28106056", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This looks like a bug in your compiler, actually. The standard mandates that during list initialisation, elements of an initialiser list be evaluated strictly in the order they appear. Quoting C++11 8.5.4/4:</p>\n<blockquote>\n<p id=\"so_28106056_28106465_0\">Within the <em>initializer-list</em> of a <em>braced-init-list,</em> the <em>initializer-clauses,</em> <strong>including any that result from pack\n  expansions</strong> (14.5.3), are evaluated in the order in which they appear. That is, every value computation and\n  side effect associated with a given <em>initializer-clause</em> is sequenced before every value computation and side\n  effect associated with any <em>initializer-clause</em> that follows it in the comma-separated list of the <em>initializer-list.</em>\n  [ <em>Note:</em> This evaluation ordering holds regardless of the semantics of the initialization; for example, it applies\n  when the elements of the <em>initializer-list</em> are interpreted as arguments of a constructor call, even though\n  ordinarily there are no sequencing constraints on the arguments of a call. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>(Emphasis mine)</p>\n<p>And indeed, using GCC, your code <a href=\"http://tinyurl.com/pnjsdga\" rel=\"nofollow\">works just fine</a>.</p>\n", "OwnerUserId": "1782465", "LastEditorUserId": "1782465", "LastEditDate": "2015-01-23T09:22:10.153", "Id": "28106465", "Score": "4", "CreationDate": "2015-01-23T09:13:59.597", "LastActivityDate": "2015-01-23T09:22:10.153"}, "28106056": {"CommentCount": "0", "ViewCount": "42", "PostTypeId": "1", "LastEditorUserId": "602798", "CreationDate": "2015-01-23T08:47:19.500", "LastActivityDate": "2015-01-23T09:22:10.153", "Title": "Error when parsing buffer to create a tuple", "AcceptedAnswerId": "28106465", "LastEditDate": "2015-01-23T09:15:55.967", "Id": "28106056", "Score": "1", "Body": "<p>I am trying to build a tuple by reading from a buffer. Here is my code:</p>\n<pre><code>template&lt;class T&gt;\nT read_from_stream(char *&amp; stream)\n{\n    T value;\n    memcpy(&amp;value, stream, sizeof(T));\n    stream += sizeof(T);\n    return value;\n}\n\n\ntemplate &lt;typename ... Args&gt;\ntuple&lt;Args...&gt; parse(char * buffer)\n{\n    return tuple&lt;Args...&gt;{read_from_stream&lt;Args&gt;(buffer)...};\n}\n</code></pre>\n<p>and I use it like</p>\n<pre><code>auto tup = parse&lt;float, int, char&gt;(buf);\n</code></pre>\n<p>Now suppose the added data in buffer is in sequence float, int, char... the read_from_stream gets called in the reverse order i.e for char first then for int and then for float. I am having to specify the function template parameter types in the reverse order (parse) to read the data correctly. I want the order to be preserved.\nWhat am I doing wrong?</p>\n<p>I am using vs2013(update 4) by the way</p>\n", "Tags": "<c++11><buffer><tuples>", "OwnerUserId": "602798", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28106056_28106465_0": {"section_id": 3326, "quality": 0.9032258064516129, "length": 56}}, "n3337": {"so_28106056_28106465_0": {"section_id": 3196, "quality": 0.9032258064516129, "length": 56}}, "n4659": {"so_28106056_28106465_0": {"section_id": 4092, "quality": 0.9032258064516129, "length": 56}}}});