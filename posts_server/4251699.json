post_cb({"4251799": {"Id": "4251799", "PostTypeId": "2", "Body": "<p>Section 2.5 of the ISO/IEC 14882:1998 standard (the original C++ standard) says:</p>\n<blockquote>\n<h3>\u00a72.5 Alternative tokens [lex.digraph]</h3>\n<p id=\"so_4251699_4251799_0\">1 Alternative token representations are provided for some operators and punctuators<sup>16)</sup>.</p>\n<p id=\"so_4251699_4251799_1\">2 In all respects of the language, each alternative token behaves the same, respectively, as its primary token,\n  except for its spelling<sup>17)</sup>. The set of alternative tokens is defined in Table 2.</p>\n<p id=\"so_4251699_4251799_2\"><sup>16)</sup> These include \u201cdigraphs\u201d and additional reserved words. The term \u201cdigraph\u201d (token consisting of two characters) is not perfectly\n  descriptive, since one of the alternative preprocessing tokens\n  is %:%: and of course several primary tokens contain two characters.\n  Nonetheless, those alternative tokens that aren\u2019t lexical keywords are colloquially known as \u201cdigraphs\u201d.</p>\n<p id=\"so_4251699_4251799_3\"><sup>17)</sup> Thus the \u201cstringized\u201d values (16.3.2) of [ and &lt;: will be different, maintaining the source spelling, but the tokens can otherwise be\n  freely interchanged.</p>\n</blockquote>\n<pre>\n                 Table 2\u2014alternative tokens\n_______________________________________________________________________________\n    alternative  primary  |  alternative  primary  |  alternative  primary\n     &lt;%            {      |     and          &amp;&amp;    |    and_eq       &amp;=\n     %&gt;            }      |    bitor         |     |    or_eq        |=\n     &lt;:            [      |     or           ||    |    xor_eq       ^=\n     :&gt;            ]      |     xor          ^     |     not         !\n     %:            #      |    compl         ~     |    not_eq       !=\n     %:%:          ##     |    bitand        &amp;     |\n_______________________________________________________________________________\n</pre>\n<p>There is no discussion of 'if you include some header' (though in C, you need <code>#include &lt;iso646.h&gt;</code>).  Any implementation that does not support the keywords or digraphs is not compliant with the 1998 edition, let alone later editions, of the C++ standard.</p>\n", "LastEditorUserId": "15168", "LastActivityDate": "2010-11-23T01:32:49.090", "Score": "1", "CreationDate": "2010-11-23T01:07:19.780", "ParentId": "4251699", "CommentCount": "0", "OwnerUserId": "15168", "LastEditDate": "2010-11-23T01:32:49.090"}, "4251718": {"Id": "4251718", "PostTypeId": "2", "Body": "<p>They are in fact standard in C++, as defined by the ISO 14882:2003 C++ standard 2.5/2 (and, indeed, as defined by the 1998 edition of the standard). Note that they are built into the language itself and don't require that you include a header file of some sort.</p>\n<p>However, they are <strong>very rarely</strong> used, and I have yet to see production code that actually uses the alternative tokens. The only reason why the alternative tokens exist in the first place is because these characters on some keyboards (especially non-QWERTY ones) were either nonexistent or clumsy to type. It's still in the standard for backwards compatibility.</p>\n<p>Even though they are standard, I highly recommend that you don't use them. The alternative tokens require more characters to type, and the QWERTY keyboard layout already has all the characters needed to type out C++ code without having to use the alternative tokens. Also, they would most likely bewilder readers of your code.</p>\n<blockquote>\n<p id=\"so_4251699_4251718_0\"><strong>2.5/2 Alternative tokens</strong></p>\n<p id=\"so_4251699_4251718_1\">In all respects of the language, each\n  alternative token behaves the same,\n  respectively, as its primary token,\n  except for its spelling. The set of\n  alternative tokens is defined in Table\n  2.</p>\n</blockquote>\n<pre>Table 2 - alternative tokens\n+--------------+-----------+\n| Alternative  |  Primary  |\n+--------------+-----------+\n|    &lt;%        |    {      |\n|    %&gt;        |    }      |\n|    &lt;:        |    [      |\n|    :&gt;        |    ]      |\n|    %:        |    #      |\n|    %:%:      |    ##     |\n|    and       |    &amp;&amp;     |\n|    bitor     |    |      |\n|    or        |    ||     |\n|    xor       |    ^      |\n|    compl     |    ~      |\n|    bitand    |    &amp;      |\n|    and_eq    |    &amp;=     |\n|    or_eq     |    |=     |\n|    xor_eq    |    ^=     |\n|    not       |    !      |\n|    not_eq    |    !=     |\n+--------------+-----------+</pre>\n", "LastEditorUserId": "15168", "LastActivityDate": "2010-11-23T02:15:13.833", "Score": "25", "CreationDate": "2010-11-23T00:45:27.073", "ParentId": "4251699", "CommentCount": "24", "OwnerUserId": "308661", "LastEditDate": "2010-11-23T02:15:13.833"}, "4251729": {"Id": "4251729", "PostTypeId": "2", "Body": "<p>they're standard C++, but with older compilers and possibly also with MSVC 10.0 (i haven't checked) you may have to include a special header, [isosomethingsomething.h]</p>\n<p>cheers &amp; hth.,</p>\n", "LastActivityDate": "2010-11-23T00:46:59.960", "CommentCount": "2", "CreationDate": "2010-11-23T00:46:59.960", "ParentId": "4251699", "Score": "4", "OwnerUserId": "464581"}, "4251771": {"Id": "4251771", "PostTypeId": "2", "Body": "<p>Wow, i've been using and looking at many C++ code examples for years.. and never, until now, knew about these so I guess that means most people don't use them. So, for the sake of consistency (if you plan on working in group projects etc) it's probably best to make a habit of using &amp;&amp; and ||.</p>\n", "LastActivityDate": "2010-11-23T01:01:45.167", "CommentCount": "0", "CreationDate": "2010-11-23T01:01:45.167", "ParentId": "4251699", "Score": "2", "OwnerUserId": "516819"}, "4251721": {"Id": "4251721", "PostTypeId": "2", "Body": "<p>These keywords ARE standard and are described in section 2.5 of the standard.  Table 2 is a table of these \"alternative tokens\".  You can use them all you want, even though everyone will hate you if you do.</p>\n", "LastActivityDate": "2010-11-23T00:45:37.293", "CommentCount": "0", "CreationDate": "2010-11-23T00:45:37.293", "ParentId": "4251699", "Score": "7", "OwnerUserId": "301883"}, "bq_ids": {"n4140": {"so_4251699_4251799_2": {"length": 27, "quality": 0.7297297297297297, "section_id": 5325}, "so_4251699_4251718_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 5326}, "so_4251699_4251799_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 5326}, "so_4251699_4251799_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 5326}, "so_4251699_4251799_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5325}}, "n3337": {"so_4251699_4251799_2": {"length": 27, "quality": 0.7297297297297297, "section_id": 5122}, "so_4251699_4251718_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 5123}, "so_4251699_4251799_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 5123}, "so_4251699_4251799_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 5123}, "so_4251699_4251799_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5122}}, "n4659": {"so_4251699_4251799_2": {"length": 27, "quality": 0.7297297297297297, "section_id": 6746}, "so_4251699_4251799_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 6747}, "so_4251699_4251718_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 6747}, "so_4251699_4251799_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 6747}, "so_4251699_4251799_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 6746}}}, "4251699": {"ViewCount": "2601", "Body": "<p>I'm used to the <code>and</code> and <code>or</code> keywords in C++. I've always used them and typing them is fast and comfortable for me. Once I've heard that these aliases are non-standard and may not work on all compilers. But I'm not sure of it, I don't really know if it's true.<br>\nLet's assume that I give someone my code, will he have problems compiling it?<br>\nIs it all right when I use <code>and</code>, <code>or</code> instead of <code>&amp;&amp;</code>, <code>||</code>? Or are these keywords really non-standard?<br>\nP.S.I use the MinGW compiler.</br></br></br></p>\n", "AcceptedAnswerId": "4251718", "Title": "Is it okay to use \"and\", \"or\" etc. instead of \"&&\", \"||\"?", "CreationDate": "2010-11-23T00:40:54.753", "Id": "4251699", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2010-11-23T00:48:34.430", "LastEditorUserId": "431287", "LastActivityDate": "2012-10-26T21:23:39.553", "Score": "17", "OwnerUserId": "431287", "Tags": "<c++><operators><standards>", "AnswerCount": "8"}, "13094633": {"Id": "13094633", "PostTypeId": "2", "Body": "<p>Obviously in regards to backward compatability the \"and/or\" keywords are not the issue. I would believe them to be the newer standard. It is just old programmers not understanding that some noob might have to be able to read the code and not want to look up what &amp;&amp; means. Then again if any IT department is worth it's salt it will make the programmers conform to the standards of the company! That is my belief so (and/or) are futuristic and real possible standard going towards the future. &amp;&amp; is backward compatable not(pun) (and/or).</p>\n", "LastActivityDate": "2012-10-26T21:23:39.553", "CommentCount": "1", "CreationDate": "2012-10-26T21:23:39.553", "ParentId": "4251699", "Score": "0", "OwnerUserId": "1778308"}, "4251714": {"Id": "4251714", "PostTypeId": "2", "Body": "<p>They are standard in the new c++0x standard. Up-to-date modern compilers should recognise them, although I don't believe they are obliged to yet. Whatever floats your boat, I assume.</p>\n", "LastActivityDate": "2010-11-23T00:44:28.650", "CommentCount": "2", "CreationDate": "2010-11-23T00:44:28.650", "ParentId": "4251699", "Score": "5", "OwnerUserId": "514672"}, "7900400": {"Id": "7900400", "PostTypeId": "2", "Body": "<p>I have always messed up ^ (xor) and the ~ (two complement) operators. With the alternative tokens (that I believe should be primary ones) there is no question about what they do, yes, I agree with former posters that the textual ones are much more descriptive.</p>\n<p>There is another possible messup using the digraphs, it is possible to forget one of the characters in ||, &amp;&amp; that will cause subtle bugs and strange behaviours.\nWith the textual operators, it is much harder to make such a mistake.</p>\n<p>I believe what I mentioned above are real valid arguments to improve code safety and clarity. Most C++ programmers SHOULD in my opinion try to get used to the textual operators in favor of the old cryptic ones.</p>\n<p>I am surprised that so few programmers know about them. These operators should have taken over  long time ago as I see it.</p>\n", "LastActivityDate": "2011-10-26T08:37:34.503", "CommentCount": "0", "CreationDate": "2011-10-26T08:37:34.503", "ParentId": "4251699", "Score": "2", "OwnerUserId": "1014194"}});