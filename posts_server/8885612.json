post_cb({"8885699": {"Id": "8885699", "PostTypeId": "2", "Body": "<p>It could be due to an uninitialised variable. Try stepping through the code in a debugger or just printing out the value of <code>count</code>.</p>\n<p>You could also check that <code>polymerPointer</code> points to allocated memory (how much memory did you allocate for the storage and is it enough for all values of <code>count</code>?).</p>\n", "LastActivityDate": "2012-01-16T20:11:52.777", "Score": "1", "CreationDate": "2012-01-16T20:11:52.777", "ParentId": "8885612", "CommentCount": "0", "OwnerUserId": "688213"}, "8885762": {"Id": "8885762", "PostTypeId": "2", "Body": "<p>You're hitting undefined behavior.</p>\n<p>The following:</p>\n<pre><code>polymerPointer[polymer::count] = new polymer();\npolymer::count++;\n</code></pre>\n<p>is not equivalent to </p>\n<pre><code>polymerPointer[polymer::count] = new polymer();\n</code></pre>\n<p>where <code>polymer()</code> increments <code>polymer::count</code>.</p>\n<p>The undefined behavior results from the fact that you're modifying a value and using that value in the same statement:</p>\n<blockquote>\n<p id=\"so_8885612_8885762_0\"><strong>\u00a71.9 p15</strong> If a side effect on a scalar object is unsequenced relative\n  to either another side effect on the same scalar object or a value\n  computation using the value of the same scalar object, the behavior is\n  undefined.</p>\n</blockquote>\n<p>What probably is occuring is that the count is incremented and then the object is placed in that new position in the array. Now code will access the empty spot left as though it held a valid pointer, or when you get to the end of an array you may try to place the pointer out of the bounds of the array.</p>\n<p>It's bad design to put the count increment in a different place than where you actually insert into the array. What you should do is write a static member function that adds elements to the array and updates the count, and then use that instead of manually creating the object and manually placing it in the array, while expecting the count to get updated automatically.</p>\n<pre><code>class polymer {\n    static void create_new_polymer() {\n        polymerPointer[polymer::count] = new polymer();\n        count++;\n    }\n};\n</code></pre>\n<p>Even better would be to just use a <code>vector</code> and have it manage it's own count:</p>\n<pre><code>polymerPointer.push_back(new polymer());\n</code></pre>\n", "LastEditorUserId": "365496", "LastActivityDate": "2012-01-16T20:25:47.013", "Score": "2", "CreationDate": "2012-01-16T20:17:46.413", "ParentId": "8885612", "CommentCount": "1", "LastEditDate": "2012-01-16T20:25:47.013", "OwnerUserId": "365496"}, "8885612": {"ViewCount": "729", "Body": "<p>I have a class <code>polymer</code> with a <code>static int count</code>.\nWhen I create a new <code>polymer</code> to add to an array of pointers I am using the <code>count</code> to find the correct location in the array and then I update the <code>count</code> in the constructor. While compiling in Windows it worked. However, when compiling in Linux (Ubuntu) it crashes unless I remove the updating of the <code>count</code> out of the constructor. </p>\n<p>WORKS in Windows and Ubuntu:</p>\n<pre><code>polymerPointer[polymer::count] = new polymer();\npolymer::count++;\n</code></pre>\n<p>WHEN the constructor doesn't update the static variable (see below)</p>\n<pre><code>polymer::polymer(){\n    //sets up lots of variables but doesn't update the static member\n};\n</code></pre>\n<p>CRASHES in Ubuntu (works in Windows):</p>\n<pre><code>polymerPointer[polymer::count] = new polymer();\n</code></pre>\n<p>WHEN the constructor does update the static variable (see below)</p>\n<pre><code>polymer::polymer(){\n    //sets up lots of variables and then updates the static member\n    count++;\n};\n</code></pre>\n<p>I can rewrite the code, but I liked not having to remember to update the variable separately, which is why I put the update in the constructor. Any ideas on what is going wrong?</p>\n", "AcceptedAnswerId": "8885762", "Title": "Updating a static member in a function call causes crash", "CreationDate": "2012-01-16T20:02:31.720", "Id": "8885612", "CommentCount": "2", "LastEditDate": "2012-01-16T20:15:59.200", "PostTypeId": "1", "LastEditorUserId": "845092", "LastActivityDate": "2012-01-16T20:25:47.013", "Score": "2", "OwnerUserId": "1152573", "Tags": "<c++><linux><static><constructor>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_8885612_8885762_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 5811}}, "n3337": {"so_8885612_8885762_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 5584}}, "n4659": {"so_8885612_8885762_0": {"length": 16, "quality": 0.6956521739130435, "section_id": 7272}}}, "8885709": {"Id": "8885709", "PostTypeId": "2", "Body": "<p>The easiest fix would be to split that assignment in two, hence introducing a <em>sequencing</em>:</p>\n<pre><code>polymer*&amp; insert_point = polymerPointer[polymer::count];\ninsert_point = new polymer();\n</code></pre>\n<p>The reasoning is explained in other answers.</p>\n", "LastActivityDate": "2012-01-16T20:12:25.973", "Score": "0", "CreationDate": "2012-01-16T20:12:25.973", "ParentId": "8885612", "CommentCount": "0", "OwnerUserId": "500104"}, "8885692": {"Id": "8885692", "PostTypeId": "2", "Body": "<p>The compiler may legally evaluate <code>polymerPointer[polymer::count]</code> before <code>new polymer();</code> or the other way around, as it wishes. This means that you cannot depend on <code>polymer::count</code> to be the original value. You must use something more deterministic, like <code>std::vector&lt;std::unique_ptr&lt;Polymer&gt;&gt;</code>?</p>\n", "LastActivityDate": "2012-01-16T20:10:55.470", "Score": "1", "CreationDate": "2012-01-16T20:10:55.470", "ParentId": "8885612", "CommentCount": "0", "OwnerUserId": "298661"}, "8885702": {"Id": "8885702", "PostTypeId": "2", "Body": "<p>Your problem is that the standard doesn't guarantee in which order your statement is executed, so <code>polymerPointer[polymer::count] = new polymer();</code> might evaluate <code>polymer::count</code> either before or after <code>new polymer();</code> is executed. </p>\n<p>If you change <code>polymer::count</code> inside of <code>polymers</code> constructor and <code>polymer::count</code> is evaluated after <code>new polymer()</code> you obviously skip indices, which is likely what leads to your crashes.</p>\n<p>But do you really have any pressing reason to use what seems like a c-style array here instead of using <code>std::vector</code> (which would not need the extra <code>count</code> variable)? Furthermore if you have the choice you really shouldn't use manual memory management, so use <code>std::unique_ptr</code> or <code>std::shared_ptr</code> if you have access to C++11, <code>std::tr1::shared_ptr</code> or <code>boost::shared_ptr</code> otherwise. If you are using boost <code>boost::ptr_vector</code> is also an option</p>\n", "LastEditorUserId": "201270", "LastActivityDate": "2012-01-16T20:17:51.977", "Score": "1", "CreationDate": "2012-01-16T20:12:02.607", "ParentId": "8885612", "CommentCount": "2", "LastEditDate": "2012-01-16T20:17:51.977", "OwnerUserId": "201270"}});