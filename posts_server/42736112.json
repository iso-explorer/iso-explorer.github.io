post_cb({"42736112": {"CommentCount": "1", "CreationDate": "2017-03-11T14:01:29.730", "PostTypeId": "1", "AcceptedAnswerId": "42736577", "LastEditorUserId": "3341331", "LastActivityDate": "2017-03-24T04:00:34.423", "LastEditDate": "2017-03-24T04:00:34.423", "ViewCount": "129", "FavoriteCount": "1", "Title": "mismatched std::allocator for some of STL containers", "Id": "42736112", "Score": "9", "Body": "<p>Is it technically valid to use mismatched <code>std::allocator</code> specialization (surely, except its specialization for <code>void</code>) as a template parameter for STL containers (not all of them, but enumerated below plus unordered_(multi)map/set)? Following code compiles fine.</p>\n<pre><code>#include &lt;list&gt;\n#include &lt;forward_list&gt;\n#include &lt;deque&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n\nint main()\n{\n    struct A { bool operator &lt; (A) const { return true; } };\n    struct B {};\n    struct C {};\n    std::list&lt; A, std::allocator&lt; C &gt; &gt; l;\n    std::forward_list&lt; A, std::allocator&lt; C &gt; &gt; fl;\n    std::deque&lt; A, std::allocator&lt; C &gt; &gt; d;\n    std::set&lt; A, std::less&lt; A &gt;, std::allocator&lt; C &gt; &gt; s;\n    std::multiset&lt; A, std::less&lt; A &gt;, std::allocator&lt; C &gt; &gt; ms;\n    std::map&lt; A, B, std::less&lt; A &gt;, std::allocator&lt; C &gt; &gt; m;\n    std::multimap&lt; A, B, std::less&lt; A &gt;, std::allocator&lt; C &gt; &gt; mm;\n}\n</code></pre>\n<p>I believe this is due to allocator being immediately rebound to underlying node type without any relation to its source type.</p>\n", "Tags": "<c++><stl><containers><language-lawyer><allocator>", "OwnerUserId": "1430927", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_42736112_42736577_0": {"section_id": 715, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_42736112_42736577_0": {"section_id": 704, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_42736112_42736577_0": {"section_id": 745, "quality": 0.8571428571428571, "length": 12}}}, "42736577": {"ParentId": "42736112", "CommentCount": "9", "Body": "<p>I'd say this is <em>UB</em> (at least in C++11) because specifying an allocator which has a different <code>value_type</code> from the <code>value_type</code> of the container violates the <em>allocator-aware container requirements</em> which means those instances do not conform to the general container requirements. Furthermore, I can't find anything in the C++11 standard that says that the allocator types are to be rebound from the type provided as template parameter.</p>\n<hr>\n<p>\u00a01. Section <code>[container.requirements.general]</code> tells us:</p>\n<blockquote>\n<p id=\"so_42736112_42736577_0\">13) All of the containers defined in this Clause and in (21.4) except array meet the additional requirements of an allocator-aware container, as described in Table 99.</p>\n</blockquote>\n<p>\u00a02. The <em>Allocator-aware container requirements</em> says:</p>\n<blockquote>\n<p id=\"so_42736112_42736577_1\">Requires: <code>allocator_type::value_type</code> is the same as <code>X::value_type</code>.</p>\n</blockquote>\n<ol start=\"3\">\n<li>Section <code>[default.allocator]</code> specifies</li>\n</ol>\n<blockquote>\n<p id=\"so_42736112_42736577_2\"><code>typedef T value_type;</code></p>\n</blockquote>\n<p>as a member of the <code>allocator</code> template in namespace <code>std</code>.</p>\n<p>\u00a04. Section <code>[multimap.overview]</code> contains:</p>\n<pre><code>template &lt;class Key, class T, class Compare = less&lt;Key&gt;,\n    class Allocator = allocator&lt;pair&lt;const Key, T&gt; &gt; &gt;\nclass multimap {\n    [...]\n    typedef Allocator allocator_type;\n    [...]\n };\n</code></pre>\n<p>(With similar findings for the other containers.)</p>\n</hr>", "OwnerUserId": "951423", "PostTypeId": "2", "Id": "42736577", "Score": "10", "CreationDate": "2017-03-11T14:50:19.850", "LastActivityDate": "2017-03-11T14:50:19.850"}});