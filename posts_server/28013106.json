post_cb({"28013106": {"CommentCount": "4", "ViewCount": "220", "CreationDate": "2015-01-18T18:15:23.787", "LastActivityDate": "2015-01-18T21:52:21.820", "Title": "Why can't we use auto in template static member initialization?", "AcceptedAnswerId": "28013314", "PostTypeId": "1", "Id": "28013106", "Score": "1", "Body": "<p>The following code</p>\n<pre><code>template &lt;typename MemberType&gt;\nstruct Holder {\n    static MemberType member;\n};\n\ntemplate &lt;typename MemberType&gt;\nauto Holder&lt;MemberType&gt;::member;\n</code></pre>\n<p>produces error C2371 in MSVS 2013 if we try to access Holder::member: </p>\n<blockquote>\n<p id=\"so_28013106_28013106_0\">error C2371: 'member' : redefinition; different basic types</p>\n</blockquote>\n<p>However, if in initialization we use template parameter name instead of 'auto' keyword</p>\n<pre><code>template &lt;typename MemberType&gt;\nMemberType Holder&lt;MemberType&gt;::member;\n</code></pre>\n<p>it compiles as expected. So, what is the reason why compiler is unable to infer static member type in this case? </p>\n", "Tags": "<c++><templates><c++11><static>", "OwnerUserId": "2370853", "AnswerCount": "1"}, "28013314": {"ParentId": "28013106", "PostTypeId": "2", "CommentCount": "4", "Body": "\n<p>The declaration of a variable with a placeholder <code>auto</code>/<code>decltype(auto)</code> must have an initializer for the type of the variable to be deduced:</p>\n<blockquote>\n<p id=\"so_28013106_28013314_0\">The type of a variable declared using <code>auto</code> or <code>decltype(auto)</code> is deduced from its initializer. This use is allowed when declaring variables in a block (6.3), in namespace scope (3.3.6), and in a <em>for-init-statement</em> (6.5.3).\n  <code>auto</code> or <code>decltype(auto)</code> shall appear as one of the <em>decl-specifiers</em> in the <em>decl-specifier-seq</em> and the <em>decl-specifier-seq</em> shall be followed by one or more <em>init-declarators</em>, each of which shall have a non-empty <em>initializer</em>.</p>\n</blockquote>\n<p>Your example doesn't have an initializer for the definition, so your code is ill-formed.</p>\n<p>The definition of a static member may have a placeholder, but the problem in your example has to do with the fact that you're using templates and the declaration of the static member is dependent on the template argument. For example, this definition won't compile:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>template &lt;typename MemberType&gt;\nauto Holder&lt;MemberType&gt;::member = 42; // error: redefinition of 'member' with\n                                    // a different type: 'int' vs 'MemberType'\n</code></pre>\n<p><code>Holder&lt;MemberType&gt;</code> causes an implicit instantiation where the compiler will look at the declaration of <code>Holder&lt;MemberType&gt;::member</code>. The compiler doesn't know at the time of this instantiation whether the type deduced from the initializer (<code>int</code>) matches <code>MemberType</code>, which is why you get the strange error \"<code>int</code> vs <code>MemberType</code>\".</p>\n<p>The above code works if you create an explicit specialization of the data member because <code>MemberType</code> is known at the time of the instantiation:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>template &lt;&gt;\nauto Holder&lt;int&gt;::member = 42; // OK, decltype(42) matches int (MemberType) \n</code></pre>\n", "OwnerUserId": "701092", "LastEditorUserId": "701092", "LastEditDate": "2015-01-18T21:52:21.820", "Id": "28013314", "Score": "1", "CreationDate": "2015-01-18T18:36:07.820", "LastActivityDate": "2015-01-18T21:52:21.820"}, "bq_ids": {"n4140": {"so_28013106_28013314_0": {"section_id": 5448, "quality": 0.8648648648648649, "length": 32}}, "n3337": {"so_28013106_28013314_0": {"section_id": 5242, "quality": 0.7297297297297297, "length": 27}}, "n4659": {"so_28013106_28013314_0": {"section_id": 6875, "quality": 0.6486486486486487, "length": 24}}}});