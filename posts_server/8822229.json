post_cb({"8822306": {"ParentId": "8822229", "CommentCount": "2", "Body": "<p>Ok, in a nutshell:</p>\n<ol>\n<li><p>I cannot see why the static members of the class need to be public - they are implementation detail.</p></li>\n<li><p>Do not make them private but instead make them members of the compilation unit (where code that implements your classes will be).</p></li>\n<li><p>Use <code>boost::call_once</code> to perform the static initialisation.</p></li>\n</ol>\n<p>Initialisation on first use is relatively easy to enforce the ordering of, it is the destruction that is far harder to perform in order. Note however that the function used in call_once must not throw an exception. Therefore if it might fail you should leave some kind of failed state and check for that after the call.</p>\n<p><em>(I will assume that in your real example, your load is not something you hard-code in but more likely you load some kind of dynamic table, so you can't just create an in-memory array).</em></p>\n", "OwnerUserId": "442284", "PostTypeId": "2", "Id": "8822306", "Score": "1", "CreationDate": "2012-01-11T15:53:15.660", "LastActivityDate": "2012-01-11T15:53:15.660"}, "8918505": {"ParentId": "8822229", "CommentCount": "0", "Body": "<p>Section 1.9 \"Program execution\" [intro.execution] of the C++11 standard says that</p>\n<blockquote>\n<p id=\"so_8822229_8918505_0\">1 The semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine. ... conforming implementations are required to emulate (only) the observable behavior of the abstract machine as explained below.<br>\n  ...  </br></p>\n<p id=\"so_8822229_8918505_1\">5 A conforming implementation executing a well-formed program shall produce the same observable behavior as one of the possible executions of the corresponding instance of the abstract machine with the same program and the same input.<br>\n  ...</br></p>\n<p id=\"so_8822229_8918505_2\">8 The least requirements on a conforming implementation are:<br>\n  \u2014 Access to volatile objects are evaluated strictly according to the rules of the abstract machine.<br>\n  \u2014 At program termination, all data written into files shall be identical to one of the possible results that execution of the program according to the abstract semantics would have produced.<br>\n  \u2014 The input and output dynamics of interactive devices shall take place in such a fashion that prompting output is actually delivered before a program waits for input. What constitutes an interactive device is implementation-defined.<br>\n  These collectively are referred to as the <em>observable behavior</em> of the program.<br>\n  ...</br></br></br></br></br></p>\n<p id=\"so_8822229_8918505_3\">12 Accessing an object designated by a volatile glvalue (3.10), modifying an object, calling a library I/O function, or calling a function that does any of those operations are all <em>side effects</em>, which are changes in the state of the execution environment.</p>\n</blockquote>\n<p>Also, in 3.7.2 \"Automatic storage duration\" [basic.stc.auto] it is said that</p>\n<blockquote>\n<p id=\"so_8822229_8918505_4\">3 If a variable with automatic storage duration has initialization or a destructor with side effects, it shall not be destroyed before the end of its block, nor shall it be eliminated as an optimization even if it appears to be unused, except that a class object or its copy/move may be eliminated as specified in 12.8.</p>\n</blockquote>\n<p>12.8-31 describes copy elision which I believe is irrelevant here.</p>\n<p>So the question is whether the initialization of your local variables has side effects that prevent it from being optimized away. Since it can perform initialization of a static variable with an address of a dynamic object, I think it produces sufficient side effects (e.g. modifies an object). Also you can add there an operation with a volatile object, thus introducing an observable behavior which cannot be eliminated.</p>\n", "OwnerUserId": "654891", "PostTypeId": "2", "Id": "8918505", "Score": "1", "CreationDate": "2012-01-18T22:31:31.860", "LastActivityDate": "2012-01-18T22:31:31.860"}, "8822229": {"CommentCount": "2", "AcceptedAnswerId": "8918505", "PostTypeId": "1", "LastEditorUserId": "476681", "CreationDate": "2012-01-11T15:47:48.093", "LastActivityDate": "2012-01-18T22:31:31.860", "LastEditDate": "2012-01-18T09:25:42.247", "ViewCount": "467", "FavoriteCount": "1", "Title": "Ordered static initialization of thread-safe classes", "Id": "8822229", "Score": "2", "Body": "<p>This post may seem overly long for just the short question at the end of it. But I also need to describe a design pattern I just came up with. Maybe it's commonly used, but I've never seen it (or maybe it just doesn't work :).</p>\n<p>First, here's a code which (to my understanding) has undefined behavior due to \"static initialization order fiasco\". The problem is that the initialization of Spanish::s_englishToSpanish is dependent on English::s_numberToStr, which are both static initialized and in different files, so the order of those initializations is undefined:</p>\n<p>File: English.h</p>\n<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nstruct English {\n    static vector&lt;string&gt;* s_numberToStr;\n    string m_str;\n\n    explicit English(int number)\n    {\n        m_str = (*s_numberToStr)[number];\n    }\n};\n</code></pre>\n<p>File: English.cpp</p>\n<pre><code>#include \"English.h\"\n\nvector&lt;string&gt;* English::s_numberToStr = new vector&lt;string&gt;( /*split*/\n[]() -&gt; vector&lt;string&gt;\n{\n    vector&lt;string&gt; numberToStr;\n    numberToStr.push_back(\"zero\");\n    numberToStr.push_back(\"one\");\n    numberToStr.push_back(\"two\");\n    return numberToStr;\n}());\n</code></pre>\n<p>File: Spanish.h</p>\n<pre><code>#pragma once\n\n#include &lt;map&gt;\n#include &lt;string&gt;\n\n#include \"English.h\"\n\nusing namespace std;\n\ntypedef map&lt;string, string&gt; MapType;\n\nstruct Spanish {\n    static MapType* s_englishToSpanish;\n    string m_str;\n\n    explicit Spanish(const English&amp; english)\n    {\n        m_str = (*s_englishToSpanish)[english.m_str];\n    }\n};\n</code></pre>\n<p>File: Spanish.cpp</p>\n<pre><code>#include \"Spanish.h\"\n\nMapType* Spanish::s_englishToSpanish = new MapType( /*split*/\n[]() -&gt; MapType\n{\n    MapType englishToSpanish;\n    englishToSpanish[ English(0).m_str ] = \"cero\";\n    englishToSpanish[ English(1).m_str ] = \"uno\";\n    englishToSpanish[ English(2).m_str ] = \"dos\";\n    return englishToSpanish;\n}());\n</code></pre>\n<p>File: StaticFiasco.h</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;tchar.h&gt;\n#include &lt;conio.h&gt;\n\n#include \"Spanish.h\"\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    _cprintf( Spanish(English(1)).m_str.c_str() ); // may print \"uno\" or crash\n\n    _getch();\n    return 0;\n}\n</code></pre>\n<p>To solve the static initialization order problem, we use the construct-on-first-use idiom, and make those static initializations function-local like so:</p>\n<p>File: English.h</p>\n<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nstruct English {\n    string m_str;\n\n    explicit English(int number)\n    {\n        static vector&lt;string&gt;* numberToStr = new vector&lt;string&gt;( /*split*/\n        []() -&gt; vector&lt;string&gt;\n        {\n            vector&lt;string&gt; numberToStr_;\n            numberToStr_.push_back(\"zero\");\n            numberToStr_.push_back(\"one\");\n            numberToStr_.push_back(\"two\");\n            return numberToStr_;\n        }());\n\n        m_str = (*numberToStr)[number];\n    }\n};\n</code></pre>\n<p>File: Spanish.h</p>\n<pre><code>#pragma once\n\n#include &lt;map&gt;\n#include &lt;string&gt;\n\n#include \"English.h\"\n\nusing namespace std;\n\nstruct Spanish {\n    string m_str;\n\n    explicit Spanish(const English&amp; english)\n    {\n        typedef map&lt;string, string&gt; MapT;\n\n        static MapT* englishToSpanish = new MapT( /*split*/\n        []() -&gt; MapT\n        {\n            MapT englishToSpanish_;\n            englishToSpanish_[ English(0).m_str ] = \"cero\";\n            englishToSpanish_[ English(1).m_str ] = \"uno\";\n            englishToSpanish_[ English(2).m_str ] = \"dos\";\n            return englishToSpanish_;\n        }());\n\n        m_str = (*englishToSpanish)[english.m_str];\n    }\n};\n</code></pre>\n<p>But now we have another problem. Due to the function-local static data, neither of those classes is thread-safe. To solve this, we add to both classes a static member variable and an initialization function for it. Then inside this function we force the initialization of all the function-local static data, by calling once each function that has function-local static data. Thus, effectively we're initializing everything at the start of program, but still controlling the order of initialization. So now our classes should be thread-safe:</p>\n<p>File: English.h</p>\n<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nstruct English {\n    static bool s_areStaticsInitialized;\n    string m_str;\n\n    explicit English(int number)\n    {\n        static vector&lt;string&gt;* numberToStr = new vector&lt;string&gt;( /*split*/\n        []() -&gt; vector&lt;string&gt;\n        {\n            vector&lt;string&gt; numberToStr_;\n            numberToStr_.push_back(\"zero\");\n            numberToStr_.push_back(\"one\");\n            numberToStr_.push_back(\"two\");\n            return numberToStr_;\n        }());\n\n        m_str = (*numberToStr)[number];\n    }\n\n    static bool initializeStatics()\n    {\n        // Call every member function that has local static data in it:\n        English english(0); // Could the compiler ignore this line?\n        return true;\n    }\n};\nbool English::s_areStaticsInitialized = initializeStatics();\n</code></pre>\n<p>File: Spanish.h</p>\n<pre><code>#pragma once\n\n#include &lt;map&gt;\n#include &lt;string&gt;\n\n#include \"English.h\"\n\nusing namespace std;\n\nstruct Spanish {\n    static bool s_areStaticsInitialized;\n    string m_str;\n\n    explicit Spanish(const English&amp; english)\n    {\n        typedef map&lt;string, string&gt; MapT;\n\n        static MapT* englishToSpanish = new MapT( /*split*/\n        []() -&gt; MapT\n        {\n            MapT englishToSpanish_;\n            englishToSpanish_[ English(0).m_str ] = \"cero\";\n            englishToSpanish_[ English(1).m_str ] = \"uno\";\n            englishToSpanish_[ English(2).m_str ] = \"dos\";\n            return englishToSpanish_;\n        }());\n\n        m_str = (*englishToSpanish)[english.m_str];\n    }\n\n    static bool initializeStatics()\n    {\n        // Call every member function that has local static data in it:\n        Spanish spanish( English(0) ); // Could the compiler ignore this line?\n        return true;\n    }\n};\n\nbool Spanish::s_areStaticsInitialized = initializeStatics();\n</code></pre>\n<p>And here's the question: Is it possible that some compiler might optimize away those calls to functions (constructors in this case) which have local static data? So the question is what exactly amounts to \"having side-effects\", which to my understanding means the compiler isn't allowed to optimize it away. Is having function-local static data enough to make the compiler think the function call can't be ignored?</p>\n", "Tags": "<c++><windows><thread-safety><initialization><lazy-initialization>", "OwnerUserId": "313853", "AnswerCount": "4"}, "8896839": {"ParentId": "8822229", "CommentCount": "0", "Body": "<p>maybe you need to do extra work to control the init order.\nlike,</p>\n<pre><code>class staticObjects\n{\n    private:\n    vector&lt;string&gt;* English::s_numberToStr;\n    MapType* s_englishToSpanish;\n};\n\nstatic staticObjects objects = new staticObjects();\n</code></pre>\n<p>and then define some interfaces to retrieve it.</p>\n", "OwnerUserId": "1153275", "PostTypeId": "2", "Id": "8896839", "Score": "0", "CreationDate": "2012-01-17T15:00:26.560", "LastActivityDate": "2012-01-17T15:00:26.560"}, "8914078": {"ParentId": "8822229", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Why don't you just hide English::s_numberToStr behind a public static function and skip the constructor syntax entirely?  Use <a href=\"http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html\" rel=\"nofollow\">DCLP</a> to ensure thread-safety.</p>\n<p>I strongly recommend avoiding class static variables whose initialization involves non-trivial side-effects.  As a general design pattern, they tend to cause more problems than they solve.  Whatever performance problems you're concerned about here needs justification because I'm doubtful that they are measurable under real-world circumstances.</p>\n", "OwnerUserId": "583604", "LastEditorUserId": "583604", "LastEditDate": "2012-01-18T18:04:34.190", "Id": "8914078", "Score": "1", "CreationDate": "2012-01-18T16:56:33.490", "LastActivityDate": "2012-01-18T18:04:34.190"}, "bq_ids": {"n4140": {"so_8822229_8918505_3": {"section_id": 5808, "quality": 0.9130434782608695, "length": 21}, "so_8822229_8918505_2": {"section_id": 5804, "quality": 0.896551724137931, "length": 52}, "so_8822229_8918505_1": {"section_id": 5801, "quality": 1.0, "length": 18}, "so_8822229_8918505_4": {"section_id": 7172, "quality": 0.9642857142857143, "length": 27}, "so_8822229_8918505_0": {"section_id": 5797, "quality": 0.9, "length": 18}}, "n3337": {"so_8822229_8918505_2": {"section_id": 5577, "quality": 0.896551724137931, "length": 52}, "so_8822229_8918505_3": {"section_id": 5581, "quality": 0.9130434782608695, "length": 21}, "so_8822229_8918505_4": {"section_id": 6916, "quality": 0.9642857142857143, "length": 27}, "so_8822229_8918505_1": {"section_id": 5574, "quality": 1.0, "length": 18}, "so_8822229_8918505_0": {"section_id": 5570, "quality": 0.9, "length": 18}}, "n4659": {"so_8822229_8918505_2": {"section_id": 7262, "quality": 0.8620689655172413, "length": 50}, "so_8822229_8918505_3": {"section_id": 7269, "quality": 0.8695652173913043, "length": 20}, "so_8822229_8918505_4": {"section_id": 8680, "quality": 0.8928571428571429, "length": 25}, "so_8822229_8918505_1": {"section_id": 7260, "quality": 1.0, "length": 18}, "so_8822229_8918505_0": {"section_id": 7256, "quality": 0.9, "length": 18}}}});