post_cb({"19483347": {"Id": "19483347", "PostTypeId": "2", "Body": "<p>Not only does the <em>Requires:</em> clause need to be satisfied, but everything in the <em>Effects:</em> and <em>Returns:</em> clause needs to be satisfied as well.  Let's go through them:</p>\n<blockquote>\n<p id=\"so_19480609_19483347_0\"><em>Effects:</em> Copies elements in the range <code>[first,last)</code> into the range <code>[result,result + (last - first))</code> starting from <code>first</code> and\n  proceeding to <code>last</code>.</p>\n</blockquote>\n<p>As <code>first == last</code>, then the range <code>[result, result + 0)</code> must be a valid range.</p>\n<p>[iterator.requirements.general]/p7 states:</p>\n<blockquote>\n<p id=\"so_19480609_19483347_1\">A range <code>[i,i)</code> is an empty range;  ... <code>Range [i,j)</code> is valid if and only if <code>j</code> is reachable from <code>i</code>.</p>\n</blockquote>\n<p>And p6 of the same section states:</p>\n<blockquote>\n<p id=\"so_19480609_19483347_2\">An iterator <code>j</code> is called reachable from an iterator <code>i</code> if and only\n  if there is a finite sequence of applications of the expression <code>++i</code>\n  that makes <code>i == j</code>.</p>\n</blockquote>\n<p>From these paragraphs I conclude that given:</p>\n<pre><code>int* dest = nullptr;\n</code></pre>\n<p>Then <code>[dest, dest)</code> forms a valid empty range.  So the first sentence in the <em>Effects:</em> paragraph looks ok to me:</p>\n<blockquote>\n<p id=\"so_19480609_19483347_3\">For each non-negative integer <code>n &lt; (last - first)</code>, performs <code>*(result + n) = *(first + n)</code>.</p>\n</blockquote>\n<p>There are no non-negative integers <code>n &lt; 0</code>, and so no assignments can be performed.  So the second sentence does not prohibit <code>dest == nullptr</code>.</p>\n<blockquote>\n<p id=\"so_19480609_19483347_4\"><em>Returns:</em> <code>result + (last - first)</code>.</p>\n</blockquote>\n<p>[expr.add]/p8 specifically allows one to add 0 to any pointer value and the result compares equal to the original pointer value.  Therefore <code>dest + 0</code> is a valid expression equal to <code>nullptr</code>.  No problems with the <em>Returns:</em> clause.</p>\n<blockquote>\n<p id=\"so_19480609_19483347_5\"><em>Requires:</em> <code>result</code> shall not be in the range <code>[first,last)</code>.</p>\n</blockquote>\n<p>I see no reasonable way to interpret that <code>dest</code> would be \"in\" an empty range.</p>\n<blockquote>\n<p id=\"so_19480609_19483347_6\"><em>Complexity:</em> Exactly <code>last - first</code> assignments.</p>\n</blockquote>\n<p>This confirms that no assignments can be done.</p>\n<p>I can find no statement in the standard that makes this example anything but well-formed.</p>\n", "LastActivityDate": "2013-10-20T21:55:41.703", "CommentCount": "9", "CreationDate": "2013-10-20T21:55:41.703", "ParentId": "19480609", "Score": "15", "OwnerUserId": "576911"}, "bq_ids": {"n4140": {"so_19480609_19483347_6": {"length": 4, "quality": 0.8, "section_id": 1289}, "so_19480609_19481123_0": {"length": 19, "quality": 0.8636363636363636, "section_id": 1238}, "so_19480609_19483347_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 1286}, "so_19480609_19483347_1": {"length": 6, "quality": 1.0, "section_id": 5561}, "so_19480609_19481123_1": {"length": 17, "quality": 0.7391304347826086, "section_id": 5571}, "so_19480609_19483347_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 1286}, "so_19480609_19483347_2": {"length": 10, "quality": 1.0, "section_id": 5560}}, "n3337": {"so_19480609_19483347_2": {"length": 10, "quality": 1.0, "section_id": 5342}, "so_19480609_19481123_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 1236}, "so_19480609_19483347_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 1281}, "so_19480609_19483347_1": {"length": 6, "quality": 1.0, "section_id": 5343}, "so_19480609_19481123_1": {"length": 17, "quality": 0.7391304347826086, "section_id": 5353}, "so_19480609_19483347_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 1281}, "so_19480609_19483347_6": {"length": 4, "quality": 0.8, "section_id": 1284}}, "n4659": {"so_19480609_19483347_2": {"length": 10, "quality": 1.0, "section_id": 7007}, "so_19480609_19481123_0": {"length": 18, "quality": 0.8181818181818182, "section_id": 1326}, "so_19480609_19483347_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 1409}, "so_19480609_19483347_1": {"length": 6, "quality": 1.0, "section_id": 7008}, "so_19480609_19481123_1": {"length": 16, "quality": 0.6956521739130435, "section_id": 7018}, "so_19480609_19483347_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 1409}, "so_19480609_19483347_6": {"length": 4, "quality": 0.8, "section_id": 1411}}}, "19480609": {"ViewCount": "933", "Body": "<p>The <code>std::move()</code> in the code below issues a runtime warning when compiled in Visual Studio 2013 (with Debug configuration) because it detects that <code>dest</code> is a <code>nullptr</code>.  However, the source range is empty, so <code>dest</code> should never be accessed.\nThe C++ standard may be unclear as to whether this should be allowed?\nIt states:  <em>Requires: result shall not be in the range [first,last).</em>\nA <code>nullptr</code> would seem to satisfy that requirement.</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nint main() {\n    std::vector&lt;int&gt; vec;\n    int* dest = nullptr;\n    // The range [begin(vec),end(vec)) is empty, so dest should never be accessed.\n    // However, it results in an assertion warning in VS2013.\n    std::move(std::begin(vec), std::end(vec), dest);\n}\n</code></pre>\n", "AcceptedAnswerId": "19483347", "Title": "should std::copy() or std::move() of empty range require valid destination?", "CreationDate": "2013-10-20T17:37:44.707", "Id": "19480609", "CommentCount": "7", "LastEditDate": "2013-10-20T17:42:54.797", "PostTypeId": "1", "LastEditorUserId": "1190077", "LastActivityDate": "2013-10-20T21:55:41.703", "Score": "10", "OwnerUserId": "1190077", "Tags": "<c++><visual-studio><c++11>", "AnswerCount": "3"}, "19481123": {"Id": "19481123", "PostTypeId": "2", "Body": "<p>This answer is derived from the comment by @Philipp Lenk.  If he supplies an answer and you find it acceptable, choose his over mine and please up-vote his original comment.</p>\n<blockquote>\n<p id=\"so_19480609_19481123_0\">\u00a725.1.5: Throughout this Clause, the names of template parameters are\n  used to express type requirement [...] if an algorithm\u2019s template\n  parameter is OutputIterator, OutputIterator1, or OutputIterator2, the\n  actual template argument shall satisfy the requirements of an output\n  iterator.</p>\n<p id=\"so_19480609_19481123_1\">\u00a724.2.4: A class or pointer type X satisfies the requirements of an\n  output iterator if X satisfies the Iterator requirements and the\n  expressions in Table 108 are valid and have the indicated semantics.\n  First line of the table: <code>*r = o</code> with the remark that <code>post: r is\n  incrementable.</code></p>\n</blockquote>\n<pre><code>int* dest = nullptr;\n*dest = 5;\n++dest;\n</code></pre>\n<p>The above code is not valid.  You cannot assign to <code>*dest</code> in this case, therefore per the standard you cannot pass a nullptr in for the dest.</p>\n", "LastActivityDate": "2013-10-20T18:25:39.333", "CommentCount": "6", "CreationDate": "2013-10-20T18:25:39.333", "ParentId": "19480609", "Score": "-1", "OwnerUserId": "879046"}, "19480936": {"Id": "19480936", "PostTypeId": "2", "Body": "<p>The debug build of STL in Visual Studio does additional parameter validation.  In this case, it is validating that dest is not null since it shouldn't be, which is failing.  The release build may very well act as you expect, never using dest but that doesn't make the input data valid.</p>\n<p>The debug build of STL is trying to help you by saying, \"your input is bad\".  While the bad input might not be a problem in some circumstances, the validator can't know under what conditions you are passing it bad data.  Personally, I would much rather have VS tell me about bad input in debug builds than have a runtime exception thrown in production.</p>\n<p>Sure, you might do something like this:</p>\n<pre><code>int* dest = nullptr;\nif (vec.size() &gt; 0) dest = realDest;\nstd::move(std::begin(vec), std::end(vec), dest);\n</code></pre>\n<p>But the validator doesn't know that so it assumes the worst, especially since fixing it is very easy for you (just always pass in a valid output iterator) and not warning you about it could have terrible consequences on your application at runtime in production.</p>\n", "LastActivityDate": "2013-10-20T18:06:57.170", "CommentCount": "2", "CreationDate": "2013-10-20T18:06:57.170", "ParentId": "19480609", "Score": "-1", "OwnerUserId": "879046"}});