post_cb({"bq_ids": {"n4140": {"so_40530874_40538421_0": {"length": 11, "quality": 1.0, "section_id": 5890}}, "n3337": {"so_40530874_40538421_0": {"length": 11, "quality": 1.0, "section_id": 5661}}, "n4659": {"so_40530874_40538421_0": {"length": 11, "quality": 1.0, "section_id": 7373}}}, "40538421": {"Id": "40538421", "PostTypeId": "2", "Body": "<p>This is undefined but not because of the strict aliasing rule. The call to <code>get_depth</code> neither reads nor modifies the value of any object (a template non-type parameter isn't an object), so it doesn't <em>access</em> (as defined in  <a href=\"https://timsong-cpp.github.io/cppwp/defns.access\" rel=\"nofollow noreferrer\">[defns.access]</a>) anything within the meaning of the strict aliasing rule.</p>\n<p>This is controlled instead by <a href=\"https://timsong-cpp.github.io/cppwp/class.mfct.non-static#2\" rel=\"nofollow noreferrer\">[class.mfct.non-static]/2</a>:</p>\n<blockquote>\n<p id=\"so_40530874_40538421_0\">If a non-static member function of a class <code>X</code> is called for an object\n  that is not of type <code>X</code>, or of a type derived from <code>X</code>, the behavior is\n  undefined.</p>\n</blockquote>\n", "LastActivityDate": "2016-11-10T22:53:05.533", "CommentCount": "1", "CreationDate": "2016-11-10T22:53:05.533", "ParentId": "40530874", "Score": "2", "OwnerUserId": "2756719"}, "40530874": {"ViewCount": "57", "Body": "<p>While working on an RAII-style guard object, I ended up encoding some of the guard state in a template parameter. This seems reasonable if, for instance, you want a recursive / nested guard object that's aware of how many levels deep it is but without space overhead (being pedantic, I know) or to eliminate some runtime overheads. This turned into an academic curiosity though...</p>\n<p>Something like this would be an example:</p>\n<pre><code>template &lt;unsigned depth&gt;\nclass guard {\n    unsigned get_depth() const {return depth;}\n};\n\nguard&lt;2&gt; g2;\nstd::cout &lt;&lt; reinterpret_cast&lt; guard&lt;5&gt;* &gt;( &amp;g2 )-&gt;get_depth(); // works? crazy? useful?\n</code></pre>\n<p>I cannot for the life of me think of a legitimate reason to do this, but it got me thinking if this is legal C++ and just how the compiler ought to handle something like this (if it can at all) or if it's just silly through and through.</p>\n<p>I assume because the cast target needs to be known at compile time, that the relevant template is instantiated for the cast. Has anyone found something like this useful, assuming it does work and has uses at all, and if so where could this be utilized?</p>\n<p>The general question I guess is <strong>can <code>reinterpret_cast</code> alter constant template parameters?</strong> If so is this just a type hack (for want of a better term) and <code>g2</code> in this case would <em>always</em> return <code>2</code> (after casting)? Or should it return <code>5</code> (after casting)?</p>\n", "AcceptedAnswerId": "40538421", "Title": "C++ Compiler behavior with re-interpreting template parameter constants", "CreationDate": "2016-11-10T15:09:23.580", "Id": "40530874", "CommentCount": "3", "LastEditDate": "2016-11-10T15:12:41.987", "PostTypeId": "1", "LastEditorUserId": "5134012", "LastActivityDate": "2016-11-10T22:53:05.533", "Score": "1", "OwnerUserId": "5134012", "Tags": "<c++><c++11><reinterpret-cast>", "AnswerCount": "1"}});