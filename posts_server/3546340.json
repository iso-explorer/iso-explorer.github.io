post_cb({"bq_ids": {"n4140": {"so_3546340_3546772_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 5846}, "so_3546340_3546582_3": {"length": 7, "quality": 0.5384615384615384, "section_id": 3296}, "so_3546340_3546582_1": {"length": 9, "quality": 1.0, "section_id": 5492}, "so_3546340_3546582_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 6003}}, "n3337": {"so_3546340_3546772_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 5616}, "so_3546340_3546582_1": {"length": 9, "quality": 1.0, "section_id": 5278}, "so_3546340_3546582_3": {"length": 7, "quality": 0.5384615384615384, "section_id": 3166}, "so_3546340_3546582_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 5771}}, "n4659": {"so_3546340_3546772_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 7325}, "so_3546340_3546582_1": {"length": 9, "quality": 1.0, "section_id": 6926}, "so_3546340_3546582_3": {"length": 7, "quality": 0.5384615384615384, "section_id": 4058}, "so_3546340_3546582_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 7502}}}, "3546437": {"Id": "3546437", "PostTypeId": "2", "Body": "<p>using X::f2; should not work due to private inheritance of below code</p>\n<pre><code>struct Y : private X{\n    void f4();\n};\n</code></pre>\n<p>It is not possible to access members of X through Y.\nSo X::f2 would conflicts.</p>\n<p><code>Z::X::f2</code> should work.\nOr <code>Z::f2</code> should work.</p>\n", "LastEditorUserId": "426051", "LastActivityDate": "2010-08-23T10:05:51.190", "Score": "0", "CreationDate": "2010-08-23T09:53:45.933", "ParentId": "3546340", "CommentCount": "3", "OwnerUserId": "426051", "LastEditDate": "2010-08-23T10:05:51.190"}, "3546772": {"Id": "3546772", "PostTypeId": "2", "Body": "<p>First, to clarify Johannes' answer. When you say <code>using Z::X::f2;</code>, the compiler does not \"build a path\" to <code>f2</code> to keep track of how it should be accessed. Since <code>Z::X</code> is the same thing as <code>X</code>, the declaration is exactly the same as saying <code>using X::f2;</code>. Contrast it with this example:</p>\n<pre><code>struct A { void f() {} void g() {} };\nstruct B { void f() {} void g() {} };\nstruct C { typedef A X; };\nstruct D { typedef B X; };\nstruct E : A, B {\n    using C::X::f; // C::X == A\n    using D::X::g; // D::X == B\n};\n</code></pre>\n<p>The syntax <code>Z::X</code> works not because of inheritance or membership, but because the identifier <code>X</code> is accessible from the scope <code>Z</code>. You are even allowed to write <code>Z::Z::Z::Z::X::X::X::X</code> ad nauseam, because every class brings its own name into its own scope. Thus <code>::</code> here does not express inheritance.</p>\n<p>Now, to solve the problem. <code>f2</code> is inherited by <code>Y</code> and <code>Z</code> from <code>X</code>. Thus, it is a first-class <em>member</em> of <code>Y</code> and <code>Z</code>. <code>E</code> doesn't need to know about <code>X</code> because it is a hidden implementation detail. So, you want</p>\n<pre><code>struct D : Y, Z{\n    using Y::f2; // error: inaccessible\n    using Z::f3;\n};\n</code></pre>\n<hr>\n<p>To explain in terms of 9.1/2 as you ask:</p>\n<blockquote>\n<p id=\"so_3546340_3546772_0\">A class-name is inserted into the\n  scope in which it is declared\n  immediately after the class-name is\n  seen. The class-name is also inserted\n  into the scope of the class itself;\n  this is known as the\n  injected-class-name.</p>\n</blockquote>\n<p>The name <code>X</code> is injected into <code>X</code> as <code>X::X</code>. It is then inherited into <code>Y</code> and <code>Z</code>. <code>Y</code> and <code>Z</code> do not implicitly declare <code>X</code> in their own scope.</p>\n<p>10.2/2: </p>\n<blockquote>\n<p id=\"so_3546340_3546772_1\">The following steps define the result of name lookup in a class\n  scope, C. First, every declaration for\n  the name in the class and in each of\n  its base class sub-objects is\n  considered. \u2026\n  If the resulting set of declarations\n  are not all from <strong>sub-objects</strong> of\n  the same type, or the set has a\n  nonstatic member and includes members\n  from distinct sub-objects, there is an\n  ambiguity and the program is\n  ill-formed. Otherwise that set is the\n  result of the lookup.</p>\n</blockquote>\n<p>Note that I bolded the plural word sub-objects. Although the name <code>X</code> is found in two sub-objects, they are both the same type, namely <code>X</code>.</p>\n</hr>", "LastEditorUserId": "153285", "LastActivityDate": "2010-08-23T11:48:14.317", "Score": "0", "CreationDate": "2010-08-23T10:41:02.840", "ParentId": "3546340", "CommentCount": "4", "OwnerUserId": "153285", "LastEditDate": "2010-08-23T11:48:14.317"}, "3546340": {"ViewCount": "612", "Body": "<p>Below is a purely academically invented class hierarchy.</p>\n<pre><code>struct X{\n        void f1();\n        void f2();\n        void f3();\n};\n\nstruct Y : private X{\n        void f4();\n};\n\nstruct Z : X{\n};\n\nstruct D : Y, Z{\n        using X::f2;\n        using Z::X::f3;\n};\n\nint main(){}\n</code></pre>\n<p>I expected using declaration for X::f2 to be ambiguous as 'X' is an ambiguous base of 'D' (visbility vs accessibility of X). However g++ (ideone.com) compiles it fine.</p>\n<p>I checked with Online Comeau and it gives error in using declaration for X::f2 as expected. However it gives ambiguity for using declaration for Z::X::f3 as well.</p>\n<p>So what is the expected behavior?</p>\n<p><strong>Edit 1:</strong> </p>\n<p>A reference to the appropriate section of the Standard would be helpful, please.</p>\n<p><strong>Edit 2:</strong></p>\n<p>I checked with VS 2010 and it has objections only with the using declaration X::f2. However it is not about ambiguity of 'X' (as in the case of gcc and Comeau). It is about \"error C2876: 'X' : not all overloads are accessible\".</p>\n<p><strong>Edit 3:</strong></p>\n<pre><code>struct X{\n    void f(){}\n};\n\nstruct Y : X{\n    struct trouble{\n        void f(){}\n    };\n\n};\n\nstruct trouble : X{\n};\n\nstruct letscheck : Y, trouble{\n    using trouble::f;\n};\n\nint main(){}\n</code></pre>\n<p>Here I have attempted (purposefully) to create an issue with types in using declaration. Gcc still compiles this fine and so does VS2010. Comeau still gives error (as expected) about ambiguous types 'trouble'. Going by explanations given for the initial queries, it appears GCC and VS2010 are wrong. Is that correct?</p>\n", "AcceptedAnswerId": "3546582", "Title": "what is the expected behavior?", "CreationDate": "2010-08-23T09:40:32.293", "Id": "3546340", "CommentCount": "1", "LastEditDate": "2010-08-23T13:06:37.847", "PostTypeId": "1", "LastEditorUserId": "418110", "LastActivityDate": "2010-08-23T14:43:12.923", "Score": "7", "OwnerUserId": "418110", "Tags": "<c++><declaration><using><ambiguity>", "AnswerCount": "3"}, "3546582": {"Id": "3546582", "PostTypeId": "2", "Body": "<p>I don't think that any of these are ill-formed. First, for <code>using X::f2</code>, <code>X</code> is looked up, and this will unambiguously yield the class type <code>X</code>. Then <code>f2</code> in <code>X</code> is looked up, and this is unambiguous too (it is not looked up in <code>D</code>!). </p>\n<p>The second case will work for the same reason. </p>\n<p>But if you <em>call</em> <code>f2</code> on a <code>D</code> object, the call will be be ambiguous because the name <code>f2</code> is looked up in all subobjects of <code>D</code> of type <code>X</code>, and <code>D</code> has two such subobjects, and <code>f2</code> is a non-static member function. The same reason holds for the second case. It does not make a difference for this whether you name <code>f3</code> using <code>Z::X</code> or <code>X</code> directly. Both of these designate the class <code>X</code>. </p>\n<p>To get an ambiguity for the using declaration, you need to write it differently. Note that in C++0x <code>using ThisClass::...;</code> is not valid. It is in C++03 though, as long as the whole name refers to a base-class member. </p>\n<p>Conversely, if this would be allowed in C++0x, the whole using declaration would also be valid, because C++0x does not take subobjects into account for name-lookup: <code>D::f2</code> unambiguously refers to only one <em>declaration</em> (the one in <code>X</code>). See <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#39\" rel=\"nofollow noreferrer\">DR #39</a> and the final paper <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1626.pdf\" rel=\"nofollow noreferrer\">N1626</a>.</p>\n<pre><code>struct D : Y, Z{\n    // ambiguous: f2 is declared in X, and X is a an ambiguous base class\n    using D::f2;\n\n    // still fine (if not referred to by calls/etc) :)\n    using Z::X::f3;\n};\n\nstruct E : D {\n  // ambiguous in C++03\n  // fine in C++0x (if not referred to by an object-context (such as a call)).\n  using D::f2;\n};\n</code></pre>\n<p>The C++03 Standard describes this in paragraphs <code>10.2</code> and <code>3.4.3.1</code>.</p>\n<hr>\n<p><strong>Response for Edit3</strong>:</p>\n<p>Yes, GCC and VS2010 are wrong. <code>trouble</code> refers to the type found by the injected class name of <code>::trouble</code> and to the nested class found as <code>Y::trouble</code>. The name <code>trouble</code> preceeding the <code>::</code> is looked up using unqualified lookup (by <code>3.4.1/7</code>, which delegates to <code>10.2</code> in the first bullet) ignoring any object, function and enumerator names (<code>3.4.3/1</code> - there are no such names in this case, though). It then violates against <code>10.2</code>'s requirement that:</p>\n<blockquote>\n<p id=\"so_3546340_3546582_0\">If the resulting set of declarations are not all from sub-objects of the same type ... the program is ill-formed.</p>\n</blockquote>\n<hr>\n<p>It is possible that VS2010 and GCC interpret C++0x wording differently than Comeau and retroactively implement that wording:</p>\n<blockquote>\n<p id=\"so_3546340_3546582_1\">In a using-declaration used as a member-declaration, the nested-name-specifier shall name a base class of the class being defined. </p>\n</blockquote>\n<p>This means that non-base classes <em>are</em> considered, but it is an error if a non-base class is named. If the Standard would intend to ignore non-base class names, it would say <em>can only</em> here, or spell it out explicitly (both practices are done). The Standard however is not at all consequent with its use of <em>shall</em> and <em>can</em>. And GCC implements C++0x wording, because it rejects otherwise completely fine C++03 code, just because the using declaration contains its class-name. </p>\n<p>For an example of the unclear wording, consider the following expression:</p>\n<pre><code>a.~A();\n</code></pre>\n<p>This is syntactically ambiguous, because it can be a member function call if <code>a</code> is a class object, but it can be a pseudo-destructor-call (which is a no-op) if <code>a</code> has a scalar type (such as <code>int</code>). But what the Standard says is for the syntax of a pseudo-destructor call and class member access at <code>5.2.4</code> and <code>5.2.5</code> respectively</p>\n<blockquote>\n<p id=\"so_3546340_3546582_2\">The left-hand side of the dot operator shall be of scalar type.</p>\n<p id=\"so_3546340_3546582_3\">For the \ufb01rst option (dot) the type of the \ufb01rst expression (the object expression ) shall be \u201cclass object\u201d (of a complete type).</p>\n</blockquote>\n<p>That is the wrong use, because it does not clear up the ambiguity at all. It should use \"can only\", and compilers interpret it in that way. This has mostly historical reasons, as some committee-member recently told me on usenet. See <a href=\"http://www.iso.org/directives\" rel=\"nofollow noreferrer\">The rules for the structure and drafting of International Standards</a>, Annex H. </p>\n</hr></hr>", "LastEditorUserId": "34509", "LastActivityDate": "2010-08-23T14:43:12.923", "Score": "2", "CreationDate": "2010-08-23T10:14:26.010", "ParentId": "3546340", "CommentCount": "12", "OwnerUserId": "34509", "LastEditDate": "2010-08-23T14:43:12.923"}});