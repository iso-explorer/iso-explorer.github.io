post_cb({"24196313": {"ParentId": "24186681", "LastEditDate": "2014-06-13T01:21:49.307", "CommentCount": "4", "CreationDate": "2014-06-13T01:15:52.633", "OwnerUserId": "433534", "LastEditorUserId": "433534", "PostTypeId": "2", "Id": "24196313", "Score": "3", "Body": "<p>There's a clear divide between inherent undefined behaviour, such as n=n++, and code that can have defined or undefined behaviour depending on the program state at runtime, such as x/y for ints.  In the latter case the program is required to work unless y is 0, but in the first case the compiler's asked to generate code that's totally illegitimate - it's within its rights to refuse to compile, it may just not be \"bullet proofed\" against such code and consequently its optimiser state (register allocations, records of which values may have been modified since read etc) gets corrupted resulting in bogus machine code for that <em>and surrounding</em> source code.  It may be that early analysis recognised an \"a=b++\" situation and generated code for the preceding if to jump over a two byte instruction, but when n=n++ is encountered no instruction was output, such that the if statement jumps somewhere into the following opcodes.  Anyway, it's simply game over.  Putting an \"if\" in front, or even wrapping it in a different function, isn't documented as \"containing\" the undefined behaviour... bits of code aren't tainted with undefined behaviour - the Standard consistently says \"the program has undefined behaviour\".</p>\n", "LastActivityDate": "2014-06-13T01:21:49.307"}, "24186681": {"CommentCount": "18", "CreationDate": "2014-06-12T14:15:18.743", "PostTypeId": "1", "AcceptedAnswerId": "24187757", "LastEditorUserId": "-1", "LastActivityDate": "2015-09-07T09:16:03.017", "LastEditDate": "2017-05-23T12:33:44.917", "ViewCount": "983", "FavoriteCount": "3", "Title": "Does an expression with undefined behaviour that is never actually executed make a program erroneous?", "Id": "24186681", "Score": "17", "Body": "<p>In many discussions about undefined behavior (UB), the point of view has been put forward that in the mere <em>presence</em> in a program of any construct that has UB in a program mandates a conforming implementation to do just anything (including nothing at all). My question is whether this should be taken in that sense even in those cases where the UB is associated to the <em>execution</em> of code, while the behaviour (otherwise) specified in the standard stipulates that the code in question should not be executed (and this possibly for specific input to the program; it might not be decidable at compile time).</p>\n<p>Phrased more informally, does the smell of UB mandate a conforming implementation to decide that the whole program stinks, and refuse to execute correctly even the parts of the program for which the behaviour is perfectly well defined. An example program would be</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    int n = 0;\n    if (false)\n      n=n++;   // Undefined behaviour if it gets executed, which it doesn't\n    std::cout &lt;&lt; \"Hi there.\\n\";\n}\n</code></pre>\n<p>For clarity, \nI am assuming the program is well-formed (so in particular the UB is not associated to preprocessing). In fact I am willing to restrict to UB associated to \"evaluations\", which clearly are not compile-time entities. The definitions pertinent to the example given are, I think,(emphasis is mine):</p>\n<blockquote>\n<p id=\"so_24186681_24186681_0\">Sequenced before is an asymmetric, transitive, pair-wise relation between <em>evaluations executed</em> by a single thread (1.10), which induces a partial order among those evaluations</p>\n<p id=\"so_24186681_24186681_1\">The value computations of the operands of an\n  operator are sequenced before the value computation of the result of the operator. If a <em>side effect</em> on a scalar object is unsequenced relative to either ... or a <em>value computation</em> using the value of the same scalar object, the behavior is undefined.</p>\n</blockquote>\n<p>It is implicitly clear that the subjects in the final sentence, \"side effect\" and \"value computation\", are instances of \"evaluation\", since that is what the relation \"sequenced before\" is defined for.</p>\n<p>I posit that in the above program, the standard stipulates that no evaluations occur for which the condition in the final sentence is satisfied (unsequenced relative to each other and of the described kind) and that therfore the program does not have UB; it is not erroneous.</p>\n<p>In other words I am convinced that the answer to the question of my title is negative. However I would appreciate the (motivated) opinions of other people on this matter.</p>\n<p>Maybe an additional question for those who advocate an affirmative answer, would that mandate that the proverbial reformatting of your hard drive might occur when an erroneous program is compiled?</p>\n<p>Some related pointers on this site:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/21110059/1436796\">Observable behavior and undefined behavior -- What happens if I don't call a destructor?</a></li>\n<li>Comments to this answer <a href=\"https://stackoverflow.com/a/24143792/1436796\">https://stackoverflow.com/a/24143792/1436796</a> (I do no longer stand absolutely with my answer itself)</li>\n<li><a href=\"https://stackoverflow.com/q/13114459/1436796\">C++ What is the earliest undefined behavior can manifest itself?</a></li>\n<li><a href=\"https://stackoverflow.com/q/22180312/1436796\">Difference between Undefined Behavior and Ill-formed, no diagnostic message required</a> and its two answers, which represent opposite points of view</li>\n</ul>\n", "Tags": "<c++><language-lawyer><undefined-behavior>", "OwnerUserId": "1436796", "AnswerCount": "8"}, "24188588": {"ParentId": "24186681", "CommentCount": "3", "Body": "<p>No. Example:</p>\n<pre><code>struct T {\n    void f() { }\n};\nint main() {\n    T *t = nullptr;\n    if (t) {\n        t-&gt;f(); // UB if t == nullptr but since the code tested against that\n    }\n}\n</code></pre>\n", "OwnerUserId": "3734773", "PostTypeId": "2", "Id": "24188588", "Score": "6", "CreationDate": "2014-06-12T15:44:06.113", "LastActivityDate": "2014-06-12T15:44:06.113"}, "29734459": {"ParentId": "24186681", "LastEditDate": "2015-04-19T19:10:09.157", "CommentCount": "0", "CreationDate": "2015-04-19T19:04:19.007", "OwnerUserId": "363751", "LastEditorUserId": "363751", "PostTypeId": "2", "Id": "29734459", "Score": "0", "Body": "<p>A C compiler is allowed to do anything it likes as soon as a program enters a state via which there is no defined sequence of events which would allow the program to avoid invoking Undefined Behavior at some point in the future (note any loop which does not have any side-effects, and which does not have an exit condition which a compiler would be to required to recognize, invokes Undefined Behavior in and of itself).  <em>The compiler's behavior in such cases is bound by the laws of neither time nor causality</em>.  In situations where Undefined Behavior occurs in an expression whose result is never used, some compilers won't generate any code for the expression (so it will never \"execute\") but that won't prevent compilers from using the Undefined Behavior to make other inferences about program behavior.</p>\n<p>For example:</p>\n<pre><code>void maybe_launch_missiles(void)\n{      \n  if (should_launch_missiles())\n  {\n    arm_missiles();\n    if (should_launch_missiles())\n      launch_missiles();\n  }\n  disarm_missiles();\n}\nint foo(int x)\n{\n  maybe_launch_missiles();\n  return x&lt;&lt;1;\n}\n</code></pre>\n<p>Under the C current C standard, if the compiler could determinate that <code>disarm_missiles()</code> would always return without terminating but the three other external functions called above might terminate, the most efficient standard-compliant replacement for the statement <code>foo(-1);</code> (return value ignored) would be <code>should_launch_missiles(); arm_missiles(); should_launch_missiles(); launch_missiles();</code>.</p>\n<p>Program behavior will only be defined if either call to <code>should_launch_missiles()</code> terminates without returning, if the first call returns non-zero and <code>arm_missiles()</code> terminates without returning, or if both calls return non-zero and <code>launch_missiles()</code> terminates without returning.  A program which works correctly in those cases will abide by the standard regardless of what it does in any other situation.  If returning from <code>maybe_launch_missiles()</code> would cause Undefined Behavior, compiler would not be required to recognize the possibility that either call to <code>should_launch_missiles()</code> could return zero.</p>\n<p>As a consequence, some modern compilers, the effect of left-shifting a negative number may be worse than <em>anything</em> that could be caused by any kind of Undefined Behavior on a typical C99 compiler on platforms that separate code and data spaces and trap stack overflow.  Even if code engaged in Undefined Behavior which could cause random control transfers, there would be no means by which it could cause <code>arm_missiles()</code> and <code>launch_missiles()</code> to be called consecutively without having an intervening call to <code>disarm_missiles()</code> unless at least one call to <code>should_launch_missiles()</code> returned a non-zero value.  A hyper-modern compiler, however, may negate such protections.</p>\n", "LastActivityDate": "2015-04-19T19:10:09.157"}, "24191665": {"ParentId": "24186681", "LastEditDate": "2014-06-13T07:47:13.250", "CommentCount": "6", "CreationDate": "2014-06-12T18:40:25.597", "OwnerUserId": "464581", "LastEditorUserId": "1609356", "PostTypeId": "2", "Id": "24191665", "Score": "5", "Body": "<p><del>Deciding whether a program will perform an integer division by 0 (which is UB) is in general equivalent the halting problem. There is no way a compiler can determine that, in general. And so the mere presence of possible UB can not logically affect the rest of the program: a requirement to that effect in the standard, would require each compiler vendor to provide a halting problem solver in the compiler.</del></p>\n<p><del>Even simpler,</del> the following program has UB only if the user inputs 0:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nauto main() -&gt; int\n{\n    int x;\n    if( cin &gt;&gt; x ) cout &lt;&lt; 100/x &lt;&lt; endl;\n}\n</code></pre>\n<p>It would be absurd to maintain that this program <em>in itself</em> has UB.</p>\n<p>Once the undefined behavior occurs, however, then anything can happen: the further execution of code in the program is then compromised (e.g. the stack might have been fouled up).</p>\n", "LastActivityDate": "2014-06-13T07:47:13.250"}, "24189488": {"ParentId": "24186681", "LastEditDate": "2017-05-23T12:33:44.917", "CommentCount": "5", "CreationDate": "2014-06-12T16:31:04.300", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "24189488", "Score": "3", "Body": "<p>In the general case the best we can say here is that it depends.</p>\n<p>One case where the answer is no, happens when dealing with indeterminate values. The latest draft clearly makes it <a href=\"https://stackoverflow.com/questions/23415661/has-c-standard-changed-with-respect-to-the-use-of-indeterminate-values-and-und\">undefined behavior to produce an indeterminate value during an evaluation</a> with some exceptions but the code sample clearly shows how subtle it could be:</p>\n<blockquote>\n<p id=\"so_24186681_24189488_0\">[ <em>Example:</em></p>\n<pre><code>int f(bool b) {\n  unsigned char c;\n  unsigned char d = c; // OK, d has an indeterminate value\n  int e = d;           // undefined behavior\n  return b ? d : 0;    // undefined behavior if b is true\n}\n</code></pre>\n<p id=\"so_24186681_24189488_1\">\u2014 <em>end example</em> ]</p>\n</blockquote>\n<p>so this line of code:</p>\n<pre><code>return b ? d : 0;\n</code></pre>\n<p>is only undefined if <code>b</code> is <code>true</code>. This seems to be the intuitive approach and seems to be how John Regehr sees it as well, if we read <a href=\"http://blog.regehr.org/archives/761\" rel=\"nofollow noreferrer\">It\u2019s Time to Get Serious About Exploiting Undefined Behavior</a>.</p>\n<p>In this case the answer is yes, the code is erroneous even though we are not calling the code invoking undefined behavior:</p>\n<pre><code>constexpr const char *str = \"Hello World\" ;      \n\nconstexpr char access()\n{\n    return str[100] ;\n}\n\nint main()\n{\n}\n</code></pre>\n<p><code>clang</code> chooses to make <code>access</code> erroneous even though it is never invoked (<em><a href=\"http://coliru.stacked-crooked.com/a/d2706792027b6475\" rel=\"nofollow noreferrer\">see it live</a></em>).</p>\n", "LastActivityDate": "2014-06-12T18:52:45.513"}, "32434618": {"ParentId": "24186681", "LastEditDate": "2017-05-23T12:08:39.517", "CommentCount": "0", "CreationDate": "2015-09-07T08:52:31.167", "OwnerUserId": "2307646", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "32434618", "Score": "1", "Body": "<p>It should be, if not \"<em>shall</em>\".</p>\n<p><em>Behavior</em>, by definition from ISO C (no corresponding definition found in ISO C++ but it should be still somehow applicable), is:</p>\n<blockquote>\n<p id=\"so_24186681_32434618_0\"><strong>3.4</strong></p>\n<p id=\"so_24186681_32434618_1\"><strong>1 behavior</strong></p>\n<p id=\"so_24186681_32434618_2\">external appearance or action</p>\n</blockquote>\n<p>And UB:</p>\n<p>WG21/N4527</p>\n<blockquote>\n<p id=\"so_24186681_32434618_3\"><strong>1.3.25 [defns.undefined]</strong></p>\n<p id=\"so_24186681_32434618_4\"><strong>undefined behavior</strong></p>\n<p id=\"so_24186681_32434618_5\">behavior for which this International Standard imposes no requirements [ Note: Undefined behavior may be expected when this International Standard omits any explicit definition of behavior or when a program uses an erroneous construct or erroneous data. Permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message). Many erroneous program constructs do not engender undefined behavior; they are required to be diagnosed.\n  \u2014end note ]</p>\n</blockquote>\n<p>Despite \"to behaving during translation\" above, the word \"behavior\" used by ISO C++ is mainly about the <em>execution</em> of programs.</p>\n<p>WG21/N4527</p>\n<blockquote>\n<p id=\"so_24186681_32434618_6\"><strong>1.9 Program execution [intro.execution]</strong></p>\n<p id=\"so_24186681_32434618_7\">1 The semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine. This International Standard places no requirement on the structure of conforming implementations. In particular, they need not copy or emulate the structure of the abstract machine. Rather, conforming implementations are required to emulate (only) the observable behavior of the abstract machine as explained below.5</p>\n<p id=\"so_24186681_32434618_8\">2 Certain aspects and operations of the abstract machine are described in this International Standard as implementation-defined (for example, <code>sizeof(int)</code>). These constitute the parameters of the abstract machine.\n  Each implementation shall include documentation describing its characteristics and behavior in these respects.6 Such documentation shall define the instance of the abstract machine that corresponds to that implementation (referred to as the \u201ccorresponding instance\u201d below).</p>\n<p id=\"so_24186681_32434618_9\">3 Certain other aspects and operations of the abstract machine are described in this International Standard as unspecified (for example, evaluation of expressions in a <em>new-initializer</em> if the allocation function fails to allocate memory (5.3.4)). Where possible, this International Standard defines a set of allowable behaviors.\n  These define the nondeterministic aspects of the abstract machine. An instance of the abstract machine can thus have more than one possible execution for a given program and a given input.</p>\n<p id=\"so_24186681_32434618_10\">4 Certain other operations are described in this International Standard as undefined (for example, the effect of attempting to modify a <code>const</code> object). [ Note: This International Standard imposes no requirements on the behavior of programs that contain undefined behavior. \u2014end note ]</p>\n<p id=\"so_24186681_32434618_11\">5 A conforming implementation executing a well-formed program shall produce the same observable behavior as one of the possible executions of the corresponding instance of the abstract machine with the same program and the same input. However, if any such execution contains an undefined operation, this International Standard places no requirement on the implementation executing that program with that input (not even with regard to operations preceding the first undefined operation).</p>\n<p id=\"so_24186681_32434618_12\">5) This provision is sometimes called the \u201cas-if\u201d rule, because an implementation is free to disregard any requirement of this International Standard as long as the result is <em>as if</em> the requirement had been obeyed, as far as can be determined from the observable behavior of the program. For instance, an actual implementation need not evaluate part of an expression if it can deduce that its value is not used and that no side effects affecting the observable behavior of the program are produced.</p>\n<p id=\"so_24186681_32434618_13\">6) This documentation also includes conditionally-supported constructs and locale-specific behavior. See 1.4.</p>\n</blockquote>\n<p>It is clear the undefined behavior would be caused by specific language construct used wrongly or in a non-portable way (which is not conforming to the standard). However, the standard mention nothing about which specific portion of code in a program would cause it. In other words, <strong>\"having undefined behavior\" is the property (about conforming) of the whole program being executed, not any smaller parts of it</strong>.</p>\n<p>The standard could have given a stronger guarantee to make the behavior well-defined once some specific code is not being executed, <em>only when there exists a way to map the C++ code to the corresponding behavior precisely</em>. This is hard (if not impossible) without a detailed semantic model about execution. In short, <strong>the operational semantics given by the abstract machine model above is not enough to achieve the stronger guarantee</strong>. But anyway, ISO C++ would never be JVMS or ECMA-335. And I don't expect there would be a complete set of formal semantics describing the language.</p>\n<p>A key problem here is the meaning of \"execution\". Some people think \"executing a program\" means making the program being run. This is not quite true. Note the representation of program executed in the abstract machine is not specified. (Also note \"this International Standard places no requirement on the structure of conforming implementations\".) The code being executed here can be literally C++ code (not necessarily machine code or some other forms of intermediate code which is not specified by the standard at all). This effectively allows the core language to be implemented as an interpreter, an online partial evaluator or some other monsters translating C++ code on-the-fly. As a result, actually there is no way to split the phases of translation (defined by ISO C++ [lex.phases]) completely ahead of the process of execution without knowledge about specific implementations. Thus, it is necessary to allow UB occurring during the translation when it is too difficult to specify portable well-defined behavior.</p>\n<p>Besides the problems above, perhaps for most ordinary users, one (non-technical) reason is enough: it is simply unnecessary to provide the stronger guarantee, allow bad code and defeat one of the (probable most important) usefulness aspect of UB itself: to encourage quickly throwing away some (unnecessarily) nonportable smelly code without effort to \"fix\" them which would be eventually in vain.</p>\n<p>Additional notes:</p>\n<p>Some words are copied and reconstructed from one of my reply to <a href=\"https://stackoverflow.com/questions/1978709/are-memory-leaks-undefined-behavior-class-problem-in-c/24143792?noredirect=1#comment52324255_24143792\">this comment</a>.</p>\n", "LastActivityDate": "2015-09-07T09:16:03.017"}, "24187757": {"ParentId": "24186681", "LastEditDate": "2014-06-12T18:17:55.140", "CommentCount": "5", "CreationDate": "2014-06-12T15:02:52.043", "OwnerUserId": "775806", "LastEditorUserId": "775806", "PostTypeId": "2", "Id": "24187757", "Score": "8", "Body": "<blockquote>\n<p id=\"so_24186681_24187757_0\">If a side effect on a scalar object is unsequenced relative to <em>etc</em></p>\n</blockquote>\n<p>Side effects are changes in the state of the execution environment (1.9/12). A change is a change, not <em>an expression that, if evaluated, would potentially produce a change</em>. If there is no change, there is no side effect. If there is no side effect, then no side effect is unsequenced relative to anything else.</p>\n<p><s>This does not mean that <em>any</em> code which is never executed is UB-free (though I'm pretty sure most of it is). Each occurrence of UB in the standard needs to be examined separately.</s> (The stricken-out text is probably overly cautious; see below).</p>\n<p>The standard also says that</p>\n<blockquote>\n<p id=\"so_24186681_24187757_1\">A conforming implementation executing a well-formed program shall produce the same observable behavior\n  as one of the possible executions of the corresponding instance of the abstract machine with the same program\n  and the same input. However, if any such <strong>execution</strong> contains an undefined operation, this International\n  Standard places no requirement on the implementation executing that program <strong>with that input</strong> (not even\n  with regard to operations preceding the first undefined operation).</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>This, as far as I can tell, is the only normative reference that says what the phrase \"undefined behavior\" means: an undefined operation in a <em>program execution</em>. No execution, no UB.</p>\n", "LastActivityDate": "2014-06-12T18:17:55.140"}, "bq_ids": {"n4140": {"so_24186681_32434618_5": {"section_id": 5768, "quality": 0.9166666666666666, "length": 55}, "so_24186681_32434618_12": {"section_id": 5797, "quality": 0.9285714285714286, "length": 39}, "so_24186681_32434618_13": {"section_id": 5798, "quality": 0.8888888888888888, "length": 8}, "so_24186681_32434618_10": {"section_id": 5800, "quality": 0.7692307692307693, "length": 20}, "so_24186681_24187757_1": {"section_id": 5801, "quality": 0.9736842105263158, "length": 37}, "so_24186681_32434618_9": {"section_id": 5799, "quality": 0.9166666666666666, "length": 44}, "so_24186681_32434618_11": {"section_id": 5801, "quality": 0.9736842105263158, "length": 37}, "so_24186681_32434618_8": {"section_id": 5798, "quality": 0.918918918918919, "length": 34}, "so_24186681_24186681_1": {"section_id": 5811, "quality": 0.9629629629629629, "length": 26}, "so_24186681_32434618_7": {"section_id": 5797, "quality": 0.8648648648648649, "length": 32}, "so_24186681_24186681_0": {"section_id": 5809, "quality": 0.8888888888888888, "length": 16}, "so_24186681_24187757_0": {"section_id": 5811, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_24186681_32434618_5": {"section_id": 5541, "quality": 0.9166666666666666, "length": 55}, "so_24186681_32434618_12": {"section_id": 5570, "quality": 0.9285714285714286, "length": 39}, "so_24186681_32434618_13": {"section_id": 5571, "quality": 0.8888888888888888, "length": 8}, "so_24186681_32434618_10": {"section_id": 5573, "quality": 0.7692307692307693, "length": 20}, "so_24186681_24187757_1": {"section_id": 5574, "quality": 0.9736842105263158, "length": 37}, "so_24186681_32434618_9": {"section_id": 5572, "quality": 0.7916666666666666, "length": 38}, "so_24186681_32434618_11": {"section_id": 5574, "quality": 0.9736842105263158, "length": 37}, "so_24186681_32434618_8": {"section_id": 5571, "quality": 0.918918918918919, "length": 34}, "so_24186681_24186681_1": {"section_id": 5584, "quality": 0.9629629629629629, "length": 26}, "so_24186681_32434618_7": {"section_id": 5570, "quality": 0.8648648648648649, "length": 32}, "so_24186681_24186681_0": {"section_id": 5582, "quality": 0.8888888888888888, "length": 16}, "so_24186681_24187757_0": {"section_id": 5584, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_24186681_32434618_5": {"section_id": 7225, "quality": 0.9166666666666666, "length": 55}, "so_24186681_32434618_12": {"section_id": 7256, "quality": 0.9285714285714286, "length": 39}, "so_24186681_32434618_13": {"section_id": 7257, "quality": 0.8888888888888888, "length": 8}, "so_24186681_32434618_10": {"section_id": 7259, "quality": 0.7692307692307693, "length": 20}, "so_24186681_24187757_1": {"section_id": 7260, "quality": 0.9736842105263158, "length": 37}, "so_24186681_24187757_0": {"section_id": 7272, "quality": 0.5714285714285714, "length": 4}, "so_24186681_32434618_11": {"section_id": 7260, "quality": 0.9736842105263158, "length": 37}, "so_24186681_32434618_8": {"section_id": 7257, "quality": 0.918918918918919, "length": 34}, "so_24186681_24186681_1": {"section_id": 7272, "quality": 0.8148148148148148, "length": 22}, "so_24186681_32434618_7": {"section_id": 7256, "quality": 0.8648648648648649, "length": 32}, "so_24186681_24186681_0": {"section_id": 7270, "quality": 0.8888888888888888, "length": 16}, "so_24186681_32434618_9": {"section_id": 7258, "quality": 0.9166666666666666, "length": 44}}}, "24188174": {"ParentId": "24186681", "CommentCount": "2", "Body": "<p>In the context of a safety-critical embedded system, the posted code would be considered defective:</p>\n<ol>\n<li>The code should not pass code review and/or standards compliance (MISRA, etc) </li>\n<li>Static analysis (lint, cppcheck, etc) should flag this as a defect</li>\n<li>Some compilers can flag this as a warning (implying a defect, as well.)</li>\n</ol>\n", "OwnerUserId": "74774", "PostTypeId": "2", "Id": "24188174", "Score": "-2", "CreationDate": "2014-06-12T15:23:14.280", "LastActivityDate": "2014-06-12T15:23:14.280"}});