post_cb({"26818745": {"Id": "26818745", "PostTypeId": "2", "Body": "<h2>Don't optimize prematurely</h2>\n<p>Unfortunately, MSVC 2010 does does not support 'magic statics' that, in effect, perform automatic double-checked locking. But before you start optimizing here: Do you <strong>REALLY</strong> need it? Don't complicate your code unless it's really necessary. Especially, since you have MSVC 2010 which does not fully support C++11 you don't have any portable standard way that guarantees proper multi-threading. </p>\n<h2>The way to get it to work</h2>\n<p>However, you can use <code>boost::atomic&lt;Foo*&gt;</code> to deal with the problem and the compiler will most likely handle the problem correctly. If you really want to be sure, check the compiled assembly code in both debug and release mode. The assignment to an atomic pointer is guaranteed to take place after the construction, even if code is inlined. This is due to special compiler intrinsics for atomic operations which are guaranteed not be be reordered with writes that are supposed to happen before the write to the atomic variable.</p>\n<p>The following code should do the trick:</p>\n<pre><code>Foo &amp; Foo::Instance()\n{\n    static boost::atomic&lt;Foo *&gt; instance; // zero-initialized, since static\n\n    if ( !instance.load() )\n    {\n        boost::lock_guard&lt;boost::mutex&gt; lock(mutex);\n        if ( !instance.load() )\n        {\n            // this code is guaranteed to be called at most once.\n            instance = new Foo;\n            std::atexit( []{ delete &amp;Instance(); } );\n        }\n    }\n    return *instance.load();\n}\n</code></pre>\n<h2>Problem 1</h2>\n<p>Your compiler might still reorder things in some optimization pass. If the compiler doesn't, then the processor might do some construction reordering. Unless you use genuine atomics with their special instructions or thread-safe constructs like mutexes and condition variables you will get races, if you access a variable through different threads at the same time and at least one of them is writing. Never EVER do that. Again, boost::atomic will do the job (most likely). </p>\n<h2>Problem 2</h2>\n<p>That is exactly what magic statics are supposed to do: They safely initialize static variables that are accessed concurrently. MSVC 2010 does not support this. Therefore, don't use it. The code that is produced by the compiler will be unsafe. What you suspected in your question can in theory really happen. By the way: The memory for static variables is reserved at program start-up and is AFAIK zero-initialized. No <code>new</code> operator is called to reserve the memory for the static variable. </p>\n<h2>Still a problem?</h2>\n<p>The <code>std::atexit()</code> function might not be thread-safely implemented in MSVC 2010 and should possibly not be used at all, or should only be used in the <code>main()</code> thread. Most implementations of double-checked locking ignore this clean-up problem. And it is no problem as long as the destructor of <code>Foo</code> does nothing important. The unfreed memory, file handles and so forth will be reclaimed by the operating system anyways. Examples of something important that could be done in the destructor are notifying another process about something or serializing state to disk that will be loaded at the next start of the application. If you are interested in double checked locking there's a really good talk <em><a href=\"https://www.youtube.com/watch?v=c1gO9aB9nbs#t=1081\" rel=\"nofollow\">Lock-Free Programming (or, Juggling Razor Blades)</a></em> by Herb Sutter that covers this topic. </p>\n", "LastEditorUserId": "1335865", "LastActivityDate": "2014-11-09T14:29:46.217", "Score": "1", "CreationDate": "2014-11-08T15:30:52.297", "ParentId": "26816465", "CommentCount": "0", "OwnerUserId": "1335865", "LastEditDate": "2014-11-09T14:29:46.217"}, "bq_ids": {"n4140": {"so_26816465_26818073_0": {"length": 13, "quality": 1.0, "section_id": 3919}}, "n3337": {"so_26816465_26818073_0": {"length": 13, "quality": 1.0, "section_id": 3779}}, "n4659": {"so_26816465_26818073_0": {"length": 13, "quality": 1.0, "section_id": 4805}}}, "26816465": {"ViewCount": "643", "Body": "<p>I've seen singleton implemented using double-check locking like this:</p>\n<pre><code>Foo&amp; Foo::Instance()\n{\n    static std::unique_ptr&lt;Foo&gt; instance;\n    if (!instance)\n    {\n        boost::unique_lock&lt;boost::mutex&gt; lock(MUTEX);\n        if (!instance)\n            instance.reset(new Foo());\n    }\n    return *instance;\n}\n</code></pre>\n<p>I know that <a href=\"http://preshing.com/20130930/double-checked-locking-is-fixed-in-cpp11/\" rel=\"nofollow\">double-checked locking is fixed in C++</a>, but in our project we use Visual C++ 2010, which <a href=\"http://msdn.microsoft.com/en-us/library/hh567368.aspx\" rel=\"nofollow\">doesn't support all C++11 features</a>.</p>\n<p>I'm curious: in which ways is this code unsafe?</p>\n<h2>Problem 1</h2>\n<p>In <a href=\"http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf\" rel=\"nofollow\">Meyers-Alexandrescu paper</a>, there is a clear example of how naive DCL may fail because of \"unexpected\" order of actual commands.</p>\n<pre><code>Singleton* Singleton::instance() {\n    if (pInstance == 0) { // 1st test\n        Lock lock;\n        if (pInstance == 0) { // 2nd test\n            pInstance = new Singleton;\n        }\n    }\n    return pInstance;\n}\n</code></pre>\n<p>Here, <code>pInstance = new Singleton;</code> actuall consists of 3 steps: memory allocation, Singleton constructor and assignment, and compiler may place them in different order. If assignment happens <em>before</em> constructor, concurrent thread may end up using uninitialized piece of memory instead of valid Singleton instance.</p>\n<p>I wonder: does it still apply to my example, where instead of plain pointer <code>unique_ptr</code> is used?</p>\n<p>From the first look, <code>instance.reset(new Foo());</code> seems OK: <code>reset</code> is called only after <code>Foo</code> is fully initialized. But what if inlining occurs? I'm in doubt about thread-safety of this.</p>\n<h2>Problem 2</h2>\n<p>Another concern: is <code>static std::unique_ptr&lt;Foo&gt; instance;</code> itself safe? AFAIK, <code>static X x;</code> translates to something like this:</p>\n<pre><code>if (!x_is_initialized) {\n    x_is_initialized = true;\n    x = new X()\n}\n</code></pre>\n<p>So in my case, unique_ptr may be allocated by thread #1 (but not constructed yet!), then thread #2 takes over, and it sees that unique_ptr is seemingly initialized and has some value (actually a bogus pointer, which has not yet been replaced by <code>nullptr</code>). Thread #2 happily dereferences that bogus and program crashes with access violation.</p>\n<p>Can it actually happen?</p>\n", "AcceptedAnswerId": "26818745", "Title": "Double-checked locking and unique_ptr static initialization in Visual C++", "CreationDate": "2014-11-08T11:11:17.067", "Id": "26816465", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-11-09T14:29:46.217", "Score": "2", "OwnerUserId": "902013", "Tags": "<c++><multithreading><visual-c++><c++11>", "AnswerCount": "3"}, "26818073": {"Id": "26818073", "PostTypeId": "2", "Body": "<p>If you're OK with C++11, everything just got a whole lot simpler thanks to \u00a76.7.4:</p>\n<blockquote>\n<p id=\"so_26816465_26818073_0\">If control enters\n  the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for\n  completion of the initialization</p>\n</blockquote>\n<p>How simple? This simple:</p>\n<pre><code>Foo&amp; Foo::Instance()\n{\n     // this is thread-safe in C++11\n     static Foo instance;\n     return instance;\n}\n</code></pre>\n<p>To what degree VC2010 supports this, I do not know. And while I realize this doesn't literally answer your questions about your specific problems (I believe that <code>instance.reset()</code> solves the simple pointer problem, since <code>reset()</code> is basically just an assignment, but am not sure), hopefully it's helpful anyway. </p>\n", "LastActivityDate": "2014-11-08T14:24:05.143", "CommentCount": "1", "CreationDate": "2014-11-08T14:24:05.143", "ParentId": "26816465", "Score": "0", "OwnerUserId": "2069064"}, "26818946": {"Id": "26818946", "PostTypeId": "2", "Body": "<p>The implementation is not thread safe: there is a data race since it's possible that some thread is accessing <code>instance</code> at the same time that another is modifying it:</p>\n<pre><code>static std::unique_ptr&lt;Foo&gt; instance;\nif (!instance)                     // Read instance\n{\n    boost::unique_lock&lt;boost::mutex&gt; lock(MUTEX);\n    if (!instance)\n        instance.reset(new Foo()); // Modify instance\n}\n</code></pre>\n<p>Programs with data races have undefined behavior, realistically for VC++ on x86 it could result in: </p>\n<ul>\n<li><p>Reader threads seeing a pointer value in <code>instance</code> to a <code>Foo</code> that isn't fully constructed. The compiler is free to reorder the store into instance with the construction of the <code>Foo</code>, since such a reordering would not be observable in a program without data races.</p></li>\n<li><p>Multiple <code>Foo</code>s being constructed simultaneously and leaked. The compiler may optimize away the check of <code>!instance</code> inside the lock, since it already knows the value of <code>instance</code> from the earlier check and that value could not have changed in a program without data races. This results in multiple threads allocating <code>Foo</code>s and storing them in the <code>unique_ptr</code>. The check of the contained pointer value could be optimized out inside <code>reset</code> as well, resulting in leaked <code>Foo</code> objects.</p></li>\n</ul>\n<p>For the question of whether or not <code>static std::unique_ptr&lt;foo&gt; instance;</code> is thread-safe in the first place, the answer is a firm <strong>maybe</strong>. <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr/unique_ptr\" rel=\"nofollow\"><code>std::unique_ptr</code>'s default constructor is <code>constexpr</code> in C++11</a>, so <code>instance</code> <em>should</em> be zero-filled during constant initialization before <code>main</code> is even entered. Of course VS2010 does not support <code>constexpr</code>, so your guess is as good as mine. Examination of the generated assembly should give you an idea.</p>\n", "LastActivityDate": "2014-11-08T15:49:24.680", "CommentCount": "0", "CreationDate": "2014-11-08T15:49:24.680", "ParentId": "26816465", "Score": "1", "OwnerUserId": "923854"}});