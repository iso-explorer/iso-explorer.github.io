post_cb({"17356090": {"ParentId": "17356048", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Stack objects are still in scope when you call <code>return</code>, so the value of <code>i</code> is still 3 because the destructor for <code>A</code> has not yet been called.  The stack objects are removed when the function's stack unwinds, which is <em>after</em> the return value has been set.</p>\n<p>Imagine if this weren't the case, if stack objects could be destroyed during the <code>return</code>.  How would you be able to return a local value from the function?</p>\n<p><em>Response to comments</em></p>\n<blockquote>\n<p id=\"so_17356048_17356090_0\">@paddy Can u explain func2 and func3 in that case ?</p>\n</blockquote>\n<p>On the surface, <code>func2</code> looks almost exactly the same as <code>func1</code>, and you would be forgiven for thinking it should return 8.  But the difference here is that it returns <code>int&amp;</code> instead of <code>int</code>.  That means a <em>reference</em> to <code>i</code> is returned by <code>return i;</code>.  Even though <code>i</code> is 8 when the stack starts unwinding, by the time <code>obj</code> is destroyed and the return value is popped back to the caller, the value of <code>i</code> is 10.  Because we returned a reference, the return value is dereferenced and the current value of <code>i</code> (10) is used.</p>\n<p>For <code>func3</code> it's even easier.  This returns a normal <code>int</code>, just like <code>func1</code>.  But the instance <code>A obj;</code> is inside its own block scope: <code>{ A obj; }</code>.  So it is destroyed before the <code>return</code>, and the value of <code>i</code> is 10 when we return from the function.</p>\n", "OwnerUserId": "1553090", "LastEditorUserId": "1553090", "LastEditDate": "2013-06-28T02:18:03.577", "Id": "17356090", "Score": "4", "CreationDate": "2013-06-28T01:58:22.883", "LastActivityDate": "2013-06-28T02:18:03.577"}, "17356156": {"ParentId": "17356048", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It has to do with whether you are returning a copy of i or a reference to it before the A destructor is called:</p>\n<p><strong>func1() case:</strong></p>\n<ol>\n<li>i is set to 3</li>\n<li>the value of i is returned as a copy of i (as a temporary)</li>\n<li>i is set to 10 in A destructor</li>\n<li>the copy of i (3) is printed</li>\n</ol>\n<p><strong>func2() case:</strong></p>\n<ol>\n<li>i is set to 8</li>\n<li>the value of i is returned as reference to the global variable i</li>\n<li>i is set to 10 in A destructor</li>\n<li>the current value of i is printed</li>\n</ol>\n<p><strong>func3() case:</strong></p>\n<ol>\n<li>i is set to 8</li>\n<li>i is set to 10 in A destructor</li>\n<li>the value of i is returned as a copy</li>\n<li>the copy of i (10) is printed</li>\n</ol>\n", "OwnerUserId": "4304", "LastEditorUserId": "4304", "LastEditDate": "2013-06-28T02:13:49.317", "Id": "17356156", "Score": "2", "CreationDate": "2013-06-28T02:08:06.060", "LastActivityDate": "2013-06-28T02:13:49.317"}, "17356273": {"ParentId": "17356048", "CommentCount": "0", "Body": "<p>The variable \"i\" is global throughout the entire of your code, there is no \"local\" instance of it.</p>\n<p>Objects are destroyed when they go out of scope, which is <em>after</em> the \"return\" in your functions, not before it. So the first dtor is called only after the first value of i has been returned and the function has ended.</p>\n<pre><code>   i = 3; &lt;-- sets i to 3\n   A Ob; &lt;-- constructs object.\n   return i; &lt;-- places the value \"3\" in the return value register.\n} &lt;-- destroys object changing future values of \"i\" to 10.\n</code></pre>\n<p>If you wanted to return \"i\" rather than the value it contains at the time of the expression \"return i\" you would have to make the following change:</p>\n<pre><code>int&amp; func1()\n{\n   i = 3; &lt;-- sets i to 3\n   A Ob; &lt;-- constructs object.\n   return i; &lt;-- places a reference to \"i\" in the return value register.\n} &lt;-- destroys object changing the value of \"i\" to 10\n</code></pre>\n<p>See <a href=\"http://ideone.com/XXYu2u\" rel=\"nofollow\">http://ideone.com/XXYu2u</a></p>\n<p>I strongly encourage you to walk thru this program before and after with a debugger to better familiarize yourself with the entire process - it's the best way to solidify your understanding of what's going on.</p>\n", "OwnerUserId": "257645", "PostTypeId": "2", "Id": "17356273", "Score": "0", "CreationDate": "2013-06-28T02:24:47.283", "LastActivityDate": "2013-06-28T02:24:47.283"}, "17356131": {"ParentId": "17356048", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From the Standard (C++11, 3.7.3):</p>\n<blockquote>\n<p id=\"so_17356048_17356131_0\">(1) Block-scope variables explicitly declared register or not explicitly declared static or extern have automatic storage duration. The storage for these entities lasts until the block in which they are created exits.</p>\n<p id=\"so_17356048_17356131_1\">[...]</p>\n<p id=\"so_17356048_17356131_2\">(3) If a variable with automatic storage duration has initialization or a destructor with side effects, it shall not\n  be destroyed before the end of its block, nor shall it be eliminated as an optimization even if it appears to\n  be unused, except that a class object or its copy/move may be eliminated as specified in 12.8.</p>\n</blockquote>\n<p>What this means is that the lifetime of <code>A</code> ends whereever the block in which it is declared ends. In the case of <code>func1</code>, this is after the return-statement. In the case of <code>func3</code> it is before the return-statement.</p>\n<p>(A \"block\" is a piece of code enclosed in curly braces: <code>{...}</code>.)</p>\n<p>Hence, <code>func1</code> evaluates the return value before the destructor of <code>A</code> is called and therefore returns <code>3</code>. <code>func3</code> evaluates the return value after the destructor is called and therefore returns <code>10</code>.</p>\n<p>In the case of <code>func2</code>, the order is the same as in <code>func1</code>, but because it returns a reference, the value modification performed by the destructor of <code>A</code>, even though it is performed after the evaluation of the return value, has an effect on the value that was returned.</p>\n", "OwnerUserId": "777186", "LastEditorUserId": "777186", "LastEditDate": "2013-06-28T02:11:10.643", "Id": "17356131", "Score": "2", "CreationDate": "2013-06-28T02:05:17.647", "LastActivityDate": "2013-06-28T02:11:10.643"}, "17356082": {"ParentId": "17356048", "CommentCount": "0", "Body": "<p>The destructor occurs after the return statement but before the next line of the calling function.  The return value is saved in a hidden variable, then the destructors and other function cleanup is called (such as returning the stack), then execution continues in the caller.</p>\n<p>To further clarify-  imagine the return line was <code>return i+A.foo();</code>. You wouldn't want to call the destructor until after this line, or A wouldn't be valid to call foo on.  This is why destructors are always called after the return.</p>\n", "OwnerUserId": "1631193", "PostTypeId": "2", "Id": "17356082", "Score": "0", "CreationDate": "2013-06-28T01:57:49.067", "LastActivityDate": "2013-06-28T01:57:49.067"}, "17356048": {"CommentCount": "0", "ViewCount": "552", "CreationDate": "2013-06-28T01:52:51.110", "LastActivityDate": "2013-06-28T02:24:47.283", "Title": "Understanding local and global variable : C++", "AcceptedAnswerId": "17356131", "PostTypeId": "1", "Id": "17356048", "Score": "1", "Body": "<p>Consider below code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n\nusing namespace std;\n\nint i;\n\nclass A{\n    public:\n    ~A(){i=10;}\n    };\n\nint func1()\n{\n    i=3;\n    A Ob; // -&gt; here local object , hence created and destroyed\n    return i;\n    }\n\nint&amp; func2()\n{\n    i=8;\n    A obj;\n    return i;\n    }\n\nint func3()\n{\n    i=8;\n    {A  obj;}\n    return i;\n    }\n\n\n\n\n\nint main()\n{\n\ncout &lt;&lt; \"i : \" &lt;&lt;func1() &lt;&lt; endl;\ncout &lt;&lt; \"i : \" &lt;&lt;func2() &lt;&lt; endl;\ncout &lt;&lt; \"i : \" &lt;&lt;func3() &lt;&lt; endl;\nreturn(0);\n}\n</code></pre>\n<p>OutPut:</p>\n<pre><code>$ ./TestCPP\ni : 3\ni : 10\ni : 10\n</code></pre>\n<p>Can someone explain why first i is 3 ? In <code>func1()</code> , <code>A Ob</code> is local variable and hence it is created and destroyed. When it is destroyed, it will call its destructor modifying i to <code>10</code> and I am expecting <code>i</code> to be <code>10</code>, but answer shows <code>i : 3</code>. </p>\n", "Tags": "<c++>", "OwnerUserId": "1559833", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_17356048_17356131_2": {"section_id": 7172, "quality": 0.9642857142857143, "length": 27}, "so_17356048_17356131_0": {"section_id": 7170, "quality": 0.9090909090909091, "length": 20}}, "n3337": {"so_17356048_17356131_2": {"section_id": 6916, "quality": 0.9642857142857143, "length": 27}, "so_17356048_17356131_0": {"section_id": 6914, "quality": 0.9090909090909091, "length": 20}}, "n4659": {"so_17356048_17356131_2": {"section_id": 8680, "quality": 0.8928571428571429, "length": 25}, "so_17356048_17356131_0": {"section_id": 8678, "quality": 0.7727272727272727, "length": 17}}}});