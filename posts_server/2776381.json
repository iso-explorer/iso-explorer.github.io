post_cb({"2776421": {"ParentId": "2776381", "CommentCount": "1", "CreationDate": "2010-05-05T20:09:42.057", "OwnerUserId": "11361", "PostTypeId": "2", "Id": "2776421", "Score": "1", "Body": "<p>There is no \"clear\" definition of what are the responsibilities of an OS. It could include the following:</p>\n<ul>\n<li>Memory management</li>\n<li>Devices &amp; drivers</li>\n<li>File system(s)</li>\n<li>Processes and threads</li>\n<li>System calls</li>\n</ul>\n<p>In a nutshell OS is a program that enable the user to control computer's hardware in a relatively simple way</p>\n", "LastActivityDate": "2010-05-05T20:09:42.057"}, "2776393": {"ParentId": "2776381", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2010-05-05T20:06:56.533", "Score": "13", "LastEditorUserId": "726361", "LastEditDate": "2012-04-25T22:27:21.097", "Id": "2776393", "OwnerUserId": "129032", "Body": "<p>An operating system is a layer between your code (user code) and the hardware. </p>\n<p>The OS is responsible for managing the physical components and giving you a simple (hopefully) API off of which to build. It handles which programs run, when, who goes first, how memory is handled, who gets memory, video drawing, and all that good stuff.</p>\n<p>For example, when making a GUI, instead of you sending each bit to the monitor, you tell the OS (or window manager) to make a window. You then tell it to place a button in your window. The OS then handles drawing the window, moving the window, moving the button (but keeping it where it should be in the window).</p>\n<p>Now, you can program an operating system in C++, but it's not easy. You have to develop your kernel and whatnot, find a way to interface with the hardware, then expose that interface to your users and their programs.</p>\n<p>So, essentially, an OS handles software-to-hardware interfacing and manages your physical resources. C++ programs can be run in an OS or, with enough work, run by themselves or even be an OS.</p>\n", "LastActivityDate": "2012-04-25T22:27:21.097"}, "3281759": {"ParentId": "2776381", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2010-07-19T14:05:55.880", "Score": "1", "LastEditorUserId": "84704", "LastEditDate": "2010-07-19T14:11:43.813", "Id": "3281759", "OwnerUserId": "84704", "Body": "<p>The term \"operating system\" when applied to a PC, normally refers to a modern \"protected memory\" operating system that provides not only a basic set of system services but also a complete user interface:</p>\n<ul>\n<li><p>the combination of a kernel, device drivers, and system services that provide memory protection, tasks that can not interfere with each other's memory, and threads which are units of execution within a process, as well as ways for threads and tasks to talk to each other and to access shared resources like file-systems that contain files, on storage devices like your PC's hard disk,  are in fact, the core of the operating system.</p></li>\n<li><p>the \"shell\" on top of that operating system might be as simple as the \"command.com\" text command prompt on DOS (remember \" C:&gt; _ \"?) or as complex as the Windows Shell,  including its control panel, etc.</p></li>\n</ul>\n<p>Sometimes, a \"linux distribution\" contains far more than an operating system, but is informally referred to by a single name (such as Ubuntu) and so the line between what the operating system is (the linux kernel and standard libraries perhaps) and the applications that merely ship with that operating system (the Gnome and KDE environments on Linux) is pretty gray.</p>\n<p>A great way to learn what an operating system really is, is to read one of Tannenbaum's books on Operating Systems.  I believe he shows the implementation in detail of his \"minix\" kernel. Another book is \"Linux Kernel Internals\". If you can handle the technical detail in this kind of book, then you can really understand what an operating system \"kernel\" is, and then begin to make sense of the layers around that kernel.</p>\n<p>I am not aware of one commercial or open source operating system that is written primarily in C++.   Such system-level programming is most commonly carried out in a mix of pure ANSI C, and Assembly/Machine language.  The low level assembly bits often are involved in tasks like handling interrupts, initializing hardware and booting the system up.   Before you have a heap, and a stack, and a working virtual memory system, you wouldn't want to be using C++ objects, or even certain C features like malloc.   Your resources and your design must be constrained by performance criteria, and any kind of extra overhead, even a semantic overhead, is to be deplored.</p>\n<p>Recently Linus Torvalds famously insulted C++ and described on a mailing list why he would never use it for a Linux kernel.  I believe however, that C++ is making inroads in areas that have typically been havens of \"pure C\". The Gnu GCC team for example is willing to allow C++ into the GCC codebase now, at last.</p>\n", "LastActivityDate": "2010-07-19T14:11:43.813"}, "bq_ids": {"n4140": {"so_2776381_2776639_0": {"section_id": 5775, "quality": 0.8181818181818182, "length": 27}, "so_2776381_2776639_2": {"section_id": 6266, "quality": 0.8181818181818182, "length": 9}, "so_2776381_2776639_1": {"section_id": 6265, "quality": 0.6923076923076923, "length": 9}}, "n3337": {"so_2776381_2776639_0": {"section_id": 5548, "quality": 0.8181818181818182, "length": 27}, "so_2776381_2776639_2": {"section_id": 6026, "quality": 0.8181818181818182, "length": 9}, "so_2776381_2776639_1": {"section_id": 6025, "quality": 0.6923076923076923, "length": 9}}, "n4659": {"so_2776381_2776639_0": {"section_id": 7232, "quality": 0.8181818181818182, "length": 27}, "so_2776381_2776639_2": {"section_id": 7772, "quality": 0.8181818181818182, "length": 9}, "so_2776381_2776639_1": {"section_id": 7771, "quality": 0.6923076923076923, "length": 9}}}, "2776481": {"ParentId": "2776381", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From a programming perspective operating systems primarily provide <em>abstraction</em>.  Abstraction from the details of the CPU and memory management, abstraction from dealing with hardware devices, abstraction from the details of network protocol stacks.</p>\n<p>The operating system provides a higher-level programming interface, often standardized across several operating systems like POSIX does for all Unix flavors.</p>\n", "OwnerUserId": "16023", "CommunityOwnedDate": "2010-05-05T20:18:34.917", "Id": "2776481", "Score": "1", "CreationDate": "2010-05-05T20:18:34.917", "LastActivityDate": "2010-05-05T20:18:34.917"}, "2776391": {"ParentId": "2776381", "CommentCount": "0", "CreationDate": "2010-05-05T20:06:29.660", "OwnerUserId": "216063", "PostTypeId": "2", "Id": "2776391", "Score": "3", "Body": "<p>sure, <a href=\"http://en.wikipedia.org/wiki/Operating_system\" rel=\"nofollow noreferrer\">http://en.wikipedia.org/wiki/Operating_system</a></p>\n<blockquote>\n<p id=\"so_2776381_2776391_0\">An operating system is the software on a computer that manages the way different programs use its hardware, and regulates the ways that a user controls the computer. Operating systems are found on almost any device that contains a computer with multiple programs\u2014from cellular phones and video game consoles to supercomputers and web servers. Some popular modern operating systems for personal computers include Microsoft Windows, Mac OS X, and Linux (see also: list of operating systems, comparison of operating systems).</p>\n</blockquote>\n<p>I mean the description of an operating system, what it does when and why goes far beyond an answer on this site imho.</p>\n", "LastActivityDate": "2010-05-05T20:06:29.660"}, "2776407": {"ParentId": "2776381", "CommentCount": "0", "CreationDate": "2010-05-05T20:08:14.027", "OwnerUserId": "1175", "PostTypeId": "2", "Id": "2776407", "Score": "4", "Body": "<p>An OS is really just a program that runs other programs and manages hardware resources for them.</p>\n<p>If you are really serious about getting into the internals, I'd recommend reading the book <a href=\"http://oreilly.com/catalog/9780596000028\" rel=\"nofollow noreferrer\">Understanding the Linux Kernel</a>.</p>\n", "LastActivityDate": "2010-05-05T20:08:14.027"}, "2776611": {"ParentId": "2776381", "CommentCount": "0", "CreationDate": "2010-05-05T20:40:50.760", "OwnerUserId": "17675", "PostTypeId": "2", "Id": "2776611", "Score": "2", "Body": "<p>An operating system, more specifically its kernel, is developed in a language such as C. And it is compiled into machine code just like any other program. The major difference between a mainstream OS and some code that you write in C is that the C code will run in a timeshare via the OS's CPU Scheduler. Also consider that the OS runs <strong>first</strong>, and is able to setup such an environment where it completely controls and restricts anything which it launches. Also keep in mind that system calls are how a process can communicate back to the OS, everything is just typical machine instructions that could run on any other processor of its type.</p>\n<p>A few key features that any mainstream OS provides:</p>\n<ul>\n<li>CPU Scheduler - This will load a process, allow it to run for a very limited amount of time before kicking it back off, regaining control and allowing something else to run (wether it be a kernel task or another process, typically kernel tasks have priority)</li>\n<li>Memory management - Any application which you run does not have exact memory addresses since this is prone to change. All processes will run in virtual memory, and the OS will translate virtual memory (ex: 0x41000+) into a physical address. (again, its abstracting the hardware as is mentioned often)</li>\n<li>File systems - <a href=\"http://en.wikipedia.org/wiki/File_system#Disk_file_systems\" rel=\"nofollow noreferrer\">various kinds</a></li>\n<li>Resources - any kind of device kind be treated as a resource. A process may request access to a resource. (Oddly enough, in this day and age no mainstream OS has a mechanism for preventing dead locks for resources.)</li>\n<li>Security - This is done through roles. It is very important that every process run within tight constrictions. This is another abstraction that the OS provides.</li>\n</ul>\n", "LastActivityDate": "2010-05-05T20:40:50.760"}, "2776693": {"ParentId": "2776381", "CommentCount": "0", "CreationDate": "2010-05-05T20:53:53.137", "OwnerUserId": "151841", "PostTypeId": "2", "Id": "2776693", "Score": "1", "Body": "<p>Basically an OS is the program that all other programs run inside of. It's literally the first program that your computer starts running when it boots up. As such, it controls all the hardware, and acts at the gatekeeper for other programs to access that hardware. It also controls ( or should, at least ) all the programs that are running under it -- when they start, how the stop, and what resources they have access to. You might call it \"The Master Control Program\" :)</p>\n", "LastActivityDate": "2010-05-05T20:53:53.137"}, "2776381": {"CommentCount": "1", "AcceptedAnswerId": "2776393", "PostTypeId": "1", "LastEditorUserId": "82320", "CreationDate": "2010-05-05T20:04:47.920", "LastActivityDate": "2012-04-25T22:27:21.097", "LastEditDate": "2011-06-08T01:54:36.290", "ViewCount": "868", "FavoriteCount": "3", "Title": "What Does an OS Actually Do?", "Id": "2776381", "Score": "13", "Body": "<p>What exactly does an operating system do? I know that operating systems can be programmed, in, for example, C++, but I previously believed that C++ programs must be run under an operating system? Can somebody please explain and give links? thanks in advance, ell</p>\n", "Tags": "<c++><operating-system>", "OwnerUserId": "303662", "AnswerCount": "11"}, "2776418": {"ParentId": "2776381", "CommentCount": "0", "CreationDate": "2010-05-05T20:09:26.270", "OwnerUserId": "283899", "PostTypeId": "2", "Id": "2776418", "Score": "1", "Body": "<p>An operating system is just a software which is an interface between your hardware and your software. It makes an abstraction of this hardware to make it simpler to use. For instance, you don't have to read the keyboard status in your programs to check if the user hit a key. You might think of it as a lot of bricks put together and piled on top of each other, from a very precise view of the hardware to a very abstract view (from bits, to windows or buttons... for instance)</p>\n<p>You don't have to program an operating system in a specific language, but most of them are written in C for efficiency and convenience reasons. You can do programming (your own applications) in any language then, provided that you have the correct libraries installed on the operating system.</p>\n", "LastActivityDate": "2010-05-05T20:09:26.270"}, "2776504": {"ParentId": "2776381", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2010-05-05T20:22:11.120", "Score": "1", "LastEditorUserId": "74465", "LastEditDate": "2010-05-05T20:35:14.210", "Id": "2776504", "OwnerUserId": "250195", "Body": "<p>After reading the question, I see what you're trying to ask. What you're asking is if C/C++ programs require an OS to run. The answer is no. A C/C++ is a compiler that translate human language into machine language. It doesn't require a specific operating system. However, if you compile in say, Visual Studio, the resulting executable machine code can't run on anything but the Windows. </p>\n<p>In specific, C/C++ code are usually portable in that if you have a compiler for an operating system, you can compile it and it will run like so. However, sometimes you have machine specific code (or OS specific code), such as a windows application that uses windows-based interfaces that cannot be ported over to another operating system. Some examples I can think of are like directory operations are usually not portable and usually depends on what OS you're on. However, most file operations, like fopen, are portable.</p>\n<p>An OS is a bit different. It requires a different kind of compiler, and it requires a different way to load. Most OS are made in C/C++, it is then compiled by a compiler, then it is distributed. For example, Microsoft wrote Windows 95 in C/C++, they put it through a compiler, then burnt the resulting executable code into a CD-ROM, then sold it to you then you put the disk in and it will copy the resulting executable code onto your machine and you use it. </p>\n<p>They don't give you the source code, then your computer compiles it; it's usually they give you the resulting executable.</p>\n", "LastActivityDate": "2010-05-05T20:35:14.210"}, "2776639": {"ParentId": "2776381", "CommentCount": "0", "CreationDate": "2010-05-05T20:44:21.693", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "2776639", "Score": "6", "Body": "<p>Actually, the C++ standard itself has something to say on this issue. \u00a71.4/7:</p>\n<blockquote>\n<p id=\"so_2776381_2776639_0\">Two kinds of implementations are defined: hosted and freestanding. For a hosted implementation, this International Standard defines the set of available libraries. A freestanding implementation is one in which execution may take place without the benefit of an operating system, and has an implementation-defined set of libraries that includes certain language-support libraries (17.4.1.3).</p>\n</blockquote>\n<p>And in 17.4.1.3,</p>\n<blockquote>\n<p id=\"so_2776381_2776639_1\">A freestanding implementation has an implementation-defined set of headers. This set shall include at least the following headers, as shown in Table 13:</p>\n</blockquote>\n<pre><code>Table 13\u2014C++ Headers for Freestanding Implementations\n_______________________________________________\n\uf8ec Subclause Header(s)\n\uf8ec 18.1 Types    &lt;cstddef&gt;   \n\uf8ec 18.2 Implementation properties    &lt;limits&gt;\n\uf8ec 18.3 Start and termination    &lt;cstdlib&gt;\n\uf8ec 18.4 Dynamic memory management    &lt;new&gt;\n\uf8ec 18.5 Type identification  &lt;typeinfo&gt;  \n\uf8ec 18.6 Exception handling   &lt;exception&gt; \n\uf8ec 18.7 Other runtime support    &lt;cstdarg&gt;   \n</code></pre>\n<blockquote>\n<p id=\"so_2776381_2776639_2\">The supplied version of the header  shall declare at least the functions abort(), atexit(), and exit() (18.3).</p>\n</blockquote>\n<p>These headers either define constants or provide basic support to the compiler. In practice, some language features will be missing until the OS completes some initialization, for example <code>new</code> and <code>catch</code>.</p>\n", "LastActivityDate": "2010-05-05T20:44:21.693"}});