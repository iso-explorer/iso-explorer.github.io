post_cb({"19122261": {"Id": "19122261", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_19121820_19122261_0\">a) in this case, subarray is allocated on the stack. Why after the function method has finished, if I look on elements[0] I still see the data of subarray? Has the compiler translated the first allocation in a heap allocation (and in this case, is this a good practice)?</p>\n</blockquote>\n<p>It's called \"undefined behavior\" and anything can happen. In this case, the values that <code>subarray</code> held are still there, incidentally, probably because you access that memory immediately after the function returns. But your compiler could also zero-out those values before returning. Your compiler could also send fire-spewing dragons to your home. Anything can happen in \"undefined behavior\"-land.</p>\n<blockquote>\n<p id=\"so_19121820_19122261_1\">b) if I declare subarray as \"const\", then the compiler does not let me assign it to elements. Why not? I thought that the const only concerns the inability to change the pointer, but nothing else.</p>\n</blockquote>\n<p>This is a rather unfortunate quirk of the language. Consider</p>\n<pre><code>const int * p1; // 1\nint const * p2; // 2\nint * const p3; // 3\nint * p4;       // 4\nint const * const p5; // 5\n</code></pre>\n<p>This is all valid C++ syntax. 1 says that we have a <em>mutable</em> pointer to a <em>const int</em>. 2 says the same as 1 (this is the quirk). 3 says that we have a <em>const pointer</em> to a <em>mutable int</em>. 4 says that we have a plain old <em>mutable pointer</em> to a <em>mutable int</em>. 5 says that we have a <em>const pointer</em> to a <em>const int</em>. The rule is roughly this: Read const from <em>right-to-left</em>, except for the very last const, which can either be on the right or on the left.</p>\n<blockquote>\n<p id=\"so_19121820_19122261_2\">c) suppose I want to allocate \"elements\" not with a fixed 10 elements, but with a parameter that comes from the constructor. Is it still possible to allocate it in the stack, or the constructor will always allocate it in the heap?</p>\n</blockquote>\n<p>If you need dynamic allocation, then this will <em>usually</em> be on the heap, but the notion of stack and heap is implementation-dependent (i.e. whatever your compiler vendor does).</p>\n<p>Lastly, if you have a Java background, then you'll need to consider ownership of memory. For example, in your method <code>void A::method(const int**)</code>, you point your pointers to locally created memory, while that memory goes away after the method returns. Your pointers now point to memory that nobody owns. It would be better to actually copy that memory into a new area (for example, a data member of the class <code>A</code>), and then let your pointers point to <em>that</em> piece of memory.\nAlso, while C++ can do pointers, it would be wise to avoid them at all costs. For example, strive to use references instead of pointers when possible and appropriate, and use the <code>std::vector</code> class for arbitrary sized arrays. This class'll also take care of the ownership problem, as assigning a vector to another vector will actually copy all the elements from the one to the other (except now with rvalue references, but forget that for the moment). Some people regard a \"naked\" new/delete as bad programming practice.</p>\n", "LastEditorUserId": "990142", "LastActivityDate": "2013-10-01T17:43:49.467", "Score": "2", "CreationDate": "2013-10-01T17:22:59.217", "ParentId": "19121820", "CommentCount": "4", "OwnerUserId": "990142", "LastEditDate": "2013-10-01T17:43:49.467"}, "19123559": {"Id": "19123559", "PostTypeId": "2", "Body": "<p>One of the major differences between Java and C/C++ is explicit Undefined Behavior (UB). The existence of UB is a major source of performance for C/C++. The difference between UB and \"Not allowed\" is that UB is unchecked, so anything can happen. In practice, when a C/C++ compiler compiles code that triggers UB the compiler will do whatever produces the most performant code. </p>\n<p>Most of the time that means \"no code\" because you can't get any faster than that, but sometimes there are more aggressive optimizations that come from conclusions of UB, e.g a pointer that was dereferenced cannot be NULL (because that would be UB), so a check for NULL later should always be false, therefore the compiler will rightfully decide that the check can be left away. </p>\n<p>Since it is often also hard for the compiler to identify UB (and not required by the standard), it truly is correct that \"anything can happen\". </p>\n<p>1) According to the standard it is UB to dereference a pointer to an automatic variable after you left the scope. Why does that work? Because the data still is there in the location you left it. Until the next function call overwrites it. Think of it like driving a car after you sold it.</p>\n<p>2) There are actually two consts possible in a pointer:</p>\n<pre><code>int * a;                        // Non const pointer to non const data\nint const * b;                  // Non const pointer to const data\nint * const c = &amp;someint;       // Const pointer to non const data\nint const * const d = &amp;someint; // Const pointer to const data\n</code></pre>\n<p>The <code>const</code> before the <code>*</code> refers to the data and the <code>const</code> after the <code>*</code> refers to the pointer itself.</p>\n<p>3) Not a stupid question. In C it is legal to allocate an array on the stack with dynamic size, but in C++ it is not. This is because in C there is no need to call constructors and destructors. This is a hard problem in C++ and was discussed for the latest C++11 standard but it was decided that it will stay the way it was: It's not part of the standard. </p>\n<p>So why does it work sometimes? Well, it works in GCC. This is a non-standard compiler extension of GCC. I suspect that they simply use the same code for C and C++ and they \"left it in there\". You can turn this off whith that GCC switch that makes it behave in a standard way.</p>\n", "LastEditorUserId": "168683", "LastActivityDate": "2013-10-01T19:22:10.213", "Score": "1", "CreationDate": "2013-10-01T18:43:10.550", "ParentId": "19121820", "CommentCount": "5", "OwnerUserId": "168683", "LastEditDate": "2013-10-01T19:22:10.213"}, "19121880": {"Id": "19121880", "PostTypeId": "2", "Body": "<p>The standard does not talk about the stack or the heap, in this case your array has automatic storage which in most modern systems will be on the stack. It is just plain <a href=\"https://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow\">undefined behavior</a> to keep a pointer to an automatic object once you have exited the scope and then access it. The draft C++ standard in section <code>3.7.3</code> <em>paragraph 1</em> says(<em>emphasis mine</em>): </p>\n<blockquote>\n<p id=\"so_19121820_19121880_0\">Block-scope variables explicitly declared register or not explicitly declared static or extern have automatic storage duration. <strong>The storage for these entities lasts until the block in which they are created exits.</strong></p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2013-10-01T17:12:40.687", "Score": "0", "CreationDate": "2013-10-01T16:58:50.283", "ParentId": "19121820", "CommentCount": "1", "OwnerUserId": "1708801", "LastEditDate": "2013-10-01T17:12:40.687"}, "19121981": {"Id": "19121981", "PostTypeId": "2", "Body": "<p>a) You see it because the stack space for it has not yet been reclaimed.  This memory is subject to being overwritten as the stack grows and shrinks.  Do not do this, results are undefined!</p>\n<p>b) subarray is a integer array, not a pointer.  If it is const, you cannot assign to it.</p>\n<p>c) Not a stupid question at all.  You can do it with a placement new.  It is also possible to use a variable to dimension an array on the stack.</p>\n", "LastActivityDate": "2013-10-01T17:04:29.603", "CommentCount": "0", "CreationDate": "2013-10-01T17:04:29.603", "ParentId": "19121820", "Score": "0", "OwnerUserId": "1649548"}, "bq_ids": {"n4140": {"so_19121820_19121880_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 7170}}, "n3337": {"so_19121820_19121880_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 6914}}, "n4659": {"so_19121820_19121880_0": {"length": 17, "quality": 0.7727272727272727, "section_id": 8678}}}, "19122047": {"Id": "19122047", "PostTypeId": "2", "Body": "<p>re a):  When the function returns the data is still where you put it, on the stack. But it is undefined behavior to access it there, and that storage will be reused almost immediately. It will certainly be reused upon the next call to any function. That's inherent in the way the stack is used.</p>\n", "LastActivityDate": "2013-10-01T17:08:43.783", "CommentCount": "0", "CreationDate": "2013-10-01T17:08:43.783", "ParentId": "19121820", "Score": "0", "OwnerUserId": "2360695"}, "19121820": {"ViewCount": "293", "Body": "<p>I come from many years of development in Java, and now that I want switch to C++ I have hard times understanding the memory management system.</p>\n<p>Let me explain the situation with a small example:</p>\n<p>From my understanding, you can allocate space either on the stack or on the heap. The first is done by declaring a variable like this:</p>\n<pre><code> int a[5]\n</code></pre>\n<p>or </p>\n<pre><code>int size = 10;\nint a[size]\n</code></pre>\n<p>On the contrary, if you want to allocate memory on the heap, then you can do it using the \"new\" command. For example like:</p>\n<pre><code>int *a = new int[10]; (notice that I haven't tried all the code, so the syntax might be wrong)\n</code></pre>\n<p>One difference between the two is that if it is allocated on the stack when the function is finished then the space is automatically deallocated, while on the other case we must explicitly deallocate it with delete().</p>\n<p>Now, suppose I have a class like this:</p>\n<pre><code>class A {\n  const int *elements[10];\n\n  public void method(const int** elements) {\n    int subarray[10];\n    //do something\n    elements[0] = subarray;\n  }\n}\n</code></pre>\n<p>Now, I have few questions:</p>\n<ol>\n<li>in this case, subarray is allocated on the stack. Why after the function method has finished, if I look on elements[0] I still see the data of subarray? Has the compiler translated the first allocation in a heap allocation (and in this case, is this a good practice)?</li>\n<li>if I declare subarray as \"const\", then the compiler does not let me assign it to elements. Why not? I thought that the const only concerns the inability to change the pointer, but nothing else.</li>\n<li>(this is probably quite stupid) suppose I want to allocate \"elements\" not with a fixed 10 elements, but with a parameter that comes from the constructor. Is it still possible to allocate it in the stack, or the constructor will always allocate it in the heap?</li>\n</ol>\n<p>Sorry for such questions (that might look silly to a expert C programmer), but the memory management system of C++ is VERY different from Java, and I want to avoid leakings or slow code. Many thanks in advance!</p>\n", "Title": "(C++) What happened to an array allocated on the stack when the function is finished?", "CreationDate": "2013-10-01T16:54:45.227", "LastActivityDate": "2013-10-01T19:22:10.213", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-10-01T17:11:26.483", "LastEditorUserId": "185915", "Id": "19121820", "Score": "4", "OwnerUserId": "2835721", "Tags": "<c++><memory-management>", "AnswerCount": "6"}, "19121906": {"Id": "19121906", "PostTypeId": "2", "Body": "<p><strong>A)</strong> No, the compiler has not translated it and you're not venturing into undefined behavior. To try to find some parallels to a Java developer, think about your function arguments. When you do:</p>\n<pre><code>int a = 4;\nobj.foo(a);\n</code></pre>\n<p>what happens to <code>a</code> when it's passed to the method <code>foo</code>? A copy is made, it is added to the stack frame, and then when the function returns the frame is now used for other purposes. You can think of local stack variables to be a continuation of the arguments, since they're typically treated similarly, barring calling convention. I think reading more about how the stack (the language-agnostic stack) works can illuminate further on the issue.</p>\n<p><strong>B)</strong> You can mark the pointer <code>const</code>, or you can mark the stuff it points to <code>const</code>.</p>\n<pre><code>int b = 3\nconst int * const ptr = &amp;b;\n^            ^\n|            |- this const marks the ptr itself const\n| - this const marks the stuff ptr points to const\n</code></pre>\n<p><strong>C)</strong> It is possible to allocate it on the stack in some C++ standards, but not in others.</p>\n", "LastEditorUserId": "490562", "LastActivityDate": "2013-10-01T17:58:29.337", "Score": "2", "CreationDate": "2013-10-01T17:00:07.953", "ParentId": "19121820", "CommentCount": "6", "OwnerUserId": "490562", "LastEditDate": "2013-10-01T17:58:29.337"}});