post_cb({"bq_ids": {"n4140": {"so_42142800_42142800_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 102}, "so_42142800_42142800_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 142}, "so_42142800_42142800_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 142}, "so_42142800_42143510_0": {"length": 16, "quality": 1.0, "section_id": 142}}, "n3337": {"so_42142800_42142800_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 97}, "so_42142800_42142800_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 136}, "so_42142800_42142800_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 136}, "so_42142800_42143510_0": {"length": 16, "quality": 1.0, "section_id": 136}}, "n4659": {"so_42142800_42142800_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 106}, "so_42142800_42142800_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 180}, "so_42142800_42143510_2": {"length": 12, "quality": 1.0, "section_id": 149}}}, "42142800": {"ViewCount": "135", "Body": "<p>Consider this simple template specialization:</p>\n<pre><code>template&lt;typename T, size_t I&gt;\nstruct S {};\n\ntemplate&lt;typename T&gt;\nstruct S&lt;T, std::tuple_size&lt;T&gt;::value&gt; {};\n</code></pre>\n<p>GCC does not compile it, as it uses template parameter <code>T</code> in the template argument <code>std::tuple_size&lt;T&gt;::value</code>:</p>\n<blockquote>\n<p id=\"so_42142800_42142800_0\">error: template argument 'std::tuple_size&lt;_Tp&gt;::value'\n  involves template parameter(s)</p>\n</blockquote>\n<p>Now let's replace <code>T</code> with <code>typename std::remove_reference&lt;T&gt;::type</code> in <code>tuple_size</code> template argument:</p>\n<pre><code>// Using primary structure template from previous example.\ntemplate&lt;typename T&gt;\nstruct S&lt;T, std::tuple_size&lt;typename std::remove_reference&lt;T&gt;::type&gt;::value&gt; {};\n</code></pre>\n<p>This code still uses template parameter in template argument, but GCC compiles it without any errors or warnings. Why?</p>\n<p>Now if we try to compile the second example using MSVS with <code>/std:c++latest</code> flag, it stops with error <a href=\"https://msdn.microsoft.com/en-us/library/e5fhx6s4.aspx\" rel=\"nofollow noreferrer\">C2755</a>:</p>\n<blockquote>\n<p id=\"so_42142800_42142800_1\">non-type parameter of a partial specialization must be a simple\n  identifier</p>\n</blockquote>\n<p>What is this strange restriction? I want to stop compile-time recursion when <code>I</code> becomes equal to tuple size.</p>\n<p>So who of them is wrong: MSVS or GCC?</p>\n<p>Note that MSVS reports the error even without any template instantiations, while GCC works fine with all of these instances:</p>\n<pre><code>S&lt;std::tuple&lt;int, float&gt;, 9&gt; s1;\nS&lt;std::tuple&lt;int, float&gt;, 2&gt; s2;\nS&lt;int, 42&gt; s3;\n</code></pre>\n<p>I use MSVS Community 2015 Update 3 with it's default compiler and GCC 6.2.1.</p>\n<p>Tried Clang 3.8.0. It does not compile both snippets with an error similar to GCC's message:</p>\n<blockquote>\n<p id=\"so_42142800_42142800_2\">error: non-type template argument depends on a template parameter of\n  the partial specialization</p>\n</blockquote>\n", "AcceptedAnswerId": "42143510", "Title": "Partial template specialization with non-type parameters: GCC vs MSVS", "CreationDate": "2017-02-09T17:10:10.650", "Id": "42142800", "CommentCount": "0", "LastEditDate": "2017-02-09T17:41:24.740", "PostTypeId": "1", "LastEditorUserId": "1690777", "LastActivityDate": "2017-02-09T17:47:34.357", "Score": "2", "OwnerUserId": "1690777", "Tags": "<c++><gcc><visual-c++><language-lawyer><template-specialization>", "AnswerCount": "1"}, "42143510": {"Id": "42143510", "PostTypeId": "2", "Body": "<p>The specific section of the standard dealing with the viability of a partial class template specialization has been changed lots of times over the last few years. The original restrictionin [temp.class.spec.match] read:</p>\n<blockquote>\n<p id=\"so_42142800_42143510_0\">A partially specialized non-type argument expression shall not involve a template parameter of the partial specialization except when the argument expression is a simple <em>identifier</em>.</p>\n</blockquote>\n<p>Your code clearly runs afoul of that, <code>std::tuple_size&lt;T&gt;::value</code> is not an identifier. </p>\n<p>It then changed, after <a href=\"https://wg21.cmeerw.net/cwg/issue1315\" rel=\"nofollow noreferrer\">cwg issue 1315</a>, to read:</p>\n<blockquote>\n<p id=\"so_42142800_42143510_1\">Each <em>template-parameter</em> shall appear at least once in the <em>template-id</em> outside a non-deduced context.</p>\n</blockquote>\n<p>But we're okay there - <code>T</code> is used in a non-deduced context as the first template parameter. And after <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0127r2.html\" rel=\"nofollow noreferrer\">template <code>auto</code></a>, it now reads:</p>\n<blockquote>\n<p id=\"so_42142800_42143510_2\">If the template arguments of a partial specialization cannot be deduced because of the structure of its\n  <em>template-parameter-list</em> and the <em>template-id</em>, the program is ill-formed.</p>\n</blockquote>\n<p>But we're okay there too. It can be deduced, you have the right \"structure\" - your specialization is using a non-type template parameter in the same location as the primary, and they should match fine. </p>\n<hr/>\n<p>I think following the resolution of 1315 (which I think is <em>post</em>-C++14), the code should be well-formed, but both gcc and clang reject it. An unfortunate fix would be to use two <em>type</em> parameters instead:</p>\n<pre><code>template &lt;class T, class I&gt;\nstruct S;\n\ntemplate&lt;typename T&gt;\nstruct S&lt;T, typename std::tuple_size&lt;T&gt;::type&gt; {};\n\ntemplate &lt;size_t I&gt;\nusing size_ = std::integral_constant&lt;size_t, I&gt;;\n\nint main() {\n    S&lt;std::tuple&lt;int&gt;, size_&lt;1&gt;&gt; s;\n}\n</code></pre>\n<p>Both gcc and clang accept that one. </p>\n", "LastActivityDate": "2017-02-09T17:47:34.357", "CommentCount": "0", "CreationDate": "2017-02-09T17:47:34.357", "ParentId": "42142800", "Score": "3", "OwnerUserId": "2069064"}});