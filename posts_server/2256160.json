post_cb({"2256215": {"PostTypeId": "2", "Body": "<p>Of course, allocating a vector here is silly. Using std::wstring here is not wise also. It's better to use a char array to call the winapi. construct a wstring when returning value.</p>\n", "LastActivityDate": "2010-02-13T02:07:44.273", "Id": "2256215", "CommentCount": "1", "CreationDate": "2010-02-13T02:07:44.273", "ParentId": "2256160", "Score": "-2", "OwnerUserId": "269262"}, "2256218": {"PostTypeId": "2", "Body": "<p>I'd consider it quite safe to assume that std::string allocates its storage contiguously.</p>\n<p>At the present time, all known implementations of <code>std::string</code> allocate space contiguously. </p>\n<p>Moreover, the current draft of C++ 0x (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf\" rel=\"noreferrer\">N3000</a>) [Edit: Warning, direct link to large PDF] requires that the space be allocated contiguously (\u00a721.4.1/5): </p>\n<blockquote>\n<p id=\"so_2256160_2256218_0\">The char-like objects in a\n  basic_string object shall be stored\n  contiguously. That is, for any\n  basic_string object s, the identity\n  &amp;*(s.begin() + n) == &amp;*s.begin() + n\n  shall hold for all values of n such\n  that 0 &lt;= n &lt; s.size().</p>\n</blockquote>\n<p>As such, the chances of a current or future implementation of <code>std::string</code> using non-contiguous storage are essentially nil.</p>\n", "LastActivityDate": "2010-02-13T02:08:34.920", "Id": "2256218", "CommentCount": "6", "CreationDate": "2010-02-13T02:08:34.920", "ParentId": "2256160", "Score": "23", "OwnerUserId": "179910"}, "2256521": {"PostTypeId": "2", "Body": "<p>A while back there was a question about being able to write to the storage for a <code>std::string</code> as if it were an array of characters, and it hinged on whether the contents of a <code>std::string</code> were contiguous:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/760790/is-it-legal-to-write-to-stdstring/760900#760900\">Is it legal to write to std::string?</a></li>\n</ul>\n<p>My answer indicated that according to a couple well regarded sources (Herb Sutter and Matt Austern) the current C++ standard does require <code>std::string</code> to store its data contiguous under certain conditions (once you call <code>str[0]</code> assuming <code>str</code> is a <code>std::string</code>) and that that fact pretty much forces the hand of any implementation.</p>\n<p>Basically, if you combine the promises made by <code>string::data()</code> and <code>string::operator[]()</code> you conclude that <code>&amp;str[0]</code> needs to return a contiguous buffer. Therefore Austern suggests that the committee just make that explicit, and apparently that's what'll happen in the 0x standard (or are they calling it the 1x standard now?).</p>\n<p>So strictly speaking an implementation doesn't have to implement <code>std::string</code> using contiguous storage, but it has to do so pretty much on demand.  And your example code does just that by passing in <code>&amp;buffer[0]</code>.</p>\n<p>Links:</p>\n<ul>\n<li><a href=\"http://herbsutter.wordpress.com/2008/04/07/cringe-not-vectors-are-guaranteed-to-be-contiguous/#comment-483\" rel=\"nofollow noreferrer\">Herb Sutter's comment</a></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530\" rel=\"nofollow noreferrer\">Matt Austern's C++ Standard Library Defect Report</a></li>\n<li><a href=\"https://stackoverflow.com/questions/760790/is-it-legal-to-write-to-stdstring/760900#760900\">previous SO answer</a></li>\n</ul>\n", "LastActivityDate": "2010-02-13T05:22:09.677", "LastEditorUserId": "-1", "Id": "2256521", "CommentCount": "0", "CreationDate": "2010-02-13T04:54:36.390", "ParentId": "2256160", "Score": "12", "OwnerUserId": "12711", "LastEditDate": "2017-05-23T12:09:29.737"}, "bq_ids": {"n4140": {"so_2256160_2256218_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 1566}}, "n3337": {"so_2256160_2256218_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 1561}}}, "2256847": {"PostTypeId": "2", "Body": "<p><strong>Edit:</strong> You want to call <code>&amp;buffer[0]</code>, <em>not</em> <code>buffer.data()</code>, because <code>[]</code> returns a non-<code>const</code> reference and <em>does</em> notify the object that its contents can change unexpectedly.</p>\n<hr>\n<p>It would be cleaner to do <code>buffer.data()</code>, but you should worry less about contiguous memory than memory shared between structures. <code>string</code> implementations can and do expect to be told when an object is being modified. <code>string::data</code> specifically requires that the program not modify the internal buffer returned.</p>\n<p>VERY high chances that some implementation will create one buffer for all strings uninitialized besides having length set to 10 or whatever.</p>\n<p>Use a <code>vector</code> or even an array with <code>new[]</code>/<code>delete[]</code>. If you really can't copy the buffer, legally initialize the string to something unique before changing it.</p>\n</hr>", "LastActivityDate": "2010-02-14T02:00:59.623", "LastEditorUserId": "153285", "Id": "2256847", "CommentCount": "10", "CreationDate": "2010-02-13T07:37:06.450", "ParentId": "2256160", "Score": "0", "OwnerUserId": "153285", "LastEditDate": "2010-02-14T02:00:59.623"}, "2256201": {"PostTypeId": "2", "Body": "<p>The result is undefined and I would not do it. The cost of reading into a vector and then converting to a string is trivial in modern c++ heaps. VS the risk that your code will die in windows 9</p>\n<p>also, doesnt that need a const_cast on &amp;buffer[0]?</p>\n", "LastActivityDate": "2010-02-13T02:07:06.443", "LastEditorUserId": "173397", "Id": "2256201", "CommentCount": "10", "CreationDate": "2010-02-13T02:01:06.077", "ParentId": "2256160", "Score": "0", "OwnerUserId": "173397", "LastEditDate": "2010-02-13T02:07:06.443"}, "2256160": {"ViewCount": "3169", "Body": "<p>I know that in C++03, technically the <code>std::basic_string</code> template is not required to have contiguous memory. However, I'm curious how many implementations exist for modern compilers that actually take advantage of this freedom. For example, if one wants to use <code>basic_string</code> to receive the results of some C API (like the example below), it seems silly to allocate a vector just to turn it into a string immediately.</p>\n<p>Example:</p>\n<pre><code>DWORD valueLength = 0;\nDWORD type;\nLONG errorCheck = RegQueryValueExW(\n        hWin32,\n        value.c_str(),\n        NULL,\n        &amp;type,\n        NULL,\n        &amp;valueLength);\n\nif (errorCheck != ERROR_SUCCESS)\n    WindowsApiException::Throw(errorCheck);\nelse if (valueLength == 0)\n    return std::wstring();\n\nstd::wstring buffer;\ndo\n{\n    buffer.resize(valueLength/sizeof(wchar_t));\n    errorCheck = RegQueryValueExW(\n            hWin32,\n            value.c_str(),\n            NULL,\n            &amp;type,\n            &amp;buffer[0],\n            &amp;valueLength);\n} while (errorCheck == ERROR_MORE_DATA);\n\nif (errorCheck != ERROR_SUCCESS)\n    WindowsApiException::Throw(errorCheck);\n\nreturn buffer;\n</code></pre>\n<p>I know code like this might slightly reduce portability because it implies that <code>std::wstring</code> is contiguous -- but I'm wondering just how unportable that makes this code. Put another way, how may compilers actually take advantage of the freedom having noncontiguous memory allows?</p>\n<hr>\n<p>EDIT: I updated this question to mention C++03. Readers should note that when targeting C++11, the standard now requires that <code>basic_string</code> be contiguous, so the above question is a non issue when targeting that standard.</p>\n</hr>", "AcceptedAnswerId": "2256218", "Title": "Is it reasonable to use std::basic_string<t> as a contiguous buffer when targeting C++03?", "CreationDate": "2010-02-13T01:36:10.667", "Id": "2256160", "CommentCount": "12", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2012-11-08T18:04:33.587", "LastEditorUserId": "82320", "LastActivityDate": "2012-11-08T18:04:33.587", "Score": "31", "OwnerUserId": "82320", "Tags": "<c++><string><winapi><stl><c++03>", "AnswerCount": "5"}});