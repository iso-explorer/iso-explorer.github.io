post_cb({"17419639": {"ViewCount": "1565", "Body": "<p>My question are located in my code comment:</p>\n<pre><code>int* a = new int[0];// I've expected the nullptr according to my logic...\nbool is_nullptr = !a; // I got 'false'\ndelete[] a; // Will I get the memory leaks, if I comment this row?\n</code></pre>\n<p>Thank you.</p>\n", "AcceptedAnswerId": "17419953", "Title": "memory allocation and 0 size: can I get the memory leaks?", "CreationDate": "2013-07-02T07:16:33.183", "Id": "17419639", "CommentCount": "12", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-07-02T09:17:44.407", "LastEditorUserId": "2020229", "LastActivityDate": "2013-07-02T12:19:34.470", "Score": "14", "OwnerUserId": "1306132", "Tags": "<c++><memory-leaks><new-operator>", "AnswerCount": "5"}, "17419953": {"Id": "17419953", "PostTypeId": "2", "Body": "<p>For C++11, and given your code:</p>\n<pre><code>int* a = new int[0];\n</code></pre>\n<p>Zero is a legal size, as per 5.3.4/7:</p>\n<blockquote>\n<p id=\"so_17419639_17419953_0\">When the value of the expression in a noptr-new-declarator is zero, the allocation function is called to\n  allocate an array with no elements.</p>\n</blockquote>\n<p>The operator invoked is as per 18.6.1.2 (emphasis mine): </p>\n<blockquote>\n<p id=\"so_17419639_17419953_1\">void* operator new[](std::size_t size);</p>\n<p id=\"so_17419639_17419953_2\">... </p>\n<p id=\"so_17419639_17419953_3\">3 Required behavior: Same <strong>as for operator new(std::size_t)</strong>. This requirement is binding on a replacement\n  version of this function.</p>\n<p id=\"so_17419639_17419953_4\">4 Default behavior: Returns operator new(size).</p>\n</blockquote>\n<p>...referencing 18.6.1.1...</p>\n<pre><code>void* operator new(std::size_t size);\n</code></pre>\n<blockquote>\n<p id=\"so_17419639_17419953_5\">3 Required behavior: Return a <strong>non-null</strong> pointer to suitably aligned storage (3.7.4), or else throw a bad_-\n  alloc exception. This requirement is binding on a replacement version of this function.</p>\n</blockquote>\n<p>So, the pointer returned must be non-null.</p>\n<p>You do need to <code>delete[]</code> it afterwards.</p>\n", "LastEditorUserId": "410767", "LastActivityDate": "2013-07-02T07:41:29.583", "Score": "16", "CreationDate": "2013-07-02T07:33:27.220", "ParentId": "17419639", "CommentCount": "3", "OwnerUserId": "410767", "LastEditDate": "2013-07-02T07:41:29.583"}, "17419926": {"Id": "17419926", "PostTypeId": "2", "Body": "<p>In C++03 <code>new int[0]</code> results in undefined behavior because the value between the <code>[]</code> must be a strictly positive value - zero is no good (5.3.4/6 \"New\").  So asking whether there's a memory leak afterwards is in a sense pointless.</p>\n<p>In C++11 <code>new int[0]</code> results in a call to the allocator to allocate a zero length array (5.3.4/7 \"New\"). If the allocation request succeeds, a pointer is returned - there's nothing in the standard that says how much memory the block pointed to by that pointer contains, other than it has to be at least the requested size.  However, it has at least the effect of allocating at least one character, because that address cannot be returned by the allocator again until it has been freed. In practice, the bookkeeping overhead will be more than one character.</p>\n", "LastEditorUserId": "701092", "LastActivityDate": "2013-07-02T12:19:34.470", "Score": "10", "CreationDate": "2013-07-02T07:31:46.083", "ParentId": "17419639", "CommentCount": "3", "OwnerUserId": "12711", "LastEditDate": "2013-07-02T12:19:34.470"}, "bq_ids": {"n4140": {"so_17419639_17419953_5": {"length": 14, "quality": 0.7, "section_id": 6814}, "so_17419639_17419953_1": {"length": 4, "quality": 1.0, "section_id": 6815}, "so_17419639_17419953_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 6088}, "so_17419639_17419953_3": {"length": 8, "quality": 0.7272727272727273, "section_id": 6838}}, "n3337": {"so_17419639_17419953_5": {"length": 14, "quality": 0.7, "section_id": 6569}, "so_17419639_17419953_1": {"length": 4, "quality": 1.0, "section_id": 6570}, "so_17419639_17419953_0": {"length": 11, "quality": 1.0, "section_id": 5856}, "so_17419639_17419953_3": {"length": 8, "quality": 0.7272727272727273, "section_id": 6588}}, "n4659": {"so_17419639_17419953_5": {"length": 12, "quality": 0.6, "section_id": 8306}, "so_17419639_17419953_1": {"length": 4, "quality": 1.0, "section_id": 8307}, "so_17419639_17419953_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 7584}}}, "17419660": {"Id": "17419660", "PostTypeId": "2", "Body": "<p>Yes, without <code>delete</code> there will be a memory leak.</p>\n<p>Every <code>new</code> has to be paired with <code>delete</code>. Even if the programmer-allocated size is 0. Allocator may allocate more memory than requested because of alignment requirements, management overhead or anything else.</p>\n", "LastEditorUserId": "426288", "LastActivityDate": "2013-07-02T07:24:21.017", "Score": "4", "CreationDate": "2013-07-02T07:17:45.803", "ParentId": "17419639", "CommentCount": "3", "OwnerUserId": "426288", "LastEditDate": "2013-07-02T07:24:21.017"}, "17419916": {"Id": "17419916", "PostTypeId": "2", "Body": "<p>Yes, there is a leak, and it is not implementation-dependent.</p>\n<p>This new expression cannot yield a null pointer.  It allocates memory by calling <code>operator new[]</code>, which is required to \"return a non-null pointer to suitably aligned storage, or else throw a <code>bad_alloc</code> exception\" (see C++11 \u00a718.6.1.1/3 and \u00a718.6.1.2/3).</p>\n<p>Further, the allocation function requirements (\u00a73.7.4.1) require that each call to an allocation function returns a pointer that is distinct from all other pointers that have been allocated but not yet deallocated.  Thus, the implementation cannot simply have a single \"empty allocation\" pointer that it always returns.</p>\n<p>This, every array-form new expression allocates <em>something</em>, even if the extent is zero.  If you don't deallocate that object via <code>delete[]</code>, you have leaked it.</p>\n", "LastActivityDate": "2013-07-02T07:31:02.677", "CommentCount": "0", "CreationDate": "2013-07-02T07:31:02.677", "ParentId": "17419639", "Score": "7", "OwnerUserId": "151292"}, "17419674": {"Id": "17419674", "PostTypeId": "2", "Body": "<p><strike>In this case it is <strong>implementation defined</strong> whether you will be returned a <code>nullptr</code> or not but</strike> you should be careful that you do not dereference this pointer also not calling <code>delete</code> will result in a Memory leak.      </p>\n<p>W.r.t to calling <code>delete</code> the rule is simple:<br>\n<strong><em>\"If you call <code>new</code> you must call <code>delete</code>.\"</em></strong></br></p>\n<p><sup><strong>Correction:</strong></sup><br>\nAs the citations in other answers have made clear, It cannot return you a <code>nullptr</code>.</br></p>\n", "LastEditorUserId": "452307", "LastActivityDate": "2013-07-02T08:31:20.437", "Score": "4", "CreationDate": "2013-07-02T07:18:24.973", "ParentId": "17419639", "CommentCount": "6", "OwnerUserId": "452307", "LastEditDate": "2013-07-02T08:31:20.437"}});