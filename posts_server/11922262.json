post_cb({"bq_ids": {"n4140": {"so_11922262_11922297_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 4384}, "so_11922262_11922297_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 4383}}, "n3337": {"so_11922262_11922297_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 4221}, "so_11922262_11922297_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 4220}}, "n4659": {"so_11922262_11922297_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 5646}, "so_11922262_11922297_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 5648}}}, "11922297": {"Id": "11922297", "PostTypeId": "2", "Body": "<p>Your code will not leak the <code>my_class</code> object, even if <code>shared_ptr</code> could not allocate memory.</p>\n<p>According to the C++11 standard (20.7.2.2.1), in the <code>shared_ptr</code> constructor:</p>\n<blockquote>\n<p id=\"so_11922262_11922297_0\">Throws: bad_alloc, or an implementation-de\ufb01ned exception when a resource other than memory\n  could not be obtained.</p>\n<p id=\"so_11922262_11922297_1\">Exception safety: If an exception is thrown, delete p is called.</p>\n</blockquote>\n<p>In the constructor version that takes a user-defined deleter, the deleter will be used instead.</p>\n<p><a href=\"http://www.boost.org/doc/libs/1_50_0/libs/smart_ptr/shared_ptr.htm#constructors\" rel=\"noreferrer\">Boost documentation</a> specifies the same.</p>\n", "LastActivityDate": "2012-08-12T12:47:34.277", "Score": "7", "CreationDate": "2012-08-12T12:47:34.277", "ParentId": "11922262", "CommentCount": "1", "OwnerUserId": "189205"}, "11922262": {"ViewCount": "941", "Body": "<p>If I understand correctly, when a shared_ptr (from boost, tr1, std, whatever) is initialised with a pointer to a freshly-allocated object, the shared_ptr's constructor allocates a small amount of memory to hold a reference count for the pointer it manages.  What happens if that allocation fails?  In the following code:</p>\n<pre><code>class my_class {};\nvoid my_func(shared_ptr&lt;my_class&gt; arg);\n\nint main(int argc, char* argv[])\n{\n    my_func(shared_ptr&lt;my_class&gt;(new my_class()));\n    return 0;\n}\n</code></pre>\n<p>...will the <code>my_class</code> object be leaked if the shared_ptr fails to allocate memory for its reference count?  Or does shared_ptr's constructor take responsibility for deleting the object?</p>\n", "AcceptedAnswerId": "11922297", "Title": "What happens if a shared_ptr's constructor fails?", "CreationDate": "2012-08-12T12:41:42.800", "Id": "11922262", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2012-08-12T12:47:34.277", "Score": "8", "OwnerUserId": "444486", "Tags": "<c++><memory-management><smart-pointers>", "AnswerCount": "1"}});