post_cb({"bq_ids": {"n4140": {"so_37326442_37326681_0": {"length": 5, "quality": 1.0, "section_id": 87}, "so_37326442_37326681_3": {"length": 7, "quality": 0.7, "section_id": 6185}}, "n3337": {"so_37326442_37326681_0": {"length": 5, "quality": 1.0, "section_id": 82}, "so_37326442_37326681_3": {"length": 10, "quality": 1.0, "section_id": 5946}}}, "37326442": {"ViewCount": "68", "Body": "<p>I have three pointers within a class, each of which are instantiation of a templated structure. I am trying to retrieve either of them using a get&lt;&gt;() method whose return type differs accordingly. </p>\n<pre><code>//Example program\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;boost/shared_ptr.hpp&gt;\n#include &lt;boost/variant.hpp&gt;\n#include &lt;boost/any.hpp&gt;\nclass CBase {};\nenum en {Aa = 1, Bb = 2, Cc = 3};\nclass A {\n    public: \n    template&lt;en dim&gt;\n    struct C : public CBase, boost::static_visitor&lt;CBase *&gt;{\n        int x;\n        C() {\n          x = dim;\n        }\n        template &lt;en t&gt;\n        CBase * operator()(C&lt;t&gt; *s) const {\n          return s;\n        }\n    };\n\n    C&lt;Aa&gt;* Aasd;\n    C&lt;Bb&gt;* Bbsd;\n    C&lt;Cc&gt;* Ccsd;\n    std::map&lt;en, boost::variant&lt;C&lt;Bb&gt; *, C&lt;Aa&gt; *, C&lt;Cc&gt; * &gt; &gt; matrices;    \n\n    A() {\n        Aasd = new C&lt;Aa&gt;;\n        Bbsd = new C&lt;Bb&gt;;\n        Ccsd = new C&lt;Cc&gt;;\n    matrices.insert(std::make_pair(Bb, Bbsd));\n    matrices.insert(std::make_pair(Aa, Aasd));\n    matrices.insert(std::make_pair(Cc, Ccsd));\n   }\n\n   template&lt;en tt&gt;\n    C&lt;tt&gt;* get() {\n     return static_cast&lt;C&lt;tt&gt; *&gt;(boost::apply_visitor(C&lt;tt&gt;(), matrices[tt]));   \n    }\n\n    ~A() {\n     delete Aasd;\n     delete Bbsd;\n     delete Ccsd;\n    }        \n};\n\n    template&lt;&gt;\n    A::C&lt;Aa&gt;* A::get&lt;Aa&gt;() {\n               return static_cast&lt;C&lt;Aa&gt; *&gt;(boost::apply_visitor(C&lt;Aa&gt;(), matrices[Aa]));\n    }\n\n    template&lt;&gt;\n    A::C&lt;Bb&gt;* A::get&lt;Bb&gt;() {\n               return static_cast&lt;C&lt;Bb&gt; *&gt;(boost::apply_visitor(C&lt;Bb&gt;(), matrices[Bb]));\n    }\n\n    template&lt;&gt;\n    A::C&lt;Cc&gt;* A::get&lt;Cc&gt;() {\n               return static_cast&lt;C&lt;Cc&gt; *&gt;(boost::apply_visitor(C&lt;Cc&gt;(), matrices[Cc]));\n    }\n\nint main()\n{    \n  A a;\n\n  int i = 0;\n  en samp = Aa;\n  std::cout&lt;&lt;a.get&lt;Aa&gt;()-&gt;x&lt;&lt;std::endl; // This runs fine\n  //std::cout&lt;&lt;a.get&lt;samp&gt;()-&gt;x&lt;&lt;std::endl; // This throws error: the value of 'samp' is not usable in a constant expression\n  return 0;\n}\n</code></pre>\n<p>I do understand that I need to specify a compile time constant to instantiate a template. However, in my case I would like to use a variable to retrieve either of the pointers. Any thoughts or suggestions on how to do that would be highly appreciated.</p>\n<p>EDIT:</p>\n<p>I am looking for alternate suggestions to retrieve the 'x' member of these 3 pointers Aasd, Bbsd, Ccsd as in the main function even if I have to completely remove the templates. It should be probably something like</p>\n<pre><code>en samp = Aa;\na.get(samp)-&gt;x = 6;\nsamp = Bb;\na.get(samp)-&gt;x = 5;\n</code></pre>\n<p>or </p>\n<pre><code>en samp = Aa;\na[samp]-&gt;x = 6;\nsamp = Bb;\na[samp]-&gt;x = 5;\n</code></pre>\n", "AcceptedAnswerId": "37327234", "Title": "Instantiating the templated function using variables", "CreationDate": "2016-05-19T14:33:50.040", "Id": "37326442", "CommentCount": "7", "LastEditDate": "2016-05-19T14:52:52.153", "PostTypeId": "1", "LastEditorUserId": "5953802", "LastActivityDate": "2016-05-20T12:11:51.253", "Score": "0", "OwnerUserId": "5953802", "Tags": "<c++><templates><const><template-specialization>", "AnswerCount": "2"}, "37326681": {"Id": "37326681", "PostTypeId": "2", "Body": "<p>Make <code>samp</code> constant:</p>\n<pre><code>const en samp;\n</code></pre>\n<p>EDIT: \nThere is <em>why</em> it works:</p>\n<p>Because </p>\n<p>Non-type Template argument has to be constant expression (known at compile time)</p>\n<p>proof:\nN3337 14.3.2/1</p>\n<blockquote>\n<p id=\"so_37326442_37326681_0\">A <strong>template-argument for a non-type</strong>, non-template <strong>template-parameter shall be one of</strong>:</p>\n<p id=\"so_37326442_37326681_1\">...</p>\n<ul>\n<li>for a <strong>non-type template-parameter</strong> of integral or <strong>enumeration type</strong>, a converted <strong>constant expression</strong> of the type of the template-parameter; or </li>\n</ul>\n<p id=\"so_37326442_37326681_2\">...</p>\n</blockquote>\n<p>And when is enumeration type variable constant expression?</p>\n<p>N3337 5.19/2:</p>\n<blockquote>\n<p id=\"so_37326442_37326681_3\">A conditional-expression is a core constant expression <strong>unless it involves one of the following</strong> as a potentially\n  evaluated subexpression</p>\n<p id=\"so_37326442_37326681_4\">...</p>\n<ul>\n<li>an lvalue-to-rvalue conversion (4.1) <strong>unless it is applied to</strong>\n<ul>\n<li>a glvalue of integral or <strong>enumeration type that refers to</strong> a non-volatile <strong>const object with a preceding\n  initialization</strong>, <strong>initialized with a constant expression</strong>, or</li>\n</ul></li>\n</ul>\n<p id=\"so_37326442_37326681_5\">...</p>\n</blockquote>\n<p>and because in case of:</p>\n<p><code>const en samp = Aa</code>,  <code>samp</code> refers to const object initialized with constant expression</p>\n", "LastEditorUserId": "4932834", "LastActivityDate": "2016-05-20T12:11:51.253", "CommentCount": "3", "CreationDate": "2016-05-19T14:44:21.910", "ParentId": "37326442", "Score": "1", "OwnerUserId": "4932834", "LastEditDate": "2016-05-20T12:11:51.253"}, "37327234": {"PostTypeId": "2", "Body": "<p>Move <code>x</code> into <code>CBase</code>, and then return <code>CBase *</code> from <code>get</code> instead of <code>C&lt;T&gt; *</code>. That will at least fix the problem with the return value, allowing the calling code to access <code>-&gt;x</code> easily.</p>\n<p>Then you can have a simple method something like this (untested):</p>\n<pre><code>CBase* A::get(en x) {\n    switch(x) {\n        break; case Aa: return this-&gt;get&lt;Aa&gt;();\n        break; case Bb: return this-&gt;get&lt;Bb&gt;();\n        break; case Cc: return this-&gt;get&lt;Cc&gt;();\n    }\n}\n</code></pre>\n", "LastActivityDate": "2016-05-19T15:05:54.557", "Id": "37327234", "CommentCount": "1", "CreationDate": "2016-05-19T15:05:54.557", "ParentId": "37326442", "Score": "0", "OwnerUserId": "146041"}});