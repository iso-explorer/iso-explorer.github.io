post_cb({"31771187": {"Id": "31771187", "PostTypeId": "2", "Body": "<p>Suppose you want to write a function taking all sorts of vectors.</p>\n<p>Then it is much more convenient being able to write</p>\n<pre><code>template &lt;class T, class A&gt;\nvoid f (std::vector &lt;T, A&gt; vec) {\n   // ...\n}\n</code></pre>\n<p>than having to write</p>\n<pre><code>template &lt;class T, template &lt;class&gt; class A&gt;\nvoid f (std::vector &lt;T, A&gt; vec) {\n   // ...\n}\n</code></pre>\n<p>In most of the cases, such a function does not care about the allocator anyway.</p>\n<p>Further note that allocators are not required to be a template. You could write separate classes for particular types that need to be allocated.</p>\n<p>An even more convenient way of designing allocators would probably have been</p>\n<pre><code>struct MyAllocator { \n   template &lt;class T&gt;\n   class Core {\n      // allocator code here\n   };\n};\n</code></pre>\n<p>Then it would have been possible to write</p>\n<pre><code>std::vector &lt;int, MyAllocator&gt; vec;\n</code></pre>\n<p>rather than the somewhat misleading expression</p>\n<pre><code>std::vector &lt;int, MyAllocator&lt;int&gt; &gt; vec;\n</code></pre>\n<p>I am not sure whether the above <code>MyAllocator</code> is permitted to be used as an allocator after adding a <code>rebind</code>, i.e. whether the following is a valid allocator class: </p>\n<pre><code>struct MyAllocator { \n   template &lt;class T&gt;\n   class Core {\n      // allocator code here\n   };\n\n   template &lt;class T&gt;\n   struct rebind { using other=Core&lt;T&gt;; };\n};\n</code></pre>\n", "LastEditorUserId": "1419315", "LastActivityDate": "2015-08-02T11:06:39.133", "Score": "0", "CreationDate": "2015-08-02T11:00:55.313", "ParentId": "12362363", "CommentCount": "1", "OwnerUserId": "1419315", "LastEditDate": "2015-08-02T11:06:39.133"}, "12362626": {"Id": "12362626", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_12362363_12362626_0\">But why is this necessary?</p>\n</blockquote>\n<p>What if your allocator class has more than one template argument?</p>\n<p>That's pretty much it in terms of why it is generally discouraged to use template template arguments, in favor of using normal template arguments, even if it means a bit of redundancy at the instantiation site. In many cases (however, probably not for allocators), that argument might not always be a class template (e.g., a normal class with template member functions).</p>\n<p>You might find it convenient (within the implementation of the container class) to use a template template parameter just because it simplifies some of the internal syntax. However, if the user has a multi-argument class template as an allocator he wants to use, but you require the user to provide an allocator which is a single-argument class template, you will in effect force him to create a wrapper for almost any new context in which he must use that allocator. This not only unscalable, it can also become very inconvenient to do. And, at this point, that solution is far from being the \"elegant and less redundant\" solution you originally thought it would be. Say you had an allocator with two arguments, which of the following is the easiest for the user?</p>\n<pre><code>std::vector&lt;T, my_allocator&lt;T,Arg2&gt; &gt; v1;\n\nstd::vector&lt;T, my_allocator_wrapper&lt;Arg2&gt;::template type &gt; v2;\n</code></pre>\n<p>You basically force the user to construct a lot of useless things (wrappers, template aliases, etc.) just to satisfy your implementation's demands. Requiring the author of a custom allocator class to supply a nested rebind template (which is just a trivial template alias) is far easier than all the contortions you require with the alternative approach.</p>\n", "LastEditorUserId": "491645", "LastActivityDate": "2012-09-11T04:25:35.687", "Score": "10", "CreationDate": "2012-09-11T04:07:42.177", "ParentId": "12362363", "CommentCount": "5", "OwnerUserId": "491645", "LastEditDate": "2012-09-11T04:25:35.687"}, "18682138": {"Id": "18682138", "PostTypeId": "2", "Body": "<p>A quoted text from <em><a href=\"http://rads.stackoverflow.com/amzn/click/1482353482\" rel=\"nofollow noreferrer\">Foundations of Algorithms in C++11</a></em>, Volume 1, chap 4, p. 35 :</p>\n<pre><code>template &lt;typename T&gt; \nstruct allocator \n{  \n   template &lt;typename U&gt;  \n   using  rebind = allocator&lt;U&gt;; \n}; \n</code></pre>\n<p>sample usage :</p>\n<pre><code>allocator&lt;int&gt;::rebind&lt;char&gt; x;\n</code></pre>\n<hr>\n<p>In <em>The C++ Programming Language</em>, 4th edition, section 34.4.1, p. 998, commenting the 'classical' rebind member in default allocator class :</p>\n<pre><code>template&lt;typename U&gt;\n     struct rebind { using other = allocator&lt;U&gt;;};\n</code></pre>\n<p>Bjarne Stroustrup writes this:</p>\n<blockquote>\n<p id=\"so_12362363_18682138_0\">The curious rebind template is an archaic alias. It should have been:</p>\n<pre><code>template&lt;typename U&gt;\nusing other = allocator&lt;U&gt;;\n</code></pre>\n<p id=\"so_12362363_18682138_1\">However, allocator was defined before such aliases were supported by C++.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "3980929", "LastActivityDate": "2017-07-08T08:01:10.083", "Score": "13", "CreationDate": "2013-09-08T09:12:44.107", "ParentId": "12362363", "CommentCount": "1", "OwnerUserId": "951155", "LastEditDate": "2017-07-08T08:01:10.083"}, "bq_ids": {"n4140": {"so_12362363_12362522_0": {"length": 55, "quality": 0.859375, "section_id": 6291}}, "n3337": {"so_12362363_12362522_0": {"length": 55, "quality": 0.859375, "section_id": 6051}}, "n4659": {"so_12362363_12362522_0": {"length": 55, "quality": 0.859375, "section_id": 7798}}}, "12362522": {"Id": "12362522", "PostTypeId": "2", "Body": "<p>In your approach you are forcing the allocator to be a template with a single parameter, which might not be always the case. In many cases, allocators can be non-template, and the nested <code>rebind</code> can return the same type of the allocator. In other cases the allocator can have extra template arguments. This second case is the case of  <code>std::allocator&lt;&gt;</code> which as all templates in the standard library is allowed to have extra template arguments as long as the implementation provides default values. Also note that the existence of <code>rebind</code> is optional in some cases, where <code>allocator_traits</code> can be used to obtain the rebound type.</p>\n<p>The standard actually mentions that the nested <code>rebind</code> is actually just a templated typedef:</p>\n<blockquote>\n<p id=\"so_12362363_12362522_0\">\u00a717.6.3.5/3\n   Note A: The member class template rebind in the table above is\n  effectively a typedef template. [ Note: In general, if the name\n  Allocator is bound to <code>SomeAllocator&lt;T&gt;</code>, then\n  <code>Allocator::rebind&lt;U&gt;::other</code> is the same type as <code>SomeAllocator&lt;U&gt;</code>,\n  where  <code>someAllocator&lt;T&gt;::value_type</code> is T and <code>SomeAllocator&lt;U&gt;::value_type</code> is U. \u2014 end note ] If Allocator is a class template\n  instantiation of the form <code>SomeAllocator&lt;T, Args&gt;</code>, where Args is zero\n  or more type arguments, and Allocator does not supply a rebind member\n  template, the standard allocator_traits template uses <code>SomeAllocator&lt;U, Args&gt;</code> in place of <code>Allocator:: rebind&lt;U&gt;::other</code> by default. For\n  allocator types that are not template instantiations of the above\n  form, no default is provided.</p>\n</blockquote>\n", "LastEditorUserId": "36565", "LastActivityDate": "2012-09-11T04:03:57.247", "Score": "4", "CreationDate": "2012-09-11T03:53:27.913", "ParentId": "12362363", "CommentCount": "16", "OwnerUserId": "36565", "LastEditDate": "2012-09-11T04:03:57.247"}, "12362363": {"ViewCount": "9480", "Body": "<p>Every allocator class must have an interface similar to the following:</p>\n<pre><code>template&lt;class T&gt;\nclass allocator\n{\n    ...\n    template&lt;class Other&gt;\n    struct rebind { typedef allocator&lt;Other&gt; other; };\n};\n</code></pre>\n<p>And classes that <em>use</em> allocators do something redundant like this:</p>\n<pre><code>template&lt;class T, class Alloc = std::allocator&lt;T&gt; &gt;\nclass vector { ... };\n</code></pre>\n<p>But why is this necessary?</p>\n<p>In other words, couldn't they have just said:</p>\n<pre><code>template&lt;class T&gt;\nclass allocator { ... };\n\ntemplate&lt;class T, template&lt;class&gt; class Alloc = std::allocator&gt;\nclass vector { ... };\n</code></pre>\n<p>which is both more elegant, less redundant, and (in some similar situations) potentially safer?<br>\nWhy did they go the <code>rebind</code> route, which also causes more redundancy (i.e. you have to say <code>T</code> twice)?</br></p>\n<p>(Similar question goes to <code>char_traits</code> and the rest... although they don't all have <code>rebind</code>, they could still benefit from template template parameters.)</p>\n<hr>\n<h3>Edit:</h3>\n<blockquote id=\"so_12362363_12362363_0\">\n<h3>But this won't work if you need more than 1 template parameter!</h3>\n</blockquote>\n<p>Actually, it works very well!</p>\n<pre><code>template&lt;unsigned int PoolSize&gt;\nstruct pool\n{\n    template&lt;class T&gt;\n    struct allocator\n    {\n        T pool[PoolSize];\n\n        ...\n    };\n};\n</code></pre>\n<p>Now if <code>vector</code> was only defined this way:</p>\n<pre><code>template&lt;class T, template&lt;class&gt; class Alloc&gt;\nclass vector { ... };\n</code></pre>\n<p>Then you could just say:</p>\n<pre><code>typedef vector&lt;int, pool&lt;1&gt;::allocator&gt; int_vector;\n</code></pre>\n<p>And it would work perfectly well, <em>without</em> needing you to (redundantly) say <code>int</code> twice.</p>\n<p>And a <code>rebind</code> operation inside <code>vector</code> would just become <code>Alloc&lt;Other&gt;</code> instead of <code>Alloc::template rebind&lt;Other&gt;::other</code>.</p>\n</hr>", "Title": "Why is allocator::rebind necessary when we have template template parameters?", "CreationDate": "2012-09-11T03:31:40.843", "LastActivityDate": "2017-07-08T08:01:10.083", "CommentCount": "5", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2012-09-11T04:27:41.103", "LastEditorUserId": "541686", "Id": "12362363", "Score": "17", "OwnerUserId": "541686", "Tags": "<c++><templates><allocator><template-templates>", "AnswerCount": "4"}});