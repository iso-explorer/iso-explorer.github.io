post_cb({"bq_ids": {"n4140": {"so_23804312_23806297_12": {"length": 8, "quality": 0.8888888888888888, "section_id": 638}, "so_23804312_23806297_1": {"length": 18, "quality": 0.75, "section_id": 603}, "so_23804312_23806297_9": {"length": 6, "quality": 1.0, "section_id": 147}, "so_23804312_23806297_5": {"length": 25, "quality": 0.8928571428571429, "section_id": 603}, "so_23804312_23806297_11": {"length": 15, "quality": 0.9375, "section_id": 624}, "so_23804312_23806297_10": {"length": 6, "quality": 1.0, "section_id": 147}, "so_23804312_23806297_4": {"length": 6, "quality": 0.75, "section_id": 603}, "so_23804312_23806297_7": {"length": 22, "quality": 0.9166666666666666, "section_id": 603}, "so_23804312_23806297_3": {"length": 18, "quality": 0.9, "section_id": 603}, "so_23804312_23806297_2": {"length": 31, "quality": 0.8611111111111112, "section_id": 603}}, "n3337": {"so_23804312_23806297_1": {"length": 18, "quality": 0.75, "section_id": 593}, "so_23804312_23806297_12": {"length": 8, "quality": 0.8888888888888888, "section_id": 628}, "so_23804312_23806297_5": {"length": 25, "quality": 0.8928571428571429, "section_id": 593}, "so_23804312_23806297_11": {"length": 15, "quality": 0.9375, "section_id": 614}, "so_23804312_23806297_10": {"length": 6, "quality": 1.0, "section_id": 141}, "so_23804312_23806297_9": {"length": 6, "quality": 1.0, "section_id": 141}, "so_23804312_23806297_2": {"length": 31, "quality": 0.8611111111111112, "section_id": 593}, "so_23804312_23806297_3": {"length": 18, "quality": 0.9, "section_id": 593}, "so_23804312_23806297_4": {"length": 6, "quality": 0.75, "section_id": 593}}, "n4659": {"so_23804312_23806297_1": {"length": 18, "quality": 0.75, "section_id": 629}, "so_23804312_23806297_12": {"length": 8, "quality": 0.8888888888888888, "section_id": 666}, "so_23804312_23806297_5": {"length": 25, "quality": 0.8928571428571429, "section_id": 629}, "so_23804312_23806297_11": {"length": 15, "quality": 0.9375, "section_id": 650}, "so_23804312_23806297_2": {"length": 31, "quality": 0.8611111111111112, "section_id": 629}, "so_23804312_23806297_10": {"length": 6, "quality": 1.0, "section_id": 151}, "so_23804312_23806297_9": {"length": 6, "quality": 1.0, "section_id": 151}, "so_23804312_23806297_7": {"length": 22, "quality": 0.9166666666666666, "section_id": 629}, "so_23804312_23806297_3": {"length": 18, "quality": 0.9, "section_id": 629}, "so_23804312_23806297_4": {"length": 6, "quality": 0.75, "section_id": 629}}}, "23805927": {"Id": "23805927", "PostTypeId": "2", "Body": "<p>That is surprising to me too.</p>\n<p>One workaround could be to pass an <code>int</code> (e.g <code>0</code>) as first argument to <code>check()</code> and force the compiler to <em>try</em> the template version <em>first</em>:</p>\n<pre><code>template&lt;typename... T, typename = decltype(f(std::declval&lt;T&gt;()...))&gt;\nstd::true_type check(int &amp;&amp;, T &amp;&amp;...); //ADDED `int &amp;&amp;` as the first parameter type\n\nstd::false_type check(...);\n\ntemplate&lt;typename... T&gt; using Predicate = decltype(check(0, std::declval&lt;T&gt;()...));\n</code></pre>\n<p>Note that the temporary created out of <code>0</code> would try to bind to <code>int&amp;&amp;</code> <strong>first</strong> (and that is very crucial here), then if the value-sfinae fails, then it would try the second overload.</p>\n<ul>\n<li><a href=\"http://coliru.stacked-crooked.com/a/1803d5fe673d6c68\" rel=\"nofollow\">Demo @ Coliru</a> </li>\n</ul>\n<p>Hope that helps.</p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2014-05-22T11:52:26.740", "Score": "4", "CreationDate": "2014-05-22T11:46:02.440", "ParentId": "23804312", "CommentCount": "4", "OwnerUserId": "415784", "LastEditDate": "2014-05-22T11:52:26.740"}, "23804312": {"ViewCount": "1395", "Body": "<p>I'm using the following SFINAE pattern to evaluate a predicate on a variadic type list:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nvoid f(int = 0);  // for example\n\ntemplate&lt;typename... T,\n    typename = decltype(f(std::declval&lt;T&gt;()...))&gt;\nstd::true_type check(T &amp;&amp;...);\nstd::false_type check(...);\n\ntemplate&lt;typename... T&gt; using Predicate = decltype(check(std::declval&lt;T&gt;()...));\n\nstatic_assert(!Predicate&lt;int, int&gt;::value, \"!!\");\nstatic_assert( Predicate&lt;int&gt;::value, \"!!\");\nstatic_assert( Predicate&lt;&gt;::value, \"!!\");  // fails\n\nint main() {\n}\n</code></pre>\n<p>To my surprise, the ellipsis overload is selected when <code>check</code> is called with an empty argument list, so <code>Predicate&lt;&gt;</code> is <code>std::false_type</code> even when the SFINAE-expression is valid!</p>\n<p>Shouldn't variadic function templates always be preferred to ellipsis functions?</p>\n<p>Are there any workarounds?</p>\n", "AcceptedAnswerId": "23806297", "Title": "Why is an ellipsis preferred to a variadic template when called with no arguments?", "CreationDate": "2014-05-22T10:31:50.933", "Id": "23804312", "CommentCount": "6", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2014-05-22T19:08:12.083", "LastEditorUserId": "3043539", "LastActivityDate": "2014-09-17T14:47:07.047", "Score": "15", "OwnerUserId": "567292", "Tags": "<c++><templates><c++11><variadic-templates><sfinae>", "AnswerCount": "2"}, "23806297": {"Id": "23806297", "PostTypeId": "2", "Body": "<p>When <code>T...</code> is empty, the compiler performs overload resolution to determine which of</p>\n<pre><code>std::true_type check(); // instantiated from the function template\nstd::false_type check(...);\n</code></pre>\n<p>is the best viable candidate, as described in [over.match.best] 13.3.3/1 (quoting N3936):</p>\n<blockquote>\n<p id=\"so_23804312_23806297_0\">Define ICSi(F) as follows:</p>\n<ul>\n<li><p id=\"so_23804312_23806297_1\">if F is a static member function, ICS1 (F) is defined such that ICS1 (F) is neither better nor worse than ICS1 (G) for any function G, and, symmetrically, ICS1 (G) is neither better nor worse than ICS1 (F)132; otherwise,</p></li>\n<li><p id=\"so_23804312_23806297_2\">let ICSi(F) denote the implicit conversion sequence that converts the i-th argument in the list to the type of the i-th parameter of viable function F. 13.3.3.1 defines the implicit conversion sequences and 13.3.3.2 defines what it means for one implicit conversion sequence to be a better conversion sequence or worse conversion sequence than another.</p></li>\n</ul>\n<p id=\"so_23804312_23806297_3\">Given these definitions, a viable function F1 is defined to be a better function than another viable function F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</p>\n<ul>\n<li><p id=\"so_23804312_23806297_4\">for some argument j, ICSj(F1) is a better conversion sequence than ICSj(F2), or, if not that,</p></li>\n<li><p id=\"so_23804312_23806297_5\">the context is an initialization by user-defined conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the standard conversion sequence from the return type of F1 to the destination type (i.e., the type of the entity being initialized) is a better conversion sequence than the standard conversion sequence from the return type of F2 to the destination type. [ <em>Example:</em></p>\n<pre><code>struct A {\n  A();\n  operator int();\n  operator double();\n} a;\nint i = a; // a.operator int() followed by no conversion\n// is better than a.operator double() followed by\n// a conversion to int\nfloat x = a; // ambiguous: both possibilities require conversions,\n// and neither is better than the other\n</code></pre>\n<p id=\"so_23804312_23806297_6\">\u2014<em>end example</em> ] or, if not that,</p></li>\n<li><p id=\"so_23804312_23806297_7\">the context is an initialization by conversion function for direct reference binding (13.3.1.6) of a reference to function type, the return type of F1 is the same kind of reference (i.e. lvalue or rvalue) as the reference being initialized, and the return type of F2 is not [ <em>Example:</em></p>\n<pre><code>template &lt;class T&gt; struct A {\n  operator T&amp;(); // #1\n  operator T&amp;&amp;(); // #2\n};\ntypedef int Fn();\nA&lt;Fn&gt; a;\nFn&amp; lf = a; // calls #1\nFn&amp;&amp; rf = a; // calls #2\n</code></pre>\n<p id=\"so_23804312_23806297_8\">\u2014<em>end example</em> ] or, if not that,</p></li>\n<li><p id=\"so_23804312_23806297_9\">F1 is not a function template specialization and F2 is a function template specialization, or, if not that,</p></li>\n<li>F1 and F2 are function template specializations, and the function template for F1 is more specialized than the template for F2 according to the partial ordering rules described in 14.5.6.2.</li>\n</ul>\n</blockquote>\n<p>In this case, the conversion sequences for both candidates are empty since there are no arguments. The second to last bullet is the deciding factor:</p>\n<blockquote id=\"so_23804312_23806297_10\">\n<ul>\n<li>F1 is not a function template specialization and F2 is a function template specialization, or, if not that,</li>\n</ul>\n</blockquote>\n<p>hence the non-template <code>std::false_type check(...);</code> is preferred.</p>\n<hr>\n<p>My preferred workaround - obviously there are many - would be to make both candidates templates and discriminate via the ellipsis conversion [over.ics.ellipsis] 13.3.3.1.3/1:</p>\n<blockquote>\n<p id=\"so_23804312_23806297_11\">An ellipsis conversion sequence occurs when an argument in a function call is matched with the ellipsis parameter specification of the function called (see 5.2.2).</p>\n</blockquote>\n<p>by giving the \"preferred\" template declaration an extraneous parameter that is a clearly better match, since any other conversion sequence will be preferred to an ellipsis conversion per [over.ics.rank] 13.3.3.2/2:</p>\n<blockquote>\n<p id=\"so_23804312_23806297_12\">When comparing the basic forms of implicit conversion sequences (as defined in 13.3.3.1)</p>\n<ul>\n<li>a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than a user-defined conversion sequence or an ellipsis conversion sequence, and</li>\n<li>a user-defined conversion sequence (13.3.3.1.2) is a better conversion sequence than an ellipsis conversion sequence (13.3.3.1.3).</li>\n</ul>\n</blockquote>\n<p><a href=\"http://coliru.stacked-crooked.com/a/77bf9b05e3ce89fa\" rel=\"nofollow\" title=\"Live at Coliru\">Example</a>:</p>\n<pre><code>template&lt;typename... T,\n    typename = decltype(f(std::declval&lt;T&gt;()...))&gt;\nstd::true_type check(int);\ntemplate&lt;typename...&gt;\nstd::false_type check(...);\n\ntemplate&lt;typename... T&gt; using Predicate = decltype(check&lt;T...&gt;(0));\n</code></pre>\n</hr>", "LastEditorUserId": "923854", "LastActivityDate": "2014-09-17T14:47:07.047", "Score": "15", "CreationDate": "2014-05-22T12:02:52.663", "ParentId": "23804312", "CommentCount": "5", "OwnerUserId": "923854", "LastEditDate": "2014-09-17T14:47:07.047"}});