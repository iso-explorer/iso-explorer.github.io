post_cb({"27679651": {"ParentId": "27679567", "CommentCount": "0", "Body": "<p>Private members are intentionally considered for overload resolution.</p>\n<p>Suppose you have</p>\n<pre><code>class C {\npublic:\n  static void f(int);\n  static void g();\nprivate:\n  static void f(long);\n};\n\nvoid C::g() {\n  f(0L); // okay\n}\nvoid g() {\n  f(0L); // error, does not silently call f(int)\n}\n</code></pre>\n<p>Making only public members available during overload resolution causes highly surprising re-interpretations of code, where code that looks like it should work the exact same way would silently call different overloads.</p>\n<p>Making such code an error was considered less troublesome than the alternative.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "27679651", "Score": "1", "CreationDate": "2014-12-28T19:04:26.153", "LastActivityDate": "2014-12-28T19:04:26.153"}, "27679661": {"ParentId": "27679567", "CommentCount": "0", "Body": "<p>To help compiler you can do this</p>\n<pre><code> struct C : public A, private B\n {\n      using A::num;\n };\n</code></pre>\n", "OwnerUserId": "205955", "PostTypeId": "2", "Id": "27679661", "Score": "3", "CreationDate": "2014-12-28T19:05:03.193", "LastActivityDate": "2014-12-28T19:05:03.193"}, "27679640": {"ParentId": "27679567", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Yes it is specified in the C++ Standard, section \u00a73.4 [basic.lookup]</p>\n<blockquote>\n<p id=\"so_27679567_27679640_0\">The access rules (Clause 11) are considered only once name lookup and function overload resolution (if applicable) have succeeded</p>\n</blockquote>\n<p>Name lookup doesn't care about accessibility : it finds both <code>A::num</code> and <code>B::num</code>, so there is an ambiguity for the compiler.</p>\n<p>You can explicitly call <code>A::num</code> with :</p>\n<pre><code>C::A::num();\n</code></pre>\n<p>If you explicitly try to call <code>B::num</code>, then your compiler will indeed emit an access error :</p>\n<pre><code>C::B::num(); // Error\n</code></pre>\n<p>You can also explicitly bring the base name into scope within the derived class, which will fix the ambiguity :</p>\n<pre><code>struct C : public A, private B\n{\n    using A::num;    \n};\n</code></pre>\n", "OwnerUserId": "3510483", "LastEditorUserId": "3510483", "LastEditDate": "2014-12-28T19:37:15.610", "Id": "27679640", "Score": "6", "CreationDate": "2014-12-28T19:03:42.677", "LastActivityDate": "2014-12-28T19:37:15.610"}, "27679567": {"CommentCount": "1", "AcceptedAnswerId": "27679640", "PostTypeId": "1", "LastEditorUserId": "557391", "CreationDate": "2014-12-28T18:56:35.710", "LastActivityDate": "2014-12-28T19:37:15.610", "LastEditDate": "2014-12-28T19:33:36.163", "ViewCount": "321", "FavoriteCount": "1", "Title": "Why doesn't private inheritance resolve ambiguity for static functions ? (tested in MSVC)", "Id": "27679567", "Score": "5", "Body": "<p>I'm wondering why a call to a static function is ambiguous, even when one of the two is obviously impossible to call as it is private.\nI was hoping I could use private / protected inheritance to help the compiler solve the ambiguity.</p>\n<p>Is it specific to MSVC or is it somehow specified in the standard ?</p>\n<pre><code>struct A\n{\n    static int num() { return 0; }\n};\n\nstruct B\n{\n    static int num() { return 1; }\n};\n\nstruct C : public A, private B\n{};\n\nint main()\n{\n     C::num(); // Ambiguous access of num\n}\n</code></pre>\n<p>The background is that I was trying a way of reusing an overloading behavior (the one in A) in many derived classes (C,D,E,F,G) by inheriting it, to adhere somehow to a rule of Don't Repeat Yourself.</p>\n", "Tags": "<c++><static-methods><ambiguous-call><private-inheritance>", "OwnerUserId": "557391", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_27679567_27679640_0": {"section_id": 7083, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_27679567_27679640_0": {"section_id": 6827, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_27679567_27679640_0": {"section_id": 8584, "quality": 0.9230769230769231, "length": 12}}}});