post_cb({"bq_ids": {"n4140": {"so_27679567_27679640_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 7083}}, "n3337": {"so_27679567_27679640_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 6827}}, "n4659": {"so_27679567_27679640_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 8584}}}, "27679661": {"Id": "27679661", "PostTypeId": "2", "Body": "<p>To help compiler you can do this</p>\n<pre><code> struct C : public A, private B\n {\n      using A::num;\n };\n</code></pre>\n", "LastActivityDate": "2014-12-28T19:05:03.193", "CommentCount": "0", "CreationDate": "2014-12-28T19:05:03.193", "ParentId": "27679567", "Score": "3", "OwnerUserId": "205955"}, "27679651": {"Id": "27679651", "PostTypeId": "2", "Body": "<p>Private members are intentionally considered for overload resolution.</p>\n<p>Suppose you have</p>\n<pre><code>class C {\npublic:\n  static void f(int);\n  static void g();\nprivate:\n  static void f(long);\n};\n\nvoid C::g() {\n  f(0L); // okay\n}\nvoid g() {\n  f(0L); // error, does not silently call f(int)\n}\n</code></pre>\n<p>Making only public members available during overload resolution causes highly surprising re-interpretations of code, where code that looks like it should work the exact same way would silently call different overloads.</p>\n<p>Making such code an error was considered less troublesome than the alternative.</p>\n", "LastActivityDate": "2014-12-28T19:04:26.153", "CommentCount": "0", "CreationDate": "2014-12-28T19:04:26.153", "ParentId": "27679567", "Score": "1", "OwnerUserId": "743382"}, "27679567": {"ViewCount": "321", "Body": "<p>I'm wondering why a call to a static function is ambiguous, even when one of the two is obviously impossible to call as it is private.\nI was hoping I could use private / protected inheritance to help the compiler solve the ambiguity.</p>\n<p>Is it specific to MSVC or is it somehow specified in the standard ?</p>\n<pre><code>struct A\n{\n    static int num() { return 0; }\n};\n\nstruct B\n{\n    static int num() { return 1; }\n};\n\nstruct C : public A, private B\n{};\n\nint main()\n{\n     C::num(); // Ambiguous access of num\n}\n</code></pre>\n<p>The background is that I was trying a way of reusing an overloading behavior (the one in A) in many derived classes (C,D,E,F,G) by inheriting it, to adhere somehow to a rule of Don't Repeat Yourself.</p>\n", "AcceptedAnswerId": "27679640", "Title": "Why doesn't private inheritance resolve ambiguity for static functions ? (tested in MSVC)", "CreationDate": "2014-12-28T18:56:35.710", "Id": "27679567", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-12-28T19:33:36.163", "LastEditorUserId": "557391", "LastActivityDate": "2014-12-28T19:37:15.610", "Score": "5", "OwnerUserId": "557391", "Tags": "<c++><static-methods><ambiguous-call><private-inheritance>", "AnswerCount": "3"}, "27679640": {"Id": "27679640", "PostTypeId": "2", "Body": "<p>Yes it is specified in the C++ Standard, section \u00a73.4 [basic.lookup]</p>\n<blockquote>\n<p id=\"so_27679567_27679640_0\">The access rules (Clause 11) are considered only once name lookup and function overload resolution (if applicable) have succeeded</p>\n</blockquote>\n<p>Name lookup doesn't care about accessibility : it finds both <code>A::num</code> and <code>B::num</code>, so there is an ambiguity for the compiler.</p>\n<p>You can explicitly call <code>A::num</code> with :</p>\n<pre><code>C::A::num();\n</code></pre>\n<p>If you explicitly try to call <code>B::num</code>, then your compiler will indeed emit an access error :</p>\n<pre><code>C::B::num(); // Error\n</code></pre>\n<p>You can also explicitly bring the base name into scope within the derived class, which will fix the ambiguity :</p>\n<pre><code>struct C : public A, private B\n{\n    using A::num;    \n};\n</code></pre>\n", "LastEditorUserId": "3510483", "LastActivityDate": "2014-12-28T19:37:15.610", "Score": "6", "CreationDate": "2014-12-28T19:03:42.677", "ParentId": "27679567", "CommentCount": "3", "OwnerUserId": "3510483", "LastEditDate": "2014-12-28T19:37:15.610"}});