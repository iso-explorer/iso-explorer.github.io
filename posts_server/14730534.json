post_cb({"bq_ids": {"n4140": {"so_14730534_14730687_1": {"length": 10, "quality": 1.0, "section_id": 6066}, "so_14730534_14730687_2": {"length": 17, "quality": 1.0, "section_id": 5942}, "so_14730534_14731279_1": {"length": 5, "quality": 1.0, "section_id": 6185}, "so_14730534_14731279_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 7194}, "so_14730534_14731279_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 7194}, "so_14730534_14731285_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 7193}, "so_14730534_14731279_2": {"length": 10, "quality": 1.0, "section_id": 7194}, "so_14730534_14731285_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 5768}, "so_14730534_14731279_0": {"length": 51, "quality": 0.9272727272727272, "section_id": 7194}, "so_14730534_14730687_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 5768}, "so_14730534_14731285_0": {"length": 27, "quality": 0.9, "section_id": 7191}}, "n3337": {"so_14730534_14731279_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 359}, "so_14730534_14730687_2": {"length": 17, "quality": 1.0, "section_id": 5713}, "so_14730534_14731279_1": {"length": 5, "quality": 1.0, "section_id": 5946}, "so_14730534_14731279_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 6938}, "so_14730534_14730687_1": {"length": 10, "quality": 1.0, "section_id": 5834}, "so_14730534_14731285_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 6937}, "so_14730534_14731279_2": {"length": 10, "quality": 1.0, "section_id": 6938}, "so_14730534_14731285_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 5541}, "so_14730534_14731279_0": {"length": 51, "quality": 0.9272727272727272, "section_id": 6938}, "so_14730534_14730687_0": {"length": 14, "quality": 1.0, "section_id": 5}, "so_14730534_14731285_0": {"length": 27, "quality": 0.9, "section_id": 6935}}, "n4659": {"so_14730534_14731279_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 8703}, "so_14730534_14730687_2": {"length": 17, "quality": 1.0, "section_id": 7426}, "so_14730534_14731279_1": {"length": 5, "quality": 1.0, "section_id": 7687}, "so_14730534_14731279_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 8703}, "so_14730534_14730687_1": {"length": 10, "quality": 1.0, "section_id": 7562}, "so_14730534_14731285_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 8702}, "so_14730534_14731279_2": {"length": 9, "quality": 0.9, "section_id": 8702}, "so_14730534_14731285_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 7225}, "so_14730534_14731279_0": {"length": 51, "quality": 0.9272727272727272, "section_id": 8703}, "so_14730534_14730687_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 7225}, "so_14730534_14731285_0": {"length": 27, "quality": 0.9, "section_id": 8700}}}, "14731285": {"Id": "14731285", "PostTypeId": "2", "Body": "<p>First off, very interesting question.</p>\n<p>I would say it is undefined behaviour, assuming \"dangling reference\" means \"referred-to object's lifetime has ended and the storage the object occupied <em>has</em> been reused or released.\" I base my reasoning on the following standard rulings:</p>\n<p>3.8 \u00a73:</p>\n<blockquote>\n<p id=\"so_14730534_14731285_0\">The properties ascribed to objects throughout this International Standard apply for a given object only\n  during its lifetime. [ Note: In particular, before the lifetime of an object starts and after its lifetime ends\n  there are significant restrictions on the use of the object, as described below ...]</p>\n</blockquote>\n<p>All the cases \"as described below\" refer to</p>\n<blockquote>\n<p id=\"so_14730534_14731285_1\">Before the lifetime of an object has started but after the storage which the object will occupy has been\n  allocated38 or, after the lifetime of an object has ended and before the storage which the object occupied is\n  reused or released</p>\n</blockquote>\n<p>1.3.24:\n<strong>undefined behavior</strong></p>\n<blockquote>\n<p id=\"so_14730534_14731285_2\">behavior for which this International Standard imposes no requirements\n  [ Note: Undefined behavior may be expected when this International Standard omits any explicit definition of\n  behavior or when a program uses an erroneous construct or erroneous data. ...]</p>\n</blockquote>\n<p>I apply the following train of thoughts to the above quotes:</p>\n<ol>\n<li>If the standard doesn't describe behaviour for a situation, the behvaiour is undefined.</li>\n<li>The standard only describes behvaiour for objects within their lifetime, and a few special cases near the start/end of their lifetime. None of these apply to our dangling reference.</li>\n<li>Therefore, using the danling reference in any way has no behaviour prescribed by the standard, hence the behaviour is undefined.</li>\n</ol>\n", "LastActivityDate": "2013-02-06T14:19:35.777", "CommentCount": "0", "CreationDate": "2013-02-06T14:19:35.777", "ParentId": "14730534", "Score": "4", "OwnerUserId": "1782465"}, "14730687": {"Id": "14730687", "PostTypeId": "2", "Body": "<p>What makes the use of an invalid object (reference, pointer, whatever) undefined behaviour is lvalue-to-rvalue conversion (\u00a74.1):</p>\n<blockquote>\n<p id=\"so_14730534_14730687_0\">If the object to which the glvalue refers is not an object of type T and is not an object of a type derived from T, or if the object is uninitialized, a program that necessitates this conversion has undefined behavior.</p>\n</blockquote>\n<p>Assuming we haven't overloaded <code>operator&amp;</code>, the unary <code>&amp;</code> operator takes an lvalue as its operand, so no conversion occurs. Having just an identifier, as in <code>x;</code> also requires no conversion. You will only get undefined behaviour when the reference is used as an operand in an expression that expects that operand to be an rvalue - which is the case for most operators. The point is, doing <code>&amp;x</code> doesn't actually require accessing the value of <code>x</code>. Lvalue-to-rvalue conversion occurs with those operators that need to access its value.</p>\n<p>I believe your code is well defined.</p>\n<p>When <code>operator&amp;</code> has been overloaded, the expression <code>&amp;x</code> is transformed into a function call and does not obey the rules of the built-in operators - instead it follows the rules of a function call. For <code>&amp;x</code>, the translation to function call results in either <code>x.operator&amp;()</code> or <code>operator&amp;(x)</code>. In the first case, lvalue-to-rvalue conversion will occur on <code>x</code> when the class member access operator is used. In the second case, the argument of <code>operator&amp;</code> will be copy-initialised with <code>x</code> (as in <code>T arg = x</code>), and the behaviour of this depends on the type of the argument. For example, in the case of the argument being an lvalue reference, there is no undefined behaviour because lvalue-to-rvalue conversion does not occur.</p>\n<p>So if <code>operator&amp;</code> is overloaded for the type of <code>x</code>, the code may or may not be well-defined, depending on the calling of the <code>operator&amp;</code> function.</p>\n<p>You could argue that the unary <code>&amp;</code> operator relies on there being at least some valid region of storage that you have the address of:</p>\n<blockquote>\n<p id=\"so_14730534_14730687_1\">Otherwise, if the type of the expression is <code>T</code>, the result has type \"pointer to <code>T</code>\" and is a prvalue that is the address of the designated object</p>\n</blockquote>\n<p>And an object is defined as being a region of storage. After the object that is referred to is destroyed, that region of storage no longer exists.</p>\n<p>I prefer to believe that it will only result in undefined behaviour if the invalid object is actually accessed. The reference still believes it's referring to some object and it can happily give the address of it even if it doesn't exist. However, this seems to be an ill-specified part of the standard.</p>\n<hr>\n<h3>Aside</h3>\n<p>As an example of undefined behaviour, consider <code>x + x</code>. Now we hit another ill-specified part of the standard. The value category of the operands of <code>+</code> are not specified. It is generally inferred from \u00a75/8 that if it is not specified, then it expects a prvalue:</p>\n<blockquote>\n<p id=\"so_14730534_14730687_2\">Whenever a glvalue expression appears as an operand of an operator that expects a prvalue for that operand, the lvalue-to-rvalue (4.1), array-to-pointer (4.2), or function-to-pointer (4.3) standard conversions are applied to convert the expression to a prvalue.</p>\n</blockquote>\n<p>Now because <code>x</code> is an lvalue, the lvalue-to-rvalue conversion is required and we get undefined behaviour. This makes sense because addition requires accessing the value of <code>x</code> so it can work out the result.</p>\n</hr>", "LastEditorUserId": "150634", "LastActivityDate": "2013-02-06T14:44:27.943", "Score": "4", "CreationDate": "2013-02-06T13:49:43.060", "ParentId": "14730534", "CommentCount": "8", "OwnerUserId": "150634", "LastEditDate": "2013-02-06T14:44:27.943"}, "14730534": {"ViewCount": "578", "Body": "<p>Assume a dangling reference <code>x</code>. Is it undefined behavior to just write</p>\n<pre><code>&amp;x;\n</code></pre>\n<p>or even</p>\n<pre><code>x;\n</code></pre>\n<p>?</p>\n", "Title": "Dangling references and undefined behavior", "CreationDate": "2013-02-06T13:41:22.063", "LastActivityDate": "2013-02-06T14:44:27.943", "CommentCount": "16", "FavoriteCount": "4", "PostTypeId": "1", "Id": "14730534", "Score": "12", "OwnerUserId": "673730", "Tags": "<c++><reference><undefined-behavior><language-lawyer>", "AnswerCount": "3"}, "14731279": {"Id": "14731279", "PostTypeId": "2", "Body": "<p>Supposing that <code>x</code> was initialized with a valid object, which was then destroyed, \u00a73.8/6 applies:</p>\n<blockquote>\n<p id=\"so_14730534_14731279_0\">Similarly, before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any glvalue that refers to the original object may be used but only in limited ways. For an object under construction or destruction, see 12.7. Otherwise, such a glvalue refers to allocated storage (3.7.4.2), and <strong>using the properties of the glvalue that do not depend on its value is well-defined.</strong> The program has undefined behavior if:</p>\n<p id=\"so_14730534_14731279_1\">\u2014 an lvalue-to-rvalue conversion (4.1) is applied to such a glvalue,</p>\n<p id=\"so_14730534_14731279_2\">\u2014 the glvalue is used to access a non-static data member or call a non-static member function of the\n  object, or</p>\n<p id=\"so_14730534_14731279_3\">\u2014 the glvalue is bound to a reference to a virtual base class (8.5.3), or</p>\n<p id=\"so_14730534_14731279_4\">\u2014 the glvalue is used as the operand of a dynamic_cast (5.2.7) or as the operand of typeid.</p>\n</blockquote>\n<p>So, simply taking the address is well-defined, and (referring to the neighboring paragraphs) can even be productively used to create a new object in place of the old one.</p>\n<p>As for <em>not</em> taking the address and just writing <code>x</code>, that really does absolutely nothing, and it is a proper subexpression of <code>&amp;x</code>. So it's also OK.</p>\n", "LastActivityDate": "2013-02-06T14:19:20.300", "CommentCount": "4", "CreationDate": "2013-02-06T14:19:20.300", "ParentId": "14730534", "Score": "3", "OwnerUserId": "153285"}});