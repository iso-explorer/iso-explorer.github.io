post_cb({"bq_ids": {"n4140": {"so_47443172_47443409_0": {"length": 19, "quality": 0.95, "section_id": 653}, "so_47443172_47443373_0": {"length": 51, "quality": 0.9622641509433962, "section_id": 584}}, "n3337": {"so_47443172_47443409_0": {"length": 20, "quality": 1.0, "section_id": 643}, "so_47443172_47443373_0": {"length": 51, "quality": 0.9622641509433962, "section_id": 574}}, "n4659": {"so_47443172_47443409_0": {"length": 19, "quality": 0.95, "section_id": 681}, "so_47443172_47443373_0": {"length": 51, "quality": 0.9622641509433962, "section_id": 607}}}, "47443361": {"Id": "47443361", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_47443172_47443361_0\">For example, is it legal to implement the following operator in the default namespace or a user-defined namespace:</p>\n<pre><code>std::string operator+(const std::string&amp; s, int right) { ... }\n</code></pre>\n</blockquote>\n<p>Yes, it's perfectly legal to do this. The only restrictions are about adding names to <code>namespace std</code> or specializing member function function templates or class templates or adding deduction guides for class templates in <code>std</code>. </p>\n<p>There's nothing that stops you from writing something like:</p>\n<pre><code>namespace N {\n    std::string operator+(std::string s, int ) { return s; }\n}\n</code></pre>\n<p>That is a well-formed program, per the standard. However note that since by definition your operators will not have any program-defined types in them, they will never be found by ADL. Since they are operators, which typically are found by ADL, this in of itself may be a reason to avoid such a pattern:</p>\n<pre><code>namespace U {\n    auto foo() {\n        return \"hello\"s + 1; // error: name lookup doesn't find our operator\n    }\n\n    auto bar() {\n        using namespace N;\n        return \"hello\"s + 1; // ok: for some definition of ok\n    }\n}\n</code></pre>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-11-22T20:41:17.333", "Score": "2", "CreationDate": "2017-11-22T20:26:21.827", "ParentId": "47443172", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2017-11-22T20:41:17.333"}, "47443373": {"Id": "47443373", "PostTypeId": "2", "Body": "<p>It is legal to write that. But it won't necessarily do what you want.</p>\n<p>If your goal is to make <code>some_string + 4</code> legal C++ code, then its legality will depend on exactly where that expression appears. Operator overloading will use ADL to look up the operator [over.match.oper]/3.2:</p>\n<blockquote>\n<p id=\"so_47443172_47443373_0\">The set of non-member candidates is the result of the unqualified lookup of operator@ in the context of the expression according to the usual rules for name lookup in unqualified function calls (6.4.2) except that all member functions are ignored. However, if no operand has a class type, only those non-member\n  functions in the lookup set that have a first parameter of type T1 or \u201creference to cv T1 \u201d, when T1 is an enumeration type, or (if there is a right operand) a second parameter of type T2 or \u201creference to cv T2\u201d, when T2 is an enumeration type, are candidate functions.</p>\n</blockquote>\n<p>But since your <code>operator+</code> is <em>not</em> in the same namespace as either argument, ADL lookup will fail. And the list of non-member candidates will not automatically include global functions, there's no chance for it to find the right <code>operator+</code>.</p>\n<p>So you cannot <em>effectively</em> overload an operator like this without opening up the namespace. Which of course is forbidden for <code>std</code>.</p>\n", "LastActivityDate": "2017-11-22T20:27:41.033", "CommentCount": "5", "CreationDate": "2017-11-22T20:27:41.033", "ParentId": "47443172", "Score": "2", "OwnerUserId": "734069"}, "47443172": {"ViewCount": "71", "Body": "<p>Is it allowed to overload operators, such as <code>operator+</code> for a combination of a standard library type and a built-in type, when such an overload doesn't exist?</p>\n<p>For example, is it legal to implement the following operator in the default namespace or a user-defined namespace:</p>\n<pre><code>std::string operator+(const std::string&amp; s, int right) { ... }\n</code></pre>\n<p>I know there are various restrictions about implementing things <em>in</em> the <code>std::</code> namespace, but it isn't clear to me if there is any rule against the above (whether it's a good idea is of course an entirely different matter!).</p>\n", "AcceptedAnswerId": "47443361", "Title": "Is it allowed to overload operator+ for a standard library type and a built-in type?", "CreationDate": "2017-11-22T20:12:19.390", "Id": "47443172", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-11-24T07:01:25.913", "LastEditorUserId": "963864", "LastActivityDate": "2017-11-24T07:01:25.913", "Score": "3", "OwnerUserId": "149138", "Tags": "<c++><operator-overloading><language-lawyer><user-defined-types>", "AnswerCount": "3"}, "47443409": {"Id": "47443409", "PostTypeId": "2", "Body": "<p>It's perfectly OK to overload <code>operator+</code> between <code>std::string</code> and <code>int</code>. The only restriction that the standard places on that is (<a href=\"https://timsong-cpp.github.io/cppwp/n3337/over.oper#6\" rel=\"nofollow noreferrer\">https://timsong-cpp.github.io/cppwp/n3337/over.oper#6</a>):</p>\n<blockquote>\n<p id=\"so_47443172_47443409_0\">An operator function shall either be a non-static member function or be a non-member function and have at least one parameter whose type is a class, a reference to a class, an enumeration, or a reference to an enumeration.</p>\n</blockquote>\n<p>There is no restriction on the being able to define them in your namespace for even the types from the standard library.</p>\n", "LastActivityDate": "2017-11-22T20:29:53.163", "CommentCount": "4", "CreationDate": "2017-11-22T20:29:53.163", "ParentId": "47443172", "Score": "3", "OwnerUserId": "434551"}});