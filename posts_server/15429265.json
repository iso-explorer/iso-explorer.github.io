post_cb({"15429265": {"CommentCount": "0", "ViewCount": "90", "CreationDate": "2013-03-15T09:55:48.277", "LastActivityDate": "2013-03-15T10:04:49.147", "Title": "How C++ determine arguments of overloaded operators?", "AcceptedAnswerId": "15429303", "PostTypeId": "1", "Id": "15429265", "Score": "1", "Body": "<p>I have overloaded I/O operators:</p>\n<pre><code>struct Time {\n  int hours;\n  int minutes;\n};\n\nostream &amp;operator &lt;&lt; ( ostream &amp;os, Time &amp;t ) {\n  os &lt;&lt; setfill('0') &lt;&lt; setw( 2 ) &lt;&lt; t.hours;\n  os &lt;&lt; \":\";\n  os &lt;&lt; setfill('0') &lt;&lt; setw( 2 ) &lt;&lt; t.minutes;\n  return os;\n}\n\nistream &amp;operator &gt;&gt; ( istream &amp;is, Time &amp;t ) { \n  is &gt;&gt; t.hours;\n  is.ignore(1, ':');\n  is &gt;&gt; t.minutes;\n  return is;\n}\n</code></pre>\n<p>I want to know when I call <code>cin &gt;&gt; time</code> how compiler determine <code>is &amp;is</code> argument. here is my <code>main()</code> program:</p>\n<pre><code>operator&gt;&gt;( cin, time );\ncout &lt;&lt; time &lt;&lt; endl;\n\ncin &gt;&gt; (cin , time);\ncout &lt;&lt; time &lt;&lt; endl;\n\ncin &gt;&gt; time;                     //Where is cin argument???\ncout &lt;&lt; time &lt;&lt; endl;\n</code></pre>\n", "Tags": "<c++><arguments><operator-overloading><istream><ostream>", "OwnerUserId": "225052", "AnswerCount": "1"}, "15429303": {"ParentId": "15429265", "PostTypeId": "2", "CommentCount": "2", "Body": "<pre><code>cin &gt;&gt; time;\n</code></pre>\n<p>This is operator <code>&gt;&gt;</code> with two operands. If the overloaded operator function is found as a non-member, then the left operand becomes the first argument and the right operand becomes the second argument. So it becomes:</p>\n<pre><code>operator&gt;&gt;(cin, time);\n</code></pre>\n<p>So the <code>cin</code> argument is just the first operand to the operator.</p>\n<p>See \u00a713.5.2 of the standard:</p>\n<blockquote>\n<p id=\"so_15429265_15429303_0\">A binary operator shall be implemented either by a non-static member function (9.3) with one parameter or by a non-member function with two parameters. Thus, for any binary operator <code>@</code>, <code>x@y</code> can be interpreted as either <code>x.operator@(y)</code> or <code>operator@(x,y)</code>.</p>\n</blockquote>\n<p>If you're wondering how this applies to chained operators, take this:</p>\n<pre><code>cin &gt;&gt; time &gt;&gt; something;\n</code></pre>\n<p>This is equivalent to:</p>\n<pre><code>(cin &gt;&gt; time) &gt;&gt; something;\n</code></pre>\n<p>Which is also equivalent to:</p>\n<pre><code>operator&gt;&gt;(operator&gt;&gt;(cin, time), something);\n</code></pre>\n", "OwnerUserId": "150634", "LastEditorUserId": "924727", "LastEditDate": "2013-03-15T10:04:49.147", "Id": "15429303", "Score": "4", "CreationDate": "2013-03-15T09:57:15.137", "LastActivityDate": "2013-03-15T10:04:49.147"}, "bq_ids": {"n4140": {"so_15429265_15429303_0": {"section_id": 659, "quality": 0.9523809523809523, "length": 20}}, "n3337": {"so_15429265_15429303_0": {"section_id": 649, "quality": 0.9523809523809523, "length": 20}}, "n4659": {"so_15429265_15429303_0": {"section_id": 687, "quality": 0.9523809523809523, "length": 20}}}});