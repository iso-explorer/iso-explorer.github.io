post_cb({"25828064": {"ParentId": "25825867", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_25825867_25828064_0\">Why is this an ambiguous situation?</p>\n</blockquote>\n<p>According to \u00a713.3.3/1, </p>\n<blockquote>\n<p id=\"so_25825867_25828064_1\">Given these definitions, a viable function <code>F1</code> is defined to be a\n  <em>better</em> function than another viable function <code>F2</code> <strong>if for all arguments <em>i</em>, ICS <em>i</em> (<code>F1</code>) is not a worse conversion sequence than\n  ICS <em>i</em> (<code>F2</code>)</strong>, and then</p>\n<p id=\"so_25825867_25828064_2\">\u2014 for some argument <em>j</em>, ICS <em>j</em> (<code>F1</code>) is a better conversion\n  sequence than ICS <em>j</em> (<code>F2</code>), or, if not that,</p>\n<p id=\"so_25825867_25828064_3\">\u2014 [...]</p>\n</blockquote>\n<p>Therefore a call like <code>function(0., 0., 0.)</code> is ambiguous; Neither of the overloads is a better match than the other.</p>\n<p>Consider template argument deduction from a function call - if a template parameter <code>T</code> is used in several function parameters (like <code>T a, T b, T c</code>) and for two of the arguments of the call it is deduced as <code>int</code>, but for the third one as <code>double</code>, should that really result in a successful deduction with <code>T=int</code>?</p>\n<p>Overload resolution doesn't count the better matches and calls the winner - that wouldn't be decisive enough. </p>\n<p>Imagine a jigsaw puzzle - is a piece really a better match for a gap if it fills in better at two ends but worse on another one?</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2014-09-13T21:58:33.260", "Id": "25828064", "Score": "2", "CreationDate": "2014-09-13T21:51:07.970", "LastActivityDate": "2014-09-13T21:58:33.260"}, "bq_ids": {"n4140": {"so_25825867_25828064_1": {"section_id": 603, "quality": 0.95, "length": 19}, "so_25825867_25828064_2": {"section_id": 603, "quality": 0.875, "length": 7}}, "n3337": {"so_25825867_25828064_1": {"section_id": 593, "quality": 0.95, "length": 19}, "so_25825867_25828064_2": {"section_id": 593, "quality": 0.875, "length": 7}}, "n4659": {"so_25825867_25828064_1": {"section_id": 629, "quality": 0.95, "length": 19}, "so_25825867_25828064_2": {"section_id": 629, "quality": 0.875, "length": 7}}}, "25825867": {"CommentCount": "1", "AcceptedAnswerId": "25828064", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2014-09-13T17:40:13.613", "LastActivityDate": "2016-03-17T10:37:40.437", "LastEditDate": "2016-03-17T10:37:40.437", "ViewCount": "123", "FavoriteCount": "0", "Title": "implicit conversion sequence in function overloading", "Id": "25825867", "Score": "3", "Body": "<p>I don't understand how the compiler chooses the best candidates.\nFor example, let's have the following code:</p>\n<pre><code>int function(double, int, int){...}\nint function(int, double, double){...}\n</code></pre>\n<p>If the second function needs to convert two variables and the first one has to only convert one variable, how come the first one isn't chosen?\nWhy is this an ambiguous situation?</p>\n", "Tags": "<c++><function><overloading><language-lawyer><ambiguous>", "OwnerUserId": "2341994", "AnswerCount": "1"}});