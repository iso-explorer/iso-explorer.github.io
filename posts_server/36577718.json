post_cb({"36578031": {"ParentId": "36577718", "LastEditDate": "2016-04-13T05:13:48.887", "CommentCount": "2", "CreationDate": "2016-04-12T15:40:44.467", "Score": "5", "LastEditorUserId": "3980929", "PostTypeId": "2", "Id": "36578031", "OwnerUserId": "3980929", "Body": "<p><code>typeid</code> ignores all cv-qualifiers:</p>\n<blockquote>\n<p id=\"so_36577718_36578031_0\">In all cases, cv-qualifiers are ignored by typeid (that is, typeid(T)==typeid(const T))</p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/typeid\" rel=\"nofollow\">(ref)</a></p>\n<p>This means that <code>typeid</code> ignores all references <code>&amp;</code> and <code>const</code> (to name a few).</p>\n<pre><code>int i = 0;\nconst int&amp;&amp; j = 1;\n\nif (typeid(i).hash_code() == typeid(j).hash_code()) //returns true\n    std::cout &lt;&lt; \"typeid(int) == typeid(const int&amp;&amp;)\";\n</code></pre>\n<p>Note that to compare 2 <code>typeid</code>s, you have to use either <code>typeid(T).hash_code()</code> or <code>std::type_index(typeid(T))</code>, because only for those 2 functions is it guaranteed that 2 same <code>typeid</code>s will be the same. Comparing references doesn't have that guarantee for example.</p>\n<blockquote>\n<p id=\"so_36577718_36578031_1\">There is no guarantee that the same std::type_info instance will be referred to by all evaluations of the typeid expression on the same type, although std::type_info::hash_code of those type_info objects would be identical, as would be their std::type_index.</p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/typeid\" rel=\"nofollow\">(ref)</a>\n<hr>\nAs, @Yakk mentioned, you can use <code>std::remove_reference</code> and <code>std::remove_cv</code> to get the behavior you wanted.</hr></p>\n<p><code>std::remove_reference</code> removes all references of T and <code>std::remove_cv</code> removes all <code>const</code> and <code>volatile</code> qualifiers. You should pass <code>T</code> through these functions before passing them to <code>std::is_same</code>, so that <code>std::is_same</code> only compares the underlying type (if any) of <code>T1</code> and <code>T2</code>.</p>\n", "LastActivityDate": "2016-04-13T05:13:48.887"}, "36577718": {"CommentCount": "10", "ViewCount": "697", "PostTypeId": "1", "LastEditorUserId": "3980929", "CreationDate": "2016-04-12T15:27:33.363", "LastActivityDate": "2016-09-06T15:06:09.827", "Title": "Same typeid name but not std::is_same", "LastEditDate": "2016-09-06T15:06:09.827", "Id": "36577718", "Score": "15", "Body": "<p>Using C++ (gcc 4.8.3) I have 2 types (<code>T1</code> and <code>T2</code>) which have the strange property that <code>typeid(T1).name()</code> and <code>typeid(T2).name()</code> are the same but\n<code>std::is_same&lt;T1, T2&gt;::value</code> is <code>false</code>.</p>\n<p>How can that be? How can I investigate further to tell what the reason might be ?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "3046585", "AnswerCount": "2"}, "36578069": {"ParentId": "36577718", "LastEditDate": "2016-04-13T18:48:01.063", "CommentCount": "0", "CreationDate": "2016-04-12T15:42:27.363", "Score": "11", "LastEditorUserId": "2069064", "PostTypeId": "2", "Id": "36578069", "OwnerUserId": "2069064", "Body": "<p>Ignoring polymorphism, <code>typeid()</code> gives you an object representing the static type of the expression. But there are certain elements that are ignored when it comes to expression types. From [expr]:</p>\n<blockquote>\n<p id=\"so_36577718_36578069_0\">If an expression initially has the type \u201creference to <code>T</code>\u201d (8.3.2, 8.5.3), the type is adjusted to <code>T</code> prior to\n  any further analysis. [...] If a prvalue initially has the type \u201c<em>cv</em> <code>T</code>\u201d, where <code>T</code> is a <em>cv</em>-unqualified non-class, non-array type, the type of\n  the expression is adjusted to <code>T</code> prior to any further analysis.</p>\n</blockquote>\n<p>As a result, any types which differ only in top-level <em>cv</em>-qualification or reference will yield the same typeid. For instance, the types <code>int</code>, <code>const int</code>, <code>int&amp;</code> <code>volatile const int&amp;&amp;</code>, etc all give you the same <code>typeid()</code>.</p>\n<p>Basically, your initial thought process was: </p>\n<pre><code>typeid(T) == typeid(U) &lt;==&gt; std::is_same&lt;T, U&gt;\n</code></pre>\n<p>But the correct equivalence is:</p>\n<pre><code>typeid(T) == typeid(U) &lt;==&gt; std::is_same&lt;expr_type&lt;T&gt;, expr_type&lt;U&gt;&gt;\n</code></pre>\n<p>where:</p>\n<pre><code>template &lt;class T&gt;\nusing expr_type = std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;;\n</code></pre>\n", "LastActivityDate": "2016-04-13T18:48:01.063"}, "bq_ids": {"n4140": {"so_36577718_36578069_0": {"section_id": 5939, "quality": 0.56, "length": 14}}, "n4659": {"so_36577718_36578069_0": {"section_id": 7423, "quality": 0.56, "length": 14}}}});