post_cb({"941922": {"ParentId": "941832", "CommentCount": "1", "Body": "<p>Deleting a void pointer is dangerous because destructors will not be called on the value it actually points to.  This can result in memory / resource leaks in your application. </p>\n", "OwnerUserId": "23283", "PostTypeId": "2", "Id": "941922", "Score": "13", "CreationDate": "2009-06-02T21:05:14.913", "LastActivityDate": "2009-06-02T21:05:14.913"}, "28259234": {"ParentId": "941832", "CommentCount": "0", "Body": "<p>For the particular case of char.</p>\n<p>char is an intrinsic type that does not have a special destructor. So the leaks arguments is a moot one.</p>\n<p>sizeof(char) is usually one so there is no alignment argument either. In the case of rare platform where the sizeof(char) is not one, they allocate memory aligned enough for their char. So the alignment argument is also a moot one.</p>\n<p>malloc/free would be faster on this case. But you forfeit std::bad_alloc and have to check the result of malloc. Calling the global new and delete operators might be better as it bypass the middle man.</p>\n", "OwnerUserId": "322631", "PostTypeId": "2", "Id": "28259234", "Score": "0", "CreationDate": "2015-02-01T03:47:02.647", "LastActivityDate": "2015-02-01T03:47:02.647"}, "941959": {"ParentId": "941832", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Deleting via a void pointer is undefined by the C++ Standard - see section 5.3.5/3:</p>\n<blockquote>\n<p id=\"so_941832_941959_0\">In the first alternative (delete\n  object), if the static type of the\n  operand is different from its dynamic\n  type, the static type shall be a base\n  class of the operand\u2019s dynamic type\n  and the static type shall have a\n  virtual destructor or the behavior is\n  undefined.  In the second alternative\n  (delete array) if the dynamic type of\n  the object to be deleted differs from\n  its static type, the behavior is\n  undefined.</p>\n</blockquote>\n<p>And its footnote:</p>\n<blockquote>\n<p id=\"so_941832_941959_1\">This implies that an object cannot be\n  deleted using a pointer of type void*\n  because there are no objects of type\n  void</p>\n</blockquote>\n<p>.</p>\n", "Id": "941959", "LastEditDate": "2009-06-03T14:56:03.580", "OwnerDisplayName": "anon", "Score": "115", "CreationDate": "2009-06-02T21:15:21.350", "LastActivityDate": "2009-06-03T14:56:03.580", "LastEditorDisplayName": "anon"}, "941953": {"ParentId": "941832", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>It depends on \"safe.\"  It will usually work because information is stored along with the pointer about the allocation itself, so the deallocator can return it to the right place.  In this sense it is \"safe\" as long as your allocator uses internal boundary tags. (Many do.)  </p>\n<p>However, as mentioned above, deleting a void pointer will not call destructors, which can be a problem.  In that sense, it is not \"safe.\"</p>\n<p>There is no good reason to do what you are doing the way you are doing it.  If you want to write your own deallocation functions, you can use function templates to generate functions with the correct type.  A good reason to do that is to generate pool allocators, which can be extremely efficient for specific types. </p>\n", "OwnerUserId": "116154", "LastEditorUserId": "116154", "LastEditDate": "2013-08-07T17:40:15.023", "Id": "941953", "Score": "16", "CreationDate": "2009-06-02T21:14:17.780", "LastActivityDate": "2013-08-07T17:40:15.023"}, "bq_ids": {"n4140": {"so_941832_941959_1": {"section_id": 6105, "quality": 0.7857142857142857, "length": 11}, "so_941832_941959_0": {"section_id": 6107, "quality": 0.8974358974358975, "length": 35}}, "n3337": {"so_941832_941959_1": {"section_id": 5871, "quality": 0.7142857142857143, "length": 10}, "so_941832_941959_0": {"section_id": 5873, "quality": 0.8974358974358975, "length": 35}}, "n4659": {"so_941832_941959_1": {"section_id": 7602, "quality": 0.7857142857142857, "length": 11}, "so_941832_941959_0": {"section_id": 7604, "quality": 0.8974358974358975, "length": 35}}}, "949090": {"ParentId": "941832", "CommentCount": "1", "Body": "<p>If you really must do this, why not cut out the middle man (the <code>new</code> and <code>delete</code> operators) and call the global <code>operator new</code> and <code>operator delete</code> directly? (Of course, if you're trying to instrument the <code>new</code> and <code>delete</code> operators, you actually ought to reimplement <code>operator new</code> and <code>operator delete</code>.)</p>\n<pre><code>void* my_alloc (size_t size)\n{\n   return ::operator new(size);\n}\n\nvoid my_free (void* ptr)\n{\n   ::operator delete(ptr);\n}\n</code></pre>\n<p>Note that unlike <code>malloc()</code>, <code>operator new</code> throws <code>std::bad_alloc</code> on failure (or calls the <code>new_handler</code> if one is registered).</p>\n", "OwnerUserId": "8090", "PostTypeId": "2", "Id": "949090", "Score": "5", "CreationDate": "2009-06-04T07:34:10.523", "LastActivityDate": "2009-06-04T07:34:10.523"}, "941857": {"ParentId": "941832", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>It's not a good idea and not something you would do in C++.  You are losing your type info for no reason.</p>\n<p>Your destructor won't be called on the objects in your array that you are deleting when you call it for non primitive types. </p>\n<p><strong>You should instead override new/delete.</strong> </p>\n<p>Deleting the void* will probably free your memory correctly by chance, but it's wrong because the results are undefined.</p>\n<p>If for some reason unknown to me you need to store your pointer in a void* then free it, you should use malloc and free.  </p>\n", "OwnerUserId": "3153", "LastEditorUserId": "3153", "LastEditDate": "2009-06-02T21:17:41.847", "Id": "941857", "Score": "23", "CreationDate": "2009-06-02T20:52:22.927", "LastActivityDate": "2009-06-02T21:17:41.847"}, "16409797": {"ParentId": "941832", "CommentCount": "0", "Body": "<p>There is hardly a reason to do this.</p>\n<p>First of all, if you don't know the <strong>type</strong> of the data, and all you know is that it's <code>void*</code>, then you really should just be treating that data as a typeless <strong>blob</strong> of binary data (<code>unsigned char*</code>), and use <code>malloc</code>/<code>free</code> to deal with it.  This is required sometimes for things like waveform data and the like, where you need to pass around <code>void*</code> pointers to C apis. That's fine.</p>\n<p>If you <strong>do</strong> know the type of the data (ie it has a ctor/dtor), but for some reason you ended up with a <code>void*</code> pointer (for whatever reason you have) <strong>then you really should cast it back to the type you know it to be</strong>, and call <code>delete</code> on it.</p>\n", "OwnerUserId": "111307", "PostTypeId": "2", "Id": "16409797", "Score": "0", "CreationDate": "2013-05-07T01:25:55.193", "LastActivityDate": "2013-05-07T01:25:55.193"}, "941933": {"ParentId": "941832", "CommentCount": "0", "Body": "<p>Because char has no special destructor logic. THIS won't work.</p>\n<pre><code>class foo\n{\n   ~foo() { printf(\"huzza\"); }\n}\n\nmain()\n{\n   foo * myFoo = new foo();\n   delete ((void*)foo);\n}\n</code></pre>\n<p>The d'ctor won't get called.</p>\n", "Id": "941933", "PostTypeId": "2", "OwnerDisplayName": "radu", "Score": "5", "CreationDate": "2009-06-02T21:07:57.873", "LastActivityDate": "2009-06-02T21:07:57.873"}, "20927932": {"ParentId": "941832", "CommentCount": "0", "Body": "<p>I have used void*, (aka unknown types) in my framework for while in code reflection and other feats of ambiguity, and so far, I have had no troubles (memory leak, access violations, etc.) from any compilers.  Only warnings due to the operation being non-standard. </p>\n<p>It perfectly makes sense to delete an unknown (void*). Just make sure the pointer follows these guidelines, or it may stop making sense:</p>\n<p>1) The unknown pointer must not point to a type that has a trivial deconstructor, and so when casted as an unknown pointer it should NEVER BE DELETED.  Only delete the unknown pointer AFTER casting it back into the ORIGINAL type.</p>\n<p>2) Is the instance being referenced as an unknown pointer in stack bound or heap bound memory?  If the unknown pointer references an instance on the stack, then it should NEVER BE DELETED!</p>\n<p>3) Are you 100% positive the unknown pointer is a valid memory region?  No, then it should NEVER BE DELTED!</p>\n<p>In all, there is very little direct work that can be done using an unknown (void*) pointer type.  However, indirectly, the void* is a great asset for C++ developers to rely on when data ambiguity is required.</p>\n", "OwnerUserId": "230194", "PostTypeId": "2", "Id": "20927932", "Score": "0", "CreationDate": "2014-01-04T23:17:05.937", "LastActivityDate": "2014-01-04T23:17:05.937"}, "944780": {"ParentId": "941832", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>If you just want a buffer, use malloc/free. \nIf you must use new/delete, consider a trivial wrapper class:</p>\n<pre><code>template&lt;int size_ &gt; struct size_buffer { \n  char data_[ size_]; \n  operator void*() { return (void*)&amp;data_; }\n};\n\ntypedef sized_buffer&lt;100&gt; OpaqueBuffer; // logical description of your sized buffer\n\nOpaqueBuffer* ptr = new OpaqueBuffer();\n\ndelete ptr;\n</code></pre>\n", "OwnerUserId": "9353", "LastEditorUserId": "9353", "LastEditDate": "2014-03-13T14:59:43.183", "Id": "944780", "Score": "0", "CreationDate": "2009-06-03T13:32:56.803", "LastActivityDate": "2014-03-13T14:59:43.183"}, "942022": {"ParentId": "941832", "CommentCount": "3", "Body": "<p>If you want to use void*, why don't you use just malloc/free? new/delete is more than just memory managing. Basically, new/delete calls a constructor/destructor and there are more things going on. If you just use built-in types (like char*) and delete them through void*, it would work but still it's not recommended. The bottom line is use malloc/free if you want to use void*. Otherwise, you can use template functions for your convenience.</p>\n<pre><code>template&lt;typename T&gt;\nT* my_alloc (size_t size)\n{\n   return new T [size];\n}\n\ntemplate&lt;typename T&gt;\nvoid my_free (T* ptr)\n{\n   delete [] ptr;\n}\n\nint main(void)\n{\n    char* pChar = my_alloc&lt;char&gt;(10);\n    my_free(pChar);\n}\n</code></pre>\n", "OwnerUserId": "115325", "PostTypeId": "2", "Id": "942022", "Score": "4", "CreationDate": "2009-06-02T21:33:07.620", "LastActivityDate": "2009-06-02T21:33:07.620"}, "941832": {"CommentCount": "10", "AcceptedAnswerId": "941953", "CreationDate": "2009-06-02T20:47:47.100", "LastActivityDate": "2016-07-25T20:58:54.330", "PostTypeId": "1", "ViewCount": "41147", "FavoriteCount": "20", "Title": "Is it safe to delete a void pointer?", "Id": "941832", "Score": "71", "Body": "<p>Suppose I have the following code:</p>\n<pre><code>void* my_alloc (size_t size)\n{\n   return new char [size];\n}\n\nvoid my_free (void* ptr)\n{\n   delete [] ptr;\n}\n</code></pre>\n<p>Is this safe?  Or must <code>ptr</code> be cast to <code>char*</code> prior to deletion?</p>\n", "Tags": "<c++><memory-management><casting><void-pointers>", "OwnerUserId": "17035", "AnswerCount": "13"}, "18683731": {"ParentId": "941832", "CommentCount": "8", "Body": "<p>The question makes no sense. Your confusion may be partly due to the sloppy language people often use with <code>delete</code>:</p>\n<p>You use <code>delete</code> to destroy an <strong>object</strong> that was dynamically allocated. Do do so, you form a <em>delete expression</em> with a <em>pointer to that object</em>.  You never \"delete a pointer\". What you really do is \"delete an object which is identified by its address\".</p>\n<p>Now we see why the question makes no sense: A void pointer isn't the \"address of an object\". It's just an address, without any semantics. It <em>may</em> have come from the address of an actual object, but that information is lost, because it was encoded in the <em>type</em> of the original pointer. The only way to restore an object pointer is to cast the void pointer back to an object pointer (which requires the author to know what the pointer means). <code>void</code> itself is an incomplete type and thus never the type of an object, and a void pointer can never be used to identify an object. (Objects are identified jointly by their type and their address.)</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "18683731", "Score": "4", "CreationDate": "2013-09-08T12:35:14.440", "LastActivityDate": "2013-09-08T12:35:14.440"}, "941951": {"ParentId": "941832", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>A lot of people have already commented saying that no, it's not safe to delete a void pointer.  I agree with that, but I also wanted to add that if you're working with void pointers in order to allocate contiguous arrays or something similar, that you can do this with <code>new</code> so that you'll be able to use <code>delete</code> safely (with, ahem, a little of extra work).  This is done by allocating a void pointer to the memory region (called an 'arena') and then supplying the pointer to the arena to new.  See this section in the <a href=\"https://isocpp.org/wiki/faq/dtors#memory-pools\" rel=\"nofollow noreferrer\">C++ FAQ</a>.  This is a common approach to implementing memory pools in C++.</p>\n", "OwnerUserId": "73274", "LastEditorUserId": "2850543", "LastEditDate": "2016-07-25T20:58:54.330", "Id": "941951", "Score": "5", "CreationDate": "2009-06-02T21:14:11.433", "LastActivityDate": "2016-07-25T20:58:54.330"}});