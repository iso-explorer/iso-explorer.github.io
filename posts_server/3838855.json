post_cb({"bq_ids": {"n4140": {"so_3838855_39605164_2": {"length": 21, "quality": 1.0, "section_id": 6142}, "so_3838855_3839447_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 6143}}, "n3337": {"so_3838855_39605164_2": {"length": 21, "quality": 1.0, "section_id": 5906}, "so_3838855_3839447_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 5907}}, "n4659": {"so_3838855_39605164_2": {"length": 11, "quality": 0.5238095238095238, "section_id": 7638}}}, "39605164": {"Id": "39605164", "PostTypeId": "2", "Body": "<p>The correct answers have been given years ago, but I find it interesting that the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf\" rel=\"nofollow\">C99 rationale</a> [sec. 6.5.6, last 3 paragraphs] explains why the standard endorses adding <code>1</code> to a pointer that points to the last element of an array (<code>p+1</code>):</p>\n<blockquote>\n<p id=\"so_3838855_39605164_0\">An important endorsement of widespread practice is the requirement that a pointer can always be incremented to just past the end of an array, with no fear of overflow or wraparound</p>\n</blockquote>\n<p>and why <code>p-1</code> is not endorsed:</p>\n<blockquote>\n<p id=\"so_3838855_39605164_1\">In the case of p-1, on the other hand, an entire object would have to be allocated prior to the array of objects that p traverses, so decrement loops that run off the bottom of an array can fail. This restriction allows segmented architectures, for instance, to place objects at the start of a range of addressable memory.</p>\n</blockquote>\n<p>So if the pointer <code>p</code> points to an object at the start of a range of addressable memory, which is endorsed by this comment, then <code>p-1</code> would generate an underflow.</p>\n<p>Note that integer overflow is the standard's example for undefined behavior [sec. 3.4.3], as it depends on the translation environment and the operating environment. I believe it is easy to see that this dependence on the environment extends to pointer underflow.</p>\n<p>This is why the standard explicitly makes it undefined behavior [in 6.5.6/8], as noted by other answers here. To cite that sentence:</p>\n<blockquote>\n<p id=\"so_3838855_39605164_2\">If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>See also [sec. 6.3.2.3, last 4 paragraphs] of the C99 rationale, which gives a more detailed description of how invalid pointers can be generated, and what effects that may have.</p>\n", "LastEditorUserId": "6854781", "LastActivityDate": "2016-09-21T04:10:05.760", "Score": "1", "CreationDate": "2016-09-20T23:17:26.760", "ParentId": "3838855", "CommentCount": "0", "OwnerUserId": "6854781", "LastEditDate": "2016-09-21T04:10:05.760"}, "3839492": {"Id": "3839492", "PostTypeId": "2", "Body": "<p>Yes, it's undefined behavior. See <a href=\"https://stackoverflow.com/questions/1866461/why-should-i-not-try-to-use-this-value-after-delete-this/1866543#1866543\">the accepted answer</a> to <a href=\"https://stackoverflow.com/questions/1866461/why-should-i-not-try-to-use-this-value-after-delete-this\">this closely related question</a>. Assigning an invalid pointer to a variable, comparing an invalid pointer, casting an invalid pointer triggers undefined behavior.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-10-01T13:16:19.050", "Score": "0", "CreationDate": "2010-10-01T13:16:19.050", "ParentId": "3838855", "CommentCount": "0", "OwnerUserId": "57428", "LastEditDate": "2017-05-23T12:15:06.583"}, "3839037": {"Id": "3839037", "PostTypeId": "2", "Body": "<p>Your code is undefined behavior for a different reason:</p>\n<p>the expression <code>begin - 1</code> does <em>not</em> yield an invalid pointer. It is undefined behavior. You are not allowed to perform pointer arithmetics beyond the bounds of the array you're working on. So it is the subtraction itself that is invalid, and not the act of storing the resulting pointer. </p>\n", "LastActivityDate": "2010-10-01T12:16:24.060", "CommentCount": "19", "CreationDate": "2010-10-01T12:16:24.060", "ParentId": "3838855", "Score": "10", "OwnerUserId": "33213"}, "3838889": {"Id": "3838889", "PostTypeId": "2", "Body": "<p>Any use of an invalid pointer yields undefined behaviour.  I don't have the C Standard here at work, but see 'invalid pointers' in the Rationale: <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf</a></p>\n", "LastActivityDate": "2010-10-01T11:56:56.663", "CommentCount": "4", "CreationDate": "2010-10-01T11:56:56.663", "ParentId": "3838855", "Score": "3", "OwnerUserId": "18167"}, "3839447": {"Id": "3839447", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3838855_3839447_0\">$5.7/6 - \"Unless both pointers point\n  to elements of the same array object,\n  or one past the last element of the\n  array object, the behavior is\n  undefined.75)\"</p>\n</blockquote>\n<p>Summary, it is undefined <strong>even if you do not dereference the pointer</strong>.</p>\n", "LastActivityDate": "2010-10-01T13:10:07.373", "CommentCount": "3", "CreationDate": "2010-10-01T13:10:07.373", "ParentId": "3838855", "Score": "1", "OwnerUserId": "418110"}, "3839023": {"Id": "3839023", "PostTypeId": "2", "Body": "<p>I have the C Draft Standard here, and it makes it undefined by omission. It defines the case of <code>ptr + I</code> at 6.5.6/8 for</p>\n<ul>\n<li>If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integer expression.</li>\n<li>Moreover, if the expression P points to the last element of an array object, the expression (P)+1 points one past the last element of the array object, and if the expression Q points one past the last element of an array object, the expression (Q)-1 points to the last element of the array object. </li>\n</ul>\n<p>Your case does not fit any of these. Neither is your array large enough to have <code>-1</code> adjust the pointer to point to a different array element, nor does any of the result or original pointer point one-past-end. </p>\n", "LastActivityDate": "2010-10-01T12:14:43.303", "CommentCount": "10", "CreationDate": "2010-10-01T12:14:43.303", "ParentId": "3838855", "Score": "14", "OwnerUserId": "34509"}, "3838855": {"ViewCount": "1358", "Body": "<p>Obviously, dereferencing an invalid pointer causes undefined behavior.  But what about simply <em>storing</em> an invalid memory address in a pointer variable?</p>\n<p>Consider the following code:</p>\n<pre><code>const char* str = \"abcdef\";\nconst char* begin = str;\nif (begin - 1 &lt; str) { /* ... do something ... */ }\n</code></pre>\n<p>The expression <code>begin - 1</code> evaluates to an invalid memory address.  Note that we don't actually dereference this address - we simply use it in pointer arithmetic to test if it is valid.  Nonetheless, we still have to load an invalid memory address into a register.</p>\n<p>So, is this undefined behavior?  I never thought it was, since a lot of pointer arithmetic seems to rely on this sort of thing, and a pointer is really nothing but an integer anyway.  But recently I heard that even the act of loading an invalid pointer into a register is undefined behavior, since certain architectures will automatically throw a bus error or something if you do that.  Can anyone point me to the relevant part of the C or C++ standard which settles this either way?</p>\n", "AcceptedAnswerId": "3839023", "Title": "Is storing an invalid pointer automatically undefined behavior?", "CreationDate": "2010-10-01T11:51:12.900", "Id": "3838855", "CommentCount": "2", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2010-10-01T12:13:16.800", "LastEditorUserId": "463823", "LastActivityDate": "2016-09-21T04:10:05.760", "Score": "17", "OwnerUserId": "463823", "Tags": "<c++><c><pointers>", "AnswerCount": "7"}, "3839757": {"Id": "3839757", "PostTypeId": "2", "Body": "<p>Some architectures have dedicated registers for holding pointers. Putting the value of an unmapped address into such a register is allowed to crash. Integer overflow/underflow is allowed to crash. Because C aims to work on a broad variety of platforms, pointers provide a mechanism for safely programming unsafe circuits.</p>\n<p>If you know you won't be running on exotic hardware with such finicky characteristics, you don't need to worry about what is undefined by the language. It is well-defined by the platform.</p>\n<p>Of course, the example is poor style and there isn't a good reason to do it.</p>\n", "LastActivityDate": "2010-10-01T13:46:54.710", "CommentCount": "6", "CreationDate": "2010-10-01T13:46:54.710", "ParentId": "3838855", "Score": "6", "OwnerUserId": "153285"}});