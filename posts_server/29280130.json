post_cb({"bq_ids": {"n4140": {"so_29280130_29280130_0": {"length": 35, "quality": 0.9210526315789473, "section_id": 5913}}, "n3337": {"so_29280130_29280130_0": {"length": 35, "quality": 0.9210526315789473, "section_id": 5685}}, "n4659": {"so_29280130_29280130_0": {"length": 34, "quality": 0.8947368421052632, "section_id": 7404}}}, "29280130": {"ViewCount": "60", "Body": "<p>\u00a79.5.1 States:</p>\n<blockquote>\n<p id=\"so_29280130_29280130_0\">[\n  Note:\n  One special guarantee\n  is made in order to simplify the use of unions: If a standard-layout union contains several standard-layout\n  structs that share a common initial sequence (\n  9.2\n  ), and if an object of this standard-layout union type\n  contains one of the standard-layout structs, it is permitted to inspect the common initial sequence of any of\n  standard-layout struct members; see\n  9.2\n  .\n  \u2014end note\n  ]</p>\n</blockquote>\n<p>There was some <a href=\"https://www.reddit.com/r/cpp/comments/304c6i/safe_bitfields_in_c/cpqain7?context=1\" rel=\"nofollow\">questions elsewhere</a> surrounding whether or not a literal type and a standard-layout struct were layout compatible and covered under this guarantee.</p>\n<p>Does the following code show undefined behavior?</p>\n<pre><code>struct S {\n  int a;\n};\n\nunion U {\n  int a;\n  S b;\n};\n\nint main() {\n  U foo;\n  foo.a = 3;\n  return foo.b.a;\n}\n</code></pre>\n", "Title": "Can the note in \u00a79.5.1 apply to literal types?", "CreationDate": "2015-03-26T13:47:20.120", "LastActivityDate": "2015-03-26T13:52:14.223", "CommentCount": "11", "LastEditDate": "2015-03-26T13:52:14.223", "PostTypeId": "1", "LastEditorUserId": "483486", "Id": "29280130", "Score": "1", "OwnerUserId": "483486", "Tags": "<c++><struct><standards><language-lawyer><unions>", "AnswerCount": "0"}});