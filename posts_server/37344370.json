post_cb({"37344370": {"ViewCount": "797", "Body": "<p>Apologies in advance, I know the general topic of evaluation order has had a lot of SO questions on it already. However, having looked at them, I want to clarify a few specific points that I don't think amount to a duplication of anything. Suppose I have the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nauto myLambda(int&amp; n)\n{\n    ++n;\n    return [](int param) { std::cout &lt;&lt; \"param: \" &lt;&lt; param &lt;&lt; std::endl; };\n}\n\nint main()\n{\n    int n{0};\n\n    myLambda(n)(n);\n    return 0;\n}\n</code></pre>\n<p>The program above outputs \"n: 0\" when I compile it. Here we have unspecified ordering at play: it could have just as easily output \"n: 1\" had a different evaluation order taken place.</p>\n<p>My questions are:</p>\n<ol>\n<li><p>What exactly is the sequencing relationship at play during the final function invocation above (i.e. the lambda-expression invocation), between the postfix expression <code>myLambda(0)</code>, its argument <code>n</code>, and the subsequent function call itself?</p></li>\n<li><p>Is the above an example of <em>undefined</em> or <em>unspecified</em> behaviour - and why exactly (with reference to the standard)?</p></li>\n<li><p>If I changed the lambda code to <code>[](int param) { std::cout &lt;&lt; \"hello\" &lt;&lt; std::endl }</code> (i.e. made the outcome independent of its parameter and thus any evaluation order decisions, making behaviour deterministic) would the answer to 2) above still be the same?</p></li>\n</ol>\n<p><strong>EDIT</strong>: I've change the lambda parameter name from 'n' to 'param' because that seemed to be causing confusion.</p>\n", "Title": "C++ postfix expression undefined vs unspecified behaviour", "CreationDate": "2016-05-20T10:31:25.383", "LastActivityDate": "2016-05-21T14:04:46.190", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-05-21T14:04:46.190", "LastEditorUserId": "2883245", "Id": "37344370", "Score": "24", "OwnerUserId": "6255513", "Tags": "<c++><language-lawyer><c++14><undefined-behavior><order-of-evaluation>", "AnswerCount": "5"}, "37345867": {"PostTypeId": "2", "Body": "<p>I didn't manage to find proper reference to standard but I see that it has similar behavior to argument evaluation order asked <a href=\"https://stackoverflow.com/q/36992039/3344612\">here</a> and the order of function arguments evaluation is not defined by the standard:</p>\n<blockquote>\n<p id=\"so_37344370_37345867_0\"><strong>5.2.2 Function call</strong></p>\n<p id=\"so_37344370_37345867_1\">8 [ <em>Note:</em> The evaluations of the postfix expression and of the argument expressions are all unsequenced relative to one another. All side effects of argument expression evaluations are sequenced before the function\n  is entered (see 1.9). <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>So here's how it goes inside the calls on different compilers:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nstruct Int\n{\n    Int() { std::cout &lt;&lt; \"Int(): \" &lt;&lt; v &lt;&lt; std::endl; }\n    Int(const Int&amp; o) { v = o.v; std::cout &lt;&lt; \"Int(const Int&amp;): \" &lt;&lt; v &lt;&lt; std::endl; }\n    Int(int o) { v = o; std::cout &lt;&lt; \"Int(int): \" &lt;&lt; v &lt;&lt; std::endl; }\n    ~Int() { std::cout &lt;&lt; \"~Int(): \" &lt;&lt; v &lt;&lt; std::endl; }\n    Int&amp; operator=(const Int&amp; o) { v = o.v; std::cout &lt;&lt; \"operator= \" &lt;&lt; v &lt;&lt; std::endl; return *this; }\n\n    int v;\n};\n\nnamespace std\n{\n    template&lt;&gt;\n    Int&amp;&amp; forward&lt;Int&gt;(Int&amp; a) noexcept\n    {\n        std::cout &lt;&lt; \"Int&amp;: \" &lt;&lt; a.v &lt;&lt; std::endl;\n        return static_cast&lt;Int&amp;&amp;&gt;(a);\n    }\n\n    template&lt;&gt;\n    Int&amp;&amp; forward&lt;Int&gt;(Int&amp;&amp; a) noexcept\n    {\n        std::cout &lt;&lt; \"Int&amp;&amp;: \" &lt;&lt; a.v &lt;&lt; std::endl;\n        return static_cast&lt;Int&amp;&amp;&gt;(a);\n    }\n}\n\nstd::function&lt;void(Int)&gt; myLambda(Int&amp; n)\n{\n    std::cout &lt;&lt; \"++n: \" &lt;&lt; n.v &lt;&lt; std::endl;\n    ++n.v;\n    return [&amp;](Int m) { \n        std::cout &lt;&lt; \"n: \" &lt;&lt; m.v &lt;&lt; std::endl;\n    };\n}\n\nint main()\n{\n    Int n(0);\n\n    myLambda(n)(n);\n    return 0;\n}\n</code></pre>\n<p>GCC <code>g++ -std=c++14 -O2 -Wall -pedantic -pthread main.cpp &amp;&amp; ./a.out</code> and MSVC</p>\n<blockquote>\n<p id=\"so_37344370_37345867_2\">Int(int): 0<br>\n  Int(const Int&amp;): 0<br>\n  ++n: 0<br>\n  Int&amp;: 0<br>\n  Int&amp;: 0<br>\n  Int(const Int&amp;): 0<br>\n  n: 0<br>\n  ~Int(): 0<br>\n  ~Int(): 0<br>\n  ~Int(): 1</br></br></br></br></br></br></br></br></br></p>\n</blockquote>\n<p>So it creates variable and copies it to pass to returned lamba.</p>\n<p>Clang <code>clang++ -std=c++14 main.cpp &amp;&amp; ./a.out</code></p>\n<blockquote>\n<p id=\"so_37344370_37345867_3\">Int(int): 0<br>\n  ++n: 0<br>\n  Int(const Int&amp;): 1<br>\n  Int&amp;: 1<br>\n  Int&amp;: 1<br>\n  Int(const Int&amp;): 1<br>\n  n: 1<br>\n  ~Int(): 1<br>\n  ~Int(): 1<br>\n  ~Int(): 1  </br></br></br></br></br></br></br></br></br></p>\n</blockquote>\n<p>Here it creates variable evaluates function and then passees copy the lamba.</p>\n<p>And the order of evaluation is:</p>\n<pre><code>struct A\n{\n    A(int) { std::cout &lt;&lt; \"1\" &lt;&lt; std::endl; }\n    ~A() { std::cout &lt;&lt; \"-1\" &lt;&lt; std::endl; }\n};\n\nstruct B\n{\n    B(double) { std::cout &lt;&lt; \"2\" &lt;&lt; std::endl; }\n    ~B() { std::cout &lt;&lt; \"-2\" &lt;&lt; std::endl; }\n};\n\nvoid f(A, B) { }\n\nint main()\n{\n    f(4, 5.);\n}\n</code></pre>\n<p>MSVC and GCC:</p>\n<blockquote>\n<p id=\"so_37344370_37345867_4\">2<br>\n  1<br>\n  -1<br>\n  -2  </br></br></br></p>\n</blockquote>\n<p>Clang:</p>\n<blockquote>\n<p id=\"so_37344370_37345867_5\">1<br>\n  2<br>\n  -2<br>\n  -1  </br></br></br></p>\n</blockquote>\n<p>As in clang order is forward and the argument to lambda is passed after evaluation of the function's argument</p>\n", "LastActivityDate": "2016-05-20T11:56:47.257", "LastEditorUserId": "-1", "Id": "37345867", "CommentCount": "0", "CreationDate": "2016-05-20T11:43:57.820", "ParentId": "37344370", "Score": "2", "OwnerUserId": "3344612", "LastEditDate": "2017-05-23T10:31:16.057"}, "37346144": {"PostTypeId": "2", "Body": "<p>The <code>n</code> in the definition of the lambda is a formal argument to the function that the lambda defines. It has no connection to the argument to <code>myLambda</code> that's also named <code>n</code>. The behavior here is dictated entirely by the way these two functions are called. In <code>myLambda(n)(n)</code> the order of evaluation of the two function arguments is unspecified. The lambda can be called with an argument of 0 or 1, depending in the compiler.</p>\n<p>If the lambda had been defined with <code>[=n]()...</code> it would behave differently.</p>\n", "LastActivityDate": "2016-05-20T11:57:02.097", "Id": "37346144", "CommentCount": "2", "CreationDate": "2016-05-20T11:57:02.097", "ParentId": "37344370", "Score": "4", "OwnerUserId": "1593860"}, "37346308": {"PostTypeId": "2", "Body": "<p>Ironically (since the example uses C++11 features, and other answers have been distracted by that) the logic that makes this sample have unspecified behaviour dates back to C++98, Section 5, para 4</p>\n<blockquote>\n<p id=\"so_37344370_37346308_0\">Except where noted, the order of evaluation of operands of individual operators and subexpressions of individual expressions, and the order in which side effects take place, is unspecified. Between the previous and next sequence point a scalar object shall have its stored value modified at most once by the evaluation of an expression. Furthermore, the prior value shall be accessed only to determine the value to be stored. The requirements of this paragraph shall be met for each allowable ordering of the subexpressions of a full expression; otherwise the behavior is undefined.</p>\n</blockquote>\n<p>Essentially the same clause exists in all C++ standards although, as noted in comment by Marc van Leeuwen, recent C++ standards no longer use the concept of sequence points.  The net effect is the same: within a statement, the order or evaluation of operands of operators and subexpressions of individual expressions remains unspecified.</p>\n<p>The unspecified behaviour occurs because an expression <code>n</code> is evaluated twice in the statement</p>\n<pre><code>myLambda(n)(n);\n</code></pre>\n<p>One evaluation of the expression <code>n</code> (to obtain a reference) is associated with the first <code>(n)</code> and another evaluation of an expression <code>n</code> (to obtain a value) is associated with the second <code>(n)</code>.   The order of evaluation of those two expressions (even though they are, optically, both <code>n</code>) is unspecified.</p>\n<p>Similar clauses exist in ALL C++ standards, and have the same result - unspecified behaviour on the statement <code>myLambda(n)(n)</code>, regardless of how <code>myLambda()</code> implemented</p>\n<p>For example, <code>myLambda()</code> could be implemented in C++98 (and all later C++ standards, including C++11 and later) like this</p>\n<pre><code> class functor\n {\n      functor() {};\n      int operator()(int n) { std::cout &lt;&lt; \"n: \" &lt;&lt; n &lt;&lt; std::endl; };\n };\n\n functor myLambda(int &amp;n) \n {\n       ++n;\n       return functor();\n }\n\n int main()\n {\n      int n = 0;\n\n      myLambda(n)(n);\n      return 0;\n }\n</code></pre>\n<p>since the code in the question is just a (C++11) technique (or shorthand) for achieving the same effect as this.</p>\n<p>The above answers OP's questions 1. and 2.    The unspecified behaviour occurs in <code>main()</code>, is unrelated to how <code>myLambda()</code> itself is implemented.</p>\n<p>To answer the OP's third question, the behaviour is still unspecified if the lambda (or the functor's <code>operator()</code>) in my example) is modified to not access the value of its argument.   The only difference is that the program as a whole produces no visible output that might vary between compilers.</p>\n", "LastActivityDate": "2016-05-20T23:26:48.947", "LastEditorUserId": "4706785", "Id": "37346308", "CommentCount": "1", "CreationDate": "2016-05-20T12:04:57.197", "ParentId": "37344370", "Score": "17", "OwnerUserId": "4706785", "LastEditDate": "2016-05-20T23:26:48.947"}, "bq_ids": {"n4140": {"so_37344370_37345867_1": {"length": 18, "quality": 0.72, "section_id": 5995}}, "n3337": {"so_37344370_37345867_1": {"length": 21, "quality": 0.84, "section_id": 5763}}}, "37352636": {"PostTypeId": "2", "Body": "<p>\u1e6ahe behaviour is unspecified, because in the function call <code>(myLambda(n))(n)</code> the postfix expression (which I gave an extra redundant pair of parentheses) is unsequenced relative to the argument expression <code>n</code> (the rightmost one). However there is no undefined behaviour, because the modification of <code>n</code> takes place inside the function call <code>myLambda(n)</code>. The only definite sequencing relation is that both evaluating <code>myLambda(n)</code> and the final <code>n</code> are obviously sequenced before the actual call of the lambda. For the final question, is the lambda chooses to completely ignore its argument, then the behaviour is no longer unspecified: though it is unspecified what value gets passed as parameter, there is no observable difference either way.</p>\n", "LastActivityDate": "2016-05-20T17:34:07.693", "Id": "37352636", "CommentCount": "0", "CreationDate": "2016-05-20T17:34:07.693", "ParentId": "37344370", "Score": "1", "OwnerUserId": "1436796"}, "37346171": {"PostTypeId": "2", "Body": "<p>The order in which sub expressions are evaluated is unspecified and can vary apart from the operators &amp;&amp;, ||,? and \",\". </p>\n<p>The compiler knows both function prototyps myLambda and also the return lambda(extracted from the return type). Cause my first sentence the compiler is free which expression he evaluates first. Thats why you should never call to functions in on expression which have additional side effects.</p>\n", "LastActivityDate": "2016-05-20T11:58:24.687", "Id": "37346171", "CommentCount": "0", "CreationDate": "2016-05-20T11:58:24.687", "ParentId": "37344370", "Score": "0", "OwnerUserId": "6350154"}});