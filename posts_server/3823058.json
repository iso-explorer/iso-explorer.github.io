post_cb({"3823248": {"ParentId": "3823058", "CommentCount": "0", "Body": "<p>The standard all but explicitly says that a string can allocate memory when you call <code>c_str</code>. In particular, it says (\u00a721.3/5):</p>\n<blockquote>\n<p id=\"so_3823058_3823248_0\">References, pointers, and iterators referring to the elements of a basic_string sequence may be invalidated by the following uses of that basic_string object:<br>\n  [ ... ]<br>\n  \u2014 Calling data() and c_str() member functions.</br></br></p>\n</blockquote>\n<p>It gives permission for pointers, references and iterators to be invalidated <em>specifically</em> to allow an implementation to re-allocate the memory used to store the string when you call <code>c_str</code>.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "3823248", "Score": "1", "CreationDate": "2010-09-29T15:41:59.083", "LastActivityDate": "2010-09-29T15:41:59.083"}, "3823124": {"ParentId": "3823058", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The standard says that calling <code>c_str()</code> may invalidate references, pointers, and interators referring to the elements of the <code>string</code>, which implies that reallaocation is permitted (21.3/5 \"Class template basic_string\").</p>\n<p>You might want to just call <code>string::copy()</code> to get your copy (you'll need to add the null terminator yourself if you need it).</p>\n", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2010-09-29T15:36:51.223", "Id": "3823124", "Score": "6", "CreationDate": "2010-09-29T15:30:35.883", "LastActivityDate": "2010-09-29T15:36:51.223"}, "3823150": {"ParentId": "3823058", "CommentCount": "0", "Body": "<p>The Standard is silent on this:</p>\n<h2>21.3.6 [lib.strings.ops]</h2>\n<blockquote>\n<p id=\"so_3823058_3823150_0\">const charT * c_str () const ; 1\n  Returns: A pointer to the initial\n  element of an array of length size() +\n  1 whose first size() elements equal\n  the corresponding elements of the\n  string controlled by *this and whose\n  last element is a null character\n  specified by charT().</p>\n<p id=\"so_3823058_3823150_1\">2 Requires: The program shall not\n  alter any of the values stored in the\n  array. Nor shall the program treat the\n  returned value as a valid pointer\n  value after any subsequent call to a\n  non-const member function of the class\n  basic_string that designates the same\n  object as this.</p>\n</blockquote>\n<p>It could.  That said, Iv'e never seen any implementation that does.</p>\n<p>If this is a concern for you, you may want to consider using <code>vector&lt;char&gt;</code> instead of <code>string</code>, and doing something like:</p>\n<pre><code>vector&lt;char&gt; chars;\n// ...\nchar* my_str = &amp;chars[0];\n</code></pre>\n<p>The trick here is knowing when &amp; how to deal with the need for <code>'\\0'</code>-terminated strings.</p>\n", "OwnerUserId": "241536", "PostTypeId": "2", "Id": "3823150", "Score": "2", "CreationDate": "2010-09-29T15:33:11.573", "LastActivityDate": "2010-09-29T15:33:11.573"}, "3823106": {"ParentId": "3823058", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>No, the standard gives no such guarantee. The only guarantee in the C++ standard is that the returned value points to a <code>char</code> array with the same contents as the <code>std::string</code>, plus a nul-terminator.</p>\n<p>So it would be standards-conforming for an implementation to store its internal representation in some way other than a C-string, and allocate a C-string on the fly when you call <code>c_str</code>, although I'm fairly certain that no widely used STL implementation actually does this.</p>\n<p>Now, with respect to C++0x, I have heard (although I am at a loss for finding documentation for this at the moment), that one of the changes is going to be to require that <code>std::string</code> operate on contiguous storage (a similar requirement already exists for <code>std::vector</code>). So in that case, you could access the span from <code>&amp;str[0]</code> through <code>&amp;str[0]+str.length()-1</code> as if it were a C-string without a nul-terminator.</p>\n", "OwnerUserId": "39375", "LastEditorUserId": "39375", "LastEditDate": "2010-09-29T15:35:35.707", "Id": "3823106", "Score": "6", "CreationDate": "2010-09-29T15:29:10.583", "LastActivityDate": "2010-09-29T15:35:35.707"}, "3823058": {"CommentCount": "0", "AcceptedAnswerId": "3823124", "CreationDate": "2010-09-29T15:23:08.500", "LastActivityDate": "2010-09-29T15:41:59.083", "PostTypeId": "1", "ViewCount": "756", "FavoriteCount": "1", "Title": "Is string::c_str() allowed to allocate anything on the heap?", "Id": "3823058", "Score": "10", "Body": "<p>If I need to get a NUL-terminated <code>char</code> array out of a <code>std::string</code> in a situation where I need to be sure nothing will be allocated, is it safe to use <code>c_str</code> to do so? For example, if I'm inside a destructor and I want to copy some data from a <code>string</code> into a pre-allocated, fixed-size buffer, can I use <code>c_str</code> and be sure it won't throw anything?</p>\n", "Tags": "<c++><string>", "OwnerUserId": "85467", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_3823058_3823248_0": {"section_id": 1567, "quality": 0.8333333333333334, "length": 15}}, "n3337": {"so_3823058_3823248_0": {"section_id": 1562, "quality": 0.8333333333333334, "length": 15}}, "n4659": {"so_3823058_3823248_0": {"section_id": 1716, "quality": 0.8333333333333334, "length": 15}}}});