post_cb({"19870937": {"ParentId": "19843816", "CommentCount": "2", "Body": "<p>Adding new data to the <code>Descendent</code> class will break <code>Descendent[]</code>'s interchangeability with <code>Base[]</code>.  In order for some function to pretend an array of larger structures is an array of smaller but otherwise compatible structures, a new array would have to be prepared in which the extra bytes are sliced off, in which case it is <em>impossible</em> to define the behavior of the system.  What happens if some pointers are sliced off?  What happens if the state of these objects is supposed to change as part of the called procedure, and the actual objects to which they refer are not the originals?  </p>\n<p>Otherwise, if no slicing occurs and a <code>Base*</code> to the <code>Derived[]</code> was <code>++</code>ed, <code>sizeof(Base)</code> would be added to its binary value, and it would no longer point to a <code>Base*</code>.  There is obviously no way to define the behavior of the system in that case either.</p>\n<p>Knowing that, using this idiom is NOT safe, even if the standard and the president and God define it as working.  Any addition to <code>Descendent</code> breaks your code.  Even if you add an assertion, there will be functions whose legitimacy depends on <code>Base[]</code> being interchangeable with <code>Descendent[]</code>.  Whoever maintains your code will have to hunt down each of these cases and come up with an appropriate workaround.  Factoring your program around this idiom to avoid these problems will probably not be worth the convenience.</p>\n", "OwnerUserId": "929845", "PostTypeId": "2", "Id": "19870937", "Score": "0", "CreationDate": "2013-11-09T00:35:45.170", "LastActivityDate": "2013-11-09T00:35:45.170"}, "19869416": {"ParentId": "19843816", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>While this particular example is safe on all modern platforms and compilers I am familiar with, it is not safe in general and it is an example of a bad code.</p>\n<ol>\n<li>It cannot work on compilers/platforms where sizeof(Base) != sizeof(Descendant)</li>\n<li>It is unsafe because someday someone in your project will add a new non-static member to the Descendant class or will make the Base class virtual.</li>\n</ol>\n<p>UPD. Both Base and Descendant are standard layout types. So it is a requirement of the standard that a pointer to Descendant can be correctly reinterpret_cast to a pointer to Base, that means no padding in front of the structure is allowed.\nBut there is no any requirement in C++ standard for padding at the end of a structure, so it is compiler-dependent.\nThere is also the standard proposal to explicitly mark this behavior as undefined.\n<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1504\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1504</a></p>\n", "OwnerUserId": "2102000", "LastEditorUserId": "2102000", "LastEditDate": "2014-04-04T18:13:08.770", "Id": "19869416", "Score": "-1", "CreationDate": "2013-11-08T22:08:51.553", "LastActivityDate": "2014-04-04T18:13:08.770"}, "19868173": {"ParentId": "19843816", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_19843816_19868173_0\">Is behavior of this program defined? Does the answer depend on the body of foo, like whether it writes to the array or only reads from it?</p>\n</blockquote>\n<p>I'm gonna hazard an answer saying that the program is well defined (as long as <code>foo</code> is) even if it is written in another language (e.g. C).</p>\n<blockquote>\n<p id=\"so_19843816_19868173_1\">If <code>sizeof(Derived)</code> is unequal to <code>sizeof(Base)</code>, then behavior is undefined according to the answers to a previous question about a base pointer to an array of derived objects. Is there any chance the objects in this question will have differing sizes, though?</p>\n</blockquote>\n<p>I don't think so. According to my reading of the standard(*) \u00a79.2 clause 17 </p>\n<blockquote>\n<p id=\"so_19843816_19868173_2\">Two standard-layout struct (Clause 9) types are layout-compatible if they have the same number of non-static\n  data members and corresponding non-static data members (in declaration order) have layout-compatible\n  types (3.9).</p>\n</blockquote>\n<p>\u00a79 clauses 7 through 9 detail the requirements for layout-compability:</p>\n<blockquote>\n<p id=\"so_19843816_19868173_3\">7 A <em>standard-layout</em> class is a class that:</p>\n<ul>\n<li><p id=\"so_19843816_19868173_4\">has no non-static data members of type non-standard-layout class (or array of such types) or reference,</p></li>\n<li><p id=\"so_19843816_19868173_5\">has no virtual functions (10.3) and no virtual base classes (10.1),</p></li>\n<li><p id=\"so_19843816_19868173_6\">has the same access control (Clause 11) for all non-static data members,</p></li>\n<li><p id=\"so_19843816_19868173_7\">has no non-standard-layout base classes,</p></li>\n<li><p id=\"so_19843816_19868173_8\">either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and</p></li>\n<li><p id=\"so_19843816_19868173_9\">has no base classes of the same type as the first non-static data member.</p></li>\n</ul>\n<p id=\"so_19843816_19868173_10\">8 A <em>standard-layout struct</em> is a standard-layout class defined with the <em>class-key</em> <code>struct</code> or the <em>class-key</em> <code>class</code>. A <em>standard-layout union</em> is a standard-layout class defined with the <em>class-key</em> <code>union</code>.</p>\n<p id=\"so_19843816_19868173_11\">9 [ <em>Note:</em> Standard-layout classes are useful for communicating with code written in other programming languages. Their layout is specified in 9.2. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>Note especially the last clause (combined with \u00a73.9) - according to my reading this is guaranteeing that as long as you're not adding too much \"C++ stuff\" (virtual functions etc. and thus violating the standard-layout requirement) your structs/classes will behave as C structs with added syntactical sugar.</p>\n<p>Would anyone have doubted the legality if <code>Base</code> didn't have a constructor? I don't think so as that pattern  (deriving from a C structure adding a constructor/helper functions) is idiomatic. </p>\n<p>I'm open to the possibility that I'm wrong and welcome additions/corrections.</p>\n<p>(*) I'm actually looking at N3290 here, but the actual standard should be close enough.</p>\n", "OwnerUserId": "786653", "LastEditorUserId": "420683", "LastEditDate": "2013-11-12T18:06:11.920", "Id": "19868173", "Score": "1", "CreationDate": "2013-11-08T20:43:35.983", "LastActivityDate": "2013-11-12T18:06:11.920"}, "19847759": {"ParentId": "19843816", "CommentCount": "2", "Body": "<p>If you declare an array of pointers to Base, then the code will run correctly.\nAs a bonus, the new foo() will be safe to use with some future subclass of Base that has new data structures.</p>\n<pre><code>void foo(Base **array, unsigned len)\n{\n    // Example code\n    for(unsigned i = 0; i &lt; len; ++i)\n    {\n        Base *x = array[i];\n        std::cout &lt;&lt; x-&gt;a &lt;&lt; x-&gt;b;\n    }\n}\n\nvoid do_something()\n{\n    Base *data[2];\n    data[0] = new Base(1, \"a\");\n    data[2] = new Descendent(2, \"b\");\n\n    foo(data, 2);\n\n    delete data[0];\n    delete data[1];\n}\n</code></pre>\n", "OwnerUserId": "1286512", "PostTypeId": "2", "Id": "19847759", "Score": "0", "CreationDate": "2013-11-07T22:13:03.033", "LastActivityDate": "2013-11-07T22:13:03.033"}, "19843816": {"CommentCount": "8", "ViewCount": "347", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-11-07T18:29:47.867", "LastActivityDate": "2014-04-04T18:13:08.770", "Title": "When S is a trivial subclass of T, is it safe to use an array of S where an array of T is expected?", "FavoriteCount": "1", "LastEditDate": "2017-05-23T12:13:44.067", "Id": "19843816", "Score": "11", "Body": "<p>Consider the following declarations of a pair of related structs. The descendant class adds no member variables, and the only member function is a constructor that does nothing but forward all its arguments to the base class's constructor.</p>\n<pre><code>struct Base {\n  Base(int a, char const* b):\n    a(a), b(b)\n  { }\n  int a;\n  char const* b;\n};\n\nstruct Descendant: Base {\n  Descendant(int a, char const* b):\n    Base(a, b)\n  { }\n};\n</code></pre>\n<p>Now consider the following code using those types. Function <code>foo</code> expects to receive an array of <code>Base</code>. However, <code>main</code> defines an array of <code>Descendant</code> and passes that to <code>foo</code> instead.</p>\n<pre><code>void foo(Base* array, unsigned len)\n{\n  /* &lt;access contents of array&gt; */\n}\n\nint main()\n{\n  Descendant main_array[] = {\n    Descendant(0, \"zero\"),\n    Descendant(1, \"one\")\n  };\n  foo(main_array, 2);\n  return 0;\n}\n</code></pre>\n<p>Is behavior of this program defined? Does the answer depend on the body of <code>foo</code>, like whether it writes to the array or only reads from it?</p>\n<p>If <code>sizeof(Derived)</code> is unequal to <code>sizeof(Base)</code>, then behavior is undefined according to the answers to a previous question about a <a href=\"https://stackoverflow.com/q/7197677/33732\">base pointer to an array of derived objects</a>. Is there any chance the objects in <em>this</em> question will have differing sizes, though?</p>\n", "Tags": "<c++><arrays><inheritance>", "OwnerUserId": "33732", "AnswerCount": "5"}, "19843889": {"ParentId": "19843816", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>BEWARE! While this is almost certainly true in your compiler, this is not guaranteed by the standard to work.</p>\n<p>At least add if (sizeof(Derived) != sizeof(Base)) logAndAbort(\"size mismatch between Derived and Base\"); check.</p>\n<p>In case you were wondering, the compilers for which this is safe are one to one in which the size doesn't change. There was something left behind in the standard that allows derived classes to be non-contiguous with base classes. In all cases where this happens, the size must grow (for obvious reasons).</p>\n", "OwnerUserId": "14768", "LastEditorUserId": "14768", "LastEditDate": "2013-11-09T21:13:10.373", "Id": "19843889", "Score": "0", "CreationDate": "2013-11-07T18:33:34.633", "LastActivityDate": "2013-11-09T21:13:10.373"}, "bq_ids": {"n4140": {"so_19843816_19868173_6": {"section_id": 5851, "quality": 1.0, "length": 8}, "so_19843816_19868173_2": {"section_id": 5876, "quality": 0.9545454545454546, "length": 21}, "so_19843816_19868173_5": {"section_id": 369, "quality": 0.7142857142857143, "length": 5}, "so_19843816_19868173_9": {"section_id": 5851, "quality": 1.0, "length": 8}, "so_19843816_19868173_8": {"section_id": 5851, "quality": 1.0, "length": 19}, "so_19843816_19868173_4": {"section_id": 5851, "quality": 1.0, "length": 10}, "so_19843816_19868173_11": {"section_id": 5853, "quality": 0.8, "length": 12}, "so_19843816_19868173_10": {"section_id": 5852, "quality": 1.0, "length": 16}}, "n3337": {"so_19843816_19868173_6": {"section_id": 5621, "quality": 1.0, "length": 8}, "so_19843816_19868173_2": {"section_id": 5647, "quality": 1.0, "length": 22}, "so_19843816_19868173_5": {"section_id": 359, "quality": 0.7142857142857143, "length": 5}, "so_19843816_19868173_9": {"section_id": 5621, "quality": 1.0, "length": 8}, "so_19843816_19868173_8": {"section_id": 5621, "quality": 1.0, "length": 19}, "so_19843816_19868173_4": {"section_id": 5621, "quality": 1.0, "length": 10}, "so_19843816_19868173_11": {"section_id": 5623, "quality": 0.8, "length": 12}, "so_19843816_19868173_10": {"section_id": 5622, "quality": 1.0, "length": 16}}, "n4659": {"so_19843816_19868173_6": {"section_id": 7330, "quality": 1.0, "length": 8}, "so_19843816_19868173_2": {"section_id": 7361, "quality": 0.8181818181818182, "length": 18}, "so_19843816_19868173_5": {"section_id": 383, "quality": 0.7142857142857143, "length": 5}, "so_19843816_19868173_9": {"section_id": 7330, "quality": 1.0, "length": 8}, "so_19843816_19868173_8": {"section_id": 7330, "quality": 0.7894736842105263, "length": 15}, "so_19843816_19868173_4": {"section_id": 7330, "quality": 1.0, "length": 10}, "so_19843816_19868173_11": {"section_id": 7332, "quality": 0.8, "length": 12}, "so_19843816_19868173_10": {"section_id": 7331, "quality": 0.875, "length": 14}}}});