post_cb({"3856771": {"CommentCount": "2", "ViewCount": "2092", "PostTypeId": "1", "LastEditorUserId": "126769", "CreationDate": "2010-10-04T15:40:12.890", "LastActivityDate": "2010-10-04T16:04:15.267", "Title": "Should I manipulate a C++ map's value via a pointer or by updating the record?", "LastEditDate": "2010-10-04T15:41:24.240", "Id": "3856771", "Score": "1", "Body": "<p>I'm using a C++ std::map to hold a large collection of entities:</p>\n<pre><code>using std::map;  \nmap {structureEntityID, classEntityRecord} tableEntityRecords; //(replace {}s with arrows)\n</code></pre>\n<p>I will be frequently modifying the entities in my table (many times a second). Is it better to modify those records via a pointer or is it better to make a local copy, modify it, and then update the table?</p>\n<p>For example...</p>\n<p>Via a pointer:  </p>\n<pre><code>classEntityRecord* getEntityRecord(structureEntityID entityID)  \n{  \n    map {structureEntityID, classEntityRecord}::iterator iteratorEntityRecord;  \n    iteratorEntityRecord = tableEntityRecords.find(entityID);  \n    return &amp;iteratorEntityRecord-&gt;second;  \n}  \n\nclassEntityRecord *entityRecord;  \nentityRecord = getEntityRecord(entityID);  \nentityRecord-&gt;x = 15;  \n</code></pre>\n<p>Via a copy/modify/update:  </p>\n<pre><code>classEntityRecord getEntityRecord(structureEntityID entityID)  \n{  \n    map {structureEntityID, classEntityRecord}::iterator iteratorEntityRecord;  \n    iteratorEntityRecord = tableEntityRecords.find(entityID);  \n    return iteratorEntityRecord-&gt;second;  \n}\n\nclassEntityRecord entityRecord;  \nentityRecord = getEntityRecord(entityID);  \nentityRecord.x = 15;  \ntableEntityRecords[entityID] = entityRecord; \n</code></pre>\n<p>I would think it is better to use a pointer, but this is my first time with C++ maps so I don't fully understand how they work.</p>\n<p>My big worry is if I take a pointer to one of the values in my table, is it possible for the C++ map to be reordered and have that pointer no longer be valid? The program is multithreaded so entities can be added to the table while others are being modified.</p>\n<p>I appreciate the help!</p>\n", "Tags": "<c++><pointers><stl><map>", "OwnerUserId": "465991", "AnswerCount": "2"}, "3856815": {"ParentId": "3856771", "CommentCount": "2", "Body": "<p>You should be thinking of references (&amp;) not pointers (*).  As it stands your getEntityRecord returns a copy of the map element value, hence changes to the returned value will not be seen via the map.  If you change this function to return a reference, it will do what you want.</p>\n<pre><code>classEntityRecord&amp; getEntityRecord(structureEntityID entityID)\n</code></pre>\n<p><code>map::find</code> returns you an <code>iterator</code>, the <code>second</code> field of which contains a reference to the <code>map</code> member value.  You can use this reference to safely modify the <code>map</code> member value without worrying about the <code>map</code> being modified, <strong>provided nobody else deletes that entry</strong>.</p>\n<p>From the <a href=\"http://www.sgi.com/tech/stl/Map.html\" rel=\"noreferrer\">map documentation for SGI STL</a></p>\n<blockquote>\n<p id=\"so_3856771_3856815_0\">Map has the important property that\n  inserting a new element into a map\n  does not invalidate iterators that\n  point to existing elements. Erasing an\n  element from a map also does not\n  invalidate any iterators, except, of\n  course, for iterators that actually\n  point to the element that is being\n  erased.</p>\n</blockquote>\n", "OwnerUserId": "210102", "PostTypeId": "2", "Id": "3856815", "Score": "5", "CreationDate": "2010-10-04T15:44:59.710", "LastActivityDate": "2010-10-04T15:44:59.710"}, "bq_ids": {"n4140": {"so_3856771_3856878_0": {"section_id": 745, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_3856771_3856878_0": {"section_id": 734, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_3856771_3856878_0": {"section_id": 803, "quality": 0.9333333333333333, "length": 14}}}, "3856878": {"ParentId": "3856771", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>As for your worry about \"if I take a pointer to one of the values in my table, is it possible for the C++ map to be reordered and have that pointer no longer be valid?\", the answer is that you probably don't need to worry much about it - but do need to take some care (assuming that you use iterators rather than pointers, which should be easy, since iterators act like pointers by design).</p>\n<p>Here's what the standard says about the validity of iterators and references to objects in associative containers like <code>std::map</code> (23.1.2/8 \"Associative containers\"):</p>\n<blockquote>\n<p id=\"so_3856771_3856878_0\">The insert members shall not affect the validity of iterators and references to the container, and the erase members shall invalidate only iterators and references to the erased elements.</p>\n</blockquote>\n", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2010-10-04T16:04:15.267", "Id": "3856878", "Score": "1", "CreationDate": "2010-10-04T15:52:46.730", "LastActivityDate": "2010-10-04T16:04:15.267"}});