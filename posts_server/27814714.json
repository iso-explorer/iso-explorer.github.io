post_cb({"27817553": {"PostTypeId": "2", "Body": "<p>As others pointed out, the lambda acts as a structure involving a template. The question then becomes: why Haskell can not type the self-application, while C++ can? </p>\n<p>The answer lies on the difference between C++ templates and Haskell polymorphic functions. Compare these:</p>\n<pre><code>-- valid Haskell\nfoo :: forall a b. a -&gt; b -&gt; a\nfoo x y = x\n\n// valid C++\ntemplate &lt;typename a, typename b&gt;\na foo(a x, b y) { return x; }\n</code></pre>\n<p>While they might look nearly equivalent, they are not really such. </p>\n<p>When Haskell type checks the above declaration, it checks that the definition is type safe for any types <code>a,b</code>. That is, if we substitute <code>a,b</code> with any two types, the function must be well-defined.</p>\n<p>C++ follows another approach. At template definition, it is not checked that any substitution for <code>a,b</code> will be correct. This check is <em>deferred</em> to the point of use of the template, i.e. at instantiation time. To stress the point, let's add a <code>+1</code> in our code:</p>\n<pre><code>-- INVALID Haskell\nfoo :: forall a b. a -&gt; b -&gt; a\nfoo x y = x+1\n\n// valid C++\ntemplate &lt;typename a, typename b&gt;\na foo(a x, b y) { return x+1; }\n</code></pre>\n<p>The Haskell definition will not type check: there's no guarantee you can perform <code>x+1</code> when <code>x</code> is of an arbitrary type. The C++ code is fine, instead. The fact that some substitutions of <code>a</code> lead to incorrect code is irrelevant right now.</p>\n<p>Deferring this check causes some \"infinitely-typed values\" to be allowed, roughly. Dynamic languages such as Python or Scheme further defer these type errors until run-time, and of course will handle self-application just fine.</p>\n", "LastActivityDate": "2015-01-07T10:48:22.823", "LastEditorUserId": "3234959", "Id": "27817553", "CommentCount": "0", "CreationDate": "2015-01-07T10:40:07.067", "ParentId": "27814714", "Score": "15", "OwnerUserId": "3234959", "LastEditDate": "2015-01-07T10:48:22.823"}, "27815705": {"PostTypeId": "2", "Body": "<p>The C++ <code>fac</code> isn't really a function, but a struct which has a member function.</p>\n<pre><code>struct aaaa // Not its real name.\n{\n    template&lt;typename a, typename b&gt;\n    auto operator()(a self, b n) const\n    { \n    }\n};\n</code></pre>\n<p>The overloaded call operator hides some of the trickery that C++ performs in order to implement \"lambda functions\"</p>\n<p>When you \"call\" <code>fac</code>, what happens is</p>\n<pre><code>fac.operator() (fac, 3);\n</code></pre>\n<p>so the argument to the function isn't the function itself, but an object which has it as a member.<br>\nOne effect of this is that the function's type (i.e. the type of <code>operator()</code>) does not occur in the type of the <code>operator()</code> function itself.<br>\n(The type of <code>self</code> is the struct that defines the function.)</br></br></p>\n<p>The template part isn't necessary for this to work; this is a non-generic version of the <code>fac</code> \"function\":</p>\n<pre><code>struct F\n{\n    int operator()(const F&amp; self, int n) const\n    { \n        // ...\n    }\n};\n\nF fac;\nfac(fac, 3);\n</code></pre>\n<p>If we keep the template and rename <code>operator()</code> to <code>applY</code>:</p>\n<pre><code>// The Y type\ntemplate&lt;typename a&gt;\nstruct Y\n{\n    // The wrapped function has type (Y&lt;a&gt;, a) -&gt; a\n    a applY(const Y&lt;a&gt;&amp; self, a n) const\n    { \n        if(n &lt; 1)\n            return 1;\n        else \n            return n * self.applY(self, n-1);\n    }\n};\n\ntemplate&lt;typename a&gt;\na fac(a n)\n{\n    Y&lt;a&gt; y;\n    return y.applY(y, n);\n}\n</code></pre>\n<p>we see that your working Haskell program and your C++ program are very similar - the differences are mainly punctuation.</p>\n<p>In contrast, in Haskell</p>\n<pre><code>fac2 self 0 = 1\nfac2 self n = n * (self self $ n-1)\n</code></pre>\n<p><code>self</code> <em>is</em> a function, and <code>fac2</code>'s type would have to be</p>\n<pre><code>X -&gt; Int -&gt; Int\n</code></pre>\n<p>for some <code>X</code>.<br>\nSince <code>self</code> is a function, and <code>self self $ n-1</code> is an Int, <code>self</code>'s type is also <code>X -&gt; Int -&gt; Int</code>.</br></p>\n<p>But what could <code>X</code> be?<br>\nIt must be the same as the type of <code>self</code> itself, i.e <code>X -&gt; Int -&gt; Int</code>.<br>\nBut that means that the type of <code>self</code> is (substituting for <code>X</code>):</br></br></p>\n<pre><code>(X -&gt; Int -&gt; Int) -&gt; Int -&gt; Int  \n</code></pre>\n<p>so the type <code>X</code> must also be</p>\n<pre><code>(X -&gt; Int -&gt; Int) -&gt; Int -&gt; Int  \n</code></pre>\n<p>so <code>self</code>'s type must be</p>\n<pre><code>((X -&gt; Int -&gt; Int) -&gt; Int -&gt; Int) -&gt; Int -&gt; Int\n</code></pre>\n<p>and so on, ad infinitum.<br>\nThat is, in Haskell the type would be infinite.</br></p>\n<p>Your solution for Haskell essentially explicitly introduces the necessary indirection that C++ generates through its structure with a member function.</p>\n", "LastActivityDate": "2015-02-04T12:13:52.453", "LastEditorUserId": "404970", "Id": "27815705", "CommentCount": "0", "CreationDate": "2015-01-07T09:00:19.320", "ParentId": "27814714", "Score": "25", "OwnerUserId": "404970", "LastEditDate": "2015-02-04T12:13:52.453"}, "bq_ids": {"n4140": {"so_27814714_27814829_0": {"length": 37, "quality": 0.8809523809523809, "section_id": 5962}}, "n3337": {"so_27814714_27814829_0": {"length": 33, "quality": 0.7857142857142857, "section_id": 5731}}}, "27814829": {"PostTypeId": "2", "Body": "<p>The expression following <code>auto fac =</code> is a lambda expression, and the compiler will automatically generate a closure object from it. The type of that object is unique and known only to the compiler.</p>\n<p>From N4296, <em>\u00a75.1.2/3</em> <strong>[expr.prim.lambda]</strong></p>\n<blockquote>\n<p id=\"so_27814714_27814829_0\">The type of the <em>lambda-expression</em> (which is also the type of the closure object) is a unique, unnamed non-union class type \u2014 called the <em>closure type</em> \u2014 whose properties are described below. This class type is neither an aggregate (8.5.1) nor a literal type (3.9). The closure type is declared in the smallest block scope, class scope, or namespace scope that contains the corresponding <em>lambda-expression</em>.</p>\n</blockquote>\n<p>Note that because of this, even two identical lambda expressions will have distinct types. For example,</p>\n<pre><code>auto l1 = []{};\nauto l2 = []{}; // l1 and l2 are of different types\n</code></pre>\n<hr>\n<p>Your lambda expression is a C++14 generic lambda, and will be translated by the compiler to a class that resembles the following:</p>\n<pre><code>struct __unique_name\n{\n    template&lt;typename Arg1, typename Arg2&gt;\n    auto operator()(Arg1 self, Arg2 n) const\n    { \n        // body of your lambda\n    }\n};\n</code></pre>\n<p>I cannot comment on the Haskell part, but the reason the recursive expression works in C++ is because you're simply passing a copy of the closure object instance (<code>fac</code>) in each call. The <code>operator()</code> being a template is able to deduce the type of the lambda even though it is not one you can name otherwise.</p>\n</hr>", "LastActivityDate": "2015-01-07T08:07:10.673", "LastEditorUserId": "241631", "Id": "27814829", "CommentCount": "0", "CreationDate": "2015-01-07T08:00:27.107", "ParentId": "27814714", "Score": "6", "OwnerUserId": "241631", "LastEditDate": "2015-01-07T08:07:10.673"}, "27814714": {"ViewCount": "1056", "Body": "<p>I wrote an anonymous factorial function in C++ and compiled my code with g++4.9.2.\nIt works well. However, I don't know the type of my function.</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;functional&gt;\nusing std::function;\nint main()\n{\n    //tested at g++ 4.9.2\n    //g++ -std=c++1y -o anony anony.cpp\n    auto fac = [](auto self,auto n)-&gt;auto{\n        if(n &lt; 1)\n            return 1;\n        else \n            return n * self(self,n-1);\n    };\n    std::cout&lt;&lt;fac(fac,3)&lt;&lt;std::endl;//6\n    return 0;\n}\n</code></pre>\n<p>So, I wonder: what are the types of <code>fac</code> and <code>self</code>?\nIf I just translate the C++ code into Haskell, it won't compile because\nit involves infinite types:</p>\n<pre><code>fac2 self 0 = 1\nfac2 self n = n * (self self $ n-1)\n</code></pre>\n<p>and I have to define some recursive type  work around it:</p>\n<pre><code>data Y a = Y ((Y a)-&gt;a-&gt;a)\nfac2 self 0 = 1\nfac2 self n = n * ((applY self self) (n-1))\n    where applY (Y f1) f2 = f1 f2\nfact2 = fac2 $ Y fac2\n</code></pre>\n<p>So, why could g++ get exactly the right type of the <code>fac</code> function, and what type does g++ think the <code>fac</code> function is?</p>\n", "AcceptedAnswerId": "27814829", "Title": "What is the type of this self-applying factorial function?", "CreationDate": "2015-01-07T07:50:39.350", "Id": "27814714", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-01-07T11:28:07.480", "LastEditorUserId": "3234959", "LastActivityDate": "2015-02-04T12:13:52.453", "Score": "24", "OwnerUserId": "2299477", "Tags": "<c++><haskell><types><c++14><generic-lambda>", "AnswerCount": "3"}});