post_cb({"4769229": {"CommentCount": "5", "AcceptedAnswerId": "4769269", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-01-22T17:05:32.630", "LastActivityDate": "2012-03-08T10:56:00.730", "LastEditDate": "2017-05-23T12:06:14.920", "ViewCount": "2592", "FavoriteCount": "5", "Title": "How will _Exit behave in a C++ program?", "Id": "4769229", "Score": "12", "Body": "<p>C99 offers the <code>_Exit</code> function, which exits \"immediately\", although it <strike>does</strike> may close file descriptors. Unix/POSIX extends this behavior by mandating the closing of all fd's without flushing (and offers the synonym <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/_Exit.html\" rel=\"nofollow noreferrer\"><code>_exit</code></a>).</p>\n<p>Will these functions call destructors for <code>static</code> objects when called from a C++ program? Does the C++ standard make any guarantees about <code>_Exit</code>?</p>\n<p>(Inspired by <a href=\"https://stackoverflow.com/questions/4769124/quick-successful-exit-from-c-with-lots-of-objects-allocated\">this question</a>; I suddenly wondered what happens in the typical <code>fork</code>-<code>exec</code>-<code>_exit</code> idiom in C++.)</p>\n", "Tags": "<c++><c><unix><destructor><exit>", "OwnerUserId": "166749", "AnswerCount": "9"}, "4769711": {"ParentId": "4769229", "CommentCount": "0", "CreationDate": "2011-01-22T18:29:32.037", "OwnerUserId": "412080", "PostTypeId": "2", "Id": "4769711", "Score": "2", "Body": "<p>C++0x defines a new function called <a href=\"http://www.cppreference.com/wiki/utility/program/quick_exit\" rel=\"nofollow\">std::quick_exit</a> that terminates a process without calling any destructors. Just checked, g++-4.4.5 already provides it.</p>\n", "LastActivityDate": "2011-01-22T18:29:32.037"}, "4769496": {"ParentId": "4769229", "CommentCount": "2", "CreationDate": "2011-01-22T17:50:49.700", "OwnerUserId": "379897", "PostTypeId": "2", "Id": "4769496", "Score": "2", "Body": "<p>Note that while C++ does not specify <code>_Exit</code> and C99 leaves it implementation-defined whether it flushes buffers, POSIX <strong>requires</strong> that it not flush buffers (since this would break the main usage of <code>_exit</code>/<code>_Exit</code>, i.e. handling failure of <code>execve</code> after <code>fork</code>). As POSIX does not align itself with C++ standards or defer to them on anything, I think it's very unlikely that a future version of the C++ standard would try to change any of this. It will probably either leave <code>_Exit</code> unspecified or specify that it's implementation-defined.</p>\n", "LastActivityDate": "2011-01-22T17:50:49.700"}, "4769292": {"ParentId": "4769229", "CommentCount": "0", "CreationDate": "2011-01-22T17:16:57.303", "OwnerUserId": "362938", "PostTypeId": "2", "Id": "4769292", "Score": "0", "Body": "<p>I did a quick test with gcc on Mac OS and my destructors didn't get called.</p>\n<pre><code>struct A\n{\n    ~A()\n    {\n        puts(\"A::~A\");\n    }\n};\n\nA globalA;\n\nint main()\n{\n    A localA;\n    _exit(0); // or _Exit(0)\n    return 0;\n}\n</code></pre>\n<p><code>exit(0)</code> on the other hand <em>calls</em> <code>globalA</code>'s destructor.</p>\n", "LastActivityDate": "2011-01-22T17:16:57.303"}, "4769269": {"ParentId": "4769229", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2011-01-22T17:14:04.367", "Score": "10", "LastEditorUserId": "47773", "LastEditDate": "2011-08-31T18:33:29.347", "Id": "4769269", "OwnerUserId": "47773", "Body": "<p>It simply doesn't exist in standard C++, so there are no guarantees.</p>\n<p>It <em>is</em> planned for inclusion in C++0x.  That specifies (\u00a718.5):</p>\n<blockquote>\n<p id=\"so_4769229_4769269_0\">The function _Exit(int status) has\n  additional behavior in this\n  International Standard:</p>\n<p id=\"so_4769229_4769269_1\">\u2014 The program is terminated without\n  executing destructors for objects of\n  automatic, thread, or static storage\n  duration and without calling functions\n  passed to atexit() (3.6.3).</p>\n</blockquote>\n<p>Followup:</p>\n<p>ISO approved C++0x on August 12, 2011.</p>\n", "LastActivityDate": "2011-08-31T18:33:29.347"}, "4769314": {"ParentId": "4769229", "CommentCount": "0", "CreationDate": "2011-01-22T17:20:27.083", "OwnerUserId": "585729", "PostTypeId": "2", "Id": "4769314", "Score": "1", "Body": "<p>Calling of static destructors is defined in terms of atexit. _exit (or _Exit) is defined not to run atexit handlers. So static destructors should not be called by any implementation.</p>\n<p>Automatic destructors are not even called when calling exit().</p>\n<p>So any sane definition of _Exit semantics for C++ would not run destructors.</p>\n", "LastActivityDate": "2011-01-22T17:20:27.083"}, "4769281": {"ParentId": "4769229", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2011-01-22T17:15:45.430", "Score": "11", "LastEditorUserId": "36723", "LastEditDate": "2011-01-22T17:30:35.070", "Id": "4769281", "OwnerUserId": "36723", "Body": "<p>First, no form of program exit will automatically call destructors for heap objects (implied in ISO/IEC 14882:1998(E) 12.4.10).</p>\n<p>Calling <code>exit()</code> will not call destructors for objects with automatic duration, as it does not return through their enclosing scopes (3.6.1.4). However, destructors for static objects <em>will</em> be called, in reverse order of construction (18.3.8).</p>\n<p>Calling <code>abort()</code> does not call any destructors for any type of object, nor does it call <code>atexit()</code> registered functions (18.3.3). The C++ standard copy I have here is a bit dated and does not mention <code>_exit</code> or <code>_Exit</code> directly, but I'd imagine that, if present, they should behave the same - that is, not calling any destructors. In particular, in the C99 standard, <code>_Exit()</code> skips <code>atexit</code> handlers (it is implementation defined whether stream buffers are flushed, open streams are closed, or temporary files removed).</p>\n<p>Further note that <code>abort()</code> can be cancelled by trapping signal <code>SIGABRT</code> (ISO/IEC 9899:1999 (E) 7.20.4.1.2 - I only have C99 here but I expect it would be the same in the version referenced by C++). <code>_Exit()</code> cannot.</p>\n<p>On a more practical note, on most unix implementations of <code>abort()</code> and <code>_exit()</code>, <code>abort()</code> raises a <code>SIGABRT</code> while <code>_exit()</code> simply calls an operating system call to terminate the process immediately. This means that the main differences are:</p>\n<ul>\n<li>You can specify an exit code for <code>_exit()</code></li>\n<li><code>abort()</code> may be trapped by a signal handler</li>\n<li>Depending on system configuration, OS, and ulimits, <code>abort()</code> may result in a core dump or similar</li>\n</ul>\n<p>In a <code>fork()/exec()</code> pattern, <code>_exit()</code> would probably be preferable, to avoid the possibility of core dump.</p>\n", "LastActivityDate": "2011-01-22T17:30:35.070"}, "4769272": {"ParentId": "4769229", "CommentCount": "0", "CreationDate": "2011-01-22T17:14:44.547", "OwnerUserId": "383795", "PostTypeId": "2", "Id": "4769272", "Score": "1", "Body": "<p>There is an interesting analysis <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2383.html\" rel=\"nofollow\">here</a> in relation with concurrency and object destruction. As far as I know, destructors will not be called. There is nothing about it in the current standard.</p>\n", "LastActivityDate": "2011-01-22T17:14:44.547"}, "5031241": {"ParentId": "4769229", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-02-17T15:50:43.937", "Score": "0", "LastEditorUserId": "86967", "LastEditDate": "2011-02-20T04:30:06.603", "Id": "5031241", "OwnerUserId": "86967", "Body": "<p><code>fork()</code>, <code>exec()</code>, and <code>_exit()</code> are all defined by POSIX and they pre-date C99's <code>_Exit()</code> by many years.  Programs that use <code>fork</code>/<code>exec</code>/<code>_exit</code> are not portable to every system that supports C++.</p>\n<p>With regard to <code>_exit()</code> specifically, it is an operating system call that (under POSIX) will close files and terminate the process directly (but not necessarily quickly).  This would bypass any C++ mechanisms for calling destructors.</p>\n<p>Even with <code>_Exit()</code> or similar being provided by C++0x, I doubt if there would be much reason to use that in conjunction with fork.  It likely just provides broader portability for a \"quick-exit\" in other contexts.  That functionality is already covered by <code>_exit()</code> if you are using the POSIX API.</p>\n<p>Program termination is addressed in C++2003 section [3.6.3].  It says that static objects are destructed implicitly when <code>main()</code> returns and when <code>exit()</code> is called.  It also says that such objects are NOT destructed when <code>abort()</code> is called.  <code>_exit()</code> isn't addressed in the C++ 2003 standard, but the fact that it is meant to bypass language-specific cleanup is described in the POSIX documentation.  That effect is further substantiated by what is stated and by what is NOT stated in the C++ standard.</p>\n", "LastActivityDate": "2011-02-20T04:30:06.603"}, "4769305": {"ParentId": "4769229", "CommentCount": "2", "CreationDate": "2011-01-22T17:19:14.367", "OwnerUserId": "9530", "PostTypeId": "2", "Id": "4769305", "Score": "3", "Body": "<p>Technically, <code>_Exit</code> is not defined by the C++ standard, so you can't even call it from a 100% portable C++ program.  The C++03 standard incorporates by reference the C89 standard (aka C90 or ANSI C), whereas <code>_Exit</code> is only defined in the newer C99 standard.  I'm not sure which version of C the upcoming C++0x standard incorporates, but I would guess that it's based on C99.</p>\n<p>In any case, though, here are the relevant clauses from the relevant language standards:</p>\n<p><code>_Exit</code> is not guaranteed to close file descriptors.  From C99 \u00a77.20.4.4/2 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_4769229_4769305_0\">The <code>_Exit</code> function causes normal program termination to occur and control to be returned to the host environment. No functions registered by the <code>atexit</code> function or signal handlers registered by the <code>signal</code> function are called. The status returned to the host environment is determined in the same way as for the <code>exit</code> function (7.20.4.3). <strong>Whether open streams with unwritten buffered data are flushed, open streams are closed, or temporary files are removed is implementation-defined.</strong></p>\n</blockquote>\n<p>Recall that <em>implementation-defined</em> means that the implementation (that is, the compiler toolchain and runtime environment) can choose to do whatever it wants, but <em>it must document what it does</em>.</p>\n<p>From C++03 \u00a73.6.3/1:</p>\n<blockquote>\n<p id=\"so_4769229_4769305_1\">Destructors (12.4) for initialized objects of static storage duration (declared at block scope or at namespace scope) are called as a result of returning from main and as a result of calling <code>exit</code> (18.3). These objects are destroyed in the reverse order of the completion of their constructor or of the completion of their dynamic initialization. If an object is initialized statically, the object is destroyed in the same order as if the object was dynamically initialized. For an object of array or class type, all subobjects of that object are destroyed before any local object with static storage duration initialized during the construction of the subobjects is destroyed.</p>\n</blockquote>\n<p>\u00a73.6.3/4:</p>\n<blockquote>\n<p id=\"so_4769229_4769305_2\">Calling the function</p>\n<p id=\"so_4769229_4769305_3\">\u00a0\u00a0\u00a0\u00a0<code>void abort();</code></p>\n<p id=\"so_4769229_4769305_4\">declared in <code>&lt;cstdlib&gt;</code> terminates the program without executing destructors for objects of automatic or static storage duration and without calling the functions passed to <code>atexit()</code>.</p>\n</blockquote>\n<p>Practically, in most implementations, global object destructors are implemented via <a href=\"http://linux.die.net/man/3/atexit\" rel=\"nofollow\"><code>atexit</code></a>, so what you will see is that <code>_Exit</code> will not call the destructors for global objects, although this behavior is not guaranteed (since <code>_Exit</code> and C++ are not guaranteed to both exist in the same language).</p>\n", "LastActivityDate": "2011-01-22T17:19:14.367"}, "bq_ids": {"n4140": {"so_4769229_4769305_1": {"section_id": 7156, "quality": 0.746031746031746, "length": 47}, "so_4769229_4769305_4": {"section_id": 6800, "quality": 0.7857142857142857, "length": 11}, "so_4769229_4769269_0": {"section_id": 6800, "quality": 0.75, "length": 6}, "so_4769229_4769269_1": {"section_id": 6800, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_4769229_4769305_1": {"section_id": 6900, "quality": 0.746031746031746, "length": 47}, "so_4769229_4769305_4": {"section_id": 6555, "quality": 0.7857142857142857, "length": 11}, "so_4769229_4769269_0": {"section_id": 6555, "quality": 0.75, "length": 6}, "so_4769229_4769269_1": {"section_id": 6555, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_4769229_4769269_1": {"section_id": 8290, "quality": 0.8666666666666667, "length": 13}, "so_4769229_4769305_4": {"section_id": 8290, "quality": 0.7857142857142857, "length": 11}, "so_4769229_4769305_1": {"section_id": 8663, "quality": 0.5555555555555556, "length": 35}}}});