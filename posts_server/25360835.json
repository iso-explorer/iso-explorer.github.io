post_cb({"bq_ids": {"n4140": {"so_25360835_25362435_4": {"length": 30, "quality": 0.967741935483871, "section_id": 660}, "so_25360835_25362435_0": {"length": 23, "quality": 0.92, "section_id": 3296}, "so_25360835_25360906_0": {"length": 25, "quality": 0.8064516129032258, "section_id": 450}, "so_25360835_25362435_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 6176}, "so_25360835_25362435_1": {"length": 6, "quality": 1.0, "section_id": 3296}, "so_25360835_25362435_2": {"length": 40, "quality": 0.8888888888888888, "section_id": 3296}}, "n3337": {"so_25360835_25362435_4": {"length": 30, "quality": 0.967741935483871, "section_id": 650}, "so_25360835_25362435_0": {"length": 23, "quality": 0.92, "section_id": 3166}, "so_25360835_25360906_0": {"length": 25, "quality": 0.8064516129032258, "section_id": 441}, "so_25360835_25362435_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 5937}, "so_25360835_25362435_1": {"length": 6, "quality": 1.0, "section_id": 3166}, "so_25360835_25362435_2": {"length": 40, "quality": 0.8888888888888888, "section_id": 3166}}, "n4659": {"so_25360835_25362435_4": {"length": 30, "quality": 0.967741935483871, "section_id": 688}, "so_25360835_25362435_0": {"length": 23, "quality": 0.92, "section_id": 4058}, "so_25360835_25360906_0": {"length": 25, "quality": 0.8064516129032258, "section_id": 472}, "so_25360835_25362435_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 7678}, "so_25360835_25362435_1": {"length": 6, "quality": 1.0, "section_id": 4058}, "so_25360835_25362435_2": {"length": 40, "quality": 0.8888888888888888, "section_id": 4058}}}, "25362435": {"Id": "25362435", "PostTypeId": "2", "Body": "<p>This is standard behavior. </p>\n<p>I searched in the latest C++ standard, ISO/IEC 14882:2011(E), Programming Language C++.</p>\n<p>The following code</p>\n<pre><code>A obj1 = 2;\n</code></pre>\n<p>Is an initialization. It is described in section 8.5 initializers, clause 16.</p>\n<blockquote>\n<p id=\"so_25360835_25362435_0\">16 The semantics of initializers are as follows. The destination type is the type of the object or reference being initialized and the source type is the type of the initializer expression. If the initializer is not a single (possibly parenthesized) expression, the source type is not defined.</p>\n</blockquote>\n<p>Following part of this clause is very long. I only reference which related to your sample code.</p>\n<blockquote>\n<p id=\"so_25360835_25362435_1\">\u2014 If the destination type is a (possibly cv-qualified) class type:</p>\n<p id=\"so_25360835_25362435_2\">\u2014 If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified version of the source type is the same class as, or a derived class of, the class of the destination, constructors are considered. The applicable constructors are enumerated (13.3.1.3), and the best one is chosen through overload resolution (13.3). The constructor so selected is called to initialize the object, with the initializer expression or expression-list as its argument(s). If no constructor applies, or the overload esolution is ambiguous, the initialization is ill-formed.</p>\n</blockquote>\n<p>Section 13.3.1.3 is Initialization by constructor. </p>\n<p>Accroding to 8.5 and 13.3.1.3, the constructor </p>\n<pre><code>A(int);\n</code></pre>\n<p>is selected to initialize obj1.</p>\n<hr>\n<p>As for the second one</p>\n<pre><code>obj1 = 3;\n</code></pre>\n<p>This behavior is defined by 5.17 Assignment and compound assignment operators, clause 4. </p>\n<blockquote>\n<p id=\"so_25360835_25362435_3\">4 If the left operand is of class type, the class shall be complete. Assignment to objects of a class is defined by the copy/move assignment operator (12.8, 13.5.3).</p>\n</blockquote>\n<p>13.5.3 Assignment, clause 1.</p>\n<blockquote>\n<p id=\"so_25360835_25362435_4\">1 An assignment operator shall be implemented by a non-static member function with exactly one parameter. Because a copy assignment operator operator= is implicitly declared for a class if not declared by the user (12.8), a base class assignment operator is always hidden by the copy assignment operator of the derived class.</p>\n</blockquote>\n<p>Function</p>\n<pre><code>void operator =(int);\n</code></pre>\n<p>is selected for     </p>\n<pre><code>obj1 = 3;\n</code></pre>\n<p>according to overload rule.</p>\n</hr>", "LastEditorUserId": "759866", "LastActivityDate": "2014-09-15T07:52:06.370", "Score": "1", "CreationDate": "2014-08-18T11:39:04.667", "ParentId": "25360835", "CommentCount": "0", "OwnerUserId": "2097803", "LastEditDate": "2014-09-15T07:52:06.370"}, "25360906": {"Id": "25360906", "PostTypeId": "2", "Body": "<p>It is standard, and I guess it is not surprising that constructor is for initialisation, and assignment operator is used for assignment. In the C++ standard the section 12.8 - Copying and moving class objects - starts with</p>\n<blockquote>\n<p id=\"so_25360835_25360906_0\">A class object can be copied or moved in two ways: by initialization (12.1, 8.5), including for function argument passing (5.2.2) and for function value return (6.6.3); and by assignment (5.17). Conceptually, these two operations are implemented by a copy/move constructor (12.1) and copy/move assignment operator (13.5.3).</p>\n</blockquote>\n", "LastActivityDate": "2014-08-18T10:14:19.677", "CommentCount": "0", "CreationDate": "2014-08-18T10:14:19.677", "ParentId": "25360835", "Score": "2", "OwnerUserId": "2382136"}, "25360835": {"ViewCount": "384", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A{\n\nprivate:\n    int a;\npublic:\n    A(int);\n    void print();\n    void operator =(int);\n};\n\n// One argument constructor\nA::A(int b){\n    cout&lt;&lt;\"Inside one argument constructor\"&lt;&lt;endl;\n    this-&gt;a=b;\n}\n\nvoid A:: operator =(int b){\n    cout&lt;&lt;\"Inside operator function\"&lt;&lt;endl;\n    this-&gt;a = b;\n}\n\nvoid A::print(){\n    cout&lt;&lt;\"Value of a =\"&lt;&lt;a&lt;&lt;endl;\n}\n\nint main() {\n\n    /* INITIALIZATION */\n    A obj1=2;\n    obj1.print();\n\n    /* ASSIGNMENT */\n    obj1=3;\n    obj1.print();\n\n    return 0;\n}\n</code></pre>\n<p>The output of the above code can be seen here: <a href=\"http://ideone.com/0hnZUb\" rel=\"nofollow\">http://ideone.com/0hnZUb</a> . It is:</p>\n<pre><code>Inside one argument constructor\nValue of a =2\nInside operator function\nValue of a =3\n</code></pre>\n<p>So what I have observed is that during initialization, the one-argument constructor is called but during assignment, the overloaded assignment operator function is called. Is this behavior enforced by the C++ standard, or is it compiler specific? Could anyone quote the section from the standard that defines this behavior?</p>\n", "AcceptedAnswerId": "25362435", "Title": "One argument constructor and assignment operator", "CreationDate": "2014-08-18T10:10:37.000", "Id": "25360835", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-09-15T07:52:06.370", "Score": "1", "OwnerUserId": "364651", "Tags": "<c++>", "AnswerCount": "2"}});