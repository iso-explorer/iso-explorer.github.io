post_cb({"20726834": {"Id": "20726834", "PostTypeId": "2", "Body": "<p>assert.h defines one macro function that can be used as a standard debugging tool.</p>\n", "LastActivityDate": "2013-12-22T06:22:50.257", "CommentCount": "0", "CreationDate": "2013-12-22T06:22:50.257", "ParentId": "10625716", "Score": "0", "OwnerUserId": "2680024"}, "10625744": {"Id": "10625744", "PostTypeId": "2", "Body": "<p>Just like any other header file, you <code>#include &lt;cassert&gt;</code> when you use something declared in that header file, such as <code>assert()</code>.</p>\n", "LastActivityDate": "2012-05-16T19:55:44.627", "CommentCount": "1", "CreationDate": "2012-05-16T19:55:44.627", "ParentId": "10625716", "Score": "7", "OwnerUserId": "893"}, "bq_ids": {"n4140": {"so_10625716_10626042_0": {"length": 19, "quality": 0.95, "section_id": 4907}, "so_10625716_10626042_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 4908}}, "n3337": {"so_10625716_10626042_0": {"length": 19, "quality": 0.95, "section_id": 4702}, "so_10625716_10626042_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 4703}}, "n4659": {"so_10625716_10626042_0": {"length": 19, "quality": 0.95, "section_id": 6316}, "so_10625716_10626042_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 6317}}}, "10625792": {"Id": "10625792", "PostTypeId": "2", "Body": "<p>See an easily accessible <a href=\"http://en.cppreference.com/w/cpp/error/assert\" rel=\"nofollow\">reference</a></p>\n<pre><code>#include &lt;iostream&gt;\n// uncomment to disable assert()\n// #define NDEBUG\n#include &lt;cassert&gt;\n\nint main()\n{\n    assert(2+2==4);\n    std::cout &lt;&lt; \"Execution continues past the first assert\\n\";\n    assert(2+2==5);\n    std::cout &lt;&lt; \"Execution continues past the second assert\\n\";\n}\n</code></pre>\n", "LastEditorUserId": "819272", "LastActivityDate": "2012-05-16T20:09:51.337", "Score": "0", "CreationDate": "2012-05-16T19:58:46.100", "ParentId": "10625716", "CommentCount": "3", "OwnerUserId": "819272", "LastEditDate": "2012-05-16T20:09:51.337"}, "10625716": {"ViewCount": "13513", "Body": "<p>In what cases should we include <strong>cassert</strong>?</p>\n", "Title": "In what cases we need to include <cassert>?", "CreationDate": "2012-05-16T19:53:28.130", "LastActivityDate": "2016-06-29T18:59:26.450", "CommentCount": "5", "FavoriteCount": "11", "PostTypeId": "1", "LastEditDate": "2012-05-16T20:30:35.007", "LastEditorUserId": "845092", "Id": "10625716", "Score": "37", "OwnerUserId": "1377855", "Tags": "<c++><header-files><assert>", "AnswerCount": "4"}, "10626042": {"Id": "10626042", "PostTypeId": "2", "Body": "<p>In short, don't use it; use <code>&lt;assert.h&gt;</code>.</p>\n<p>C++11 removed any formal guarantee of a \"c....\" header not polluting the global namespace.</p>\n<p>It was never an in-practice guarantee, and now it's not even a formal guarantee.</p>\n<p>Hence, with C++11 there is no longer any conceivable advantage in using the \"c....\" header variants, while there is the distinct and clear disadvantage that code that works well with one compiler and version of that compiler, may fail to compile with another compiler or version, due to e.g. name collisions or different overload selection in the global namespace.</p>\n<p>SO, while <code>cassert</code> was pretty meaningless in C++03 (you can't put a macro in a namespace), it is totally meaningless -- even as a special case of a general scheme -- in C++11.</p>\n<hr>\n<p><strong>Addendum</strong>, Dec 22 2013:</p>\n<p>The standard defines each C++ <em>C header</em> &lt;X.h&gt; header in terms of the &lt;cX&gt; header, which in turn is defined in terms of the corresponding C library header.</p>\n<p><strong>C++11 \u00a7D.5/2</strong>:</p>\n<blockquote>\n<p id=\"so_10625716_10626042_0\">\u201cEvery C header, each of which has a name of the form <code>name.h</code>, behaves as if each name placed in the standard library namespace by the corresponding <em>cname</em> header is placed within the global namespace scope.\u201d</p>\n</blockquote>\n<p><strong>C++11 \u00a7D.5/3</strong> (non-normative example):</p>\n<blockquote>\n<p id=\"so_10625716_10626042_1\">\u201cThe header <code>&lt;cstdlib&gt;</code> assuredly provides its declarations and definitions within the namespace <code>std</code>. It may also provide these names within the global namespace. The header <code>&lt;stdlib.h&gt;</code> assuredly provides the same declarations and definitions within the global namespace, much as in the C Standard. It may also provide these names within the namespace <code>std</code>.\u201d</p>\n</blockquote>\n<p>Stack Overflow user <a href=\"https://stackoverflow.com/users/832878/c-r\">C.R.</a>\u2019s comment made me aware that some versions of g++, such as MinGW g++ 4.7.2, are quite <strong>non-standard</strong> with respect to the <code>&lt;X.h&gt;</code> headers, lacking the overloads of e.g. <code>sin</code> that the C++ standard requires:</p>\n<p>I already knew that MinGW g++ 4.7.2 also entirely lacks functions such as <code>swprintf</code>, and that it has ditto shortcomings in the pure C++ library such as lacking C++11 <code>std::to_string</code>. However, the information about it lacking the C function overloads was new to me.</p>\n<p>In practice the lacking overloads with g++ means</p>\n<ul>\n<li><p>ignoring the g++ issue, or</p></li>\n<li><p>avoiding using the missing g++ overloads,<br>\ne.g. using only <code>double sin( double )</code>, or</br></p></li>\n<li><p>using the <code>std</code> namespace overloads<br>\n(one then needs to include <code>&lt;cmath&gt;</code> to guarantee their presence with g++).</br></p></li>\n</ul>\n<p>In order to use the g++ <code>std</code> namespace overloads unqualified, one practical approach is to define <strong>headers wrappers</strong> for this compiler. I've used that approach to address g++ shortcomings wrt. to the <code>printf</code> family. For as David Wheeler once remarked, \u201cAll problems in computer science can be solved by another level of indirection\u201d\u2026</p>\n<p>Then things can be arranged so that standard code that uses g++'s missing overloads, also compiles with g++. This adjusts the compiler to the standard, with a fixed amount of code.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-06-29T18:59:26.450", "Score": "39", "CreationDate": "2012-05-16T20:15:35.810", "ParentId": "10625716", "CommentCount": "8", "OwnerUserId": "464581", "LastEditDate": "2017-05-23T12:26:23.613"}});