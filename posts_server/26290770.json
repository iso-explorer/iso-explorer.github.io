post_cb({"bq_ids": {"n4140": {"so_26290770_26290930_1": {"length": 21, "quality": 0.84, "section_id": 7223}, "so_26290770_26290930_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 91}, "so_26290770_26290930_0": {"length": 8, "quality": 1.0, "section_id": 57}}, "n3337": {"so_26290770_26290930_1": {"length": 21, "quality": 0.84, "section_id": 6967}, "so_26290770_26290930_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 86}, "so_26290770_26290930_0": {"length": 8, "quality": 1.0, "section_id": 52}}, "n4659": {"so_26290770_26290930_1": {"length": 20, "quality": 0.8, "section_id": 8732}, "so_26290770_26290930_0": {"length": 8, "quality": 1.0, "section_id": 59}}}, "26290930": {"Id": "26290930", "PostTypeId": "2", "Body": "<p>\u00a714.1 [temp.param]/p4 says:</p>\n<blockquote>\n<p id=\"so_26290770_26290930_0\">A non-type <em>template-parameter</em> shall have one of the following\n  (optionally cv-qualified) types:</p>\n<ul>\n<li>integral or enumeration type,</li>\n<li>pointer to object or pointer to function,</li>\n<li>lvalue reference to object or lvalue reference to function,</li>\n<li>pointer to member,</li>\n<li><code>std::nullptr_t</code>.</li>\n</ul>\n</blockquote>\n<p>Read literally, this disallows <code>void*</code> template parameters altogether. <code>void*</code> is an <em>object pointer type</em> but isn't a pointer to object type (\u00a73.9.2 [basic.compound]/p3):</p>\n<blockquote>\n<p id=\"so_26290770_26290930_1\">The type of a pointer to <code>void</code> or a pointer to an object type is\n  called an <em>object pointer type</em>. [ <em>Note</em>: A pointer to <code>void</code> does\n  not have a pointer-to-object type, however, because <code>void</code> is not an\n  object type. \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>If we assume it's a defect and that the standard really meant to say \"object pointer type\", then using <code>0</code> and company is still disallowed by \u00a714.3.2 [temp.arg.nontype]/p5 (emphasis added):</p>\n<blockquote>\n<p id=\"so_26290770_26290930_2\">The following conversions are performed on each expression used as a\n  non-type <em>template-argument</em>. If a non-type <em>template-argument</em> cannot be\n  converted to the type of the corresponding <em>template-parameter</em> then the\n  program is ill-formed.</p>\n<ul>\n<li>[...]</li>\n<li>for a non-type <em>template-parameter</em> of type pointer to object, qualification conversions (4.4) and the array-to-pointer conversion\n  (4.2) are applied; if the <em>template-argument</em> is of type <code>std::nullptr_t</code>,\n  the null pointer conversion (4.10) is applied. [ <em>Note</em>: <strong>In particular,\n  neither the null pointer conversion for a zero-valued integer literal\n  (4.10) nor the derived-to-base conversion (4.10) are applied.</strong> Although\n  0 is a valid <em>template-argument</em> for a non-type <em>template-parameter</em> of\n  integral type, it is not a valid <em>template-argument</em> for a non-type\n  <em>template-parameter</em> of pointer type. However, both <code>(int*)0</code> and <code>nullptr</code>\n  are valid <em>template-arguments</em> for a non-type template-parameter of type\n  \u201cpointer to int.\u201d \u2014<em>end note</em> ]</li>\n</ul>\n</blockquote>\n<p><code>= 0</code> works for function default arguments because those are subject to the normal conversion rules, which allows an integer literal with value 0 to convert to a null pointer, rather than the special rules for template arguments.</p>\n<hr>\n<blockquote>\n<p id=\"so_26290770_26290930_3\">if I remove the whitespace between * and =, it also failed. Why is that?</p>\n</blockquote>\n<p>Maximum munch. If the whitespace is removed, <code>*=</code> is a single token (the compound assignment operator). Just like in C++03 when you had to put a space between the <code>&gt;</code>s in <code>std::vector&lt;std::vector&lt;int&gt; &gt;</code>.</p>\n</hr>", "LastEditorUserId": "2756719", "LastActivityDate": "2014-10-10T02:33:03.640", "Score": "9", "CreationDate": "2014-10-10T02:15:44.037", "ParentId": "26290770", "CommentCount": "1", "OwnerUserId": "2756719", "LastEditDate": "2014-10-10T02:33:03.640"}, "26290770": {"ViewCount": "440", "Body": "<p>I have two version of <code>my_begin</code>:</p>\n<pre><code>template&lt;typename T, typename std::enable_if&lt;std::is_array&lt;T&gt;::value&gt;::type* = 0&gt;\ntypename std::decay&lt;T&gt;::type my_begin(T&amp; array) {\n    return array;\n}\n</code></pre>\n<p>and</p>\n<pre><code>template&lt;typename T&gt;\ntypename std::decay&lt;T&gt;::type my_begin(T&amp; array, \n        typename std::enable_if&lt;std::is_array&lt;T&gt;::value&gt;::type* = 0) {\n    return array;\n}\n</code></pre>\n<p>However the first one does not work and gives error:</p>\n<pre><code>int a[10];\nint* a_it = my_begin(a);\n</code></pre>\n<p>error:</p>\n<pre><code>main.cpp:17:30: note:   template argument deduction/substitution failed:\n\nmain.cpp:16:80: error: could not convert template argument '0' to 'std::enable_if&lt;true, void&gt;::type* {aka void*}'\n\n template&lt;typename T, typename std::enable_if&lt;std::is_array&lt;T&gt;::value&gt;::type* = 0&gt;\n</code></pre>\n<p>But the second one works. When I change 0 in the first one to nullptr, it works too (but still not working for NULL). I do understand that in template it requires explicit casting (in this case, from <code>int</code> to <code>void*</code>, but why the second one does not require it?</p>\n<p>Another question, if I remove the whitespace between <code>*</code> and <code>=</code>, it also failed. Why is that?</p>\n", "AcceptedAnswerId": "26290930", "Title": "Why void* as template parameter works as function parameter but not template parameter?", "CreationDate": "2014-10-10T01:56:06.717", "Id": "26290770", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-10-10T02:33:03.640", "Score": "3", "OwnerUserId": "1270003", "Tags": "<c++><templates><c++11>", "AnswerCount": "1"}});