post_cb({"666697": {"CommentCount": "1", "Body": "<p>What's the content of CFE() ?</p>\n<p>Why not define CFE() as;\nvoid CFE(float *density, float *energy, int NumElem);</p>\n<p>So you don't have to fool around with casts and just do; density[i] = ... inside your loops?</p>\n", "CreationDate": "2009-03-20T15:40:12.853", "OwnerDisplayName": "partouf", "ParentId": "666320", "Id": "666697", "LastActivityDate": "2009-03-20T15:40:12.853", "PostTypeId": "2", "Score": "0", "OwnerUserId": "80473"}, "666508": {"CreationDate": "2009-03-20T14:58:55.793", "ParentId": "666320", "LastEditorDisplayName": "Michael Burr", "Score": "1", "LastEditorUserId": "12711", "CommentCount": "2", "Body": "<p>The code you posted appears to be OK - you'll need to give more detail if you want the problem debugged.  Actually, if you run the program in a debugger, it should be able to tell you exactly which line of code is causing the exception (you may have to look in a call stack), or simply step through the program until it crashes.</p>\n<p>As for the confusion about whether vector can be treated as a C array, it definitely can by getting the address of the first element (ie., <code>&amp;vect[0]</code>) - if the vector contains elements.</p>\n<p>The C++03 standard says this about <code>vector&lt;&gt;</code> in 23.2.4:</p>\n<blockquote>\n<p id=\"so_666320_666508_0\">The elements of a vector are stored contiguously, meaning that if <code>v</code> is a <code>vector&lt;T, Allocator&gt;</code> where <code>T</code> is some type other than <code>bool</code>, then it obeys the identity <code>&amp;v[n] == &amp;v[0] + n</code> for all <code>0 &lt;= n &lt; v.size()</code></p>\n</blockquote>\n<p>Note that this was not explicitly stated in the C++98 standard (but was still the intent).</p>\n<p>See also Herb Sutter's article: </p>\n<ul>\n<li><a href=\"http://herbsutter.wordpress.com/2008/04/07/cringe-not-vectors-are-guaranteed-to-be-contiguous/\" rel=\"nofollow noreferrer\">http://herbsutter.wordpress.com/2008/04/07/cringe-not-vectors-are-guaranteed-to-be-contiguous/</a></li>\n</ul>\n<p>Note that <code>vector&lt;bool&gt;</code> cannot be treated as a C array - it a special case since the elements in <code>vector&lt;bool&gt;</code> are not stored as <code>bool</code>.</p>\n", "Id": "666508", "OwnerDisplayName": "Michael Burr", "LastEditDate": "2009-03-20T15:23:03.817", "LastActivityDate": "2009-03-20T15:23:03.817", "PostTypeId": "2", "OwnerUserId": "12711"}, "bq_ids": {"n4140": {"so_666320_666508_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 955}}, "n3337": {"so_666320_666508_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 943}}}, "666455": {"CommentCount": "0", "Body": "<p>The code that you've posted is correct.  Provided that every access to an array element inside of <code>CFE()</code> is within bounds, you shouldn't be getting a segmentation fault.  Try running your program under <a href=\"http://valgrind.org/\" rel=\"nofollow noreferrer\">valgrind</a> and see if it reports anything unusual.</p>\n", "CreationDate": "2009-03-20T14:48:51.307", "OwnerDisplayName": "Adam Rosenfield", "ParentId": "666320", "Id": "666455", "LastActivityDate": "2009-03-20T14:48:51.307", "PostTypeId": "2", "Score": "0", "OwnerUserId": "9530"}, "666334": {"CreationDate": "2009-03-20T14:19:34.640", "ParentId": "666320", "LastEditorDisplayName": "Pablo Santa Cruz", "Score": "0", "LastEditorUserId": "67606", "CommentCount": "5", "Body": "<p>You can't do that. Vector class is not the same as a C-like array.</p>\n<p>You must convert it to a regular C array before passing it to CFE function.</p>\n<p>Edit:\nApparently my answer is wrong. Check Neil's post.</p>\n", "Id": "666334", "OwnerDisplayName": "Pablo Santa Cruz", "LastEditDate": "2009-03-20T14:43:05.877", "LastActivityDate": "2009-03-20T14:43:05.877", "PostTypeId": "2", "OwnerUserId": "67606"}, "666352": {"LastActivityDate": "2009-03-20T14:57:14.937", "CommentCount": "4", "Body": "<p>Provided you stay within the bounds of the vector, what you are doing would seem to be OK.</p>\n<p><strong>You can treat a std::vector exactly as if it were a C array by doing what you are doing - taking the address of the first element. The C++ Standard has been changed to specifically allow this kind of usage.</strong></p>\n<p>Can't find a copy of C++ the Technical Corrigendum 2003 at present, but apparently the relevant section ref is 23.2.4, </p>\n", "CreationDate": "2009-03-20T14:23:10.807", "OwnerDisplayName": "anon", "LastEditDate": "2009-03-20T14:57:14.937", "ParentId": "666320", "Id": "666352", "LastEditorDisplayName": "anon", "PostTypeId": "2", "Score": "11"}, "666320": {"CreationDate": "2009-03-20T14:16:02.587", "ViewCount": "395", "Id": "666320", "AcceptedAnswerId": "666352", "Score": "1", "Title": "Accessing public class memory from C++ using C", "CommentCount": "2", "Body": "<p>Greetings Everyone.</p>\n<p>I'm currently writing a multi-language programe in C, C++ and fortran on UNIX, unfortunatly I run into \"Segmentation Error\" when I try and execute after compiling. </p>\n<p>I've narrowed down the problem to the interface between the C++ and C sections of my program. The first section consists of main.ccp and SA.cpp, and the second CFE.c. </p>\n<p>A class called 'SimAnneal' exsists in SA.cpp, with public vectors DensityArray and ElementArray. The order of the program follows:</p>\n<ol>\n<li><p>Create SimAnneal Object 'Obj1' and call function ObjFunction()</p></li>\n<li><p>That function initializes the vector sizes</p></li>\n<li><p>Call CFE(...) with pointers to both vectors and their length.</p></li>\n<li><p>CFE.c edits the data elements of the vectors directly via use of the pointers</p></li>\n<li><p>ObjFunction() uses EnergyArray (and possible DensityArray) data.</p></li>\n</ol>\n<p>The relevant script is below for all sources:</p>\n<p>main.cpp</p>\n<pre><code>#include \"SA.h\" \n\nint main() \n{   \n    SimAnneal Obj1;\n\n    Obj1.ObjFunction();\n\n    return 0;\n}\n</code></pre>\n<p>SA.h</p>\n<pre><code>class SimAnneal \n{\n    void Initialize ();\n    ...\n  public\n    std::vector&lt;float&gt; DensityArray; \n    std::vector&lt;float&gt; EnergyArray;\n    double ObjFunction ();\n    ...\n}\n</code></pre>\n<p>SA.cpp</p>\n<pre><code>#include \"CFE.h\"\n\nvoid SimAnneal::Initialize ()\n{\n    int length = 15;\n    EnergyArray.resize(length);\nDensityArray.resize(length);\n}\n\ndouble SimAnneal::ObjFunction () \n{\n    Initialize ();\n\n    CFE(&amp;DensityArray[0], &amp;EnergyArray[0], DensityArray.size()); \n\n      // sends pointers of both arrays to CFE.c, which will then \n      // directly modify the array\n\n    double SumStrainEnergy = 0;\n\n    for (int i = 0; i &lt; EnergyArray.size(); i++)\n    {\n        SumStrainEnergy += EnergyArray[i];  //Effectively sum of array \n                                            //engy[] from CFE.c\n    }\n\n    return SumStrainEnergy;\n}\n</code></pre>\n<p>CFE.h</p>\n<pre><code>#ifdef __cplusplus\nextern \"C\" {\n#endif \n\nvoid CFE(float density[], float energy[], int NumElem);\n\n#ifdef __cplusplus\n }\n#endif\n</code></pre>\n<p>CFE.c</p>\n<pre><code>void CFE(float density[], float energy[], int NumElem)\n{\n    ...\n\n    float * dens;\n    dens = density;  //pass pointer of array density[0] in SA.cpp to CFE.c\n\n    for(n=0; n&lt;NumElem; n++)\n    { ... modify dens (e.g. DensityArray from SA.cpp) ... }\n\n    float * engy;\n    engy = energy; //pass pointer of array energy[0] in SA.cpp to CFE.c\n\n    for(n=0; n&lt;NumElem; n++)\n    { ... modify engy (e.g. EnergyArray from SA.cpp) ... }   \n}\n</code></pre>\n<p>Am I causing an illegal memory access by trying to access the vector elements from the C portion of my program? Is there any sure way to allow this?</p>\n<p>Any help would be much appriciated.</p>\n", "Tags": "<c++><c><memory><class>", "OwnerDisplayName": "Raugnar", "LastActivityDate": "2009-03-20T15:40:12.837", "PostTypeId": "1", "AnswerCount": "5", "OwnerUserId": "73484"}});