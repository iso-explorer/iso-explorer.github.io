post_cb({"bq_ids": {"n4140": {"so_8555175_8555343_0": {"length": 28, "quality": 0.7368421052631579, "section_id": 6045}}, "n3337": {"so_8555175_8555343_0": {"length": 33, "quality": 0.868421052631579, "section_id": 5814}}, "n4659": {"so_8555175_8555343_0": {"length": 28, "quality": 0.7368421052631579, "section_id": 7544}}}, "8555427": {"Id": "8555427", "PostTypeId": "2", "Body": "<p>The intent is clear (and not something that needs to be debated):</p>\n<p><strong><code>reinterpret_cast</code> never changes the value of an address</strong>, unless the target type cannot represent all address values (like a small integer type, on a pointer type with intrinsic alignment: f.ex. a pointer that can only represent even addresses, or pointers to object and pointers to functions cannot be mixed...).</p>\n<p>The wording of the standard fails to capture that, but that doesn't mean there is a real practical issue here.</p>\n<pre><code>char *c = reinterpret_cast&lt;char*&gt;(&amp;d);\n</code></pre>\n<p><code>c</code> will point to the first byte of <code>d</code>, always.</p>\n", "LastActivityDate": "2011-12-18T22:40:20.607", "Score": "0", "CreationDate": "2011-12-18T22:40:20.607", "ParentId": "8555175", "CommentCount": "0", "OwnerUserId": "963864"}, "8555175": {"ViewCount": "265", "Body": "<p>According to strict aliasing rules:</p>\n<pre><code>struct B { virtual ~B() {} };\nstruct D : public B { };\n\nD d;\nchar *c = reinterpret_cast&lt;char*&gt;(&amp;d);\n</code></pre>\n<p>A <code>char*</code> to any object of different type is valid. But now the question is, will it point to the same address of &amp;d? what is the guarantee made by C++ Standard that it will return the same address?</p>\n", "AcceptedAnswerId": "8555566", "Title": "char* conversion and aliasing rules", "CreationDate": "2011-12-18T22:02:19.300", "Id": "8555175", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-12-18T23:39:07.350", "LastEditorUserId": "1086635", "LastActivityDate": "2011-12-19T00:45:04.443", "Score": "5", "OwnerUserId": "1086635", "Tags": "<c++><pointers><reinterpret-cast><strict-aliasing>", "AnswerCount": "3"}, "8555566": {"Id": "8555566", "PostTypeId": "2", "Body": "<p><code>c</code> and <code>&amp;d</code> do indeed have the same value, and if you reinterpret-cast <code>c</code> back to a <code>D*</code> you get a valid pointer that you may dereference. Furthermore, you can treat <code>c</code> as (pointer to the first element of) an opaque array <code>char[sizeof(D)]</code> -- this is indeed the main purpose of casting pointers to char pointers: To allow (de)serialization (e.g. <code>ofile.write(c, sizeof(D));</code>), although you should generally only do this for primitive types (and arrays thereof), since the binary layout of of compound types is not generally specified in a portable fashion.</p>\n<p>As @Oli rightly points out and would like me to reinforce, you should really never serialize compound types as a whole. The result will almost never be deserializable, since the implementation of polymorphic classes and padding between data fields is not specified and not accessible to you.</p>\n<p>Note that <code>reinterpret_cast&lt;char*&gt;(static_cast&lt;B*&gt;(&amp;d))</code> may be treated as an opaque array <code>char[sizeof(B)]</code> by similar reasoning.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2011-12-19T00:25:28.080", "Score": "6", "CreationDate": "2011-12-18T23:05:28.893", "ParentId": "8555175", "CommentCount": "7", "LastEditDate": "2011-12-19T00:25:28.080", "OwnerUserId": "596781"}, "8555343": {"Id": "8555343", "PostTypeId": "2", "Body": "<p>Section 5.2.10, point 7 of the 2003 C++ Standard says:</p>\n<blockquote>\n<p id=\"so_8555175_8555343_0\">A pointer to an object can be explicitly converted to a pointer to an\n  object of different type. Except that converting an rvalue of type\n  \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are\n  object types and where the alignment requirements of T2 are no\n  stricter than those of T1) and <strong>back to its original type yields the\n  original pointer value</strong>, the result of such a pointer conversion is\n  unspecified.</p>\n</blockquote>\n<p>If by \"same address\" you mean \"original pointer value,\" then this entry says \"yes.\"</p>\n", "LastEditorUserId": "124755", "LastActivityDate": "2011-12-19T00:45:04.443", "Score": "2", "CreationDate": "2011-12-18T22:28:18.350", "ParentId": "8555175", "CommentCount": "0", "LastEditDate": "2011-12-19T00:45:04.443", "OwnerUserId": "124755"}});