post_cb({"17233649": {"ParentId": "17233547", "LastEditDate": "2016-06-27T04:22:47.337", "CommentCount": "10", "CreationDate": "2013-06-21T11:02:00.407", "Score": "107", "LastEditorUserId": "1621391", "PostTypeId": "2", "Id": "17233649", "OwnerUserId": "1932150", "Body": "<p>Generic lambdas were introduced in <strong><code>C++14</code></strong>. </p>\n<p>Simply, the closure type defined by the lambda expression will have a <em>templated</em> call operator rather than the regular, non-template call operator of <strong><code>C++11</code></strong>'s lambdas (of course, when <code>auto</code> appears at least once in the parameter list). </p>\n<p>So your example:</p>\n<pre><code>auto glambda = [] (auto a) { return a; };\n</code></pre>\n<p>Will make <code>glambda</code> an instance of this type:</p>\n<pre><code>class /* unnamed */\n{\npublic:\n    template&lt;typename T&gt;\n    T operator () (T a) const { return a; }\n};\n</code></pre>\n<p>Paragraph 5.1.2/5 of the C++14 Standard Draft n3690 specifies how the call operator of the closure type of a given lambda expression is defined:</p>\n<blockquote>\n<p id=\"so_17233547_17233649_0\">The closure type for a non-generic lambda-expression has a public inline function call operator (13.5.4)\n  whose parameters and return type are described by the lambda-expression\u2019s parameter-declaration-clause\n  and trailing-return-type respectively. <strong>For a generic lambda, the closure type has a public inline function call\n  operator member template (14.5.2) whose template-parameter-list consists of one invented type template-parameter\n  for each occurrence of auto in the lambda\u2019s parameter-declaration-clause, in order of appearance</strong>.\n  The invented type template-parameter is a parameter pack if the corresponding parameter-declaration declares\n  a function parameter pack (8.3.5). The return type and function parameters of the function call\n  operator template are derived from the lambda-expression\u2019s trailing-return-type and parameter-declarationclause\n  by replacing each occurrence of auto in the decl-specifiers of the parameter-declaration-clause with\n  the name of the corresponding invented template-parameter.</p>\n</blockquote>\n<p>Finally:</p>\n<blockquote>\n<p id=\"so_17233547_17233649_1\">Is it similar to templates where for each different argument type compiler generates functions with the same body but changed types or is it more similar to Java's generics?</p>\n</blockquote>\n<p>As the above paragraph explains, generic lambdas are just syntactic sugar for unique, unnamed functors with a templated call operator. That should answer your question :)</p>\n", "LastActivityDate": "2016-06-27T04:22:47.337"}, "17233671": {"ParentId": "17233547", "LastEditDate": "2013-06-21T11:11:25.657", "CommentCount": "5", "CreationDate": "2013-06-21T11:03:37.870", "Score": "22", "LastEditorUserId": "76722", "PostTypeId": "2", "Id": "17233671", "OwnerUserId": "76722", "Body": "<p><strong>Unfortunately</strong>, they are not part of C++11 (<a href=\"http://ideone.com/NsqYuq\" rel=\"noreferrer\">http://ideone.com/NsqYuq</a>):</p>\n<pre><code>auto glambda = [](auto a) { return a; };\n\nint main() {}\n</code></pre>\n<p>With g++ 4.7:</p>\n<pre><code>prog.cpp:1:24: error: parameter declared \u2018auto\u2019\n...\n</code></pre>\n<hr>\n<p><strong>However</strong>, the way it might be implemented in C++14 as per the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3418.pdf\" rel=\"noreferrer\">Portland proposal for generic lambdas</a>:</p>\n<pre><code>[](const&amp; x, &amp; y){ return x + y; }\n</code></pre>\n<p>This would yield for the biggest part the usual creation of an anonymous functor class, but with the lack of types the compiler would emit a templated member-<code>operator()</code>:</p>\n<pre><code>struct anonymous\n{\n    template &lt;typename T, typename U&gt;\n    auto operator()(T const&amp; x, U&amp; y) const -&gt; decltype(x+y)\n    { return x + y; }\n};\n</code></pre>\n<p>Or as per the newer proposal <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3559.pdf\" rel=\"noreferrer\">Proposal for Generic (Polymorphic) Lambda Expressions</a></p>\n<pre><code>auto L = [](const auto&amp; x, auto&amp; y){ return x + y; };\n\n---&gt;\n\nstruct /* anonymous */\n{\n    template &lt;typename T, typename U&gt;\n    auto operator()(const T&amp; x, U&amp; y) const // N3386 Return type deduction\n    { return x + y; }\n} L;\n</code></pre>\n<p>So yes, for every permutation of parameters, a new instantiation would arise, however, the members of that functor would still be shared (i.e. the captured arguments).</p>\n</hr>", "LastActivityDate": "2013-06-21T11:11:25.657"}, "17233672": {"ParentId": "17233547", "CommentCount": "0", "CreationDate": "2013-06-21T11:03:44.183", "OwnerUserId": "1137388", "PostTypeId": "2", "Id": "17233672", "Score": "12", "Body": "<p>It's a proposed C++14 feature (not in C++11) similar (or even equivalent) to templates. For instance, <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3559.pdf\">N3559</a> provides this example:</p>\n<blockquote>\n<blockquote>\n<p id=\"so_17233547_17233672_2\">For example, this generic lambda-expression containing statement:</p>\n<pre><code>auto L = [](const auto&amp; x, auto&amp; y){ return x + y; };\n</code></pre>\n<p id=\"so_17233547_17233672_3\">might result in the creation of a closure type, and object that behaves similar to the struct below:</p>\n<pre><code>struct /* anonymous */\n{\n    template &lt;typename T, typename U&gt;\n    auto operator()(const T&amp; x, U&amp; y) const // N3386 Return type deduction\n    { return x + y; }\n} L;\n</code></pre>\n</blockquote>\n</blockquote>\n", "LastActivityDate": "2013-06-21T11:03:44.183"}, "bq_ids": {"n4140": {"so_17233547_17233649_0": {"section_id": 5964, "quality": 0.9156626506024096, "length": 76}}, "n4659": {"so_17233547_17233649_0": {"section_id": 7453, "quality": 0.9156626506024096, "length": 76}}}, "17233547": {"CommentCount": "1", "ViewCount": "26625", "PostTypeId": "1", "LastEditorUserId": "2149111", "CreationDate": "2013-06-21T10:57:39.580", "LastActivityDate": "2016-06-27T04:22:47.337", "LastEditDate": "2014-09-25T20:11:32.470", "AcceptedAnswerId": "17233649", "FavoriteCount": "20", "Title": "How does generic lambda work in C++14?", "Id": "17233547", "Score": "89", "Body": "<p>How does generic lambda work (<code>auto</code> keyword as an argument type) in C++14 standard? </p>\n<p>Is it based on C++ templates where for each different argument type compiler generates a new function with the same body but replaced types (compile-time polymorphism)  or is it more similar to Java's generics (type erasure)? </p>\n<p>Code example:</p>\n<pre><code>auto glambda = [](auto a) { return a; };\n</code></pre>\n", "Tags": "<c++><lambda><auto><c++14>", "OwnerUserId": "2149111", "AnswerCount": "3"}});