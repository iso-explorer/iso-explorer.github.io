post_cb({"bq_ids": {"n4140": {"so_12837631_12838694_1": {"length": 12, "quality": 0.5454545454545454, "section_id": 6172}, "so_12837631_12838694_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 6172}, "so_12837631_12838694_2": {"length": 8, "quality": 0.8, "section_id": 6170}}, "n3337": {"so_12837631_12838694_1": {"length": 12, "quality": 0.5454545454545454, "section_id": 5933}, "so_12837631_12838694_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 5933}, "so_12837631_12838694_2": {"length": 8, "quality": 0.8, "section_id": 5931}}, "n4659": {"so_12837631_12838694_1": {"length": 12, "quality": 0.5454545454545454, "section_id": 7670}, "so_12837631_12838694_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 7670}, "so_12837631_12838694_2": {"length": 8, "quality": 0.8, "section_id": 7668}}}, "12838204": {"Id": "12838204", "PostTypeId": "2", "Body": "<p><code>if (a &lt; b)</code> equals the pseudo <code>if (unsigned int &lt; unsigned char)</code>.</p>\n<p>Whenever a char type is used in an expression the integer promotion rules in C implicitly converts it to an <code>int</code>. After that is done, you have</p>\n<p><code>if (unsigned int &lt; int)</code>.</p>\n<p>Whenever two integers of same rank but different signedness are used in an expression, the signed one gets implicitly converted to unsigned. This is determined by <em>the usual arithmetic conversions</em>, aka <em>balancing</em>.</p>\n<p>So your first expression is converted to</p>\n<p><code>if (unsigned int &lt; unsigned int)</code></p>\n<p>before anything is done.</p>\n<hr>\n<p>In the second expression we have <code>if (a &lt; (b ? b : c))</code> which equals pseudo </p>\n<p><code>if (unsigned int &lt; (unsigned char ? unsigned char : unsigned char))</code>.</p>\n<p>Integer promotions are performed on all chars, so it gets implicitly converted to</p>\n<p><code>if (unsigned int &lt; (int ? int : int))</code>.</p>\n<p>Then a weird, obscure rule for the conditional operator dictactes that the 2nd and 3rd operator of the ?: operator must be balanced with the usual arithmetic conversions. In this case they are already of the same type, so nothing happens. We end up with</p>\n<p><code>if (unsigned int &lt; int)</code></p>\n<p>Balancing occurs again, the result will be evaluated as</p>\n<p><code>if (unsigned int &lt; unsigned int)</code></p>\n<hr>\n<blockquote>\n<p id=\"so_12837631_12838204_0\">When I compile it with Microsoft</p>\n</blockquote>\n<p>When you compile with Microsoft, all bets are off, their compiler is very poor at following the standard. Expect weird, illogical warnings.</p>\n</hr></hr>", "LastActivityDate": "2012-10-11T11:11:50.487", "CommentCount": "1", "CreationDate": "2012-10-11T11:11:50.487", "ParentId": "12837631", "Score": "3", "OwnerUserId": "584518"}, "12838110": {"Id": "12838110", "PostTypeId": "2", "Body": "<p>This is probably due to the arithmetic conversion rules: First, any integer type of conversion rank less than <code>int</code> (eg <code>unsigned char</code>) will promote to <code>int</code> or <code>unsigned int</code>.</p>\n<p>Whether the result will be <code>int</code> or <code>unsigned int</code> does not (directly) depend on the signedness of the original type, but its range: <code>int</code> is used even for unsigned types as long as all values can be represented, which is the case for <code>unsigned char</code> on mainstream architectures.</p>\n<p>Second, as both operands end up with the same conversion rank, but one is unsigned, the other operand will be converted to an unsigned type as well.</p>\n<p>Semantically, your expressions read</p>\n<pre><code>a &lt; (unsigned int)(int)b\n</code></pre>\n<p>and</p>\n<pre><code>a &lt; (unsigned int)(b ? (int)b : (int)c)\n</code></pre>\n<p>The compiler is apparently smart enough to notice that the first case cannot cause problems, but fails for the second one.</p>\n<p>Steve Jessop's comment nicely explains how this could happen:</p>\n<blockquote>\n<p id=\"so_12837631_12838110_0\">I would imagine that in the first case the compiler thinks, \"I have a comparison operator whose operand types are <code>unsigned int</code> and <code>unsigned char</code>. No need for a warning, now let's apply promotion followed by usual conversion\".</p>\n<p id=\"so_12837631_12838110_1\">In the second case it thinks, \"I have a comparison operator whose operand types are <code>unsigned int</code> and <code>int</code> (which I derived as the type of the conditional expression on the RHS). Best warn about that!\".</p>\n</blockquote>\n", "LastEditorUserId": "48015", "LastActivityDate": "2012-10-11T11:58:38.203", "Score": "7", "CreationDate": "2012-10-11T11:06:20.563", "ParentId": "12837631", "CommentCount": "7", "OwnerUserId": "48015", "LastEditDate": "2012-10-11T11:58:38.203"}, "12837631": {"ViewCount": "3933", "Body": "<p>I have the following C code:</p>\n<pre><code>unsigned int a;\nunsigned char b, c;\nvoid test(void) {\n    if (a &lt; b)\n        return;\n    if (a &lt; (b ? b : c))\n        return;\n}\n</code></pre>\n<p>When I compile it (with Microsoft <code>cl</code>, from MS SDK 7, <code>-W3</code> warning level), the second comparison emits a warning: C4018, signed/unsigned mismatch. The first comparison emits no warning.</p>\n<p>I've checked <a href=\"http://msdn.microsoft.com/en-us/library/e4213hs1%28v=vs.90%29.aspx\" rel=\"nofollow\">MS docs on the conditional operator</a> and they says that if both operands are of same type, the result will be of the same type, so it should work as the first comparison. Am I missing something?</p>\n<p><strong>UPD:</strong> tested with <code>gcc -Wall -Wextra -pedantic</code> and got no warnings whatsoever.</p>\n", "AcceptedAnswerId": "12838110", "Title": "Signed/unsigned mismatch when comparing two unsigned values using a conditional operator", "CreationDate": "2012-10-11T10:34:53.677", "Id": "12837631", "CommentCount": "4", "LastEditDate": "2012-10-11T11:04:43.177", "PostTypeId": "1", "LastEditorUserId": "478521", "LastActivityDate": "2012-10-11T11:58:38.203", "Score": "7", "OwnerUserId": "478521", "Tags": "<c><visual-c++><conditional-operator>", "AnswerCount": "3"}, "12838694": {"Id": "12838694", "PostTypeId": "2", "Body": "<p>The rules are different between C and C++. The appropriate standard can be difficult to judge when compiling C with MSVC, but fortunately in this case C89 and C99 are the same.</p>\n<p>In C89 3.3.15:</p>\n<blockquote>\n<p id=\"so_12837631_12838694_0\">If both the second and third operands have arithmetic type, the usual\n  arithmetic conversions are performed to bring them to a common type\n  and the result has that type</p>\n</blockquote>\n<p>In C99 6.5.15/5:</p>\n<blockquote>\n<p id=\"so_12837631_12838694_1\">If both the second and third operands have arithmetic type, the result\n  type that would be determined by the usual arithmetic conversions,\n  were they applied to those two operands, is the type of the result.</p>\n</blockquote>\n<p>In C++03 5.16/4:</p>\n<blockquote>\n<p id=\"so_12837631_12838694_2\">If the second and third operands are lvalues and have the same type,\n  the result is of that type and is an lvalue</p>\n</blockquote>\n<p>So when you, say, \"if both operands are of same type, the result will be of the same type, so it should work as the first comparison\", that only applies to C++, not to C. In C the type of the RHS of that comparison is <code>int</code>. In C++ the RHS would be an lvalue of type <code>unsigned char</code> as you expected.</p>\n", "LastActivityDate": "2012-10-11T11:40:10.277", "Score": "1", "CreationDate": "2012-10-11T11:40:10.277", "ParentId": "12837631", "CommentCount": "4", "OwnerUserId": "13005", "CommunityOwnedDate": "2012-10-11T11:49:07.827"}});