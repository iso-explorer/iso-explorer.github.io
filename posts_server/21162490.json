post_cb({"21162864": {"ParentId": "21162490", "CommentCount": "0", "Body": "<p>here <code>a *poi;</code> <code>poi=new b;</code> is valid because <code>poi</code> has the reference of <code>var</code> and the object of <code>b</code> also has the variable <code>var</code> because of inheritance. which is a valid reference.</p>\n<p>in case of <code>b *poi2;</code> <code>poi2=new a;</code> <code>poi2</code> also can have reference of <code>var2</code> and <code>var3</code> but object of <code>a</code> doesn't contain <code>var2</code> and <code>var3</code>. which leads to an invalid reference.\nI mean <code>poi2-&gt;var2</code> is a valid statement but there is no <code>var2</code> if compiler allow  <code>poi2=new a;</code> then <code>poi2-&gt;var2</code> will point to an invalid memory segment.</p>\n", "OwnerUserId": "3064551", "PostTypeId": "2", "Id": "21162864", "Score": "1", "CreationDate": "2014-01-16T13:15:32.427", "LastActivityDate": "2014-01-16T13:15:32.427"}, "bq_ids": {"n4140": {"so_21162490_21162566_0": {"section_id": 41, "quality": 0.8823529411764706, "length": 15}}, "n3337": {"so_21162490_21162566_0": {"section_id": 38, "quality": 0.8823529411764706, "length": 15}}, "n4659": {"so_21162490_21162566_0": {"section_id": 41, "quality": 0.8823529411764706, "length": 15}}}, "21162566": {"ParentId": "21162490", "CommentCount": "2", "Body": "<p>This doesn't really have anything to do with the memory allocation. It is simply that the first conversion is a valid implicit conversion (from derived class pointer to base pointer), but the second is not (from base class pointer to derived pointer):</p>\n<blockquote>\n<p id=\"so_21162490_21162566_0\"><em>\u00a74.10/3 [conv.ptr]</em> A prvalue of type \u201cpointer to cv D\u201d, where D is a class type, can be converted to a prvalue of type \u201cpointer to cv B\u201d, where B is a base class (Clause 10) of D.</p>\n</blockquote>\n<p>The reason for this is that polymorphism represents an <em>is-a</em> relationship. A <code>b</code> <em>is an</em> <code>a</code>, but an <code>a</code> is not a <code>b</code>. Therefore, you can have an <code>a</code> pointer pointing at a <code>b</code>, because the object it's pointing at is a valid <code>a</code> object. However, you can't have a <code>b</code> pointer pointing at an <code>a</code>, because an <code>a</code> object is not necessarily a valid <code>b</code> object.</p>\n", "OwnerUserId": "150634", "PostTypeId": "2", "Id": "21162566", "Score": "2", "CreationDate": "2014-01-16T13:01:54.100", "LastActivityDate": "2014-01-16T13:01:54.100"}, "21162490": {"CommentCount": "2", "ViewCount": "123", "PostTypeId": "1", "LastEditorUserId": "1170333", "CreationDate": "2014-01-16T12:59:05.150", "LastActivityDate": "2014-01-16T13:23:57.493", "Title": "Why i cannot allocate a a memory using a a base class type pointing to a derived class pointer?", "LastEditDate": "2014-01-16T13:06:18.483", "Id": "21162490", "Score": "1", "Body": "<pre><code>class a\n{\n    int var;\n}\nclass b :public a\n{\n    int var2,var3;\n}\n\nint main()\n{\n    a *poi;\n    poi=new b;\n    //b *poi2;\n    //poi2=new a;\n    return 0\n}\n</code></pre>\n<p>In above code,i was able to allocate a memory using a derived class type pointing to a base class pointer variable.\ni.e, <code>a *poi=new b;</code>\nBut i was not able to allocate a memory using a  a base class type pointing to a derived class pointer.\ni.e. <code>b *poi=new a;</code></p>\n<p>Why the following memory allocation is not possible?\nWhat is the logic behind it?</p>\n", "Tags": "<c++><pointers><inheritance><memory>", "OwnerUserId": "2530921", "AnswerCount": "3"}, "21162606": {"ParentId": "21162490", "LastEditDate": "2014-01-16T13:23:57.493", "CommentCount": "3", "CreationDate": "2014-01-16T13:03:54.860", "OwnerUserId": "3119226", "LastEditorUserId": "3119226", "PostTypeId": "2", "Id": "21162606", "Score": "4", "Body": "<p>That's not about memory allocation but about inheritance. </p>\n<pre><code>Fruit* f = new Apple\n</code></pre>\n<p>works well, but</p>\n<pre><code>Apple* a = new Fruit\n</code></pre>\n<p>would give you a incomplete apple, or even a banana, so compiler doesn't allow you doing that.</p>\n<p>Both pointers have same size, and you could use a <a href=\"http://www.cplusplus.com/doc/tutorial/typecasting/\" rel=\"nofollow\">unsafe static cast </a> to store a fruit pointer into a apple pointer, but you should avoid doing that </p>\n", "LastActivityDate": "2014-01-16T13:23:57.493"}});