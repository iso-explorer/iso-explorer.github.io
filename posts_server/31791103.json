post_cb({"31791236": {"ParentId": "31791103", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Provide a pure virtual destructor:</p>\n<pre><code>struct Base {\n virtual ~Base() = 0;\n};\n\ninline Base::~Base() {}\n</code></pre>\n<p>You need to provide an implementation, which you could right in the header by making it <code>inline</code>.</p>\n<hr>\n<p>An abstract class is a class with some pure virtual function:</p>\n<blockquote>\n<p id=\"so_31791103_31791236_0\">[...] A class is abstract if it has at least one pure virtual function. [...]</p>\n<p id=\"so_31791103_31791236_1\">[N4431 \u00a710.4/2]</p>\n</blockquote>\n<p>Since you want an array of pointers to instances of (classes derived from) your abstract class, I assume you also want to be able to eventually <code>delete</code> and thus <em>destruct</em> one or more of those instances via these pointers:</p>\n<pre><code>Base * instance = // ... whatever ...\ndelete instance;\n</code></pre>\n<p>To call the correct destructor (of the derived class) in that case, the destructor <em>has</em> to be virtual.</p>\n<p>So since it's virtual either way, and you don't want some pure virtual member function, it's best to make the destructor pure virtual.</p>\n<p>To make a virtual function pure, you append the <em>pure-specifier</em> to its declaration:</p>\n<pre><code>struct Foo {\n virtual void bar(void) /* the */ = 0; // pure-specifier\n};\n</code></pre>\n<p>Now, regarding the definition, you wonder why we need to provide one, since ...</p>\n<blockquote>\n<p id=\"so_31791103_31791236_2\">[...] A pure virtual function need be defined only if called with, or as if with (12.4), the qualified-id syntax (5.1). [...]</p>\n<p id=\"so_31791103_31791236_3\">[N4431 \u00a710.4/2]</p>\n</blockquote>\n<p>This is because when destructing a derived class, after the derived classes destructor has been called, the destructors of the bases classes will also be called:</p>\n<pre><code>struct Derived : public Base {\n ~Derived() {\n  // contents\n  // Base::~Base() will be called\n }\n};\n</code></pre>\n<blockquote>\n<p id=\"so_31791103_31791236_4\">After executing the body of the destructor [...] a destructor for class X calls [...] the destructors for X\u2019s direct base classes and, if X is the type of the most derived class (12.6.2), its destructor calls the destructors for X\u2019s virtual base classes. All destructors are called as if they were referenced with a qualified name [...]</p>\n<p id=\"so_31791103_31791236_5\">[N4431 \u00a712.4/8]</p>\n</blockquote>\n<p>So a definition of the pure virtual destructor if the <code>Base</code> class is needed. However ...</p>\n<blockquote>\n<p id=\"so_31791103_31791236_6\">[...] A function declaration cannot provide both a pure-specifier and a definition [...]</p>\n<p id=\"so_31791103_31791236_7\">[N4431 \u00a710.4/2]</p>\n</blockquote>\n<p>... so it has to be defined outside of the class definition. This could be done in a separate source file, or thanks to ...</p>\n<blockquote>\n<p id=\"so_31791103_31791236_8\">An inline function shall be defined in every translation unit in which it is odr-used and shall have exactly the same definition in every case [...]</p>\n<p id=\"so_31791103_31791236_9\">[N4431 \u00a77.1.2/4]</p>\n</blockquote>\n<p>... as a <code>inline</code> function in the header.</p>\n<hr>\n<p>The standard is even explicit about the requirement of a definition in this case:</p>\n<blockquote>\n<p id=\"so_31791103_31791236_10\">A destructor can be declared virtual (10.3) or pure virtual (10.4); if any objects of that class or any derived class are created in the program, the destructor shall be defined. [...]</p>\n<p id=\"so_31791103_31791236_11\">[N4431 \u00a712.4/9]</p>\n</blockquote>\n</hr></hr>", "OwnerUserId": "1116364", "LastEditorUserId": "1116364", "LastEditDate": "2015-08-03T20:09:33.993", "Id": "31791236", "Score": "11", "CreationDate": "2015-08-03T15:31:24.133", "LastActivityDate": "2015-08-03T20:09:33.993"}, "31791103": {"CommentCount": "10", "ViewCount": "424", "PostTypeId": "1", "LastEditorUserId": "893254", "CreationDate": "2015-08-03T15:24:48.870", "LastActivityDate": "2015-08-04T17:56:15.867", "Title": "C++: How to create an abstract base class if class has no member functions?", "AcceptedAnswerId": "31791236", "LastEditDate": "2015-08-04T17:56:15.867", "Id": "31791103", "Score": "1", "Body": "<p>I have an abstract base class, which serves the purpose of allowing an array of pointers to a base class to be created. (Useful for 'many things'...)</p>\n<p>My abstract base class contains no member functions. Therefore there are no pure virtual methods, and therefore I guess it is not technically abstract.</p>\n<p>However, I do not want to be able to create an instance of this class.</p>\n<p>Is it possible to create a memberless abstract base class? If not, is there another resolution to preventing an instance of my \"abstract base\" from being created? Will making the constructor <code>protected</code> suffice?</p>\n<p>It has been pointed out to me that actually, an abstract base class would not be required if the purpose of that class was to allow a vector or array of pointers to the base class to be created - one could simply not have a base class and use as the base class the class at the top of the inheritance hierarchy. Alternatively, one could copy and paste that top class and exchange the implemented methods for pure virtual functions with no implementation, however this seems logically inconstant with the idea of abstract base pointers, and would lead to more difficult to maintain code.</p>\n", "Tags": "<c++><abstract-base-class>", "OwnerUserId": "893254", "AnswerCount": "3"}, "31791617": {"ParentId": "31791103", "CommentCount": "0", "Body": "<p>If you are going to delete instances of that class polymorphically, then you <em>must</em> have a virtual destructor anyway. It's not just to prevent instantiations of the base class, it's <em>required</em> to avoid undefined behaviour. Just make it pure virtual. And give it an empty implementation (yes, this works in C++).</p>\n<p>If, however, you are not using polymorphism at all, then you should avoid adding a virtual destructor and instead just make the constructor protected. Remember that a base class does not necessarily have to establish a polymorphic class hierarchy (see examples in the C++ library like <a href=\"http://en.cppreference.com/w/cpp/iterator/iterator_tags\" rel=\"nofollow\"><code>std::input_iterator_tag</code></a>).</p>\n", "OwnerUserId": "3313064", "PostTypeId": "2", "Id": "31791617", "Score": "1", "CreationDate": "2015-08-03T15:50:48.443", "LastActivityDate": "2015-08-03T15:50:48.443"}, "bq_ids": {"n4140": {"so_31791103_31791236_4": {"section_id": 404, "quality": 0.967741935483871, "length": 30}, "so_31791103_31791236_2": {"section_id": 7019, "quality": 0.8888888888888888, "length": 8}, "so_31791103_31791236_10": {"section_id": 405, "quality": 0.8666666666666667, "length": 13}, "so_31791103_31791236_8": {"section_id": 5404, "quality": 1.0, "length": 13}, "so_31791103_31791236_6": {"section_id": 7019, "quality": 1.0, "length": 7}, "so_31791103_31791236_0": {"section_id": 7019, "quality": 1.0, "length": 7}}, "n3337": {"so_31791103_31791236_4": {"section_id": 395, "quality": 0.967741935483871, "length": 30}, "so_31791103_31791236_2": {"section_id": 6765, "quality": 0.8888888888888888, "length": 8}, "so_31791103_31791236_10": {"section_id": 396, "quality": 0.8666666666666667, "length": 13}, "so_31791103_31791236_8": {"section_id": 5199, "quality": 1.0, "length": 13}, "so_31791103_31791236_6": {"section_id": 6765, "quality": 1.0, "length": 7}, "so_31791103_31791236_0": {"section_id": 6765, "quality": 1.0, "length": 7}}, "n4659": {"so_31791103_31791236_4": {"section_id": 422, "quality": 0.967741935483871, "length": 30}, "so_31791103_31791236_2": {"section_id": 8516, "quality": 0.8888888888888888, "length": 8}, "so_31791103_31791236_10": {"section_id": 423, "quality": 0.8666666666666667, "length": 13}, "so_31791103_31791236_8": {"section_id": 6853, "quality": 1.0, "length": 13}, "so_31791103_31791236_6": {"section_id": 8516, "quality": 1.0, "length": 7}, "so_31791103_31791236_0": {"section_id": 8516, "quality": 1.0, "length": 7}}}, "31791255": {"ParentId": "31791103", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_31791103_31791255_0\">Is it possible to create a memberless abstract base class?</p>\n</blockquote>\n<p>The simplest way is to make the destructor pure virtual.</p>\n<pre><code>class AbstractBase\n{\n   public:\n      virtual ~AbstractBase() = 0;\n};\n</code></pre>\n", "OwnerUserId": "434551", "LastEditorUserId": "434551", "LastEditDate": "2015-08-03T15:33:32.323", "Id": "31791255", "Score": "1", "CreationDate": "2015-08-03T15:31:59.483", "LastActivityDate": "2015-08-03T15:33:32.323"}});