post_cb({"2826589": {"CommentCount": "4", "AcceptedAnswerId": "2826757", "PostTypeId": "1", "LastEditorUserId": "168175", "CreationDate": "2010-05-13T12:09:55.827", "LastActivityDate": "2012-02-13T09:48:06.400", "LastEditDate": "2012-02-13T09:48:06.400", "ViewCount": "2653", "FavoriteCount": "3", "Title": "empty base class optimization", "Id": "2826589", "Score": "9", "Body": "<p>Two quotes from the C++ standard, \u00a71.8:</p>\n<blockquote>\n<p id=\"so_2826589_2826589_0\">An object is a region of storage.</p>\n<p id=\"so_2826589_2826589_1\">Base class subobjects may have zero size.</p>\n</blockquote>\n<p>I don't think a region of storage can be of size zero. That would mean that some base class subobjects aren't actually objects. How do these statements co-exist?</p>\n", "Tags": "<c++>", "OwnerUserId": "252000", "AnswerCount": "3"}, "2826757": {"ParentId": "2826589", "LastEditDate": "2010-05-13T13:06:43.707", "CommentCount": "8", "CreationDate": "2010-05-13T12:35:47.940", "OwnerUserId": "13005", "LastEditorUserId": "13005", "PostTypeId": "2", "Id": "2826757", "Score": "10", "Body": "<p>A philosophical argument over the definition of \"region\" is unnecessary.</p>\n<p>1.8/5 says, \"Unless it is a bit-field, a most derived object shall have a non-zero size ... Base class sub-objects may have zero size\".</p>\n<p>So the standard is quite clear what objects (and hence what \"regions of storage\") can have zero size. If you disagree with the standard what \"region\" means in English that's one thing, you can fault the authors' (non-programming-related) literary skills. For that matter you can fault their poetic skills (14.7.3/7) But it's quite clear what the standard says here about the sizes of objects of class types.</p>\n<p>The pragmatic way to read standards is that given two plausible interpretations of a word, choose the one which doesn't directly contradict another sentence in the same section of the standard. Don't choose the one which matches more closely your personal preferred use of the word, or even the most common use.</p>\n", "LastActivityDate": "2010-05-13T13:06:43.707"}, "2826863": {"ParentId": "2826589", "CommentCount": "0", "Body": "<p>The C++ standard 1.8.5 states :-</p>\n<blockquote>\n<p id=\"so_2826589_2826863_0\">Unless it is a bit-field (9.6), a most\n  derived object shall have a non-zero\n  size and shall occupy one or more\n  bytes of storage. <strong>Base class\n  subobjects may have zero size</strong>. An\n  object of trivially copyable or\n  standard-layout type (3.9) shall\n  occupy contiguous bytes of storage.</p>\n</blockquote>\n<p>So, the standard alows a base-class that has no data members (and no virtuals) to share the same address as another subobject with a distinct type. You can play around with the empty base class size like ...</p>\n<pre><code>struct a{}; \nstruct a1{}; \nstruct b : public a, public a1{char c;}; \n\n\nint main() \n{ \n  std::cout &lt;&lt; sizeof(b) &lt;&lt; \"\\n\"; \n  std::cout &lt;&lt; sizeof(b::a); \n} \n\n\nWhich outputs (ignoring padding)...\n\n1 \n1 \n\n\nnow try: \n\n\nstruct a{}; \nstruct b : public a {a ax;}; \n\n\nint main() \n{ \n  std::cout &lt;&lt; sizeof(b) &lt;&lt; \"\\n\"; \n  std::cout &lt;&lt; sizeof(b::a); \n} \n\n\nand the output is ...\n\n2 \n1 \n</code></pre>\n<p>because the two instances of a (as a base and as a member) must have distinct addresses.</p>\n<p><strong>BTW</strong>: \"b::a\" is another way to say \"a\". The presence of the scope access operator does not request the \"base-class subobject of b of type a\". Verse <code>5.3.3/2</code> says :- <em>When applying sizeof to a base class subobject, the result is the size of that object's type</em>.</p>\n", "OwnerUserId": "79298", "PostTypeId": "2", "Id": "2826863", "Score": "2", "CreationDate": "2010-05-13T12:52:34.443", "LastActivityDate": "2010-05-13T12:52:34.443"}, "2826753": {"ParentId": "2826589", "CommentCount": "2", "Body": "<p>C++ does not allow an object of size zero, because every object must have a unique memory address.  So if you have:</p>\n<pre><code>struct empty {};\n\n// ...\n\nempty myempty;\nempty* ptr = &amp;myempty;\n</code></pre>\n<p>then <code>ptr</code> must be pointing to a unique memory address.  The standard states the minimum size for an object is 1 byte for this purpose.  Similarly, allocations of size 0 are allowed, and return a valid pointer, even if writing to that pointer is not allowed (this works for <code>malloc(0)</code>, and <code>new empty</code> returns a pointer to one byte, since <code>sizeof(empty) == 1</code>).</p>\n<p>If I derive from <code>empty</code> like so:</p>\n<pre><code>struct derived : public empty\n{\n    int data;\n}\n</code></pre>\n<p>There is no longer any point in the base class <code>empty</code> occupying one byte, because all <code>derived</code> will have a unique address due to the <code>data</code> member.  The quote \"Base class subobjects may have zero size\" is present to allow, in this case, for the compiler to not use any space for <code>empty</code>, such that <code>sizeof(derived) == 4</code>.  As the title states, it's just an optimization, and it is perfectly legal for the <code>empty</code> part of <code>derived</code> to occupy zero space.</p>\n", "OwnerUserId": "177222", "PostTypeId": "2", "Id": "2826753", "Score": "9", "CreationDate": "2010-05-13T12:35:27.880", "LastActivityDate": "2010-05-13T12:35:27.880"}, "bq_ids": {"n4140": {"so_2826589_2826863_0": {"section_id": 5794, "quality": 0.9655172413793104, "length": 28}, "so_2826589_2826589_1": {"section_id": 5794, "quality": 1.0, "length": 7}}, "n3337": {"so_2826589_2826863_0": {"section_id": 5567, "quality": 0.9655172413793104, "length": 28}, "so_2826589_2826589_1": {"section_id": 5567, "quality": 1.0, "length": 7}}, "n4659": {"so_2826589_2826863_0": {"section_id": 7253, "quality": 0.9655172413793104, "length": 28}, "so_2826589_2826589_1": {"section_id": 7253, "quality": 1.0, "length": 7}}}});