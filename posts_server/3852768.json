post_cb({"bq_ids": {"n4140": {"so_3852768_3852774_1": {"length": 32, "quality": 0.9696969696969697, "section_id": 5811}, "so_3852768_3852768_3": {"length": 17, "quality": 0.8095238095238095, "section_id": 7207}, "so_3852768_3852774_5": {"length": 21, "quality": 0.9545454545454546, "section_id": 5811}, "so_3852768_3852768_2": {"length": 9, "quality": 0.75, "section_id": 5811}, "so_3852768_3852774_4": {"length": 7, "quality": 0.7, "section_id": 6074}, "so_3852768_3852768_0": {"length": 20, "quality": 0.8, "section_id": 5808}, "so_3852768_3852774_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 5808}, "so_3852768_3852774_3": {"length": 15, "quality": 1.0, "section_id": 6173}, "so_3852768_3852768_1": {"length": 22, "quality": 0.9565217391304348, "section_id": 5811}}, "n3337": {"so_3852768_3852774_1": {"length": 32, "quality": 0.9696969696969697, "section_id": 5584}, "so_3852768_3852768_3": {"length": 17, "quality": 0.8095238095238095, "section_id": 6951}, "so_3852768_3852774_5": {"length": 21, "quality": 0.9545454545454546, "section_id": 5584}, "so_3852768_3852768_2": {"length": 9, "quality": 0.75, "section_id": 5584}, "so_3852768_3852774_4": {"length": 7, "quality": 0.7, "section_id": 5842}, "so_3852768_3852768_0": {"length": 20, "quality": 0.8, "section_id": 5581}, "so_3852768_3852774_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 5581}, "so_3852768_3852774_3": {"length": 15, "quality": 1.0, "section_id": 5934}, "so_3852768_3852768_1": {"length": 22, "quality": 0.9565217391304348, "section_id": 5584}}, "n4659": {"so_3852768_3852774_1": {"length": 26, "quality": 0.7878787878787878, "section_id": 7272}, "so_3852768_3852768_3": {"length": 17, "quality": 0.8095238095238095, "section_id": 8716}, "so_3852768_3852774_5": {"length": 15, "quality": 0.6818181818181818, "section_id": 7272}, "so_3852768_3852774_4": {"length": 6, "quality": 0.6, "section_id": 7570}, "so_3852768_3852768_0": {"length": 20, "quality": 0.8, "section_id": 7269}, "so_3852768_3852774_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 7269}, "so_3852768_3852774_3": {"length": 15, "quality": 1.0, "section_id": 7675}, "so_3852768_3852768_1": {"length": 16, "quality": 0.6956521739130435, "section_id": 7272}}}, "7968335": {"Id": "7968335", "PostTypeId": "2", "Body": "<p>In thinking about expressions like those mentioned, I find it useful to imagine a machine where memory has interlocks so that reading a memory location as part of a read-modify-write sequence will cause any attempted read or write, other than the concluding write of the sequence, to be stalled until the sequence completes.  Such a machine would hardly be an absurd concept; indeed, such a design could simplify many multi-threaded code scenarios.  On the other hand, an expression like \"x=y++;\" could fail on such a machine if 'x' and 'y' were references to the same variable, and the compiler's generated code did something like read-and-lock reg1=y; reg2=reg1+1; write x=reg1; write-and-unlock y=reg2.  That would be a very reasonable code sequence on processors where writing a newly-computed value would impose a pipeline delay, but the write to x would lock up the processor if y were aliased to the same variable.</p>\n", "LastActivityDate": "2011-11-01T14:55:31.007", "CommentCount": "0", "CreationDate": "2011-11-01T14:55:31.007", "ParentId": "3852768", "Score": "0", "OwnerUserId": "363751"}, "3852768": {"ViewCount": "3036", "Body": "<p>Sorry for opening this topic again, but thinking about this topic itself has started giving me an Undefined Behavior. Want to move into the zone of well-defined behavior.</p>\n<p>Given</p>\n<pre><code>int i = 0;\nint v[10];\ni = ++i;     //Expr1\ni = i++;     //Expr2\n++ ++i;      //Expr3\ni = v[i++];  //Expr4\n</code></pre>\n<p>I think of the above expressions (in that order) as</p>\n<pre><code>operator=(i, operator++(i))    ; //Expr1 equivalent\noperator=(i, operator++(i, 0)) ; //Expr2 equivalent\noperator++(operator++(i))      ; //Expr3 equivalent\noperator=(i, operator[](operator++(i, 0)); //Expr4 equivalent\n</code></pre>\n<p>Now coming to behaviors here are the important quotes from <strong>C++ 0x</strong>.</p>\n<blockquote>\n<p id=\"so_3852768_3852768_0\">$1.9/12- \"Evaluation of an expression\n  (or a sub-expression) in general\n  includes both value computations\n  (including determining the identity of\n  an object for lvalue  evaluation and\n  fetchinga value previously assigned to\n  an object for rvalue evaluation) and\n  initiation of side effects.\"</p>\n<p id=\"so_3852768_3852768_1\">$1.9/15- \"If a side effect on a scalar\n  object is unsequenced relative to\n  either another side effect on the same\n  scalar object <strong>or</strong> a value\n  computation using the value of the\n  same scalar object, the behavior is\n  undefined.\"</p>\n<p id=\"so_3852768_3852768_2\">[ Note: Value computations and side\n  effects associated with different\n  argument expressions are unsequenced.\n  \u2014end note ]</p>\n<p id=\"so_3852768_3852768_3\">$3.9/9- \"Arithmetic types (3.9.1),\n  enumeration types, pointer types,\n  pointer to member types (3.9.2),\n  std::nullptr_t, and cv-qualified\n  versions of these types (3.9.3) are\n  collectively called scalar types.\"</p>\n</blockquote>\n<ul>\n<li><p>In Expr1, the evaluation of the expression <code>i</code> (first argument), is unsequenced with respect to the evaluation of the expession <code>operator++(i)</code> (which has a side effect).</p>\n<p><strong>Hence Expr1 has undefined behavior.</strong></p></li>\n<li><p>In Expr2, the evaluation of the expression <code>i</code> (first argument), is unsequenced with respect to the evaluation of the expession <code>operator++(i, 0)</code> (which has a side effect)'.</p>\n<p><strong>Hence Expr2 has undefined behavior.</strong></p></li>\n<li><p>In Expr3, the evaluation of the lone argument <code>operator++(i)</code> is required to be complete before the outer <code>operator++</code> is called.</p>\n<p><strong>Hence Expr3 has well defined behavior.</strong></p></li>\n<li><p>In Expr4, the evaluation of the expression <code>i</code> (first argument) is unsequenced with respect to the evaluation of the <code>operator[](operator++(i, 0)</code> (which has a side effect).</p>\n<p><strong>Hence Expr4 has undefined behavior.</strong></p></li>\n</ul>\n<p>Is this understanding correct?</p>\n<hr>\n<p>P.S. The method of analyzing the expressions as in OP is not correct. This is because, as @Potatoswatter, notes - \"clause 13.6 does not apply. See the disclaimer in 13.6/1, \"These candidate functions participate in the operator overload resolution process as described in 13.3.1.2 and are used for no other purpose.\" They are just dummy declarations; no function-call semantics exist with respect to built-in operators.\"</p>\n</hr>", "AcceptedAnswerId": "3852774", "Title": "Unsequenced value computations (a.k.a sequence points)", "CreationDate": "2010-10-04T04:06:16.237", "Id": "3852768", "CommentCount": "9", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2015-11-01T03:05:13.833", "LastEditorUserId": "153285", "LastActivityDate": "2015-11-01T03:05:13.833", "Score": "16", "OwnerUserId": "418110", "Tags": "<c++><language-lawyer><side-effects><sequence-points>", "AnswerCount": "2"}, "3852774": {"Id": "3852774", "PostTypeId": "2", "Body": "<p>Native operator expressions are not equivalent to overloaded operator expressions. There is a sequence point at the binding of values to function arguments, which makes the <code>operator++()</code> versions well-defined. But that doesn't exist for the native-type case.</p>\n<p>In all four cases, <code>i</code> changes twice within the full-expression. Since no <code>,</code>, <code>||</code>, or <code>&amp;&amp;</code> appear in the expressions, that's instant UB.</p>\n<p>\u00a75/4:</p>\n<blockquote>\n<p id=\"so_3852768_3852774_0\">Between the previous and next sequence point a scalar object shall have its stored value modified at most once by the evaluation of an expression.</p>\n</blockquote>\n<h2>Edit for C++0x (updated)</h2>\n<p>\u00a71.9/15:</p>\n<blockquote>\n<p id=\"so_3852768_3852774_1\">The value computations of the operands of an operator are sequenced before the value computation of the result of the operator. If a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined.</p>\n</blockquote>\n<p>Note however that a value computation and a side effect are two distinct things. If <code>++i</code> is equivalent to <code>i = i+1</code>, then <code>+</code> is the value computation and <code>=</code> is the side effect. From 1.9/12:</p>\n<blockquote>\n<p id=\"so_3852768_3852774_2\">Evaluation of an expression (or a sub-expression) in general includes both value computations (including determining the identity of an object for glvalue evaluation and fetching a value previously assigned to an object for prvalue evaluation) and initiation of side effects.</p>\n</blockquote>\n<p>So although the value computations are more strongly sequenced in C++0x than C++03, <s>the side effects are not.</s> Two side effects in the same expression, unless otherwise sequenced, produce UB.</p>\n<p><s>Value computations are ordered by their data dependencies anyway and, side effects absent, their order of evaluation is unobservable, so I'm not sure why C++0x goes to the trouble of saying anything, but that just means I need to read more of the papers by Boehm and friends wrote.</s></p>\n<h2>Edit #3:</h2>\n<p>Thanks Johannes for coping with my laziness to type \"sequenced\" into my PDF reader search bar. I was going to bed and getting up on the last two edits anyway\u2026 right ;v) .</p>\n<p>\u00a75.17/1 defining the assignment operators says</p>\n<blockquote>\n<p id=\"so_3852768_3852774_3\">In all cases, the assignment is sequenced after the value computation of the right and left operands, and before the value computation of the assignment expression.</p>\n</blockquote>\n<p>Also \u00a75.3.2/1 on the preincrement operator says</p>\n<blockquote>\n<p id=\"so_3852768_3852774_4\">If x is not of type bool, the expression ++x is equivalent to x+=1 [Note: see \u2026 addition (5.7) and assignment operators (5.17) \u2026].</p>\n</blockquote>\n<p>By this identity, <code>++ ++ x</code> is shorthand for <code>(x +=1) +=1</code>. So, let's interpret that.</p>\n<ul>\n<li>Evaluate the <code>1</code> on the far RHS and descend into the parens.</li>\n<li>Evaluate the inner <code>1</code> and the value (prvalue) and address (glvalue) of <code>x</code>.</li>\n<li>Now we need the value of the += subexpression.\n<ul>\n<li>We're done with the value computations for that subexpression.</li>\n<li>The assignment side effect must be sequenced before the value of assignment is available!</li>\n</ul></li>\n<li>Assign the new value to <code>x</code>, which is identical to the glvalue and prvalue result of the subexpression.</li>\n<li>We're out of the woods now. The whole expression has now been reduced to <code>x +=1</code>.</li>\n</ul>\n<p><em><strong>So, then</strong></em></p> 1 and 3 are well-defined and 2 and 4 are undefined behavior, which you would expect.\n<p>The only other surprise I found by searching for \"sequenced\" in N3126 was 5.3.4/16, where the implementation is allowed to call <code>operator new</code> before evaluating constructor arguments. That's cool.</p>\n<h2>Edit #4: (Oh, what a tangled web we weave)</h2>\n<p>Johannes notes again that in <code>i == ++i;</code> the glvalue (a.k.a. the address) of <code>i</code> is ambiguously dependent on <code>++i</code>. The glvalue is certainly <em>a</em> value of <code>i</code>, but I don't think 1.9/15 is intended to include it for the simple reason that the glvalue of a named object is constant, and cannot actually have dependencies.</p>\n<p>For an informative strawman, consider</p>\n<pre><code>( i % 2? i : j ) = ++ i; // certainly undefined\n</code></pre>\n<p>Here, the glvalue of the LHS of <code>=</code> is dependent on a side-effect on the prvalue of <code>i</code>. The address of <code>i</code> is not in question; the outcome of the <code>?:</code> is.</p>\n<p>Perhaps a good counterexample is</p>\n<pre><code>int i = 3, &amp;j = i;\nj = ++ i;\n</code></pre>\n<p>Here <code>j</code> has a glvalue distinct from (but identical to) <code>i</code>. Is this well-defined, yet <code>i = ++i</code> is not? This represents a trivial transformation that a compiler could apply to any case.</p>\n<p>1.9/15 should say</p>\n<blockquote>\n<p id=\"so_3852768_3852774_5\">If a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation using the <strong>prvalue</strong> of the same scalar object, the behavior is undefined.</p>\n</blockquote>\n", "LastEditorUserId": "153285", "LastActivityDate": "2010-10-05T19:49:58.047", "Score": "14", "CreationDate": "2010-10-04T04:09:27.580", "ParentId": "3852768", "CommentCount": "41", "OwnerUserId": "153285", "LastEditDate": "2010-10-05T19:49:58.047"}});