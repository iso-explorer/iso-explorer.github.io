post_cb({"14094408": {"CommentCount": "14", "AcceptedAnswerId": "14095403", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-12-30T20:35:13.793", "LastActivityDate": "2013-01-13T15:18:09.447", "LastEditDate": "2017-05-23T12:14:41.260", "ViewCount": "961", "FavoriteCount": "1", "Title": "Is the time complexity of `std::vector<T>::clear` *really* not specified?", "Id": "14094408", "Score": "13", "Body": "<p>During the proceedings of <a href=\"https://stackoverflow.com/questions/14094302/stdvectorintclear-constant-time\">this question</a>, it came to light that there appear to be no time complexity requirements placed on <code>std::vector&lt;T&gt;::clear</code> by the C++ standard.</p>\n<p>Table 100 under 23.2.3 says:</p>\n<blockquote>\n<p id=\"so_14094408_14094408_0\">Destroys all elements in <code>a</code>. Invalidates all references, pointers, and iterators referring to the elements of <code>a</code> and may invalidate the past-the-end iterator. post: <code>a.empty()</code> returns <code>true</code></p>\n</blockquote>\n<p>And... that's it. There's no entry for it specifically under 23.3.6, and no <em>explicit</em> indication that the following applies to <code>clear</code>:</p>\n<blockquote>\n<p id=\"so_14094408_14094408_1\"><code>[C++11: 23.3.6.1/1]:</code> A vector is a sequence container that supports random access iterators. In addition, <strong>it supports (amortized) constant time insert and erase operations at the end; insert and erase in the middle take linear time</strong>. Storage management is handled automatically, though hints can be given to improve efficiency. <em>[..]</em></p>\n</blockquote>\n<p>So... is this really true? Or have I simply missed it?</p>\n", "Tags": "<c++><std><language-lawyer>", "OwnerUserId": "560648", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_14094408_14094408_1": {"section_id": 955, "quality": 0.9411764705882353, "length": 32}, "so_14094408_14094408_0": {"section_id": 723, "quality": 1.0, "length": 18}}, "n3337": {"so_14094408_14094408_1": {"section_id": 943, "quality": 0.9411764705882353, "length": 32}, "so_14094408_14094408_0": {"section_id": 712, "quality": 1.0, "length": 18}}, "n4659": {"so_14094408_14094408_1": {"section_id": 1016, "quality": 0.7941176470588235, "length": 27}, "so_14094408_14094408_0": {"section_id": 754, "quality": 0.9444444444444444, "length": 17}}}, "14095403": {"ParentId": "14094408", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>This seems to be an unintended consequence of <a href=\"http://cplusplus.github.com/LWG/lwg-defects.html#704\" rel=\"nofollow noreferrer\">DR 704</a> (and the related <a href=\"http://cplusplus.github.com/LWG/lwg-closed.html#1301\" rel=\"nofollow noreferrer\">DR 1301</a>) which removed the wording saying <code>clear()</code> was equivalent to <code>erase(begin(), end())</code> because <code>erase()</code> requires MoveAssignable, which isn't needed when erasing every element.  Removing the definition in terms of <code>erase()</code> also removes the complexity requirement.  That can probably be handled editorially; I've raised it with the committee.</p>\n<p>N.B. <code>std::deque::clear()</code> and <code>std::forward_list::clear()</code> are also affected. <code>std::list::clear()</code> does have a complexity guarantee.</p>\n<p><strong>Edit:</strong> this is now <a href=\"http://cplusplus.github.com/LWG/lwg-active.html#2231\" rel=\"nofollow noreferrer\">http://cplusplus.github.com/LWG/lwg-active.html#2231</a></p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2013-01-13T15:18:09.447", "Id": "14095403", "Score": "16", "CreationDate": "2012-12-30T22:36:25.803", "LastActivityDate": "2013-01-13T15:18:09.447"}});