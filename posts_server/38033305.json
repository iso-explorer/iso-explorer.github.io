post_cb({"38033403": {"ParentId": "38033305", "PostTypeId": "2", "CommentCount": "3", "Body": "<h2>Short answer</h2>\n<p>You can call your function using the pointer to member operator (<code>.*</code> or <code>-&gt;*</code>):  </p>\n<pre><code>void OrderBook::ExecuteFunction(Order &amp; order, std::list&lt;Order&gt; listOfOrders)\n{\n    (this-&gt;*m_matchingAlgorithm)(order, listOfOrders);\n}\n</code></pre>\n<p>More info <a href=\"https://isocpp.org/wiki/faq/pointers-to-members#fnptr-vs-memfnptr-types\" rel=\"nofollow\">here</a>.  </p>\n<h2>Long explanations</h2>\n<p>We are all used to omit <code>this-&gt;</code> for accessing members of the current object.  The mecanism that allows this is name resolution principles.  But these do not apply for pointer dereferencing operators.  </p>\n<p><strong>The simple case of a pointer to a data member</strong></p>\n<p>Let's star with a simpler case : a pointer to an integer member.  </p>\n<pre><code>class OrederBook {\n    ...\n    int x,y; \n    int OrderBook::* px; \n};\n</code></pre>\n<p>In the constructor you couldn't initialize <code>px</code> with <code>&amp;x</code> because <code>&amp;x</code> is an absolute address of an integer, and <code>px</code> is the (relative) address of an integer in an <code>OrderBook</code>.  We would then initialize it:  </p>\n<pre><code>OrderBook::OrderBook(..)\n    : m_OrderBookName(name), px(&amp;OrderBook::x) {...}\n</code></pre>\n<p>But in this case, the ordinary dereferencing operator for <code>px</code> would not work either: </p>\n<pre><code> *px =2;    // error because of unary operator *\n</code></pre>\n<p>In fact, for dereferencing such a pointer, you need to know not only the pointer, but also the object in which this pointer should be used:</p>\n<pre><code> this-&gt;*px =2;    // yes ! take relative px address and apply it to this object.  \n</code></pre>\n<p><strong>Unary vs. Binary derefencing</strong></p>\n<p>The standard defines two different dereferencing operators: </p>\n<blockquote>\n<p id=\"so_38033305_38033403_0\"><strong>5.3.1/1:</strong> The <strong>unary</strong> * operator performs indirection: the expression to which it\n  is applied shall be a pointer to an object type, or a pointer to a\n  function type and the result is an lvalue referring to the object or\n  function to which the expression points. If the type of the expression\n  is \u201cpointer to T,\u201d the type of the result is \u201cT.\u201d</p>\n<p id=\"so_38033305_38033403_1\"><strong>5.5/3:</strong> The <strong>binary</strong> operator -&gt;* binds its second operand, which shall be of type \u201cpointer to member of T\u201d to its first operand, which\n  shall be of type \u201cpointer to T\u201d or \u201cpointer to a class of which T is\n  an unambiguous and accessible base class.\u201d The expression E1-&gt;<em>E2 is\n  converted into the equivalent form (</em>(E1)).*E2.</p>\n</blockquote>\n<p><strong>Dereferencing a pointer to a member function</strong></p>\n<p>For the data example above, you have the choice of the weapons.  You could build very easily code achieving the same results, but defining <code>px</code> as <code>int *px</code> instead of <code>int OrderBook::*px</code> and using the unary <code>*</code> as usual.  </p>\n<p>Unfortunately for poitners to non static member function, you can't use such shortcuts. You really need a pointer to a member function and not a pointer to a function:  When you call a member function, in addition to the arguments that you have to pass, you always have to know for which object you call it.  And the only way to tell this is to use <code>(-&gt;*)</code> or <code>(.*)</code>.   </p>\n<p><strong>Conclusion</strong></p>\n<p>Ommitting <code>this-&gt;*</code> and assuming the compiler would be intelligent enough to deduct that it's for the current object could seem natural for us.  But this is not defined by the standard.  It's unfortunate and more <a href=\"https://isocpp.org/wiki/faq/pointers-to-members#macro-for-ptr-to-memfn\" rel=\"nofollow\">here</a>.  </p>\n", "OwnerUserId": "3723423", "LastEditorUserId": "3723423", "LastEditDate": "2016-06-25T23:43:10.650", "Id": "38033403", "Score": "2", "CreationDate": "2016-06-25T22:11:46.090", "LastActivityDate": "2016-06-25T23:43:10.650"}, "38033305": {"CommentCount": "1", "AcceptedAnswerId": "38033336", "CreationDate": "2016-06-25T21:56:06.407", "LastActivityDate": "2016-06-25T23:43:10.650", "PostTypeId": "1", "ViewCount": "49", "FavoriteCount": "1", "Title": "Pointer-to-member-function error", "Id": "38033305", "Score": "2", "Body": "<p>I am trying to use a pointer to a member function in my code so that I can easily replace the function to use without changing everywhere in the code. I get an error while compiling that I don't understand how to solve. Here is a minimum working example:</p>\n<p><strong>OrderBook.h</strong></p>\n<pre><code>#include &lt;list&gt;\n#include &lt;string&gt;\n\nclass Order\n{\n\n};\n\nclass OrderBook\n{\n    typedef void(OrderBook::* MatchingAlgorithm)(Order&amp;, std::list&lt;Order&gt;&amp;);\npublic:\n    OrderBook(const std::string name);    \n    void ExecuteFunction(Order&amp;, std::list&lt;Order&gt;);\nprivate:\n    void FunctionToUse(Order&amp;, std::list&lt;Order&gt;&amp;);        \n    const std::string m_OrderBookName;\n    MatchingAlgorithm m_matchingAlgorithm;\n};\n</code></pre>\n<p><strong>OrderBook.cpp</strong></p>\n<pre><code>#include \"OrderBook.h\"\n\nOrderBook::OrderBook(\n    const std::string name\n    )\n    : m_OrderBookName(name)\n{\n    m_matchingAlgorithm = &amp;OrderBook::FunctionToUse;\n}\n\nvoid OrderBook::ExecuteFunction(Order &amp; order, std::list&lt;Order&gt; listOfOrders)\n{\n    (*m_matchingAlgorithm)(order, listOfOrders);\n}\n\nvoid OrderBook::FunctionToUse(Order &amp;, std::list&lt;Order&gt;&amp;)\n{\n    // do nothing\n}\n</code></pre>\n<p><strong>Source.cpp</strong></p>\n<pre><code>#include \"OrderBook.h\"\n\nint main() \n{\n    std::list&lt;Order&gt; mylist;\n    Order o1, o2;    \n    mylist.push_back(o1);\n    mylist.push_back(o2);\n\n    OrderBook ob(\"my book\");\n\n    ob.ExecuteFunction(o1, mylist);\n\n    return 0;\n}\n</code></pre>\n<p><strong>Compilation Errors</strong></p>\n<pre><code>error C2171: '*': illegal on operands of type 'OrderBook::MatchingAlgorithm'\nerror C2064: term does not evaluate to a function taking 2 arguments\n</code></pre>\n<p>If I replace <code>(*m_matchingAlgorithm)</code> with <code>FunctionToUse</code> inside <code>ExecuteFunction</code> the code compiles without errors.</p>\n", "Tags": "<c++><visual-c++>", "OwnerUserId": "1297822", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_38033305_38033403_1": {"section_id": 6130, "quality": 0.9, "length": 27}, "so_38033305_38033403_0": {"section_id": 6064, "quality": 0.8846153846153846, "length": 23}}, "n3337": {"so_38033305_38033403_1": {"section_id": 5894, "quality": 0.9, "length": 27}, "so_38033305_38033403_0": {"section_id": 5832, "quality": 0.8846153846153846, "length": 23}}, "n4659": {"so_38033305_38033403_1": {"section_id": 7627, "quality": 0.8666666666666667, "length": 26}, "so_38033305_38033403_0": {"section_id": 7560, "quality": 0.8846153846153846, "length": 23}}}, "38033336": {"ParentId": "38033305", "CommentCount": "3", "Body": "<p>Change the function call to:</p>\n<pre><code>(this-&gt;*m_matchingAlgorithm)(order, listOfOrders);\n</code></pre>\n", "OwnerUserId": "3943312", "PostTypeId": "2", "Id": "38033336", "Score": "2", "CreationDate": "2016-06-25T22:01:42.797", "LastActivityDate": "2016-06-25T22:01:42.797"}});