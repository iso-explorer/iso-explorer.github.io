post_cb({"13556763": {"CommentCount": "0", "AcceptedAnswerId": "13556919", "CreationDate": "2012-11-25T23:35:32.783", "LastActivityDate": "2012-11-26T02:25:29.510", "PostTypeId": "1", "ViewCount": "1187", "FavoriteCount": "1", "Title": "Does boost::condition::notify_all guarantee that a listener thread will acquire the lock before returning?", "Id": "13556763", "Score": "1", "Body": "\n<pre class=\"lang-cpp prettyprint-override\"><code>boost::condition cond;\nboost::mutex access;\nvoid listener_thread()\n{\n  boost::mutex::scoped_lock lock(access);\n\n  while (true) {\n      while (!condition_check_var) {\n          cond.wait(lock);\n      }\n      do_some_work();\n  }\n}\n\n/// ... Main thread ...\ncond.notify_all();\ncheck_work:\n{\n    boost::mutex::scoped_lock lock(access);\n    function_relies_on_work_been_done();\n}\n</code></pre>\n<p>Is this proper design? Is it safe to assume that once the <code>notify_all()</code> returns, the listener_thread will have already acquired the lock? And that when the <code>check_work</code> block will run (since it's locking the same mutex as the <code>listener_thread()</code>), some \"work\" will have already been done by the <code>listener_thread()</code>?</p>\n<p>If not, what is the preferred way to achieve this kind of behavior?</p>\n", "Tags": "<c++><multithreading><boost><synchronization>", "OwnerUserId": "419542", "AnswerCount": "2"}, "13556919": {"ParentId": "13556763", "CommentCount": "0", "Body": "<p>There is no guarantee that any other thread has acted upon a notification or even, yet, received. In fact, there isn't even a guarantee that there is a thread currently waiting for its reception although in your setup it looks as if it is likely the case that there are threads waiting. If you want to make sure that the receiving threads have done their work you'll need to set up a reverse communication channel, e.g., using another condition variable and a suitable condition.</p>\n<p>I realize that your question is about Boost but here is what the standard has to say about this (30.5.1 [thread.condition.condvar] paragraph 8):</p>\n<blockquote>\n<p id=\"so_13556763_13556919_0\"><code>void notify_all() noexcept;</code>\n  Effects: Unblocks all threads that are blocked waiting for <code>*this</code>.</p>\n</blockquote>\n<p>It doesn't give any guarantee about what happens to the threads and/or any involved mutex.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "13556919", "Score": "3", "CreationDate": "2012-11-25T23:57:17.717", "LastActivityDate": "2012-11-25T23:57:17.717"}, "bq_ids": {"n4140": {"so_13556763_13556919_0": {"section_id": 2994, "quality": 0.5555555555555556, "length": 5}}, "n3337": {"so_13556763_13556919_0": {"section_id": 2864, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_13556763_13556919_0": {"section_id": 3753, "quality": 0.5555555555555556, "length": 5}}}, "13556873": {"ParentId": "13556763", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It's generally OK, though the typical way to write it is like this:</p>\n<pre><code>while (true)\n{\n    cond.wait(lock, [&amp;]() -&gt; bool { return condition_check_var; });\n    do_some_work();\n}\n</code></pre>\n<p>You can't speak to the simultaneity of calling <code>notify_all()</code> and the return of <code>wait()</code>, since there is no formal causal relationship between the two. All you need to know for synchronisation is that when <code>wait()</code> returns you will have acquired the lock. Since your <code>check_work</code> block also locks the mutex, it is guaranteed to execute only while the other thread is blocking on the condition variable.</p>\n", "OwnerUserId": "596781", "LastEditorUserId": "36565", "LastEditDate": "2012-11-26T02:25:29.510", "Id": "13556873", "Score": "1", "CreationDate": "2012-11-25T23:50:05.067", "LastActivityDate": "2012-11-26T02:25:29.510"}});