post_cb({"48586173": {"Id": "48586173", "PostTypeId": "2", "Body": "<p>The access control is applied to names. That means only the name of the <code>struct</code> <code>PrivateInner</code> is restricted. The members of the <code>struct</code> itself have own access control. So all members of <code>PrivateInner</code> are public.</p>\n<blockquote>\n<h2>11 Member access control [class.access]</h2>\n<p id=\"so_48585843_48586173_0\">1 A member of a class can be</p>\n<ul>\n<li><strong>private</strong>; that is, its name can be used only by members and friends of the class in which it is declared.</li>\n</ul>\n<p id=\"so_48585843_48586173_1\">...</p>\n<p id=\"so_48585843_48586173_2\">4 Access control is applied uniformly to all names, whether the names\n  are referred to from declarations or expressions. ...</p>\n</blockquote>\n<p>As you already found out, you can use the constructor (and the <code>struct</code> in general) if you're not using its name:</p>\n<pre><code>c.innerVect.push_back({});\nc.innerVect.emplace_back();\n</code></pre>\n<p>even</p>\n<pre><code>template &lt;typename T&gt;\nT createPrivateInner()\n{\n    return T();\n}\n\n...\n\nc.innerVect.push_back(createPrivateInner&lt;decltype(Outer::inner)&gt;());\n</code></pre>\n", "LastEditorUserId": "8918119", "LastActivityDate": "2018-02-02T16:10:57.427", "Score": "3", "CreationDate": "2018-02-02T15:44:41.960", "ParentId": "48585843", "CommentCount": "0", "OwnerUserId": "8918119", "LastEditDate": "2018-02-02T16:10:57.427"}, "48585923": {"Id": "48585923", "PostTypeId": "2", "Body": "<p>The member is public so of course you can call its member functions. If its name is visible, then so are its own public members.</p>\n<p>Likewise the inner class is private, so of course you can't refer to its name from outside the class. These are the basic definitions of the access control rules.</p>\n<p><code>emplace_back</code> can call the constructor because <code>std::vector</code> received the type as a template parameter from someone who was allowed to refer to it. The access check occurred when the template was instantiated. At that point its name was accessible.</p>\n<p>You can call the constructor outside of the class anywhere using <code>decltype</code>:</p>\n<pre><code>Outer c;\nauto this_works_too = decltype(c.inner){};\n</code></pre>\n<p>This works because you don't have to refer to it by an inaccessible name.</p>\n", "LastEditorUserId": "880984", "LastActivityDate": "2018-02-02T16:01:14.457", "Score": "2", "CreationDate": "2018-02-02T15:30:17.237", "ParentId": "48585843", "CommentCount": "0", "OwnerUserId": "880984", "LastEditDate": "2018-02-02T16:01:14.457"}, "bq_ids": {"n4140": {"so_48585843_48586173_2": {"length": 11, "quality": 1.0, "section_id": 6667}}, "n3337": {"so_48585843_48586173_2": {"length": 11, "quality": 1.0, "section_id": 6422}}, "n4659": {"so_48585843_48586173_2": {"length": 11, "quality": 1.0, "section_id": 8142}}}, "48586010": {"Id": "48586010", "PostTypeId": "2", "Body": "<p>The member \"createObject()\" is private. So, of course, you cannot access it. You should add some member function in public field to implement this private member.</p>\n", "LastActivityDate": "2018-02-02T15:35:31.137", "Score": "0", "CreationDate": "2018-02-02T15:35:31.137", "ParentId": "48585843", "CommentCount": "0", "OwnerUserId": "9246483"}, "48585843": {"ViewCount": "165", "Body": "<p>Found this strange compilation behavior, checked on VS2012, VS2017 and <a href=\"https://www.onlinegdb.com/online_c++_compiler\" rel=\"nofollow noreferrer\">https://www.onlinegdb.com/online_c++_compiler</a>)</p>\n<p>Basically for private nested classes you can call public functions outside, but not public constructors.</p>\n<p>3 questions:</p>\n<ul>\n<li><p>what is the reasoning behind compiler letting me call func()?</p></li>\n<li><p>if compiler lets me call func(), why I cannot call ctor?</p></li>\n<li><p>if I cannot call ctor, how come emplace_back is able to do it?</p></li>\n</ul>\n<hr>\n<pre><code>class Outer {\n    struct PrivateInner {\n        PrivateInner() {}\n        void func() {}\n    };\npublic:\n    PrivateInner inner;\n    std::vector&lt;PrivateInner&gt; innerVect;\n};\n\nvoid f1()\n{\n    Outer c;\n    c.inner.func(); // COMPILING, but why?\n}\n\nvoid f2()\n{\n    Outer c;\n    c.innerVect.push_back(Outer::PrivateInner()); // NOT COMPILING, why no access to ctor if there is access to func()?\n    c.innerVect.emplace_back(); // COMPILING, but why? Doesn't it call Outer::PrivateInner inside?\n}\n</code></pre>\n<p>As I see I still can create a (static) function createObject():</p>\n<pre><code>class Outer {\n    struct PrivateInner {\n        PrivateInner() {}\n        static PrivateInner createObject() { return PrivateInner(); }\n        void func() {}\n    };\n.....\n};\n</code></pre>\n<p>and then call it.</p>\n<p>createObject() may be non-static if calling static from instances is not pure standard thing.</p>\n<pre><code>c.innerVect.push_back(c.inner.createObject()); // COMPILING\n</code></pre>\n<p>to \"hack\" compilation</p>\n</hr>", "AcceptedAnswerId": "48586025", "Title": "C++ private nested class - access to different functions", "CreationDate": "2018-02-02T15:25:37.503", "LastActivityDate": "2018-02-02T16:19:20.887", "CommentCount": "2", "LastEditDate": "2018-02-02T16:03:07.977", "PostTypeId": "1", "LastEditorUserId": "616363", "Id": "48585843", "Score": "5", "OwnerUserId": "616363", "Tags": "<c++><class><private>", "AnswerCount": "4"}, "48586025": {"Id": "48586025", "PostTypeId": "2", "Body": "<p>Note that the nested <code>struct</code> <code>PrivateInner</code> is declared as <code>private</code>, so only <code>Outer::PrivateInner</code> is <code>private</code>, you can't use this name to declare variable like <code>Outer::PrivateInner pi;</code> without sufficient access right, but you can write it like <code>decltype(Outer::inner) pi;</code>. </p>\n<p>On the other hand, its constructor and member function are <code>public</code>, so they can be called.</p>\n<blockquote id=\"so_48585843_48586025_0\">\n<pre><code>c.inner.func(); // COMPILING, but why?\n</code></pre>\n</blockquote>\n<p><code>func()</code> is <code>public</code>, so if you have got an instance of type <code>Outer::PrivateInner</code> you can call <code>func</code> on it. </p>\n<blockquote id=\"so_48585843_48586025_1\">\n<pre><code>c.innerVect.push_back(Outer::PrivateInner()); // NOT COMPILING, why no access to ctor if there is access to func()?\n</code></pre>\n</blockquote>\n<p>It has nothing to do with the constructor, you just can't use the name <code>Outer::PrivateInner</code> here.</p>\n<blockquote id=\"so_48585843_48586025_2\">\n<pre><code>c.innerVect.emplace_back(); // COMPILING, but why? Doesn't it call Outer::PrivateInner inside?\n</code></pre>\n</blockquote>\n<p>The constructor is <code>public</code>, then it could be used to construct the object. <code>std::vector</code> doesn't use the name like <code>Outer::PrivateInner</code> directly; it uses the name specified as the template argument.</p>\n<p>BTW: For the same reason,</p>\n<blockquote id=\"so_48585843_48586025_3\">\n<pre><code>c.innerVect.push_back(c.inner.createObject()); // COMPILING\n</code></pre>\n</blockquote>\n<p>but <code>c.innerVect.push_back(Outer::PrivateInner::createObject());</code> won't compile.</p>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2018-02-02T16:19:20.887", "Score": "1", "CreationDate": "2018-02-02T15:36:15.903", "ParentId": "48585843", "CommentCount": "1", "OwnerUserId": "3309790", "LastEditDate": "2018-02-02T16:19:20.887"}});