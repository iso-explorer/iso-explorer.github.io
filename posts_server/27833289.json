post_cb({"27835103": {"ParentId": "27833289", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>I don't know whether you'd regard it as making sense, but <code>abs()</code> applied to an unsigned value can certainly return a value other than the one passed in.  That's because <code>abs()</code> takes an <code>int</code> argument and returns an <code>int</code> value.</p>\n<p>For example:</p>\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    unsigned u1 = 0x98765432;\n    printf(\"u1 = 0x%.8X; abs(u1) = 0x%.8X\\n\", u1, abs(u1));\n    unsigned long u2 = 0x9876543201234567UL;\n    printf(\"u2 = 0x%.16lX; abs(u2) = 0x%.16lX\\n\", u2, labs(u2));\n    return 0;\n}\n</code></pre>\n<p>When compiled as C or C++ (using GCC 4.9.1 on Mac OS X 10.10.1 Yosemite), it produces:</p>\n<pre><code>u1 = 0x98765432; abs(u1) = 0x6789ABCE\nu2 = 0x9876543201234567; abs(u2) = 0x6789ABCDFEDCBA99\n</code></pre>\n<p>If the high bit of the unsigned value is set, then the result of <code>abs()</code> is not the value that was passed to the function.</p>\n<p>The subtraction is merely a distraction; if the result has the most significant bit set, the value returned from <code>abs()</code> will be different from the value passed to it.</p>\n<hr>\n<p>When you compile this code with C++ headers, instead of the C headers shown in the question, then it fails to compile with ambiguous call errors:</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main(void)\n{\n    unsigned u1 = 0x98765432;\n    cout &lt;&lt; \"u1 = 0x\" &lt;&lt; hex &lt;&lt; u1 &lt;&lt; \"; abs(u1) = 0x\" &lt;&lt; hex &lt;&lt; abs(u1) &lt;&lt; \"\\n\";\n    unsigned long u2 = 0x9876543201234567UL;\n    cout &lt;&lt; \"u2 = 0x\" &lt;&lt; hex &lt;&lt; u2 &lt;&lt; \"; abs(u2) = 0x\" &lt;&lt; hex &lt;&lt; abs(u2) &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>\n<p>Compilation errors:</p>\n<pre><code>absuns2.cpp: In function \u2018int main()\u2019:\nabsuns2.cpp:8:72: error: call of overloaded \u2018abs(unsigned int&amp;)\u2019 is ambiguous\n     cout &lt;&lt; \"u1 = 0x\" &lt;&lt; hex &lt;&lt; u1 &lt;&lt; \"; abs(u1) = 0x\" &lt;&lt; hex &lt;&lt; abs(u1) &lt;&lt; \"\\n\";\n                                                                        ^\nabsuns2.cpp:8:72: note: candidates are:\nIn file included from /usr/gcc/v4.9.1/include/c++/4.9.1/cstdlib:72:0,\n                 from absuns2.cpp:1:\n/usr/include/stdlib.h:129:6: note: int abs(int)\n int  abs(int) __pure2;\n      ^\nIn file included from absuns2.cpp:1:0:\n/usr/gcc/v4.9.1/include/c++/4.9.1/cstdlib:174:3: note: long long int std::abs(long long int)\n   abs(long long __x) { return __builtin_llabs (__x); }\n   ^\n/usr/gcc/v4.9.1/include/c++/4.9.1/cstdlib:166:3: note: long int std::abs(long int)\n   abs(long __i) { return __builtin_labs(__i); }\n   ^\nabsuns2.cpp:10:72: error: call of overloaded \u2018abs(long unsigned int&amp;)\u2019 is ambiguous\n     cout &lt;&lt; \"u2 = 0x\" &lt;&lt; hex &lt;&lt; u2 &lt;&lt; \"; abs(u2) = 0x\" &lt;&lt; hex &lt;&lt; abs(u2) &lt;&lt; \"\\n\";\n                                                                        ^\nabsuns2.cpp:10:72: note: candidates are:\nIn file included from /usr/gcc/v4.9.1/include/c++/4.9.1/cstdlib:72:0,\n                 from absuns2.cpp:1:\n/usr/include/stdlib.h:129:6: note: int abs(int)\n int  abs(int) __pure2;\n      ^\nIn file included from absuns2.cpp:1:0:\n/usr/gcc/v4.9.1/include/c++/4.9.1/cstdlib:174:3: note: long long int std::abs(long long int)\n   abs(long long __x) { return __builtin_llabs (__x); }\n   ^\n/usr/gcc/v4.9.1/include/c++/4.9.1/cstdlib:166:3: note: long int std::abs(long int)\n   abs(long __i) { return __builtin_labs(__i); }\n   ^\n</code></pre>\n<p>So, the code in the question only compiles when only the C-style headers are used; it doesn't compile when the C++ headers are used.  If you add <code>&lt;stdlib.h&gt;</code> as well as <code>&lt;cstdlib&gt;</code>, there's an additional overload available to make the calls more ambiguous.</p>\n<p>You can make the code compile if you add (in)appropriate casts to the calls to <code>abs()</code>, and the absolute value of a signed quantity can be different from the original signed quantity, which is hardly surprising news:</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main(void)\n{\n    unsigned u1 = 0x98765432;\n    cout &lt;&lt; \"u1 = 0x\" &lt;&lt; hex &lt;&lt; u1 &lt;&lt; \"; abs(u1) = 0x\" &lt;&lt; hex &lt;&lt; abs(static_cast&lt;int&gt;(u1)) &lt;&lt; \"\\n\";\n    unsigned long u2 = 0x9876543201234567UL;\n    cout &lt;&lt; \"u2 = 0x\" &lt;&lt; hex &lt;&lt; u2 &lt;&lt; \"; abs(u2) = 0x\" &lt;&lt; hex &lt;&lt; abs(static_cast&lt;long&gt;(u2)) &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>u1 = 0x98765432; abs(u1) = 0x6789abce\nu2 = 0x9876543201234567; abs(u2) = 0x6789abcdfedcba99\n</code></pre>\n<p>Moral: Don't use the C headers for which there are C++ equivalents in C++ code; use the C++ headers instead.</p>\n</hr>", "OwnerUserId": "15168", "LastEditorUserId": "15168", "LastEditDate": "2015-01-08T15:37:12.263", "Id": "27835103", "Score": "7", "CreationDate": "2015-01-08T07:36:31.383", "LastActivityDate": "2015-01-08T15:37:12.263"}, "27833306": {"ParentId": "27833289", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Not it doesn't make sense.</p>\n<p>If you want the difference, use</p>\n<pre><code>c = (a &gt; b) ? a - b : b - a;\n</code></pre>\n<p>or</p>\n<pre><code>c = max(a, b) - min(a, b);\n</code></pre>\n<p>Unsigned if go below zero would wrap back (effect is similar to adding 2<sup>sizeof (unsigned long) * CHAR_BIT</sup>)</p>\n<p>If you are looking for difference between two numbers, you can write a small template as below</p>\n<pre><code>namespace MyUtils {\n  template&lt;typename T&gt;\n  T diff(const T&amp;a, const T&amp;b) {\n    return (a &gt; b) ? (a - b) : (b - a);\n  }\n}\n</code></pre>\n<hr>\n<p>Looking at the declaration of <a href=\"http://en.cppreference.com/w/cpp/numeric/math/abs\" rel=\"noreferrer\">abs</a> inherited from <code>C</code> (Because you included <code>stdlib.h</code>)</p>\n<pre><code>int       abs( int n );\nlong      abs( long n );\nlong long abs( long long n ); //    (since C++11)\n//Defined in header &lt;cinttypes&gt;\nstd::intmax_t abs( std::intmax_t n ); //    (since C++11)\n</code></pre>\n<p>And <a href=\"http://en.cppreference.com/w/cpp/numeric/math/fabs\" rel=\"noreferrer\">abs</a> in <code>C++</code> (from <code>cmath</code>)</p>\n<pre><code>float       abs( float arg );\ndouble      abs( double arg );\nlong double abs( long double arg );\n</code></pre>\n<p>If you notice, both the argument and return type of each function are <code>signed</code>. So if you pass an unsigned type to one of these function, implicit conversion <code>unsigned T1 -&gt; signed T2 -&gt; unsigned T1</code> would take place (where <code>T1</code> and <code>T2</code> may be same and <code>T1</code> is <code>long</code> in your case). When you convert an unsigned integral to signed integral, the behavior is implementation dependendent if it can not be represented in a signed type.</p>\n<p>From <strong>4.7 Integral conversions [conv.integral]</strong></p>\n<blockquote id=\"so_27833289_27833306_0\">\n<ol start=\"2\">\n<li>If the destination type is unsigned, the resulting value is the least\n  unsigned integer congruent to the source integer (modulo 2<sup>n</sup> where n is\n  the number of bits used to represent the unsigned type). [ Note: In a\n  two\u2019s complement representation, this conversion is conceptual and\n  there is no change in the bit pattern (if there is no truncation). \u2014\n  end note]<br/></li>\n<li>If the destination type is signed, the value is unchanged if it can be\n  represented in the destination type (and bit-field width); otherwise,\n  the value is implementation-defined.</li>\n</ol>\n</blockquote>\n</hr>", "OwnerUserId": "2659313", "LastEditorUserId": "2659313", "LastEditDate": "2015-01-19T05:32:17.070", "Id": "27833306", "Score": "13", "CreationDate": "2015-01-08T05:05:56.550", "LastActivityDate": "2015-01-19T05:32:17.070"}, "27833289": {"CommentCount": "5", "AcceptedAnswerId": "27833306", "PostTypeId": "1", "LastEditorUserId": "2659313", "CreationDate": "2015-01-08T05:03:43.993", "LastActivityDate": "2015-02-23T13:06:01.683", "LastEditDate": "2015-02-23T13:06:01.683", "ViewCount": "3726", "FavoriteCount": "2", "Title": "Does abs(unsigned long) make any sense?", "Id": "27833289", "Score": "9", "Body": "<p>I've come across this code, which incidentally my profiler reports as a bottleneck:</p>\n<pre><code>#include &lt;stdlib.h&gt;\n\nunsigned long a, b;\n// Calculate values for a and b\nunsigned long c;\n\nc = abs(a - b);\n</code></pre>\n<p>Does that line do anything more interesting that <code>c = a - b;</code>? Do either of the options invoke undefined or implementation-defined behaviour, and are there other potential gotchas? Note that the C <code>&lt;stdlib.h&gt;</code> is included, not <code>&lt;cstdlib&gt;</code>.</p>\n", "Tags": "<c++><c>", "OwnerUserId": "1270789", "AnswerCount": "3"}, "27834808": {"ParentId": "27833289", "CommentCount": "1", "Body": "<p>I think when c=a-b is negative, if c is unsigned number, c is not the accurate answer. Using abs to guarantee c is a positive number.</p>\n", "OwnerUserId": "4427875", "PostTypeId": "2", "Id": "27834808", "Score": "0", "CreationDate": "2015-01-08T07:16:02.770", "LastActivityDate": "2015-01-08T07:16:02.770"}, "bq_ids": {"n4140": {"so_27833289_27833306_0": {"section_id": 31, "quality": 0.6304347826086957, "length": 29}}, "n3337": {"so_27833289_27833306_0": {"section_id": 28, "quality": 0.6304347826086957, "length": 29}}, "n4659": {"so_27833289_27833306_0": {"section_id": 31, "quality": 0.6304347826086957, "length": 29}}}});