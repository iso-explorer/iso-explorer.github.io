post_cb({"38036851": {"Id": "38036851", "PostTypeId": "2", "Body": "<p><code>T&amp; object = *dynamic_cast&lt;T*&gt;(ptr);</code> is broken because it invokes UB on failure, period. I see no need to belabor the point. Even if it seems to work on current compilers, it may not work on later versions with more aggressive optimizers.</p>\n<p>If you want checks and don't want to be bothered writing an assertion, use the reference form that throws <code>bad_cast</code> on failure:</p>\n<pre><code>T&amp; object = dynamic_cast&lt;T&amp;&gt;(*ptr);\n</code></pre>\n<hr>\n<p><code>dynamic_cast</code> isn't just a run-time check. It can do things <code>static_cast</code> can't. For example, it can cast sideways.</p>\n<pre><code>A   A (*)\n|   |\nB   C\n\\   /\n \\ /\n  D\n</code></pre>\n<p>If the actual most derived object is a <code>D</code>, and you have a pointer to the <code>A</code> base marked with <code>*</code>, you can actually <code>dynamic_cast</code> it to get a pointer to the <code>B</code> subobject:</p>\n<pre><code>struct A { virtual ~A() = default; };\nstruct B : A {};\nstruct C : A {};\nstruct D : B, C {};\nvoid f() {\n    D d;\n    C&amp; c = d;\n    A&amp; a = c;\n    assert(dynamic_cast&lt;B*&gt;(&amp;a) != nullptr);\n}\n</code></pre>\n<p>Note that a <code>static_cast</code> here would be completely wrong.</p>\n<p>(Another prominent example where <code>dynamic_cast</code> can do something <code>static_cast</code> can't is when you are casting from a virtual base to a derived class.)</p>\n<p>In a world without <code>final</code> or whole-program knowledge, you have to do the check at run time (because <code>C</code> and <code>D</code> may not be visible to you). With <code>final</code> on <code>B</code>, you should be able to get away with not doing it, but I'm not surprised if compilers haven't gotten around to optimizing that case yet.</p>\n</hr>", "LastActivityDate": "2016-06-26T09:01:25.630", "CommentCount": "1", "CreationDate": "2016-06-26T09:01:25.630", "ParentId": "38035722", "Score": "8", "OwnerUserId": "2756719"}, "bq_ids": {"n4140": {"so_38035722_38035722_0": {"length": 62, "quality": 0.7126436781609196, "section_id": 6018}}, "n3337": {"so_38035722_38035722_0": {"length": 62, "quality": 0.7126436781609196, "section_id": 5786}}, "n4659": {"so_38035722_38035722_0": {"length": 62, "quality": 0.7126436781609196, "section_id": 7517}}}, "38035722": {"ViewCount": "546", "Body": "<p>Recently I was looking in the code of an open source project, and I saw a bunch of statements of the form <code>T &amp; object = *dynamic_cast&lt;T*&gt;(ptr);</code>.</p>\n<p>(Actually this was occuring in macro used to declare many functions following a similar pattern.)</p>\n<p>To me this looked like a code-smell. My reasoning was, if you <em>know</em> the cast will succeed, then why not use a <code>static_cast</code>? If you aren't sure, then shouldn't you use an assert to test? Since the compiler can assume that any pointer that you <code>*</code> is not null.</p>\n<p>I asked one of the devs on irc about it, and he said that, he considers <code>static_cast</code> downcast to be unsafe. They could add an assert, but even if they don't, he says you will still get a null pointer dereference and crash when <code>obj</code> is actually used. (Because, on failure, the <code>dynamic_cast</code> will convert the pointer to null, then when you access any member, you will be reading from some address of value very close to zero, which the OS won't allow.) If you use a <code>static_cast</code>, and it goes bad, you might just get some memory corruption. So by using the <code>*dynamic_cast</code> option, you are trading off speed for slightly better debuggability. You aren't paying for the assert, instead you are basically relying on the OS to catch the nullptr dereference, at least that's what I understood.</p>\n<p>I accepted that explanation at the time, but it bothered me and I thought about it some more.</p>\n<p>Here's my reasoning.</p>\n<p>If I understand the standard right, a <code>static_cast</code> pointer cast basically means to do some fixed pointer arithmetic. That is, if I have <code>A * a</code>, and I static cast it to  a related type <code>B *</code>, what the compiler is actually going to do with that is add some offset to the pointer, the offset depending only on the layout of the types <code>A</code>, <code>B</code>, (and which C++ implementation potentially). This theory can be tested by static casting pointers to <code>void *</code> and outputting them, before and after the static cast. I expect that if you look at the generated assembly, the <code>static_cast</code> will turn into \"add some fixed constant to the register corresponding to the pointer.\"</p>\n<p>A <code>dynamic_cast</code> pointer cast means, first check the RTTI and only do the static cast if it is valid based on the dynamic type. If it is not, then return <code>nullptr</code>. So, I'd expect that the compiler will at some point expand an expresion <code>dynamic_cast&lt;B*&gt;(ptr)</code> where <code>ptr</code> is of type <code>A*</code> into an expression like</p>\n<pre><code>(__validate_dynamic_cast_A_to_B(ptr) ? static_cast&lt;B*&gt;(ptr) : nullptr)\n</code></pre>\n<p>However, if we then <code>*</code> the result of the dynamic_cast, <code>*</code> of <code>nullptr</code> is UB, so we are implicitly promising that the <code>nullptr</code> branch never happens. And conforming compilers are permitted to \"reason backwards\" from that and eliminate null checks, a point driven home in Chris Lattner's <a href=\"http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html\">famous blog post</a>.</p>\n<p>If the test function <code>__validate_dynamic_cast_A_to_B(ptr)</code> is opaque to the optimizer, i.e. it might have side effects, then the optimizer can't get rid of it, even if it \"knows\" the nullptr branch doesn't happen. However, probably this function is not opaque to the optimizer -- probably it has a very good understanding of its possible side effects.</p>\n<p>So, my expectation is that the optimizer will essentially convert <code>*dynamic_cast&lt;T*&gt;(ptr)</code> into <code>*static_cast&lt;T*&gt;(ptr)</code>, and that interchanging these should give the same generated assembly.</p>\n<p>If true, that would justify my original argument that <code>*dynamic_cast&lt;T*&gt;</code> is a code smell, even if you don't really care about UB in your code and only care about what \"actually\" happens. Because, if a conforming compiler would be permitted to change it to a <code>static_cast</code> silently, then you aren't getting any safety that you think you are, so you should either explicitly <code>static_cast</code> or explicitly assert. At least, that would be my vote in a code review. I'm trying to figure out if that argument is actually right.</p>\n<hr>\n<p>Here is what the standard says about <code>dynamic_cast</code>:</p>\n<blockquote>\n<p id=\"so_38035722_38035722_0\"><code>[5.2.7]</code> Dynamic Cast  <code>[expr.dynamic.cast]</code><br>\n  1. The result of the expression <code>dynamic_cast&lt;T&gt;(v)</code> is the result of converting the expression <code>v</code> to type <code>T</code>. <code>T</code> shall be a pointer or reference to a complete class type, or <em>\"pointer to cv void.\"</em> The <code>dynamic_cast</code> operator shall not cast away constness.<br>\n  ...<br>\n  8. If <code>C</code> is the class type to which <code>T</code> points or refers, the run-time check logically executes as follows:<br>\n  (8.1) - If, in the most derived object pointed (referred) to by <code>v</code>, <code>v</code> points (refers) to a public base class subobject of a <code>C</code> object, and if only one object of type <code>C</code> is derived from the subobject pointed (referred) to by <code>v</code> the result points (refers) to that <code>C</code> object.<br>\n  (8.2) - Otherwise, if <code>v</code> points (refers) to a public base class subobject of the most derived object, and the type of the most derived object has a base class, of type <code>C</code>, that is unambiguous and public, the result points (refers) to the <code>C</code> subobject of the most derived object.<br>\n  (8.3) - Otherwise, the run-time check fails.  </br></br></br></br></br></br></p>\n</blockquote>\n<p>Assuming that the hierarchy of classes is known at compile-time, the relative offsets of each of these classes within eachothers layouts are also known. If <code>v</code> is a pointer to type <code>A</code>, and we want to cast it to a pointer of type <code>B</code>, and the cast is unambiguous, then the shift that <code>v</code> must take is a compile-time constant. Even if <code>v</code> actually points to an object of a more derived type <code>C</code>, that fact doesn't change where the <code>A</code> subobject lies relative to the <code>B</code> subobject, right? So no matter what the type <code>C</code> is, even if it is some unknown type from another compilation unit, to my knowledge the result of a <code>dynamic_cast&lt;T*&gt;(ptr)</code> has only two possible values, <code>nullptr</code> or \"fixed-offset from <code>ptr</code>\".</p>\n<hr>\n<p>However, the plot thickens somewhat upon actually looking at some code gen.</p>\n<p>Here's a simple program that I made to investigate this:</p>\n<hr>\n<pre><code>int output = 0;\n\nstruct A {\n  explicit A(int n) : num_(n) {}\n  int num_;\n\n  virtual void foo() {\n    output += num_;\n  }\n};\n\nstruct B final : public A {\n  explicit B(int n) : A(n), num2_(2 * n) {}\n\n  int num2_;\n\n  virtual void foo() override {\n    output -= num2_;\n  }\n};\n\nvoid visit(A * ptr) {\n  B &amp; b = *dynamic_cast&lt;B*&gt;(ptr);\n  b.foo();\n  b.foo();\n}\n\nint main() {\n  A * ptr = new B(5); \n\n  visit(ptr);\n\n  ptr = new A(10);\n  visit(ptr);\n\n  return output;\n}\n</code></pre>\n<hr>\n<p>According to <a href=\"http://gcc.godbolt.org/#\">godbolt compiler explorer</a>, <code>gcc 5.3</code> x86 assembly for this, with options <code>-O3 -std=c++11</code>, looks like this:</p>\n<hr>\n<pre><code>A::foo():\n        movl    8(%rdi), %eax\n        addl    %eax, output(%rip)\n        ret\nB::foo():\n        movl    12(%rdi), %eax\n        subl    %eax, output(%rip)\n        ret\nvisit(A*):\n        testq   %rdi, %rdi\n        je      .L4\n        subq    $8, %rsp\n        xorl    %ecx, %ecx\n        movl    typeinfo for B, %edx\n        movl    typeinfo for A, %esi\n        call    __dynamic_cast\n        movl    12(%rax), %eax\n        addl    %eax, %eax\n        subl    %eax, output(%rip)\n        addq    $8, %rsp\n        ret\n.L4:\n        movl    12, %eax\n        ud2\nmain:\n        subq    $8, %rsp\n        movl    $16, %edi\n        call    operator new(unsigned long)\n        movq    %rax, %rdi\n        movl    $5, 8(%rax)\n        movq    vtable for B+16, (%rax)\n        movl    $10, 12(%rax)\n        call    visit(A*)\n        movl    $16, %edi\n        call    operator new(unsigned long)\n        movq    vtable for A+16, (%rax)\n        movl    $10, 8(%rax)\n        movq    %rax, %rdi\n        call    visit(A*)\n        movl    output(%rip), %eax\n        addq    $8, %rsp\n        ret\ntypeinfo name for A:\ntypeinfo for A:\ntypeinfo name for B:\ntypeinfo for B:\nvtable for A:\nvtable for B:\noutput:\n        .zero   4\n</code></pre>\n<hr>\n<p>When I change the <code>dynamic_cast</code> to a <code>static_cast</code>, I get the following instead:</p>\n<hr>\n<pre><code>A::foo():\n        movl    8(%rdi), %eax\n        addl    %eax, output(%rip)\n        ret\nB::foo():\n        movl    12(%rdi), %eax\n        subl    %eax, output(%rip)\n        ret\nvisit(A*):\n        movl    12(%rdi), %eax\n        addl    %eax, %eax\n        subl    %eax, output(%rip)\n        ret\nmain:\n        subq    $8, %rsp\n        movl    $16, %edi\n        call    operator new(unsigned long)\n        movl    $16, %edi\n        subl    $20, output(%rip)\n        call    operator new(unsigned long)\n        movl    12(%rax), %edx\n        movl    output(%rip), %eax\n        subl    %edx, %eax\n        subl    %edx, %eax\n        movl    %eax, output(%rip)\n        addq    $8, %rsp\n        ret\noutput:\n        .zero   4\n</code></pre>\n<hr>\n<p>Here's the same  with <code>clang 3.8</code> and same options.</p>\n<p><code>dynamic_cast</code>:</p>\n<hr>\n<pre><code>visit(A*):                            # @visit(A*)\n        xorl    %eax, %eax\n        testq   %rdi, %rdi\n        je      .LBB0_2\n        pushq   %rax\n        movl    typeinfo for A, %esi\n        movl    typeinfo for B, %edx\n        xorl    %ecx, %ecx\n        callq   __dynamic_cast\n        addq    $8, %rsp\n.LBB0_2:\n        movl    output(%rip), %ecx\n        subl    12(%rax), %ecx\n        movl    %ecx, output(%rip)\n        subl    12(%rax), %ecx\n        movl    %ecx, output(%rip)\n        retq\n\nB::foo():                            # @B::foo()\n        movl    12(%rdi), %eax\n        subl    %eax, output(%rip)\n        retq\n\nmain:                                   # @main\n        pushq   %rbx\n        movl    $16, %edi\n        callq   operator new(unsigned long)\n        movl    $5, 8(%rax)\n        movq    vtable for B+16, (%rax)\n        movl    $10, 12(%rax)\n        movl    typeinfo for A, %esi\n        movl    typeinfo for B, %edx\n        xorl    %ecx, %ecx\n        movq    %rax, %rdi\n        callq   __dynamic_cast\n        movl    output(%rip), %ebx\n        subl    12(%rax), %ebx\n        movl    %ebx, output(%rip)\n        subl    12(%rax), %ebx\n        movl    %ebx, output(%rip)\n        movl    $16, %edi\n        callq   operator new(unsigned long)\n        movq    vtable for A+16, (%rax)\n        movl    $10, 8(%rax)\n        movl    typeinfo for A, %esi\n        movl    typeinfo for B, %edx\n        xorl    %ecx, %ecx\n        movq    %rax, %rdi\n        callq   __dynamic_cast\n        subl    12(%rax), %ebx\n        movl    %ebx, output(%rip)\n        subl    12(%rax), %ebx\n        movl    %ebx, output(%rip)\n        movl    %ebx, %eax\n        popq    %rbx\n        retq\n\nA::foo():                            # @A::foo()\n        movl    8(%rdi), %eax\n        addl    %eax, output(%rip)\n        retq\n\noutput:\n        .long   0                       # 0x0\n\ntypeinfo name for A:\n\ntypeinfo for A:\n\ntypeinfo name for B:\n\ntypeinfo for B:\n\nvtable for B:\n\nvtable for A:\n</code></pre>\n<hr>\n<p><code>static_cast</code>:</p>\n<hr>\n<pre><code>visit(A*):                            # @visit(A*)\n        movl    output(%rip), %eax\n        subl    12(%rdi), %eax\n        movl    %eax, output(%rip)\n        subl    12(%rdi), %eax\n        movl    %eax, output(%rip)\n        retq\n\nmain:                                   # @main\n        retq\n\noutput:\n        .long   0                       # 0x0\n</code></pre>\n<hr>\n<p>So, in both cases, it seems that <code>dynamic_cast</code> cannot be eliminated by the optimizer:</p>\n<p>It seems to generate calls to a mysterious <code>__dynamic_cast</code> function, using the typeinfo of both classes, no matter what. Even if all optimizations are on, and <code>B</code> is marked final.</p>\n<ul>\n<li><p>Does this low-level call have side effects that I didn't consider? My understanding was that the vtables are essentially fixed and that the vptr in an object doesn't change... am I right? I have only basic familiarity with how vtables are actually implemented and tbh I usually avoid virtual functions in my code, so I haven't really thought deeply on it or accumulated experience.</p></li>\n<li><p>Am I right that a conforming compiler <em>could</em> replace <code>*dynamic_cast&lt;T*&gt;(ptr)</code> with <code>*static_cast&lt;T*&gt;(ptr)</code> as a valid optimization?</p></li>\n<li><p>Is it true that \"usually\" (meaning, on x86 machines, let's say, and casting between classes in a hierarchy of \"usual\" complexity) a <code>dynamic_cast</code> cannot be optimized away, and will <em>in fact</em> produce a <code>nullptr</code> even if you <code>*</code> it right after, leading to <code>nullptr</code> dereference and crash upon accessing the object?</p></li>\n<li><p>Is \"always replace <code>*dynamic_cast&lt;T*&gt;(ptr)</code> with either <code>dynamic_cast</code> + test or assertion of some kind, or with <code>*static_cast&lt;T*&gt;(ptr)</code>\" a sound advice?</p></li>\n</ul>\n</hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr>", "AcceptedAnswerId": "38036851", "Title": "What is the meaning of `*dynamic_cast<T*>(...)`?", "CreationDate": "2016-06-26T06:10:55.210", "Id": "38035722", "CommentCount": "10", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-06-26T06:56:41.243", "LastEditorUserId": "3598119", "LastActivityDate": "2016-06-26T09:01:25.630", "Score": "12", "OwnerUserId": "3598119", "Tags": "<c++><c++11><casting><undefined-behavior><dynamic-cast>", "AnswerCount": "1"}});