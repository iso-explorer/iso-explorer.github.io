post_cb({"40483483": {"CommentCount": "13", "ViewCount": "125", "PostTypeId": "1", "LastEditorUserId": "951423", "CreationDate": "2016-11-08T09:39:42.177", "LastActivityDate": "2016-11-08T11:26:31.800", "Title": "Exception safety of std::vector implementation shipped with Visual Studio 2015", "FavoriteCount": "2", "LastEditDate": "2016-11-08T11:26:31.800", "Id": "40483483", "Score": "3", "Body": "<p>Consider the following program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;type_traits&gt;\nstruct X\n{\n    int state;\n    X() : state(0) {};\n    X(int x) : state(x) {};\n    X(X const&amp; y) noexcept : state(1) {}\n    X(X&amp;&amp; y) noexcept(false) : state(y.state != 8 ? 2 : throw 1) \n    { y.state = 0; }\n    X&amp; operator =(X const&amp;) = default;\n    X&amp; operator =(X&amp;&amp;) = default;\n};\nint main() {\n    std::vector&lt;X&gt; a;\n    a.reserve(2u);\n    a.emplace_back(6);\n    a.emplace_back(8);\n    try { \n        // ####\n        std::cout &lt;&lt; 'A' &lt;&lt; a.front().state &lt;&lt; a.back().state;\n    }\n    catch (...) \n    { \n        std::cout &lt;&lt; 'B' &lt;&lt; a.front().state &lt;&lt; a.back().state;\n    }\n    return 0;\n}\n</code></pre>\n<p>At position <code>// ####</code> different statements may be employed, each giving different output on g++/clang++ versus msvc.</p>\n<pre><code>    statement               g++     msvc    expected\n\n1   a.resize(10u, X{});     A11     B08     A11\n2   X b; a.push_back(b);    A11     B08     A11\n3   a.emplace_back(1);      A11     B08     A11\n</code></pre>\n<p>So, why do I expect <code>A11</code> in all cases here?</p>\n<p><strong>1: <code>a.resize(10u, X{});</code></strong></p>\n<p>[vector.capacity], 16/17 of n4140 and n4606 say about <code>void resize(size_type sz, const T&amp; c);</code></p>\n<blockquote>\n<p id=\"so_40483483_40483483_0\">Requires: <code>T</code> shall be <code>CopyInsertable</code> into <code>*this</code>.</p>\n<p id=\"so_40483483_40483483_1\">Remarks: If an exception is thrown there are no effects.</p>\n</blockquote>\n<p>Thus, if the compiler must guarantee that a full rollback in case of an exception is possible (\"no effects\") it must either copy the elements or can only move if the move is noexcept because moving has an immediate effect on the elements which cannot be rolled back (which would only be necessary if moving would throw which in turn is not the case for noexcept move constructors).</p>\n<p>Therefore, I'd expect <code>A11</code> as output (or <code>B68</code> if the copy constructor throws).</p>\n<p><strong>2: <code>X b; a.push_back(b);</code></strong></p>\n<p><strong>3: <code>a.emplace_back(1);</code></strong></p>\n<p>[vector.modifiers], 1 of n4140 and n4606 say:</p>\n<blockquote>\n<p id=\"so_40483483_40483483_2\">If an exception is thrown while inserting a single element at the end and <code>T</code> is <code>CopyInsertable</code> or <code>is_nothrow_move_constructible&lt;T&gt;::value</code> is <code>true</code>, there are no effects.</p>\n</blockquote>\n<p>Again the standard requires \"no effect\" in case of an exception when the type is \"CopyInsertable\" (X is CopyInsertible). -&gt; move_if_noexcept!</p>\n<p>My interpretation of those mandates would be that <code>A11</code> is the expected output (or in other terms, that a conformant std::vector shouldn't move its elements unless moving is noexcept or copying is impossible).</p>\n<p>I tried to find some information on the VS SL but only found a blog post '<a href=\"https://blogs.msdn.microsoft.com/vcblog/2016/01/22/vs-2015-update-2s-stl-is-c17-so-far-feature-complete/\" rel=\"nofollow noreferrer\">VS 2015 Update 2\u2019s STL is C++17-so-far Feature Complete</a>' on the VS blog suggests that the VS standard library implementation is \"feature complete\" where I don't get whether this is supposed to claim standard compliance.</p>\n<p><em>Note: I doubt that I'm the first to spot that VS incorrectly moves its elements when it should actually copy them - if anyone has a connect issue or SO-question, don't refrain from pointing to it.</em></p>\n<p>So the question is: Is there a specific reason for the behaviour in MSVC (i.e. performance implications other than copy vs. move or anything) or is this a bug?</p>\n", "Tags": "<c++><vector><visual-studio-2015><stl><c++14>", "OwnerUserId": "951423", "AnswerCount": "0"}, "bq_ids": {"n4140": {"so_40483483_40483483_2": {"section_id": 986, "quality": 1.0, "length": 12}, "so_40483483_40483483_1": {"section_id": 818, "quality": 0.8, "length": 4}}, "n3337": {"so_40483483_40483483_2": {"section_id": 701, "quality": 0.5833333333333334, "length": 7}, "so_40483483_40483483_1": {"section_id": 807, "quality": 0.8, "length": 4}}, "n4659": {"so_40483483_40483483_2": {"section_id": 1049, "quality": 0.9166666666666666, "length": 11}, "so_40483483_40483483_1": {"section_id": 873, "quality": 0.8, "length": 4}}}});