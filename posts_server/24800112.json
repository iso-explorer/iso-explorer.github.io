post_cb({"bq_ids": {"n4140": {"so_24800112_24800112_0": {"length": 30, "quality": 0.8823529411764706, "section_id": 5986}, "so_24800112_24800112_1": {"length": 4, "quality": 1.0, "section_id": 5987}}, "n3337": {"so_24800112_24800112_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 5754}, "so_24800112_24800112_1": {"length": 4, "quality": 1.0, "section_id": 5755}}, "n4659": {"so_24800112_24800112_0": {"length": 28, "quality": 0.8235294117647058, "section_id": 7486}, "so_24800112_24800112_1": {"length": 4, "quality": 1.0, "section_id": 7487}}}, "24800425": {"Id": "24800425", "PostTypeId": "2", "Body": "<p>Question 1</p>\n<p>The rule about not binding temporaries to lvalues doesn't provide ironclad safety. It prevents part of this class of errors, but not all. I suspect that to prevent all such errors, the notion of \"temporariness\" would need to be incorporated into the type system, just like <code>const</code>. Then you could \"cast away temporariness\" in cases where you know you aren't going to keep the reference for longer than the lifetime of the temporary. The committee has decided that the rule we have is worth it, presumably they've also decided that going to further effort isn't worth it.</p>\n<p>For another example, <code>vector&lt;int&gt;(4)[0]</code> also returns an lvalue even though the <code>operator[]</code> call was made on a temporary. The standard isn't going to forbid temporary vectors to be constructed because of this, and I don't see that it should forbid temporary arrays either. OK, so <code>vector</code> is a user-defined type whereas arrays are built-in, but aside from that I think the situations are similar.</p>\n<p>If you use arrays at all, and especially temporary ones, then to some extent the standard thinks you get what you deserve. It's not going to forbid temporary arrays just because it's possible to get an lvalue out of one.</p>\n<p>I think you have a valid general point, though. Subscript probably <em>could</em> be defined more safely on array rvalues, since the compiler has the necessary information. It could evaluate to an rvalue whose value is that of the corresponding array element. That might be confusing or inconvenient, since its not consistent with the usual subscript expressions, but it would be safer :-) If you write <code>struct A {int a;}</code>, then <code>A().a</code> is an rvalue, so I don't think it would be completely out of the question to apply that principle to arrays. It would be a breaking change of course.</p>\n<p>Question 2</p>\n<p>You aren't using a subscript on a braced-init-list. You're using it on a temporary that happens to have been constructed using new-style initializer syntax. That is to say, your expression parses <code>(intArray{1, 2, 3, 4})[1]</code>, not <code>intArray({1, 2, 3, 4}[1])</code>.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2014-07-17T10:34:17.673", "Score": "3", "CreationDate": "2014-07-17T09:59:34.890", "ParentId": "24800112", "CommentCount": "3", "OwnerUserId": "13005", "LastEditDate": "2014-07-17T10:34:17.673"}, "24800112": {"ViewCount": "189", "Body": "<pre><code>using intArray = int[];\nint (&amp;a) [4] = intArray{1, 2, 3, 4};\n</code></pre>\n<p>This is not allowed since it's illegal to bind a non-const lvalue reference to a temporary (rvalue). Both g++ 4.9.1 and clang 3.4.2 barks back with errors; it compiles fine when <code>a</code> is <code>const</code> qualified</p>\n<pre><code>int const (&amp;a) [4] = intArray{1, 2, 3, 4};\n</code></pre>\n<p>However, when I do this</p>\n<pre><code>int &amp;x = intArray{1, 2, 3, 4} [1];\n</code></pre>\n<p>both compilers compile it fine without an error. Digging the standard (draft N3337) for this, <code>\u00a75.2.1 Subscripting</code> says</p>\n<blockquote>\n<p id=\"so_24800112_24800112_0\">1 A postfix expression followed by an expression in square brackets is a postfix expression. One of the expressions shall have the type \u201cpointer to T\u201d and the other shall have unscoped enumeration or integral type. <strong>The result is an lvalue of type \u201cT.\u201d</strong> The type \u201cT\u201d shall be a completely-defined object type. The expression E1[E2] is identical (by definition) to *((E1)+(E2))</p>\n<p id=\"so_24800112_24800112_1\">2 <strong>A braced-init-list shall not be used with the built-in subscript operator.</strong></p>\n</blockquote>\n<ol>\n<li><p>If I go with <em>1</em> then I don't see why the standard allows temporary arrays to be constructed since subscripting an element in it would give out an lvalue i.e. I can get a lvalue from a temporary which contradicts the original notion of temporaries can only be bound to const lvalue references or rvalue references.</p></li>\n<li><p>If I go with <em>2</em> then why do the compilers not throw an error when I'm doing <code>{1, 2, 3, 4}[1]</code>?</p></li>\n</ol>\n", "Title": "Aren't elements of a temporary array rvalues themselves?", "CreationDate": "2014-07-17T09:45:24.943", "LastActivityDate": "2014-07-17T10:34:17.673", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-07-17T09:52:55.763", "LastEditorUserId": "183120", "Id": "24800112", "Score": "10", "OwnerUserId": "183120", "Tags": "<c++><arrays><c++11><temporary><rvalue>", "AnswerCount": "1"}});