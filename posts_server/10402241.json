post_cb({"10402348": {"Id": "10402348", "PostTypeId": "2", "Body": "<p>Both your variants will move the string. The second variant should be preferred because it will not default construct an empty string just to move assign it afterwards.</p>\n<p>Check your testcase and then your compiler's bugzilla list. You need to trace calls to both <code>string::operator=(string&amp;&amp;)</code> (1st case) <em>and</em> <code>string::string(string&amp;&amp;)</code> (2nd case) if you want to ensure for both cases that they move.</p>\n", "LastActivityDate": "2012-05-01T18:31:02.243", "Score": "11", "CreationDate": "2012-05-01T18:31:02.243", "ParentId": "10402241", "CommentCount": "1", "OwnerUserId": "34509"}, "10402367": {"Id": "10402367", "PostTypeId": "2", "Body": "<p>Both Constructors should work. So both are correct move constructors. The second one might be more efficient, since the first one default constructs <code>string</code> only to assign to it, while the second will simply move construct it and should therefore be more efficient. If the second one is less efficient I would suspect a compiler bug (remember that C++11 support is still not complete for current compilers) or a flawed test methology (how exactly do you test copy vs move and are you sure the move constructor not the assignment op is called in both cases?). </p>\n<p>Of course whenever possibly you could simply let the compiler generate your constructor via <code>C(C&amp;&amp;) = default;</code>.</p>\n", "LastActivityDate": "2012-05-01T18:32:22.360", "Score": "3", "CreationDate": "2012-05-01T18:32:22.360", "ParentId": "10402241", "CommentCount": "0", "OwnerUserId": "201270"}, "10402264": {"Id": "10402264", "PostTypeId": "2", "Body": "<p>There is no need to implement a move constructor here since you don't have to manually manage memory. Move constructors are only useful when you manually use dynamic arrays in your class.</p>\n<p>You can still explicitly have the compiler create the default move constructor even though it should have already been done even if you don't request it:</p>\n<pre><code>C(C&amp;&amp; c) = default;\n</code></pre>\n", "LastEditorUserId": "1364752", "LastActivityDate": "2012-05-01T18:36:59.560", "Score": "2", "CreationDate": "2012-05-01T18:24:56.683", "ParentId": "10402241", "CommentCount": "1", "LastEditDate": "2012-05-01T18:36:59.560", "OwnerUserId": "1364752"}, "10402241": {"ViewCount": "10248", "Body": "<p><br/>\nWhat would be the correct way to implement a move constructor considering the following class:</p>\n<pre><code>class C {\npublic:\n    C();\n    C(C&amp;&amp; c);\nprivate:\n    std::string string;\n}\n</code></pre>\n<p>Of course, the idea is to avoid copying <code>string</code> or deallocating it twice.<br/>\nLets assume the basic example is just for clarity and I do need a move constructor.<p>\n<br/>I tried:</p>\n<pre><code>C::C(C&amp;&amp; c) {\n    //move ctor\n    string = std::move(c.string);\n}\n</code></pre>\n<p>And</p>\n<pre><code>C::C(C&amp;&amp; c) : string(std::move(c.string)) {\n    //move ctor\n}\n</code></pre>\n<p>Both compile fine on gcc 4.8 and run fine. It <em>seems</em> option A is the correct behaviour, <code>string</code> gets copied instead of moved with option B.<br/>\nIs this the correct implementation of a move constructor?</p>\n</p>", "AcceptedAnswerId": "10402308", "Title": "C++11 move constructor", "CreationDate": "2012-05-01T18:22:14.430", "Id": "10402241", "CommentCount": "9", "FavoriteCount": "11", "PostTypeId": "1", "LastEditDate": "2012-05-01T18:30:29.137", "LastEditorUserId": "642681", "LastActivityDate": "2012-05-01T18:36:59.560", "Score": "24", "OwnerUserId": "642681", "Tags": "<c++><c++11><move-semantics>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_10402241_10402308_6": {"length": 5, "quality": 0.625, "section_id": 461}, "so_10402241_10402308_3": {"length": 20, "quality": 0.8695652173913043, "section_id": 460}, "so_10402241_10402308_2": {"length": 7, "quality": 1.0, "section_id": 460}, "so_10402241_10402308_4": {"length": 16, "quality": 0.8, "section_id": 460}, "so_10402241_10402308_7": {"length": 8, "quality": 0.5714285714285714, "section_id": 369}, "so_10402241_10402308_1": {"length": 14, "quality": 0.875, "section_id": 460}, "so_10402241_10402308_9": {"length": 17, "quality": 1.0, "section_id": 461}, "so_10402241_10402308_8": {"length": 9, "quality": 1.0, "section_id": 461}}, "n3337": {"so_10402241_10402308_6": {"length": 5, "quality": 0.625, "section_id": 452}, "so_10402241_10402308_5": {"length": 16, "quality": 1.0, "section_id": 451}, "so_10402241_10402308_3": {"length": 22, "quality": 0.9565217391304348, "section_id": 451}, "so_10402241_10402308_2": {"length": 7, "quality": 1.0, "section_id": 451}, "so_10402241_10402308_8": {"length": 9, "quality": 1.0, "section_id": 452}, "so_10402241_10402308_7": {"length": 8, "quality": 0.5714285714285714, "section_id": 359}, "so_10402241_10402308_1": {"length": 14, "quality": 0.875, "section_id": 451}, "so_10402241_10402308_9": {"length": 17, "quality": 1.0, "section_id": 452}, "so_10402241_10402308_4": {"length": 19, "quality": 0.95, "section_id": 451}}, "n4659": {"so_10402241_10402308_6": {"length": 5, "quality": 0.625, "section_id": 484}, "so_10402241_10402308_5": {"length": 9, "quality": 0.5625, "section_id": 383}, "so_10402241_10402308_3": {"length": 20, "quality": 0.8695652173913043, "section_id": 483}, "so_10402241_10402308_2": {"length": 7, "quality": 1.0, "section_id": 483}, "so_10402241_10402308_8": {"length": 9, "quality": 1.0, "section_id": 484}, "so_10402241_10402308_7": {"length": 8, "quality": 0.5714285714285714, "section_id": 383}, "so_10402241_10402308_1": {"length": 14, "quality": 0.875, "section_id": 483}, "so_10402241_10402308_9": {"length": 16, "quality": 0.9411764705882353, "section_id": 484}, "so_10402241_10402308_4": {"length": 16, "quality": 0.8, "section_id": 483}}}, "10402308": {"Id": "10402308", "PostTypeId": "2", "Body": "<p>Since <code>std::string</code> itself has a move-ctor, the implicitly defined move-ctor for <code>C</code> will take care of the proper move operation. You may not define it yourself. However, if you have any other data member and specifically: </p>\n<blockquote>\n<p id=\"so_10402241_10402308_0\"><strong>12.8 Copying and moving class objects</strong></p>\n<p id=\"so_10402241_10402308_1\"><strong>12</strong> An implicitly-declared copy/move constructor is an inline public\n  member of its class. A defaulted copy- /move constructor for a class X\n  is defined as deleted (8.4.3) if X has: </p>\n<p id=\"so_10402241_10402308_2\">\u2014 a variant member with a\n  non-trivial corresponding constructor and X is a union-like class, </p>\n<p id=\"so_10402241_10402308_3\">\u2014 a\n  non-static data member of class type M (or array thereof) that cannot\n  be copied/moved because overload resolution (13.3), as applied to M\u2019s\n  corresponding constructor, results in an ambiguity or a function that\n  is deleted or inaccessible from the defaulted constructor, or</p>\n<p id=\"so_10402241_10402308_4\">\u2014 a\n  direct or virtual base class B that cannot be copied/moved because\n  overload resolution (13.3), as applied to B\u2019s corresponding\n  constructor, results in an ambiguity or a function that is deleted or\n  inaccessible from the defaulted constructor, or </p>\n<p id=\"so_10402241_10402308_5\">\u2014 for the move\n  constructor, a non-static data member or direct or virtual base class\n  with a type that does not have a move constructor and is not trivially\n  copyable. </p>\n<p id=\"so_10402241_10402308_6\"><strong>13</strong> A copy/move constructor for class X is trivial if it is\n  neither user-provided nor deleted and if</p>\n<p id=\"so_10402241_10402308_7\">\u2014 class X has no virtual functions (10.3) and no virtual base classes (10.1), and\n  functions (10.3) and no virtual base classes (10.1), and</p>\n<p id=\"so_10402241_10402308_8\">\u2014 the\n  constructor selected to copy/move each direct base class subobject is\n  trivial, and </p>\n<p id=\"so_10402241_10402308_9\">\u2014 for each non-static data member of X that is of class\n  type (or array thereof), the constructor selected to copy/move that\n  member is trivial; otherwise the copy/move constructor is non-trivial.</p>\n</blockquote>\n<p>you may want to implement your own move-ctor.</p>\n<p>In case you need the move-ctor, prefer the initializer list syntax. Always! Otherwise, you may end up with a default construction per object not mentioned in the initializer list (which is what you're forced for member objects with non-default ctors only).</p>\n", "LastActivityDate": "2012-05-01T18:27:59.810", "Score": "15", "CreationDate": "2012-05-01T18:27:59.810", "ParentId": "10402241", "CommentCount": "0", "OwnerUserId": "66692"}});