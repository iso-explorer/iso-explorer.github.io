post_cb({"17564190": {"ParentId": "17564037", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You cannot actually <em>catch</em> an exception in a constructor. You can handle it, but you have to rethrow it or another exception. The reason is about object integrity and object lifetimes:</p>\n<p>If the construction of <code>a</code> throws, a part of <code>c</code> has not been initialized and is completely missing - lifetime of <code>a</code> never starts. <code>a</code> is not an optional part of <code>C</code>, otherwise it had to be a pointer or a <code>std::optional</code> (since C++14 - <code>boost::optional</code> before that).</p>\n<p>So how do you assemble a <code>C</code> if one of its vital parts cannot be constructed? You can't. <code>c</code> can never start to exist as a complete object, so there is no way you can exit the constructor normally. That's the reason why if construction of a member object fails, construction of the whole object has to fail, i.e. <em>has to</em> throw an exception.</p>\n<p>If you don't throw an exception in <code>C::C</code>'s catch block, the compiler will do so for you.</p>\n<p>C++ Standard, <strong>\u00a715.3,15</strong>:</p>\n<blockquote>\n<p id=\"so_17564037_17564190_0\">The currently handled exception is rethrown if control reaches the end of a handler of the function-try-block of a constructor or destructor.</p>\n</blockquote>\n<p>For a broader treatment on that topic, see <a href=\"http://www.gotw.ca/gotw/066.htm\">http://www.gotw.ca/gotw/066.htm</a></p>\n", "OwnerUserId": "1838266", "LastEditorUserId": "1838266", "LastEditDate": "2013-07-10T07:42:58.910", "Id": "17564190", "Score": "16", "CreationDate": "2013-07-10T06:53:11.207", "LastActivityDate": "2013-07-10T07:42:58.910"}, "bq_ids": {"n4140": {"so_17564037_17564190_0": {"section_id": 3360, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_17564037_17564190_0": {"section_id": 3230, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_17564037_17564190_0": {"section_id": 4126, "quality": 0.9166666666666666, "length": 11}}}, "17564037": {"CommentCount": "12", "AcceptedAnswerId": "17564190", "CreationDate": "2013-07-10T06:42:41.307", "LastActivityDate": "2013-07-10T07:42:58.910", "PostTypeId": "1", "ViewCount": "1653", "FavoriteCount": "3", "Title": "C++ constructor initializer list throw exceptions", "Id": "17564037", "Score": "7", "Body": "<p>I have a problem with the following code. As we can see I have already handled the exception thrown by A's constructor in C's constructor, why should I bother to catch and handle the exception again in the main function?</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass WException : public std::exception\n{\npublic:\n    WException( const char* info ) : std::exception(info){}\n};\n\nclass A\n{\npublic:\n    A( int a ) : a(a) \n    {\n        std::cout &lt;&lt; \"A's constructor run.\" &lt;&lt; std::endl;\n        throw WException(\"A constructor throw exception.\");\n    }\n\nprivate:\n    int a;\n};\n\nclass B\n{\npublic:\n    B( int b ) : b(b) \n    {\n        std::cout &lt;&lt; \"B's constructor body run.\" &lt;&lt; std::endl;\n        throw WException(\"B constructor throw exception\");\n    }\n\nprivate:\n    int b;\n};\n\nclass C : public A, public B\n{\npublic:\n    C( int a, int b ) try : A(a), B(b)\n    {\n        std::cout &lt;&lt; \"C's constructor run.\" &lt;&lt; std::endl;\n    }\n    catch( const WException&amp; e )\n    {\n        std::cerr &lt;&lt; \"In C's constructor\" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n};\n\nint main( int argc, char* argv[] )\n{\n    try\n    {\n        C c( 10, 100 );\n    }\n    catch( const WException&amp; e )\n    {\n        std::cerr &lt;&lt; \"In the main: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }   \n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><list><exception><constructor><initializer>", "OwnerUserId": "2567264", "AnswerCount": "1"}});