post_cb({"bq_ids": {"n4140": {"so_6493052_6493117_0": {"length": 20, "quality": 0.5128205128205128, "section_id": 6697}}, "n3337": {"so_6493052_6493117_0": {"length": 20, "quality": 0.5128205128205128, "section_id": 6452}}, "n4659": {"so_6493052_6493117_0": {"length": 20, "quality": 0.5128205128205128, "section_id": 8172}}}, "6493117": {"Id": "6493117", "PostTypeId": "2", "Body": "<p>This is specified in paragraph 11.6.1 of the standard:</p>\n<blockquote>\n<p id=\"so_6493052_6493117_0\">The access rules (clause 11) for a\n  virtual function are determined by its\n  declaration and are not affected by\n  the rules for a function that later\n  overrides it. [<em>Example - basically same as yours</em>]\n  Access is checked at the call point\n  using the type of the expression used\n  to denote the object for which the\n  member function is called . The access\n  of the member function in the class in\n  which it was defined is in general not\n  known.</p>\n</blockquote>\n", "LastActivityDate": "2011-06-27T12:53:03.807", "CommentCount": "1", "CreationDate": "2011-06-27T12:53:03.807", "ParentId": "6493052", "Score": "7", "OwnerUserId": "160206"}, "6493210": {"Id": "6493210", "PostTypeId": "2", "Body": "<p><code>private</code> means you can't inherit from it. <code>protected</code> or <code>public</code> you can inherit from but there is nothing stopping you limiting the visibility to a lower level (i.e. <code>public</code> to <code>protected</code> or <code>private</code>; or <code>protected</code> to <code>private</code>) in your top class.</p>\n", "LastActivityDate": "2011-06-27T13:01:21.047", "CommentCount": "0", "CreationDate": "2011-06-27T13:01:21.047", "ParentId": "6493052", "Score": "-1", "OwnerUserId": "716851"}, "6493127": {"Id": "6493127", "PostTypeId": "2", "Body": "<pre><code>Interface* i = new Usage();\nstd::cout &lt;&lt; i-&gt;bb() &lt;&lt; std::endl;\n</code></pre>\n<p>This is working because the function name is resolved based on the <code>static</code> type of the object. </p>\n<p>Here the object is <code>i</code> whose  <code>static</code> type is <code>Interface*</code> which has a <code>public</code> function name <code>bb()</code>. Hence, the compiler doesn't see any problem, as the requirement to call a member function meets it. </p>\n<p>Also note that accessibilities (<code>public</code>, <code>private</code> and <code>protected</code>) are compile-time constructs. At runtime, there is no such thing. Compiler can detect any violation of rules related to accessibility at compile time only. It cannot know what happens at runtime. </p>\n<p>So even if <code>i</code> points to an object whose type is <code>Usage</code> which has defined <code>bb()</code> in the <code>private</code> section, the compiler is fine with it, as noted before the <code>static</code> type of <code>i</code> is still <code>Interface*</code> which has a <code>public</code> function <code>bb()</code>. The compiler doens't bother with the <em>dynamic</em> type of object and how it overrides the function, because it cannot, precisely for the reason that its <em>dynamic</em>; its determined at runtime.</p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2011-06-27T13:00:33.543", "Score": "1", "CreationDate": "2011-06-27T12:53:45.470", "ParentId": "6493052", "CommentCount": "0", "OwnerUserId": "415784", "LastEditDate": "2011-06-27T13:00:33.543"}, "6493052": {"ViewCount": "76", "Body": "<p>I might be very well just tired or too long far from C++ but this one really surprised me today:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Interface\n{\npublic:\n    virtual int aa() const = 0;\n    virtual int bb() const = 0;\n};\n\nclass Usage : public Interface\n{\nprivate:\n    virtual int aa() const\n    {\n        int a = 10 * 10;\n        return a;\n    }\n\n    virtual int bb() const\n    {\n        int b = 20 * 20;\n        return b;\n    }\n};\n\nint main(int argc, char* argv[])\n{\n    Interface* i = new Usage();\n    std::cout &lt;&lt; i-&gt;bb() &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>I'd expect compiler and/or linker would complain about either bad function signature or at least about missing implementation. Considering this is working and ok, what is the meaning of public/protected/private modifiers when it's hidden by the top class declaration?</p>\n<p>How does this rule call in C++ ?</p>\n", "AcceptedAnswerId": "6493117", "Title": "When inheriting from public interface, why it doesn't matter if the implementation is public or private?", "CreationDate": "2011-06-27T12:47:22.560", "Id": "6493052", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2011-06-27T13:01:21.047", "Score": "1", "OwnerUserId": "21009", "Tags": "<c++><inheritance><virtual>", "AnswerCount": "3"}});