post_cb({"bq_ids": {"n4140": {"so_42416993_48837089_0": {"length": 24, "quality": 1.0, "section_id": 332}}, "n3337": {"so_42416993_48837089_0": {"length": 24, "quality": 1.0, "section_id": 322}}, "n4659": {"so_42416993_48837089_0": {"length": 24, "quality": 1.0, "section_id": 341}}}, "42416993": {"ViewCount": "1146", "Body": "<p>The rules for picking which class template specialization is preferred involve rewriting the specializations into function templates and determining which function template is more specialized via the ordering rules for function templates [temp.class.order]. Consider this example, then:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt; struct voider { using type = void; };\ntemplate &lt;class T&gt; using void_t = typename voider&lt;T&gt;::type;\n\ntemplate &lt;class T, class U&gt; struct A { };\n\ntemplate &lt;class T&gt; int foo(A&lt;T, void_t&lt;T&gt;&gt; ) { return 1; }\ntemplate &lt;class T&gt; int foo(A&lt;T*, void&gt; )     { return 2; }\n\nint main() {\n    std::cout &lt;&lt; foo(A&lt;int*, void&gt;{});\n}\n</code></pre>\n<p>Both gcc and clang print <code>2</code> here. This makes sense with some previous examples - deducing against a non-deduced context (<code>void</code> against <code>void_t&lt;T&gt;</code>) is just ignored, so deducing <code>&lt;T, void_t&lt;T&gt;&gt;</code> against <code>&lt;X*, void&gt;</code> succeeds but deducing <code>&lt;T*, void&gt;</code> against <code>&lt;Y, void_t&lt;Y&gt;&gt;</code> fails in both arguments. Fine.</p>\n<p>Now consider this generalization:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt; struct voider { using type = void; };\ntemplate &lt;class T&gt; using void_t = typename voider&lt;T&gt;::type;\n\ntemplate &lt;int I&gt; struct int_ { static constexpr int value = I; };\n\ntemplate &lt;class T, class U&gt; struct A      : int_&lt;0&gt; { };\ntemplate &lt;class T&gt; struct A&lt;T, void_t&lt;T&gt;&gt; : int_&lt;1&gt; { };\ntemplate &lt;class T&gt; struct A&lt;T*, void&gt;     : int_&lt;2&gt; { };\n\nint main() {\n    std::cout &lt;&lt; A&lt;int*, void&gt;::value &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Both clang and gcc report this specialization as ambiguous, between <code>1</code> and <code>2</code>. But why? The synthesized function templates aren't ambiguous. What's the difference between these two cases? </p>\n", "AcceptedAnswerId": "48837089", "Title": "Class template specialization partial ordering and function synthesis", "CreationDate": "2017-02-23T13:22:15.290", "Id": "42416993", "CommentCount": "32", "FavoriteCount": "13", "PostTypeId": "1", "LastActivityDate": "2018-02-17T01:36:36.220", "Score": "43", "OwnerUserId": "2069064", "Tags": "<c++><templates><language-lawyer><partial-ordering>", "AnswerCount": "1"}, "48837089": {"Id": "48837089", "PostTypeId": "2", "Body": "<p><strong>Clang is being GCC-compatible</strong> (and compatible with existing code that depends on both of these behaviors).</p>\n<p>Consider <strong>[temp.deduct.type]p1</strong>:</p>\n<blockquote>\n<p id=\"so_42416993_48837089_0\">[...] an attempt is made to find template argument values (a type for a type parameter, a value for a non-type parameter, or a template for a template parameter) that will make P, after substitution of the deduced values (call it the deduced A), compatible with A.</p>\n</blockquote>\n<p>The crux of the issue is what \"compatible\" means here.</p>\n<p>When partially ordering function templates, Clang merely deduces in both directions; if deduction succeeds in one direction but not the other, it assumes that means the result will be \"compatible\", and uses that as the ordering result.</p>\n<p>When partially ordering class template partial specializations, however, Clang interprets \"compatible\" as meaning \"the same\". Therefore it only considers one partial specialization to be more specialized than another if substituting the deduced arguments from one of them into the other would reproduce the original partial specialization.</p>\n<p>Changing either of these two to match the other breaks substantial amounts of real code. :(</p>\n", "LastActivityDate": "2018-02-17T01:36:36.220", "Score": "4", "CreationDate": "2018-02-17T01:36:36.220", "ParentId": "42416993", "CommentCount": "0", "OwnerUserId": "1041090"}});