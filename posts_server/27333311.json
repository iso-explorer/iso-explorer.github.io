post_cb({"27333663": {"ParentId": "27333311", "CommentCount": "0", "Body": "<p>Per C++11 [intro.multithread]/6: \"All modifications to a particular atomic object <code>M</code> occur in some particular total order, called the modification order of <code>M</code>.\" Consequently, reads of an atomic object by a particular thread will never see \"older\" values than those the thread has already observed. Note that there is no mention of memory orderings here, so this property holds true for all of them - <code>seq_cst</code> through <code>relaxed</code>.</p>\n<p>In the example given in the OP, the modification order of <code>x</code> can be either <code>(0,1,2)</code> or <code>(0,2,1)</code>. A thread that has observed a given value in that modification order cannot later observe an earlier value. The outcome <code>r1==1, r2==2</code> implies that the modification order of <code>x</code> is <code>(0,1,2)</code>, but <code>r3==2, r4==1</code> implies it is <code>(0,2,1)</code>, a contradiction. So that outcome is not possible on an implementation that conforms to C++11 .</p>\n", "OwnerUserId": "923854", "PostTypeId": "2", "Id": "27333663", "Score": "4", "CreationDate": "2014-12-06T16:20:00.827", "LastActivityDate": "2014-12-06T16:20:00.827"}, "27333661": {"ParentId": "27333311", "CommentCount": "4", "Body": "<p>No, such an outcome is not allowed. \u00a71.10 [intro.multithread]/p8, 18 (quoting N3936/C++14; the same text is found in paragraphs 6 and 16 for N3337/C++11):</p>\n<blockquote>\n<p id=\"so_27333311_27333661_0\">8 All modifications to a particular atomic object M occur in some\n  particular total order, called the <em>modification order</em> of M.</p>\n<p id=\"so_27333311_27333661_1\">18 If a value computation A of an atomic object M happens before a\n  value computation B of M, and A takes its value from a side effect X\n  on M, then the value computed by B shall either be the value stored by\n  X or the value stored by a side effect Y on M, where Y follows X in\n  the modification order of M. [ <em>Note</em>: This requirement is known as\n  read-read coherence. \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>In your code there are two side effects, and by p8 they occur in some particular total order. In Thread 3, the value computation to calculate the value to be stored in <code>r1</code> happens before that of <code>r2</code>, so given <code>r1 == 1</code> and <code>r2 == 2</code> we know that the store performed by Thread 1 precedes the store performed by Thread 2 in the modification order of <code>x</code>. That being the case, <code>Thread 4</code> cannot observe <code>r3 == 2, r4 == 1</code> without running afoul of p18. This is regardless of the <code>memory_order</code> used.</p>\n<p>There is a note in p21 (p19 in N3337) that is relevant:</p>\n<blockquote>\n<p id=\"so_27333311_27333661_2\">[ <em>Note</em>: The four preceding coherence requirements effectively\n  disallow compiler reordering of atomic operations to a single object,\n  even if both operations are relaxed loads. This effectively makes the\n  cache coherence guarantee provided by most hardware available to C++\n  atomic operations. \u2014<em>end note</em> ]</p>\n</blockquote>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "27333661", "Score": "7", "CreationDate": "2014-12-06T16:19:48.430", "LastActivityDate": "2014-12-06T16:19:48.430"}, "27333311": {"CommentCount": "0", "AcceptedAnswerId": "27333661", "PostTypeId": "1", "LastEditorUserId": "1171688", "CreationDate": "2014-12-06T15:43:14.683", "LastActivityDate": "2014-12-06T16:20:00.827", "LastEditDate": "2014-12-06T15:49:24.113", "ViewCount": "265", "FavoriteCount": "4", "Title": "Will two relaxed writes to the same location in different threads always be seen in the same order by other threads?", "Id": "27333311", "Score": "11", "Body": "<p>On the x86 architecture, stores to the same memory location have a total order, e.g., see <a href=\"http://youtu.be/WUfvvFD5tAA?t=19m58s\">this video</a>. What are the guarantees in the C++11 memory model?</p>\n<p>More precisely, in</p>\n<pre><code>-- Initially --\nstd::atomic&lt;int&gt; x{0};\n\n-- Thread 1 --\nx.store(1, std::memory_order_release);\n\n-- Thread 2 --\nx.store(2, std::memory_order_release);\n\n-- Thread 3 --\nint r1 = x.load(std::memory_order_acquire);\nint r2 = x.load(std::memory_order_acquire);\n\n-- Thread 4 --\nint r3 = x.load(std::memory_order_acquire);\nint r4 = x.load(std::memory_order_acquire);\n</code></pre>\n<p>would the outcome <code>r1==1, r2==2, r3==2, r4==1</code> be allowed (on some architecture other than x86)? What if I were to replace all <code>memory_order</code>'s by <code>std::memory_order_relaxed</code>?</p>\n", "Tags": "<c++><c++11><concurrency><memory-model><stdatomic>", "OwnerUserId": "1171688", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_27333311_27333661_2": {"section_id": 5832, "quality": 0.8484848484848485, "length": 28}, "so_27333311_27333661_0": {"section_id": 5819, "quality": 1.0, "length": 13}, "so_27333311_27333661_1": {"section_id": 5829, "quality": 0.8857142857142857, "length": 31}}, "n3337": {"so_27333311_27333661_2": {"section_id": 5603, "quality": 0.8484848484848485, "length": 28}, "so_27333311_27333661_0": {"section_id": 5590, "quality": 1.0, "length": 13}, "so_27333311_27333661_1": {"section_id": 5600, "quality": 0.8857142857142857, "length": 31}}, "n4659": {"so_27333311_27333661_2": {"section_id": 7294, "quality": 0.8484848484848485, "length": 28}, "so_27333311_27333661_0": {"section_id": 7280, "quality": 0.9230769230769231, "length": 12}, "so_27333311_27333661_1": {"section_id": 7291, "quality": 0.8857142857142857, "length": 31}}}});