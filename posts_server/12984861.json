post_cb({"17205195": {"CommentCount": "11", "CreationDate": "2013-06-20T04:20:12.157", "CommunityOwnedDate": "2013-06-21T16:57:05.333", "LastEditorUserId": "86967", "LastActivityDate": "2014-02-16T23:37:46.263", "ParentId": "12984861", "PostTypeId": "2", "LastEditDate": "2014-02-16T23:37:46.263", "Id": "17205195", "Score": "9", "Body": "<p><strong>To simply disable this warning, use <code>-Wno-strict-overflow</code>.</strong>  To instead disable the specific optimization that triggers this warning, use <code>-fno-strict-overflow</code> or <code>-fwrapv</code>.</p>\n<p>The <a href=\"http://linux.die.net/man/1/gcc\" rel=\"noreferrer\">gcc manpage</a> describes that this warning can be controlled with levels: <code>-Wstrict-overflow=n</code>.</p>\n<p>If this is stopping your build due to <code>-Werror</code>, you can work-around without hiding the warnings by using <code>-Wno-error=strict-overflow</code> (or just <code>-Wno-error</code> to override <code>-Werror</code>).</p>\n<hr>\n<p>Analysis and commentary...</p>\n<p>I got the same warning and spent a couple of hours trying to reproduce it in a smaller example, but never succeeded.  My real code involved calling an inline function in a templated class, but the algorithm simplifies to the following...</p>\n<pre><code>int X = some_unpredictable_value_well_within_the_range_of_int();\nfor ( int c=0; c&lt;4; c++ ) assert( X+c &gt;= X ); ## true unless (X+c) overflows\n</code></pre>\n<p>In my case the warning was somehow correlated with the optimizer unrolling the <code>for</code> loop, so I was able to work-around by declaring <code>volatile int c=0</code>.  Another thing that fixed it was to declare <code>unsigned int c=0</code>, but I'm not exactly sure why that makes a difference.  Another thing that fixed it was making the loop count large enough that the loop wouldn't be unrolled, but that's not a useful solution.</p>\n<p>So what is this warning really saying?  Either it is saying that the optimizer has modified the semantics of your algorithm (by assuming no overflow), or it is simply informing you that <strong>the optimizer is assuming that your code doesn't have the <em>undefined behavior</em> of overflowing a signed integer</strong>.  Unless overflowing signed integers is part of the intended behavior of your program, this message probably does not indicate a problem in your code -- so you will likely want to disable it for normal builds.  If you get this warning but aren't sure about the code in question, it may be safest to just disable the optimization with <code>-fwrapv</code>.</p>\n<p>By the way, I ran into this issue on GCC 4.7, but the same code compiled without warning using 4.8 -- perhaps indicating that the GCC developers recognized the need to be a bit less \"strict\" in the normal case (or maybe it was just due to differences in the optimizer).</p>\n<hr>\n<p>Philosophy...</p>\n<p>In [C++11:<a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2011/n3242.pdf\" rel=\"noreferrer\">N3242</a>$5.0.4], it states...</p>\n<blockquote>\n<p id=\"so_12984861_17205195_0\">If during the evaluation of an expression, the result is not\n  mathematically defined or not in the range of representable values for\n  its type, the behavior is undefined.</p>\n</blockquote>\n<p>This means that a conforming compiler can simply assume that overflow never occurs (even for unsigned types).</p>\n<p>In C++, due to features such as templates and copy constructors, <a href=\"https://en.wikipedia.org/wiki/Elision_%28disambiguation%29\" rel=\"noreferrer\">elision</a> of pointless operations is an important optimizer capability.  Sometimes though, if you are using C++ as a low-level \"system language\", you probably just want the compiler to do what you tell it to do -- and rely on the behavior of the underlying hardware.  Given the language of the standard, I'm not sure how to achieve this in a compiler-independent fashion.</p>\n</hr></hr>", "OwnerUserId": "86967"}, "12984861": {"CommentCount": "3", "ViewCount": "6905", "PostTypeId": "1", "LastEditorUserId": "2642204", "CreationDate": "2012-10-20T02:58:15.397", "LastActivityDate": "2014-06-20T09:23:56.643", "Title": "Don't understand \"assuming signed overflow\" warning", "FavoriteCount": "3", "LastEditDate": "2014-06-20T09:23:56.643", "Id": "12984861", "Score": "14", "Body": "<p>I am getting:</p>\n<blockquote>\n<p id=\"so_12984861_12984861_0\">warning: assuming signed overflow does not occur when assuming that (X + c) &lt; X is always false [-Wstrict-overflow]   </p>\n</blockquote>\n<p>on this line: </p>\n<pre><code>if ( this-&gt;m_PositionIndex[in] &lt; this-&gt;m_EndIndex[in] ) \n</code></pre>\n<p><code>m_PositionIndex</code> and <code>m_EndIndex</code> of type <code>itk::Index</code> (<a href=\"http://www.itk.org/Doxygen/html/classitk_1_1Index.html\">http://www.itk.org/Doxygen/html/classitk_1_1Index.html</a>), and their <code>operator[]</code> returns a <code>signed long</code>.</p>\n<p>(it is line 37 here: <a href=\"https://github.com/Kitware/ITK/blob/master/Modules/Core/Common/include/itkImageRegionConstIteratorWithIndex.hxx\">https://github.com/Kitware/ITK/blob/master/Modules/Core/Common/include/itkImageRegionConstIteratorWithIndex.hxx</a> for context)</p>\n<p>Can anyone explain what would cause that warning here? I don't see the pattern <code>(x+c) &lt; x</code> anywhere - as this is simply a <code>signed long</code> comparison.</p>\n<p>I tried to reproduce it in a self-contained example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace itk\n{\n  struct Index\n  {\n    signed long data[2];\n\n    Index()\n    {\n      data[0] = 0;\n      data[1] = 0;\n    }\n\n    signed long&amp; operator[](unsigned int i)\n    {\n      return data[i];\n    }\n  };\n}\nint main (int argc, char *argv[])\n{\n  itk::Index positionIndex;\n  itk::Index endIndex;\n\n  for(unsigned int i = 0; i &lt; 2; i++)\n  {\n    positionIndex[i]++;\n    if ( positionIndex[i] &lt; endIndex[i] )\n    {\n      std::cout &lt;&lt; \"something\" &lt;&lt; std::endl;\n    }\n  }\n\n  return 0;\n}\n</code></pre>\n<p>but I do not get the warning there. Any thoughts as to what is different between my demo and the real code, or what could be causing the warning in the real code? I get the warning with both gcc 4.7.0 and 4.7.2 with the -Wall flag.</p>\n", "Tags": "<c++><gcc><gcc-warning>", "OwnerUserId": "284529", "AnswerCount": "5"}, "12984885": {"ParentId": "12984861", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>I think that the compiler changed</p>\n<pre><code>positionIndex[i]++;\nif ( positionIndex[i] &lt; endIndex[i] )\n</code></pre>\n<p>into something more optimized like</p>\n<pre><code>if ( positionIndex[i]++ &lt; endIndex[i] )\n</code></pre>\n<p>so</p>\n<pre><code>if ( positionIndex[i] + 1 &lt; endIndex[i] )\n</code></pre>\n<p>that causes undefined behavior in case of overflow (thanks Seth).</p>\n", "OwnerUserId": "121747", "LastEditorUserId": "121747", "LastEditDate": "2012-10-20T03:12:27.790", "Id": "12984885", "Score": "0", "CreationDate": "2012-10-20T03:03:17.037", "LastActivityDate": "2012-10-20T03:12:27.790"}, "18154467": {"ParentId": "12984861", "CommentCount": "0", "Body": "<p>In my case, this was a good warning from the compiler.  I had a stupid copy/paste bug where I had a loop inside a loop, and each was the same set of conditions.  Something like this:</p>\n<pre><code>for (index = 0; index &lt; someLoopLimit; index++)\n{\n    // blah, blah, blah.....\n    for (index = 0; index &lt; someLoopLimit; index++)\n    {\n        //  More blah, blah, blah....\n    }\n}\n</code></pre>\n<p>This warning saved me time debugging.  Thanks, gcc!!!</p>\n", "OwnerUserId": "2246302", "PostTypeId": "2", "Id": "18154467", "Score": "0", "CreationDate": "2013-08-09T19:43:22.903", "LastActivityDate": "2013-08-09T19:43:22.903"}, "17245156": {"ParentId": "12984861", "CommentCount": "0", "Body": "<p>This is almost certainly an error, even though I cannot tell which of three possible errors it is.</p>\n<p>I believe, that gcc is somehow figuring out what the values in 'this-&gt;m_PositionIndex[in]' etc. are computed from, namely that both values are derived from the same value, one with an offset it can also prove to be positive. Consequently it figures, that one branch of the if/else construct is unreachable code.</p>\n<p>This is bad. Definitely. Why? Well, there are exactly three possibilities:</p>\n<ol>\n<li><p>gcc is right in that the code is unreachable, and you overlooked that this is the case. In this case you simply have bloated code. Best of the three possibilities, but still bad in terms of code quality.</p></li>\n<li><p>gcc is right in that the code is unreachable, but you wanted it to be reachable. In this case, you need to take a second look at why it is not reachable and fix the bug in your logic.</p></li>\n<li><p>gcc is wrong, you have stumbled on a bug in it. Quite unlikely, but possible, and unfortunately very hard to prove.</p></li>\n</ol>\n<p>The really bad thing is, that you absolutely need to either find out exactly why the code is unreachable, or you need to disprove that gcc is right (which is easier said than done). According to Murphy's law, assuming case 1. or 3. without proving it will make sure that it was case 2., and that you will have to hunt for the bug a second time...</p>\n", "OwnerUserId": "2445184", "PostTypeId": "2", "Id": "17245156", "Score": "0", "CreationDate": "2013-06-21T22:19:15.603", "LastActivityDate": "2013-06-21T22:19:15.603"}, "18155193": {"ParentId": "12984861", "CommentCount": "0", "Body": "<p>The compiler is telling you that it has enough static knowledge of that snippet to know that test will always succeed if it can optimize the test assuming that no signed operation will overflow.</p>\n<p>In other words, the only way <code>x + 1 &lt; x</code> will ever return true when <code>x</code> is signed is if <code>x</code> is already the maximum signed value. <code>[-Wstrict-overflow]</code> let's the compiler warn when it can assume that no signed addition will overflow; it's basically telling you it's going to optimize away the test because signed overflow is undefined behavior.</p>\n<p>If you want to suppress the warning, get rid of the test.</p>\n", "OwnerUserId": "6210", "PostTypeId": "2", "Id": "18155193", "Score": "3", "CreationDate": "2013-08-09T20:34:45.047", "LastActivityDate": "2013-08-09T20:34:45.047"}, "bq_ids": {"n4140": {"so_12984861_17205195_0": {"section_id": 5937, "quality": 1.0, "length": 13}}, "n3337": {"so_12984861_17205195_0": {"section_id": 5709, "quality": 1.0, "length": 13}}, "n4659": {"so_12984861_17205195_0": {"section_id": 7421, "quality": 1.0, "length": 13}}}});