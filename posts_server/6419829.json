post_cb({"bq_ids": {"n4140": {"so_6419829_6419947_1": {"length": 14, "quality": 1.0, "section_id": 5861}}, "n3337": {"so_6419829_6419947_1": {"length": 14, "quality": 1.0, "section_id": 5631}}, "n4659": {"so_6419829_6419947_1": {"length": 9, "quality": 0.6428571428571429, "section_id": 6103}}}, "6419829": {"ViewCount": "833", "Body": "<pre><code>class private_object\n{\nprivate:\n  struct make_public;\n  friend struct make_public;\n  static void method1() {}\n};\n\nstruct private_object::make_public\n{\n  class nested_outer\n  {\n    void callFromOuter() \n    { private_object::method1(); }   // Should this be an error?\n\n    class nested_inner\n    {\n      void callFromInner() \n      { private_object::method1(); } // How about this one?\n    };\n  };\n};\n</code></pre>\n<p>This friendship issue came up when I was trying to port an open source project to compile under borland. According to <a href=\"http://www.parashift.com/c++-faq-lite/friends.html#faq-14.4\" rel=\"nofollow noreferrer\">parashift</a> and two semi-related questions <a href=\"https://stackoverflow.com/questions/5013717/are-inner-classes-in-c-automatically-friends\">here</a> and <a href=\"https://stackoverflow.com/questions/3584385/friend-access-to-protected-nested-class\">here</a>, the above example should not be valid. </p>\n<p>However, after testing it on <em>seven</em> different compilers<sup>1</sup>, only borland and dmc complained. This behavior surprised me because I wasn't expecting friendship to be transitive in nested classes.</p>\n<p>So this raises a couple of questions:</p>\n<ul>\n<li>What is the right behavior? I'm guessing it's the one accepted by most compilers.</li>\n<li>If this is the correct behavior, why is this instance of friendship transitivity ok?</li>\n<li>If this is correct then that would also imply a change in the standard. What might be the reasons for allowing this in the standard?</li>\n<li>For compilers that rejected this code, what would be an appropriate workaround? Keep in mind that an actual project might contain fairly deep nesting so I'm looking for a solution that's semi-scalable.</li>\n</ul>\n<p><sub>1. tested on mingw-gcc 4.5.2, clang, borland c++ builder2007, digital mars, open watcom, visualc2010 and comeau online</sub></p>\n", "AcceptedAnswerId": "6419947", "Title": "Are friends supposed to be transitive in nested classes?", "CreationDate": "2011-06-21T02:50:51.760", "Id": "6419829", "CommentCount": "0", "LastEditDate": "2017-11-16T12:05:54.567", "PostTypeId": "1", "LastEditorUserId": "1472253", "LastActivityDate": "2017-11-16T12:05:54.567", "Score": "5", "OwnerUserId": "234175", "Tags": "<c++><friend><standards-compliance>", "AnswerCount": "2"}, "6419947": {"Id": "6419947", "PostTypeId": "2", "Body": "<p>In C++03, nested class <em>cannot</em> access <code>private</code> and <code>protected</code> members of enclosing class by default (see \u00a711.8/1). But if you make them friend of the enclosing classs, then they can access them. But again nested class of nested class is still not friend of the outermost enclosing class, the nested class of the nested class cannot access private and protected members of the outermost enclosing class; it cannot even access the private and protected member of the immediate enclosing class, as noted earlier. What you're doing is that, hence that is not allowed. </p>\n<p>The C++ Standard (2003) says in $11.8/1 [class.access.nest],</p>\n<blockquote>\n<p id=\"so_6419829_6419947_0\"><strong>The members of a nested class have no\n  special access to members of an\n  enclosing class</strong>, nor to classes or\n  functions that have granted friendship\n  to an enclosing class; the usual\n  access rules (clause 11) shall be\n  obeyed. <strong>The members of an enclosing\n  class have no special access to\n  members of a nested class;</strong> the usual\n  access rules (clause 11) shall be\n  obeyed.</p>\n</blockquote>\n<p>Example from the Standard itself:</p>\n<pre><code>class E \n{\n    int x;\n    class B { };\n    class I \n    {\n        B b; // error: E::B is private\n        int y;\n        void f(E* p, int i)\n        {\n           p-&gt;x = i; // error: E::x is private\n        }\n   };\n   int g(I* p)\n   {\n       return p-&gt;y; // error: I::y is private\n   }\n};\n</code></pre>\n<hr>\n<h1>Its a defect in the C++03 Standard.</h1>\n<p>By the way, its a <strong>defect</strong> in the C++03 Standard. Since the nested class is a member, it should have access to private and protected members, just like any other member:</p>\n<p>\u00a79.2/1 (C++03):</p>\n<blockquote>\n<p id=\"so_6419829_6419947_1\">Members of a class are data members, member functions (9.3), <strong>nested types</strong>\u2026 Nested types are classes (9.1, 9.7) and enumerations (7.2) defined in the class\u2026</p>\n</blockquote>\n<p>See this <strong>Defect Report</strong> : </p>\n<ul>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#45\" rel=\"nofollow\">45. Access to nested classes</a></li>\n</ul>\n</hr>", "LastEditorUserId": "415784", "LastActivityDate": "2011-06-21T03:18:00.547", "Score": "3", "CreationDate": "2011-06-21T03:12:30.970", "ParentId": "6419829", "CommentCount": "0", "LastEditDate": "2011-06-21T03:18:00.547", "OwnerUserId": "415784"}, "6419870": {"Id": "6419870", "PostTypeId": "2", "Body": "<p>I somehow feel that this should be <strong>allowed</strong>. Though I am not sure about the standard behavior. Someone can point out.</p>\n<blockquote>\n<p id=\"so_6419829_6419870_0\">For compilers that rejected this code,\n  what would be an appropriate\n  workaround?</p>\n</blockquote>\n<p>Best I can think of is to make a wrapper:</p>\n<pre><code>struct private_object::make_public\n{\n  static void wrap_method1() { private_object::method1(); }\n  // use wrap_method1() everywhere else\n  // ...\n};\n</code></pre>\n", "LastActivityDate": "2011-06-21T02:58:33.670", "Score": "1", "CreationDate": "2011-06-21T02:58:33.670", "ParentId": "6419829", "CommentCount": "0", "OwnerUserId": "514235"}});