post_cb({"bq_ids": {"n4140": {"so_46646773_46647140_0": {"length": 42, "quality": 0.8936170212765957, "section_id": 5891}, "so_46646773_46647030_2": {"length": 20, "quality": 0.9090909090909091, "section_id": 6682}, "so_46646773_46647030_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 7113}}, "n3337": {"so_46646773_46647140_0": {"length": 42, "quality": 0.8936170212765957, "section_id": 5662}, "so_46646773_46647030_2": {"length": 20, "quality": 0.9090909090909091, "section_id": 6437}, "so_46646773_46647030_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 6857}}, "n4659": {"so_46646773_46647140_0": {"length": 42, "quality": 0.8936170212765957, "section_id": 7374}, "so_46646773_46647030_2": {"length": 20, "quality": 0.9090909090909091, "section_id": 8157}, "so_46646773_46647030_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 8614}}}, "46647140": {"Id": "46647140", "PostTypeId": "2", "Body": "<p>Yes. These are extract of the c++ standard grammar rules:</p>\n<pre><code>id-expression:\n  unqualified-id\n  qualified-id\n\npostfix-expression:\n  [...]\n  postfix-expression . template[opt] id-expression\n  [...]\n</code></pre>\n<p>In [class.mcft.non-static]:</p>\n<blockquote>\n<p id=\"so_46646773_46647140_0\">When an id-expression (8.1) that is not part of a class member access syntax (8.2.5) and not used to form\n  a pointer to member (8.3.1) is used in a member of class X in a context where this can be used (8.1.2), if\n  name lookup (6.4) resolves the name in the id-expression to a non-static non-type member of some class\n  C, and if either the id-expression is potentially evaluated or C is X or a base class of X, the id-expression is\n  transformed into a class member access expression (8.2.5) using (*this) (12.2.2.1) as the postfix-expression\n  to the left of the . operator.</p>\n</blockquote>\n", "LastActivityDate": "2017-10-09T13:00:41.717", "CommentCount": "0", "CreationDate": "2017-10-09T13:00:41.717", "ParentId": "46646773", "Score": "1", "OwnerUserId": "5632316"}, "46647030": {"Id": "46647030", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_46646773_46647030_0\">Is <code>B::i</code> well-formed?</p>\n</blockquote>\n<p>Yes, it is. The most pertinent reference is <a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.qual#1\" rel=\"nofollow noreferrer\">[class.qual]/1</a>:</p>\n<blockquote>\n<p id=\"so_46646773_46647030_1\">If the nested-name-specifier of a qualified-id nominates a class, the\n  name specified after the nested-name-specifier is looked up in the\n  scope of the class, except for the cases listed below. <strong>The name\n  shall represent one or more members of that class or of one of its\n  base classes</strong>.</p>\n</blockquote>\n<p>Which specifies you can name <code>i</code> on account of it being a member of <code>B</code>'s base. The accessibility is only checked afterwards, and in your case it's public.</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.access#base-5\" rel=\"nofollow noreferrer\">[class.access.base]/5</a></p>\n<blockquote>\n<p id=\"so_46646773_46647030_2\">... The access to a member is affected by the class in which the\n  member is named. This naming class is the class in which the member\n  name was looked up and found... A member m is accessible at the point\n  R when named in class N if</p>\n<ul>\n<li>there exists a base class B of N that is accessible at R, and m is accessible at R when named in class B.</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "817643", "LastActivityDate": "2017-10-09T13:01:25.600", "Score": "5", "CreationDate": "2017-10-09T12:55:05.197", "ParentId": "46646773", "CommentCount": "0", "OwnerUserId": "817643", "LastEditDate": "2017-10-09T13:01:25.600"}, "46646773": {"ViewCount": "227", "Body": "<p>Here is an example of multiple inheritance. I used the scope resolution operator to resolve the ambiguity instead of a virtual class.</p>\n<pre><code>struct A \n{\n    int i;\n};\n\nstruct B : A\n{};\n\nstruct C : A\n{};\n\nstruct D: B, C \n{\n    void f()\n    {\n        B::i = 10;\n    }\n    void g()\n    {\n        std::cout &lt;&lt; B::i &lt;&lt;std::endl;\n    }\n};\n\nint main() \n{\n    D d1;\n    d1.f();\n    d1.g();\n    return 0;\n}\n</code></pre>\n<p>Is <code>B::i</code> well-formed?</p>\n", "AcceptedAnswerId": "46647030", "Title": "Avoid multiple inheritance induced ambiguity by using scope resolution", "CreationDate": "2017-10-09T12:43:14.520", "Id": "46646773", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-10-10T05:57:38.787", "LastEditorUserId": "6935629", "LastActivityDate": "2017-10-10T05:57:38.787", "Score": "4", "OwnerUserId": "6935629", "Tags": "<c++><c++11><inheritance><multiple-inheritance><diamond-problem>", "AnswerCount": "2"}});