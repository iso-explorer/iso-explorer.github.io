post_cb({"1934449": {"ParentId": "1934367", "CommentCount": "0", "Body": "<p>Calling a non-const (by declaration) member function on a const object is not illegal per se. You can use whatever method you wish to work around the compiler restrictions: either an explicit <code>const_cast</code> or a trick with constructor as in your example.</p>\n<p>However, the behavior is only defined as long as the member function you are calling does not make an attempt to actually physically <em>modify</em> the object (i.e. modify a non-mutable member of the constant object). Once it makes an attempt to perform a modification, the behavior becomes undefined. In your case, method <code>inc</code> modifies the object, meaning that in your example the behavior is undefined.</p>\n<p>Just calling the method, again, is perfectly legal.</p>\n", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "1934449", "Score": "1", "CreationDate": "2009-12-19T23:24:35.923", "LastActivityDate": "2009-12-19T23:24:35.923"}, "1934456": {"ParentId": "1934367", "CommentCount": "2", "Body": "<p>Yes, it is undefined behavior, as per 7.1.5.1/4:</p>\n<blockquote>\n<p id=\"so_1934367_1934456_0\">Except that any class member declared mutable (7.1.1) can be modified, any attempt to modify a const object during its lifetime (3.8) results in undefined behavior.</p>\n</blockquote>\n<p>Note that object's lifetime begins when the constructor call has completed (3.8/1).</p>\n", "OwnerUserId": "89847", "PostTypeId": "2", "Id": "1934456", "Score": "3", "CreationDate": "2009-12-19T23:27:04.733", "LastActivityDate": "2009-12-19T23:27:04.733"}, "1934367": {"CommentCount": "2", "CreationDate": "2009-12-19T22:57:20.707", "PostTypeId": "1", "AcceptedAnswerId": "1934456", "LastEditorUserId": "19100", "LastActivityDate": "2009-12-19T23:52:09.677", "LastEditDate": "2009-12-19T23:24:44.537", "ViewCount": "3173", "FavoriteCount": "1", "Title": "Indirectly calling non-const function on a const object", "Id": "1934367", "Score": "3", "Body": "<p>Given the following code:</p>\n<pre><code>class foo;\n\nfoo* instance = NULL;\n\nclass foo\n{\npublic:\n   explicit foo(int j)\n    : i(j)\n   {\n      instance = this;\n   }\n\n   void inc()\n   {\n      ++i;\n   }\n\nprivate:\n   int i;\n};\n</code></pre>\n<p>Is the following using defined behavior?</p>\n<pre><code>const foo f(0);\n\nint main()\n{\n   instance-&gt;inc();\n}\n</code></pre>\n<p>I'm asking because I'm using a class registry, and as I don't directly modify <code>f</code> it would be nice to make it <code>const</code>, but then later on <code>f</code> is modified indirectly by the registry.</p>\n<p>EDIT: By defined behavior I mean: Is the object placed into some special memory location which can only be written to once? Read-only memory is out of the question, at least until constexpr of C++1x. Constant primitive types for instance, are (often) placed into read-only memory, and doing a <code>const_cast</code> on it may result in undefined behavior, for instance:</p>\n<pre><code>int main()\n{\n    const int i = 42;\n    const_cast&lt;int&amp;&gt;(i) = 0; // UB\n}\n</code></pre>\n", "Tags": "<c++><function><const><undefined-behavior>", "OwnerUserId": "19100", "AnswerCount": "7"}, "1934435": {"ParentId": "1934367", "CommentCount": "1", "Body": "<p>It's hard to tell the intent with these arbitrary names. If <code>i</code> is intended as just a use counter, and it isn't really considered part of the data, then it is perfectly appropriate to declare it as <code>mutable int i;</code> Then the <code>const</code>-ness of an instance is not violated when <code>i</code> is modified. On the other hand, if <code>i</code> is meaningful data in the space being modeled, then that would be a very bad thing to do.</p>\n<p>Separately from that, though, your example is a bit of a mess for what you seem to be asking. <code>foo* instance = NULL;</code> is effectively (if confusingly) using a <code>NULL</code> as a numeric zero and initializing <code>instance</code>, which is not <code>const</code>; then you separately initialize <code>f</code>, which is <code>const</code>, but never reference it.</p>\n", "OwnerUserId": "217246", "PostTypeId": "2", "Id": "1934435", "Score": "0", "CreationDate": "2009-12-19T23:18:54.983", "LastActivityDate": "2009-12-19T23:18:54.983"}, "1934388": {"ParentId": "1934367", "CommentCount": "4", "Body": "<p>This may be one of the rare cases where the not very known <code>mutable</code> keyword could be used:</p>\n<p><code>mutable int i;</code></p>\n<p><code>i</code> can now be changed even if the object is const. It's used when <strong>logically</strong> the object doesn't change, but in reality it does.</p>\n<hr>\n<p>For example:</p>\n<pre><code>class SomeClass\n{\n// ....\n    void DoSomething() { mMutex.lock(); ...; }\n    mutable Mutex mMutex;\n}\n</code></pre>\n<p>In <code>DoSomething()</code> the object doesn't logically change and yet mMutex has to change in order to lock it. So it makes sense to make it <code>mutable</code>, otherwise no instance of SomeClass could be <code>const</code> (assuming you lock the muetx for every operation).</p>\n</hr>", "OwnerUserId": "95135", "PostTypeId": "2", "Id": "1934388", "Score": "1", "CreationDate": "2009-12-19T23:02:48.993", "LastActivityDate": "2009-12-19T23:02:48.993"}, "1934503": {"ParentId": "1934367", "CommentCount": "1", "Body": "<p>If you define a const instance of the object, then cast away the const-ness, and modify the contents of the object, you get undefined behavior.</p>\n<p>From the sound of things, what you want is exactly the opposite: create a non-const instance of the object, then return a const pointer to that object to (most of) the clients, while the \"owner\" retains a non-const pointer to the object so it can modify members as it sees fit.</p>\n<p>You'd typically manage a situation like this by defining the class with a private ctor, so most clients can't create objects of the type. The class will then declare the owner class as a friend, so it can use the private ctor and/or a static member function to create instances (or often only one instance) of the object. The owner class then passes out pointers (or references) to const objects for clients to use. You need neither a mutable member nor to cast away constness, because the owner, which has the \"right\" to modify the object, always has a non-const pointer (or, again, reference) to the object. Its clients receive only const pointers/references, preventing modification.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "1934503", "Score": "2", "CreationDate": "2009-12-19T23:52:09.677", "LastActivityDate": "2009-12-19T23:52:09.677"}, "1934440": {"ParentId": "1934367", "CommentCount": "1", "Body": "<p>Under GCC, at least, your constructor should be <code>explicit foo(int j)</code> with the word <code>int</code>.</p>\n<p>However, it's perfectly fine to have two pointers to the same value, one <code>const</code> and the other not.</p>\n", "OwnerUserId": "209359", "PostTypeId": "2", "Id": "1934440", "Score": "0", "CreationDate": "2009-12-19T23:21:18.490", "LastActivityDate": "2009-12-19T23:21:18.490"}, "bq_ids": {"n4140": {"so_1934367_1934456_0": {"section_id": 5433, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_1934367_1934456_0": {"section_id": 5228, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_1934367_1934456_0": {"section_id": 6861, "quality": 0.9444444444444444, "length": 17}}}, "1934396": {"ParentId": "1934367", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Why dont you make use of const cast ?</p>\n<p>Any reason to make object as const eventhough its state is not constant?</p>\n<p>Also make following change :</p>\n<pre><code>explicit foo(int j = 0)    : i(j)   \n\n{    instance = this;   }\n</code></pre>\n", "OwnerUserId": "303986", "LastEditorUserId": "303986", "LastEditDate": "2009-12-19T23:28:39.693", "Id": "1934396", "Score": "0", "CreationDate": "2009-12-19T23:05:22.907", "LastActivityDate": "2009-12-19T23:28:39.693"}});