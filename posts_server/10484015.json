post_cb({"10485296": {"ParentId": "10484015", "CommentCount": "2", "Body": "<p>I believe the library is trying to find out if your iterator is an input_iterator or a random_access_iterator by looking for the nested typedefs a well behaved iterator should contain. Specifically <code>iterator_category</code>.</p>\n<p>The standard suggests inheriting from <code>std::iterator</code> to get appropriate definitions.</p>\n<blockquote>\n<p id=\"so_10484015_10485296_0\"><strong>24.4.2 Basic iterator</strong><br>\n  The <code>iterator</code> template may be used as a base class to ease the definition of required types for new iterators.</br></p>\n</blockquote>\n<pre><code>namespace std {\n\n    template&lt;class Category, class T, class Distance = ptrdiff_t,\n             class Pointer = T*, class Reference = T&amp;&gt;\n    struct iterator {\n        typedef T value_type;\n\n        typedef Distance difference_type;\n\n        typedef Pointer pointer;\n\n        typedef Reference reference;\n\n        typedef Category iterator_category;\n\n    };\n\n}\n</code></pre>\n<p>Or you can just add the same set of typedefs to your existing class.</p>\n", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "10485296", "Score": "0", "CreationDate": "2012-05-07T16:03:38.537", "LastActivityDate": "2012-05-07T16:03:38.537"}, "10484015": {"CommentCount": "0", "ViewCount": "593", "CreationDate": "2012-05-07T14:40:03.260", "LastActivityDate": "2012-05-07T16:03:38.537", "Title": "G++/MSVC++2008 difference for calling inner_product() in a matrix implement", "PostTypeId": "1", "Id": "10484015", "Score": "2", "Body": "<p>I would like to get some help for a weird problem.  For a code got from online about matrix,\nI can compile and run on g++ but fail to build on VC++ 2008.  The build error from vc++ is </p>\n<pre><code>------ Build started: Project: Matrix, Configuration: Debug Win32 ------\nCompiling...Matrix.cpp\n\nc:\\matrix\\matrix\\matrix.cpp(260) : warning C4996: 'std::inner_product': Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'\n\nc:\\program files (x86)\\microsoft visual studio 9.0\\vc\\include\\numeric(103) : see    declaration of 'std::inner_product'\nc:\\matrix\\matrix\\matrix.cpp(275) : warning C4996: 'std::inner_product': Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'\n\nc:\\program files (x86)\\microsoft visual studio 9.0\\vc\\include\\numeric(103) : see declaration of 'std::inner_product'\n\nc:\\matrix\\matrix\\matrix.cpp(288) : warning C4018: '&lt;' : signed/unsigned mismatch\n\nc:\\matrix\\matrix\\matrix.cpp(290) : warning C4018: '&lt;' : signed/unsigned mismatch\n\nc:\\matrix\\matrix\\matrix.cpp(346) : warning C4018: '&lt;' : signed/unsigned mismatch\n\nc:\\program files (x86)\\microsoft visual studio 9.0\\vc\\include\\xutility(1598) : error C2665: 'std::_Debug_range2' : none of the 2 overloads could convert all the argument types\n\nc:\\program files (x86)\\microsoft visual studio 9.0\\vc\\include\\xutility(1577): \n    could be 'void std::_Debug_range2&lt;_InIt&gt;(_InIt,_InIt,const wchar_t *,unsigned \n    int,std::input_iterator_tag)'\n    with\n    [\n        _InIt=Cslice_iter&lt;double&gt;\n    ]\n    c:\\program files (x86)\\microsoft visual studio 9.0\\vc\\include\\xutility(1583):      \n    or       'void std::_Debug_range2&lt;_InIt&gt;(_RanIt,_RanIt,const wchar_t *,unsigned \n    int,std::random_access_iterator_tag)'\n    with\n    [\n        _InIt=Cslice_iter&lt;double&gt;,\n        _RanIt=Cslice_iter&lt;double&gt;\n    ]\n    while trying to match the argument list '(Cslice_iter&lt;T&gt;, Cslice_iter&lt;T&gt;, const wchar_t *, unsigned int, double)'\n    with\n    [\n        T=double\n    ]\n    c:\\program files (x86)\\microsoft visual studio 9.0\\vc\\include\\numeric(63) : see reference to function template instantiation 'void std::_Debug_range&lt;_InIt1&gt;(_InIt,_InIt,const wchar_t *,unsigned int)' being compiled\n    with\n    [\n        _InIt1=Cslice_iter&lt;double&gt;,\n        _InIt=Cslice_iter&lt;double&gt;\n    ]\n    c:\\program files (x86)\\microsoft visual studio 9.0\\vc\\include\\numeric(106) : see reference to function template instantiation '_Ty std::_Inner_product&lt;Cslice_iter&lt;T&gt;,_InIt2,_Ty,std::_Iter_random_helper&lt;_Cat1,_Cat2&gt;::_Iter_random_cat&gt;(_InIt1,_InIt1,_InIt2,_Ty,_InItCats,std::_Range_checked_iterator_tag)' being compiled\n    with\n    [\n        _Ty=double,\n        T=double,\n        _InIt2=double *,\n        _Cat1=double,\n        _Cat2=std::random_access_iterator_tag,\n        _InIt1=Cslice_iter&lt;double&gt;,\n        _InItCats=std::_Iter_random_helper&lt;double,std::random_access_iterator_tag&gt;::_Iter_random_cat\n    ]\n    c:\\matrix\\matrix\\matrix.cpp(260) : see reference to function template instantiation 'double std::inner_product&lt;Cslice_iter&lt;T&gt;,_Ty*,double&gt;(_InIt1,_InIt1,_InIt2,_Ty)' being compiled\n    with\n    [\n        T=double,\n        _Ty=double,\n        _InIt1=Cslice_iter&lt;double&gt;,\n        _InIt2=double *\n    ]\nBuild log was saved at \"file://c:\\Matrix\\Matrix\\Debug\\BuildLog.htm\"\nMatrix - 1 error(s), 5 warning(s)\n========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========\n</code></pre>\n<p>Any help is really appreciated.</p>\n<p>Thanks very much.</p>\n<pre><code>// Program to test slices and a simple N*M matrix class\n\n\n\n#include&lt;iostream&gt;\n#include&lt;valarray&gt;\n#include&lt;algorithm&gt;\n#include&lt;numeric&gt;   // for inner_product\nusing namespace std;\n\n// forward declarations to allow friend declarations:\ntemplate&lt;class T&gt; class Slice_iter;\ntemplate&lt;class T&gt; bool operator==(const Slice_iter&lt;T&gt;&amp;, const Slice_iter&lt;T&gt;&amp;);\ntemplate&lt;class T&gt; bool operator!=(const Slice_iter&lt;T&gt;&amp;, const Slice_iter&lt;T&gt;&amp;);\ntemplate&lt;class T&gt; bool operator&lt; (const Slice_iter&lt;T&gt;&amp;, const Slice_iter&lt;T&gt;&amp;);\n\ntemplate&lt;class T&gt; class Slice_iter {\nvalarray&lt;T&gt;* v;\nslice s;\nsize_t curr;    // index of current element\n\nT&amp; ref(size_t i) const { return (*v)[s.start()+i*s.stride()]; }\npublic:\nSlice_iter(valarray&lt;T&gt;* vv, slice ss) :v(vv), s(ss), curr(0) { }\n\nSlice_iter end() const\n{\n    Slice_iter t = *this;\n    t.curr = s.size();  // index of last-plus-one element\n    return t;\n}\n\nSlice_iter&amp; operator++() { curr++; return *this; }\nSlice_iter operator++(int) { Slice_iter t = *this; curr++; return t; }\n\nT&amp; operator[](size_t i) { return ref(i); }      // C style subscript\nT&amp; operator()(size_t i) { return ref(i); }      // Fortran-style subscript\nT&amp; operator*() { return ref(curr); }            // current element\n\nfriend bool operator==&lt;&gt;(const Slice_iter&amp; p, const Slice_iter&amp; q);\nfriend bool operator!=&lt;&gt;(const Slice_iter&amp; p, const Slice_iter&amp; q);\nfriend bool operator&lt; &lt;&gt;(const Slice_iter&amp; p, const Slice_iter&amp; q);\n\n};\n\n\ntemplate&lt;class T&gt;\nbool operator==(const Slice_iter&lt;T&gt;&amp; p, const Slice_iter&lt;T&gt;&amp; q)\n{\nreturn p.curr==q.curr\n    &amp;&amp; p.s.stride()==q.s.stride()\n    &amp;&amp; p.s.start()==q.s.start();\n}\n\ntemplate&lt;class T&gt;\nbool operator!=(const Slice_iter&lt;T&gt;&amp; p, const Slice_iter&lt;T&gt;&amp; q)\n{\nreturn !(p==q);\n}\n\ntemplate&lt;class T&gt;\nbool operator&lt;(const Slice_iter&lt;T&gt;&amp; p, const Slice_iter&lt;T&gt;&amp; q)\n{\nreturn p.curr&lt;q.curr\n    &amp;&amp; p.s.stride()==q.s.stride()\n    &amp;&amp; p.s.start()==q.s.start();\n}\n\n\n//-------------------------------------------------------------\n\n\n\n// forward declarations to allow friend declarations:\ntemplate&lt;class T&gt; class Cslice_iter;\ntemplate&lt;class T&gt; bool operator==(const Cslice_iter&lt;T&gt;&amp;, const Cslice_iter&lt;T&gt;&amp;);\ntemplate&lt;class T&gt; bool operator!=(const Cslice_iter&lt;T&gt;&amp;, const Cslice_iter&lt;T&gt;&amp;);\ntemplate&lt;class T&gt; bool operator&lt; (const Cslice_iter&lt;T&gt;&amp;, const Cslice_iter&lt;T&gt;&amp;);\n\n\ntemplate&lt;class T&gt; class Cslice_iter\n{\nvalarray&lt;T&gt;* v;\nslice s;\nsize_t curr; // index of current element\nconst T&amp; ref(size_t i) const { return (*v)[s.start()+i*s.stride()]; }\npublic:\nCslice_iter(valarray&lt;T&gt;* vv, slice ss): v(vv), s(ss), curr(0){}\n//typedef T        iterator_category; //I added these defs, otherwise more compile errors on vc++\n//typedef T        value_type;        //after I uncomment these, build only fails at call inner_product     \n//typedef T*       iterator;          //and transform calls.\n//typedef const T* const_iterator;\n//typedef T&amp;       reference;\n//typedef const T&amp; const_reference;\n//typedef T*       pointer;\n//typedef std::size_t    size_type;\ntypedef std::ptrdiff_t difference_type;\n\nCslice_iter end() const\n{\n    Cslice_iter t = *this;\n    t.curr = s.size(); // index of one plus last element\n    return t;\n}\nCslice_iter&amp; operator++() { curr++; return *this; }\nCslice_iter operator++(int) { Cslice_iter t = *this; curr++; return t; }\n\nconst T&amp; operator[](size_t i) const { return ref(i); }\nconst T&amp; operator()(size_t i) const { return ref(i); }\nconst T&amp; operator*() const { return ref(curr); }\n\nfriend bool operator==&lt;&gt;(const Cslice_iter&amp; p, const Cslice_iter&amp; q);\nfriend bool operator!=&lt;&gt;(const Cslice_iter&amp; p, const Cslice_iter&amp; q);\nfriend bool operator&lt; &lt;&gt;(const Cslice_iter&amp; p, const Cslice_iter&amp; q);\n\n};\n\ntemplate&lt;class T&gt;\nbool operator==(const Cslice_iter&lt;T&gt;&amp; p, const Cslice_iter&lt;T&gt;&amp; q)\n{\nreturn p.curr==q.curr\n    &amp;&amp; p.s.stride()==q.s.stride()\n    &amp;&amp; p.s.start()==q.s.start();\n}\n\ntemplate&lt;class T&gt;\nbool operator!=(const Cslice_iter&lt;T&gt;&amp; p, const Cslice_iter&lt;T&gt;&amp; q)\n{\nreturn !(p==q);\n}\n\ntemplate&lt;class T&gt;\nbool operator&lt;(const Cslice_iter&lt;T&gt;&amp; p, const Cslice_iter&lt;T&gt;&amp; q)\n{\nreturn p.curr&lt;q.curr\n    &amp;&amp; p.s.stride()==q.s.stride()\n    &amp;&amp; p.s.start()==q.s.start();\n}\n\n\n//-------------------------------------------------------------\n\n\nclass Matrix {\nvalarray&lt;double&gt;* v;    // stores elements by column as described in 22.4.5\nsize_t d1, d2;  // d1 == number of columns, d2 == number of rows\npublic:\nMatrix(size_t x, size_t y);     // note: no default constructor\nMatrix(const Matrix&amp;);\nMatrix&amp; operator=(const Matrix&amp;);\n~Matrix();\n\nsize_t size() const { return d1*d2; }\nsize_t dim1() const { return d1; }\nsize_t dim2() const { return d2; }\n\nSlice_iter&lt;double&gt; row(size_t i);\nCslice_iter&lt;double&gt; row(size_t i) const;\n\nSlice_iter&lt;double&gt; column(size_t i);\nCslice_iter&lt;double&gt; column(size_t i) const;\n\ndouble&amp; operator()(size_t x, size_t y); // Fortran-style subscripts\ndouble operator()(size_t x, size_t y) const;\n\nSlice_iter&lt;double&gt; operator()(size_t i) { return column(i); }\nCslice_iter&lt;double&gt; operator()(size_t i) const { return column(i); }\n\nSlice_iter&lt;double&gt; operator[](size_t i) { return column(i); }// C-style subscript\nCslice_iter&lt;double&gt; operator[](size_t i) const { return column(i); }\n\nMatrix&amp; operator*=(double);\n\nvalarray&lt;double&gt;&amp; array() { return *v; }\n};\n\n\ninline Slice_iter&lt;double&gt; Matrix::row(size_t i)\n{\nreturn Slice_iter&lt;double&gt;(v,slice(i,d1,d2));\n}\n\ninline Cslice_iter&lt;double&gt; Matrix::row(size_t i) const\n{\nreturn Cslice_iter&lt;double&gt;(v,slice(i,d1,d2));\n}\n\ninline Slice_iter&lt;double&gt; Matrix::column(size_t i)\n{\nreturn Slice_iter&lt;double&gt;(v,slice(i*d2,d2,1));\n}\n\ninline Cslice_iter&lt;double&gt; Matrix::column(size_t i) const\n{\nreturn Cslice_iter&lt;double&gt;(v,slice(i*d2,d2,1));\n}\n\nMatrix::Matrix(size_t x, size_t y)\n{\n// check that x and y are sensible\nd1 = x;\nd2 = y;\nv = new valarray&lt;double&gt;(x*y);\n}\n\nMatrix::~Matrix()\n{\ndelete v;\n}\n\ndouble&amp; Matrix::operator()(size_t x, size_t y)\n{\nreturn column(x)[y];\n}\n\n\n\n//-------------------------------------------------------------\n\n\n\n\ndouble mul(const Cslice_iter&lt;double&gt;&amp; v1, const valarray&lt;double&gt;&amp; v2)\n{\ndouble res = 0;\nfor (size_t i = 0; i&lt;v2.size(); i++) res+= v1[i]*v2[i];\nreturn res;\n}\n\n\nvalarray&lt;double&gt; operator*(const Matrix&amp; m, const valarray&lt;double&gt;&amp; v)\n{\nif (m.dim1()!=v.size()) cerr &lt;&lt; \"wrong number of elements in m*v\\n\";\n\nvalarray&lt;double&gt; res(m.dim2());\nfor (size_t i = 0; i&lt;m.dim2(); i++) res[i] = mul(m.row(i),v);\nreturn res;\n}\n\n\n// alternative definition of m*v\n\n//valarray&lt;double&gt; operator*(const Matrix&amp; m, valarray&lt;double&gt;&amp; v)\nvalarray&lt;double&gt; mul_mv(const Matrix&amp; m, valarray&lt;double&gt;&amp; v)\n{\nif (m.dim1()!=v.size()) cerr &lt;&lt; \"wrong number of elements in m*v\\n\";\n\nvalarray&lt;double&gt; res(m.dim2());\n\nfor (size_t i = 0; i&lt;m.dim2(); i++) {\n    const Cslice_iter&lt;double&gt;&amp; ri = m.row(i);\n    res[i] = inner_product(ri,ri.end(),&amp;v[0],double(0));\n}\nreturn res;\n}\n\n\n\nvalarray&lt;double&gt; operator*(valarray&lt;double&gt;&amp; v, const Matrix&amp; m)\n{\nif (v.size()!=m.dim2()) cerr &lt;&lt; \"wrong number of elements in v*m\\n\";\n\nvalarray&lt;double&gt; res(m.dim1());\n\nfor (size_t i = 0; i&lt;m.dim1(); i++) {\n    const Cslice_iter&lt;double&gt;&amp; ci = m.column(i);\n    res[i] = inner_product(ci,ci.end(),&amp;v[0],double(0));\n}\nreturn res;\n}\n\nMatrix&amp; Matrix::operator*=(double d)\n{\n(*v) *= d;\nreturn *this;\n}\n\nostream&amp; operator&lt;&lt;(ostream&amp; os, Matrix&amp; m)\n{\nfor(int y=0; y&lt;m.dim2(); y++)\n{\n    for(int x=0; x&lt;m.dim1(); x++)\n        os&lt;&lt;m[x][y]&lt;&lt;\"\\t\";\n    os &lt;&lt; \"\\n\";\n}\nreturn os;\n}\n\n\n//-------------------------------------------------------------\n\n\nvoid f (int x_max, int y_max)   // test layout and basic access\n{\ncout &lt;&lt; \"\\nf(\" &lt;&lt; x_max &lt;&lt;\",\" &lt;&lt; y_max &lt;&lt; \"):\\n\";\n\nMatrix a(x_max, y_max);\n\nfor(int x=0; x&lt;x_max; x++)      // initialize\n    for(int y=0; y&lt;y_max; y++)\n        a[x][y]=x+y*10;\n\ncout&lt;&lt;\"C-style access used to initialize:\\n\" &lt;&lt; a;\n\nfor(int x=0; x&lt;x_max; x++)\n    for(int y=0; y&lt;y_max; y++)\n        a(x,y)=x+y*10;\n\ncout &lt;&lt;\"Fortran-style access used to initialize:\\n\" &lt;&lt; a;\n\ncout &lt;&lt; \"addresses: \\n\";\n\nfor(int x=0; x&lt;x_max; x++)\n    for(int y=0; y&lt;y_max; y++)\n        cout&lt;&lt;\"(\"&lt;&lt; x&lt;&lt;\",\"&lt;&lt;y&lt;&lt;\") at \"&lt;&lt;&amp;a[x][y]-&amp;a[0][0]&lt;&lt;\"\\n\";\ncout &lt;&lt;\"columns :\\n\";\n\nfor(int x=0; x&lt;x_max; x++) {\n    cout &lt;&lt; \"column \" &lt;&lt; x &lt;&lt; \":\\n\";\n    for (Slice_iter&lt;double&gt; c = a.column(x); c!=c.end(); ++c)\n        cout &lt;&lt; \"\\t\" &lt;&lt; *c &lt;&lt;\"\\n\";\n}\n\ncout &lt;&lt;\"rows :\\n\";\n\nfor(int y=0; y&lt;y_max; y++) {\n    cout &lt;&lt; \"row \" &lt;&lt; y &lt;&lt; \":\";\n    for(Slice_iter&lt;double&gt; r = a.row(y); r!=r.end(); ++r)\n        cout &lt;&lt; \"\\t\" &lt;&lt; *r ;\n    cout &lt;&lt;\"\\n\";\n}\n\n\n}\n\nostream&amp; operator&lt;&lt;(ostream&amp; os, const valarray&lt;double&gt;&amp; v)\n{\nfor (int i = 0; i&lt;v.size(); ++i) os &lt;&lt; '\\t' &lt;&lt; v[i];\nreturn os;\n}\n\nvoid g(int x_max,int y_max) // check multiplication\n{\ncout &lt;&lt; \"\\ng(\" &lt;&lt; x_max &lt;&lt;\",\" &lt;&lt; y_max &lt;&lt; \"):\\n\";\n\nMatrix a(x_max,y_max);\n\nfor(int x=0; x&lt;x_max; x++)      // initialize\n    for(int y=0; y&lt;y_max; y++)\n        a[x][y]=x+y*10;\n\nvalarray&lt;double&gt; r(2,x_max);\ncout &lt;&lt; \"a*v: \" &lt;&lt; a*r &lt;&lt; endl;\ncout &lt;&lt; \"m*v: \" &lt;&lt; mul_mv(a,r) &lt;&lt; endl;\n\nvalarray&lt;double&gt; c(2,y_max);\ncout &lt;&lt; \"v*a: \" &lt;&lt; c*a &lt;&lt; endl;\n\n}\n\nint main()\n{\nf(3,4);\nf(4,3);\n\ng(3,4);\ng(4,3);\n}\n\n\n//main for vc++\n/*int _tmain(int argc, _TCHAR* argv[])\n{\nf(3,4);\nf(4,3);\n\ng(3,4);\ng(4,3);\n\nreturn 0;\n}*/\n\n// the stdafx.h from vc++\n// stdafx.h : include file for standard system include files,\n// or project specific include files that are used frequently, but\n// are changed infrequently\n//\n\n/*#pragma once\n\n#include \"targetver.h\"\n\n#include &lt;stdio.h&gt;\n#include &lt;tchar.h&gt;\n*/\n</code></pre>\n", "Tags": "<c++><visual-c++>", "OwnerUserId": "1373694", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_10484015_10485296_0": {"section_id": 5587, "quality": 0.7333333333333333, "length": 11}}, "n3337": {"so_10484015_10485296_0": {"section_id": 5370, "quality": 0.7333333333333333, "length": 11}}, "n4659": {"so_10484015_10485296_0": {"section_id": 6429, "quality": 0.7333333333333333, "length": 11}}}});