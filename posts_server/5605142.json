post_cb({"5612606": {"ParentId": "5605142", "PostTypeId": "2", "CommentCount": "2", "Body": "<h2>Critical Update</h2>\n<p><em>The below analysis is wrong, because it confuses one important thing</em>. The following statement I did missed one important detail, which requires an entirely different answer.</p>\n<blockquote>\n<p id=\"so_5605142_5612606_0\">The unnamed reference <code>max</code> returns will refer to that operand.</p>\n</blockquote>\n<p>The problem here is that <em>function invocation substitution</em> is <strong>done</strong> at that point. If the invocation susbstitution would include the lvalue to rvalue conversion on that glvalue that <code>max</code> yields, everything would be fine, because reading from a glvalue that refers to a temporary not of static storage duration is fine <em>during computation of the constant expression</em>. But since the read happens outside of function invocation substitution, the result of function invocation substitution is an <em>lvalue</em>. The respective text of the spec says</p>\n<blockquote>\n<p id=\"so_5605142_5612606_1\">A reference constant expression is an lvalue core constant expression that designates an object with static storage duration or a function. </p>\n</blockquote>\n<p>But the reference that <code>max</code> returns yields an lvalue that designates an object of unspecified storage duration. Function invocation substitution is required to yield a <em>constant expression</em>, not merely a <em>core</em> constant expression. So <code>max(sizeof(A), sizeof(B))</code> is not guaranteed to work.</p>\n<p><strong>The following (older) text needs to be read taking the above into account</strong>.</p>\n<hr>\n<p>I can't see any reason at the moment why you wouldn't want to stick a <code>constexpr</code> there. Anyway, the following code definitely is useful</p>\n<pre><code>template&lt;typename T&gt; constexpr\nT const&amp; max(T const&amp; a, T const&amp; b) {\n  return a &gt; b ? a : b;\n}\n</code></pre>\n<p>Contrary to what other answers write, I think this is legal. Not all instantiations of <code>max</code> are required to be constexpr functions. The current n3242 says</p>\n<blockquote>\n<p id=\"so_5605142_5612606_2\">If the instantiated template specialization of a constexpr function template or member function of a class template would fail to satisfy the requirements for a constexpr function or constexpr constructor, that specialization is not a constexpr function or constexpr constructor.</p>\n</blockquote>\n<p>If you call the template, argument deduction will yield a function template specialization. Calling it will trigger <em>function invocation substitution</em>. Consider the following call</p>\n<pre><code>int a[max(sizeof(A), sizeof(B))];\n</code></pre>\n<p>It will first do an implicit conversion of the two <code>size_t</code> prvalues to the two reference parameters, binding both references to temporary objects storing their value. The result of this conversion is a <em>glvalue</em> for each case that refers to a temporary object (see 4p3). Now function invocation substitution takes those two glvalues and substitutes all occurences of <code>a</code> and <code>b</code> in the function body by those glvalues</p>\n<pre><code>return (&lt;glval.a&gt;) &gt; (&lt;glval.b&gt;) ? (&lt;glval.a&gt;) : (&lt;glval.b&gt;);\n</code></pre>\n<p>The condition will require lvalue to rvalue conversions on these glvalues, which are allowed by 5.19p2</p>\n<blockquote id=\"so_5605142_5612606_3\">\n<ul>\n<li>a glvalue of literal type that refers to a non-volatile temporary object initialized with a constant expression</li>\n</ul>\n</blockquote>\n<p>The conditional expression will yield a glvalue to either the first or second operand. The unnamed reference <code>max</code> returns will refer to that operand. And the final lvalue to rvalue conversion happening in the array dimension size specification will be valid by the same rule quoted above. </p>\n<hr>\n<p>Note that <code>initializer_list</code> currently doesn't have <code>constexpr</code> member functions. This is a known limitation and will be handled post-C++0x, most likely making those members <code>constexpr</code>.</p>\n</hr></hr>", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2011-12-27T16:06:12.923", "Id": "5612606", "Score": "12", "CreationDate": "2011-04-10T15:01:49.857", "LastActivityDate": "2011-12-27T16:06:12.923"}, "5605168": {"ParentId": "5605142", "CommentCount": "1", "Body": "<p>My guess is that, in the general case, operator&lt;(T, T) is not guaranteed to be constexpr either.</p>\n", "OwnerUserId": "490341", "PostTypeId": "2", "Id": "5605168", "Score": "-3", "CreationDate": "2011-04-09T13:01:55.423", "LastActivityDate": "2011-04-09T13:01:55.423"}, "5605142": {"CommentCount": "0", "AcceptedAnswerId": "5612606", "PostTypeId": "1", "LastEditorUserId": "3614835", "CreationDate": "2011-04-09T12:54:00.463", "LastActivityDate": "2016-07-14T08:11:22.067", "LastEditDate": "2016-07-14T04:23:22.643", "ViewCount": "7165", "FavoriteCount": "1", "Title": "std::max() and std::min() not constexpr", "Id": "5605142", "Score": "29", "Body": "<p>I just noticed that the new standard defines <code>min(a,b)</code> and <code>max(a,b)</code> <strong>without</strong> <code>constexpr</code>.</p>\n<p>Examples from 25.4.7, [alg.min.max]:</p>\n<pre><code>template&lt;class T&gt; const T&amp; min(const T&amp; a, const T&amp; b);\ntemplate&lt;class T&gt; T min(initializer_list&lt;T&gt; t);\n</code></pre>\n<p>Isn't this a pity? I would have liked to write</p>\n<pre><code>char data[ max(sizeof(A),sizeof(B)) ];\n</code></pre>\n<p>instead of</p>\n<pre><code>char data[ sizeof(A) &gt; sizeof(B) ? sizeof(A) : sizeof(B) ];\nchar data[ MAX(sizeof(A),sizeof(B)) ]; // using a macro\n</code></pre>\n<p>Any reason why those <strong>can not be <code>constexpr</code></strong>?</p>\n", "Tags": "<c++><max><c++11><min><constexpr>", "OwnerUserId": "472245", "AnswerCount": "5"}, "38368835": {"ParentId": "5605142", "CommentCount": "0", "Body": "<p>The inclusion of <code>constexpr</code> versions of <code>std::min()</code> and <code>std::max()</code> in C++14 demonstrates that there's no fundamental obstacle to making (versions of) these functions <code>constexpr</code>.  It seems that this wasn't considered early enough when <code>constexpr</code> was added to C++11.</p>\n<p>Obviously, for the versions where a comparison function is provided, that function must itself be <code>constexpr</code> for the template expansion to succeed.</p>\n", "OwnerUserId": "4850040", "PostTypeId": "2", "Id": "38368835", "Score": "1", "CreationDate": "2016-07-14T08:11:22.067", "LastActivityDate": "2016-07-14T08:11:22.067"}, "5605639": {"ParentId": "5605142", "CommentCount": "7", "Body": "<p><code>min</code> and <code>max</code> are only constant expressions if you call them with constant expressions as arguments. Since they're meant to be much more generally usable than that, you can't make the declaration.</p>\n<p>Here's what <a href=\"http://en.wikipedia.org/wiki/C%2B%2B0x#Generalized_constant_expressions\" rel=\"nofollow\">Wikipedia says about <code>constexpr</code></a> (emphasis added). I know Wikipedia is not the ultimate reference, but I believe it's correct in this case.</p>\n<blockquote>\n<p id=\"so_5605142_5605639_0\">The use of <code>constexpr</code> on a function\n  imposes very strict limitations on\n  what that function can do. First, the\n  function must have a non-void return\n  type. Second, the function contents\n  must be of the form: return expr.\n  <strong>Third, expr must be a constant\n  expression, after argument\n  substitution. This constant expression\n  may only call other functions defined\n  as constexpr, or it may use other\n  constant expression data variables.</strong></p>\n</blockquote>\n", "OwnerUserId": "5987", "PostTypeId": "2", "Id": "5605639", "Score": "-1", "CreationDate": "2011-04-09T14:33:11.647", "LastActivityDate": "2011-04-09T14:33:11.647"}, "bq_ids": {"n4140": {"so_5605142_5612606_3": {"section_id": 6185, "quality": 0.9, "length": 9}, "so_5605142_5612606_2": {"section_id": 5422, "quality": 1.0, "length": 23}, "so_5605142_5612606_1": {"section_id": 87, "quality": 0.7692307692307693, "length": 10}}, "n3337": {"so_5605142_5612606_3": {"section_id": 5946, "quality": 1.0, "length": 10}, "so_5605142_5612606_2": {"section_id": 5217, "quality": 1.0, "length": 23}, "so_5605142_5612606_1": {"section_id": 5947, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_5605142_5612606_3": {"section_id": 7687, "quality": 0.9, "length": 9}, "so_5605142_5612606_2": {"section_id": 6844, "quality": 1.0, "length": 23}, "so_5605142_5612606_1": {"section_id": 217, "quality": 0.6923076923076923, "length": 9}}}, "35814441": {"ParentId": "5605142", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>std::min and std::max <a href=\"http://en.cppreference.com/w/cpp/algorithm/min\" rel=\"noreferrer\">are constexpr</a> in C++14, which obviously means there isn't a good reason (these days) not to have them constexpr. Problem solved :-)</p>\n", "OwnerUserId": "1593077", "LastEditorUserId": "1593077", "LastEditDate": "2016-03-07T17:48:02.363", "Id": "35814441", "Score": "11", "CreationDate": "2016-03-05T12:59:48.310", "LastActivityDate": "2016-03-07T17:48:02.363"}});