post_cb({"bq_ids": {"n4140": {"so_32246949_32247189_1": {"length": 26, "quality": 0.8666666666666667, "section_id": 1395}, "so_32246949_32247189_0": {"length": 44, "quality": 0.9565217391304348, "section_id": 1394}, "so_32246949_32247189_2": {"length": 30, "quality": 0.9090909090909091, "section_id": 1396}}, "n3337": {"so_32246949_32247189_1": {"length": 26, "quality": 0.8666666666666667, "section_id": 1389}, "so_32246949_32247189_0": {"length": 43, "quality": 0.9347826086956522, "section_id": 1388}, "so_32246949_32247189_2": {"length": 30, "quality": 0.9090909090909091, "section_id": 1390}}, "n4659": {"so_32246949_32247189_1": {"length": 24, "quality": 0.8, "section_id": 1513}, "so_32246949_32247189_0": {"length": 44, "quality": 0.9565217391304348, "section_id": 1512}, "so_32246949_32247189_2": {"length": 30, "quality": 0.9090909090909091, "section_id": 1514}}}, "32246949": {"ViewCount": "110", "Body": "<p>This is how my code looks like</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\nusing namespace std;\n\nenum Enum_type \n{\n    Enum_type_1 = 1,\n    Enum_type_2,\n    Enum_type_3,\n    Enum_type_4\n};\n\nclass my_class\n{\npublic:\n\n    my_class(Enum_type type) :\n        source_type(type)\n    {}\n\n    bool operator&lt;(const my_class &amp;another) const;\n\n    Enum_type source_type;\n};\n\nbool my_class::operator&lt;(const my_class&amp; another) const\n{\n    return true;\n}\n\nint main()\n{\n    std::set&lt;my_class&gt; bracers_initialized_set {\n        my_class{Enum_type_1},\n        my_class{Enum_type_2},\n        my_class{Enum_type_3},\n        my_class{Enum_type_4}};\n\n    cout&lt;&lt; \"bracers_initialized_set.size() \" &lt;&lt;  bracers_initialized_set.size() &lt;&lt;endl;\n    for (auto my_class_ : bracers_initialized_set) {\n        cout &lt;&lt; \"enum value: \" &lt;&lt; my_class_.source_type &lt;&lt; endl;\n    }\n    cout&lt;&lt; \"bracers_initialized_set.size() \" &lt;&lt;  bracers_initialized_set.size() &lt;&lt;endl;\n\n    std::set&lt;my_class&gt; inserted_set;\n    if (inserted_set.insert(my_class(Enum_type_1)).second) {\n        cout &lt;&lt; \"inserted_1\" &lt;&lt; endl;\n    }\n    if (inserted_set.insert(my_class(Enum_type_2)).second) {\n        cout &lt;&lt; \"inserted_2\" &lt;&lt; endl;\n    }   \n    if (inserted_set.insert(my_class(Enum_type_3)).second) {\n        cout &lt;&lt; \"inserted_3\" &lt;&lt; endl;\n    }\n    if (inserted_set.insert(my_class(Enum_type_4)).second) {\n        cout &lt;&lt; \"inserted_4\" &lt;&lt; endl;\n    }\n\n    cout&lt;&lt; \"inserted_set.size() \" &lt;&lt;  inserted_set.size() &lt;&lt;endl;\n    for (auto my_class_ : inserted_set) {\n        cout &lt;&lt; \"enum value: \" &lt;&lt; my_class_.source_type &lt;&lt; endl;\n    }\n    cout&lt;&lt; \"inserted_set.size() \" &lt;&lt;  inserted_set.size() &lt;&lt;endl;\n}\n</code></pre>\n<p>And this is the output:</p>\n<pre><code>bracers_initialized_set.size() 4\nenum value: 2\nenum value: 1\nbracers_initialized_set.size() 4\ninserted_1\ninserted_2\ninserted_3\ninserted_4\ninserted_set.size() 4\nenum value: 4\nenum value: 3\nenum value: 2\nenum value: 1\ninserted_set.size() 4\n</code></pre>\n<p>As you can see the set initialized with initializer_list behaves bad (size is different than number of iterations). If I implement operator&lt; this way: </p>\n<pre><code>bool my_class::operator&lt;(const my_class&amp; another) const\n{\n    return source_type&lt;another.source_type;\n}\n</code></pre>\n<p>then the output is correct for both examples.</p>\n<p>However shouldnt the initializer_list initialization and insertion output be the same, regardless of how the operator&lt; looks like? Also shouldnt size always reflect the number of elements?</p>\n<p>$ gcc -v</p>\n<pre><code>COLLECT_GCC=gcc\nCOLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/4.8/lto-wrapper\nTarget: x86_64-linux-gnu\nConfigured with: ../src/configure -v --with-pkgversion='Ubuntu 4.8.4-2ubuntu1~14.04' --with-bugurl=file:///usr/share/doc/gcc-4.8/README.Bugs --enable-languages=c,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.8 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.8 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --disable-libmudflap --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-4.8-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu\nThread model: posix\ngcc version 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04) \n</code></pre>\n<p>~Marcin</p>\n", "AcceptedAnswerId": "32247189", "Title": "Initializer_list initialization of std::set<my_class> with trivial operator<. Bug in gcc+ / standard library?", "CreationDate": "2015-08-27T10:29:00.833", "Id": "32246949", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-08-27T10:40:13.387", "Score": "1", "OwnerUserId": "2500149", "Tags": "<c++11><gcc><operators><initializer-list><stdset>", "AnswerCount": "1"}, "32247189": {"Id": "32247189", "PostTypeId": "2", "Body": "<p>In the standard it's specified that, at \u00a725.4/2:</p>\n<blockquote>\n<p id=\"so_32246949_32247189_0\">Compare is a function object type (20.9). The return value of the function call operation applied to an object of type Compare, when contextually converted to bool (Clause 4), <strong>yields true if the first argument of the call is less than the second, and false otherwise</strong>. Compare comp is used throughout for algorithms assuming an ordering relation. It is assumed that comp will not apply any non-constant function through the dereferenced iterator.</p>\n</blockquote>\n<p>(emphasis mine) and moreover at \u00a725.4/3:</p>\n<blockquote>\n<p id=\"so_32246949_32247189_1\">For all algorithms that take Compare, there is a version that uses operator&lt; instead. That is, comp(*i, *j) != false defaults to *i &lt; *j != false. <strong>For algorithms other than those described in 25.4.3 to work correctly, comp has to induce a strict weak ordering on the values</strong>.</p>\n</blockquote>\n<p>(emphasis mine) which means, as described in \u00a725.4/4:</p>\n<blockquote>\n<p id=\"so_32246949_32247189_2\">The term strict refers to the requirement of an irreflexive relation (!comp(x, x) for all x), and the term weak to requirements that are not as strong as those for a total ordering, but stronger than those for a partial ordering. If we define equiv(a, b) as !comp(a, b) &amp;&amp; !comp(b, a), then the requirements are that comp and equiv both be transitive relations:</p>\n<ul>\n<li>comp(a, b) &amp;&amp; comp(b, c) implies comp(a, c)</li>\n<li>equiv(a, b) &amp;&amp; equiv(b, c) implies equiv(a, c) [ Note: Under these conditions, it can be shown\n  that\n  \n  <ul>\n<li>equiv is an equivalence relation</li>\n<li>comp induces a well-defined relation on the equivalence classes determined by equiv </li>\n<li>The induced relation is a strict total ordering. \u2014 end note ]</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>You are breaking those requirements, so the standard library is breaking its guarantees.</p>\n", "LastActivityDate": "2015-08-27T10:40:13.387", "CommentCount": "2", "CreationDate": "2015-08-27T10:40:13.387", "ParentId": "32246949", "Score": "3", "OwnerUserId": "493122"}});