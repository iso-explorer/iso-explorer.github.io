post_cb({"23302179": {"Id": "23302179", "PostTypeId": "2", "Body": "<p>The reason why many <code>std::copy_n</code> implementations increment n-1 times is due to the interactions with <code>istream_iterator</code>, and how that is typically implemented.</p>\n<p>For example, if you had an input file with integers in them</p>\n<pre><code>std::vector&lt;int&gt; buffer(2);\nstd::istream_iterator&lt;int&gt; itr(stream); // Assume that stream is an ifstream of the file\nstd::copy_n(itr, 2, buffer.begin());\n</code></pre>\n<p>Because <code>istream_iterator</code> is specified to read on increment (and on either construction or first dereference), if <code>std::copy_n</code> incremented the input iterator 2 times, you would actually read 3 values out of the file.  The third value would simply be discarded when the local iterator inside <code>copy_n</code> went out of scope.</p>\n<p><code>istreambuf_iterator</code> doesn't have the same interactions, since it doesn't actually copy the value from the stream into a local copy, like most <code>istream_iterators</code> do, but <code>copy_n</code> still behaves this way.</p>\n<p>Edit:  Example of losing data if copy-N incremented N times (the cplusplus.com description, which doesn't seem to be correct).  Note, this really only applies to <code>istream_iterators</code> or other iterators that reads and remove their underlying data on increment.</p>\n<pre><code>std::istream_iterator&lt;int&gt; itr(stream); // Reads 1st value\n\nwhile(n &gt; 0) // N = 2 loop start \n{       \n *result = *first;\n ++result; ++first; // Reads 2nd value\n --n; // N: 1\n // N = 1 loop start\n *result = *first;\n ++result; ++first; // Reads 3rd value\n --n; // N :0\n // Loop exit\n}\nreturn result;\n</code></pre>\n", "LastEditorUserId": "862231", "LastActivityDate": "2014-04-25T20:28:23.920", "Score": "7", "CreationDate": "2014-04-25T20:13:12.523", "ParentId": "23301162", "CommentCount": "11", "OwnerUserId": "862231", "LastEditDate": "2014-04-25T20:28:23.920"}, "bq_ids": {"n4140": {"so_23301162_23301404_5": {"length": 14, "quality": 0.8235294117647058, "section_id": 5569}, "so_23301162_23301404_0": {"length": 12, "quality": 1.0, "section_id": 1245}, "so_23301162_23301404_2": {"length": 6, "quality": 0.75, "section_id": 1286}}, "n3337": {"so_23301162_23301404_5": {"length": 14, "quality": 0.8235294117647058, "section_id": 5351}, "so_23301162_23301404_0": {"length": 12, "quality": 1.0, "section_id": 1243}, "so_23301162_23301404_2": {"length": 6, "quality": 0.75, "section_id": 1281}}, "n4659": {"so_23301162_23301404_5": {"length": 11, "quality": 0.6470588235294118, "section_id": 7016}, "so_23301162_23301404_0": {"length": 12, "quality": 1.0, "section_id": 1333}, "so_23301162_23301404_2": {"length": 6, "quality": 0.75, "section_id": 1409}}}, "23301162": {"ViewCount": "961", "Body": "<p>I would expect the following to leave the <code>buf_iter</code> pointing to the character <code>n</code> characters after the point at which it started. Instead it is left pointing at the last character read. Why is this? i.e. if I do in_stream.tellg() before and after the copy_n, they differ not by <code>n</code> but by <code>(n-1)</code>. Had I read <code>n</code> characters with <code>in_stream.read</code>, then the position would be advanced by <code>n</code>. </p>\n<pre><code>std::istreambuf_iterator&lt;char&gt; buf_iter(in_stream);\nstd::copy_n(buf_iter, n, sym.begin());\n</code></pre>\n<p>I've looked at the implementation and it clearly does this on purpose, skipping the final increment. </p>\n<p>Another post <a href=\"https://stackoverflow.com/questions/5074122/stdistream-iterator-with-copy-n-and-friends\">here</a> mentions that incrementing the from iterator when it is hooked up to, say, <code>cin</code>, will cause one too many reads since a read is done on <code>operator++()</code>. That sounds like an issue with <code>cin</code> - why isn't the read done on <code>operator*()</code>? </p>\n<p>Does the standard specify this anywhere? The docs I've seen don't mention what happens to the from iterator, and I've seen two different pages that give \"possible correct implementations\" that do each of the behaviours:</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/algorithm/copy_n\" rel=\"nofollow noreferrer\">At cppreference we have:</a></p>\n<pre><code>template&lt; class InputIt, class Size, class OutputIt&gt;\nOutputIt copy_n(InputIt first, Size count, OutputIt result)\n{\n    if (count &gt; 0) {\n        *result++ = *first;\n        for (Size i = 1; i &lt; count; ++i) {\n            *result++ = *++first;\n        }\n    }\n    return result;\n}\n</code></pre>\n<p><a href=\"http://www.cplusplus.com/reference/algorithm/copy_n/\" rel=\"nofollow noreferrer\">while at cplusplus.com we have</a>:</p>\n<pre><code>template&lt;class InputIterator, class Size, class OutputIterator&gt;\n  OutputIterator copy_n (InputIterator first, Size n, OutputIterator result)\n{\n  while (n&gt;0) {\n    *result = *first;\n    ++result; ++first;\n    --n;\n  }\n  return result;\n}\n</code></pre>\n<p>Both do n reads and result in the same contents in result. However, the first will only increment the \"first\" iterator <code>n-1</code> times, and the second will increment it <code>n</code> times.</p>\n<p>What gives? How do I write portable code? I can use <code>tellg</code> and then <code>seekg</code> but then I might as well just do the loop by hand (ugh!).</p>\n<hr>\n<p>Note that I'm not trying to read from the iterator after calling <code>copy_n</code>, rather I want to read from the underlying stream after calling <code>copy_n</code>, and the problem is that <code>copy_n</code> is left pointing on byte short of where I had expected it to be. For now I'm going with the somewhat hideous but apparently portable:</p>\n<pre><code>auto pos = in_stream.tellg();\nstd::istreambuf_iterator&lt;char&gt; buf_iter(in_stream);\nstd::copy_n(buf_iter, cl, sym.begin());\n\nin_stream.seekg(pos + cl);\n\nuint64_t foo;\nin_stream.read(reinterpret_cast&lt;char *&gt;(&amp;foo), 8);\n</code></pre>\n<p>BTW, in case its not clear, I'm trying to avoid copying the data into a buffer and then again into the string <code>sym</code>.</p>\n<hr>\n<p>@DaveS: Moving out of my specific problem, here is a simple program that does not output what I would expect due to the fact that the input iterator isn't incremented the final time:</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nint main(int argc, const char * argv[])\n{\n    std::ifstream in(\"numbers.txt\");\n\n    std::istreambuf_iterator&lt;char&gt; in_iter(in);\n    std::ostreambuf_iterator&lt;char&gt; out_iter(std::cout);\n\n    std::copy_n(in_iter, 3, out_iter);\n    std::cout &lt;&lt; std::endl;\n\n    std::copy_n(in_iter, 3, out_iter);\n    std::cout &lt;&lt; std::endl;\n\n    std::copy_n(in_iter, 3, out_iter);\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>The input file is just <code>\"0123456789\\n\"</code></p>\n<p>I'm getting:</p>\n<pre><code>012\n234\n456\n</code></pre>\n<p>Because of the side-effect of <code>istreambuf_iterator::operator++()</code>, this would give a different result if <code>copy_n</code> was implemented to increment the input iterator <code>n</code> times.</p>\n<hr>\n<p>@aschepler: Need to capture the local parameter, but I'm going with it:</p>\n<pre><code> std::generate_n(sym.begin(), cl, [&amp;in_stream](){ return in_stream.get(); });\n</code></pre>\n</hr></hr></hr>", "Title": "Why does std::copy_n not increment the Input iterator n times?", "CreationDate": "2014-04-25T19:10:04.103", "LastActivityDate": "2014-04-25T21:36:28.533", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:32:38.650", "LastEditorUserId": "-1", "Id": "23301162", "Score": "17", "OwnerUserId": "2587908", "Tags": "<c++><algorithm><c++11><stl>", "AnswerCount": "3"}, "23301404": {"Body": "<p>n3797 [algorithms.general]/12</p>\n<blockquote>\n<p id=\"so_23301162_23301404_0\">In the description of the algorithms operators <code>+</code> and <code>-</code> are used for some of the iterator categories for which they do not have to be defined. In these cases the semantics of <code>a+n</code> is the same as that of</p>\n<pre><code>X tmp = a;\nadvance(tmp, n);\nreturn tmp;\n</code></pre>\n<p id=\"so_23301162_23301404_1\">and that of <code>b-a</code> is the same as of</p>\n<pre><code>return distance(a, b);\n</code></pre>\n</blockquote>\n<p>[alg.modifying.operations]</p>\n<blockquote>\n<pre><code>template&lt;class InputIterator, class Size, class OutputIterator&gt;\nOutputIterator copy_n(InputIterator first, Size n,\n                      OutputIterator result);\n</code></pre>\n<p id=\"so_23301162_23301404_2\"><sup>5</sup> <em>Effects:</em> For each non-negative integer <em>i &lt; n</em>, performs <code>*(result + i) = *(first + i)</code>.</p>\n<p id=\"so_23301162_23301404_3\"><sup>6</sup> <em>Returns:</em> <code>result + n</code>.</p>\n<p id=\"so_23301162_23301404_4\"><sup>7</sup> <em>Complexity:</em> Exactly <code>n</code> assignments.</p>\n</blockquote>\n<hr>\n<p>I'm not sure this is well-formed for InputIterators (no multipass), since it does not modify the original iterator, but always advances a copy of the original iterator. It doesn't seem to be efficient either.</p>\n<p>[input.iterators]/Table 107 - Input iterator requirements (in addition to Iterator)</p>\n<blockquote>\n<p id=\"so_23301162_23301404_5\">Expression: <code>++r</code><br/>\n  Return type: <code>X&amp;</code><br/>\n  pre: <code>r</code> is dereferencable.<br/>\n  post: <code>r</code> is dereferenceable or <code>r</code> is past-the-end.<br/>\n  post: any copies of the previous value of <code>r</code> are no longer required either to be\n  dereferenceable or to be in the domain of <code>==</code>.</p>\n</blockquote>\n<p>As far as I can see, the <code>a</code> in</p>\n<blockquote id=\"so_23301162_23301404_6\">\n<pre><code>X tmp = a;\nadvance(tmp, n);\nreturn tmp;\n</code></pre>\n</blockquote>\n<p>is therefore no longer required to be incrementable.</p>\n<hr>\n<p>Related defect report: <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2173\">LWG 2173</a></p>\n</hr></hr>", "CreationDate": "2014-04-25T19:26:50.637", "ParentId": "23301162", "CommentCount": "4", "LastEditDate": "2014-04-25T19:41:24.580", "Id": "23301404", "PostTypeId": "2", "LastActivityDate": "2014-04-25T19:41:24.580", "LastEditorUserId": "420683", "CommunityOwnedDate": "2014-04-25T19:26:50.637", "Score": "7", "OwnerUserId": "420683"}, "23301198": {"Id": "23301198", "PostTypeId": "2", "Body": "<p>The source iterator is not taken by reference. So, a copy of it is incremented n times, but the parameter is left untouched.</p>\n<p>9 out of 10 times, this is what you want.</p>\n<p>As far as the side-effects of incrementing specifically on InputIterators is concerned I think officially, input iterators shall be \"incremented\" upon each read (repeated read without increment does <strong>not</strong> yield the same value). So, just make the increment a no-op.</p>\n", "LastEditorUserId": "85371", "LastActivityDate": "2014-04-25T19:19:05.097", "Score": "3", "CreationDate": "2014-04-25T19:13:04.080", "ParentId": "23301162", "CommentCount": "5", "OwnerUserId": "85371", "LastEditDate": "2014-04-25T19:19:05.097"}});