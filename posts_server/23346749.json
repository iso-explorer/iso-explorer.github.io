post_cb({"23347213": {"Id": "23347213", "PostTypeId": "2", "Body": "<p>Rule of pointer conversion is governed as laid down in the standard</p>\n<p>N3337 : 4.10 Pointer conversions  [conv.ptr]</p>\n<p>In case of conversion from a pointer to derived to a pointer to base as you have depicted in your examaple</p>\n<pre><code>Derived* myDerived = new Derived();\n*myBase = myDerived;\n</code></pre>\n<p>is valid because the standard says</p>\n<blockquote>\n<p id=\"so_23346749_23347213_0\">A prvalue of type \u201cpointer to cv D\u201d, where D is a class type, can be\n  converted to a prvalue of type \u201cpointer to cv B\u201d, where B is a base\n  class (Clause 10) of D. If B is an inaccessible (Clause 11) or\n  ambiguous (10.2) base class of D, a program that necessitates this\n  conversion is ill-formed. The result of the conversion is a pointer to\n  the base class subobject of the derived class object. The null pointer\n  value is converted to the null pointer value of the destination type.</p>\n</blockquote>\n<p>But in case of conversion from </p>\n<pre><code>'Derived **' to 'Base **'\n</code></pre>\n<p>It is not a supported prvalue conversion. </p>\n<p>To summarize the section, a prvalue of Type T1 can be converted to a prvalue of Type T2, iff</p>\n<ol>\n<li>T1 is a null pointer constant that evaluates to zero or a prvalue of type std::nullptr_t i.e. assigning NULL or nullptr to a pointer type.</li>\n<li>T1 is of type \u201cpointer to cv T,\u201d where T is an object type, and T2 is of type \u201cpointer\nto cv void\u201d i.e. <code>T *pT = new T(); void *p = pT</code></li>\n<li>T1 is of type \u201cpointer to cv D\u201d, where D is a class type, and T2 is of type \u201cpointer\nto cv B\u201d, where B is a base class of D i.e. <code>Base* pBase = new Derived()</code></li>\n</ol>\n", "LastActivityDate": "2014-04-28T17:15:06.310", "CommentCount": "1", "CreationDate": "2014-04-28T17:15:06.310", "ParentId": "23346749", "Score": "1", "OwnerUserId": "977038"}, "23346862": {"Id": "23346862", "PostTypeId": "2", "Body": "<p>The answer lies in what a cast to base pointer actually does in C++. Consider the following simple example:</p>\n<pre><code>struct A { std::uint32_t a; };\nstruct B { std::uint32_t b; };\nstruct D : A, B { std::uint32_t d; };\n</code></pre>\n<p>Here <code>D</code> has two bases, <code>A</code> and <code>B</code>. But only one of them can live at the beginning of <code>D</code> (lets say it is <code>A</code>), so when you convert the <code>D</code> to the other one (<code>B</code>), the value of the pointer needs to change, to point at some point <em>in the middle of <code>D</code></em>.</p>\n<p>To visualize this, consider how an object of type <code>D</code> looks like in your memory:</p>\n<pre><code>0 1 2 3 4 5 6 7 8 9 A B\n[ A::a ][ B::b ][ D::d ]\n^ a D* would point here\n^ a A* would point here\n        ^ a B* must point here\n</code></pre>\n<p>Whilst <code>D</code> expects all three of these integers, when thinking of this object as an <code>A</code>, we only expect the first one, but the pointer is (numerically) the same, we only expect a shorter object. However, when thinking of it as an <code>B</code>, we need to point at the one integer in the middle.</p>\n<p>When you do that to one pointer, the compiler will take care of this for you by changing the value of the pointer appropriately. However, when you do that to an array of pointers, the compiler would need to emit a loop over all elements of that and correct every single pointer - when in fact it cannot even know where the array ends (since the compiler only sees a pointer to its beginning)!</p>\n<p>Therefore C++ disallows this kind of conversion.</p>\n", "LastEditorUserId": "65678", "LastActivityDate": "2014-04-28T17:05:51.940", "Score": "5", "CreationDate": "2014-04-28T16:55:17.283", "ParentId": "23346749", "CommentCount": "5", "OwnerUserId": "65678", "LastEditDate": "2014-04-28T17:05:51.940"}, "23346874": {"Id": "23346874", "PostTypeId": "2", "Body": "<p>You cannot do that because it would create uncheckable restrictions. When you dereference <code>myBase</code>, you'd get a <code>Derived**</code>, which semantically shouldn't allow you to assign it a <code>Base</code> again. This causes real issues when you use multiple inheritance.</p>\n<p>If this many indirections are necessary, your solution would be to use a <code>Base**</code> instead. Remember that you can still assign a Derived to <code>**myBase</code> once you get there.</p>\n", "LastActivityDate": "2014-04-28T16:55:36.770", "CommentCount": "0", "CreationDate": "2014-04-28T16:55:36.770", "ParentId": "23346749", "Score": "0", "OwnerUserId": "251153"}, "bq_ids": {"n4140": {"so_23346749_23347213_0": {"length": 41, "quality": 0.9318181818181818, "section_id": 41}}, "n3337": {"so_23346749_23347213_0": {"length": 41, "quality": 0.9318181818181818, "section_id": 38}}, "n4659": {"so_23346749_23347213_0": {"length": 41, "quality": 0.9318181818181818, "section_id": 41}}}, "23346749": {"ViewCount": "208", "Body": "<p>Let's assume I have a <code>Base</code> class and a <code>Derived</code> class:</p>\n<pre><code>class Base {};\n\nclass Derived : public Base {};\n</code></pre>\n<p>I <code>fun</code> I can now obviously assign a pointer to <code>Derived</code> to the contents of <code>myBase</code> as follows:</p>\n<pre><code>void fun( Base** myBase ) {\n\n    Derived* myDerived = new Derived();\n    *myBase = myDerived;\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    Base *myBase = NULL;\n    fun( &amp;myBase );\n\n    return 0;\n}\n</code></pre>\n<p>Now, the problem is that I want to assign to an array of <code>Base*</code> (I cannot use a typedef to mask the three-star since the signature of <code>fun</code> is auto-generated):</p>\n<pre><code>void fun( Base*** myBase ) {\n\n    Derived** myDerived = new Derived*();\n    *myBase = myDerived;\n}\n</code></pre>\n<p>Why do I get <code>C2440: '=' : cannot convert from 'Derived **' to 'Base **'</code> while the conversion from <code>Derived*</code> to <code>Base*</code> is perfectly fine?</p>\n", "AcceptedAnswerId": "23346862", "Title": "C2440 when assigning `Derived**` to `Base**`", "CreationDate": "2014-04-28T16:49:15.967", "Id": "23346749", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-04-28T17:15:06.310", "Score": "3", "OwnerUserId": "586380", "Tags": "<c++><casting>", "AnswerCount": "3"}});