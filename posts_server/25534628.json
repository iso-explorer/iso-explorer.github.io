post_cb({"bq_ids": {"n4140": {"so_25534628_25534823_6": {"length": 36, "quality": 0.9473684210526315, "section_id": 480}, "so_25534628_25534823_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 3338}, "so_25534628_25534823_4": {"length": 17, "quality": 0.68, "section_id": 3294}, "so_25534628_25534823_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 3336}, "so_25534628_25534823_5": {"length": 20, "quality": 0.6896551724137931, "section_id": 481}}, "n3337": {"so_25534628_25534823_6": {"length": 36, "quality": 0.9473684210526315, "section_id": 471}, "so_25534628_25534823_1": {"length": 12, "quality": 0.8, "section_id": 3208}, "so_25534628_25534823_4": {"length": 17, "quality": 0.68, "section_id": 3164}, "so_25534628_25534823_0": {"length": 11, "quality": 0.6470588235294118, "section_id": 3206}, "so_25534628_25534823_5": {"length": 29, "quality": 1.0, "section_id": 472}}, "n4659": {"so_25534628_25534823_6": {"length": 37, "quality": 0.9736842105263158, "section_id": 502}, "so_25534628_25534823_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 4105}, "so_25534628_25534823_4": {"length": 17, "quality": 0.68, "section_id": 4056}, "so_25534628_25534823_0": {"length": 12, "quality": 0.7058823529411765, "section_id": 4103}, "so_25534628_25534823_5": {"length": 16, "quality": 0.5517241379310345, "section_id": 504}}}, "25534823": {"Id": "25534823", "PostTypeId": "2", "Body": "<p>\u00a7 15.1 [except.throw]:</p>\n<blockquote>\n<ol start=\"2\">\n<li><p id=\"so_25534628_25534823_0\">Throwing an exception <strong>copy-initializes</strong> (8.5, 12.8) a temporary object,\n  called the exception object. The\n  temporary is an lvalue and is used to initialize the variable named in the matching handler.</p></li>\n<li><p id=\"so_25534628_25534823_1\">When the thrown object is a class object, the constructor selected for the copy-initialization and the destructor shall be accessible, even if the copy/move operation is elided (12.8).</p></li>\n</ol>\n</blockquote>\n<p>\u00a7 8.5 [dcl.init]:</p>\n<blockquote>\n<ol start=\"15\">\n<li><p id=\"so_25534628_25534823_2\">The initialization that occurs in the form</p>\n<p id=\"so_25534628_25534823_3\"><code>T x = a;</code></p></li>\n</ol>\n<p id=\"so_25534628_25534823_4\">, as well as in argument passing, function return, <strong>throwing an exception</strong> (15.1), handling an exception\n  (15.3), and aggregate member initialization (8.5.1) is called <em>copy-initialization</em>. [ Note: Copy-initialization <strong>may invoke a move</strong> (12.8). \u2014end note ]</p>\n</blockquote>\n<p>\u00a7 12.8 [class.copy]:</p>\n<blockquote id=\"so_25534628_25534823_5\">\n<ol start=\"32\">\n<li>When the criteria for elision of a copy operation are met or would be met save for the fact that the source\n  object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to\n  select the constructor for the copy is first performed <strong>as if the object were designated by an rvalue</strong>.</li>\n</ol>\n</blockquote>\n<p>The aforementioned criteria for copy-elision include the following (\u00a712.8 [class.copy]/p31):</p>\n<blockquote id=\"so_25534628_25534823_6\">\n<ul>\n<li>in a <em>throw-expression</em>, when the operand is the name of a non-volatile automatic object (other than a\n  function or catch-clause parameter) whose scope does not extend beyond the end of the innermost\n  enclosing <em>try-block</em> (if there is one), the copy/move operation from the operand to the exception\n  object (15.1) can be omitted by constructing the automatic object directly into the exception object</li>\n</ul>\n</blockquote>\n<p>Copy-initialization of an exception may invoke a move-constructor to construct the actual exception object (even if <code>std::move(e)</code> is not explicitly invoked in a <code>throw</code> excpression), but not its matching handler (if tried to be caught by value).</p>\n", "LastEditorUserId": "3953764", "LastActivityDate": "2015-09-24T11:57:21.333", "Score": "9", "CreationDate": "2014-08-27T18:46:31.197", "ParentId": "25534628", "CommentCount": "10", "OwnerUserId": "3953764", "LastEditDate": "2015-09-24T11:57:21.333"}, "25534628": {"ViewCount": "676", "Body": "<p>If I have an object <code>e</code> of type <code>Error</code> which implements a move constructor, will throwing <code>std::move( e )</code> use the move constructor of <code>Error</code> to \"duplicate\" <code>e</code>, so does it avoid making an actual copy of the object? So if I have</p>\n<pre><code>Error e;\n\nthrow std::move( e );\n</code></pre>\n<p>will the copy constructor of <code>Error</code> be called or not? This is of interest when your move constructor is <code>noexcept</code> (as it should be), but your copy constructor isn't.</p>\n", "AcceptedAnswerId": "25534823", "Title": "Using the move constructor to throw exceptions? (C++)", "CreationDate": "2014-08-27T18:34:32.047", "Id": "25534628", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-09-24T11:57:21.333", "Score": "9", "OwnerUserId": "3910671", "Tags": "<c++><exception><move>", "AnswerCount": "1"}});