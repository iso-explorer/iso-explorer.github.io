post_cb({"8091339": {"ParentId": "8091302", "CommentCount": "1", "CreationDate": "2011-11-11T08:20:57.897", "OwnerUserId": "415784", "PostTypeId": "2", "Id": "8091339", "Score": "1", "Body": "<pre><code>T t = -1.0;\n</code></pre>\n<p>Of course, this wouldn't compile if <code>T</code> is <code>std::string</code>. It has nothing to do with <code>get</code> being <code>virtual</code> and which function will be called at runtime. Runtime comes after code gets compiled to machine code, and your code wouldn't even compile.</p>\n<p>Why don't you do this:</p>\n<pre><code>T t = T(); \n</code></pre>\n<p>Again it requires <code>T</code> to have a default constructor.</p>\n", "LastActivityDate": "2011-11-11T08:20:57.897"}, "8091356": {"ParentId": "8091302", "PostTypeId": "2", "CommentCount": "16", "CreationDate": "2011-11-11T08:22:47.063", "Score": "6", "LastEditorUserId": "734069", "LastEditDate": "2011-11-11T08:56:33.197", "Id": "8091356", "OwnerUserId": "734069", "Body": "<blockquote>\n<p id=\"so_8091302_8091356_0\">However, I'm getting a compiler error saying that I can't initialize a string to -1.0, which means that the compiler is trying to call base::get() when I call d.print().</p>\n</blockquote>\n<p>No, that compiler error means that the compiler is trying to instantiate <code>base&lt;std::string&gt;::get()</code>, which it <em>must</em> do because <code>derived</code> uses <code>base&lt;std::string&gt;</code> as a base class. Just because you don't call a function doesn't mean you <em>can't</em>. You could still call <code>base&lt;std::string&gt;::get()</code> directly.</p>\n<p>You instantiated <code>base&lt;std::string&gt;</code> and used it as a base class. Since <code>base&lt;std::string&gt;::get()</code> is a virtual function, it is considered \"used\" by the fact that you use <code>base&lt;std::string&gt;</code> as a base class. Since it is in use, it must be instantiated. So the compiler must and will attempt to compile the function.</p>\n<p>And since <code>std::string</code> cannot be implicitly constructed from a float, the compiler errors out from a failed template substitution.</p>\n", "LastActivityDate": "2011-11-11T08:56:33.197"}, "8091302": {"CommentCount": "7", "ViewCount": "481", "PostTypeId": "1", "LastEditorUserId": "160206", "CreationDate": "2011-11-11T08:16:53.503", "LastActivityDate": "2011-11-11T08:56:33.197", "Title": "Calling a virtual member function from inside the (template) base class", "AcceptedAnswerId": "8091356", "LastEditDate": "2011-11-11T08:37:45.050", "Id": "8091302", "Score": "4", "Body": "<p>Suppose I have the following:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\ntemplate&lt;class T&gt;\nclass base\n{\npublic:\n    void print()\n    {\n        T t = get();\n        std::cout &lt;&lt; t &lt;&lt; std::endl;\n    }\n\n    virtual T get() const\n    {\n        // assumes T can be constructed from, say, -1\n        T t = -1.0;\n        return t;\n    }\n};\n\nclass derived : public base&lt;std::string&gt;\n{\npublic:\n    virtual std::string get() const\n    {\n        // this is a silly example, but one can\n        // imagine that what we return here could\n        // depend on data members of derived\n        return \"this is a string\";\n    }\n};\n\nint main()\n{\n    derived d;\n    d.print();\n\n    return 0;\n}\n</code></pre>\n<p>It seems to me that <code>d.print()</code> should call <code>derived::get()</code> because <code>get()</code> is virtual. However, I'm getting a compiler error saying that I can't initialize a <code>string</code> to <code>-1.0</code>, which means that the compiler is trying to call <code>base::get()</code> when I call <code>d.print()</code>. What's going on?</p>\n", "Tags": "<c++><templates><gcc><polymorphism>", "OwnerUserId": "373774", "AnswerCount": "4"}, "8091463": {"ParentId": "8091302", "CommentCount": "4", "CreationDate": "2011-11-11T08:37:03.450", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "8091463", "Score": "4", "Body": "<p>When you implicitly instantiate a class template, only those member functions that are <em>used</em> will be instantiated, as you already know or else you would not be asking this. The problem is that the definition of <em>use</em> in the standard may not be exactly what you expect, and in particular, any <em>virtual</em> function is <em>used</em> if it is not <em>pure</em></p>\n<blockquote>\n<p id=\"so_8091302_8091463_0\">\u00a73.2p2 [...]A virtual member function is odr-used if it is not pure.[...]</p>\n</blockquote>\n<p>And this means that <code>base::get</code> is used even if your code does not explicitly call it, and thus the compiler will implicitly instantiate it and trigger the compiler error that you are seeing.</p>\n", "LastActivityDate": "2011-11-11T08:37:03.450"}, "8091364": {"ParentId": "8091302", "CommentCount": "0", "CreationDate": "2011-11-11T08:24:25.207", "OwnerUserId": "476681", "PostTypeId": "2", "Id": "8091364", "Score": "1", "Body": "<p>The problem is in this method (where T=std::string) :  </p>\n<pre><code>virtual T get() const\n{\n    // assumes T can be constructed from, say, -1\n    T t = -1.0;\n    return t;\n}\n</code></pre>\n<p>The compiler is right. You can not initialize std::string using a double value.</p>\n", "LastActivityDate": "2011-11-11T08:24:25.207"}, "bq_ids": {"n4140": {"so_8091302_8091463_0": {"section_id": 7040, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_8091302_8091463_0": {"section_id": 6785, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_8091302_8091463_0": {"section_id": 8537, "quality": 0.8333333333333334, "length": 5}}}});