post_cb({"36585964": {"CommentCount": "4", "ViewCount": "43", "CreationDate": "2016-04-12T23:38:02.993", "LastActivityDate": "2016-04-13T00:05:56.783", "Title": "Custom cast not applied to references of derived class", "AcceptedAnswerId": "36586174", "PostTypeId": "1", "Id": "36585964", "Score": "2", "Body": "<p>When casting references, it seems that the compiler tries to convert the <code>Derived</code> class to its <code>Base</code> and does not use the custom cast at all. This works flawlessly with pointers though.    </p>\n<p>Example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Base {\npublic:\n    int fn() {\n        return 42;\n    }\n};\n\nclass Derived : private Base {\npublic:\n    operator Base&amp;() {\n        return *dynamic_cast&lt;Base*&gt;(this);\n    }\n\n    operator Base*() {\n        return dynamic_cast&lt;Base*&gt;(this);\n    }\n};\n\nint main() {\n    Derived d;\n    Derived &amp;dRef = d;\n\n    std::cout&lt;&lt;static_cast&lt;Base&amp;&gt;(dRef).fn()&lt;&lt;std::endl;    // &lt;-- error: non-reachable base &gt;&gt;Base&lt;&lt; of &gt;&gt;Derived&lt;&lt;\n    std::cout&lt;&lt;static_cast&lt;Base*&gt;(d)-&gt;fn()&lt;&lt;std::endl;      // OK -&gt; \"42\"\n}\n</code></pre>\n<p>Why is it not possible to use the custom cast like this? Is it possible to achieve the intended behavior (\"upcasting\" to a non-reachable base with references)? </p>\n", "Tags": "<c++><templates><inheritance><casting><reference>", "OwnerUserId": "207861", "AnswerCount": "1"}, "36586174": {"ParentId": "36585964", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>[class.conv.fct]/1 reads (emphasis mine):</p>\n<blockquote>\n<p id=\"so_36585964_36586174_0\">A conversion function is never used to convert a (possibly cv-qualified) object to the (possibly cv-qualified)\n  same object type (or a reference to it), to a (possibly cv-qualified) <strong>base class of that type (or a reference to\n  it)</strong>, or to (possibly cv-qualified) void.</p>\n</blockquote>\n<p>And indeed clang gives a warning:</p>\n<pre><code>warning: conversion function converting 'Derived' to its base class 'Base' will never be used\noperator Base&amp;() {\n^\n</code></pre>\n<p>There's no such restriction for pointers, so <code>static_cast&lt;Base*&gt;(d)</code> works and calls the custom conversion operator.</p>\n<p>If you really want to use the conversion operator for references, you have to call it explicitly:</p>\n<pre><code>std::cout &lt;&lt; dRef.operator Base&amp;().fn() &lt;&lt; std::endl;\n</code></pre>\n<p>But in this case you'll probably want to create just a regular member function for that, or be honest and just make the inheritance public.</p>\n", "OwnerUserId": "3959454", "LastEditorUserId": "3959454", "LastEditDate": "2016-04-13T00:05:56.783", "Id": "36586174", "Score": "5", "CreationDate": "2016-04-12T23:59:20.750", "LastActivityDate": "2016-04-13T00:05:56.783"}, "bq_ids": {"n4140": {"so_36585964_36586174_0": {"section_id": 391, "quality": 1.0, "length": 22}}, "n3337": {"so_36585964_36586174_0": {"section_id": 382, "quality": 1.0, "length": 22}}, "n4659": {"so_36585964_36586174_0": {"section_id": 408, "quality": 1.0, "length": 22}}}});