post_cb({"bq_ids": {"n4140": {"so_31702505_31702712_5": {"length": 13, "quality": 0.8125, "section_id": 7213}, "so_31702505_31702712_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 5943}, "so_31702505_31702644_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 6135}, "so_31702505_31702644_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 5943}, "so_31702505_31702644_4": {"length": 10, "quality": 0.9090909090909091, "section_id": 45}, "so_31702505_31702712_6": {"length": 27, "quality": 0.9642857142857143, "section_id": 7213}, "so_31702505_31702712_3": {"length": 23, "quality": 1.0, "section_id": 5943}, "so_31702505_31702699_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 45}}, "n3337": {"so_31702505_31702712_5": {"length": 15, "quality": 0.9375, "section_id": 6957}, "so_31702505_31702712_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 5714}, "so_31702505_31702644_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 5899}, "so_31702505_31702644_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 5714}, "so_31702505_31702644_4": {"length": 10, "quality": 0.9090909090909091, "section_id": 42}, "so_31702505_31702712_6": {"length": 27, "quality": 0.9642857142857143, "section_id": 6957}, "so_31702505_31702712_3": {"length": 23, "quality": 1.0, "section_id": 5714}, "so_31702505_31702699_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 42}}, "n4659": {"so_31702505_31702712_5": {"length": 13, "quality": 0.8125, "section_id": 8722}, "so_31702505_31702712_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 7428}, "so_31702505_31702644_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 7632}, "so_31702505_31702644_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 7428}, "so_31702505_31702644_4": {"length": 10, "quality": 0.9090909090909091, "section_id": 46}, "so_31702505_31702712_6": {"length": 27, "quality": 0.9642857142857143, "section_id": 8722}, "so_31702505_31702712_3": {"length": 23, "quality": 1.0, "section_id": 7428}, "so_31702505_31702699_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 46}}}, "31702505": {"ViewCount": "242", "Body": "<p>I just wrote these codes:</p>\n<pre><code>int x = -1;//x must be negative\nunsigned int y = 1;//y must be positive\nbool b;\nfor(; ; x--, y++){\n    b = ((unsigned int)x) * y == ((unsigned int)(x * y));\n}\n</code></pre>\n<p>Then I just found that <code>b</code> is always true. In my opinion, ((unsigned int)x) * y will overflow, but ((unsigned int)(x * y))won't. It's really hard for me to believe this to be true. Is this just coincidence or is there any law behind this phenomenon?</p>\n", "AcceptedAnswerId": "31702699", "Title": "why is ((unsigned int)x) * y == ((unsigned int)(x * y) always true?", "CreationDate": "2015-07-29T13:52:51.187", "Id": "31702505", "CommentCount": "5", "LastEditDate": "2015-07-29T14:58:55.207", "PostTypeId": "1", "LastEditorUserId": "1708801", "LastActivityDate": "2015-07-29T23:59:12.273", "Score": "4", "OwnerUserId": "4526762", "Tags": "<c++><implicit-conversion>", "AnswerCount": "3"}, "31702644": {"Id": "31702644", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_31702505_31702644_0\">Is this just coincidence or is there any law behind this phenomenon?</p>\n</blockquote>\n<p>No, this is not a coincidence, this can be explained by the implicit conversion performed by the usual arithmetic conversions.</p>\n<p>The multiplication operator performs the <a href=\"http://en.cppreference.com/w/cpp/language/operator_arithmetic#Conversions\" rel=\"nofollow\">usual arithmetic conversions</a> on its operands to bring them to a common type and for this sub-expression:</p>\n<pre><code>(unsigned int)(x * y)\n</code></pre>\n<p>will result in <code>x</code> being converted to unsigned int. Which makes:</p>\n<pre><code>(unsigned int)(x * y)\n</code></pre>\n<p>equivalent to:</p>\n<pre><code>((unsigned int)x) * y\n</code></pre>\n<p>A lot of times using the correct warning flags can help to solve a puzzle, using <code>-Wall</code> with gcc it gives the following warning:</p>\n<pre><code>warning: self-comparison always evaluates to true [-Wtautological-compare]\n   b = ((unsigned int)x) * y == ((unsigned int)(x * y));\n                             ^\n</code></pre>\n<p>Using <code>-Wconversion</code> flag with clang gives the following warning (<em><a href=\"http://melpon.org/wandbox/permlink/Z69VxPasB6rMES8O\" rel=\"nofollow\">see it live</a></em>):</p>\n<pre><code>warning: implicit conversion changes signedness: 'int' to 'unsigned int' [-Wsign-conversion]\nb = ((unsigned int)x) * y == ((unsigned int)(x * y));\n                                             ^ ~\n</code></pre>\n<p>For reference the draft C++ standard section <code>5.6</code> <em>[expr.mul]</em> says:</p>\n<blockquote>\n<p id=\"so_31702505_31702644_1\">The usual arithmetic conversions are performed on the operands\n  and determine the type of the result.</p>\n</blockquote>\n<p>And section <code>5</code> which covers the <em>usual arithmetic conversions</em> says:</p>\n<blockquote>\n<p id=\"so_31702505_31702644_2\">Otherwise, the integral promotions (4.5) shall be performed on both operands.<sup>61</sup> Then the following\n  rules shall be applied to the promoted operands:</p>\n<p id=\"so_31702505_31702644_3\">[...]</p>\n<ul>\n<li>Otherwise, if the operand that has unsigned integer type has rank greater than or equal to the\n  rank of the type of the other operand, the operand with signed integer type shall be converted to\n  the type of the operand with unsigned integer type.</li>\n</ul>\n</blockquote>\n<p>We can find rank covered on <a href=\"http://en.cppreference.com/w/cpp/language/operator_arithmetic#Conversions\" rel=\"nofollow\">cppreference here</a> and the draft C++ standard in section <code>4.13</code> <em>[conv.rank]</em>:</p>\n<blockquote>\n<p id=\"so_31702505_31702644_4\">The rank of any unsigned integer type shall equal the rank of the corresponding signed integer type.</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-07-29T23:59:12.273", "Score": "3", "CreationDate": "2015-07-29T13:58:12.207", "ParentId": "31702505", "CommentCount": "0", "LastEditDate": "2015-07-29T23:59:12.273", "OwnerUserId": "1708801"}, "31702699": {"Id": "31702699", "PostTypeId": "2", "Body": "<p>In <code>x * y</code>, <code>x</code> is already converted to <code>unsigned</code> as a result of the usual arithmetic conversions. \u00a75/10:</p>\n<p><a href=\"https://i.stack.imgur.com/gfKEW.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/gfKEW.png\"/></a></p>\n<p>I.e. your first expression, <code>(unsigned)(x * y)</code>, is equivalent to <code>(unsigned)((unsigned)x * y)</code> which in turn is equivalent to <code>(unsigned)x * y</code> - your second expression.</p>\n<hr>\n<p>Note that the rank of <code>unsigned int</code> equals the rank of (<code>signed</code>)<code>int</code> by \u00a74.13/1.4:</p>\n<blockquote>\n<p id=\"so_31702505_31702699_0\">The rank of any unsigned integer type shall equal the rank of\n  the corresponding signed integer type.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2015-07-29T14:36:04.790", "Score": "8", "CreationDate": "2015-07-29T14:00:02.850", "ParentId": "31702505", "CommentCount": "2", "LastEditDate": "2015-07-29T14:36:04.790", "OwnerUserId": "3647361"}, "31702712": {"Id": "31702712", "PostTypeId": "2", "Body": "<p>There are 2 key points here:</p>\n<ol>\n<li><p>the usual arithmetic conversions</p></li>\n<li><p>unsigned integer arithmetic cannot overflow</p></li>\n</ol>\n<p>Quoting from the Standard:</p>\n<blockquote>\n<p id=\"so_31702505_31702712_0\">\u00a75 Expressions [expr] </p>\n<p id=\"so_31702505_31702712_1\">9 Many binary operators that expect operands of\n  arithmetic or enumeration type cause conversions and yield result\n  types in a similar way. The purpose is to yield a common type, which\n  is also the type of the result. This pattern is called the usual\n  arithmetic conversions, which are defined as follows:</p>\n<p id=\"so_31702505_31702712_2\">[...]</p>\n<p id=\"so_31702505_31702712_3\">\u2014 Otherwise, if the operand that has unsigned integer type has rank greater than or equal to the\n  rank of the type of the other operand, the operand with signed integer type shall be <strong>converted to\n  the type of the operand with unsigned integer type</strong>.</p>\n</blockquote>\n<p>So (point 1), having both operands the same rank, the signed one will be converted to the unsigned type. Thus <code>((unsigned int)x) * y</code> and <code>((unsigned int)(x * y))</code> evaluate always the same.</p>\n<p>Let's see if they are always valid, now.</p>\n<blockquote>\n<p id=\"so_31702505_31702712_4\">\u00a73.9.1 Fundamental types [basic.fundamental]</p>\n<p id=\"so_31702505_31702712_5\">4 Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo 2n where n is the number\n  of bits in the value representation of that particular size of integer.46</p>\n<p id=\"so_31702505_31702712_6\">46) This implies that <strong>unsigned arithmetic does not overflow</strong> because a result that cannot be represented by the resulting\n  unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the\n  resulting unsigned integer type.</p>\n</blockquote>\n<p>So (point 2), <code>((unsigned int)x) * y</code> will <strong>not</strong> overflow (nor will <code>y</code>, though <code>x</code> will, as the for loop goes on, so undefined behavior will occur).</p>\n", "LastEditorUserId": "2508150", "LastActivityDate": "2015-07-29T15:05:31.927", "Score": "1", "CreationDate": "2015-07-29T14:00:17.553", "ParentId": "31702505", "CommentCount": "0", "LastEditDate": "2015-07-29T15:05:31.927", "OwnerUserId": "2508150"}});