post_cb({"6302706": {"CommentCount": "0", "CreationDate": "2011-06-10T06:26:16.370", "PostTypeId": "1", "AcceptedAnswerId": "6303180", "LastEditorUserId": "560648", "LastActivityDate": "2014-11-10T04:55:50.237", "LastEditDate": "2012-11-16T11:28:35.430", "ViewCount": "1537", "FavoriteCount": "4", "Title": "Check whether iterator belongs to a list", "Id": "6302706", "Score": "14", "Body": "<p>Is there any way to check whether a given iterator belongs to a given list in C++?</p>\n", "Tags": "<c++><stl>", "OwnerUserId": "627005", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_6302706_6303180_0": {"section_id": 5574, "quality": 0.8, "length": 8}}, "n3337": {"so_6302706_6303180_0": {"section_id": 5356, "quality": 0.8, "length": 8}}, "n4659": {"so_6302706_6303180_0": {"section_id": 7021, "quality": 0.8, "length": 8}}}, "6303180": {"ParentId": "6302706", "PostTypeId": "2", "CommentCount": "10", "Body": "<h2>The obvious but invalid approach</h2>\n<p>You can't simply iterate through the list, comparing each iterator value to your \"candidate\".</p>\n<p>The C++03 Standard is vague about the validity of <code>==</code> applied to iterators from different containers (Mankarse's comment on Nawaz's answer links <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2948.html#446\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2948.html#446</a>), some compilers (eg. VC++2005 debug mode) warn if you do so, but despite all that it may actually work reliably depending on your compiler/libraries - check its documentation if you don't care about portability.</p>\n<p>The C++11 Standard is very explicit, <strong>you can't compare iterators to different containers</strong>:</p>\n<blockquote>\n<p id=\"so_6302706_6303180_0\">\u00a7 24.2.5 The domain of == for forward iterators is that of iterators over the same underlying sequence.</p>\n</blockquote>\n<p>So, the answers to this question that rely on <code>operator==</code> are questionable now, and invalid in future.</p>\n<h2>An oft-valid approach</h2>\n<p>What you <em>can</em> do is iterate along the list, comparing the address of the elements (i.e. <code>&amp;*i</code>) to the address of the object to which your other iterate points.</p>\n<ul>\n<li><p>Mankarse's comment cautions that this might not work as intended for objects providing their own <code>operator&amp;</code>.  You could work around this using <a href=\"http://en.cppreference.com/w/cpp/memory/addressof\" rel=\"nofollow noreferrer\"><code>std::addressof</code></a>, or for C++03 <a href=\"http://www.boost.org/doc/libs/1_42_0/libs/utility/utility.htm#addressof\" rel=\"nofollow noreferrer\">boost's version</a></p></li>\n<li><p>Martin's comment mentions that you have to assume the candidate iterator that you're testing list membership for is safely dereferenceable - i.e. not equal to an <code>end()</code> iterator on the container from which it came.  As Steve points out - that's a pretty reasonable precondition and shouldn't surprise anyone.</p></li>\n</ul>\n<p>(This is fine for all Standard containers as stored elements never have the same address, but more generally user-defined containers could allow non-equal iterators to address the same value object (e.g. supporting cycles or a \"flyweight pattern\" style optimisation), in which case this approach would fail.  Still, if you write such a container you're probably in a position to design for safe iterator comparison.)</p>\n<p>Implementation:</p>\n<pre><code>template &lt;class IteratorA, class IteratorB, class IteratorC&gt;\ninline bool range_contains(IteratorA from, const IteratorB&amp; end,\n                           const IteratorC&amp; candidate)\n{\n    while (from != end)\n        if (&amp;*from++ == &amp;*candidate)\n            return true;\n    return false;\n}\n</code></pre>\n<p>Notes:</p>\n<ul>\n<li>This adopts the Standard library approach of accepting a range of iterator positions to search.</li>\n<li>The types of each iterator are allowed to vary, as there are portability issues, e.g. containers where <code>begin()</code> returns an <code>iterator</code> but <code>end()</code> returns a <code>const_iterator</code>.</li>\n<li>Iterators other than <code>from</code> are taken by <code>const</code> reference, as iterators can sometimes be non-trivial objects (i.e. too large to fit in a register, relatively expensive to copy).  <code>from</code> is needed by value as it will be incremented through the range.</li>\n</ul>\n", "OwnerUserId": "410767", "LastEditorUserId": "410767", "LastEditDate": "2014-11-10T04:55:50.237", "Id": "6303180", "Score": "17", "CreationDate": "2011-06-10T07:21:11.093", "LastActivityDate": "2014-11-10T04:55:50.237"}});