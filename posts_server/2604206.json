post_cb({"2604206": {"CommentCount": "0", "AcceptedAnswerId": "2604269", "PostTypeId": "1", "LastEditorUserId": "153285", "CreationDate": "2010-04-08T23:51:12.150", "LastActivityDate": "2015-09-02T01:56:02.800", "LastEditDate": "2015-09-02T01:56:02.800", "ViewCount": "7157", "FavoriteCount": "6", "Title": "C++ constant reference lifetime (container adaptor)", "Id": "2604206", "Score": "14", "Body": "<p>I have code that looks like this:</p>\n<pre><code>class T {};\n\nclass container {\n const T &amp;first, T &amp;second;\n container(const T&amp;first, const T &amp; second);\n};\n\nclass adapter : T {};\n\ncontainer(adapter(), adapter());\n</code></pre>\n<p>I thought lifetime of constant reference would be lifetime of container.\nHowever, it appears otherwise, adapter object is destroyed after container is created, leaving dangling reference.</p>\n<p>What is the correct lifetime?</p>\n<p>is stack scope of adapter temporary object the scope of container object or of container constructor?</p>\n<p>how to correctly implement binding temporary object to class member reference?</p>\n<p>Thanks</p>\n", "Tags": "<c++><reference><const><lifetime>", "OwnerUserId": "206328", "AnswerCount": "5"}, "2604242": {"ParentId": "2604206", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2010-04-08T23:58:45.840", "Score": "1", "LastEditorUserId": "136540", "LastEditDate": "2010-04-09T00:11:36.043", "Id": "2604242", "OwnerUserId": "136540", "Body": "<p>The reference will exist for the entire lifetime of <code>container</code>, but the <b>object being referenced</b> will exist only for the lifetime of that object. In this case, you have bound your reference to a temporary object with automatic storage allocation (\"stack allocation\", if you will, although that isn't C++ nomenclature). Therefore, you cannot expect the temporary to exist beyond the statement in which it was written (as it goes out of scope immediately after the call to the constructor for <code>container</code>). The best way to deal with this is to use a copy, instead of a reference. Since you are using a const reference, anyway, it will have similar semantics.</p>\n<p>You should redefine your class as:</p>\n<pre>\ntemplate&lt;typename T&gt; \nclass container \n{\n    public:\n        container(const T&amp; first, const T&amp; second) : first(first), second(second) {}\n    private:\n        const T first;\n        const T second;\n};\n</pre>\n<p>Alternatively, you could give your objects a name to prevent them from going out of scope:</p>\n<pre>\n   adaptor first;\n   adaptor second;\n   container c(first,second);\n</pre>\n<p>However, I don't think this a good idea, since a statement such as <code>return c</code> is invalid.</p>\n<p><b>Edit</b><br/>\nIf your goal is to share objects in order to avoid the cost of copying, then you should consider using smart pointer objects. For example, we can redefine your object using smart pointers as follows:</p>\n<pre>\ntemplate&lt;typename T&gt; \nclass container \n{\n    public:\n        container(const boost::shared_ptr&lt;const T&gt;&amp; first, const boost::shared_ptr&lt;const T&gt;&amp; second) : first(first), second(second) {}\n    private:\n        boost::shared_ptr&lt;const T&gt; first;\n        boost::shared_ptr&lt;const T&gt; second;\n};\n</pre>\n<p>You can then use:</p>\n<pre>\nboost::shared_ptr&lt;const adaptor&gt; first(new adaptor);\nboost::shared_ptr&lt;const adaptor&gt; second(new adaptor);\ncontainer&lt;adaptor&gt; c(first,second);\n</pre>\n<p>Or, if you want to have mutable copies of first and second locally:</p>\n<pre>\nboost::shared_ptr&lt;adaptor&gt; first(new adaptor);\nboost::shared_ptr&lt;adaptor&gt; second(new adaptor);\ncontainer&lt;adaptor&gt; c(boost::const_pointer_cast&lt;const adaptor&gt;(first),boost::const_pointer_cast&lt;const adaptor&gt;(second));\n</pre>\n", "LastActivityDate": "2010-04-09T00:11:36.043"}, "2604269": {"ParentId": "2604206", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2010-04-09T00:04:56.417", "Score": "16", "LastEditorUserId": "12711", "LastEditDate": "2010-04-09T01:18:10.463", "Id": "2604269", "OwnerUserId": "12711", "Body": "<p>According to the C++03 standard, a temporary bound to a reference has differing lifetimes depending on the context.  In your example, I think the highlighted portion below applies (12.2/5 \"Temporary objects\"):</p>\n<blockquote>\n<p id=\"so_2604206_2604269_0\">The temporary to which the reference is bound or the temporary that is the complete object to a subobject of which the temporary is bound persists for the lifetime of the reference except as specified below. A temporary bound to a reference member in a constructor\u2019s ctor-initializer (12.6.2) persists until the constructor exits. <strong>A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full expression containing the call.</strong></p>\n</blockquote>\n<p>So while binding a temporary is an advanced technique to extend the lifetime of the temporary object (<a href=\"http://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/\" rel=\"noreferrer\">GotW #88: A Candidate For the \"Most Important const\"</a>), it apparently won't help you in this case.</p>\n<p>On the other hand, Eric Niebler has an article that you may be interested in that discusses an interesting (if convoluted) technique that could let your class's constructors deduce whether a temporary object (actually an rvalue) has been passed to it (and therefore would have to be copied) or a non-temporary (lvalue) as been passed (and therefore could potentially safely have a reference stashed away instead of copying):</p>\n<ul>\n<li><a href=\"http://www.artima.com/cppsource/foreach.html\" rel=\"noreferrer\">Conditional Love: FOREACH Redux</a> </li>\n</ul>\n<p>Good luck with it though - every time I read the article, I have to work through everything as if I've never seen the material before. It only sticks with me for a fleeting moment...</p>\n<p>And I should mention that C++0x's rvalue references should make Niebler's techniques unnecessary.  Rvalue references will be supported by MSVC 2010 which is scheduled to be released in a week or so (on 12 April 2010 if I recall correctly). I don't know what the status of rvalue references is in GCC.</p>\n", "LastActivityDate": "2010-04-09T01:18:10.463"}, "2604239": {"ParentId": "2604206", "CommentCount": "2", "CreationDate": "2010-04-08T23:58:04.527", "OwnerUserId": "36384", "PostTypeId": "2", "Id": "2604239", "Score": "6", "Body": "<p>Temporary const references only have the lifetime of the current statement (that is, they go out of scope just before the semi-colon).  So the rule of thumb is never rely on a const-reference existing beyond the lifetime of the function that receives it as a parameter, in this case that's just the constructor.  So once the constructor is done, don't rely on any const references to still be around.</p>\n<p>There is no way to change/override/extend this lifetime for temporaries.  If you want a longer lifetime, use an actual object and not a temporary:</p>\n<pre><code>adapter a, b; \ncontainer(a, b); // lifetime is the lifetime of a and b\n</code></pre>\n<p>Or better yet, just don't use constant references to class members except in the most dire circumstances when the objects are very closely related and definitely not temporary.</p>\n", "LastActivityDate": "2010-04-08T23:58:04.527"}, "2604248": {"ParentId": "2604206", "PostTypeId": "2", "CommentCount": "14", "CreationDate": "2010-04-08T23:59:46.707", "Score": "-1", "LastEditorUserId": "303180", "LastEditDate": "2010-04-09T00:13:01.767", "Id": "2604248", "OwnerUserId": "303180", "Body": "<p>Don't do this.  A temporary is destroyed immediately after the expression in which it was created (except in the case that it's immediately bound to a reference, in which case it's the scope of the reference).  The lifetime cannot be extended to that of the class.</p>\n<p>This is why I never store members as references - only copied objects or pointers.  To me, pointers make it obvious that the lifetime comes in to play.  Especially in the case of a constructor, it's non-obvious that your constructor params must outlive the class itself.</p>\n", "LastActivityDate": "2010-04-09T00:13:01.767"}, "bq_ids": {"n4140": {"so_2604206_2604269_0": {"section_id": 382, "quality": 0.8292682926829268, "length": 34}}, "n3337": {"so_2604206_2604269_0": {"section_id": 373, "quality": 0.8292682926829268, "length": 34}}, "n4659": {"so_2604206_2604269_0": {"section_id": 397, "quality": 0.5853658536585366, "length": 24}}}, "2606552": {"ParentId": "2604206", "CommentCount": "0", "CreationDate": "2010-04-09T10:15:05.980", "OwnerUserId": "219972", "PostTypeId": "2", "Id": "2606552", "Score": "0", "Body": "<p>If you want to avoid copying, then I suppose the Container must create the stored instances itself.</p>\n<p>If you want to invoke the default constructor, then it should be no problem. Just invoke the default constructor of Container.</p>\n<p>It is probably more problematic if you want to invoke a non-default constructor of the contained type. C++0x will have better solutions for that.</p>\n<p>As an excercise, the container can accept a T, or an object containing the arguments for the constructor of T. This still relies on RVO (return value optimization).</p>\n<pre><code>template &lt;class T1&gt;\nclass construct_with_1\n{\n    T1 _1;\npublic:\n    construct_with_1(const T1&amp; t1): _1(t1) {}\n    template &lt;class U&gt;\n    U construct() const { return U(_1); }\n};\n\ntemplate &lt;class T1, class T2&gt;\nclass construct_with_2\n{\n    T1 _1;\n    T2 _2;\npublic:\n    construct_with_2(const T1&amp; t1, const T2&amp; t2): _1(t1), _2(t2) {}\n    template &lt;class U&gt;\n    U construct() const { return U(_1, _2); }\n};\n\n//etc for other arities\n\ntemplate &lt;class T1&gt;\nconstruct_with_1&lt;T1&gt; construct_with(const T1&amp; t1)\n{\n    return construct_with_1&lt;T1&gt;(t1);\n}\n\ntemplate &lt;class T1, class T2&gt;\nconstruct_with_2&lt;T1, T2&gt; construct_with(const T1&amp; t1, const T2&amp; t2)\n{\n    return construct_with_2&lt;T1, T2&gt;(t1, t2);\n}\n\n//etc\ntemplate &lt;class T&gt;\nT construct(const T&amp; source) { return source; }\n\ntemplate &lt;class T, class T1&gt;\nT construct(const construct_with_1&lt;T1&gt;&amp; args)\n{\n    return args.template construct&lt;T&gt;();\n}\n\ntemplate &lt;class T, class T1, class T2&gt;\nT construct(const construct_with_2&lt;T1, T2&gt;&amp; args)\n{\n    return args.template construct&lt;T&gt;();\n}\n\ntemplate &lt;class T&gt;\nclass Container\n{\npublic:\n    T first, second;\n\n    template &lt;class T1, class T2&gt;\n    Container(const T1&amp; a = T1(), const T2&amp; b = T2()) : \n        first(construct&lt;T&gt;(a)), second(construct&lt;T&gt;(b)) {}\n}; \n\n#include &lt;iostream&gt;\n\nclass Test\n{\n    int n;\n    double d;\npublic:\n    Test(int a, double b = 0.0): n(a), d(b) { std::cout &lt;&lt; \"Test(\" &lt;&lt; a &lt;&lt; \", \" &lt;&lt; b &lt;&lt; \")\\n\"; }\n    Test(const Test&amp; x): n(x.n), d(x.d) { std::cout &lt;&lt; \"Test(const Test&amp;)\\n\"; }\n    void foo() const { std::cout &lt;&lt; \"Test.foo(\" &lt;&lt; n &lt;&lt; \", \" &lt;&lt; d &lt;&lt; \")\\n\"; }\n};\n\nint main()\n{\n    Test test(4, 3.14);\n    Container&lt;Test&gt; a(construct_with(1), test); //first constructed internally, second copied\n    a.first.foo();\n    a.second.foo();\n}\n</code></pre>\n", "LastActivityDate": "2010-04-09T10:15:05.980"}});