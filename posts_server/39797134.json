post_cb({"39797134": {"CommentCount": "9", "ViewCount": "127", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2016-09-30T17:40:50.407", "LastActivityDate": "2017-03-19T16:53:41.390", "Title": "Where exactly in the C++14 Standard does it allow the use of a user-defined conversion function in a direct-initialization?", "LastEditDate": "2017-03-19T16:53:41.390", "Id": "39797134", "Score": "5", "Body": "<p>For example, in the snippet below the user-defined conversion function <code>C::operator A()</code> is implicitly invoked to convert an lvalue of type <code>C</code> into a prvalue of type <code>A</code>, which copy-initializes the variable <code>a</code> in a <strong>direct-initialization</strong>.</p>\n<pre><code>struct A {};  \nstruct C { operator A() { return A(); }; };\n\nint main()\n{\n     C c;\n     A a(c); \n}\n</code></pre>\n<p>I just want to know where this is described in the C++14 Standard. I have a feeling that the answer is in [over.match.copy]/1 bullet point (1.2), but I'm having a problem with the section title <strong>Copy-initialization by user-defined conversion</strong>.</p>\n", "Tags": "<c++><c++14><language-lawyer>", "OwnerUserId": "2548699", "AnswerCount": "1"}, "42889321": {"ParentId": "39797134", "CommentCount": "0", "Body": "<p>There are two constructors on <code>A</code> that can be invoked with a single argument:</p>\n<pre><code>A(A const&amp;); // copy constructor\nA(A&amp;&amp; );     // move constructor\n</code></pre>\n<p>In either case, <a href=\"http://eel.is/c++draft/dcl.init.ref#5.1.2\" rel=\"nofollow noreferrer\">[dcl.init.ref]</a> explains how we can initialize the reference:</p>\n<blockquote>\n<p id=\"so_39797134_42889321_0\">A reference of type \"<em>cv1</em> <code>T1</code>\" is initialized by an expression of type \"<em>cv2</em> <code>T2</code>\" as follows:<br>\n  \u2014 If the reference is an lvalue reference and the initializer expression<br>\n  \u00a0\u00a0\u2014 is an lvalue (but is not a bit-field), and \u201c<em>cv1</em> <code>T1</code>\u201d is reference-compatible with \u201c<em>cv2</em> <code>T2</code>\u201d, or<br>\n  \u00a0\u00a0\u2014 <strong>has a class type (i.e., <code>T2</code> is a class type), where <code>T1</code> is not reference-related to <code>T2</code>, and can be converted to an lvalue of type \u201c<em>cv3</em> <code>T3</code>\u201d, where \u201c<em>cv1</em> <code>T1</code>\u201d is reference-compatible with \u201c<em>cv3</em> <code>T3</code>\u201d (this conversion is selected by enumerating the applicable conversion functions ([over.match.ref]) and choosing the best one through overload resolution)</strong>,<br>\n  \u00a0\u00a0then the reference is bound to the initializer expression lvalue in the first case and to the lvalue result of the conversion in the second case (or, in either case, to the appropriate base class subobject of the object).</br></br></br></br></p>\n</blockquote>\n<p>We have references of type <code>A</code> or <code>A const</code> being initialized by an expression of type <code>C</code>, which is a class type not reference-related to <code>A</code>. To check if it can be converted to a reference-compatible type <em>cv3</em> <code>T3</code>, we check <a href=\"http://eel.is/c++draft/over.match.ref\" rel=\"nofollow noreferrer\">[over.match.ref]</a>:</p>\n<blockquote>\n<p id=\"so_39797134_42889321_1\">The conversion functions of <code>S</code> and its base classes are considered. Those non-explicit conversion functions that are not hidden within <code>S</code> and yield type <strong>\u201clvalue reference to <em>cv2</em> <code>T2</code>\u201d (when initializing an lvalue reference or an rvalue reference to function)</strong> or <strong>\u201c<em>cv2</em> <code>T2</code>\u201d or \u201crvalue reference to <em>cv2</em> <code>T2</code>\u201d (when initializing an rvalue reference or an lvalue reference to function)</strong>, where \u201c<em>cv1</em> <code>T</code>\u201d is reference-compatible with \u201c<em>cv2</em> <code>T2</code>\u201d, are candidate functions. For direct-initialization, [...]</p>\n</blockquote>\n<p>Hence, for the copy constructor, we consider those conversion functions that yield <code>A&amp;</code> and for the move constructor, we consider those conversion functions that yield <code>A</code> or <code>A&amp;&amp;</code>. We don't have the former, but we do have the latter: <code>operator A()</code>. </p>\n<p>This makes the move constructor of <code>A</code> a viable constructor, but not the copy constructor of <code>A</code>. Since we only have one viable candidate, it is trivially the best viable candidate. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "42889321", "Score": "0", "CreationDate": "2017-03-19T16:52:04.113", "LastActivityDate": "2017-03-19T16:52:04.113"}, "bq_ids": {"n4140": {"so_39797134_42889321_0": {"section_id": 3321, "quality": 0.8805970149253731, "length": 59}, "so_39797134_42889321_1": {"section_id": 597, "quality": 0.8372093023255814, "length": 36}}, "n3337": {"so_39797134_42889321_0": {"section_id": 3191, "quality": 0.8805970149253731, "length": 59}, "so_39797134_42889321_1": {"section_id": 587, "quality": 0.5581395348837209, "length": 24}}, "n4659": {"so_39797134_42889321_0": {"section_id": 4087, "quality": 0.8805970149253731, "length": 59}, "so_39797134_42889321_1": {"section_id": 620, "quality": 0.8372093023255814, "length": 36}}}});