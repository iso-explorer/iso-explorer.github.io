post_cb({"1801280": {"ParentId": "1801251", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_1801251_1801280_0\">Under the covers, BOOST_FOREACH uses\n  iterators to traverse the element\n  sequence. Before the loop is executed,\n  the end iterator is cached in a local\n  variable. This is called hoisting, and\n  it is an important optimization. It\n  assumes, however, that the end\n  iterator of the sequence is stable. It\n  usually is, but if we modify the\n  sequence by adding or removing\n  elements while we are iterating over\n  it, we may end up hoisting ourselves\n  on our own petard.</p>\n</blockquote>\n<p><a href=\"http://www.boost.org/doc/libs/1_40_0/doc/html/foreach/pitfalls.html\" rel=\"noreferrer\">http://www.boost.org/doc/libs/1_40_0/doc/html/foreach/pitfalls.html</a></p>\n<p>If you don't want the end() iterator to change use resize on the vector rather than reserve.</p>\n<p><a href=\"http://www.cplusplus.com/reference/stl/vector/resize/\" rel=\"noreferrer\">http://www.cplusplus.com/reference/stl/vector/resize/</a></p>\n<p>Note that then you wouldn't want to push_back but use the operator[] instead.  But be careful of going out of bounds.</p>\n", "OwnerUserId": "130086", "LastEditorUserId": "130086", "LastEditDate": "2009-11-26T02:57:50.930", "Id": "1801280", "Score": "6", "CreationDate": "2009-11-26T02:43:32.660", "LastActivityDate": "2009-11-26T02:57:50.930"}, "1801251": {"CommentCount": "8", "ViewCount": "3849", "CreationDate": "2009-11-26T02:30:49.240", "LastActivityDate": "2009-11-26T17:15:03.997", "Title": "Modifying contents of vector in BOOST_FOREACH", "AcceptedAnswerId": "1801280", "PostTypeId": "1", "Id": "1801251", "Score": "0", "Body": "<p>This is a question that goes to how BOOST_FOREACH checks it's loop termination</p>\n<pre><code>cout &lt;&lt; \"Testing BOOST_FOREACH\" &lt;&lt; endl;\nvector&lt;int&gt; numbers; numbers.reserve(8);\nnumbers.push_back(1); numbers.push_back(2); numbers.push_back(3);\ncout &lt;&lt; \"capacity = \" &lt;&lt; numbers.capacity() &lt;&lt; endl;\nBOOST_FOREACH(int elem, numbers)\n{\n    cout &lt;&lt; elem &lt;&lt; endl;\n    if (elem == 2) numbers.push_back(4); \n}\ncout &lt;&lt; \"capacity = \" &lt;&lt; numbers.capacity() &lt;&lt; endl;\n</code></pre>\n<p>gives the output</p>\n<pre><code>Testing BOOST_FOREACH\ncapacity = 8\n1\n2\n3\ncapacity = 8\n</code></pre>\n<p>But what about the number 4 which was inserted half way through the loop? If I change the type to a list the newly inserted number will be iterated over. The vector push_back operation will invalidate any pointers IF a reallocation is required, however that is not happening in this example. So the question I guess is why does the end() iterator appear to only be evaluated once (before the loop) when using vector but has a more dynamic evaluation when using a list?</p>\n", "Tags": "<c++><boost><vector><foreach>", "OwnerUserId": "105804", "AnswerCount": "3"}, "1801336": {"ParentId": "1801251", "CommentCount": "1", "Body": "<p>boost's foreach will terminate when it's iterator == numbers.end()</p>\n<p>Be careful though, calling push_back can/will invalidate any current iterators you have.</p>\n", "OwnerUserId": "158259", "PostTypeId": "2", "Id": "1801336", "Score": "0", "CreationDate": "2009-11-26T03:09:28.787", "LastActivityDate": "2009-11-26T03:09:28.787"}, "1801384": {"ParentId": "1801251", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The question was raised in the comments as to why the Microsoft debug runtime raises an assertion during iteration over the vector but not over the list.  The reason is that <code>insert</code> is defined differently for <code>list</code> and <code>vector</code> (note that <code>push_back</code> is just an <code>insert</code> at the end of the sequence).</p>\n<p>Per the C++ standard (ISO/IEC 14882:2003 23.2.4.3, <em>vector modifiers</em>):</p>\n<blockquote>\n<p id=\"so_1801251_1801384_0\">[on insertion], if no reallocation happens, all the iterators and references before the insertion point remain valid.</p>\n</blockquote>\n<p>(23.2.2.3, <em>list modifiers</em>):</p>\n<blockquote>\n<p id=\"so_1801251_1801384_1\">[insert] does not affect the validity of iterators and references.</p>\n</blockquote>\n<p>So, if you use <code>push_back</code> (and are sure that it's not going to cause a reallocation), it's okay with either container to continue using your iterator to iterate over the rest of the sequence.</p>\n<p>In the case of the vector, however, it's <strong>undefined behavior</strong> to use the <code>end</code> iterator that you obtained before the <code>push_back</code>.</p>\n<p><em>This is a roundabout answer to the question; it's a direct answer to the discussion in the question's comments.</em></p>\n", "OwnerUserId": "151292", "LastEditorUserId": "151292", "LastEditDate": "2009-11-26T17:15:03.997", "Id": "1801384", "Score": "2", "CreationDate": "2009-11-26T03:28:02.650", "LastActivityDate": "2009-11-26T17:15:03.997"}, "bq_ids": {"n4140": {"so_1801251_1801384_0": {"section_id": 986, "quality": 0.9090909090909091, "length": 10}, "so_1801251_1801384_1": {"section_id": 745, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_1801251_1801384_0": {"section_id": 971, "quality": 0.9090909090909091, "length": 10}, "so_1801251_1801384_1": {"section_id": 734, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_1801251_1801384_0": {"section_id": 1049, "quality": 0.9090909090909091, "length": 10}, "so_1801251_1801384_1": {"section_id": 803, "quality": 0.8333333333333334, "length": 5}}}});