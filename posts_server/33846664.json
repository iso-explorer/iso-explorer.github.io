post_cb({"bq_ids": {"n4140": {"so_33846664_33848134_0": {"length": 10, "quality": 1.0, "section_id": 381}, "so_33846664_33848134_1": {"length": 5, "quality": 1.0, "section_id": 382}, "so_33846664_33846664_0": {"length": 19, "quality": 0.8636363636363636, "section_id": 382}}, "n3337": {"so_33846664_33848134_0": {"length": 10, "quality": 1.0, "section_id": 372}, "so_33846664_33848134_1": {"length": 5, "quality": 1.0, "section_id": 373}, "so_33846664_33846664_0": {"length": 19, "quality": 0.8636363636363636, "section_id": 373}}, "n4659": {"so_33846664_33848134_0": {"length": 9, "quality": 0.9, "section_id": 396}, "so_33846664_33848134_1": {"length": 4, "quality": 0.8, "section_id": 397}, "so_33846664_33846664_0": {"length": 18, "quality": 0.8181818181818182, "section_id": 397}}}, "33846664": {"ViewCount": "195", "Body": "<p>The C++ standard draft N4296 says</p>\n<blockquote>\n<p id=\"so_33846664_33846664_0\">[class.temporary/5] The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except...</p>\n</blockquote>\n<p>So I want to know what happens if two or more references are bound to a temporary. Is it specific <strong>in the standard</strong>? The following code may be an example:</p>\n<pre><code>#include &lt;iostream&gt; //std::cout\n#include &lt;string&gt;   //std::string\nconst std::string &amp;f() {\n    const std::string &amp;s = \"hello\";\n    static const std::string &amp;ss = s;\n    return ss;\n}\nint main() {\n    const std::string &amp;rcs = f();\n    std::cout &lt;&lt; rcs; //empty output\n                      //the lifetime of the temporary is the same as that of s\n    return 0;\n}\n</code></pre>\n<p>If we change the bounding order, the case is different.</p>\n<pre><code>#include &lt;iostream&gt; //std::cout\n#include &lt;string&gt;   //std::string\nconst std::string &amp;f() {\n    static const std::string &amp;ss = \"hello\";\n    const std::string &amp;s = ss;\n    return ss;\n}\nint main() {\n    const std::string &amp;rcs = f();\n    std::cout &lt;&lt; rcs; //output \"hello\"\n                      //the lifetime of the temporary is the same as that of ss\n    return 0;\n}\n</code></pre>\n<p>The compilation is done on Ideone.com. </p>\n<p>I guess [class.temporary/5] only holds when the <strong>first</strong> reference is bound to the temporary, but I cannot find an evidence in the standard.</p>\n", "AcceptedAnswerId": "33847360", "Title": "The lifetime of a temporary to which several references are bound in C++", "CreationDate": "2015-11-21T17:53:44.883", "Id": "33846664", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-11-21T22:09:35.433", "Score": "5", "OwnerUserId": "5376789", "Tags": "<c++><standards><temporary><object-lifetime>", "AnswerCount": "3"}, "33848134": {"Id": "33848134", "PostTypeId": "2", "Body": "<p>The first function presented in the question,</p>\n<pre><code>const std::string &amp;f() {\n    const std::string &amp;s = \"hello\";\n    static const std::string &amp;ss = s;\n    return ss;\n}\n</code></pre>\n<p>yields Undefined Behaviour if the returned reference is used. The referred to object ceases to exist when the first call of the function returns. And on subsequent calls <code>ss</code> is a <em>dangling reference</em>.</p>\n<p>The <strong>context</strong> of the standard's lifetime extension paragraph is</p>\n<b>C++11 \u00a712.2/4</b>\n<blockquote>\n<p id=\"so_33846664_33848134_0\"><strong>\u201d</strong> There are two contexts in which temporaries are destroyed at a different point than the end of the full-expression</p>\n</blockquote>\n<p>I.e., this is all about about temporaries that otherwise would be destroyed at the end of the full-expression producing them.</p>\n<p>One of the two contexts is, with four noted exceptions,</p>\n<b>C+11 \u00a712.2/5</b>\n<blockquote>\n<p id=\"so_33846664_33848134_1\"><strong>\u201d</strong> \u2026 when a reference is bound to [such a] a temporary</p>\n</blockquote>\n<p>In the code above the temporary <code>std::string</code> produced by the full-expression <code>\"hello\"</code> is bound to the reference <code>s</code> and lifetime extended to the scope of <code>s</code>, which is the function body.</p>\n<p>The subsequent declaration and initialization of a static reference <code>ss</code> does not involve a full-expression that creates temporary. Its initializer expression <code>s</code> is not a temporary: it's a reference to a local. Hence it's outside the context covered by the lifetime extension paragraph.</p>\n<p>But how do we <em>know</em> that that's what's meant? Well, keeping track of whether a reference dynamically refers to something that originally was a temporary, is non-computable for the general case, and the C++ language standard does not involve such far fetched concepts. So it's simple, really.</p>\n<hr>\n<p>An IMHO more interesting case, wrt. the formal rules, is</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt; class Type &gt;\nauto temp_ref( Type&amp;&amp; o ) -&gt; T&amp; { return o; }\n\nauto main() -&gt; int\n{\n    auto const&amp; s = temp_ref( string( \"uh\" ) + \" oh!\" );\n    cout &lt;&lt; s &lt;&lt; endl;\n}\n</code></pre>\n<p>I contend that there's no lifetime extension here, and that the output statement using reference <code>s</code> is using a dangling reference, with UB as a result.</p>\n<p>And I think that this conclusion, unlike the OP's choice of example, cannot be argued solely on the basis of the standard's wording, because (it seems to me that) the standard's wording is a bit defective. That it fails to make an exception for <em>reference types</em>. But, I might be wrong, and if I learn that I'll update this answer to reflect that new understanding.</p>\n</hr>", "LastEditorUserId": "464581", "LastActivityDate": "2015-11-21T20:52:43.943", "Score": "1", "CreationDate": "2015-11-21T20:15:58.177", "ParentId": "33846664", "CommentCount": "2", "OwnerUserId": "464581", "LastEditDate": "2015-11-21T20:52:43.943"}, "33847360": {"Id": "33847360", "PostTypeId": "2", "Body": "<p>This is a defect in that section that I reported as <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1299\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1299</a> .</p>\n<p>The proposed resolution is to add a term \"temporary expressions\". Life-time extension only happens for objects referred to by temporary expressions. </p>\n<p>Here's my original report which I privately emailed. I think it makes clear what it's about</p>\n<blockquote>\n<p id=\"so_33846664_33847360_0\">In the model of the Standard, there appears to be a distinction about\n  temporary objects, and temporary expressions.</p>\n<p id=\"so_33846664_33847360_1\">Temporary objects are created by certain operations operations, like\n  functional casts to class types. Temporary objects have a limited\n  specified lifetime.</p>\n<p id=\"so_33846664_33847360_2\">Temporary expressions are expressions that are so attributed because\n  they are used to track whether or not an expression refers to a\n  temporary object for the purpose of determining whether or not the\n  lifetime of their referent is lengthened when bound by a reference.\n  Temporary expressions are compile time entities.</p>\n<p id=\"so_33846664_33847360_3\">Several paragraphs refer to \"temporaries\", but do not explicitly\n  specify whether they refer to temporary objects referred to by\n  arbitrary expressions, or whether they refer only to temporary\n  expressions. The paragraphs about RVO (paragraph 12.8p31) use\n  \"temporary\" in the sense of temporary objects (they say such things\n  like \"temporary class object that has not been bound to a reference\").\n  The paragraphs about lifetime lengthening (sub-clause 12.2) refer to\n  both kinds of temporaries. For example, in the following, \"*this\" is\n  not regarded as a temporary, even though it refers to a temporary</p>\n<pre><code>struct A { A() { } A &amp;f() { return *this; } void g() { } };\n\n// call of g() is valid: lifetime did not end prematurely\n// at the return statement\nint main () { A().f().g(); }\n</code></pre>\n<p id=\"so_33846664_33847360_4\">As another example, core issue 462 handles about temporary expressions\n  (making a comma operator expression a temporary, if the left operand\n  was one). This appears to be very similar to the notion of \"lvalue\n  bitfields\". Lvalues that track along that they refer to bitfields at\n  translation time, so that reads from them can act accordingly and that\n  certain reference binding scenarios can emit diagnostics.</p>\n</blockquote>\n", "LastEditorUserId": "34509", "LastActivityDate": "2015-11-21T19:10:56.433", "Score": "5", "CreationDate": "2015-11-21T19:01:25.757", "ParentId": "33846664", "CommentCount": "13", "OwnerUserId": "34509", "LastEditDate": "2015-11-21T19:10:56.433"}, "33847223": {"Id": "33847223", "PostTypeId": "2", "Body": "<p>What you need to know is that a reference return type does not count as a temporary for the purposes of this section, and will never cause lifetime extension.</p>\n<p>(Pedantic note: The standard requires that the reference be bound to an <em>xvalue</em>, not merely to a temporary.  The second reference is bound via an lvalue, not an xvalue.)</p>\n<p>Your first example returns a dangling reference -- the <code>cout</code> line is undefined behavior.  It could print <code>Hello!</code> and that would prove nothing.</p>\n<p>Here's a simpler example:</p>\n<pre><code>template&lt;class T&gt;\nconst T&amp; ident(const T&amp; in) { return in; }\n\nint main(void)\n{\n    const X&amp; ref1 = X(1); // lifetime extension occurs\n    const X&amp; ref2 = ident(X(2)); // no lifetime extension\n    std::cout &lt;&lt; \"Here.\\n\";\n}\n</code></pre>\n<p>The order of construction and destruction is:</p>\n<pre><code>X(1)\nX(2)\n~X() for X(2) object\n\"Here.\" is printed\n~X() for X(1) object\n</code></pre>\n", "LastEditorUserId": "103167", "LastActivityDate": "2015-11-21T22:09:35.433", "Score": "2", "CreationDate": "2015-11-21T18:48:30.870", "ParentId": "33846664", "CommentCount": "9", "OwnerUserId": "103167", "LastEditDate": "2015-11-21T22:09:35.433"}});