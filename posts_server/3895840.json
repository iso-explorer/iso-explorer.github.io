post_cb({"3896363": {"ParentId": "3895840", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>I see two issues with your approach.</p>\n<p>You rely on the behaviour</p>\n<pre><code>int   i = 0;\nint&amp;  j = true?      i  :      i;\nint&amp;&amp; k = true? move(i) : move(i);\nassert(&amp;i == &amp;j); // OK, Guaranteed since C++98\nassert(&amp;i == &amp;k); // Does this hold as well?\n</code></pre>\n<p>The current standard draft N3126 contains 5.16/4:</p>\n<blockquote>\n<p id=\"so_3895840_3896363_0\">If the second and third operands [to the conditional operator] are glvalues of the same value category and have the same type, the result is of that type and value category</p>\n</blockquote>\n<p>which makes me think that the above two asserts should hold. But using GCC 4.5.1 the second one fails. I believe that this is a GCC bug.</p>\n<p>In addition, you rely on the compiler to extend life time of the temporary object <code>y</code> refers to in the following example:</p>\n<pre><code>A func();\n\nA&amp;&amp; x = func();                   // #1\nA&amp;&amp; y = static_cast&lt;A&amp;&amp;&gt;(func()); // #2\n</code></pre>\n<p><code>x</code> won't be a dangling reference <strike>but I'm not so sure about <code>y</code>. I think the rule about extending the life-time of temporaries is only supposed to apply in cases the initializer expressions are <em>pure</em> rvalues. At least, this would greatly simplify the implementation. Also, GCC seems to agree with me on this one. GCC doesn't extend the life-time of the temporary A object in the second case. This would be a dangling-reference problem in your approach</strike>.</p>\n<p><strong>Update:</strong> According to 12.2/5 the lifetimes of the temporary objects are supposed to be extended in both cases, #1 and #2. None of the bullet points in the list of exceptions seem to apply here. Again, GCC seems to be buggy in this regard.</p>\n<p>One easy solution for your problem would be:</p>\n<pre><code>vector&lt;A&gt; tempcopy;\nif (!modify) tempcopy.push_back(myA);\nA&amp; ref = modify ? myA : tempcopy.back();\n</code></pre>\n<p>Alternativly, you could use a boost::scoped_ptr instead of a vector.</p>\n", "OwnerUserId": "172531", "LastEditorUserId": "172531", "LastEditDate": "2010-10-09T17:32:01.367", "Id": "3896363", "Score": "2", "CreationDate": "2010-10-09T16:18:17.130", "LastActivityDate": "2010-10-09T17:32:01.367"}, "3896794": {"ParentId": "3895840", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Just avoid this whole mess with an extra function call:</p>\n<pre><code>void f(bool modify, A &amp;obj) {\n  return [&amp;](A &amp;&amp;obj) {\n    real();\n    work();\n  }(modify ? std::move(obj) : std::move(A(obj)));\n}\n</code></pre>\n<p>Instead of:</p>\n<pre><code>void f(bool modify, A &amp;obj) {\n  A &amp;&amp;var_or_dummy = /* ??? */;\n  real();\n  work();\n}\n</code></pre>\n<p>It's <a href=\"http://herbsutter.com/2010/10/07/c-and-beyond-session-lambdas-lambdas-everywhere/\" rel=\"nofollow\">lambdas, lambdas, everywhere</a>!</p>\n", "Id": "3896794", "LastEditDate": "2010-10-09T17:52:18.347", "OwnerDisplayName": "Roger Pate", "Score": "2", "CreationDate": "2010-10-09T09:41:57.067", "LastActivityDate": "2010-10-09T17:52:18.347", "LastEditorDisplayName": "Roger Pate"}, "3898712": {"ParentId": "3895840", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The issue of xvalue safety can be worked around somewhat by providing an alternative for use inside expressions. The issues are completely different, now we <em>don't</em> want an xvalue result and can use a function:</p>\n<pre><code>template&lt; typename T &gt;\nT &amp;var_or_dummy( bool modify, T &amp;var, T &amp;&amp;dummy = T() ) {\n    if ( modify ) return var;\n    else return dummy = var;\n}\n\n    maybe_get_result( arg, var_or_dummy( want_it, var ) );\n</code></pre>\n<p>Now the type has to be default-constructible, and the dummy is always constructed. The copy is conditionally evaluated. I don't think I'd really want to deal with code that did too much of this.</p>\n<p><a href=\"http://www.boost.org/doc/libs/release/libs/optional/index.html\" rel=\"nofollow\">Boost Optional</a> can help a bit; it only requires CopyConstructible T:</p>\n<pre><code>template&lt; typename T &gt;\nT &amp;var_or_dummy( bool modify, T &amp;var,\n                 boost::optional&lt; T &gt; &amp;&amp;dummy = boost::optional&lt; T &gt;() ) {\n    if ( modify ) return var;\n    else return dummy = var;\n}\n</code></pre>\n<p>Optional is useful, but it has some overlap with C++0x unions. It's not too hard to reimplement.</p>\n<pre><code>template&lt; class T &gt;\nstruct optional_union {\n    bool valid;\n    union storage {\n        T obj; // union of one non-POD member simply reserves storage\n\n        storage() {} // uh, what could the constructor/destructor possibly do??\n        ~storage() {}\n    } s;\n\n    optional_union() : valid( false ) {}\n    optional_union &amp;operator=( T const &amp;in ) {\n        new( &amp;s.obj ) T( in ); // precondition: ! valid\n        valid = true;\n        return *this; \n    }\n    ~optional_union()\n        { if ( valid ) s.obj.~T(); }\n};\n\ntemplate&lt; typename T &gt;\nT &amp;var_or_dummy( bool modify, T &amp;var,\n                 optional_union&lt; T &gt; &amp;&amp;dummy = optional_union&lt; T &gt;() ) {\n    if ( modify ) return var;\n    else return ( dummy = var ).s.obj;\n}\n</code></pre>\n<p>The <code>optional_union</code> class is only sufficient for this application\u2026 obviously it could be expanded a lot.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2010-10-10T02:13:36.127", "Id": "3898712", "Score": "0", "CreationDate": "2010-10-10T02:07:47.360", "LastActivityDate": "2010-10-10T02:13:36.127"}, "3895840": {"CommentCount": "4", "AcceptedAnswerId": "3896794", "PostTypeId": "1", "LastEditorUserId": "153285", "CreationDate": "2010-10-09T05:32:47.060", "LastActivityDate": "2010-10-10T07:39:22.863", "LastEditDate": "2010-10-09T06:25:11.723", "ViewCount": "461", "FavoriteCount": "0", "Title": "style in binding a reference to object-or-dummy", "Id": "3895840", "Score": "5", "Body": "<p>What is the best way to bind an rvalue reference to either a given object or a temporary copy of it?</p>\n<pre><code>A &amp;&amp;var_or_dummy = modify? static_cast&lt;A&amp;&amp;&gt;( my_A )\n                         : static_cast&lt;A&amp;&amp;&gt;( static_cast&lt;A&gt;( my_A ) );\n</code></pre>\n<p>(This code doesn't work on my recent GCC 4.6\u2026 I recall it working before, but now it always returns a copy.)</p>\n<p>On the first line, the <code>static_cast</code> transforms <code>my_A</code> from an lvalue to an xvalue. (C++0x \u00a75.2.9/1-3) The inner <code>static_cast</code> on the second line performs lvalue-to-rvalue conversion, and the outer one obtains an xvalue from this prvalue.</p>\n<p>This appears to be supported because the named reference is conditionally bound to the temporary per \u00a712.2/5. The same trick works the same way in C++03 with a <code>const</code> reference.</p>\n<p>I can also write the same thing less verbosely:</p>\n<pre><code>A &amp;&amp;var_or_dummy = modify? std::move( my_A )\n                         : static_cast&lt;A&amp;&amp;&gt;( A( my_A ) );\n</code></pre>\n<p>Now it's much shorter. The first abbreviation is questionable: <code>move</code> is supposed to signal that something is happening to the object, not a mere lvalue-to-xvalue-to-lvalue shuffle. Confusingly, <code>move</code> cannot be used after the <code>:</code> because the function call would interrupt the temporary-to-reference binding. The syntax <code>A(my_A)</code> is perhaps clearer than the <code>static_cast</code>, but it's technically equivalent to a C-style cast.</p>\n<p>I can also go all the way and write it entirely in C-style casts:</p>\n<pre><code>A &amp;&amp;var_or_dummy = modify? (A&amp;&amp;)( my_A ) : (A&amp;&amp;)( A( my_A ) );\n</code></pre>\n<p>After all, if this is going to be an idiom, it must be convenient, and <code>static_cast</code> isn't really protecting me from anything anyway \u2014 the real danger is failing to bind directly to <code>my_A</code> in the <code>true</code> case.</p>\n<p>On the other hand, this easily gets dominated by the typename repeated three times. If <code>A</code> were replaced with a big, ugly template-id, I'd really want a real shortcut.</p>\n<p>(Note that <code>V</code> is evaluated only once despite appearing five times:)</p>\n<pre><code>#define VAR_OR_DUMMY( C, V ) ( (C)? \\\n  static_cast&lt; typename std::remove_reference&lt; decltype(V) &gt;::type &amp;&amp; &gt;( V ) \\\n: static_cast&lt; typename std::remove_reference&lt; decltype(V) &gt;::type &amp;&amp; &gt;   (  \\\n  static_cast&lt; typename std::remove_reference&lt; decltype(V) &gt;::type &gt;( V ) ) )\n</code></pre>\n<p>Hackish as macros are, I think that's the best alternative of the bunch. It's a bit dangerous because it returns an xvalue, so it shouldn't be used outside reference initialization.</p>\n<p>There must be something I haven't thought of\u2026 suggestions?</p>\n", "Tags": "<c++><coding-style><c++11><rvalue-reference>", "OwnerUserId": "153285", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_3895840_3896363_0": {"section_id": 6170, "quality": 0.875, "length": 14}}, "n3337": {"so_3895840_3896363_0": {"section_id": 5931, "quality": 0.875, "length": 14}}, "n4659": {"so_3895840_3896363_0": {"section_id": 7668, "quality": 0.875, "length": 14}}}});