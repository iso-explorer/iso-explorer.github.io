post_cb({"43680035": {"CommentCount": "7", "AcceptedAnswerId": "43680348", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2017-04-28T12:15:21.220", "LastActivityDate": "2017-04-28T12:55:34.010", "LastEditDate": "2017-04-28T12:18:56.290", "ViewCount": "1678", "FavoriteCount": "8", "Title": "Does the C++ standard guarantee that uniform initialization is exception-safe?", "Id": "43680035", "Score": "45", "Body": "<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct A\n{\n    A() { cout &lt;&lt; \"A\" &lt;&lt; endl; }\n    ~A() { cout &lt;&lt; \"~A\" &lt;&lt; endl; }\n};\n\nA Ok() { return {}; }\nA NotOk() { throw \"NotOk\"; }\n\nstruct B\n{\n    A a1;\n    A a2;\n};\n\nvoid f(B) {}\n\nint main()\n{\n    try\n    {\n        f({ Ok(), NotOk() });\n    }\n    catch (...)\n    {}\n}\n</code></pre>\n<p><code>vc++</code> and <code>clang</code> output:</p>\n<pre><code>A\n~A\n</code></pre>\n<p>While <code>gcc</code> outputs:</p>\n<pre><code>A\n</code></pre>\n<p>It seems a serious bug of GCC.</p>\n<p>For reference, see <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66139\" rel=\"noreferrer\">GCC bug 66139</a> and <a href=\"https://akrzemi1.wordpress.com/2017/04/27/a-serious-bug-in-gcc/\" rel=\"noreferrer\">\"A serious bug in GCC\" by Andrzej Krzemie\u0144ski</a>.</p>\n<p>I just wonder:</p>\n<p><strong>Does the C++ standard guarantee that uniform initialization is exception-safe?</strong></p>\n", "Tags": "<c++><exception><gcc><c++1z><uniform-initialization>", "OwnerUserId": "508343", "AnswerCount": "1"}, "43680348": {"ParentId": "43680035", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>It seems so:</p>\n<p>Curiously found in \u00a76.6/2 Jump Statements [stmt.jump] of all places (N4618):</p>\n<blockquote>\n<p id=\"so_43680035_43680348_0\">On exit from a scope (however accomplished), objects with automatic\n  storage duration (3.7.3) that have been constructed in that scope are\n  destroyed in the reverse order of their construction. [ Note: For\n  temporaries, see 12.2. \u2014end note ] Transfer out of a loop, out of a\n  block, or back past an initialized variable with automatic storage\n  duration involves the destruction of objects with automatic storage\n  duration that are in scope at the point transferred from but not at\n  the point transferred to. (See 6.7 for transfers into blocks). [ Note:\n  However, the program can be terminated (by calling <code>std::exit()</code> or\n  <code>std::abort()</code> (18.5), for example) without destroying class objects\n  with automatic storage duration. \u2014end note ]</p>\n</blockquote>\n<p>I think the emphasis here is on the \"(however accomplished)\" part. This includes an exception (but excludes things that cause a <code>std::terminate</code>). </p>\n<hr>\n<h3>EDIT</h3>\n<p>I think a better reference is \u00a715.2/3 Constructors and destructors [except.ctor] (<strong>emphasis</strong> mine):</p>\n<blockquote>\n<p id=\"so_43680035_43680348_1\">If the <strong>initialization</strong> or destruction of an object other than by\n  delegating constructor is terminated by an exception, <strong>the destructor\n  is invoked for each of the object\u2019s direct subobjects</strong> and, for a\n  complete object, virtual base class subobjects, whose initialization\n  has completed (8.6) and whose destructor has not yet begun execution,\n  except that in the case of destruction, the variant members of a\n  union-like class are not destroyed. The subobjects are destroyed in\n  the reverse order of the completion of their construction. Such\n  destruction is sequenced before entering a handler of the\n  <em>function-try-block</em> of the constructor or destructor, if any.</p>\n</blockquote>\n<p>This would include aggregate initialization (which I learned today can be called <em>non-vacuous initialization</em>)</p>\n<p>...and for objects with constructors we can cite \u00a712.6.2/12 [class.base.init](<strong>emphasis</strong> mine):</p>\n<blockquote>\n<p id=\"so_43680035_43680348_2\">In a non-delegating constructor, the destructor for each potentially\n  constructed subobject of class type is potentially invoked (12.4). [\n  Note: <strong>This provision ensures that destructors can be called for\n  fully-constructed subobjects in case an exception is thrown</strong> (15.2).\n  \u2014end note ]</p>\n</blockquote>\n</hr>", "OwnerUserId": "27678", "LastEditorUserId": "27678", "LastEditDate": "2017-04-28T12:55:34.010", "Id": "43680348", "Score": "29", "CreationDate": "2017-04-28T12:31:57.843", "LastActivityDate": "2017-04-28T12:55:34.010"}, "bq_ids": {"n4140": {"so_43680035_43680348_0": {"section_id": 3909, "quality": 0.8571428571428571, "length": 60}, "so_43680035_43680348_2": {"section_id": 437, "quality": 0.7777777777777778, "length": 21}}, "n3337": {"so_43680035_43680348_0": {"section_id": 3769, "quality": 0.8571428571428571, "length": 60}}, "n4659": {"so_43680035_43680348_1": {"section_id": 4110, "quality": 0.9814814814814815, "length": 53}, "so_43680035_43680348_0": {"section_id": 4795, "quality": 0.8571428571428571, "length": 60}, "so_43680035_43680348_2": {"section_id": 457, "quality": 0.7777777777777778, "length": 21}}}});