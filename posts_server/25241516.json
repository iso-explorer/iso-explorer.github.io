post_cb({"25242107": {"Id": "25242107", "PostTypeId": "2", "Body": "<h3>Short</h3>\n<p><em>The conversion function <code>operator int()</code> is selected by clang over <code>operator bool() const</code> since <code>b</code> is not const qualified, whereas the conversion operator for bool is.</em></p>\n<p>The short reasoning is that the candidate functions for overload resolution (with implicit object parameter in place), when converting <code>b</code> to <code>bool</code> are</p>\n<pre><code>operator bool (B2 const &amp;);\noperator int (B2 &amp;);\n</code></pre>\n<p>where the second one is a better match since <code>b</code> is not const qualified.</p>\n<p>If both functions share the same qualification (either both <code>const</code> or not), <code>operator bool</code> is selected since it provides direct conversion.</p>\n<h3>Conversion via cast-notation, analyzed step by step</h3>\n<p>If we agree that the boolean ostream inserter (std::basic_ostream::operator&lt;&lt;(bool val) as per [ostream.inserters.arithmetic]) is called with the value that results from a conversion of <code>b</code> to <code>bool</code> we can dig into that conversion.</p>\n<h3>1. The cast expression</h3>\n<p>The cast of b to bool</p>\n<pre><code>(bool)b\n</code></pre>\n<p>evaluates to </p>\n<pre><code>static_cast&lt;bool&gt;(b)\n</code></pre>\n<p>as per <em>C++11, 5.4/4 [expr.cast]</em> since <code>const_cast</code> is not applicable (not adding or removing const here).</p>\n<p>This static conversion is allowed per <em>C++11, 5.2.9/4 [expr.static.cast]</em>, if <code>bool t(b);</code> for an invented variable t is well formed.\nSuch statements are called direct-initialization as per <em>C++11, 8.5/15 [dcl.init]</em>.</p>\n<h3>2. Direct initialization <code>bool t(b);</code></h3>\n<p>Clause <em>16</em> of the least mentioned standard paragraph states (emphasis mine):</p>\n<blockquote>\n<p id=\"so_25241516_25242107_0\">The semantics of initializers are as follows. The destination type is the type of the object or reference being initialized and the source type is the type of the initializer expression.</p>\n<p id=\"so_25241516_25242107_1\">[...]</p>\n<p id=\"so_25241516_25242107_2\">[...] if the <strong>source type</strong> is a (possibly cv-qualified) <strong>class type, conversion functions</strong> are considered.</p>\n<p id=\"so_25241516_25242107_3\">The applicable conversion functions are enumerated, and the best one is chosen through overload resolution.</p>\n</blockquote>\n<h3>2.1 Which conversion functions are available?</h3>\n<p>The available conversion functions are <code>operator int ()</code> and <code>operator bool() const</code> since as <em>C++11, 12.3/5 [class.conv]</em> tells us:</p>\n<blockquote>\n<p id=\"so_25241516_25242107_4\">A conversion function in a derived class does not hide a conversion function in a base class unless the two functions convert to the same type.</p>\n</blockquote>\n<p>While <em>C++11, 13.3.1.5/1 [over.match.conv]</em> states:</p>\n<blockquote>\n<p id=\"so_25241516_25242107_5\">The conversion functions of S and its base classes are considered.</p>\n</blockquote>\n<p>where S is the class that will be converted from.</p>\n<h3>2.2 Which conversion functions are applicable?</h3>\n<p><em>C++11, 13.3.1.5/1 [over.match.conv]</em> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_25241516_25242107_6\"><em>1</em> [...] Assuming that \u201ccv1 T\u201d is the type of the object being initialized, and \u201ccv S\u201d is the type of the initializer expression, with S a class type, the candidate functions are selected as follows:\n  The conversion functions of S and its base classes are considered. Those non-explicit conversion functions that are not hidden within S and yield type T <strong>or a type that can be converted to type T via a standard conversion sequence</strong> are candidate functions.</p>\n</blockquote>\n<p>Therefore <code>operator bool () const</code> is applicable since it is not hidden within <code>B2</code> and yields a <code>bool</code>.</p>\n<p>The part with emphasis in the last standard quote is relevant for the conversion using <code>operator int ()</code> since <code>int</code> is a type that can be converted to bool via standard conversion sequence.\nThe conversion from <code>int</code> to <code>bool</code> is not even a sequence but a plain direct conversion which is allowed per <em>C++11, 4.12/1 [conv.bool]</em></p>\n<blockquote>\n<p id=\"so_25241516_25242107_7\">A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a prvalue of type bool. A zero value, null pointer value, or null member pointer value is converted to false; any other value is converted to true.</p>\n</blockquote>\n<p>This means that <code>operator int ()</code> is applicable as well.</p>\n<h3>2.3 Which conversion function is selected?</h3>\n<p>The selection of the appropriate conversion function is performed via overload resolution (<em>C++11, 13.3.1.5/1 [over.match.conv]</em>):</p>\n<blockquote>\n<p id=\"so_25241516_25242107_8\">Overload resolution is used to select the conversion function to be invoked.</p>\n</blockquote>\n<p>There is one special \"quirk\" when it comes to overload resolution for class member functions: the implicit object parameter\".</p>\n<p>Per <em>C++11, 13.3.1 [over.match.funcs]</em>, </p>\n<blockquote>\n<p id=\"so_25241516_25242107_9\">[...]both static and non-static member functions have an implicit object parameter[...]</p>\n</blockquote>\n<p>where the type of this parameter for non-static member functions -according to clause 4- is:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_25241516_25242107_10\">\u201clvalue reference to cv X\u201d for functions declared without a ref-qualifier or with the &amp; ref-qualifier</p></li>\n<li><p id=\"so_25241516_25242107_11\">\u201crvalue reference to cv X\u201d for functions declared with the &amp;&amp; ref-qualifier</p></li>\n</ul>\n<p id=\"so_25241516_25242107_12\">where X is the class of which the function is a member and <strong>cv is the cv-qualification on the member function declaration.</strong></p>\n</blockquote>\n<p>This means that (per <em>C++11, 13.3.1.5/2 [over.match.conv]</em>), in an initialization by conversion function,</p>\n<blockquote>\n<p id=\"so_25241516_25242107_13\">[t]he argument list has one argument, which is the initializer expression. [ Note: This argument will be compared against the implicit object parameter of the conversion functions. \u2014end note ]</p>\n</blockquote>\n<p>The candidate functions for overload resolution are:</p>\n<pre><code>operator bool (B2 const &amp;);\noperator int (B2 &amp;);\n</code></pre>\n<p>Obviously, <code>operator int ()</code> is a better match if a conversion is requested using a non-constant object of type <code>B2</code> since <code>operator bool ()</code> required a qualification conversion.</p>\n<p>If both conversion functions share the same const qualification, overload resolution of those function won't do the trick anymore.\nIn this case, conversion (sequence) ranking comes into place.</p>\n<h3>3. Why is <code>operator bool ()</code> selected when both conversion function share the same const qualification?</h3>\n<p>The conversion from <code>B2</code> to <code>bool</code> is an user-defined conversion sequence (<em>C++11, 13.3.3.1.2/1 [over.ics.user]</em>)</p>\n<blockquote>\n<p id=\"so_25241516_25242107_14\">A user-defined conversion sequence consists of an initial standard conversion sequence followed by a userdefined conversion followed by a second standard conversion sequence.</p>\n<p id=\"so_25241516_25242107_15\">[...] If the user-defined conversion is specified by a conversion function, the initial standard conversion sequence converts the source type to the implicit object parameter of the conversion function.</p>\n</blockquote>\n<p><em>C++11, 13.3.3.2/3 [over.ics.rank]</em> </p>\n<blockquote>\n<p id=\"so_25241516_25242107_16\">[...] defines a partial ordering of implicit conversion sequences based on the relationships better conversion sequence and better conversion.</p>\n<p id=\"so_25241516_25242107_17\">[...] User-defined conversion sequence U1 is a better conversion sequence than another user-defined conversion sequence U2 if they contain the same user-defined conversion function or constructor or aggregate initialization and the second standard conversion sequence of U1 is better than the second standard conversion sequence of U2.</p>\n</blockquote>\n<p>The second standard conversion is case of <code>operator bool()</code> is <code>bool</code> to <code>bool</code> (identity conversion) whereas the second standard conversion in case of <code>operator int ()</code> is <code>int</code> to <code>bool</code> which is a boolean conversion.</p>\n<p>Therefore, the conversion sequence, using <code>operator bool ()</code>, is better if both conversion function share the same const qualification.</p>\n", "LastEditorUserId": "951423", "LastActivityDate": "2014-12-23T23:44:28.543", "Score": "9", "CreationDate": "2014-08-11T11:23:58.220", "ParentId": "25241516", "CommentCount": "0", "LastEditDate": "2014-12-23T23:44:28.543", "OwnerUserId": "951423"}, "25242022": {"Id": "25242022", "PostTypeId": "2", "Body": "<p>The standard states:</p>\n<blockquote>\n<p id=\"so_25241516_25242022_0\">A conversion function in a derived class does not hide a conversion function in a base class unless the two functions convert to the same type.</p>\n<p id=\"so_25241516_25242022_1\">\u00a712.3 [class.conv]</p>\n</blockquote>\n<p>Which means that <code>operator bool</code> is not hidden by <code>operator int</code>.</p>\n<p>The standard states:</p>\n<blockquote>\n<p id=\"so_25241516_25242022_2\">During overload resolution, the implied object argument is indistinguishable from other arguments.</p>\n<p id=\"so_25241516_25242022_3\">\u00a713.3.3.1 [over.match.funcs]</p>\n</blockquote>\n<p>The \"implied object argument\" in this case is <code>b</code>, which is of type <code>B2 &amp;</code>.  <code>operator bool</code> requires <code>const B2 &amp;</code>, so the compiler will have to add const to <code>b</code> to call <code>operator bool</code>.  This -- all other things being equal -- makes <code>operator int</code> a better match.</p>\n<p>The standard states that a <code>static_cast</code> (which the C-style cast is performing in this instance) can convert to a type <code>T</code> (in this case <code>int</code>) if:</p>\n<blockquote>\n<p id=\"so_25241516_25242022_4\">the declaration <code>T t(e);</code> is well-formed, for some invented temporary variable <code>t</code>.</p>\n<p id=\"so_25241516_25242022_5\">\u00a75.2.9 [expr.static.cast]</p>\n</blockquote>\n<p>Therefore the <code>int</code> may be converted to a <code>bool</code>, and a <code>bool</code> may equally be converted to a <code>bool</code>.</p>\n<p>The standard states:</p>\n<blockquote>\n<p id=\"so_25241516_25242022_6\">The conversion functions of <code>S</code> and its base classes are considered. Those non-explicit conversion functions that are not hidden within <code>S</code> and yield type <code>T</code> <strong>or a type that can be converted to type <code>T</code> via a standard conversion sequence</strong> are candidate functions.</p>\n<p id=\"so_25241516_25242022_7\">\u00a713.3.1.5 [over.match.conv]</p>\n</blockquote>\n<p>So the overload set consists of <code>operator int</code> and <code>operator bool</code>.  All other things being equal, <code>operator int</code> is a better match (since you don't have to add constness).  Therefore <code>operator int</code> should be selected.</p>\n<p>Note that (perhaps against intuition) the standard does not consider the return type (i.e. the type to which these operators convert) once they have been added to the overload set (as established above), provided the conversion sequence for the arguments of one of them is superior to the conversion sequence for the arguments of the other (which, due to constness, is the case in this instance).</p>\n<p>The standard states:</p>\n<blockquote>\n<p id=\"so_25241516_25242022_8\">Given these definitions, a viable function F1 is defined to be a better function than another viable function F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</p>\n<ul>\n<li>for some argument j, ICSj(F1) is a better conversion sequence than ICSj(F2), or, if not that,</li>\n<li>the context is an initialization by user-defined conversion and the standard conversion sequence from the return type of F1 to the destination type (i.e., the type of the entity being initialized) is a better conversion sequence than the standard conversion sequence from the return type of F2 to the destination type.</li>\n</ul>\n<p id=\"so_25241516_25242022_9\">\u00a713.3.3 [over.match.best]</p>\n</blockquote>\n<p>In this case, there is only one argument (the implicit <code>this</code> parameter).  The conversion sequence for <code>B2 &amp;</code> =&gt; <code>B2 &amp;</code> (to call <code>operator int</code>) is superior to <code>B2 &amp;</code> =&gt; <code>const B2 &amp;</code> (to call <code>operator bool</code>), and therefore <code>operator int</code> is selected from the overload set without regard to the fact that it actually doesn't convert directly to <code>bool</code>.</p>\n", "LastEditorUserId": "1007504", "LastActivityDate": "2014-08-11T12:34:42.617", "Score": "51", "CreationDate": "2014-08-11T11:19:59.447", "ParentId": "25241516", "CommentCount": "11", "LastEditDate": "2014-08-11T12:34:42.617", "OwnerUserId": "1007504"}, "25241516": {"ViewCount": "2384", "Body": "<p>Consider the following short C++ program:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass B {\npublic:\n    operator bool() const {\n        return false;\n    }\n};\n\nclass B2 : public B {\npublic:\n    operator int() {\n        return 5;\n    }\n};\n\nint main() {\n    B2 b;\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; (bool)b &lt;&lt; std::endl;\n}\n</code></pre>\n<p>If I compile it on different compilers, I get various results. With Clang 3.4 and GCC 4.4.7 it prints <code>true</code>, while Visual Studio 2013 prints <code>false</code>, which means that they call different cast operators at <code>(bool)b</code>. Which is the correct behavior according to the standard?</p>\n<p>In my understanding <code>operator bool()</code> needs no conversion, while <code>operator int()</code> would require an <code>int</code> to <code>bool</code> conversion, so the compiler should choose the first one. Does <code>const</code> do something with that, is const-conversion considered more \"expensive\" by the compiler?</p>\n<p>If I remove the <code>const</code>, all compilers equally produce <code>false</code> as output.\nOn the other hand, if I combine the two classes together (both operators will be in the same class) all three compilers will produce <code>true</code> output.</p>\n", "AcceptedAnswerId": "25242022", "Title": "Different cast operator called by different compilers", "CreationDate": "2014-08-11T10:52:02.113", "Id": "25241516", "CommentCount": "7", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2014-08-11T11:46:04.473", "LastEditorUserId": "377393", "LastActivityDate": "2014-12-23T23:44:28.543", "Score": "79", "OwnerUserId": "509303", "Tags": "<c++><language-lawyer>", "AnswerCount": "4"}, "25290753": {"Id": "25290753", "PostTypeId": "2", "Body": "<p>Some of the previous answers, already provide a lot of info.</p>\n<p>My contribution is, \"cast operations\" are compiled similar, to \"overloaded operations\", I suggest to make a function with a unique identifier for each operation, and later, replace it by the required operator or cast.</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass B {\npublic:\n    bool ToBool() const {\n        return false;\n    }\n};\n\nclass B2 : public B {\npublic:\n    int ToInt() {\n        return 5;\n    }\n};\n\nint main() {\n    B2 b;\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; b.ToBool() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>And, later, apply the operator or cast.</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass B {\npublic:\n    operator bool() {\n        return false;\n    }\n};\n\nclass B2 : public B {\npublic:\n    operator int() {\n        return 5;\n    }\n};\n\nint main() {\n    B2 b;\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; (bool)b &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Just my 2 cents.</p>\n", "LastActivityDate": "2014-08-13T15:53:24.453", "Score": "0", "CreationDate": "2014-08-13T15:53:24.453", "ParentId": "25241516", "CommentCount": "0", "OwnerUserId": "535724"}, "bq_ids": {"n4140": {"so_25241516_25242107_7": {"length": 28, "quality": 1.0, "section_id": 44}, "so_25241516_25242107_6": {"length": 36, "quality": 0.9473684210526315, "section_id": 595}, "so_25241516_25242107_8": {"length": 6, "quality": 1.0, "section_id": 595}, "so_25241516_25242107_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 593}, "so_25241516_25242107_16": {"length": 13, "quality": 1.0, "section_id": 637}, "so_25241516_25242107_10": {"length": 6, "quality": 1.0, "section_id": 568}, "so_25241516_25242022_0": {"length": 15, "quality": 1.0, "section_id": 387}, "so_25241516_25242022_6": {"length": 22, "quality": 0.9565217391304348, "section_id": 595}, "so_25241516_25242107_14": {"length": 14, "quality": 1.0, "section_id": 620}, "so_25241516_25242107_4": {"length": 15, "quality": 1.0, "section_id": 387}, "so_25241516_25242107_12": {"length": 8, "quality": 1.0, "section_id": 568}, "so_25241516_25242107_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 3296}, "so_25241516_25242107_15": {"length": 16, "quality": 1.0, "section_id": 620}, "so_25241516_25242107_11": {"length": 5, "quality": 1.0, "section_id": 568}, "so_25241516_25242022_4": {"length": 6, "quality": 1.0, "section_id": 2}, "so_25241516_25242107_13": {"length": 15, "quality": 0.7894736842105263, "section_id": 594}, "so_25241516_25242107_9": {"length": 9, "quality": 1.0, "section_id": 566}, "so_25241516_25242022_8": {"length": 18, "quality": 0.9, "section_id": 603}, "so_25241516_25242107_17": {"length": 28, "quality": 1.0, "section_id": 639}, "so_25241516_25242107_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 3296}, "so_25241516_25242022_2": {"length": 9, "quality": 1.0, "section_id": 569}, "so_25241516_25242107_2": {"length": 8, "quality": 1.0, "section_id": 3296}}, "n3337": {"so_25241516_25242107_7": {"length": 28, "quality": 1.0, "section_id": 41}, "so_25241516_25242107_8": {"length": 6, "quality": 1.0, "section_id": 585}, "so_25241516_25242107_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 583}, "so_25241516_25242107_16": {"length": 13, "quality": 1.0, "section_id": 627}, "so_25241516_25242107_10": {"length": 6, "quality": 1.0, "section_id": 559}, "so_25241516_25242107_9": {"length": 9, "quality": 1.0, "section_id": 557}, "so_25241516_25242022_8": {"length": 18, "quality": 0.9, "section_id": 593}, "so_25241516_25242022_0": {"length": 15, "quality": 1.0, "section_id": 378}, "so_25241516_25242022_6": {"length": 22, "quality": 0.9565217391304348, "section_id": 585}, "so_25241516_25242107_14": {"length": 14, "quality": 1.0, "section_id": 610}, "so_25241516_25242107_4": {"length": 15, "quality": 1.0, "section_id": 378}, "so_25241516_25242107_11": {"length": 5, "quality": 1.0, "section_id": 559}, "so_25241516_25242107_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 3166}, "so_25241516_25242107_15": {"length": 16, "quality": 1.0, "section_id": 610}, "so_25241516_25242107_12": {"length": 8, "quality": 1.0, "section_id": 559}, "so_25241516_25242022_4": {"length": 6, "quality": 1.0, "section_id": 2}, "so_25241516_25242107_13": {"length": 15, "quality": 0.7894736842105263, "section_id": 584}, "so_25241516_25242107_2": {"length": 8, "quality": 1.0, "section_id": 3166}, "so_25241516_25242107_6": {"length": 36, "quality": 0.9473684210526315, "section_id": 585}, "so_25241516_25242107_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 3166}, "so_25241516_25242022_2": {"length": 9, "quality": 1.0, "section_id": 560}, "so_25241516_25242107_17": {"length": 28, "quality": 1.0, "section_id": 629}}, "n4659": {"so_25241516_25242107_7": {"length": 28, "quality": 1.0, "section_id": 45}, "so_25241516_25242107_8": {"length": 6, "quality": 1.0, "section_id": 618}, "so_25241516_25242107_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 616}, "so_25241516_25242107_16": {"length": 13, "quality": 1.0, "section_id": 665}, "so_25241516_25242107_10": {"length": 6, "quality": 1.0, "section_id": 591}, "so_25241516_25242022_8": {"length": 18, "quality": 0.9, "section_id": 629}, "so_25241516_25242022_0": {"length": 15, "quality": 1.0, "section_id": 404}, "so_25241516_25242022_6": {"length": 22, "quality": 0.9565217391304348, "section_id": 618}, "so_25241516_25242107_14": {"length": 14, "quality": 1.0, "section_id": 646}, "so_25241516_25242107_4": {"length": 15, "quality": 1.0, "section_id": 404}, "so_25241516_25242107_11": {"length": 5, "quality": 1.0, "section_id": 591}, "so_25241516_25242107_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 4058}, "so_25241516_25242107_15": {"length": 16, "quality": 1.0, "section_id": 646}, "so_25241516_25242107_12": {"length": 8, "quality": 1.0, "section_id": 591}, "so_25241516_25242022_4": {"length": 6, "quality": 1.0, "section_id": 2}, "so_25241516_25242107_13": {"length": 15, "quality": 0.7894736842105263, "section_id": 617}, "so_25241516_25242022_2": {"length": 9, "quality": 1.0, "section_id": 592}, "so_25241516_25242107_6": {"length": 37, "quality": 0.9736842105263158, "section_id": 618}, "so_25241516_25242107_17": {"length": 28, "quality": 1.0, "section_id": 667}, "so_25241516_25242107_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 4058}, "so_25241516_25242107_9": {"length": 9, "quality": 1.0, "section_id": 589}, "so_25241516_25242107_2": {"length": 8, "quality": 1.0, "section_id": 4058}}}, "25241814": {"Id": "25241814", "PostTypeId": "2", "Body": "<p>The C++ bool type has two values - true and false with corresponding values 1 and 0. The inherent confusion can be avoided if you add a bool operator in B2 class that calls base class(B)'s bool operator explicitly, then the output comes as false.\nHere's my modified program. Then operator bool means operator bool and not operator int by any means.</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass B {\npublic:\n    operator bool() const {\n        return false;\n    }\n};\n\nclass B2 : public B {\npublic:\n    operator int() {\n        return 5;\n    }\n    operator bool() {\n        return B::operator bool();\n    }\n};\n\nint main() {\n    B2 b;\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; (bool)b &lt;&lt; std::endl;\n}\n</code></pre>\n<p>In your example, (bool) b was trying to call the bool operator for B2, B2 has inherited bool operator, and int operator, by dominance rule, int operator gets called and the inherited bool operator in B2. However, by explicitly having a bool operator in B2 class itself, the problem gets solved.</p>\n", "LastActivityDate": "2014-08-11T11:08:27.520", "Score": "1", "CreationDate": "2014-08-11T11:08:27.520", "ParentId": "25241516", "CommentCount": "6", "OwnerUserId": "2032021"}});