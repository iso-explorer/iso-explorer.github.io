post_cb({"bq_ids": {"n4140": {"so_32338988_32339430_3": {"length": 11, "quality": 1.0, "section_id": 639}, "so_32338988_32339430_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 639}, "so_32338988_32339430_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 603}}, "n3337": {"so_32338988_32339430_3": {"length": 11, "quality": 1.0, "section_id": 629}, "so_32338988_32339430_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 629}, "so_32338988_32339430_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 593}}, "n4659": {"so_32338988_32339430_3": {"length": 11, "quality": 1.0, "section_id": 667}, "so_32338988_32339430_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 667}, "so_32338988_32339430_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 629}}}, "32338988": {"ViewCount": "208", "Body": "<p>I am asking this question with reference to the following code</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\n    void foo(){}\n};\n\ntemplate &lt;typename T&gt;\nvoid func(T (&amp;a) [1]) {cout &lt;&lt; \"In array type\" &lt;&lt; endl;}\ntemplate &lt;typename T&gt;\nvoid func(T (*a) [1]) {cout &lt;&lt; \"In pointer to array type \" &lt;&lt; endl;}\ntemplate &lt;typename T&gt;\nvoid func(T* a) {cout &lt;&lt; \"in pointer type\" &lt;&lt; endl;}\ntemplate &lt;typename T&gt;\nvoid func(T** a) {cout &lt;&lt; \"In pointer pointer type\" &lt;&lt; endl;}\ntemplate &lt;typename T&gt;\nvoid func(...) {}\n\nint foo(int a) {return 1;}\nint foo1() {return 1;}\n\nint main() {\n    A a[1];\n    func&lt;A&gt;(&amp;a);    \n\n    return 0;\n}\n</code></pre>\n<p>What is the type of an array? From the following code I can tell that when you take the address of an array with the <code>&amp;</code> operator the function call resolves to the one with <code>T (*a) [1]</code> and the call is not ambiguous, but the when I change the code to the following</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\n    void foo(){}\n};\n\ntemplate &lt;typename T&gt;\nvoid func(T (&amp;a) [1]) {cout &lt;&lt; \"In array type\" &lt;&lt; endl;}\ntemplate &lt;typename T&gt;\nvoid func(T (*a) [1]) {cout &lt;&lt; \"In pointer to array type \" &lt;&lt; endl;}\ntemplate &lt;typename T&gt;\nvoid func(T* a) {cout &lt;&lt; \"in pointer type\" &lt;&lt; endl;}\ntemplate &lt;typename T&gt;\nvoid func(T** a) {cout &lt;&lt; \"In pointer pointer type\" &lt;&lt; endl;}\ntemplate &lt;typename T&gt;\nvoid func(...) {}\n\nint foo(int a) {return 1;}\nint foo1() {return 1;}\n\nint main() {\n    A a[1];\n    func&lt;A&gt;(a);  // &lt;-- CHANGE HERE  \n\n    return 0;\n}\n</code></pre>\n<p>I get an error, saying that the call to the function is ambiguous. So the imaginary <code>type_of(a)</code> and <code>T*</code> are equivalent. How then are the types of <code>&amp;a</code> and <code>T**</code> not equivalent?</p>\n<p>The way I am trying to explain this to myself is that the type of an array to objects is <code>T (&amp;) [N]</code> and the type of an array of objects of type <code>T</code> is <code>T (*) [N]</code>. And that the standard allows implicit conversion from the first (i.e. from <code>T (&amp;a) [N]</code> to <code>T*</code>) but when you take the address of an array it does not implicitly go from a <code>T (*) [N]</code> to a <code>T**</code>. Am I correct? Or am I inferring what <code>T (*) [N]</code> is wrongly? </p>\n<p>Further how do you go about reading the meaning of syntax like this. Is there a document I can refer to?</p>\n<p>Thanks!</p>\n", "AcceptedAnswerId": "32339430", "Title": "What type is an array?", "CreationDate": "2015-09-01T18:56:47.507", "Id": "32338988", "CommentCount": "4", "LastEditDate": "2015-09-01T19:26:26.063", "PostTypeId": "1", "OwnerDisplayName": "user4386938", "LastEditorUserId": "2069064", "LastActivityDate": "2015-09-01T19:26:26.063", "Score": "3", "Tags": "<c++><c++11><c++14>", "AnswerCount": "1"}, "32339430": {"Id": "32339430", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_32338988_32339430_0\">... the type of an array to objects is <code>T (&amp;) [N]</code> ...</p>\n</blockquote>\n<p>No. The type of an array is <code>T[N]</code>. The type of <code>a</code> is <code>A[1]</code>. What you are describing is a <em>reference</em> to an array, and your original example involves passing a <em>pointer</em> to an array, which has type <code>A(*)[1]</code>. The other rule you are running into is that an array can decay into a pointer. In other words, an object of type <code>T[N]</code> can be implicitly converted to an object of type <code>T*</code>. </p>\n<p>It's because of that implicit conversion that your second example fails. The relevant overloads are simply:</p>\n<pre><code>template &lt;typename T&gt; void func(T (&amp;)[1]); // (1)\ntemplate &lt;typename T&gt; void func(T* );      // (2)\n</code></pre>\n<p>Both overloads are viable. The first is an exact match, whereas the second involves an array-to-pointer conversion. But according to the table in [over.ics.rank], the way to determine which viable candidate is better involves selecting conversion sequences thusly:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_32338988_32339430_1\">Standard conversion sequence <code>S1</code> is a better conversion sequence than standard conversion sequence  <code>S2</code> if</p>\n<ul>\n<li><p id=\"so_32338988_32339430_2\"><code>S1</code> is a proper subsequence of <code>S2</code> (comparing the conversion sequences in the canonical form  defined by 13.3.3.1.1, <strong>excluding\n  any Lvalue Transformation</strong>; the identity conversion sequence is considered to be a subsequence of any non-identity conversion\n  sequence) or, if not that,</p></li>\n<li><p id=\"so_32338988_32339430_3\">the rank of <code>S1</code> is better than the rank of <code>S2</code>, or <code>S1</code> and <code>S2</code> have the same rank and are distinguishable by the rules in the paragraph below, or, if not that,</p></li>\n<li><p id=\"so_32338988_32339430_4\">[..]</p></li>\n</ul></li>\n</ul>\n</blockquote>\n<p>The array-to-pointer conversion is an lvalue transformation, so it's excluded from that bullet point. Thus, neither conversion sequence is considered better, so we have to move onto the other tiebreakers. Yet, both functions are templates, and neither is more specialized than the other. That's why it's ambiguous. </p>\n", "LastActivityDate": "2015-09-01T19:25:33.407", "CommentCount": "4", "CreationDate": "2015-09-01T19:25:33.407", "ParentId": "32338988", "Score": "6", "OwnerUserId": "2069064"}});