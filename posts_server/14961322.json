post_cb({"bq_ids": {"n4140": {"so_14961322_14961618_0": {"length": 53, "quality": 0.9464285714285714, "section_id": 43}, "so_14961322_14961618_1": {"length": 32, "quality": 0.9142857142857143, "section_id": 6038}}, "n3337": {"so_14961322_14961618_0": {"length": 53, "quality": 0.9464285714285714, "section_id": 40}, "so_14961322_14961618_1": {"length": 32, "quality": 0.9142857142857143, "section_id": 5806}}, "n4659": {"so_14961322_14961618_0": {"length": 53, "quality": 0.9464285714285714, "section_id": 43}, "so_14961322_14961618_1": {"length": 27, "quality": 0.7714285714285715, "section_id": 7537}}}, "14961618": {"Id": "14961618", "PostTypeId": "2", "Body": "<p>From the C++11 standard, section 4.11.2:</p>\n<blockquote>\n<p id=\"so_14961322_14961618_0\">A prvalue of type \u201cpointer to member of B of type cv T\u201d, where B is a class type, can be converted to a\n  prvalue of type \u201cpointer to member of D of type cv T\u201d, where D is a derived class (Clause 10) of B. If B is\n  an inaccessible (Clause 11), ambiguous (10.2), or virtual (10.1) base class of D, or a base class of a virtual\n  base class of D, a program that necessitates this conversion is ill-formed. The result of the conversion refers\n  to the same member as the pointer to member before the conversion took place, but it refers to the base\n  class member as if it were a member of the derived class.</p>\n</blockquote>\n<p>So yes, this should be safe.</p>\n<p>Edit: so if you actually meant <strong>downcasting:</strong> that's also legal, according to C++11 5.2.9.12:</p>\n<blockquote>\n<p id=\"so_14961322_14961618_1\">A prvalue of type \u201cpointer to member of D of type cv1 T\u201d can be converted to a prvalue of type \u201cpointer to\n  member of B\u201d of type cv2 T, where B is a base class (Clause 10) of D, if a valid standard conversion from\n  \u201cpointer to member of B of type T\u201d to \u201cpointer to member of D of type T\u201d exists (4.11), and cv2 is the same\n  cv-quali\ufb01cation as, or greater cv-quali\ufb01cation than, cv1.\n  69</p>\n</blockquote>\n", "LastEditorDisplayName": "user529758", "OwnerDisplayName": "user529758", "LastActivityDate": "2013-02-19T16:09:32.253", "Score": "4", "CreationDate": "2013-02-19T15:52:40.550", "ParentId": "14961322", "CommentCount": "6", "LastEditDate": "2013-02-19T16:09:32.253"}, "14961322": {"ViewCount": "385", "Body": "<p>I have base classes <code>Object</code> and an <code>Event</code></p>\n<pre><code>class Object\n{\n//...\n};\n\nclass Event\n{\n};\n</code></pre>\n<p>And a typedef for a function pointer</p>\n<pre><code>typedef void (Object::*PF) (Event*);\n</code></pre>\n<p>And an unrelated class which stores two pointers</p>\n<pre><code>class Dispatcher\n{\npublic:\n    Dispatcher (Object* obj, PF pf) : _obj (obj), _pf (pf)\n\n    void call (Event* event)\n    {\n        _obj-&gt;*pf (event);\n    }\n\n    Object* _obj;\n    PF _pf;\n};\n</code></pre>\n<p>I then have a concrete object and a concrete event</p>\n<pre><code>class ConcreteEvent : public Event\n{\n};\n\nclass ConcreteObject : public Object\n{\npublic:\n   void handle (ConcreteEvent* event)\n   {\n      // Do something specific for ConcreteEvent\n   }\n};\n</code></pre>\n<p>And then call it like this</p>\n<pre><code>ConcreteObject* obj = new ConcreteObject();\nDispatcher dispatcher (obj, static_cast&lt;PF&gt;(&amp;ConcreteObject::handle));\n\nConcreteEvent* event = new ConcreteEvent ();\ndispatcher.call (event);\n</code></pre>\n<p>I guarantee that the dispatcher will always be called with a correct event, i.e. I will not call a dispatcher and pass it <code>ConcreteEvent</code> when the function pointer it encapsulates in fact takes <code>SomeOtherConcreteEvent</code></p>\n<p>The question is: Is this guaranteed to work? Is certainly works fine in gcc 4.7 on both linux and mingw.</p>\n", "Title": "Is it safe to upcast a function pointer?", "CreationDate": "2013-02-19T15:38:16.100", "LastActivityDate": "2013-02-19T16:14:28.230", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-02-19T15:58:08.087", "OwnerDisplayName": "user1773602", "LastEditorUserId": "147192", "Id": "14961322", "Score": "3", "Tags": "<c++><member-function-pointers><upcasting>", "AnswerCount": "2"}, "14962123": {"Id": "14962123", "PostTypeId": "2", "Body": "<p>I would argue it is <em>not</em> safe, for two reasons.</p>\n<p>The first is that pointer to member functions can only be safely propagated <em>downward</em> (because you the <code>Derived</code> class necessarily has inherited the function from the base class whilst the reverse is not true).</p>\n<pre><code>class Base {\npublic:\n   void foo();\n}; // class Base\n\nclass Derived: public Base {\npublic:\n   void bar();\n};\n\nusing PBase = void (Base::*)();\nusing PDerived = void (Derived::*)();\n\nint main() {\n   PBase pb = &amp;Base::foo;\n   PDerived pd = &amp;Derived::bar;\n\n   pb = pd; // error: cannot convert 'PDerived {aka void (Derived::*)()}'\n            //                    to 'PBase {aka void (Base::*)()}' in assignment\n   pd = pb;\n}\n</code></pre>\n<p>(as seen <a href=\"http://liveworkspace.org/code/228cv0%241\" rel=\"nofollow\">here</a>)</p>\n<p>The second is that you cannot change the type of argument <em>just like that</em>. To illustrate the issue, use <code>ConcreteObject: public virtual Object</code> and you will see that it does not work as you hoped it would.</p>\n<hr>\n<p>Now, it does not mean that what you would like to do is impossible, merely that it'll require <em>a bit more</em>.</p>\n<p>Ideally, instead of using member functions, you would just <em>fix</em> the signature to take both an <code>Object</code> and an <code>Event</code>, and then let it deal with manual casts if necessary:</p>\n<pre><code>using Function = std::function&lt;void(Object*,Event*)&gt;;\n\nvoid handle(Object* o, Event* e) {\n    ConcreteObject* co = dynamic_cast&lt;ConcreteObject*&gt;(o);\n    ConcreteEvent* ce = dynamic_cast&lt;ConcreteEvent*&gt;(e);\n\n    if (co and ce) { co-&gt;handle(ce); }\n}\n</code></pre>\n<p>Or whatever casts/checks you are comfortable with.</p>\n<p><em>Note: using <code>std::function</code> for compatibility with lambdas/functors.</em></p>\n</hr>", "LastActivityDate": "2013-02-19T16:14:28.230", "CommentCount": "2", "CreationDate": "2013-02-19T16:14:28.230", "ParentId": "14961322", "Score": "1", "OwnerUserId": "147192"}});