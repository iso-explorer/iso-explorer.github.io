post_cb({"33027214": {"CommentCount": "0", "ViewCount": "126", "CreationDate": "2015-10-08T22:50:15.457", "LastActivityDate": "2015-10-08T22:58:38.333", "Title": "Pointer to function vs function as template non-type parameter", "AcceptedAnswerId": "33027310", "PostTypeId": "1", "Id": "33027214", "Score": "0", "Body": "<p>I am trying to understand what's going on in the following snippet:</p>\n<pre><code>// using FUN = void(*)(void);\nusing FUN = void(void);\n\ntemplate&lt;FUN fun&gt; struct Fun{};\n\nint main ()\n{\n    FUN fun;\n    Fun&lt;fun&gt;{};\n}\n</code></pre>\n<p>I can use <code>void(void)</code> as a function non-type parameter, everything is fine, the program compiles. However, changing the type to pointer to function, i.e. removing the comment in the first line and commenting the second line, results in the error</p>\n<blockquote>\n<p id=\"so_33027214_33027214_0\">(<strong>g++</strong>) error: the value of 'fun' is not usable in a constant expression </p>\n<p id=\"so_33027214_33027214_1\">(<strong>clang</strong>) error: non-type template argument of type 'FUN' (aka 'void (*)()')\n        is not a constant expression </p>\n</blockquote>\n<p>What exactly is going on? Isn't a function type actually the same as a pointer to function (i.e., implicitly convertible everywhere?) I understand that the pointer to function shouldn't work, since <code>FUN fun;</code> in <code>main</code> it's not a constant expression, but why does declaring <code>FUN</code> as <code>void(void);</code> make it work?</p>\n", "Tags": "<c++><templates><function-pointers>", "OwnerUserId": "3093378", "AnswerCount": "1"}, "33027310": {"ParentId": "33027214", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_33027214_33027310_0\">A non-type template-parameter of type \u201carray of <code>T</code>\u201d or \u201cfunction returning <code>T</code>\u201d is adjusted to be of type\n  \u201cpointer to <code>T</code>\u201d or \u201cpointer to function returning <code>T</code>\u201d, respectively.</p>\n</blockquote>\n<p>([temp.param]/8 in C++14)</p>\n<p>Therefore the template <code>Fun</code> is the same template regardless of whether <code>FUN</code> is declared to be a function or pointer to function type.</p>\n<p>But, this block declaration:</p>\n<pre><code>FUN fun;\n</code></pre>\n<p>has a different meaning depending on what <code>FUN</code> is. If <code>FUN</code> is a function, this is a block declaration of a function (which, if odr-used, must be defined somewhere else). Generally, you can use the name of a function as an argument to a template parameter of type pointer to function---no issues here. But if <code>FUN</code> is a function pointer, this creates an uninitialized function pointer. Since it's a non-<code>const</code> object, it cannot be used as a template argument, just as an <code>int</code> variable cannot be used as a template argument for an <code>int</code> template parameter but a <code>const int</code> variable can.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "33027310", "Score": "3", "CreationDate": "2015-10-08T22:58:38.333", "LastActivityDate": "2015-10-08T22:58:38.333"}, "bq_ids": {"n4140": {"so_33027214_33027310_0": {"section_id": 61, "quality": 1.0, "length": 13}}, "n3337": {"so_33027214_33027310_0": {"section_id": 56, "quality": 1.0, "length": 13}}, "n4659": {"so_33027214_33027310_0": {"section_id": 63, "quality": 0.6153846153846154, "length": 8}}}});