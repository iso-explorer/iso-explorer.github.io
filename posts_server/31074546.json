post_cb({"31074546": {"CreationDate": "2015-06-26T13:32:17.783", "ViewCount": "591", "Id": "31074546", "Score": "7", "Title": "VS2013 - static const already defined", "LastEditorUserId": "1537403", "CommentCount": "4", "Body": "<p>I have the following code (simplified), which compiles fine in gcc, but gives an error in VS:</p>\n<pre><code>// main.cpp\n#include \"test.h\"\nint main() {\n  return 0;\n}\n\n// test.h\n#pragma once\nclass Test {\n  static const int TEST = 3;\n};\n\n// test.cpp\n#include \"test.h\"\nconst int Test::TEST;\n</code></pre>\n<p>Error:</p>\n<pre><code>main.obj : error LNK2005: \"private: static int const Test::TEST\" (?TEST@Test@@0HB) already defined in test.obj\n</code></pre>\n<p>Is it a VS bug or is gcc incorrectly allowing me to define the static const member explicitly?</p>\n<p><strong>Update:</strong> found this in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">C++ Standard</a> (9.4.2.3):</p>\n<blockquote>\n<p id=\"so_31074546_31074546_0\">If a non-volatile const static data member is of integral or enumeration type, its declaration in the class\n  definition can specify a brace-or-equal-initializer in which every initializer-clause that is an assignment-expression is a constant expression (5.20). A static data member of literal type can be declared in the\n  class definition with the constexpr specifier; if so, its declaration shall specify a brace-or-equal-initializer\n  in which every initializer-clause that is an assignment-expression is a constant expression. [ Note: In both\n  these cases, the member may appear in constant expressions. \u2014 end note ] <em>The member shall still be defined\n  in a namespace scope if it is odr-used (3.2) in the program and the namespace scope definition shall not\n  contain an initializer.</em></p>\n</blockquote>\n<p><strong>Update #2:</strong> found a <a href=\"https://connect.microsoft.com/VisualStudio/feedbackdetail/view/933699/lnk2005-when-defining-static-const-member\" rel=\"nofollow\">bug report</a>, which claims that it is fixed in the <em>next major version</em>.</p>\n", "Tags": "<c++><visual-studio><visual-studio-2013>", "LastEditDate": "2015-06-26T14:02:42.343", "LastActivityDate": "2017-01-23T21:12:06.917", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "1537403"}, "bq_ids": {"n4140": {"so_31074546_31074546_0": {"length": 58, "quality": 0.9206349206349206, "section_id": 5908}}, "n3337": {"so_31074546_31074546_0": {"length": 58, "quality": 0.9206349206349206, "section_id": 5680}}}, "31547498": {"LastActivityDate": "2015-07-21T19:13:31.320", "CommentCount": "0", "Body": "<p>Exactly as you said it was a MSVC <a href=\"https://connect.microsoft.com/VisualStudio/feedbackdetail/view/933699/lnk2005-when-defining-static-const-member\" rel=\"nofollow noreferrer\">bug</a>.\nThe code compiles and runs perfectly in Visual Studio 2015 RC with default project options.</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/yFmaZ.png\"/></p>\n<p>The compiler thinks \"static const int TEST = 3;\" and \"const int Test::TEST;\" are two different definitions of the same variable. To fix this in your version you could try setting the static variable value in the .cpp file:</p>\n<pre><code>// test.h\n#pragma once\nclass Test {\n  static const int TEST;\n};\n\n// test.cpp\n#include \"test.h\"\nconst int Test::TEST = 3;\n</code></pre>\n", "CreationDate": "2015-07-21T19:02:33.887", "LastEditDate": "2015-07-21T19:13:31.320", "ParentId": "31074546", "Id": "31547498", "LastEditorUserId": "2565020", "PostTypeId": "2", "Score": "2", "OwnerUserId": "2565020"}, "41815700": {"CommentCount": "0", "Body": "<p>With <a href=\"https://msdn.microsoft.com/en-us/library/34h23df8(v=vs.71).aspx\" rel=\"nofollow noreferrer\">Microsoft Extensions to C and C++</a> enabled, compiler generates the out-of-class definition automatically. Some compiler versions are probably buggy and do this auto-definition even when you defined it manually (e.g. when writing portable code).</p>\n<p>You can either disable the extensions, or check for _MSC_EXTENSIONS macro. It's defined when the /Ze option is set. For example:</p>\n<pre><code>#ifndef _MSC_EXTENSIONS\n   const int MyClass::MyStaticMember;\n#endif\n</code></pre>\n", "CreationDate": "2017-01-23T21:12:06.917", "ParentId": "31074546", "Id": "41815700", "LastActivityDate": "2017-01-23T21:12:06.917", "PostTypeId": "2", "Score": "1", "OwnerUserId": "1809845"}});