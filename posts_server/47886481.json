post_cb({"bq_ids": {"n4140": {"so_47886481_47887190_1": {"length": 20, "quality": 1.0, "section_id": 5908}, "so_47886481_47887586_0": {"length": 27, "quality": 0.9, "section_id": 275}}, "n3337": {"so_47886481_47887190_1": {"length": 20, "quality": 1.0, "section_id": 5680}, "so_47886481_47887586_0": {"length": 21, "quality": 0.7, "section_id": 266}}, "n4659": {"so_47886481_47887190_1": {"length": 13, "quality": 0.65, "section_id": 7390}, "so_47886481_47887586_0": {"length": 28, "quality": 0.9333333333333333, "section_id": 282}}}, "47887586": {"Id": "47887586", "PostTypeId": "2", "Body": "<p>You stumbled upon a \"small\" issue due to explicitly specializing. If we refer to <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.expl.spec#13\" rel=\"nofollow noreferrer\">[temp.expl.spec]/13</a>:</p>\n<blockquote>\n<p id=\"so_47886481_47887586_0\">An explicit specialization of a static data member of a template or an\n  explicit specialization of a static data member template is a\n  definition if the declaration includes an initializer; otherwise, it\n  is a declaration. [\u2009Note: The definition of a static data member of a\n  template that requires default-initialization must use a\n  braced-init-list:</p>\n<pre><code>template&lt;&gt; X Q&lt;int&gt;::x;                         // declaration\ntemplate&lt;&gt; X Q&lt;int&gt;::x ();                      // error: declares a function\ntemplate&lt;&gt; X Q&lt;int&gt;::x { };                     // definition\n</code></pre>\n<p id=\"so_47886481_47887586_1\">\u2009\u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>Meaning that you <em>declare</em> <code>X&lt;1&gt;::x</code> to exist, but not define it. Hence it's undefined. </p>\n<p>What I find crazy, is that your compiler just accepts it. You can't declare <code>constexpr</code> variables without defining them, in general. This is quite odd.</p>\n", "LastActivityDate": "2017-12-19T12:57:18.623", "Score": "4", "CreationDate": "2017-12-19T12:57:18.623", "ParentId": "47886481", "CommentCount": "8", "OwnerUserId": "817643"}, "47887190": {"Id": "47887190", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_47886481_47887190_0\">Is it possible to define a data-member without [specializing] the whole template?</p>\n</blockquote>\n<p><code>static</code> data members of a class template <em>are</em> allowed to be explicitly specialized ([temp.expl.spec]), however if you wish to do this, you cannot already specify an initializer for the member within the class template (class.static.data). That is,</p>\n<p>if we replace <code>constexpr</code> with <code>const</code>, this code would be fine:</p>\n<pre><code>template&lt;int&gt;\nstruct X {\n    static const int x;\n};\n\ntemplate&lt;int I&gt;\nconst int X&lt;I&gt;::x = 0;\n\ntemplate&lt;&gt;\nconst int X&lt;1&gt;::x = 1;\n</code></pre>\n<p>But this code would <em>NOT</em> be fine:</p>\n<pre><code>template&lt;int&gt;\nstruct X {\n    static const int x = 0;\n};\n\ntemplate&lt;&gt;\nconst int X&lt;1&gt;::x = 1;\n</code></pre>\n<p>You can see the difference is where we initialize the variable for the primary template.</p>\n<p>Now, if we wish to replace <code>const</code> with <code>constexpr</code>, then we're <strong>required</strong> to provide an initializer (class.static.data):</p>\n<blockquote>\n<p id=\"so_47886481_47887190_1\">A <code>static</code> data member of literal type can be declared in the\n  class definition with the <code>constexpr</code> specifier; if so, its declaration shall specify a <em>brace-or-equal-initializer</em>\n  in which every <em>initializer-clause</em> that is an assignment-expression is a constant expression</p>\n</blockquote>\n<p>So we end up in this weird situation where we can specialize the <code>static</code> member, but not if it is <code>constexpr</code> because <code>constexpr</code> requires an initializer. IMHO this is a shortcoming of the standard.</p>\n<p>However, it doesn't appear that all modern compilers agree.</p>\n<p>gcc 8.0.0 compiles (but doesn't link) your code as-is (wrong), however if you add an initializer for the specialization it complains about duplicate initialization (right).</p>\n<p>clang 6.0.0 doesn't compile the code as-is (right), but when you add the initializer it works without a hitch (wrong, but this is probably what the standard should dictate)</p>\n<p>MSVC 19.00.23506 doesn't compile the code as-is (right), AND it doesn't compile the code when you add the initializer (complaining about redefinition) (right).</p>\n<p>In the end, it might just be easier to push the specialization into a helper Traits class:</p>\n<pre><code>template&lt;int&gt;\nstruct X_Traits{\n    static constexpr int value = 0;\n};\n\ntemplate&lt;&gt;\nstruct X_Traits&lt;1&gt;{\n    static constexpr int value = 1;\n};\n\ntemplate&lt;int I&gt;\nstruct X {\n    static constexpr int x=X_Traits&lt;I&gt;::value;\n    // ...\n};\n</code></pre>\n<hr>\n<p>In C++17 and beyond we can make use of <a href=\"http://en.cppreference.com/w/cpp/language/if#Constexpr_If\" rel=\"nofollow noreferrer\">constexpr if</a> to avoid needing to specialize our traits class:</p>\n<pre><code>template&lt;int I&gt;\nstruct X_Traits{\n    static constexpr int get_value(){\n        if constexpr(I==1){\n            return 1;\n        }else{\n            return 0;\n        }\n    }\n};\n\ntemplate&lt;int I&gt;\nstruct X {\n    static constexpr int x=X_Traits&lt;I&gt;::get_value();\n    // ...\n};\n\nint main(){\n    static_assert(X&lt;0&gt;::x == 0);\n    static_assert(X&lt;1&gt;::x == 1);\n}\n</code></pre>\n</hr>", "LastEditorUserId": "27678", "LastActivityDate": "2017-12-19T21:02:40.057", "Score": "3", "CreationDate": "2017-12-19T12:35:43.437", "ParentId": "47886481", "CommentCount": "5", "OwnerUserId": "27678", "LastEditDate": "2017-12-19T21:02:40.057"}, "47886481": {"ViewCount": "120", "Body": "<p>The following code gives an undefined reference linking error:</p>\n<pre><code>template&lt;int&gt;\nstruct X {\n    static constexpr int x = 0;\n};\n\ntemplate&lt;&gt;\nconstexpr int X&lt;1&gt;::x;\n\nint main() \n{   \n    return X&lt;1&gt;::x;\n}\n</code></pre>\n<p>But I don't know exactly why.</p>\n<p>Is it possible to define a data-member without to specialize the whole template?</p>\n<p>To be clear: this code compiles fine, but gives a linker error (undefined-reference).</p>\n", "AcceptedAnswerId": "47887190", "Title": "static constexpr template member gives undefined-reference when specialized", "CreationDate": "2017-12-19T11:56:20.813", "LastActivityDate": "2017-12-19T21:02:40.057", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-12-19T19:52:09.943", "LastEditorUserId": "7256341", "Id": "47886481", "Score": "4", "OwnerUserId": "3359751", "Tags": "<c++><templates><linker-errors><constexpr>", "AnswerCount": "3"}, "47886828": {"Id": "47886828", "PostTypeId": "2", "Body": "<p>like this.</p>\n<pre><code>template&lt;int i&gt;\nstruct X {\n    static constexpr int x = i==0?2:10;\n};\n\nint main() \n{   \n    return X&lt;1&gt;::x;\n}\n</code></pre>\n<p>notice that you do not need to define it outside of class.</p>\n", "LastActivityDate": "2017-12-19T12:15:52.793", "Score": "2", "CreationDate": "2017-12-19T12:15:52.793", "ParentId": "47886481", "CommentCount": "2", "OwnerUserId": "5980430"}});