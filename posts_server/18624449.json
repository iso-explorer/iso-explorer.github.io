post_cb({"18629436": {"Id": "18629436", "PostTypeId": "2", "Body": "<p>Actually, what you have written is not a strict aliasing violation.</p>\n<p>C++11 spec 3.10.10 says:</p>\n<blockquote>\n<p id=\"so_18624449_18629436_0\">If a program attempts to access the stored value of an object through a glvalue of other than one of the\n  following types the behavior is undefined</p>\n</blockquote>\n<p>So the thing that causes the undefined behavior is accessing the stored value, not just creating a pointer to it.  Your example does not violate anything.  It would need to do the next step:  float badValue = smem[0].  smem[0] gets the stored value from the shared buffer, creating an aliasing violation.</p>\n<p>Of course, you aren't about to just grab smem[0] before setting it.  You are going to write to it first.  Assigning to the same memory does not access the stored value, so no ailiasing  However, it IS illegal to write over the top of an object while it is still alive.  To prove that we are safe, we need object lifespans from 3.8.4:</p>\n<blockquote>\n<p id=\"so_18624449_18629436_1\">A program may end the lifetime of any object by reusing the storage which the object occupies or by\n  explicitly calling the destructor for an object of a class type with a non-trivial destructor. For an object\n  of a class type with a non-trivial destructor, the program is not required to call the destructor explicitly\n  before the storage which the object occupies is reused or released; ... [continues on regarding consequences of not calling destructors]</p>\n</blockquote>\n<p>You have a POD type, so trivial destructor, so you can simply declare verbally \"the int objects are all at the end of their lifespan, I'm using the space for floats.\"  You then reuse the space for floats, and no aliasing violation occurs.</p>\n", "LastActivityDate": "2013-09-05T06:41:52.330", "CommentCount": "11", "CreationDate": "2013-09-05T06:41:52.330", "ParentId": "18624449", "Score": "2", "OwnerUserId": "2728148"}, "bq_ids": {"n4140": {"so_18624449_18629436_1": {"length": 31, "quality": 0.8378378378378378, "section_id": 7192}, "so_18624449_18629436_0": {"length": 14, "quality": 1.0, "section_id": 7239}}, "n3337": {"so_18624449_18629436_1": {"length": 31, "quality": 0.8378378378378378, "section_id": 6936}, "so_18624449_18629436_0": {"length": 14, "quality": 1.0, "section_id": 6983}}, "n4659": {"so_18624449_18629436_1": {"length": 31, "quality": 0.8378378378378378, "section_id": 8701}, "so_18624449_18629436_0": {"length": 14, "quality": 1.0, "section_id": 8748}}}, "18624900": {"Id": "18624900", "PostTypeId": "2", "Body": "<p>If a union is used to hold the int and float variables, then you can by pass the strict aliasing. More about this is given in \n<a href=\"http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html\" rel=\"nofollow\">http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html</a></p>\n<p>Also see the following article.</p>\n<p><a href=\"http://blog.regehr.org/archives/959\" rel=\"nofollow\">http://blog.regehr.org/archives/959</a></p>\n<p>He gives a way to use unions to do this.</p>\n", "LastEditorUserId": "2741199", "LastActivityDate": "2013-09-05T00:34:04.520", "Score": "0", "CreationDate": "2013-09-04T22:32:36.587", "ParentId": "18624449", "CommentCount": "1", "OwnerUserId": "2741199", "LastEditDate": "2013-09-05T00:34:04.520"}, "18624449": {"ViewCount": "1156", "Body": "<p>I am struggling with implementing a shared memory buffer without breaking C99's strict aliasing rules.<br><br>\nSuppose I have some code that processes some data and needs to have some 'scratch' memory to operate. I could write it as something like:<br/></br></br></p>\n<pre><code>void foo(... some arguments here ...) {\n  int* scratchMem = new int[1000];   // Allocate.\n  // Do stuff...\n  delete[] scratchMem;  // Free.\n}\n</code></pre>\n<p>Then I have another function that does some other stuff that also needs a scratch buffer:</p>\n<pre><code>void bar(...arguments...) {\n  float* scratchMem = new float[1000];   // Allocate.\n  // Do other stuff...\n  delete[] scratchMem;  // Free.\n}\n</code></pre>\n<p>The problem is that foo() and bar() may be called many times during operation and having heap allocations all over the place may be quite bad in terms of performance and memory fragmentation. An obvious solution would be to allocate a common, shared memory buffer of proper size once and  then pass it into foo() and bar() as an argument, BYOB-style:<br/></p>\n<pre><code>void foo(void* scratchMem);\nvoid bar(void* scratchMem);\n\nint main() {\n  const int iAmBigEnough = 5000;\n  int* scratchMem = new int[iAmBigEnough];\n\n  foo(scratchMem);\n  bar(scratchMem);\n\n  delete[] scratchMem;\n  return 0;\n}\n\nvoid foo(void* scratchMem) {\n  int* smem = (int*)scratchMem;\n  // Dereferencing smem will break strict-aliasing rules!\n  // ...\n}\n\nvoid bar(void* scratchMem) {\n  float* smem = (float*)scratchMem;\n  // Dereferencing smem will break strict-aliasing rules!\n  // ...\n}\n</code></pre>\n<p><br>\nI guess I have two questions now:<br>\n- How can I implement a shared common scratch memory buffer that is not in violation of aliasing rules?<br>\n- Even though the above code does violate strict aliasing rules, there is no 'harm' being done with the alias. Therefore could any sane compiler generate (optimized) code that still gets me into trouble?</br></br></br></p>\n<p>Thanks</p>\n", "Title": "Shared memory buffers in C++ without violating strict aliasing rules", "CreationDate": "2013-09-04T21:55:17.600", "LastActivityDate": "2013-09-05T06:41:52.330", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "Id": "18624449", "Score": "5", "OwnerUserId": "1232524", "Tags": "<c++><memory><buffer><strict-aliasing><type-punning>", "AnswerCount": "3"}, "18624729": {"Id": "18624729", "PostTypeId": "2", "Body": "<p>It is always valid to interpret an object as a sequence of bytes (i.e. it is <em>not</em> an aliasing violation to treat any object pointer as the pointer to the first element of an array of chars), and you can construct an object in any piece of memory that's large enough and suitably aligned.</p>\n<p>So, you can allocate a large array of <code>char</code>s (any signedness), and locate an offset that's aliged at <code>alignof(maxalign_t)</code>; now you can interpret that pointer as an object pointer once you've constructed the appropriate object there (e.g. using placement-new in C++).</p>\n<p>You do of course have to make sure not to write into an existing object's memory; in fact, object lifetime is intimately tied to what happens to the memory which represents the object.</p>\n<p>Example:</p>\n<pre><code>char buf[50000];\n\nint main()\n{\n    uintptr_t n = reinterpret_cast&lt;uintptr_t&gt;(buf);\n    uintptr_t e = reinterpret_cast&lt;uintptr_t&gt;(buf + sizeof buf);\n\n    while (n % alignof(maxalign_t) != 0) { ++n; }\n\n    assert(e &gt; n + sizeof(T));\n\n    T * p = :: new (reinterpret_cast&lt;void*&gt;(n)) T(1, false, 'x');\n\n    // ...\n\n    p-&gt;~T();\n}\n</code></pre>\n<p>Note that memory obtained by <code>malloc</code> or <code>new char[N]</code> is <em>always</em> aligned for maximal alignment (but not more, and you may wish to use over-aligned addresses).</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2013-09-04T22:48:26.943", "Score": "1", "CreationDate": "2013-09-04T22:19:04.503", "ParentId": "18624449", "CommentCount": "10", "OwnerUserId": "596781", "LastEditDate": "2013-09-04T22:48:26.943"}});