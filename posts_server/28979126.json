post_cb({"bq_ids": {"n4140": {"so_28979126_29893260_0": {"length": 20, "quality": 0.8, "section_id": 6043}, "so_28979126_29893260_1": {"length": 40, "quality": 0.8888888888888888, "section_id": 6044}}, "n3337": {"so_28979126_29893260_0": {"length": 20, "quality": 0.8, "section_id": 5811}, "so_28979126_29893260_1": {"length": 40, "quality": 0.8888888888888888, "section_id": 5812}}, "n4659": {"so_28979126_29893260_0": {"length": 20, "quality": 0.8, "section_id": 7542}, "so_28979126_29893260_1": {"length": 40, "quality": 0.8888888888888888, "section_id": 7543}}}, "28979126": {"ViewCount": "152", "Body": "<p>According to <a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast\">http://en.cppreference.com/w/cpp/language/reinterpret_cast</a>, it is known that <code>reinterpret_cast</code> a pointer to an integral of sufficient size and back yield the same value. I'm wondering whether the converse is also true by the standards. That is, does <code>reinterpret_cast</code> an integral to a pointer type of sufficient size and back yield the same value?</p>\n", "AcceptedAnswerId": "29893260", "Title": "Does reinterpret_casting an integral to a pointer type and back yield the same value?", "CreationDate": "2015-03-11T05:21:00.873", "Id": "28979126", "CommentCount": "5", "LastEditDate": "2015-03-11T05:42:30.353", "PostTypeId": "1", "LastEditorUserId": "1348273", "LastActivityDate": "2015-04-27T10:32:25.503", "Score": "5", "OwnerUserId": "1348273", "Tags": "<c++><pointers><language-lawyer><integral><reinterpret-cast>", "AnswerCount": "2"}, "29476024": {"Id": "29476024", "PostTypeId": "2", "Body": "<p>I get exactly this problem in library exporting pointers to objects as opaque identifiers and now attempting to recover these pointers from external calls don't work for old x86 CPU's (in the time of windows 98). So, while we can expect that behaviour, this is false in general case. In 386-CPU the address is composed by overlapped pointers so the address of any memory position is not unique, and I found that conversion back don't recover original value.</p>\n", "LastActivityDate": "2015-04-06T17:15:29.870", "CommentCount": "0", "CreationDate": "2015-04-06T17:15:29.870", "ParentId": "28979126", "Score": "0", "OwnerUserId": "4575304"}, "29893260": {"Id": "29893260", "PostTypeId": "2", "Body": "<p>No, that is not guaranteed by the standard. Quoting all parts of C++14 (n4140) [expr.reinterpret.cast] which concern pointer\u2013integer conversions, emphasis mine:</p>\n<blockquote>\n<p id=\"so_28979126_29893260_0\">4 A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is\n  implementation-defined. [ <em>Note:</em> It is intended to be unsurprising to those who know the addressing structure\n  of the underlying machine. <em>\u2014end note</em> ] ...</p>\n<p id=\"so_28979126_29893260_1\">5 A value of integral type or enumeration type can be explicitly converted to a pointer. A pointer converted\n  to an integer of sufficient size (if any such exists on the implementation) and back to the same pointer type\n  will have its original value; <strong>mappings between pointers and integers are otherwise implementation-defined.</strong>\n  [ <em>Note:</em> Except as described in 3.7.4.3, the result of such a conversion will not be a safely-derived pointer\n  value. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>So starting with an integral value and converting it to a pointer and back (assuming no size issues) is implementation-defined. Which means you must consult your compiler's documentation to learn whether such a round trip preserves values or not. As such, it is certainly not portable.</p>\n", "LastActivityDate": "2015-04-27T10:32:25.503", "CommentCount": "0", "CreationDate": "2015-04-27T10:32:25.503", "ParentId": "28979126", "Score": "0", "OwnerUserId": "1782465"}});