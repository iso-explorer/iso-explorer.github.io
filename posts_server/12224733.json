post_cb({"12225051": {"ParentId": "12224733", "CommentCount": "1", "Body": "<p>I had a misunderstanding of syntax.<br>\nI was accustomed to initializing variables like this:</br></p>\n<pre><code>int i{0};\n</code></pre>\n<p>However, I need to initalize this type with parenthesis not brackets.<br>\nThank you Raymond</br></p>\n", "OwnerUserId": "908939", "PostTypeId": "2", "Id": "12225051", "Score": "0", "CreationDate": "2012-09-01T05:05:50.090", "LastActivityDate": "2012-09-01T05:05:50.090"}, "12224793": {"ParentId": "12224733", "CommentCount": "0", "Body": "<p>No, <code>auto</code> will not \"just deduce that Function is going to return an int\"; the way how the <em>auto</em> specifier works is well-defined in 7.1.6.4, and is as follows:</p>\n<blockquote>\n<p id=\"so_12224733_12224793_0\">(7.1.6.4/p6) Once the type of a <em>declarator-id</em> has been determined according to 8.3, the type of the declared variable\n  using the <em>declarator-id</em> is determined from the type of its initializer using the rules for template argument\n  deduction. Let <code>T</code> be the type that has been determined for a variable identifier <code>d</code>. Obtain <code>P</code> from <code>T</code> by\n  replacing the occurrences of <code>auto</code> with either a new invented type template parameter <code>U</code> or, if the initializer\n  is a <code>braced-init-list</code> (8.5.4), with <code>std::initializer_list&lt;U&gt;</code>. The type deduced for the variable <code>d</code> is then\n  the deduced <code>A</code> determined using the rules of template argument deduction from a function call (14.8.2.1),\n  where <code>P</code> is a function template parameter type and the initializer for <code>d</code> is the corresponding argument. If\n  the deduction fails, the declaration is ill-formed.</p>\n</blockquote>\n", "OwnerUserId": "463074", "PostTypeId": "2", "Id": "12224793", "Score": "2", "CreationDate": "2012-09-01T04:03:25.510", "LastActivityDate": "2012-09-01T04:03:25.510"}, "12224733": {"CommentCount": "10", "CreationDate": "2012-09-01T03:44:13.827", "PostTypeId": "1", "AcceptedAnswerId": "12232658", "LastEditorUserId": "1033581", "LastActivityDate": "2017-07-30T17:51:53.570", "LastEditDate": "2017-07-30T17:51:53.570", "ViewCount": "271", "FavoriteCount": "0", "Title": "Why can't I initialize a value using braces with auto and pass it into this function", "Id": "12224733", "Score": "1", "Body": "<p><strong>Why can't I initialize a value with auto and pass it into a function that expects a decltype as a parameter?</strong></p>\n<p>Let me set the scene, and show you a tiny program.</p>\n<hr>\n<p>Here is a function that returns a value.  </p>\n<pre><code>int Function(void);\n</code></pre>\n<p>In this case, it happens to be an integer, but the return type is subject to change.<br>\nThat is why this next function, is written as followed:  </br></p>\n<pre><code>void What_I_Take_Depends_On_Function(decltype(Function()) x);\n</code></pre>\n<p>If someone decides to change the return type of Function, then the deceleration of <em>this</em> function will not need to be changed.  Yes, the definition of the function may not handle the new type correctly, or if Function's return type is changed to void there will be an issue, but that is irrelevant to my problem.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n\nint Function(void){return 5;}\n\nvoid What_I_Take_Depends_On_Function(decltype(Function()) x){return;}\n\nint main(){\n\n    //assignments(Edit: these are initializations)\n    int  var1 = Function();\n    auto var2 = Function();\n\n    //initializations\n    int  var3 {Function()};\n    auto var4 {Function()};\n\n    What_I_Take_Depends_On_Function(var1); //works\n    What_I_Take_Depends_On_Function(var2); //works\n    What_I_Take_Depends_On_Function(var3); //works\n    What_I_Take_Depends_On_Function(var4); //COMPILER ERROR\n\n    //cannot convert \u2018std::initializer_list&lt;int&gt;\u2019 to \u2018int\u2019 for argument \u20181\u2019 to \u2018void What_I_Take_Depends_On_Function(int)\u2019\n\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>So why is var4 an initializer_list and not an int?<br>\nCan't auto just deduce that Function is going to return an int,<br>\nand then change the deceleration to that similar of var3?</br></br></p>\n</hr>", "Tags": "<c++><c++11><auto><initializer-list>", "OwnerUserId": "908939", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_12224733_12224793_0": {"section_id": 5451, "quality": 0.5882352941176471, "length": 40}}, "n3337": {"so_12224733_12224793_0": {"section_id": 5245, "quality": 0.9117647058823529, "length": 62}}, "n4659": {"so_12224733_12224793_0": {"section_id": 6889, "quality": 0.5147058823529411, "length": 35}}}, "12232658": {"ParentId": "12224733", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The brace-init-list <code>{...}</code> is the new uniform initialization syntax for C++11, and it can be used to initialise any automatic, static or member variable <em>if the type of that variable is known</em>. These are a few examples of valid C++11 initialization:</p>\n<pre><code>class S\n{\nprivate:\n  int _m;\npublic:\n  S(int m) : _m { m }  // &lt;== initialization of a member\n  {}\n};\n\n\nint main() {\n\n  constexpr unsigned i { 10 }; // &lt;== initialization of a constexpr\n\n  S s { i };  // &lt;== initialization by calling constructor\n\n  /* ... */\n}\n</code></pre>\n<p>In <strong>none of the above cases</strong> will a <code>std::initializer_list</code> be generated. The brace-init-list <code>{...}</code> simply means the compiler will try to identify a <strong>suitable constructor</strong> for the given data type, whose argument list matches the contents of the brace-init-list (\u00a78.5.4).</p>\n<p>There are <strong>two special cases:</strong></p>\n<ol>\n<li><p>If <strong>one of the constructors</strong> defined for the given data type <strong>takes a <code>std::initializer_list&lt;T&gt;</code> as argument</strong>, and the contents of the brace-init-list are all implicitly convertible to <code>T</code>. This is the case when you use one of the built-in container types, e.g.</p>\n<pre><code>std::vector&lt;int&gt; vec { 1, 2, 3 };\n</code></pre>\n<p><code>std::vector&lt;T&gt;</code> has a constructor <code>std::vector&lt;T&gt;(const std::initializer_list&lt;T&gt;)</code>, so the brace-init-list will be converted to a <code>std::initializer_list&lt;int&gt;</code> and as such copied  into the vector constructor. The constructor will iterate through the list and append the elements one by one.</p>\n<p>This is a bit of a trap when the list contains only one argument:</p>\n<pre><code>std::vector&lt;int&gt; vec { 10 };\n</code></pre>\n<p>Here, the same happens, so you will get a vector that contains the one element <code>10</code>. This is different from using old-style syntax:</p>\n<pre><code>std::vector&lt;int&gt; vec(10);\n</code></pre>\n<p>This calls the <code>std::vector&lt;int&gt;(const size_t)</code> constructor, i.e. it creates a vector of 10 default-initialised elements.</p></li>\n<li><p>If the type of the variable to be initialised is not pre-determined, i.e. <strong>when <code>auto</code> is used in the declaration:</strong></p>\n<pre><code>auto v { 1, 2, 3 };\n</code></pre>\n<p>In this case (\u00a77.1.6.4/6) the compiler cannot identify a suitable constructor, because <em>any</em> data type that takes three integer (or convertible-to-integer) arguments is a possible candidate. The rule here is that the compiler assumes <code>std::initializer_list&lt;int&gt;</code> as the data type for <code>v</code>. That is what happens in your case as well.</p></li>\n</ol>\n<p>In other words, using brace-init-lists is fine (and even encouraged) for initialization, but you can't readily combine it with <code>auto</code>. To solve you problem, you need to either declare the data type explicitly</p>\n<pre><code>int var4 { Function() };\n</code></pre>\n<p>or, to keep things flexible, use <code>decltype</code> here too:</p>\n<pre><code>decltype(Function()) var4 { Function() };\n</code></pre>\n<p>Alternatively, you can use old-style syntax:</p>\n<pre><code>auto v (Function());\n</code></pre>\n", "OwnerUserId": "777186", "LastEditorUserId": "777186", "LastEditDate": "2012-09-02T01:18:09.357", "Id": "12232658", "Score": "3", "CreationDate": "2012-09-02T01:06:09.003", "LastActivityDate": "2012-09-02T01:18:09.357"}});