post_cb({"4037283": {"ParentId": "4037219", "CommentCount": "0", "Body": "<p>According to ISO/IEC 14882:2003(E) section 12.6.2:</p>\n<blockquote>\n<p id=\"so_4037219_4037283_0\">Initialization shall proceed in the following order:</p>\n<ul>\n<li>First, and only for the constructor of the most derived class as described below, virtual base classes shall\n  be initialized in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph\n  of base classes, where \u201cleft-to-right\u201d is the order of appearance of the base class names in the derived\n  class base-specifier-list.</li>\n<li>Then, direct base classes shall be initialized in declaration order as they appear in the base-specifier-list\n  (regardless of the order of the mem-initializers).</li>\n<li>Then, nonstatic data members shall be initialized in the order they were declared in the class definition\n  (again regardless of the order of the mem-initializers).</li>\n<li>Finally, the body of the constructor is executed.</li>\n</ul>\n</blockquote>\n<p>So, follow that order, and you'll have your order. Also according to the standard, the order is prescribed as such so that objects can be uninitialized in the precisely reverse order.</p>\n", "OwnerUserId": "123827", "PostTypeId": "2", "Id": "4037283", "Score": "28", "CreationDate": "2010-10-27T20:14:45.583", "LastActivityDate": "2010-10-27T20:14:45.583"}, "4037219": {"CommentCount": "2", "AcceptedAnswerId": "4037283", "CreationDate": "2010-10-27T20:06:24.467", "LastActivityDate": "2010-10-27T20:42:43.423", "PostTypeId": "1", "ViewCount": "11804", "FavoriteCount": "6", "Title": "Order of execution in constructor initialization list", "Id": "4037219", "Score": "8", "Body": "<p>Is order of execution in constructor initialization list determinable? I know that members order in a class is the order in which those members will be initialized but if I have scenario like this:</p>\n<pre><code>class X()\n{\nX_Implementation* impl_;\n};  \n\nand then providing that allocator is available:\n\nX::X():impl_(Allocate(sizeof(X_Implementation)))//HERE I'M ALLOCATING &lt;--1\n,impl_(Construct&lt;X_Implementation&gt;(impl_))//AND HERE I'M CONSTRUCTING &lt;--2\n{\n}\n</code></pre>\n<p>but in order for this to be dependable this order MUST be from left to right. Is it guarantied by GREAT BOOK OF std:: or not? If not I can always move the second line into the body.</p>\n", "Tags": "<c++><order-of-evaluation>", "OwnerUserId": "207177", "AnswerCount": "3"}, "4037500": {"ParentId": "4037219", "CommentCount": "0", "Body": "<p>Your specific scenario is based on the idea of initializing the same member more than once. This is plain illegal in C++. Your code will not compile. So, the question you are asking doesn't really exist.</p>\n<p>The order of member initialization is the order of their declaration in class definition. In no-inheritance contexts that covers everything related to the order of initialization in the constructions initializer list.</p>\n", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "4037500", "Score": "4", "CreationDate": "2010-10-27T20:38:01.123", "LastActivityDate": "2010-10-27T20:38:01.123"}, "bq_ids": {"n4140": {"so_4037219_4037227_0": {"section_id": 438, "quality": 1.0, "length": 14}}, "n3337": {"so_4037219_4037227_0": {"section_id": 429, "quality": 1.0, "length": 14}}, "n4659": {"so_4037219_4037227_0": {"section_id": 458, "quality": 1.0, "length": 14}}}, "4037227": {"ParentId": "4037219", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The C++ standard does guarantee an order for initialization lists (ISO C++ Standard 12.6.2/5):</p>\n<blockquote>\n<p id=\"so_4037219_4037227_0\">...nonstatic data members shall be\n  initialized in the order they were\n  declared in the class definition\n  (again regardless of the order of the\n  mem-initializers).</p>\n</blockquote>\n<p>(See <a href=\"https://stackoverflow.com/questions/4037219/order-of-execution-in-constructor-initialization-list/4037283#4037283\">Wyatt Anderson's answer</a> for more information.)</p>\n<p>Example:</p>\n<pre><code>class Foo\n{\npublic:\n    Foo();\nprivate:\n    A a;\n    B b;\n    C c;\n};\n\nFoo::Foo() : b(), a(), c()\n{\n    // a is initialized first, then b, then c - NOT b, a, then c!\n}\n</code></pre>\n<p>However, you can't initialize a variable twice - what you have won't compile.</p>\n<pre><code>class X //() what's with the pair of parentheses you have in your code snippet?\n{ \npublic:\n    X();\nprivate:\n    X_Implementation* impl_; \n};   \n\nX::X() : \n    impl_(Allocate(sizeof(X_Implementation))),\n    // It is not allowed to initialize a data member twice!\n    impl_(Construct&lt;X_Implementation&gt;(impl_))\n{ \n} \n</code></pre>\n<p>Instead, just put the extra work into the constructor:</p>\n<pre><code>X::X() : impl_(Allocate(sizeof(X_Implementation)))\n{ \n    impl_ = Construct&lt;X_Implementation&gt;(impl_);\n}\n</code></pre>\n<hr>\n<p>There may be exception safety issues with the above code, but without knowing what <code>Allocate()</code> or <code>Construct()</code> actually does I'm not able to tell. I can tell you that it's best to separate allocation and construction into their own classes if you do that, using the <em>Resource Acquisition Is Initialization (RAII)</em> idiom:</p>\n<pre><code>class XBase\n{\nprotected:\n    XBase() : impl_(Allocate(sizeof(X_Implementation)))\n    {\n    }\n\n    ~XBase()\n    {\n        if(impl_ != 0) { Deallocate(impl_); } // Or something like this\n    }\n\n    X_Implementation* impl_; \n};\n\nclass X : private XBase // XBase is an implementation detail\n{\npublic:\n    X()\n    {\n        impl_ = Construct&lt;X_Implementation&gt;(impl_);\n    }\n\n    ~X()\n    {\n        Destruct&lt;X_Implementation&gt;(impl_); // Or something like this\n    }\n};\n</code></pre>\n<p>This way, if <code>Construct()</code> throws an exception, you won't leak memory since the base class destructor will be called which will deallocate the memory pointed by <code>impl_</code>. This is important because if the exception is not caught and leaves the constructor, its matching destructor <em>will not be called</em>. See Bjarne Stroustrup's paper on exception safety: <a href=\"http://www2.research.att.com/~bs/except.pdf\" rel=\"nofollow noreferrer\">http://www2.research.att.com/~bs/except.pdf</a></p>\n</hr>", "OwnerUserId": "308661", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:25:36.213", "Id": "4037227", "Score": "21", "CreationDate": "2010-10-27T20:07:48.797", "LastActivityDate": "2010-10-27T20:42:43.423"}});