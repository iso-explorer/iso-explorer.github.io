post_cb({"bq_ids": {"n4140": {"so_16234626_16234816_0": {"length": 106, "quality": 0.8833333333333333, "section_id": 6142}}, "n3337": {"so_16234626_16234816_0": {"length": 106, "quality": 0.8833333333333333, "section_id": 5906}}}, "16234816": {"CommentCount": "1", "Body": "<ol>\n<li>Yes, both are undefined behavior: in the first case, <code>array-1</code> is undefined; in the second case, <code>ptr</code> becomes undefined when it is decremented after the iteration when it is equal to <code>array</code>.</li>\n<li>This is covered by section 6.5.6 of the standard, part 8 (emphasis is mine):</li>\n</ol>\n<blockquote>\n<p id=\"so_16234626_16234816_0\">When an expression that has integer type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integer expression. In other words, if the expression <code>P</code> points to the i-th element of an array object, the expressions <code>(P)+N</code> (equivalently, <code>N+(P)</code>) and <code>(P)-N</code> (where <code>N</code> has the value <code>n</code>) point to, respectively, the <code>i+n</code>-th and <code>i\u2212n</code>-th elements of the array object, provided they exist. Moreover, if the expression <code>P</code> points to the last element of an array object, the expression <code>(P)+1</code> points one past the last element of the array object, and if the expression <code>Q</code> points one past the last element of an array object, the expression <code>(Q)-1</code> points to the last element of the array object. If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; <strong>otherwise, the behavior is undefined</strong>. If the result points one past the last element of the array object, it shall not be used as the operand of a unary <code>*</code> operator that is evaluated.</p>\n</blockquote>\n<p>The standard goes length to cover the element at the position one past the last element of the array object, while the element at the position one prior the first element falls under the \"otherwise\" clause of the above rule.</p>\n", "CreationDate": "2013-04-26T10:58:32.610", "ParentId": "16234626", "Id": "16234816", "LastActivityDate": "2013-04-26T10:58:32.610", "PostTypeId": "2", "Score": "13", "OwnerUserId": "335858"}, "16234626": {"FavoriteCount": "1", "ViewCount": "761", "Id": "16234626", "AcceptedAnswerId": "16234816", "Score": "8", "Title": "pointer comparisons \u201c>\u201d with one before the first element of an array object", "LastEditorUserId": "-1", "CommentCount": "1", "Body": "<p>According to this <a href=\"https://stackoverflow.com/questions/16233868/pointer-comparisons-with-one-past-the-last-element-of-an-array-object\">topic</a>, comparing pointer with <strong>one past the last element of an array</strong> object is allowed.</p>\n<p>And according to <strong><em>@jalf</em></strong> comment, comparing pointer with <strong>one before the first element of an array object</strong> is forbidden.</p>\n<p><strong>example1</strong></p>\n<pre><code>int array[10];\nint *ptr;\nfor(ptr=&amp;array[9]; ptr&gt;(array-1); ptr--) {...}\n</code></pre>\n<p><strong>example2</strong></p>\n<pre><code>int array[10];\nint *ptr;\nfor(ptr=&amp;array[9]; ptr&gt;=(array); ptr--) {...}\n</code></pre>\n<p>1) Are both <strong>example1</strong> and <strong>example2</strong> forbidden?</p>\n<p>2) Is there proof from the C standard that comparing pointer with <strong>one before the first element of an array object</strong> is forbidden?</p>\n", "Tags": "<c++><c><pointers><comparison>", "CreationDate": "2013-04-26T10:48:31.780", "LastEditDate": "2017-05-23T12:00:21.383", "LastActivityDate": "2013-04-26T11:04:00.300", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "1003575"}});