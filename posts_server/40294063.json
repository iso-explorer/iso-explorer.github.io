post_cb({"40294176": {"Id": "40294176", "PostTypeId": "2", "Body": "<p>As others pointed out in comments: you are modifying object the <code>m_ptr</code> points to. This \"pointed to\" object is not a part of <code>class Test</code> (as far as compiler sees it). That's why compiler allows you to do so.</p>\n<p>Having said that, I believe that it will be undefined behaviour. That's because <code>m_ptr</code> actually points to another member variable (<code>m_val</code>) of object <code>const Test t</code>! Compilers are allowed to optimize arggresively and they might rely on constness to do so.</p>\n<p>The only exception is then you use <code>mutable</code> keyword, but it's another story.</p>\n", "LastEditorUserId": "2581119", "LastActivityDate": "2016-10-27T21:18:46.740", "Score": "4", "CreationDate": "2016-10-27T21:04:54.023", "ParentId": "40294063", "CommentCount": "2", "OwnerUserId": "2581119", "LastEditDate": "2016-10-27T21:18:46.740"}, "bq_ids": {"n4140": {"so_40294063_40294459_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5433}}, "n3337": {"so_40294063_40294459_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5228}}, "n4659": {"so_40294063_40294459_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 6861}}}, "40294405": {"Id": "40294405", "PostTypeId": "2", "Body": "<p><code>const</code> enforces \"bitwise constness\", but what you usually want is \"logical constness\".</p>\n<p>In the case of an object that contains a pointer, this means that a const member function can't modify the pointer itself, but can modify what the pointer refers to.</p>\n<p>This has been well known for a long time.</p>\n<p>To get logical constness, you 1) use <code>mutable</code> (or sometimes <code>const_cast</code>) to allow modification of members that don't affect the object's logical state (e.g., cached values/memoization), and 2) generally have to manually enforce not writing to data through a pointer (but if it's an owning pointer, that ownership should probably be delegated to an object that <em>only</em> manages ownership of that data, in which case making it const should normally prevent writing to the data it owns).</p>\n<p>As far as the specific detail of having a non-const pointer pointing to data that might itself have been const modified, well, you're basically just getting a (persistent) version of roughly the same thing that <code>const_cast</code> is typically used to do: get non-const access to data to which you'd otherwise only have a <code>const</code> pointer. It's up to you to ensure that you only use this in ways that doesn't cause a problem (but just having and/or writing through that pointer doesn't, in itself, necessarily lead to a problem).</p>\n<p>In other words, what we have here are two separate pointers to some data. <code>this</code> lets you access an object's data. In a <code>const</code> member function, you can only read (not) write data via <code>this</code>, unless (as noted above) it's marked <code>mutable</code>. In this case, you're saving a second pointer to the same data. Since there's nothing to mark that as a pointer to <code>const</code>, it's not, so you get non-const access to the data it points at.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2016-10-27T21:32:45.123", "Score": "7", "CreationDate": "2016-10-27T21:23:20.770", "ParentId": "40294063", "CommentCount": "2", "OwnerUserId": "179910", "LastEditDate": "2016-10-27T21:32:45.123"}, "40294459": {"Id": "40294459", "PostTypeId": "2", "Body": "<p>Basically there are two types of constness in <em>C++</em>: physical constness and logical constness.</p>\n<p>As for the physical constness everything is perfectly valid in the considered piece of code because <code>set()</code> modifies a value which is pointed by <code>m_ptr</code> and not the pointer itself which is a part of the class.</p>\n<p>Logical constness is violated here. But there many ways in <em>C++</em> to violate logical constness because this type of constness relies much on the particular class design.</p>\n<p>In the example above program leads to UB because it tries to change a const object.</p>\n<p>From the n4296, 7.1.6.1 <em>The cv-qualifiers</em>:</p>\n<blockquote>\n<p id=\"so_40294063_40294459_0\">Except that any class member declared mutable (7.1.1) can be modified,\n  any attempt to modify a const object during its lifetime (3.8) results\n  in undefined behavior.</p>\n</blockquote>\n", "LastEditorUserId": "5507349", "LastActivityDate": "2016-10-27T21:33:27.027", "Score": "2", "CreationDate": "2016-10-27T21:27:34.130", "ParentId": "40294063", "CommentCount": "2", "OwnerUserId": "5507349", "LastEditDate": "2016-10-27T21:33:27.027"}, "40294377": {"Id": "40294377", "PostTypeId": "2", "Body": "<p>It's undefined behavior.  Not all <code>const</code> declared types are indeed constants, so it's not always undefined behavior to modify something declared that way.  You could have a reference to a const type that refers to a non-const non-const value, cast away constness and modify the value without invoking undefined behavior.  In this case though the original definition is <code>const</code> so you must assume it's a constant.</p>\n<p>Modification of any constant is undefined behavior and yes, there's numerous ways to \"accidentally\" do so.  In the aligned_storage version then yes, it's undefined behavior to modify that <em>constant</em> data by using placement new to modify it.</p>\n", "LastEditorUserId": "301883", "LastActivityDate": "2016-10-27T21:25:56.853", "Score": "1", "CreationDate": "2016-10-27T21:20:39.543", "ParentId": "40294063", "CommentCount": "1", "OwnerUserId": "301883", "LastEditDate": "2016-10-27T21:25:56.853"}, "40294063": {"ViewCount": "387", "Body": "<p>I just discovered how easy it is to modify const objects without any <code>const_cast</code> black magic. Consider:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Test {\npublic:\n    Test(int v)\n        :m_val{ v },\n        m_ptr{ &amp;m_val }\n    {}\n\n    int get() const { return m_val; }\n    void set(int v) const { *m_ptr = v; }\n\nprivate:\n    int m_val;\n    int* m_ptr;\n};\n\nint main()\n{\n    const Test t{ 10 };\n\n    std::cout &lt;&lt; t.get() &lt;&lt; '\\n';\n    t.set(0);\n    std::cout &lt;&lt; t.get() &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre>\n<p>Recent versions of Clang, GCC, and MSVC don't show any warning and produce expected output:</p>\n<blockquote>\n<p id=\"so_40294063_40294063_0\">10 0</p>\n</blockquote>\n<p>Is this well defined behavior according to the current standard? If it's undefined what if <code>m_val</code> was of type <code>std::aligned_storage_t&lt;sizeof(int), alignof(int)&gt;</code> and constructor <code>new</code>'ed <code>int</code> in it? I believe it's pretty common case when it comes to small buffer optimizations.</p>\n<p><strong>Edit</strong></p>\n<p>Thanks, it seems that it's just another way to shoot yourself in a foot. \nWhat's troubling it seems that this:</p>\n<pre><code>struct Test2 {\n    int i;\n    void operator()() { ++i; }\n};\n\nconst std::function&lt;void()&gt; f{ Test2{ 10 } };\nf();\n</code></pre>\n<p>is also undefined behavior when implementation chooses to store the <code>Test2</code> object inside <code>f</code> (and that's the case in libc++ and in Visual Studio)</p>\n", "AcceptedAnswerId": "40294405", "Title": "Modifying const object through pointer obtained during construction", "CreationDate": "2016-10-27T20:56:27.473", "Id": "40294063", "CommentCount": "4", "LastEditDate": "2016-10-27T22:16:00.533", "PostTypeId": "1", "LastEditorUserId": "6130965", "LastActivityDate": "2016-10-27T22:16:00.533", "Score": "10", "OwnerUserId": "6130965", "Tags": "<c++><const>", "AnswerCount": "4"}});