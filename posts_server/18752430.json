post_cb({"18752430": {"ViewCount": "74", "Body": "<p>Given code for an incomplete server like:</p>\n<pre><code>enum class Command : uint32_t {\n    LOGIN,\n    MESSAGE,\n    JOIN_CHANNEL,\n    PART_CHANNEL,\n    INVALID\n};\n</code></pre>\n<p>Can I expect that converting <code>Command::LOGIN</code> to an integer will always give the same value? </p>\n<ul>\n<li>Across compilers? </li>\n<li>Across compiler versions?</li>\n<li>If I add another enumeration?</li>\n<li>If I remove an enumeration?</li>\n</ul>\n<p>Converting <code>Command::LOGIN</code> would look something like this:</p>\n<pre><code>uint32_t number = static_cast&lt;uint32_t&gt;(Command::LOGIN);\n</code></pre>\n<p>Some extra information on what I am doing here. This enumeration is fed onto the wire by converting it to an integer sending it along to the server/client. I do not really particularly care <em>what</em> the number is, as long as it will always stay the same. If it will not stay the same, then obviously I will have to provide my own numbers through the usual way.</p>\n<p>Now my sneaking suspicion is that it will change depending on what compiler was used to compile the code, but I would like to know for sure.</p>\n<p>Bonus question: How does the compiler/language determine what number to use for <code>Command::LOGIN</code>?</p>\n<p><em>Before submitting this question, I have noticed some changes from say 3137527848 to 0 and back, so it is obviously not valid to rely on it not changing. I am still curious about how this number is determined, and how or why that number is changing.</em></p>\n", "AcceptedAnswerId": "18752683", "Title": "Does the actual value of a enum class enumeration remain constant/invariant?", "CreationDate": "2013-09-11T22:36:35.423", "Id": "18752430", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-09-11T23:05:45.130", "Score": "0", "OwnerUserId": "439902", "Tags": "<c++11><enums>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_18752430_18752683_0": {"length": 18, "quality": 1.0, "section_id": 5461}, "so_18752430_18752683_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 6035}, "so_18752430_18752504_1": {"length": 61, "quality": 0.9384615384615385, "section_id": 5461}}, "n3337": {"so_18752430_18752683_0": {"length": 18, "quality": 1.0, "section_id": 5248}, "so_18752430_18752683_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 5803}, "so_18752430_18752504_1": {"length": 61, "quality": 0.9384615384615385, "section_id": 5248}}, "n4659": {"so_18752430_18752683_0": {"length": 18, "quality": 1.0, "section_id": 6895}, "so_18752430_18752683_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 7534}, "so_18752430_18752504_1": {"length": 58, "quality": 0.8923076923076924, "section_id": 6895}}}, "18752489": {"Id": "18752489", "PostTypeId": "2", "Body": "<p>Command::LOGIN will always be 0 as long as it's the first enum in the list. Just be careful with the rest of the enums, because they will have different binary representations based on if the computer is using big endian or little endian.</p>\n", "LastActivityDate": "2013-09-11T22:41:20.987", "CommentCount": "4", "CreationDate": "2013-09-11T22:41:20.987", "ParentId": "18752430", "Score": "1", "OwnerUserId": "2752296"}, "18752504": {"Id": "18752504", "PostTypeId": "2", "Body": "<p>If you assign explicit integer values to your enum constants then you are guaranteed to always have the same value when converting to the integer type.</p>\n<p>Just do something like the following:</p>\n<pre><code>enum class Command : uint32_t {\n    LOGIN = 12,\n    MESSAGE = 46,\n    JOIN_CHANNEL = 5,\n    PART_CHANNEL = 0,\n    INVALID = 42\n};\n</code></pre>\n<p>If you don't specify any values explicitly, the values are set implicitly, starting from zero and increasing by one with each move down the list. </p>\n<p>Quoting from draft <strong>n3485</strong>:</p>\n<blockquote>\n<p id=\"so_18752430_18752504_0\"><strong>[dcl.enum] paragraph 2</strong></p>\n<p id=\"so_18752430_18752504_1\">The enumeration type declared with an enum-key of only enum is an\n  unscoped enumeration, and its enumerators are unscoped enumerators.\n  The enum-keys enum class and enum struct are semantically equivalent;\n  an enumeration type declared with one of these is a scoped\n  enumeration, and its enumerators are scoped enumerators. [...] The\n  identifiers in an enumerator-list are declared as constants, and can\n  appear wherever constants are required. An enumerator-definition with\n  = gives the associated enumerator the value indicated by the constant-expression. If the first enumerator has no initializer, the\n  value of the corresponding constant is zero. <strong>An\n  enumerator-definition without an initializer gives the enumerator the\n  value obtained by increasing the value of the previous enumerator by\n  one</strong>.</p>\n</blockquote>\n<p>The drawback of relying on this, is that if the list order somehow changes in the future, then your code might silently break, so I would advise you be explicit.</p>\n", "LastEditorUserId": "801438", "LastActivityDate": "2013-09-11T23:05:45.130", "Score": "2", "CreationDate": "2013-09-11T22:42:55.607", "ParentId": "18752430", "CommentCount": "7", "OwnerUserId": "801438", "LastEditDate": "2013-09-11T23:05:45.130"}, "18752683": {"Id": "18752683", "PostTypeId": "2", "Body": "<p>From the C++11 Standard (or rather, n3485):</p>\n<p>[dcl.enum]/2</p>\n<blockquote>\n<p id=\"so_18752430_18752683_0\">If the first <em>enumerator</em> has no <em>initializer</em>, the value of the corresponding constant is zero. An <em>enumerator-definition</em> without an <em>initializer</em> gives the <em>enumerator</em> the value obtained by increasing the value of the previous <em>enumerator</em> by one.</p>\n</blockquote>\n<p>Additionally, [expr.static.cast]/9</p>\n<blockquote>\n<p id=\"so_18752430_18752683_1\">A value of a scoped enumeration type can be explicitly converted to an integral type. The value is unchanged if the original value can be represented by the specified type.</p>\n</blockquote>\n<p>I think it's obvious that the values of the enumerators can be represented by <code>uint32_t</code>; if they weren't, [dcl.enum]/5 says \"if the initializing value of an <em>enumerator</em> cannot be represented by the underlying type, the program is ill-formed.\"</p>\n<p>So as long as you use the underlying type for conversion (either explicitly or via <code>std::underlying_type&lt;Command&gt;::type</code>), the value of those enumerators are fixed <strong>as long as you don't add any enumerators before them</strong> (in the same enumeration) <strong>or alter their order</strong>.</p>\n<p>As Nicolas Louis Guillemo <a href=\"https://stackoverflow.com/a/18752489/420683\">pointed out</a>, be aware of possible different endianness when transferring the value.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-09-11T22:58:22.860", "Score": "2", "CreationDate": "2013-09-11T22:58:22.860", "ParentId": "18752430", "CommentCount": "3", "OwnerUserId": "420683", "LastEditDate": "2017-05-23T12:11:08.523"}});