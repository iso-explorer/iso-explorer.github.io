post_cb({"35313292": {"CommentCount": "4", "AcceptedAnswerId": "35335037", "PostTypeId": "1", "LastEditorUserId": "1505939", "CreationDate": "2016-02-10T10:58:16.607", "LastActivityDate": "2017-08-02T13:52:27.770", "LastEditDate": "2017-07-25T04:51:09.313", "ViewCount": "242", "FavoriteCount": "3", "Title": "Aggregate reference member and temporary lifetime", "Id": "35313292", "Score": "7", "Body": "<p>Given this code sample, what are the rules regarding the lifetime of the temporary string being passed to <code>S</code>.</p>\n<pre><code>struct S\n{\n    // [1] S(const std::string&amp; str) : str_{str} {}\n    // [2] S(S&amp;&amp; other) : str_{std::move(other).str} {}\n\n    const std::string&amp; str_;\n};\n\nS a{\"foo\"}; // direct-initialization\n\nauto b = S{\"bar\"}; // copy-initialization with rvalue\n\nstd::string foobar{\"foobar\"};\nauto c = S{foobar}; // copy-initialization with lvalue\n\nconst std::string&amp; baz = \"baz\";\nauto d = S{baz}; // copy-initialization with lvalue-ref to temporary\n</code></pre>\n<p>According to the standard:</p>\n<p>N4140 12.2 p5.1 (removed in N4296)</p>\n<blockquote>\n<p id=\"so_35313292_35313292_0\">A temporary bound to a reference member in a constructor\u2019s ctor-initializer (12.6.2) persists until the\n  constructor exits.</p>\n</blockquote>\n<p>N4296 12.6.2 p8</p>\n<blockquote>\n<p id=\"so_35313292_35313292_1\">A temporary expression bound to a reference member in a mem-initializer is ill-formed.</p>\n</blockquote>\n<p>So having a user defined constructor like <code>[1]</code> is definitively not what we want. It's even supposed to be ill-formed in the latest C++14 (or is it?) neither gcc nor clang warned about it.<br>\nDoes it change with direct aggregate initialization? I looks like in that case, the temporary lifetime is extended.</br></p>\n<p>Now regarding copy-initialization, <a href=\"https://stackoverflow.com/questions/33379327/default-move-constructor-and-reference-members\">Default move constructor and reference members</a> states that <code>[2]</code> is implicitly generated. Given the fact that the move might be elided, does the same rule apply to the implicitly generated move constructor?</p>\n<p>Which of <code>a, b, c, d</code> has a valid reference?</p>\n", "Tags": "<c++><reference><initialization><aggregate><temporary>", "OwnerUserId": "2404064", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_35313292_35335037_0": {"section_id": 382, "quality": 0.7916666666666666, "length": 19}, "so_35313292_35335037_1": {"section_id": 382, "quality": 0.9090909090909091, "length": 10}, "so_35313292_35313292_1": {"section_id": 91, "quality": 0.5714285714285714, "length": 4}, "so_35313292_35313292_0": {"section_id": 382, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_35313292_35313292_1": {"section_id": 86, "quality": 0.5714285714285714, "length": 4}, "so_35313292_35335037_1": {"section_id": 373, "quality": 0.9090909090909091, "length": 10}, "so_35313292_35335037_0": {"section_id": 373, "quality": 0.7916666666666666, "length": 19}, "so_35313292_35313292_0": {"section_id": 373, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_35313292_35335037_0": {"section_id": 397, "quality": 0.75, "length": 18}, "so_35313292_35313292_1": {"section_id": 453, "quality": 1.0, "length": 7}}}, "35335037": {"ParentId": "35313292", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The lifetime of temporary objects bound to references is extended, unless there's a specific exception. That is, if there is no such exception, then the lifetime will be extended.</p>\n<p>From a fairly recent draft, N4567:</p>\n<blockquote>\n<p id=\"so_35313292_35335037_0\">The second context [where the lifetime is extended] is when a\n  reference is bound to a temporary. The temporary to which the\n  reference is bound or the temporary that is the complete object of a\n  subobject to which the reference is bound persists for the lifetime of\n  the reference except:</p>\n<ul>\n<li>(5.1) A temporary object bound to a reference parameter in a function call (5.2.2) persists until the completion of the\n  full-expression containing the call.</li>\n<li>(5.2) The lifetime of a temporary bound to the returned value in a function return statement (6.6.3) is not extended; the temporary is\n  destroyed at the end of the full-expression in the return statement.</li>\n<li>(5.3) A temporary bound to a reference in a new-initializer (5.3.4) persists until the completion of the full-expression\n  containing the new-initializer.</li>\n</ul>\n</blockquote>\n<p>The only significant change to C++11 is, as the OP mentioned, that in C++11 there was an additional exception for data members of reference types (from N3337):</p>\n<blockquote id=\"so_35313292_35335037_1\">\n<ul>\n<li>A temporary bound to a reference member in a constructor\u2019s ctor-initializer (12.6.2) persists until the constructor exits.</li>\n</ul>\n</blockquote>\n<p>This was removed in <a href=\"http://wg21.cmeerw.net/cwg/issue1696\" rel=\"nofollow noreferrer\">CWG 1696</a> (post-C++14), and binding temporary objects to reference data members via the mem-initializer is now ill-formed.</p>\n<hr>\n<p>Regarding the examples in the OP:</p>\n<blockquote id=\"so_35313292_35335037_2\">\n<pre><code>struct S\n{\n    const std::string&amp; str_;\n};\n\nS a{\"foo\"}; // direct-initialization\n</code></pre>\n</blockquote>\n<p>This creates a temporary <code>std::string</code> and initializes the <code>str_</code> data member with it. The <code>S a{\"foo\"}</code> uses aggregate-initialization, so no mem-initializer is involved. None of the exceptions for lifetime extensions apply, therefore the lifetime of that temporary is extended to the lifetime of the reference data member <code>str_</code>.</p>\n<hr>\n<blockquote id=\"so_35313292_35335037_3\">\n<pre><code>auto b = S{\"bar\"}; // copy-initialization with rvalue\n</code></pre>\n</blockquote>\n<p><strong>Prior to mandatory copy elision with C++17:</strong>\nFormally, we create a temporary <code>std::string</code>, initialize a temporary <code>S</code> by binding the temporary <code>std::string</code> to the <code>str_</code> reference member. Then, we move that temporary <code>S</code> into <code>b</code>. This will \"copy\" the reference, which will not extend the lifetime of the <code>std::string</code> temporary.\nHowever, implementations will elide the move from the temporary <code>S</code> to <code>b</code>. This must not affect the lifetime of the temporary <code>std::string</code> though. You can observe this in the following program:</p>\n<pre><code>#include &lt;iostream&gt;\n\n#define PRINT_FUNC() { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \"\\n\"; }\n\nstruct loud\n{\n    loud() PRINT_FUNC()\n    loud(loud const&amp;) PRINT_FUNC()\n    loud(loud&amp;&amp;) PRINT_FUNC()\n    ~loud() PRINT_FUNC()\n};\n\nstruct aggr\n{\n    loud const&amp; l;\n    ~aggr() PRINT_FUNC()\n};\n\nint main() {\n    auto x = aggr{loud{}};\n    std::cout &lt;&lt; \"end of main\\n\";\n    (void)x;\n}\n</code></pre>\n<p><a href=\"http://melpon.org/wandbox/permlink/EhmY7FTEYCTNamcz\" rel=\"nofollow noreferrer\">Live demo</a></p>\n<p>Note that the destructor of <code>loud</code> is called before the \"end of main\", whereas <code>x</code> lives until after that trace. Formally, the temporary <code>loud</code> is destroyed at the end of the full-expression which created it.</p>\n<p>The behaviour does not change if the move constructor of <code>aggr</code> is user-defined.</p>\n<p><strong>With mandatory copy-elision in C++17:</strong> We identify the object on the rhs <code>S{\"bar\"}</code> with the object on the lhs <code>b</code>. This causes the lifetime of the temporary to be extended to the lifetime of <code>b</code>. See <a href=\"https://wg21.link/cwg1697\" rel=\"nofollow noreferrer\">CWG 1697</a>.</p>\n<hr>\n<p>For the remaining two examples, the move constructor - if called - simply copies the reference. The move constructor (of <code>S</code>) can be elided, of course, but this is not observable since it only copies the reference.</p>\n</hr></hr></hr>", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2017-08-02T13:52:27.770", "Id": "35335037", "Score": "2", "CreationDate": "2016-02-11T09:13:26.077", "LastActivityDate": "2017-08-02T13:52:27.770"}});