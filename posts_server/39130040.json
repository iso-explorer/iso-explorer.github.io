post_cb({"39133379": {"Id": "39133379", "PostTypeId": "2", "Body": "<p>Briefly summarizing the pertinent points, mostly from <a href=\"http://developers.redhat.com/blog/2016/02/29/why-cstdlib-is-more-complicated-than-you-might-think/\">Jonathan Wakely's excellent blog post</a>:</p>\n<ul>\n<li>glibc &lt;2.23's <code>math.h</code> declares the obsolete X/Open <code>int isnan(double);</code> that is incompatible with the C99/C++11 version (<code>bool isnan(double);</code>).</li>\n<li>glibc 2.23's <code>math.h</code> fixes this by not declaring the <code>isnan</code> function in C++11 or later.</li>\n<li>All of them still define an <code>isnan</code> macro. <code>#include &lt;cmath&gt;</code> nukes that macro as required by the C++ standard.</li>\n<li>GCC 6's libstdc++ provides its own special <code>math.h</code> header that declares a <code>bool isnan(double);</code> in the global namespace (unless the libc <code>math.h</code> declares the obsolete signature) and also nukes the macros as required by the standard.</li>\n<li>Before GCC 6, <code>#include &lt;math.h&gt;</code> simply included the header from your libc, so the macro isn't nuked.</li>\n<li><code>#include &lt;cmath&gt;</code> always nukes the macros.</li>\n</ul>\n<p>Net result, in C++11 mode:</p>\n<pre><code>glibc &lt;  2.23, GCC &lt;  6: &lt;math.h&gt; uses the macro; &lt;cmath&gt; uses obsolete signature\nglibc &gt;= 2.23, GCC &lt;  6: &lt;math.h&gt; uses the macro; &lt;cmath&gt; results in error\nglibc &lt;  2.23, GCC &gt;= 6: &lt;math.h&gt; and &lt;cmath&gt; use obsolete signature\nglibc &gt;= 2.23, GCC &gt;= 6: &lt;math.h&gt; and &lt;cmath&gt; use standard signature\n</code></pre>\n", "LastActivityDate": "2016-08-24T21:34:09.823", "CommentCount": "3", "CreationDate": "2016-08-24T21:34:09.823", "ParentId": "39130040", "Score": "12", "OwnerUserId": "2756719"}, "bq_ids": {"n4140": {"so_39130040_39132787_0": {"length": 37, "quality": 0.9024390243902439, "section_id": 4907}, "so_39130040_39132787_1": {"length": 35, "quality": 0.8536585365853658, "section_id": 4908}}, "n3337": {"so_39130040_39132787_0": {"length": 37, "quality": 0.9024390243902439, "section_id": 4702}, "so_39130040_39132787_1": {"length": 35, "quality": 0.8536585365853658, "section_id": 4703}}, "n4659": {"so_39130040_39132787_0": {"length": 37, "quality": 0.9024390243902439, "section_id": 6316}, "so_39130040_39132787_1": {"length": 35, "quality": 0.8536585365853658, "section_id": 6317}}}, "39131338": {"Id": "39131338", "PostTypeId": "2", "Body": "<p>A lot of the functions inside <code>math.h</code> are actually macros. Since this is not idiomatic c++ the header <code>cmath</code> contains following code:</p>\n<pre><code>    ...\n    #undef isinf\n    #undef isnan\n    #undef isnormal\n    ...\n</code></pre>\n<p>And implements then all those undefined macros as function in the <code>namespace std</code>. This is at least true for gcc 6.1.1. That's why your compiler can't find <code>isnan</code>.</p>\n", "LastActivityDate": "2016-08-24T19:12:41.443", "CommentCount": "3", "CreationDate": "2016-08-24T19:12:41.443", "ParentId": "39130040", "Score": "3", "OwnerUserId": "4990485"}, "39130040": {"ViewCount": "1170", "Body": "<p>I have here a small test app which uses <code>isnan</code> from <code>&lt;math.h&gt;</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;math.h&gt;\n\nint main()\n{\n    double d = NAN;\n\n    std::cout &lt;&lt; isnan(d) &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre>\n<p><strong>Build and run under 3 different standards:</strong></p>\n<blockquote id=\"so_39130040_39130040_0\">\n<pre><code>$ g++ -std=c++98 main.cpp; ./a.out\n1\n\n$ g++ -std=c++11 main.cpp; ./a.out\n1\n\n$ g++ -std=c++14 main.cpp; ./a.out\n1\n</code></pre>\n</blockquote>\n<p>Now we also include <code>&lt;cmath&gt;</code>, and test with both <code>isnan</code> and <code>std::isnan</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;math.h&gt;\n\nint main()\n{\n    double d = NAN;\n\n    std::cout &lt;&lt; std::isnan(d) &lt;&lt; '\\n';\n    std::cout &lt;&lt; isnan(d) &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre>\n<p><strong>Build and run:</strong></p>\n<p><strong><em>C++98 works</em></strong></p>\n<blockquote id=\"so_39130040_39130040_1\">\n<pre><code>$ g++ -std=c++98 main.cpp; ./a.out\n1\n1\n</code></pre>\n</blockquote>\n<p><strong><em>C++11 and C++14 don't, <code>isnan</code> is not found.</em></strong></p>\n<blockquote id=\"so_39130040_39130040_2\">\n<pre><code>$ g++ -std=c++11 main.cpp\nmain.cpp: In function \u2018int main()\u2019:\nmain.cpp:10:25: error: \u2018isnan\u2019 was not declared in this scope\n     std::cout &lt;&lt; isnan(d) &lt;&lt; '\\n';\n                         ^\nmain.cpp:10:25: note: suggested alternative:\nIn file included from main.cpp:3:0:\n/usr/include/c++/5/cmath:641:5: note:   \u2018std::isnan\u2019\n     isnan(_Tp __x)\n     ^\n\n$ g++ -std=c++14 main.cpp\nmain.cpp: In function \u2018int main()\u2019:\nmain.cpp:10:25: error: \u2018isnan\u2019 was not declared in this scope\n     std::cout &lt;&lt; isnan(d) &lt;&lt; '\\n';\n                         ^\nmain.cpp:10:25: note: suggested alternative:\nIn file included from main.cpp:3:0:\n/usr/include/c++/5/cmath:641:5: note:   \u2018std::isnan\u2019\n     isnan(_Tp __x)\n     ^\n</code></pre>\n</blockquote>\n<p>Note the order of inclusion is not important. If I include <code>&lt;cmath&gt;</code> before <code>&lt;math.h&gt;</code> or after, the result is the same.</p>\n<p><strong>Questions</strong></p>\n<ul>\n<li>Why is <code>isnan</code> gone? </li>\n<li>Without having to go back and change old code to compile under the new standard, is there any way to fix this?</li>\n</ul>\n", "AcceptedAnswerId": "39133379", "Title": "<cmath> hides isnan in <math.h> in C++14 / C++11?", "CreationDate": "2016-08-24T17:56:22.757", "Id": "39130040", "CommentCount": "17", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-08-25T00:50:45.160", "LastEditorUserId": "6710751", "LastActivityDate": "2016-08-25T00:50:45.160", "Score": "16", "OwnerUserId": "955273", "Tags": "<c++><c++11><c++14><nan><cmath>", "AnswerCount": "3"}, "39132787": {"Id": "39132787", "PostTypeId": "2", "Body": "<p>If you look inside <code>&lt;cmath&gt;</code> from GCC, it has this:</p>\n<pre><code>. . .\n#include &lt;math.h&gt;\n. . .\n#undef isnan\n</code></pre>\n<p>That's why the order doesn't matter - whenever you <code>#include &lt;cmath&gt;</code>, <code>&lt;math.h&gt;</code> is auto-included and its contents is (partially) nuked.</p>\n<p>Attempting to include it again will have no effect because of <code>#ifndef _MATH_H</code>.</p>\n<hr>\n<p>Now, what does the standard have to say about this behavior?</p>\n<p><a href=\"http://eel.is/c++draft/depr.c.headers\">[depr.c.headers]</a>:</p>\n<blockquote>\n<p id=\"so_39130040_39132787_0\">... every C header, each\n  of which has a name of the form <code>name.h</code>, behaves as if each name placed\n  in the standard library namespace by the corresponding c<em>name</em> header is\n  placed within the global namespace scope. It is unspecified whether\n  these names are first declared or defined within namespace scope\n  ([basic.scope.namespace]) of the namespace <code>std</code> and are then injected\n  into the global namespace scope by explicit <em>using-declarations</em>\n  ([namespace.udecl]).</p>\n<p id=\"so_39130040_39132787_1\">[ Example: The header <code>&lt;cstdlib&gt;</code> assuredly provides its declarations\n  and definitions within the namespace <code>std</code>. It <strong><em>may</em></strong> also provide these\n  names within the global namespace. The header <code>&lt;stdlib.h&gt;</code> assuredly\n  provides the same declarations and definitions within the global\n  namespace, much as in the C Standard. It may also provide these names\n  within the namespace <code>std</code>.  \u2014 end example ]</p>\n</blockquote>\n<p>So it's OK that <code>&lt;cmath&gt;</code> does not provide <code>isnan</code> in the global namespace.</p>\n<p>But it's a gray area what should happen when <em>both</em> are included in one compilation unit, although one could argue that the statement above <em>implies</em> that both versions must interoperate, in which case it would be a bug in GCC/libstdc++ (some versions).</p>\n</hr>", "LastEditorUserId": "485343", "LastActivityDate": "2016-08-24T21:06:14.070", "Score": "8", "CreationDate": "2016-08-24T20:48:49.030", "ParentId": "39130040", "CommentCount": "0", "OwnerUserId": "485343", "LastEditDate": "2016-08-24T21:06:14.070"}});