post_cb({"bq_ids": {"n4140": {"so_44356761_44411583_2": {"length": 7, "quality": 0.875, "section_id": 6280}}, "n3337": {"so_44356761_44411583_2": {"length": 7, "quality": 0.875, "section_id": 6040}}, "n4659": {"so_44356761_44411583_2": {"length": 7, "quality": 0.875, "section_id": 7787}}}, "44379698": {"Id": "44379698", "PostTypeId": "2", "Body": "<p><sup>I'm still very new to concepts, so feel free to point out any errors I need to fix in this answer.  The answer is divided into three sections: The first directly regards the use of <code>std::forward</code>, the second expands on <code>Swappable</code>, and the third regards the internal error.</sup></p>\n<p>This appears to be a typo<sup>1</sup>, and likely should be <code>requires(T&amp;&amp; t, U&amp;&amp; u)</code>.  In this case, perfect forwarding is used to ensure that the concept will be properly evaluated for both lvalue and rvalue references, guaranteeing that only lvalue references will be marked as swappable.</p>\n<p>The full <a href=\"http://en.cppreference.com/w/cpp/experimental/ranges/concepts/Swappable\" rel=\"nofollow noreferrer\">Ranges TS <code>Swappable</code> concept</a>, which this is based on, is fully defined as:</p>\n<pre><code>template &lt;class T&gt;\nconcept bool Swappable() {\n    return requires(T&amp;&amp; a, T&amp;&amp; b) {\n               ranges::swap(std::forward&lt;T&gt;(a), std::forward&lt;T&gt;(b));\n           };\n}\n\ntemplate &lt;class T, class U&gt;\nconcept bool Swappable() {\n    return ranges::Swappable&lt;T&gt;() &amp;&amp;\n           ranges::Swappable&lt;U&gt;() &amp;&amp;\n           ranges::CommonReference&lt;const T&amp;, const U&amp;&gt;() &amp;&amp;\n           requires(T&amp;&amp; t, U&amp;&amp; u) {\n               ranges::swap(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));\n               ranges::swap(std::forward&lt;U&gt;(u), std::forward&lt;T&gt;(t));\n           };\n}\n</code></pre>\n<p>The concept shown on the <a href=\"http://en.cppreference.com/w/cpp/language/constraints\" rel=\"nofollow noreferrer\">Constraints and concepts</a> page is a simplified version of this, which appears to be intended as a minimal implementation of library concept <code>Swappable</code>.  As the full definition specifies <code>requires(T&amp;&amp;, U&amp;&amp;)</code>, it stands to reason that this simplified version should as well.  <code>std::forward</code> is thus used with the expectation that <code>t</code> and <code>u</code> are forwarding references.</p>\n<p><sup>1: <a href=\"https://stackoverflow.com/questions/44356761/why-use-stdforward-in-concepts#comment75754691_44356761\">Cubbi's comment</a>, made while I was testing code, doing research, and eating supper, confirms that it's a typo.</sup></p>\n<hr>\n<p>[The following expands on <code>Swappable</code>.  Feel free to skip it if this doesn't concern you.]</p>\n<p><sup>Note that this section only applies if <code>Swappable</code> is defined outside namespace <code>std</code>; if defined in <code>std</code>, as it appears to be in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4382.pdf\" rel=\"nofollow noreferrer\">the draft</a>, the two <code>std::swap()</code>s will automatically be considered during overload resolution, meaning no additional work is required to include them.  Thanks go to Cubbi for linking to the draft and stating that <code>Swappable</code> was taken directly from it.</sup></p>\n<p>Note, however, that the simplified form by itself isn't a full implementation of <code>Swappable</code>, unless <code>using std::swap</code> has already been specified.  <a href=\"https://timsong-cpp.github.io/cppwp/utility.requirements#swappable.requirements-3\" rel=\"nofollow noreferrer\"><code>[swappable.requirements/3]</code></a> states that overload resolution must consider both the two <code>std::swap()</code> templates and any <code>swap()</code>s found by ADL (i.e., resolution must proceed as if the using-declaration <code>using std::swap</code> had been specified).  As concepts cannot contain using-declarations, a more complete <code>Swappable</code> might look something like this:</p>\n<pre><code>template&lt;typename T, typename U = T&gt;\nconcept bool ADLSwappable = requires(T&amp;&amp; t, U&amp;&amp; u) {\n    swap(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));\n    swap(std::forward&lt;U&gt;(u), std::forward&lt;T&gt;(t));\n};\n\ntemplate&lt;typename T, typename U = T&gt;\nconcept bool StdSwappable = requires(T&amp;&amp; t, U&amp;&amp; u) {\n    std::swap(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));\n    std::swap(std::forward&lt;U&gt;(u), std::forward&lt;T&gt;(t));\n};\n\ntemplate&lt;typename T, typename U = T&gt;\nconcept bool Swappable = ADLSwappable&lt;T, U&gt; || StdSwappable&lt;T, U&gt;;\n</code></pre>\n<p>This expanded <code>Swappable</code> will allow for proper detection of parameters that fulfil the library concept, <a href=\"http://coliru.stacked-crooked.com/a/53b40dfc934bf157\" rel=\"nofollow noreferrer\">like so</a>.</p>\n<hr>\n<p>[The following regards GCC's internal error, and isn't directly related to <code>Swappable</code> itself.  Feel free to skip it if this doesn't concern you.]</p>\n<p>To use this, however, <code>f()</code> needs a few modifications.  Rather than:</p>\n<pre><code>void f(Swappable&amp; x) {}\n</code></pre>\n<p>One of the following should instead be used:</p>\n<pre><code>template&lt;typename T&gt;\nvoid f(T&amp;&amp; x) requires Swappable&lt;T&amp;&amp;&gt; {}\n\ntemplate&lt;typename T&gt;\nvoid f(T&amp; x) requires Swappable&lt;T&amp;&gt; {}\n</code></pre>\n<p>This is due to an interaction between GCC and concept resolution rules, and will probably be sorted out in future versions of the compiler.  Using a constraint-expression sidesteps the interaction that I believe is responsible for the internal error, making it a viable (if more verbose) stopgap measure for the time being.</p>\n<p>The internal error appears to be caused by the way GCC handles concept resolution rules.  When it encounters this function:</p>\n<pre><code>void f(Swappable&amp; x) {}\n</code></pre>\n<p>As function concepts can be overloaded, concept resolution is performed when concept names are encountered in certain contexts (such as when used as a constrained type specifier, like <code>Swappable</code> is here).  Thus, GCC attempts to resolve <code>Swappable</code> as specified by concept resolution rule #1, <a href=\"http://en.cppreference.com/w/cpp/language/constraints\" rel=\"nofollow noreferrer\">in the <strong>Concept resolution</strong> section of this page</a>:</p>\n<ol>\n<li>As <code>Swappable</code> is used without a parameter list, it takes a single wildcard as its argument.  This wildcard can match any possible template parameter (whether type, non-type, or template), and thus is a perfect match for <code>T</code>.</li>\n<li><p>As <code>Swappable</code>'s second parameter doesn't correspond to an argument, its default template argument will be used, as specified after the numbered rules; I believe this to be the problem.  As <code>T</code> is currently <code>(wildcard)</code>, a simplistic approach would be to temporarily instantiate <code>U</code> as either another wildcard or a copy of the first wildcard, and determine whether <code>Swappable&lt;(wildcard), (wildcard)&gt;</code> matches the pattern <code>template&lt;typename T, typename U&gt;</code> (it does); it could then deduce <code>T</code>, and use that to properly determine whether it resolves to the <code>Swappable</code> concept.</p>\n<p>Instead, GCC appears to have reached a Catch-22: It can't instantiate <code>U</code> until it deduces <code>T</code>, but it can't deduce <code>T</code> until it determines whether this <code>Swappable</code> correctly resolves to the <code>Swappable</code> concept... which it can't do without <code>U</code>.  So, it needs to figure out what <code>U</code> is before it can figure out whether we have the right <code>Swappable</code>, but it needs to know whether we have the right <code>Swappable</code> before it can figure out what <code>U</code> is; faced with this unresolvable conundrum, it has an aneurysm, keels over, and dies.</p></li>\n</ol>\n</hr></hr>", "LastEditorUserId": "5386374", "LastActivityDate": "2017-06-07T19:30:17.020", "Score": "4", "CreationDate": "2017-06-06T00:37:04.133", "ParentId": "44356761", "CommentCount": "13", "LastEditDate": "2017-06-07T19:30:17.020", "OwnerUserId": "5386374"}, "44411583": {"Id": "44411583", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_44356761_44411583_0\">Don't we want to call swap with lvalues [\u2026]</p>\n</blockquote>\n<p>That\u2019s a very good question. A question of API design specifically: what meaning or meanings should the designer of a concept library give to the parameters of its concepts?</p>\n<p>A quick recap on Swappable requirements. That is, the actual requirements that already appear in today\u2019s Standard and have been here since before concepts-lite:</p>\n<blockquote>\n<ul>\n<li>An object <code>t</code> is <em>swappable with</em> an object <code>u</code> if and only if:\n  \n  <ul>\n<li>[\u2026] the expressions <code>swap(t, u)</code> and <code>swap(u, t)</code> are valid [\u2026]</li>\n</ul></li>\n</ul>\n<p id=\"so_44356761_44411583_1\">[\u2026]</p>\n<p id=\"so_44356761_44411583_2\">An rvalue or lvalue <code>t</code> is swappable if and only if t is swappable with any rvalue or lvalue, respectively, of type <code>T</code>.</p>\n</blockquote>\n<p>(Excerpts butchered from <a href=\"http://eel.is/c++draft/swappable.requirements\" rel=\"nofollow noreferrer\"><code>Swappable</code> requirements [swappable.requirements]</a> to cut down on a whole lot of irrelevant details.)</p>\n<h1>Variables</h1>\n<p>Did you catch that? The first bit gives requirements that match your expectations. It\u2019s quite straightforward to turn into an actual concept\u2020, too:</p>\n<p><sup>\u2020: as long as we\u2019re willing to ignore a ton of details that are outside our scope</sup></p>\n<pre><code>template&lt;typename Lhs, typename Rhs = Lhs&gt;\nconcept bool FirstKindOfSwappable = requires(Lhs lhs, Rhs rhs) {\n    swap(lhs, rhs);\n    swap(rhs, lhs);\n};\n</code></pre>\n<p>Now, very importantly we should immediately notice that this concept supports reference variables right out of the box:</p>\n<pre><code>int&amp;&amp; a_rref = 0;\nint&amp;&amp; b_rref = 0;\n// valid...\nusing std::swap;\nswap(a_rref, b_rref);\n// ...which is reflected here\nstatic_assert( FirstKindOfSwappable&lt;int&amp;&amp;&gt; );\n</code></pre>\n<p><sup>(Now technically the Standard was talking in terms of objects which references aren't. Since references not only refer to objects <sup>or functions</sup> but are meant to transparently stand for them, we\u2019ve actually provided a very desirable feature. Practically speaking we are now working in terms of <em>variables</em>, not just objects.)</sup></p>\n<p>There\u2019s a very important connection here: <code>int&amp;&amp;</code> is the declared type of our variables, as well as the actual argument passed to the concept, which in turn ends up again as the declared type of our <code>lhs</code> and <code>rhs</code> requires parameters. Keep that in mind as we dig deeper.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/52f856f41e80349e\" rel=\"nofollow noreferrer\"><kbd>Coliru</kbd> demo</a></p>\n<h1>Expressions</h1>\n<p>Now what about that second bit that mentions lvalues and rvalues? Well, here we\u2019re not dealing in variables any more but instead in terms of <em>expressions</em>. Can we write a concept for that? Well, there\u2019s a certain expression-to-type encoding we can use. Namely the one used by <code>decltype</code> as well as <code>std::declval</code> in the other direction. This leads us to:</p>\n<pre><code>template&lt;typenaome Lhs, typename Rhs = Lhs&gt;\nconcept bool SecondKindOfSwappable = requires(Lhs lhs, Rhs rhs) {\n    swap(std::forward&lt;Lhs&gt;(lhs), std::forward&lt;Rhs&gt;(rhs));\n    swap(std::forward&lt;Rhs&gt;(rhs), std::forward&lt;Lhs&gt;(lhs));\n\n    // another way to express the first requirement\n    swap(std::declval&lt;Lhs&gt;(), std::declval&lt;Rhs&gt;());\n};\n</code></pre>\n<p>Which is what you ran into! And as you found out, the concept must be used in a different way:</p>\n<pre><code>// not valid\n//swap(0, 0);\n//     ^- rvalue expression of type int\n//        decltype( (0) ) =&gt; int&amp;&amp;\nstatic_assert( !SecondKindOfSwappable&lt;int&amp;&amp;&gt; );\n// same effect because the expression-decltype/std::declval encoding\n// cannot properly tell apart prvalues and xvalues\nstatic_assert( !SecondKindOfSwappable&lt;int&gt; );\n\nint a = 0, b = 0;\nswap(a, b);\n//   ^- lvalue expression of type int\n//      decltype( (a) ) =&gt; int&amp;\nstatic_assert( SecondKindOfSwappable&lt;int&amp;&gt; );\n</code></pre>\n<p>If you find that non-obvious, take a look at the connection at play this time: we have an lvalue expression of type <code>int</code>, which becomes encoded as the <code>int&amp;</code> argument to the concept, which gets restored to an expression in our constraint by <code>std::declval&lt;int&amp;&gt;()</code>. Or in a more roundabout way, by <code>std::forward&lt;int&amp;&gt;(lhs)</code>.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/40ca85ebafc41652\" rel=\"nofollow noreferrer\"><kbd>Coliru</kbd> demo</a></p>\n<h1>Putting it together</h1>\n<p>What appears on the cppreference entry is a summary of the <code>Swappable</code> concept specified by the Ranges TS. If I were to guess, I would say that the Ranges TS settled on giving the <code>Swappable</code> parameters to stand for expressions for the following reasons:</p>\n<ul>\n<li><p>we can write <code>SecondKindOfSwappable</code> in terms of <code>FirstKindOfSwappable</code> as given by the following <sup>nearly</sup>:</p>\n<pre><code>template&lt;typename Lhs, typename Rhs = Lhs&gt;\nconcept bool FirstKindOfSwappable = SecondKindOfSwappable&lt;Lhs&amp;, Rhs&amp;&gt;;\n</code></pre>\n<p>This recipe can be applied in many but not all cases, making it sometimes possible to express a concept parametrised on types-of-variables in terms of the same concept parametrised on expressions-hidden-in-types. But it\u2019s usually not possible to go the other way around.</p></li>\n<li><p>constraining on <code>swap(std::forward&lt;Lhs&gt;(lhs), std::forward&lt;Rhs&gt;(rhs))</code> is expected to be an important enough scenario; off the top of my head it comes up in business such as:</p>\n<pre><code>template&lt;typename Val, typename It&gt;\nvoid client_code(Val val, It it)\n    requires Swappable&lt;Val&amp;, decltype(*it)&gt;\n//                           ^^^^^^^^^^^^^--.\n//                                          |\n//  hiding an expression into a type! ------`\n{\n    ranges::swap(val, *it);\n}\n</code></pre></li>\n<li><p>consistency: for the most part, other concepts of the TS follow the same convention and are parametrised over types of expressions</p></li>\n</ul>\n<p>But why for the most part?</p>\n<p>Because there is a third kind of concept parameter: the type that stand for\u2026 a type. A good example of that is <code>DerivedFrom&lt;Derived, Base&gt;()</code> which value does not give you valid expressions (or ways to use variables) in the usual sense.</p>\n<p>In fact, in e.g. <code>Constructible&lt;Arg, Inits...&gt;()</code> the first argument <code>Arg</code> can arguably be interpreted in two ways:</p>\n<ul>\n<li><code>Arg</code> stands for a type, i.e. taking constructibility as an inherent property of a type</li>\n<li><code>Arg</code> is the declared type of a variable being constructed, i.e. the constraint implies that <code>Arg imaginary_var { std::declval&lt;Inits&gt;()... };</code> is valid</li>\n</ul>\n<h1>How should I write my own concepts?</h1>\n<p>I\u2019ll conclude with a personal note: I think the reader should not conclude (yet) that they should write their own concepts the same way just because concepts over expressions appear, at least from the perspective of a concept writer, to be a superset of concepts over variables.</p>\n<p>There are other factors at play, and my concern is namely with usability from the perspective of a concept client <sup>and all these details I only mentioned in passing, too</sup>. But that doesn\u2019t really have to do with the question and this answer is already long enough, so I\u2019ll leave that story for another time.</p>\n", "LastEditorUserId": "726300", "LastActivityDate": "2017-06-07T23:05:05.070", "Score": "3", "CreationDate": "2017-06-07T11:38:11.760", "ParentId": "44356761", "CommentCount": "1", "LastEditDate": "2017-06-07T23:05:05.070", "OwnerUserId": "726300"}, "44356761": {"ViewCount": "322", "Body": "<p>I was reading the <a href=\"http://en.cppreference.com/w/cpp/language/constraints\" rel=\"noreferrer\">cppreference page on Constraints</a> and noticed this example:</p>\n<pre><code>// example constraint from the standard library (ranges TS)\ntemplate &lt;class T, class U = T&gt;\nconcept bool Swappable = requires(T t, U u) {\n    swap(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));\n    swap(std::forward&lt;U&gt;(u), std::forward&lt;T&gt;(t));\n};\n</code></pre>\n<p>I'm puzzled why they're using <code>std::forward</code>.  Some attempt to support reference types in the template parameters?  Don't we want to call <code>swap</code> with lvalues, and wouldn't the <code>forward</code> expressions be rvalues when <code>T</code> and <code>U</code> are scalar (non-reference) types?</p>\n<p>For example, I would expect this program to fail given their <code>Swappable</code> implementation:</p>\n<pre><code>#include &lt;utility&gt;\n\n// example constraint from the standard library (ranges TS)\ntemplate &lt;class T, class U = T&gt;\nconcept bool Swappable = requires(T t, U u) {\n    swap(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));\n    swap(std::forward&lt;U&gt;(u), std::forward&lt;T&gt;(t));\n};\n\nclass MyType {};\nvoid swap(MyType&amp;, MyType&amp;) {}\n\nvoid f(Swappable&amp; x) {}\n\nint main()\n{\n    MyType x;\n    f(x);\n}\n</code></pre>\n<p>Unfortunately g++ 7.1.0 gives me an <a href=\"http://coliru.stacked-crooked.com/a/7f17cf55137efefa\" rel=\"noreferrer\">internal compiler error</a>, which doesn't shed much light on this.</p>\n<p>Here both <code>T</code> and <code>U</code> should be <code>MyType</code>, and <code>std::forward&lt;T&gt;(t)</code> should return <code>MyType&amp;&amp;</code>, which can't be passed to my <code>swap</code> function.</p>\n<p>Is this implementation of <code>Swappable</code> wrong?  Have I missed something?</p>\n", "AcceptedAnswerId": "44411583", "Title": "Why use std::forward in concepts?", "CreationDate": "2017-06-04T17:13:38.640", "Id": "44356761", "CommentCount": "8", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-06-04T17:30:00.983", "LastEditorUserId": "1774667", "LastActivityDate": "2017-06-07T23:05:05.070", "Score": "18", "OwnerUserId": "459640", "Tags": "<c++><c++-concepts><c++20>", "AnswerCount": "2"}});