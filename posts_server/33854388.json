post_cb({"33854742": {"ParentId": "33854388", "CommentCount": "4", "Body": "<p>clang seems correct to me. I agree with your interpretation that the lambda return type must be <code>decltype(u)</code>, but not that <code>decltype(u)</code> is <code>unmovable&amp;</code>.</p>\n<blockquote>\n<p id=\"so_33854388_33854742_0\"><strong>5.1.2 Lambda expressions [expr.prim.lambda]</strong></p>\n<p id=\"so_33854388_33854742_1\">18 Every <em>id-expression</em> within the <em>compound-statement</em> of a <em>lambda-expression</em> that is an odr-use (3.2) of an\n  entity captured by copy is transformed into an access to the corresponding unnamed data member of the\n  closure type. [ <em>Note:</em> An <em>id-expression</em> that is not an odr-use refers to the original entity, never to a member of the closure type. Furthermore, such an <em>id-expression</em> does not cause the implicit capture of the entity.\n  -- <em>end note</em> ] [...]</p>\n<p id=\"so_33854388_33854742_2\">19 Every occurrence of <code>decltype((x))</code> where [...]</p>\n</blockquote>\n<p>p19 doesn't apply, since you have <code>decltype(u)</code>, not <code>decltype((u))</code>.</p>\n<p>p18 then says that as the <code>u</code> in <code>decltype(u)</code> is not an odr-use, it refers to the original entity, it does not get transformed to an access of the member of the closure type.</p>\n<p>However, p19 does make it clear that if you write your <code>return</code> statement as</p>\n<pre><code>auto i = [&amp;]() -&gt; decltype(auto) { return (u); };\n</code></pre>\n<p>then the lambda will return <code>u</code> by reference. This will work with clang, if this is the behaviour you were after.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "33854742", "Score": "7", "CreationDate": "2015-11-22T12:26:00.040", "LastActivityDate": "2015-11-22T12:26:00.040"}, "33854388": {"CommentCount": "6", "CreationDate": "2015-11-22T11:46:52.157", "PostTypeId": "1", "AcceptedAnswerId": "33854742", "LastEditorUserId": "3953764", "LastActivityDate": "2015-11-22T12:36:05.877", "LastEditDate": "2015-11-22T11:50:18.327", "ViewCount": "593", "FavoriteCount": "1", "Title": "decltype(auto) deduced return type from lambda capture", "Id": "33854388", "Score": "8", "Body": "<p>I have compilers disagreeing on a small C++14 code snippet:</p>\n<pre><code>#include &lt;cassert&gt;\n\nstruct unmovable {\n  unmovable() {}\n  unmovable(unmovable&amp;&amp;) = delete;\n};\n\nint main()\n{\n  unmovable u;\n\n  auto i = [&amp;]() -&gt; decltype(auto) { return u; };\n  auto&amp; uu = i();\n\n  assert(&amp;uu == &amp;u);\n}\n</code></pre>\n<p>The program is accepted by g++4.9.3, g++-5.1.0, g++-5.2.0 and VisualStudio 2015, but not by clang++-3.7.</p>\n<p>clang++-3.7 deduces the return type to be <code>unmovable</code> (value) and not <code>unmovable&amp;</code>.</p>\n<p>If the program is changed slightly, so that the variable <code>u</code> is global, then all compilers agree on the error.</p>\n<p>As I understand it, the captured <code>u</code> in the lambda should be of type <code>unmovable&amp;</code> when the variable is local.</p>\n<p>I don't have the C++14 standard, but hopefully the draft from <a href=\"https://github.com/cplusplus/draft\">github</a> is relevant. My interpretation of 7.1.6.2 and 7.1.6.4 is that <code>decltype(auto)</code> becomes <code>decltype(u)</code> from the return, which in the global case should be <code>unmovable</code> (value) and in the lambda reference capture of the local <code>u</code>, it should become <code>unmovable&amp;</code> since the captured variable must be of type <code>unmovable&amp;</code>. This would indicate that clang++ got it wrong.</p>\n<p>If I change the lambda and its use slightly:</p>\n<pre><code>auto i = [](auto&amp; v) -&gt; decltype(auto) { return v; };\nauto&amp; uu = i(u);\n</code></pre>\n<p>then all compilers accept it, regardless of whether <code>u</code> is global or local, which I think strengthens my interpretation of the <code>decltype(auto)</code> deduction, since <code>v</code> here definitely becomes of type <code>unmovable&amp;</code>.</p>\n<p>Is my interpretation correct and thus clang++ incorrect?</p>\n", "Tags": "<c++><c++11><lambda><c++14><decltype>", "OwnerUserId": "4966163", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33854388_33854742_1": {"section_id": 5977, "quality": 0.9210526315789473, "length": 35}, "so_33854388_33854742_2": {"section_id": 5978, "quality": 1.0, "length": 4}}, "n3337": {"so_33854388_33854742_1": {"section_id": 5745, "quality": 0.8421052631578947, "length": 32}, "so_33854388_33854742_2": {"section_id": 5746, "quality": 1.0, "length": 4}}, "n4659": {"so_33854388_33854742_1": {"section_id": 7474, "quality": 0.9210526315789473, "length": 35}, "so_33854388_33854742_2": {"section_id": 7477, "quality": 1.0, "length": 4}}}});