post_cb({"29483338": {"ParentId": "29483123", "CommentCount": "1", "CreationDate": "2015-04-07T03:40:45.513", "OwnerUserId": "862351", "PostTypeId": "2", "Id": "29483338", "Score": "9", "Body": "<p>There is no notion of endian-ness as far as the standard is concerned. When it comes to <code>std::bitset</code>, <code>[template.bitset]/3</code> defines <em>bit position</em>:</p>\n<blockquote>\n<p id=\"so_29483123_29483338_0\">When converting between an object of class <code>bitset&lt;N&gt;</code> and a value of\n  some integral type, <em>bit position</em> <code>pos</code> corresponds to the bit value <code>1&lt;&lt;pos</code>.\n  The integral value corresponding to two or more bits is the sum\n  of their bit values.</p>\n</blockquote>\n<p>Using this definition of <em>bit position</em> in your standard quote</p>\n<blockquote>\n<p id=\"so_29483123_29483338_1\">initializing the first <code>M</code> <em>bit positions</em> to the corresponding bit values in <code>val</code></p>\n</blockquote>\n<p>a <code>val</code> with binary representation <code>11</code> leads to a <code>bitset&lt;N&gt; b</code> with <code>b[0] = 1</code>, <code>b[1] = 1</code> and remaining bits set to <code>0</code>.</p>\n", "LastActivityDate": "2015-04-07T03:40:45.513"}, "29483123": {"CommentCount": "4", "ViewCount": "1417", "PostTypeId": "1", "LastEditorUserId": "183120", "CreationDate": "2015-04-07T03:16:14.730", "LastActivityDate": "2015-06-15T05:31:02.550", "Title": "Why does std::bitset expose bits in little-endian fashion?", "AcceptedAnswerId": "29483338", "LastEditDate": "2015-06-15T05:31:02.550", "Id": "29483123", "Score": "4", "Body": "<p>When I use <code>std::bitset&lt;N&gt;::bitset( unsigned long long )</code> this constructs a bitset and when I access it via the <code>operator[]</code>, the bits seems to be ordered in the little-endian fashion. Example:</p>\n<pre><code>std::bitset&lt;4&gt; b(3ULL);\nstd::cout &lt;&lt; b[0] &lt;&lt; b[1] &lt;&lt; b[2] &lt;&lt; b[3];\n</code></pre>\n<p>prints <code>1100</code> instead of <code>0011</code> i.e. the ending (or LSB) is at the little (lower) address, index 0.</p>\n<p>Looking up the standard, it says</p>\n<blockquote>\n<p id=\"so_29483123_29483123_0\">initializing the first M bit positions to the corresponding bit values in <code>val</code></p>\n</blockquote>\n<p>Programmers naturally think of binary digits from LSB to MSB (right to left). So the <em>first M bit positions</em> is understandably LSB \u2192 MSB, so bit 0 would be at <code>b[0]</code>.</p>\n<p>However, under shifting, the definition goes</p>\n<blockquote>\n<p id=\"so_29483123_29483123_1\">The value of <code>E1</code> &lt;&lt; <code>E2</code> is <code>E1</code> left-shifted <code>E2</code> bit positions; vacated bits are zero-filled.</p>\n</blockquote>\n<p>Here one has to interpret the bits in <code>E1</code> as going from MSB \u2192 LSB and then left-shift <code>E2</code> times. Had it been written from LSB \u2192 MSB, then only right-shifting <code>E2</code> times would give the same result.</p>\n<p>I'm surprised that everywhere else in C++, the language seems to project the natural (English; left-to-right) writing order (when doing bitwise operations like shifting, etc.). Why be different here?</p>\n", "Tags": "<c++><binary><endianness><bitset>", "OwnerUserId": "183120", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_29483123_29483123_0": {"section_id": 4114, "quality": 1.0, "length": 8}, "so_29483123_29483338_0": {"section_id": 4111, "quality": 0.8928571428571429, "length": 25}, "so_29483123_29483338_1": {"section_id": 4114, "quality": 1.0, "length": 8}, "so_29483123_29483123_1": {"section_id": 6147, "quality": 0.875, "length": 7}}, "n3337": {"so_29483123_29483123_0": {"section_id": 3957, "quality": 1.0, "length": 8}, "so_29483123_29483338_0": {"section_id": 3954, "quality": 0.8928571428571429, "length": 25}, "so_29483123_29483338_1": {"section_id": 3957, "quality": 1.0, "length": 8}, "so_29483123_29483123_1": {"section_id": 5910, "quality": 0.875, "length": 7}}, "n4659": {"so_29483123_29483123_0": {"section_id": 5379, "quality": 1.0, "length": 8}, "so_29483123_29483338_0": {"section_id": 5376, "quality": 0.8928571428571429, "length": 25}, "so_29483123_29483338_1": {"section_id": 5379, "quality": 1.0, "length": 8}, "so_29483123_29483123_1": {"section_id": 7643, "quality": 0.875, "length": 7}}}, "29483339": {"ParentId": "29483123", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-04-07T03:40:46.887", "Score": "5", "LastEditorUserId": "5987", "LastEditDate": "2015-04-07T03:58:23.393", "Id": "29483339", "OwnerUserId": "5987", "Body": "<p>This is consistent with the way bits are usually numbered - bit 0 represents 2<sup>0</sup>, bit 1 represents 2<sup>1</sup>, etc. It has nothing to do with the endianness of the architecture, which concerns byte ordering not bit ordering.</p>\n", "LastActivityDate": "2015-04-07T03:58:23.393"}});