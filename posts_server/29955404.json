post_cb({"bq_ids": {"n4140": {"so_29955404_29956343_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 3299}, "so_29955404_29956343_0": {"length": 8, "quality": 0.8, "section_id": 3309}}, "n3337": {"so_29955404_29956343_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 3169}, "so_29955404_29956343_0": {"length": 8, "quality": 0.8, "section_id": 3179}}, "n4659": {"so_29955404_29956343_1": {"length": 24, "quality": 0.7741935483870968, "section_id": 4065}, "so_29955404_29956343_0": {"length": 6, "quality": 0.6, "section_id": 4075}}}, "29955404": {"ViewCount": "1566", "Body": "<p>I have encountered the following VS2015 CTP6 VC++ compiler behavior:</p>\n<pre><code>unsigned char a = 1;\n\nunsigned char x = (2 | a);   //this compiles fine\n\nunsigned char y[] = {2 | a}; //this emits warning C4838: conversion from\n                             //'int' to 'unsigned char' requires a narrowing conversion\n</code></pre>\n<p>I assume that some implicit type conversion or promotion occurs in the definition of <code>y</code>, but whatever is happening there should've happened in the line that defines <code>x</code> as well - yet this line compiles fine.</p>\n<p>Reversing the operands order didn't help, casting <code>2</code> to <code>unsigned char</code> didn't help either:</p>\n<pre><code>unsigned char y[] = {(unsigned char)2 | a}; //same warning\nunsigned char y[] = {a | 2};                //same warning\n</code></pre>\n<p>Same thing happens with other bitwise operators as well. The only thing that resolved the warning was an explicit cast of the result of bitwise operation: <code>unsigned char y[] = {(unsigned char)(2 | a)};</code> </p>\n<p>Can anyone explain such compiler behavior? Is it a bug?</p>\n<p><strong>Edit</strong>:</p>\n<p><code>GCC 4.9.1</code> compiles cleanly, <code>Clang 3.5</code> issues an error: \"<em>error: non-constant-expression cannot be narrowed from type 'int' to 'unsigned char' in initializer list [-Wc++11-narrowing]</em>\". Can anyone explain? </p>\n", "AcceptedAnswerId": "29956343", "Title": "VS2015 inconsistent compiler behavior", "CreationDate": "2015-04-29T22:04:47.027", "Id": "29955404", "CommentCount": "12", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-04-29T23:04:08.000", "LastEditorUserId": "1756636", "LastActivityDate": "2016-06-15T19:03:46.783", "Score": "1", "OwnerUserId": "1756636", "Tags": "<c++><visual-c++><visual-studio-2015>", "AnswerCount": "3"}, "29955673": {"Id": "29955673", "PostTypeId": "2", "Body": "<p><code>(2 | a)</code> is of type <code>int</code>, because 2 is an int, and <code>a</code>gets promoted.</p>\n<p>C++ inherited from C an ability to silently perform unsafe conversions from a wider type to a smaller type - unsafe in the sense that any higher order bits are lost.</p>\n<p>That's what this does:</p>\n<pre><code>unsigned char x = (2 | a);\n</code></pre>\n<p>The new brace initialisation syntax is an opportunity to ditch this backward compatibility. By design, if you want an unsafe/lossy conversion when using brace initialisation you must ask for it. That's why this doesn't work:</p>\n<pre><code>unsigned char y[] = {2 | a}; \n</code></pre>\n<p>Initialising an <code>unsigned char</code> from <code>int</code> loses information so needs a cast.</p>\n<p>This isn't a bug, it's required behaviour. And one day it will catch a bug at compile time that would have taken you hours to find when it happened at run time, so always use the new syntax when you can.</p>\n", "LastActivityDate": "2015-04-29T22:26:40.377", "CommentCount": "5", "CreationDate": "2015-04-29T22:26:40.377", "ParentId": "29955404", "Score": "1", "OwnerUserId": "212870"}, "29956343": {"Id": "29956343", "PostTypeId": "2", "Body": "<p>The rules for aggregate initialization changed between C++03 and today -- a lot.  (All quotes from section <code>[dcl.init.aggr]</code> which remains 8.5.1 in all versions)</p>\n<p>In C++03, the rule was</p>\n<blockquote>\n<p id=\"so_29955404_29956343_0\">All implicit type conversions are considered when initializing the aggregate member with an initializer from an initializer-list. </p>\n</blockquote>\n<p>In draft n3485 (roughly, C++11) and n4296 (roughly, C++14), this case is now covered by a different rule</p>\n<blockquote>\n<p id=\"so_29955404_29956343_1\">When an aggregate is initialized by an initializer list, as speci\ufb01ed in 8.5.4, the elements of the initializer list are taken as initializers for the members of the aggregate, in increasing subscript or member order. Each\n  member is copy-initialized from the corresponding initializer-clause. <strong>If the initializer-clause is an expression and a narrowing conversion is required to convert the expression, the program is ill-formed.</strong></p>\n</blockquote>\n<p>This was an intentional breakage of backward compatibility, and listed as such in the C++11 appendix:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_29955404_29956343_2\">Change: Narrowing restrictions in aggregate initializers</p></li>\n<li><p id=\"so_29955404_29956343_3\">Rationale: Catches bugs.</p></li>\n<li><p id=\"so_29955404_29956343_4\">Effect on original feature: <strong>Valid C++ 2003 code may fail to compile in this International Standard.</strong> For example, the following code is valid in C++ 2003 but invalid in this International Standard because <code>double</code> to <code>int</code> is a narrowing conversion:</p>\n<pre><code>int x[] = { 2.0 };\n</code></pre></li>\n</ul>\n</blockquote>\n<p>The semantics of promotion which cause OR-ing <code>unsigned char</code> values to yield a result that doesn't fit back into <code>unsigned char</code> without narrowing have already been fully explained here:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/28142902/103167\">Are the \"usual arithmetic conversions\" and the \"integer promotions\" the same thing?</a></li>\n</ul>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-04-29T23:44:30.487", "Score": "4", "CreationDate": "2015-04-29T23:22:14.747", "ParentId": "29955404", "CommentCount": "7", "OwnerUserId": "103167", "LastEditDate": "2017-05-23T12:24:03.880"}, "29955767": {"Id": "29955767", "PostTypeId": "2", "Body": "<p>I'm not sure about Alan's answer because the brace syntax to initialize an array (which is what you're doing there) is valid C syntax, so that's not new to C++.</p>\n<p>On VS2013, your code compiles for me with no warnings. I said something else originally, but as I think about it I'm not sure what's proper as far as issuing warnings go.</p>\n", "LastEditorUserId": "4778565", "LastActivityDate": "2015-04-29T22:39:37.497", "Score": "-1", "CreationDate": "2015-04-29T22:34:33.277", "ParentId": "29955404", "CommentCount": "1", "OwnerUserId": "4778565", "LastEditDate": "2015-04-29T22:39:37.497"}});