post_cb({"25118838": {"ParentId": "25118191", "CommentCount": "0", "Body": "<p>This is indirectly forbidden, because:</p>\n<p>7/3 forbids writing the explicit specialization without a <em>class-key</em> (<code>class</code>, <code>struct</code>, or <code>union</code>):</p>\n<blockquote>\n<p id=\"so_25118191_25118838_0\">In a <em>simple-declaration</em>, the optional <em>init-declarator-list</em> can be omitted only when declaring a class (Clause 9) or enumeration (7.2), that is, when the <em>decl-specifier-seq</em> contains either a <em>class-specifier</em>, an <em>elaborated-type-specifier</em> with a <em>class-key</em> (9.1), or an <em>enum-specifier</em>.</p>\n</blockquote>\n<p>7.1.6.3/2 forbids combining a <em>class-key</em> with an alias template specialization:</p>\n<blockquote>\n<p id=\"so_25118191_25118838_1\">3.4.4 describes how name lookup proceeds for the <em>identifier</em> in an <em>elaborated-type-specifier</em>.  ...  If the <em>identifier</em> resolves to a <em>typedef-name</em> or the <em>simple-template-id</em> resolves to an alias template specialization, the <em>elaborated-type-specifier</em> is ill-formed.</p>\n</blockquote>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "25118838", "Score": "10", "CreationDate": "2014-08-04T12:36:20.897", "LastActivityDate": "2014-08-04T12:36:20.897"}, "25118191": {"CommentCount": "5", "AcceptedAnswerId": "25118838", "PostTypeId": "1", "LastEditorUserId": "1422197", "CreationDate": "2014-08-04T11:59:03.040", "LastActivityDate": "2014-08-04T12:36:20.897", "LastEditDate": "2014-08-04T12:04:11.100", "ViewCount": "474", "FavoriteCount": "3", "Title": "Explicitly instantiate class through template alias", "Id": "25118191", "Score": "12", "Body": "<p>Is it possible to explicitly instantiate a template class through a template alias?</p>\n<p>If so, how? Otherwise, can someone point to the ISO paper in which this was discussed and decided against?</p>\n<pre><code>template&lt;class T&gt;\nstruct A { };\n\n/// Explicit instantiate A for int:\ntemplate struct A&lt;int&gt;;\n\n/// Alias\ntemplate&lt;class T&gt;\nusing B = A&lt;T&gt;;\n\n/// Explicitly instantiate A for double via alias B:\ntemplate struct B&lt;double&gt;;\n/// error: elaborated type refers to a non-tag type\n</code></pre>\n<p>Shouldn't this instantiate <code>A&lt;double&gt;</code> since <code>B&lt;T&gt;</code> is just a different name for <code>A&lt;T&gt;</code> ?</p>\n", "Tags": "<templates><c++11><template-aliases><explicit-instantiation>", "OwnerUserId": "1422197", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_25118191_25118838_0": {"section_id": 5381, "quality": 1.0, "length": 18}, "so_25118191_25118838_1": {"section_id": 5443, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_25118191_25118838_0": {"section_id": 5175, "quality": 1.0, "length": 18}, "so_25118191_25118838_1": {"section_id": 5238, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_25118191_25118838_0": {"section_id": 6805, "quality": 1.0, "length": 18}, "so_25118191_25118838_1": {"section_id": 6870, "quality": 0.9444444444444444, "length": 17}}}});