post_cb({"36603734": {"ParentId": "36603628", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_36603628_36603734_0\">Why isn't the deleted copy constructor considered?</p>\n</blockquote>\n<p>It <em>is</em> considered. It's just not used, so the fact that it's <code>delete</code>d doesn't matter. That rule, from [dcl.fct.def.delete] is:</p>\n<blockquote>\n<p id=\"so_36603628_36603734_1\">A program that refers to a deleted function implicitly or explicitly, other than to declare it, is ill-formed.\n  <em>[ Note:</em> [...] If a function\n  is overloaded, it is referenced only if the function is selected by overload resolution. [...] <em>\u2014end note ]</em></p>\n</blockquote>\n<p>Overload resolution on <code>auto a = A{};</code> (braces vs parens is equivalent in this case) finds two constructor candidates:</p>\n<pre><code>A(const A&amp;);\nA(A&amp;&amp; );\n</code></pre>\n<p>One of the rules for choosing which candidate is the \"best viable\" candidate is, from [over.match.best]:</p>\n<blockquote>\n<p id=\"so_36603628_36603734_2\">Given these definitions, a viable function F1 is defined to be a better function than another viable function\n  F2 if [...], and then<br>\n  \u2014 [...]<br>\n  \u2014 the context is an initialization by conversion function for direct reference binding (13.3.1.6) of a reference\n  to function type, the return type of F1 is the same kind of reference (i.e. lvalue or rvalue) as the\n  reference being initialized, and the return type of F2 is not</br></br></p>\n</blockquote>\n<p>The move constructor is the same kind of reference (rvalue) as the parameter, whereas the copy constructor is not. Hence it's preferred and selected as the best viable candidate. Since <code>A(const A&amp;)</code> wasn't selected by overload resolution, we're not referring to that constructor, so the code is fine. </p>\n<p>If we actually used the copy constructor on the other hand (e.g. <code>A a(a5)</code>), <em>that</em> would actually attempt to use the copy constructor, which would be ill-formed. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2016-04-13T16:02:47.157", "Id": "36603734", "Score": "4", "CreationDate": "2016-04-13T15:57:40.097", "LastActivityDate": "2016-04-13T16:02:47.157"}, "36603628": {"CommentCount": "2", "AcceptedAnswerId": "36603734", "CreationDate": "2016-04-13T15:52:50.557", "LastActivityDate": "2016-04-13T16:02:47.157", "PostTypeId": "1", "ViewCount": "51", "FavoriteCount": "1", "Title": "Move constructor bypasses copy constructor", "Id": "36603628", "Score": "2", "Body": "<p>As expected the following does not compile:</p>\n<pre><code>class A {\npublic:\n    A() = default;\n    //A(A&amp;&amp;) = default;\n    A(const A&amp;) = delete;\n    int x;\n};\n\nint main()\n{\n    auto a4 = A{}; // not ok, copy constructor is deleted\n    auto a5 = A(); // not ok, copy constructor is deleted\n    return 0;\n}\n</code></pre>\n<p>But if a move constructor is added, even with the copy constructor explicitly deleted, then the following does compile:</p>\n<pre><code>class A {\npublic:\n    A() = default;\n    A(A&amp;&amp;) = default;\n    A(const A&amp;) = delete;\n    int x;\n};\n\nint main()\n{\n    auto a4 = A{}; // now ok, even though copy constructor is deleted\n    auto a5 = A(); // now ok, even though copy constructor is deleted\n    return 0;\n}\n</code></pre>\n<p>Why isn't the deleted copy constructor considered?</p>\n", "Tags": "<c++><constructor>", "OwnerUserId": "1460794", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_36603628_36603734_1": {"section_id": 3277, "quality": 0.8421052631578947, "length": 16}, "so_36603628_36603734_2": {"section_id": 603, "quality": 0.9428571428571428, "length": 33}}, "n3337": {"so_36603628_36603734_1": {"section_id": 3148, "quality": 0.8421052631578947, "length": 16}, "so_36603628_36603734_2": {"section_id": 593, "quality": 0.5714285714285714, "length": 20}}, "n4659": {"so_36603628_36603734_1": {"section_id": 4035, "quality": 0.8421052631578947, "length": 16}, "so_36603628_36603734_2": {"section_id": 629, "quality": 0.9428571428571428, "length": 33}}}});