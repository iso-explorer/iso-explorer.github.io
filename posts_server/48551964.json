post_cb({"48552383": {"Id": "48552383", "PostTypeId": "2", "Body": "<p>According to [intro.races]/20.2,</p>\n<blockquote>\n<p id=\"so_48551964_48552383_0\">The execution of a program contains a data race if it contains two potentially concurrent conflicting actions,\n  at least one of which is not atomic, and neither happens before the other, except for the special case for\n  signal handlers described below. Any such data race results in undefined behavior.</p>\n</blockquote>\n<p>According to [intro.races]/2,</p>\n<blockquote>\n<p id=\"so_48551964_48552383_1\">Two expression evaluations conflict if one of them modifies a memory location (4.4) and the other one reads\n  or modifies the same memory location.</p>\n</blockquote>\n<p>Accessing an atomic variable through a reference doesn't introduce any additional accesses or modifications, because references do not occupy memory locations. Therefore, performing potentially concurrent atomic operations is still safe when those operations occur through references.</p>\n<p>In fact, in the abstract model of evaluation in C++, there is no difference between accessing an object by its name and accessing an object through a reference variable bound to that object. Both are merely lvalues referring to the object.</p>\n<p>Beware of the <code>std::atomic_init</code> function, which is non-atomic:</p>\n<pre><code>std::atomic&lt;int&gt; x;\nvoid f(std::atomic&lt;int&gt;&amp; r) {\n    std::atomic_init(&amp;r, 0);\n}\nvoid g(std::atomic&lt;int&gt;&amp; r) {\n    r = 42;\n}\n</code></pre>\n<p>In the above code, if <code>f</code> and <code>g</code> run in separate threads and both access the atomic variable <code>x</code>, a data race can occur, because one of the operations is not atomic. However, this is no different from triggering the data race like so:</p>\n<pre><code>std::atomic&lt;int&gt; x;\nvoid f() {\n    std::atomic_init(&amp;x, 0);\n}\nvoid g() {\n    x = 42;\n}\n</code></pre>\n<p>where no references are involved.</p>\n", "LastActivityDate": "2018-01-31T22:18:30.483", "Score": "0", "CreationDate": "2018-01-31T22:18:30.483", "ParentId": "48551964", "CommentCount": "0", "OwnerUserId": "481267"}, "bq_ids": {"n4140": {"so_48551964_48552383_0": {"length": 29, "quality": 0.90625, "section_id": 5834}, "so_48551964_48552383_1": {"length": 14, "quality": 0.875, "section_id": 5817}}, "n3337": {"so_48551964_48552383_0": {"length": 20, "quality": 0.625, "section_id": 5605}, "so_48551964_48552383_1": {"length": 14, "quality": 0.875, "section_id": 5588}}, "n4659": {"so_48551964_48552383_0": {"length": 29, "quality": 0.90625, "section_id": 7296}, "so_48551964_48552383_1": {"length": 15, "quality": 0.9375, "section_id": 7278}}}, "48551964": {"ViewCount": "69", "Body": "<p>I am wondering if you can pass a an atomic by reference to a thread and for the .load and .store operations still be thread safe. For instance:</p>\n<pre><code>#include &lt;thread&gt;\n#include &lt;atomic&gt;\n#include &lt;cstdlib&gt;\n\nvoid addLoop(std::atomic_int&amp; adder)\n{\n    int i = adder.load();\n    std::srand(std::time(0));\n    while(i &lt; 200)\n    {\n        i = adder.load();\n        i += (i + (std::rand() % i));\n        adder.store(i);\n    }\n}\n\nvoid subLoop (std::atomic_int&amp; subber)\n{\n    int j = subber.load();\n    std::srand(std::time(0));\n    while(j &lt; 200)\n    {\n        j = subber.load();\n        j -= (j - (std::rand() % j));\n        subber.store(j);\n    }\n}\n\nint main()\n{\n    std::atomic_int dummyInt(1);\n    std::thread add(addLoop, std::ref(dummyInt));\n    std::thread sub(subLoop, std::ref(dummyInt));\n    add.join();\n    sub.join();\n    return 0;\n}\n</code></pre>\n<p>When the addLoop thread stores the new value into the atomic if subLoop were to access it using the load and store functions would it end up being an undefined state?</p>\n", "AcceptedAnswerId": "48552383", "Title": "C++ 11 can you safely pass and access std::atomics by reference in different threads", "CreationDate": "2018-01-31T21:45:42.530", "Id": "48551964", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2018-01-31T22:18:30.483", "Score": "0", "OwnerUserId": "8721191", "Tags": "<c++><multithreading><c++11><pass-by-reference><atomic>", "AnswerCount": "1"}});