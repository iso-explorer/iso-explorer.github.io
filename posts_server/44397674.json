post_cb({"44398280": {"ParentId": "44397674", "CommentCount": "5", "Body": "<p>Your program's behavior is <em>well-defined</em>, but <em>unspecified</em>.  The difference is that <code>v</code> has a valid state, you just don't know what that state is without inspecting it.</p>\n<p>This corner of the standard has been controversial, and the wording has been difficult to get right.  But I believe the latest wording (C++17) is our best attempt so far, so I will quote from that (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf\" rel=\"noreferrer\">N4660</a>).  </p>\n<p>Disclaimer, I actually linked to N4659 as N4660 is not publicly available.  The difference is inconsequential.</p>\n<p>From 20.5.5.15 <strong>Moved-from state of library types [lib.types.movedfrom]</strong></p>\n<blockquote>\n<p id=\"so_44397674_44398280_0\">1 Objects of types defined in the C++ standard library may be moved from (15.8). Move operations may be explicitly specified or implicitly generated. Unless otherwise specified, such moved-from objects shall be placed in a valid but unspecified state.</p>\n</blockquote>\n<p>This paragraph is a blanket statement for all types defined by the std::lib that moved-from objects are not \"poison\", you just don't know value they have.</p>\n<p>Furthermore, each algorithm (including member functions) defined in the standard may have a list of preconditions that must be true prior to calling that algorithm.  If there are no preconditions listed, that means that you can always call that function.</p>\n<p>Move assignment for all types defined in the std::lib never have any preconditions listed for the left or right hand side arguments.</p>\n<p>It is hard to quote something that doesn't exist, but that is the way this specification works.</p>\n<p>Generalizing further, the following section refers to <em>all</em> types (i.e. user-supplied) that are used with the std::lib:</p>\n<p><strong>20.5.3.1 Template argument requirements [utility.arg.requirements]</strong></p>\n<p>Table 23 \u2014 MoveConstructible requirements [moveconstructible]</p>\n<pre><code>T u = rv;\nT(rv);\n</code></pre>\n<p><code>rv</code>'s state is unspecified in the post-condition.</p>\n<p>Table 25 \u2014 MoveAssignable requirements [moveassignable]</p>\n<pre><code>t = rv\n</code></pre>\n<p>Only if <code>t</code> and <code>rv</code> do not refer to the same object, <code>t</code> is equivalent to the value of <code>rv</code> before the assignment.</p>\n<p>Afterwards, <code>rv</code>'s state is unspecified (whether or not <code>t</code> and <code>rv</code> refer to the same object).</p>\n<p>Furthermore this sections notes (notes are non-normative and often the normative text appears elsewhere) that <code>rv</code> must still meet the requirements of the library component (algorithm) it is being used with, even though it has been moved from.</p>\n<p>For example, std::sort is allowed to move from a value <code>x</code>, and then use that <code>x</code> in a comparison expression.  <code>x</code> must be LessThanComparable, whether or not <code>x</code> is moved-from.  Only <code>x</code>'s value is unspecified.</p>\n<pre><code>bool b = x &lt; x;  // b must be false, no matter what!\n</code></pre>\n", "OwnerUserId": "576911", "PostTypeId": "2", "Id": "44398280", "Score": "5", "CreationDate": "2017-06-06T19:25:17.327", "LastActivityDate": "2017-06-06T19:25:17.327"}, "bq_ids": {"n4140": {"so_44397674_44398280_0": {"section_id": 6365, "quality": 0.92, "length": 23}}, "n3337": {"so_44397674_44398280_0": {"section_id": 6122, "quality": 0.92, "length": 23}}, "n4659": {"so_44397674_44398280_0": {"section_id": 7876, "quality": 0.92, "length": 23}}}, "44397674": {"CommentCount": "2", "ViewCount": "105", "CreationDate": "2017-06-06T18:49:54.497", "LastActivityDate": "2017-06-06T19:25:17.327", "Title": "Moving from a moved-from object", "FavoriteCount": "1", "PostTypeId": "1", "Id": "44397674", "Score": "6", "Body": "<p>Consider the following code.</p>\n<pre><code>using T = std::string;\n\nvoid rotate_left(std::vector&lt;T&gt;&amp; v) {\n    T temp = std::move(v[0]);\n    for (size_t i=0; i+1 &lt; v.size(); ++i) {\n        v[i] = std::move(v[i+1]);\n    }\n    v.back() = std::move(temp);\n}\n\nint main()\n{\n    std::vector&lt;T&gt; v(3);  // a vector of three Ts\n    T x = std::move(v[1]);  // move-from the second element\n    rotate_left(v);\n    // Can we now say that v[0] is in a moved-from state, or did we\n    // get undefined behavior when we moved from v[1] a second time?\n}\n</code></pre>\n<p>The <code>rotate_left</code> function is just really simply shifting everything in the vector down by one position (and then putting the first element onto the end).  My question is, does this function have defined behavior when one of the elements in the vector is in a \"moved-from state\"?</p>\n<p>This is related but not quite the same as \"self-move\". In this case, we're moving from one moved-from object into another moved-from object, and my question is whether we can rely on this leaving both objects still in some moved-from state, or whether \"assignment-from\" is one of those operations that \"has a precondition\" and therefore can't be used on arbitrary moved-from objects.</p>\n<p>I'm well aware that</p>\n<ul>\n<li>this is perfectly fine for sane library types such as <code>unique_ptr</code></li>\n<li>this <em>will</em> be perfectly fine for my own user-defined types if I define them sanely</li>\n<li>this <em>will</em> be problematic for my own user-defined types if I define them insanely</li>\n<li>this is perfectly fine for all the library types I've tried on libstdc++ and libc++</li>\n</ul>\n<p>So what I'm really looking for is either:</p>\n<ul>\n<li>concrete wording from the Standard proving that this <em>must</em> be perfectly fine for all STL types going forward, or</li>\n<li>a concrete example of an STL or Boost type \"in the wild\" where this code is <em>definitely</em> problematic</li>\n</ul>\n<p>I infer from <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=59603\" rel=\"noreferrer\">this bug</a> that <code>_GLIBCXX_DEBUG</code> checks for self-move, but I can confirm that it does not check for move-from-moved; is this because they consider move-from-moved to be safe and legal, or just because nobody wrote the code to check for it yet?</p>\n", "Tags": "<c++><language-lawyer><move-semantics>", "OwnerUserId": "1424877", "AnswerCount": "1"}});