post_cb({"47311250": {"CommentCount": "11", "ViewCount": "71", "PostTypeId": "1", "LastEditorUserId": "8157187", "CreationDate": "2017-11-15T15:28:24.500", "LastActivityDate": "2017-11-15T18:33:04.780", "Title": "Explicitly setting active member in union in C++", "FavoriteCount": "0", "LastEditDate": "2017-11-15T17:14:07.313", "Id": "47311250", "Score": "2", "Body": "<p>The following code is the classical, infamous type-punning union. Similar code is legal in C99/C11 but illegal in C++, because one has to read from the inactive member.</p>\n<p>To activate the inactive member one has to write to it (that is not appropriate here) or to construct it via placement-new. </p>\n<p>The code below does exactly this: it initializes member <code>a</code> and then activates member <code>b</code> by placement-new. In case of an array of primitive types, the construction is actually a noop, and the bitvalues remain the same. </p>\n<p>I never saw this solution in the numerous other questions / answers to this topix, so I wonder if the code below in fact circumvents UB really.</p>\n<pre><code>#include &lt;cstdint&gt;\n#include &lt;cstddef&gt;\n#include &lt;utility&gt;\n#include &lt;array&gt;\n#include &lt;tuple&gt;\n#include &lt;cassert&gt;\n\nunion ByteUnion32 {\npublic:\n    explicit ByteUnion32(uint32_t v) : a{v}{\n        new (&amp;b) std::byte[sizeof(uint32_t)]; // set b active, but prevents constexpr, actually a noop\n    }\n    std::byte operator[](uint8_t i) const {\n            return b[i];\n    }\nprivate:\n    uint32_t a;\n    std::byte b[sizeof(uint32_t)];\n};\nint main(){\n    ByteUnion32 u10{0x01020304}; // initialise and activate byte-memebers\n    auto v10 = std::to_integer&lt;uint8_t&gt;(u10[0]);    \n    assert(v10 == 4);\n\n}\n</code></pre>\n", "Tags": "<c++><type-conversion><language-lawyer><unions><placement-new>", "OwnerUserId": "3359751", "AnswerCount": "2"}, "47313934": {"ParentId": "47311250", "CommentCount": "11", "CreationDate": "2017-11-15T17:37:47.557", "OwnerUserId": "3359751", "PostTypeId": "2", "Id": "47313934", "Score": "0", "Body": "<p>Instead of using a union to provide both conversion direction, the following maybe a solution in C++ using two specializations for the conversion directions <code>std::byte</code> to larger integer-type or integer-type to <code>std::byte</code>.</p>\n<pre><code>#include &lt;cstdint&gt;\n#include &lt;cstddef&gt;\n#include &lt;utility&gt;\n#include &lt;array&gt;\n#include &lt;tuple&gt;\n#include &lt;cassert&gt;\n#include &lt;cstring&gt;\n\nnamespace std {\n    enum class endian { // since c++20\n#ifdef _WIN32\n        little = 0,\n        big    = 1,\n        native = little\n#else\n        little = __ORDER_LITTLE_ENDIAN__,\n        big    = __ORDER_BIG_ENDIAN__,\n        native = __BYTE_ORDER__\n#endif\n    };\n    namespace literals {\n        constexpr byte operator\"\" _byte(unsigned long long v) { // &lt;&gt; Literal-Operator for suffix `_byte`\n            return byte{static_cast&lt;uint8_t&gt;(v)};\n        }\n    }\n}\n\ntemplate&lt;typename T&gt;\nrequires (std::is_same&lt;uint64_t, T&gt;::value || std::is_same&lt;uint32_t, T&gt;::value || std::is_same&lt;uint16_t, T&gt;::value) &amp;&amp; (sizeof(T) &gt; 1)\nstruct ByteUnion&lt;ByteToIntegral, T&gt; {\npublic:\n    template&lt;typename... B&gt;\n    requires (std::is_same&lt;B, std::byte&gt;::value || ...) &amp;&amp; (sizeof...(B) == sizeof(T))\n    explicit ByteUnion(B... vv) : ByteUnion{endian_type{}, std::index_sequence_for&lt;B...&gt;{}, vv...} {}\n\n    const T&amp; value() const {return a;}     \nprivate:\n    template&lt;size_t... II, typename... B&gt;\n    explicit ByteUnion(LittleEndian, std::index_sequence&lt;II...&gt;, B&amp;&amp;... vv) {\n        uint8_t* p = reinterpret_cast&lt;uint8_t*&gt;(&amp;a);\n        ((p[sizeof...(II) - 1 - II] = static_cast&lt;uint8_t&gt;(vv)),...);    \n    }\n    template&lt;size_t... II, typename... B&gt;\n    explicit ByteUnion(BigEndian, std::index_sequence&lt;II...&gt;, B&amp;&amp;... vv) {\n        uint8_t* p = reinterpret_cast&lt;uint8_t*&gt;(&amp;a);\n        ((p[II] = static_cast&lt;uint8_t&gt;(vv)),...);\n    }\n    T a;\n};\n\nusing namespace std::literals;\n\nint main(){\n    ByteUnion&lt;IntegralToByte, uint64_t&gt; u1{0x01020304}; // initialise and activate byte-memebers\n//    ByteUnion&lt;ByteToIntegral, uint64_t&gt; u1x{0x01020304}; // not possible\n    auto v1 = std::to_integer&lt;uint8_t&gt;(u1[0]);    \n//    u1.value(); // not possible, who access inactive member\n    assert(v1 == 4);\n\n    ByteUnion&lt;ByteToIntegral, uint32_t&gt; u2{0x01_byte, 0x02_byte, 0x03_byte, 0x04_byte}; // initialise and activate integral value member\n//    ByteUnion&lt;IntegralToByte, uint32_t&gt; u2x{0x01_byte, 0x02_byte, 0x03_byte, 0x04_byte}; // not possible\n    auto v2 = u2.value(); \n    assert(v2 == 0x01020304);\n//    u2[0];\n\n}\n</code></pre>\n", "LastActivityDate": "2017-11-15T17:37:47.557"}, "bq_ids": {"n4140": {"so_47311250_47314810_0": {"section_id": 3291, "quality": 0.9444444444444444, "length": 34}}, "n4659": {"so_47311250_47314810_0": {"section_id": 4053, "quality": 0.9444444444444444, "length": 34}}}, "47314810": {"ParentId": "47311250", "CommentCount": "0", "CreationDate": "2017-11-15T18:33:04.780", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "47314810", "Score": "1", "Body": "<p>From <a href=\"http://eel.is/c++draft/dcl.init#12\" rel=\"nofollow noreferrer\">[dcl.init]/12</a>:</p>\n<blockquote>\n<p id=\"so_47311250_47314810_0\">If no initializer is specified for an object, the object is default-initialized. When storage for an object with automatic or dynamic storage duration is obtained, the object has an <em>indeterminate value</em>, and if no initialization is performed for the object, that object retains an indeterminate value until that value is replaced ([expr.ass]). [...] If an indeterminate value is produced by an evaluation, the behavior is undefined except in the following cases: [...]</p>\n</blockquote>\n<p>In this code:</p>\n<pre><code>assert(v10 == 4);\n</code></pre>\n<p>Either the initialization of <code>v10</code> itself is undefined behavior due to not fitting any of the bullet points (I'm not entirely sure about this), or the initialization of <code>v10</code> is fine and it just is considered to have indeterminate value, at which point the ultimate comparison to <code>4</code> is undefined behavior.</p>\n<p>Either way, this is undefined behavior.</p>\n", "LastActivityDate": "2017-11-15T18:33:04.780"}});