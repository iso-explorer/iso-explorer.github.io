post_cb({"35134633": {"CommentCount": "5", "ViewCount": "81", "CreationDate": "2016-02-01T15:49:36.377", "LastActivityDate": "2016-02-01T16:37:15.820", "Title": "Identification of Data Types in C / C++", "AcceptedAnswerId": "35134977", "PostTypeId": "1", "Id": "35134633", "Score": "-4", "Body": "<p>I have used the below simple code:</p>\n<pre><code>#define char long long int\nint main()\n{\n    cout&lt;&lt;sizeof(char) &lt;&lt; endl;\n    // want to use char as a 1 byte data type\n}\n</code></pre>\n<p>I have the idea that if <code>#define</code> is used in a program then definition is expanded in the compile time. But, now if I want to use <code>char</code> as a 1 byte data types then what should I do ? Is it possible ? </p>\n", "Tags": "<c++>", "OwnerUserId": "2315473", "AnswerCount": "3"}, "35134773": {"ParentId": "35134633", "CommentCount": "1", "Body": "<p>Once you <code>#define</code> something, it stays defined to that value for the rest of the compilation unit.</p>\n<p>During a specific compilation unit, you can undo your <code>#define</code> with an <code>#undef</code>.</p>\n<p>I'm sure you don't need to be told that using <code>#define</code> to change a keyword's behaviour is pernicious.</p>\n", "OwnerUserId": "2380830", "PostTypeId": "2", "Id": "35134773", "Score": "1", "CreationDate": "2016-02-01T15:55:43.747", "LastActivityDate": "2016-02-01T15:55:43.747"}, "35134708": {"ParentId": "35134633", "CommentCount": "0", "Body": "<p>You have to use</p>\n<pre><code>#undef char\n</code></pre>\n<p>and after that, you can use char as you want.</p>\n<p>But it's really dangerous to redefine keyword with macro.</p>\n", "OwnerUserId": "3932569", "PostTypeId": "2", "Id": "35134708", "Score": "1", "CreationDate": "2016-02-01T15:53:07.960", "LastActivityDate": "2016-02-01T15:53:07.960"}, "bq_ids": {"n4140": {"so_35134633_35134977_2": {"section_id": 6304, "quality": 0.5384615384615384, "length": 14}}, "n3337": {"so_35134633_35134977_2": {"section_id": 6061, "quality": 0.5384615384615384, "length": 14}}, "n4659": {"so_35134633_35134977_2": {"section_id": 7814, "quality": 0.5384615384615384, "length": 14}}}, "35134977": {"ParentId": "35134633", "PostTypeId": "2", "CommentCount": "3", "Body": "<p><strong>17.6.4.3.1 Macro names [macro.names]</strong></p>\n<blockquote>\n<p id=\"so_35134633_35134977_0\">1 A translation unit that includes a standard library header shall not #define or #undef names declared in any standard library header.<br>\n  2 A translation unit shall not #define or #undef names lexically identical to keywords.</br></p>\n</blockquote>\n<p>So whatever you do after your define, program semantics is undefined anyway.</p>\n<p><strong>UPDATE</strong>:\nTechnically behavior is undefined only when you include any header from standard library. You seem to do so, as you are using cout. Anyway not including any standard header is a very heavy constraint.</p>\n<p>The previous standard quotation is preceded with:</p>\n<blockquote>\n<p id=\"so_35134633_35134977_1\">17.6.4.3 Reserved names [reserved.names]</p>\n<p id=\"so_35134633_35134977_2\">1 The C ++ standard library reserves the following kinds of names:<br>\n  \u2014 macros<br>\n  \u2014 global names<br>\n  \u2014 names with external linkage<br>\n  2 If a program declares or defines a name in a context where it is reserved, other than as explicitly allowed by this Clause, its behavior is undefined.</br></br></br></br></p>\n</blockquote>\n", "OwnerUserId": "113662", "LastEditorUserId": "113662", "LastEditDate": "2016-02-01T16:37:15.820", "Id": "35134977", "Score": "3", "CreationDate": "2016-02-01T16:05:44.533", "LastActivityDate": "2016-02-01T16:37:15.820"}});