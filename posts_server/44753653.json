post_cb({"44753653": {"CommentCount": "0", "ViewCount": "54", "CreationDate": "2017-06-26T05:40:20.330", "LastActivityDate": "2017-06-26T07:16:27.993", "Title": "Static initializers of unused global", "AcceptedAnswerId": "44753852", "PostTypeId": "1", "Id": "44753653", "Score": "3", "Body": "<p>If I have a global with internal linkage that is never used, is its initializer guaranteed to run? For example:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>static int x = SideEffectfulFunction();\n</code></pre>\n<p>or</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>namespace {\n    int x = SideEffectfulFunction();\n}\n</code></pre>\n<p>Is <code>SideEffectfulFunction()</code> guaranteed to be called, even if <code>x</code> is never referenced? Or is it legal for <code>x</code> to be removed?</p>\n", "Tags": "<c++><static-initialization>", "OwnerUserId": "8213872", "AnswerCount": "2"}, "44753852": {"ParentId": "44753653", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Yes, the standard guarantees this</p>\n<p><strong>Static storage duration [basic.stc.static]</strong></p>\n<blockquote>\n<p id=\"so_44753653_44753852_0\">2 If a variable with static storage duration has initialization or a destructor with side effects, it shall not be eliminated even if it appears to be unused, except that a class object or its copy/move may be eliminated as specified in 15.8.</p>\n</blockquote>\n", "OwnerUserId": "5501675", "LastEditorUserId": "5501675", "LastEditDate": "2017-06-26T07:16:27.993", "Id": "44753852", "Score": "9", "CreationDate": "2017-06-26T06:03:57.893", "LastActivityDate": "2017-06-26T07:16:27.993"}, "bq_ids": {"n4140": {"so_44753653_44753852_0": {"section_id": 7165, "quality": 0.9523809523809523, "length": 20}}, "n3337": {"so_44753653_44753852_0": {"section_id": 6909, "quality": 0.9523809523809523, "length": 20}}, "n4659": {"so_44753653_44753852_0": {"section_id": 8673, "quality": 0.9523809523809523, "length": 20}}}, "44753864": {"ParentId": "44753653", "CommentCount": "0", "Body": "<p>It is guaranteed to run. If you are creating more than one static object that reference each other in different source files there is no guarantee in which order the objects would be initialized, this is known as the <code>static initialization order fiasco</code> in which case you can create a function which creates the static object, ensuring that the order of initialization is function object first, then the secondary object.</p>\n<p>Source:\n<a href=\"https://isocpp.org/wiki/faq/ctors#static-init-order\" rel=\"nofollow noreferrer\">https://isocpp.org/wiki/faq/ctors#static-init-order</a></p>\n", "OwnerUserId": "7144080", "PostTypeId": "2", "Id": "44753864", "Score": "0", "CreationDate": "2017-06-26T06:04:57.547", "LastActivityDate": "2017-06-26T06:04:57.547"}});