post_cb({"bq_ids": {"n4140": {"so_2371176_2371368_0": {"length": 14, "quality": 0.6363636363636364, "section_id": 435}, "so_2371176_2371368_2": {"length": 16, "quality": 1.0, "section_id": 404}}, "n3337": {"so_2371176_2371368_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 427}, "so_2371176_2371368_2": {"length": 16, "quality": 1.0, "section_id": 395}}, "n4659": {"so_2371176_2371368_0": {"length": 14, "quality": 0.6363636363636364, "section_id": 454}, "so_2371176_2371368_2": {"length": 16, "quality": 1.0, "section_id": 422}}}, "2371327": {"Id": "2371327", "PostTypeId": "2", "Body": "<p>Virtual base classes are always initialized from the most derived classes (C here).  The compiler has to check that the constructor is accessible (i.e. I get an error with g++ 3.4 for</p>\n<pre><code>class A { public: A(int) {} };\nclass B: private virtual A {public: B() : A(0) {} };\nclass C: public B {};\n\nint main() {\n    C c;\n    return 0;\n}\n</code></pre>\n<p>while your description implies there is none) but the fact that as a base, A is private or not doesn't matter (to subvert would be easy: <code>class C: public B, private virtual A</code>).</p>\n<p>The reason for which the virtual base classes constructors are called from the most derived class is that it needs to be constructed before any classes having them as a base class.</p>\n<p>Edit: Kirill mentioned an old core issue which is at odd with my reading and the behavior of recent compilers. I'll try to get standard references in one way or the other, but that can takes time.</p>\n", "LastEditorUserId": "136208", "LastActivityDate": "2010-03-03T13:01:47.690", "Score": "2", "CreationDate": "2010-03-03T12:52:54.007", "ParentId": "2371176", "CommentCount": "2", "OwnerUserId": "136208", "LastEditDate": "2010-03-03T13:01:47.690"}, "2371176": {"ViewCount": "3238", "Body": "<p>In the following code, it seems class C does not have access to A's constructor, which is required because of the virtual inheritance. Yet, the code still compiles and runs. Why does it work?</p>\n<pre><code>class A {};\nclass B: private virtual A {};\nclass C: public B {};\n\nint main() {\n    C c;\n    return 0;\n}\n</code></pre>\n<p>Moreover, if I remove the default constructor from A, e.g.</p>\n<pre><code>class A {\npublic:\n    A(int) {}\n};\nclass B: private virtual A {\npublic:\n    B() : A(3) {}\n};\n</code></pre>\n<p>then</p>\n<pre><code>class C: public B {};\n</code></pre>\n<p>would (unexpectedly) compile, but</p>\n<pre><code>class C: public B {\npublic:\n    C() {}\n};\n</code></pre>\n<p>would not compile, as expected.</p>\n<p>Code compiled with \"g++ (GCC) 3.4.4 (cygming special, gdc 0.12, using dmd 0.125)\", but it has been verified to behave the same with other compilers as well.</p>\n", "AcceptedAnswerId": "2371324", "Title": "C++ private virtual inheritance problem", "CreationDate": "2010-03-03T12:29:52.987", "Id": "2371176", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-08-04T16:45:32.523", "LastEditorUserId": "963864", "LastActivityDate": "2012-08-04T16:45:32.523", "Score": "18", "OwnerUserId": "242762", "Tags": "<c++><inheritance><encapsulation><virtual-inheritance><private-inheritance>", "AnswerCount": "3"}, "2371368": {"Id": "2371368", "PostTypeId": "2", "Body": "<p>For the second question, it is probably because you don't cause it to be implicitly <em>defined</em>. If the constructor is merely implicitly declared, there is no error. Example:</p>\n<pre><code>struct A { A(int); };\nstruct B : A { };\n// goes fine up to here\n\n// not anymore: default constructor now is implicitly defined \n// (because it's used)\nB b;\n</code></pre>\n<p>For your first question - it depends on what name the compiler uses. I have no idea what the standard specifies, but this code for instance is correct because the outer class name (instead of the inherited class name) is accessible:</p>\n<pre><code>class A {};\nclass B: private virtual A {};\nclass C: public B { C(): ::A() { } }; // don't use B::A\n</code></pre>\n<p>Maybe the Standard is underspecified at this point. We'll have to look. </p>\n<hr>\n<p>There does not seem to be any problem with the code. Furthermore, there is indication that the code is valid. The (virtual) base class subobject is default initialized - there is no text that implies that name lookup for the class name is dine inside the scope of <code>C</code>. Here is what the Standard says:</p>\n<p><code>12.6.2/8</code> (C++0x)</p>\n<blockquote>\n<p id=\"so_2371176_2371368_0\">If a given non-static data member or base class is not named by a mem-initializer-id (including the case\n  where there is no mem-initializer-list because the constructor has no ctor-initializer) and the entity is not a virtual base class of an abstract class  </p>\n<p id=\"so_2371176_2371368_1\">[...] otherwise, the entity is default-initialized</p>\n</blockquote>\n<p>And C++03 has similar text (thou less clear text - it simply says its default constructor is called at one place, and at another it makes it dependent on whether the class is a POD). For the compiler to default initialize the subobject, it just has to call its default constructor - there is no need to lookup the name of the base class first (it <em>already knows</em> what base is considered).  </p>\n<p>Consider this code that certainly is intended to be valid, but that would fail if this <em>would</em> be done (see <code>12.6.2/4</code> in C++0x)</p>\n<pre><code>struct A { };\nstruct B : virtual A { };\nstruct C : B, A { };\nC c;\n</code></pre>\n<p>If the compiler's default constructor would simply look-up class name <code>A</code> inside of <code>C</code>, it would have an ambiguous lookup result with regard to what subobject to initialize, because both the non-virtual <code>A</code> and the virtual <code>A</code>'s class-names are found. If your code is intended to be ill-formed, i would say the Standard certainly needs to be clarified. </p>\n<hr>\n<p>For the constructor, notice what <code>12.4/6</code> says about the destructor of <code>C</code>:</p>\n<blockquote>\n<p id=\"so_2371176_2371368_2\">All destructors are called as if they were referenced with a qualified name, that is, ignoring any possible virtual overriding destructors in more derived classes. </p>\n</blockquote>\n<p>This can be interpreted in two ways:</p>\n<ul>\n<li>calling A::~A()</li>\n<li>calling ::A::~A()</li>\n</ul>\n<p>It seems to me that the Standard is less clear here. The second way would make it valid (by <code>3.4.3/6</code>, C++0x, because both class-names <code>A</code> are looked up in global scope), while the first will make it invalid (because both <code>A</code> will find the inherited class names). It also depends what subobject the search starts with (and i believe we will have to use the virtual base class' subobject as start point). If this goes like</p>\n<pre><code>virtual_base -&gt; A::~A();\n</code></pre>\n<p>Then we will directly find the virtual base' class name as a public name, because we won't have to go through the derived class' scopes and find the name as non-accessible. Again, the reasoning is similar. Consider:</p>\n<pre><code>struct A { };\nstruct B : A { };\nstruct C : B, A {\n} c;\n</code></pre>\n<p>If the destructor would simply call <code>this-&gt;A::~A()</code>, this call would not be valid because of the ambiguous lookup result of <code>A</code> as an inherited class name (you cannot refer to any non-static member-function of the direct base class object from the scope <code>C</code>, see <code>10.1/3</code>, C++03). It will uniquely have to identify the class names that are involved, and has to start with the class' subobject reference like <code>a_subobject-&gt;::A::~A();</code>. </p>\n</hr></hr>", "LastEditorUserId": "34509", "LastActivityDate": "2010-03-03T13:55:51.020", "Score": "6", "CreationDate": "2010-03-03T13:00:30.680", "ParentId": "2371176", "CommentCount": "15", "OwnerUserId": "34509", "LastEditDate": "2010-03-03T13:55:51.020"}, "2371324": {"Id": "2371324", "PostTypeId": "2", "Body": "<p>According to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#7\" rel=\"noreferrer\">C++ Core Issue #7</a> class with a virtual private base can't be derived from. This is a bug in compiler.</p>\n", "LastEditorUserId": "123111", "LastActivityDate": "2010-03-03T13:16:06.877", "Score": "13", "CreationDate": "2010-03-03T12:52:09.337", "ParentId": "2371176", "CommentCount": "6", "OwnerUserId": "123111", "LastEditDate": "2010-03-03T13:16:06.877"}});