post_cb({"bq_ids": {"n4140": {"so_24130395_24130657_1": {"length": 23, "quality": 0.92, "section_id": 6365}, "so_24130395_24130657_3": {"length": 15, "quality": 0.9375, "section_id": 4279}}, "n3337": {"so_24130395_24130657_1": {"length": 23, "quality": 0.92, "section_id": 6122}, "so_24130395_24130657_3": {"length": 15, "quality": 0.9375, "section_id": 4120}}, "n4659": {"so_24130395_24130657_1": {"length": 23, "quality": 0.92, "section_id": 7876}, "so_24130395_24130657_3": {"length": 15, "quality": 0.9375, "section_id": 5535}}}, "24130657": {"Id": "24130657", "PostTypeId": "2", "Body": "<p>Generally what happens is described in the standard as:</p>\n<blockquote>\n<p id=\"so_24130395_24130657_0\">\u00a717.6.5.15.1 <strong>Moved-from state of library types</strong> [lib.types.movedfrom]</p>\n<p id=\"so_24130395_24130657_1\">Objects of types defined in the C++ standard library may be moved from (12.8). Move operations may be explicitly specified or implicitly generated. Unless otherwise specified, such moved-from objects shall be placed in a valid but unspecified state.</p>\n</blockquote>\n<p>The standard actually specifically describe the behavior of <code>std::unique_ptr</code> in:</p>\n<blockquote>\n<p id=\"so_24130395_24130657_2\">\u00a720.8.1.4 <strong>Class template unique_ptr</strong> [unique.ptr]</p>\n<p id=\"so_24130395_24130657_3\">Additionally, <code>u</code> can, upon request, transfer ownership to another unique pointer <code>u2</code>. Upon completion of such a transfer, the following postconditions hold:</p>\n<ul>\n<li>u2.p is equal to the pre-transfer u.p,</li>\n<li>u.p is equal to nullptr, and</li>\n<li>if the pre-transfer u.d maintained state, such state has been transferred to u2.d.</li>\n</ul>\n</blockquote>\n<p>Specifically, <code>dep</code>, after the construction of the <code>Foo</code> sub-object at:</p>\n<pre><code>Foo(std::move(dep))\n</code></pre>\n<p>is a <code>nullptr</code>.</p>\n<p>Moreover if <code>dep</code> was still a valid pointer, <code>Foo(std::move(dep))</code> would have copied <code>dep</code>, which doesn't make sense for <code>std::unique_ptr</code>'s semantic (as it is non-copyable).</p>\n<p>What you want to do is let a reference to the pointed object, with the due considerations of the case (for example, can the unique_ptr be <code>nullpt</code>? etc..), in <code>Foo</code>:</p>\n<pre><code>class Foo {\npublic:\n    Foo(unique_ptr&lt;Dep&gt; dep) : dep_(dep) {}\n    const Dep&amp; get_dep() const { return *dep_; }\n    Dep&amp; get_dep()             { return *dep_; }\nprivate:\n    std::unique_ptr&lt;Dep&gt; dep_;\n};\n</code></pre>\n<p>and then simply construct the <code>TestFoo</code> object as:</p>\n<pre><code>TestFoo(unique_ptr&lt;MockDep&gt; dep) : Foo(std::move(dep)) {}\n</code></pre>\n", "LastEditorUserId": "493122", "LastActivityDate": "2014-06-09T23:39:13.083", "Score": "1", "CreationDate": "2014-06-09T23:32:43.950", "ParentId": "24130395", "CommentCount": "1", "LastEditDate": "2014-06-09T23:39:13.083", "OwnerUserId": "493122"}, "24130395": {"ViewCount": "176", "Body": "<p>Perhaps I was trying to be too generic. (Original question below) Concretely, I have some dependency <code>Dep</code> of a class <code>Foo</code>. I also have a class <code>MockDep</code> and am defining a class <code>TestFoo</code>. Here is its constructor I tried to write:</p>\n<pre><code>TestFoo(unique_ptr&lt;MockDep&gt; dep) : Foo(std::move(dep)), mock_dep_(dep.get()) {}\n</code></pre>\n<p>And <code>Foo</code>'s constructor looks like:</p>\n<pre><code>Foo(unique_ptr&lt;Dep&gt; dep) : dep_(dep) {}\n</code></pre>\n<p><code>mock_dep_</code> is delcared in <code>TestFoo</code> as <code>MockDep* mock_dep_</code>, and <code>dep_</code> is declared in <code>Foo</code> as <code>unique_ptr&lt;Dep&gt; dep_</code>. How can I get <code>mock_dep_</code> to contain <code>dep_</code>'s address? (as the above doesn't work since <code>std::move(dep)</code> nulls out <code>dep</code>.)</p>\n<hr>\n<p><strong>Original post:</strong></p>\n<p>I have an object of type <code>Foo</code> that I'm to pass to a different object of type <code>OtherObject</code> which claims ownership of it, but as a pointer to its base class. However, I want to grab a pointer to the child object that I can use to reference it. I wrote something like:</p>\n<pre><code>Foo(std::unique_ptr&lt;Child&gt; thing) :\n    OtherObject(std::move(thing)), child_(thing.get()) {}\n\nOtherObject(std::unique_ptr&lt;Base&gt; thing, ...) { ... }\n</code></pre>\n<p>However, this doesn't seem to work, as the <code>std::move(thing)</code> seems to null out the pointer that returns from <code>thing.get()</code> later.</p>\n<p>I can change <code>Foo</code>'s parameter to be of type <code>Child*</code> instead of <code>unique_ptr&lt;Child&gt;</code>, but I'd prefer to be able to do the latter as it explicitly documents the ownership semantics.</p>\n<p>What's the most appropriate (or failing that, unobtrusive) way of resolving this?</p>\n<p><strong>edit</strong>: <code>Foo</code> and <code>OtherObject</code> are both meant to be classes whose constructors I'm defining.</p>\n</hr>", "Title": "unique_ptr ownership semantics", "CreationDate": "2014-06-09T23:03:16.617", "LastActivityDate": "2014-06-10T00:51:23.573", "CommentCount": "5", "LastEditDate": "2014-06-09T23:23:27.010", "PostTypeId": "1", "LastEditorUserId": "598940", "Id": "24130395", "Score": "5", "OwnerUserId": "598940", "Tags": "<c++><smart-pointers><unique-ptr><ownership-semantics>", "AnswerCount": "2"}, "24130441": {"Id": "24130441", "PostTypeId": "2", "Body": "<p>You may use:</p>\n<pre><code>Foo(std::unique_ptr&lt;Child&gt; thing) :\n    OtherObject(std::move(thing)),\n    child_(OtherObject.getChildPtr()) /* one accessor to get the pointer. */\n{}\n</code></pre>\n<p>If base object <code>OtherObject</code> doesn't provide an accessor to the pointer, you may delegate the constructor to an other constructor, something like:</p>\n<pre><code>class Foo: public OtherObject\n{\npublic:\n    Foo(std::unique_ptr&lt;Child&gt; thing) : Foo(thing, thing.get()) {}\n\nprivate:\n    Foo(std::unique_ptr&lt;Child&gt;&amp; thing, Child* child) :\n        OtherObject(std::move(thing)),\n        child_(child)\n    {}\nprivate:\n    Child* child_;\n};\n</code></pre>\n<p>A third solution would be to change the order between <code>OtherObject</code> and <code>child_</code> (to have <code>child_</code> before) by introducing an other derivation:</p>\n<pre><code>class ChildPtr\n{\npublic:\n    ChildPtr(Child* child) : child_(child) {}\n\n    Child* child_;\n};\n\nclass Foo: private ChildPtr, public OtherObject\n{\npublic:\n    Foo(std::unique_ptr&lt;Child&gt; thing) :\n        ChildPtr(thing.get()),\n        OtherObject(std::move(thing))\n    {}\n};\n</code></pre>\n", "LastEditorUserId": "2684539", "LastActivityDate": "2014-06-10T00:51:23.573", "Score": "6", "CreationDate": "2014-06-09T23:06:43.023", "ParentId": "24130395", "CommentCount": "4", "LastEditDate": "2014-06-10T00:51:23.573", "OwnerUserId": "2684539"}});