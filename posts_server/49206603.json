post_cb({"49207203": {"Id": "49207203", "PostTypeId": "2", "Body": "<p>Yes, but be very be careful cause each thread may using the same resource and leading to \"data racing\". You should use \"mutex\" or another machanism to sysnchronize\nEx: Without mutex</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;vector&gt;\n#include&lt;thread&gt;\n\nstatic std::vector&lt;std::string&gt; glm;\nvoid addMap(std::vector&lt;std::string&gt; &amp;glm, std::string name)\n{\n    glm.push_back(name);\n    std::cout &lt;&lt; \"Add: \" &lt;&lt; name &lt;&lt; \"\\n\";\n}\n\nint main()\n{\n    std::thread t[4];\n    std::vector &lt; std::string&gt; names = { \"Hellen\", \"Peter\", \"Bob\", \"Zoe\" };\n\n    for(int i = 0; i &lt; names.size(); i++)\n    {\n        t[i] = std::thread(addMap, glm, names[i]);\n    }\n\n    for(int i = 0; i &lt; names.size(); i++)\n    {\n        t[i].join();\n    }\n}\n</code></pre>\n<p>As example above, we expect it will print:\nAdd: Hellen\nAdd: Peter\nAdd: Bob\nAdd: Zoe</p>\n<p>But it's NOT. Sometimes, it will print not enough names, sometimes the order is different.\nExample with mutex:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;vector&gt;\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\nstatic std::vector&lt;std::string&gt; glm;\nstd::mutex mut;\nvoid addMap(std::vector&lt;std::string&gt; &amp;glm, std::string name)\n{\n    mut.lock();\n    glm.push_back(name);\n    std::cout &lt;&lt; \"Add: \" &lt;&lt; name &lt;&lt; \"\\n\";\n    mut.unlock();\n}\n\n\nint main()\n{\n    std::thread t[4];\n    std::vector &lt; std::string&gt; names = { \"Hellen\", \"Peter\", \"Bob\", \"Zoe\" };\n\n    for(int i = 0; i &lt; names.size(); i++)\n    {\n        t[i] = std::thread(addMap, glm, names[i]);\n    }\n\n    for(int i = 0; i &lt; names.size(); i++)\n    {\n        t[i].join();\n    }\n}\n</code></pre>\n<p>Be very careful when coding with multithread</p>\n", "LastActivityDate": "2018-03-10T08:54:20.573", "Score": "-1", "CreationDate": "2018-03-10T08:54:20.573", "ParentId": "49206603", "CommentCount": "5", "OwnerUserId": "8330838"}, "bq_ids": {"n4140": {"so_49206603_49209586_3": {"length": 16, "quality": 1.0, "section_id": 5812}}, "n3337": {"so_49206603_49209586_3": {"length": 16, "quality": 1.0, "section_id": 5585}}, "n4659": {"so_49206603_49209586_3": {"length": 16, "quality": 1.0, "section_id": 7275}}}, "49206603": {"ViewCount": "49", "Body": "<p>It is possible to <em>pass</em> an argument to a function running in another thread, by <strong>reference</strong>.</p>\n<p>Is it possible to <em>return</em> a result from a function running in another thread, by <strong>reference</strong>. If so, how?</p>\n", "Title": "How to return a result from a thread by reference?", "CreationDate": "2018-03-10T07:43:11.227", "LastActivityDate": "2018-03-10T13:40:40.103", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "Id": "49206603", "Score": "0", "OwnerUserId": "9102144", "Tags": "<c++>", "AnswerCount": "2"}, "49209586": {"Id": "49209586", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_49206603_49209586_0\">It is possible to pass an argument to a function running in another\n  thread, by reference.</p>\n</blockquote>\n<p>Not directly, because all arguments are copied or moved into the other thread, but you can simulate reference passing with <code>std::ref</code> or <code>std::cref</code>. See <a href=\"http://en.cppreference.com/w/cpp/thread/thread/thread\" rel=\"nofollow noreferrer\"><code>std::thread</code> constructor documentation</a>:</p>\n<blockquote>\n<p id=\"so_49206603_49209586_1\">The arguments to the thread function are moved or copied by value. If\n  a reference argument needs to be passed to the thread function, it has\n  to be wrapped (e.g. with <code>std::ref</code> or <code>std::cref</code>).</p>\n</blockquote>\n<p>And of course, you have to make sure that the referenced object isn't destructed before the other thread is done using it.</p>\n<p>Here's a small example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;thread&gt;\n\nvoid f(int&amp; x)\n{\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\n}\n\nint main()\n{\n    int a = 1;\n    std::thread t(f, std::ref(a));\n    t.join();\n    // safe, because `a` still exists at this point,\n    // but the thread is already finished\n}\n</code></pre>\n<blockquote>\n<p id=\"so_49206603_49209586_2\">Is it possible to return a result from a function running in another\n  thread, by reference.</p>\n</blockquote>\n<p>No.</p>\n<p>First of all, that wouldn't make sense, because it would defeat the purpose of threads if the caller was blocked waiting for the called function to return (however, see below).</p>\n<p>Second, that's just not how threads work. As the C++ standard says at \u00a74.7/1 <code>[intro.multithread]</code>:</p>\n<blockquote>\n<p id=\"so_49206603_49209586_3\">When one thread creates another, the initial call to the top-level\n  function of the new thread is executed by the new thread, not by the\n  creating thread.</p>\n</blockquote>\n<p>In other words, every thread has \"its own stack\". This is completely different from using functions in the same thread. You cannot use <code>return</code> to return anything from a new thread to the original thread.</p>\n<p>You indirectly \"return\" something by the other thread setting data accessible to the original thread. You can do that via a simulated reference if you want to:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;thread&gt;\n\nvoid f(int&amp; x, int&amp; result)\n{\n    result = x * x;\n}\n\nint main()\n{\n    int a = 2;\n    int result;\n    std::thread t(f, std::ref(a), std::ref(result));\n    t.join();\n    std::cout &lt;&lt; result &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Outside of such toy examples, the shared data will more realistically be a <code>std::atomic</code> or be guarded by <code>std::mutex</code> / <code>std::scoped_lock</code> et al.</p>\n<hr>\n<p>That being said, you should definitely have a look at <a href=\"http://en.cppreference.com/w/cpp/thread/future\" rel=\"nofollow noreferrer\"><code>std::future</code></a>. Futures don't change the way threads work internally, but they provide an abstraction layer which resembles a normal function-call stack.</p>\n</hr>", "LastEditorUserId": "3313064", "LastActivityDate": "2018-03-10T13:40:40.103", "Score": "3", "CreationDate": "2018-03-10T13:25:27.900", "ParentId": "49206603", "CommentCount": "2", "OwnerUserId": "3313064", "LastEditDate": "2018-03-10T13:40:40.103"}});