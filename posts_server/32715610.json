post_cb({"bq_ids": {"n4140": {"so_32715610_32716199_2": {"length": 23, "quality": 1.0, "section_id": 5861}, "so_32715610_32716199_1": {"length": 21, "quality": 1.0, "section_id": 5857}, "so_32715610_32716199_0": {"length": 15, "quality": 1.0, "section_id": 7033}}, "n3337": {"so_32715610_32716199_2": {"length": 23, "quality": 1.0, "section_id": 5631}, "so_32715610_32716199_1": {"length": 21, "quality": 1.0, "section_id": 5627}, "so_32715610_32716199_0": {"length": 15, "quality": 1.0, "section_id": 6779}}, "n4659": {"so_32715610_32716199_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 7344}, "so_32715610_32716199_1": {"length": 21, "quality": 1.0, "section_id": 7336}, "so_32715610_32716199_0": {"length": 15, "quality": 1.0, "section_id": 8530}}}, "32716199": {"Id": "32716199", "PostTypeId": "2", "Body": "<p>From [basic.def]:</p>\n<blockquote>\n<p id=\"so_32715610_32716199_0\">A declaration (Clause 7) may introduce one or more names into a translation unit <strong>or redeclare names</strong> introduced by previous declarations.</p>\n</blockquote>\n<p>From [class.name]:</p>\n<blockquote>\n<p id=\"so_32715610_32716199_1\">A declaration consisting solely of <em>class-key identifier;</em> is either <strong>a redeclaration of the name</strong> in the current scope or a forward declaration of the identifier as a class name. It introduces the class name\n  into the current scope.</p>\n</blockquote>\n<p>So it's generally legal to do this. There's just the one exception in [class.mem]:</p>\n<blockquote>\n<p id=\"so_32715610_32716199_2\">A member <strong>shall not be declared twice</strong> in the <em>member-specification</em>,\n  except that a nested class or member class template can be declared and then later defined, and except that an enumeration can be introduced with an <em>opaque-enum-declaration</em> and later redeclared with an <em>enum-specifier</em>.</p>\n</blockquote>\n<p>Perfectly OK in namespace scope, not allowed in class scope.</p>\n<hr/>\n<p>As to why? Well, this rule let's you \"forward\" declare all the classes you need everywhere you would typically be allowed to do so:</p>\n<pre><code>// a.h\nstruct C;\n\nstruct A {\n    C* c;\n};\n\n// b.h\nstruct C;\n\nstruct B {\n    C&amp; c;\n};\n</code></pre>\n<p>without having to worry about somebody actually including the full declaration and breaking everything for you:</p>\n<pre><code>// d.h\n#include \"c.h\"\n#include \"a.h\" // now C was already declared!\n#include \"b.h\" // and here too!\n\nstruct D { ... };\n</code></pre>\n<p>This isn't so much of a concern <em>within a class definition</em>. It can't exactly span multiple files. So the inability to redeclare nested types doesn't actually achieve anything. </p>\n", "LastActivityDate": "2015-09-22T11:54:07.260", "CommentCount": "2", "CreationDate": "2015-09-22T11:54:07.260", "ParentId": "32715610", "Score": "8", "OwnerUserId": "2069064"}, "32715610": {"ViewCount": "281", "Body": "<p>I just read <a href=\"https://stackoverflow.com/questions/32712057/is-this-trick-is-legal-and-why-compiler-made-it/32713932#32713932\">this answer</a>, and it completely puzzles me.</p>\n<p>I was always thinking a class declaration can appear many times, and only the definition has to exist only once, like:</p>\n<pre><code>/*class Class {*/\n\n    class A;         // (1) forward declaration\n\n    class A {        // (2) definition, only once\n       int m;\n    };\n\n    class A;         // (3) declaration again, legal?\n\n    class A a;       // (4) declaration again, legal?\n\n/*};*/\n</code></pre>\n<p>From the linked answer: (3) (and (4)?) is illegal if the code above is <strong><em>nested inside a class</em></strong> (definition and declarations of <code>class A</code> are nested inside <code>class Class</code>).</p>\n<p>On <a href=\"http://en.cppreference.com/w/cpp/language/class\" rel=\"nofollow noreferrer\">cppreference</a>, I found an example of the above, <strong><em>not nested</em></strong>:</p>\n<blockquote id=\"so_32715610_32715610_0\">\n<pre><code>struct s { int a; };\nstruct s; // does nothing (s already defined in this scope)\nvoid g() {\n    struct s; // forward declaration of a new, local struct \"s\"\n              // this hides global struct s until the end of this block\n    s* p;     // pointer to local struct s\n    struct s { char* p; }; // definitions of the local struct s\n}\n</code></pre>\n</blockquote>\n<p>See the second line.</p>\n<p><strong>Question:</strong> Given that it is illegal inside a class, is my example code, and the cppreference example above, legal when <em>not</em> nested inside a class? Or more generally: When can a class declaration follow a definition (how is it inside namespaces for example)? If it is legal, why is there a difference?</p>\n", "AcceptedAnswerId": "32716199", "Title": "Is a class declaration allowed after a class definition?", "CreationDate": "2015-09-22T11:25:38.317", "Id": "32715610", "CommentCount": "9", "LastEditDate": "2017-05-23T12:23:20.737", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-09-22T21:03:20.247", "Score": "5", "OwnerUserId": "3435400", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}, "32715969": {"Id": "32715969", "PostTypeId": "2", "Body": "<p><code>class A;</code>  This is a forward declaration of incomplete <code>class A</code> (legal).</p>\n<p><code>class A {  int m; };</code> This is the definition of <code>Class A</code> (legal).</p>\n<p><code>class A;</code> This is re-declaration of <code>class A</code> (legal).</p>\n<p><code>class A a;</code> This is declaration of object <code>a</code> of type <code>A</code> (legal).</p>\n", "LastActivityDate": "2015-09-22T11:44:13.253", "CommentCount": "2", "CreationDate": "2015-09-22T11:44:13.253", "ParentId": "32715610", "Score": "2", "OwnerUserId": "2352671"}});