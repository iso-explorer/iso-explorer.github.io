post_cb({"7226021": {"Id": "7226021", "PostTypeId": "2", "Body": "<p>As has been mentioned in commentary and in other answers, by there is no <code>operator+</code> for fundamental types. For classes, the answer to which of <code>operator+(x,y)</code> versus <code>x.operator+(y)</code> is correct is \"it depends\". Particularly, it depends on how <code>operator+</code> was defined. If it was defined as an member function then you need to use <code>x.operator+(y)</code>. If it was defined as a global function then you need to use <code>operator+(x,y)</code>.</p>\n<p>When the compiler confronts the statement <code>z=x+y;</code> your compiler is smart enough to look for the appropriate form. You shouldn't be expecting one or the other. You should be using <code>x+y</code>.</p>\n", "LastEditorUserId": "774499", "LastActivityDate": "2011-08-29T12:15:58.050", "Score": "1", "CreationDate": "2011-08-29T04:20:10.307", "ParentId": "7225962", "CommentCount": "6", "OwnerUserId": "774499", "LastEditDate": "2011-08-29T12:15:58.050"}, "7226018": {"Id": "7226018", "PostTypeId": "2", "Body": "<p>For native types, the operators aren't functions. Only overloaded operators are functions. Built-in operators are built-in - they don't have \"functions\", they usually just compile down to one or two assembly instructions that it would be insane to call as a function.</p>\n<p>So neither <code>operator+(x, y)</code> nor <code>x.operator+(y)</code> is correct. I suppose <code>x.operator+(y)</code> is less correct because non-<code>struct</code> types can't have members, but I doubt that helps much.</p>\n", "LastActivityDate": "2011-08-29T04:19:33.033", "CommentCount": "2", "CreationDate": "2011-08-29T04:19:33.033", "ParentId": "7225962", "Score": "1", "OwnerUserId": "60777"}, "7226025": {"Id": "7226025", "PostTypeId": "2", "Body": "<p>You can't overload binary operators when both arguments are built in types.\nHowever for your own objects this is how you can create them.</p>\n<pre><code>//Simple struct that behaves like an int.\nstruct A\n{\n  int v_;\n  explicit A(int i) : v_(i) {}  \n  // A member operator so we can write a+b\n  A operator+(const A &amp; a ) const { return A( v_ + a.v_); }      \n};\n\n// A non-member operator, so we can write 1+a\nA operator+(int i, const A &amp; a)\n{\n   return A(i+a.v_);\n}\n\nint main()\n{\n  A a(1);\n  A b(2);\n\n  // Call the member version using its natural syntax    \n  A c = a+b;\n  //Call the member version using function call syntax\n  A d = a.operator+(b);\n  // Call the non-member version using the natural syntax\n  A e = 1 + b;\n  // Call the nonmember version using function call syntax.\n  A f = ::operator+(1,b);\n}\n</code></pre>\n", "LastActivityDate": "2011-08-29T04:20:51.583", "CommentCount": "1", "CreationDate": "2011-08-29T04:20:51.583", "ParentId": "7225962", "Score": "2", "OwnerUserId": "221955"}, "7226010": {"Id": "7226010", "PostTypeId": "2", "Body": "<p>Using C++ standardese, the function call syntax (<code>operator+(x, y)</code> or <code>x.operator+(y)</code>) works only for <em>operator functions</em>:</p>\n<blockquote>\n<p id=\"so_7225962_7226010_0\"><strong>13.5 Overloaded operators [over.oper]</strong></p>\n<p id=\"so_7225962_7226010_1\"><em>4.</em> Operator functions are usually not called directly; instead they\n  are invoked to evaluate the operators they implement (13.5.1 -\n  13.5.7). They can be explicitly called, however, using the\n  <em>operator-function-id</em> as the name of the function in the function call\n  syntax (5.2.2). [<em>Example:</em></p>\n<pre><code>    complex z = a.operator+(b); // complex z = a+b;\n    void* p = operator new(sizeof(int)*n);\n</code></pre>\n<p id=\"so_7225962_7226010_2\"><em>\u2014end example</em>]</p>\n</blockquote>\n<p>And operator functions require at least one parameter that is a class type or an enumeration type:</p>\n<blockquote>\n<p id=\"so_7225962_7226010_3\"><strong>13.5 Overloaded operators [over.oper]</strong></p>\n<p id=\"so_7225962_7226010_4\"><em>6.</em> An operator function shall either be a non-static member function\n  or be a non-member function and have at least one parameter whose type\n  is a class, a reference to a class, an enumeration, or a reference to\n  an enumeration.</p>\n</blockquote>\n<p>That implies that an operator function <code>operator+()</code> that only takes <code>int</code>s cannot exist per 13.5/6. And you obviously can't use the function call syntax on an operator function that can't exist.</p>\n", "LastEditorUserId": "308661", "LastActivityDate": "2011-08-29T04:27:49.267", "Score": "16", "CreationDate": "2011-08-29T04:16:40.510", "ParentId": "7225962", "CommentCount": "5", "OwnerUserId": "308661", "LastEditDate": "2011-08-29T04:27:49.267"}, "bq_ids": {"n4140": {"so_7225962_7226010_4": {"length": 19, "quality": 0.95, "section_id": 653}, "so_7225962_7226010_1": {"length": 24, "quality": 0.8571428571428571, "section_id": 651}}, "n3337": {"so_7225962_7226010_4": {"length": 20, "quality": 1.0, "section_id": 643}, "so_7225962_7226010_1": {"length": 24, "quality": 0.8571428571428571, "section_id": 641}}, "n4659": {"so_7225962_7226010_4": {"length": 19, "quality": 0.95, "section_id": 681}, "so_7225962_7226010_1": {"length": 24, "quality": 0.8571428571428571, "section_id": 679}}}, "7225962": {"ViewCount": "4849", "Body": "<p>I'm trying to understand operators in C++ more carefully.</p>\n<p>I know that operators in C++ are basically just functions. What I don't get is, what does the function look like? </p>\n<p>Take for example:</p>\n<pre><code>int x = 1;\nint y = 2;\nint z = x + y;\n</code></pre>\n<p>How does the last line translate? Is it:</p>\n<p>1. <code>int z = operator+(x,y);</code></p>\n<p>or </p>\n<p>2. <code>int z = x.operator+(y);</code>?</p>\n<p>When I tried both of them, the compiler errors. Am I calling them wrong or are operators in C++ not allowed to be called directly?</p>\n", "AcceptedAnswerId": "7226010", "Title": "Is it not possible to call C++ operators manually?", "CreationDate": "2011-08-29T04:07:38.430", "Id": "7225962", "CommentCount": "8", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2011-08-29T04:12:56.270", "LastEditorUserId": "68587", "LastActivityDate": "2011-08-29T18:34:26.267", "Score": "14", "OwnerUserId": "901870", "Tags": "<c++><operator-keyword>", "AnswerCount": "6"}, "7225989": {"Id": "7225989", "PostTypeId": "2", "Body": "<p>Operator overloads only apply to objects and structs, not to fundamental types (such as int or float).  If you had an object class like:</p>\n<pre><code>  class A {\n    A operator+(const A&amp; rhs) {\n      return someComputedValue;\n    }\n  }\n</code></pre>\n<p>then you can indeed call <code>myA.operator+(anotherA)</code> and that will be equivalent to <code>myA + anotherA</code>.</p>\n", "LastEditorUserId": "318857", "LastActivityDate": "2011-08-29T18:34:26.267", "Score": "6", "CreationDate": "2011-08-29T04:13:43.457", "ParentId": "7225962", "CommentCount": "7", "OwnerUserId": "318857", "LastEditDate": "2011-08-29T18:34:26.267"}, "7226006": {"Id": "7226006", "PostTypeId": "2", "Body": "<p>For basic types like <code>int</code>, <code>float</code>, <code>double</code>; the operators are already overloaded/pre-defined, so nothing special can be done for that. And,</p>\n<pre><code>int z = x + y;\n</code></pre>\n<p>is the only way to express/call it.</p>\n<p>For <strong>interpretation purpose</strong>, actually both the statements,</p>\n<pre><code>int z = operator+(x,y);\nint z = x.operator+(y);\n</code></pre>\n<p>are true (had it been overloadable).</p>\n", "LastActivityDate": "2011-08-29T04:16:26.840", "CommentCount": "2", "CreationDate": "2011-08-29T04:16:26.840", "ParentId": "7225962", "Score": "8", "OwnerUserId": "514235"}});