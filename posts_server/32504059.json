post_cb({"32504059": {"CommentCount": "0", "AcceptedAnswerId": "32504539", "CreationDate": "2015-09-10T14:04:07.000", "LastActivityDate": "2015-09-10T14:51:43.107", "PostTypeId": "1", "ViewCount": "64", "FavoriteCount": "1", "Title": "Static member function, same name, different code, only the first encountered version is used, why is that?", "Id": "32504059", "Score": "2", "Body": "<p>I stumbled upon this strange behavior (after I tried to prove that the Scott Meyers singleton pattern would produce different singleton instances for each .cpp file if the <code>instance()</code> function is defined in the header file, but nevermind that).</p>\n<h2>What it produces:</h2>\n<p>The code produces this output - <code>0 2 4 6</code>, or <code>0 1 2 3</code> <strong>depending on the order of compilation</strong> (whether test1.cpp or test2.cpp has been compiled first).</p>\n<h2>What I expect:</h2>\n<p>I expect the result to be <code>0 0 1 2</code>, because the 2 functions should operate on 2 separate static variables, even though they have the same name, not to mention the fact that <code>Foo::foo()</code> is a different function in each compilation unit.</p>\n<p>But it seems that <code>test1()</code> and <code>test2()</code> call the version of <code>Foo::foo()</code> <strong>that was first encountered during compilation</strong>, which was surprising for me.</p>\n<p>This is the code:</p>\n<h2>test1.cpp</h2>\n<pre><code>static int var = 0;\nclass Foo {\npublic:\n    static void foo() {\n        printf(\"%d \", var);\n        var += 2;             // &lt;--- This is the difference!\n    }\n};\nvoid test1() {\n    Foo::foo();\n}\n</code></pre>\n<h2>test2.cpp</h2>\n<pre><code>static int var = 0;\nclass Foo {\npublic:\n    static void foo() {\n        printf(\"%d \", var);\n        var++;                // &lt;--- This is the difference!\n    }\n};\nvoid test2() {\n    Foo::foo();\n}\n</code></pre>\n<h2>main.cpp</h2>\n<pre><code>void test1();\nvoid test2();\nint main() {\n    test2();\n    test1();\n    test2();\n    test1();\n    return 0;\n}\n</code></pre>\n<h2>My question</h2>\n<p>My question is, I guess, why does the compiler behave that way, is it specified by the standard, and what does the standard say about having a different implementations of a class in different compilation units, provided they are used only in that compilation unit?</p>\n", "Tags": "<c++><linker><static-members>", "OwnerUserId": "492336", "AnswerCount": "2"}, "32504539": {"ParentId": "32504059", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>You are violating the \"<strong>One definition rule</strong>\" (section 3.2):</p>\n<blockquote>\n<p id=\"so_32504059_32504539_0\">Given such an entity named D defined in more than one translation unit, then</p>\n<ul>\n<li>each definition of D shall consist of the same sequence of tokens; and</li>\n<li>in each definition of D, corresponding names, looked up according to\n  3.4 , shall refer to an entity defined within the definition of D, \n  or shall refer to the <strong>same entity</strong>, after overload resolution (13.3) \n  and after matching of partial template specialization (14.8.3),\n  except that a name can refer to a const object with internal or no \n  linkage if the object has the same literal type in all definitions \n  of D, and the object is initialized with a constant expression (5.19),\n  and the value (but not the address) of the object is used, and the \n  object has the same value in all definitions of D; and</li>\n<li>in each definition of D, corresponding entities shall have the same \n  language linkage; and </li>\n<li>in each definition of D, the overloaded operators referred to, the \n  implicit calls to conversion functions, constructors, operator new \n  functions and operator delete functions, shall refer to the <strong>same \n  function</strong>, or to a function defined within the definition of D; and</li>\n<li>...</li>\n</ul>\n<p id=\"so_32504059_32504539_1\">If the definitions of D satisfy all these requirements, then the program \n  shall behave <strong>as if there were a single definition</strong> of D.</p>\n<p id=\"so_32504059_32504539_2\">If the definitions of D do not satisfy these requirements, then the \n  <strong>behavior is undefined</strong>.</p>\n</blockquote>\n<p>So, <code>Foo::foo()</code> shall be the same method in both files. \nOtherwise, the behavior is undefined.</p>\n", "OwnerUserId": "2020827", "LastEditorUserId": "2020827", "LastEditDate": "2015-09-10T14:51:43.107", "Id": "32504539", "Score": "2", "CreationDate": "2015-09-10T14:23:19.463", "LastActivityDate": "2015-09-10T14:51:43.107"}, "32504505": {"ParentId": "32504059", "CommentCount": "0", "Body": "<p>Since the namespace of both static functions are the same (The class name 'Foo' in your case), the function signatures in compiled code of test1 will be the exact same function signature of the test2. I guess depending on the compiler you might get a warning/error or it might just skip the next occurrences of the compiled function.</p>\n<p>Hence your output results is as expected.</p>\n", "OwnerUserId": "1981061", "PostTypeId": "2", "Id": "32504505", "Score": "0", "CreationDate": "2015-09-10T14:21:57.210", "LastActivityDate": "2015-09-10T14:21:57.210"}, "bq_ids": {"n4140": {"so_32504059_32504539_1": {"section_id": 7043, "quality": 0.9, "length": 9}, "so_32504059_32504539_0": {"section_id": 7043, "quality": 1.0, "length": 11}, "so_32504059_32504539_2": {"section_id": 7043, "quality": 1.0, "length": 6}}, "n3337": {"so_32504059_32504539_1": {"section_id": 6788, "quality": 1.0, "length": 10}, "so_32504059_32504539_0": {"section_id": 6788, "quality": 1.0, "length": 11}, "so_32504059_32504539_2": {"section_id": 6788, "quality": 1.0, "length": 6}}, "n4659": {"so_32504059_32504539_1": {"section_id": 8540, "quality": 0.9, "length": 9}, "so_32504059_32504539_0": {"section_id": 8540, "quality": 1.0, "length": 11}, "so_32504059_32504539_2": {"section_id": 8540, "quality": 1.0, "length": 6}}}});