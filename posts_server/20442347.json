post_cb({"bq_ids": {"n4140": {"so_20442347_20444531_0": {"length": 23, "quality": 0.92, "section_id": 6070}}, "n3337": {"so_20442347_20444531_0": {"length": 23, "quality": 0.92, "section_id": 5838}}, "n4659": {"so_20442347_20444531_0": {"length": 23, "quality": 0.92, "section_id": 7566}}}, "20442347": {"ViewCount": "464", "Body": "<p>[Disclaimer: I know an answer to this question. I thought it might be of some general interest.]</p>\n<p><strong>Question:</strong> How can we have a type trait that produces the type that results from performing <em>default argument promotions</em>?</p>\n<p><strong>Motivation:</strong> I would like to be able to use variable arguments portably. For example:</p>\n<pre><code>void foo(char const * fmt, ...);  // Please pass: * unsigned short\n                                  //              * bool\n                                  //              * char32_t\n                                  //              * unsigned char\n</code></pre>\n<p>When passing arguments to a function call without parameters, i.e. matching the ellipsis, the arguments undergo default argument promotion. So far so good, but those promotions are platform dependent. I can recover the arguments with <code>va_arg(ap, T)</code>, but what is <code>T</code>?</p>\n<p>Now, for some simple situations this is easy: For example, I can always say:</p>\n<pre><code>unsigned short n = va_args(ap, unsigned int);\n</code></pre>\n<p>The default promotion will result in either a <code>signed int</code> or an <code>unsigned int</code>, but according to, say, C11 7.16.1.1/3, va-casting to <code>unsigned int</code> is always fine, since even if the default promotion results in an <code>int</code>, the original value can be represented by both types.</p>\n<p>But what type should I cast to when I expect a <code>char32_t</code>? C++11 4.5/2 leaves the resulting type wide open. So I would like a trait that lets me write:</p>\n<pre><code>char32_t c = va_args(ap, default_promote&lt;char32_t&gt;::type);\n</code></pre>\n<p>How to do this?</p>\n<p>Bonus points for a trait that produces a static assertion when the parameter type must not be passed as a variable argument.</p>\n", "Title": "Type trait to obtain default argument promotions", "CreationDate": "2013-12-07T14:14:55.947", "LastActivityDate": "2013-12-09T22:23:42.753", "CommentCount": "14", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2013-12-07T14:20:19.260", "LastEditorUserId": "596781", "Id": "20442347", "Score": "8", "OwnerUserId": "596781", "Tags": "<c++><typetraits><variadic-functions>", "AnswerCount": "3"}, "20444868": {"Id": "20444868", "PostTypeId": "2", "Body": "<p>I think it may be slightly better to avoid <code>operator+</code>. <code>?:</code> cannot be overloaded, the checks that actually matter can be performed with that as well, and by making the other operand a literal 0, all forms of pointer types get handled properly automatically:</p>\n<pre><code>// nullptr_t promotes to void *\ntemplate &lt;typename T, typename = typename std::enable_if&lt;std::is_same&lt;T, std::nullptr_t&gt;::value&gt;::type&gt;\nvoid *default_promote_impl(T);\n\n// float promotes to double\ntemplate &lt;typename T, typename = typename std::enable_if&lt;std::is_same&lt;T, float&gt;::value&gt;::type&gt;\ndouble default_promote_impl(T);\n\n// scalar types other than nullptr_t/float that have a conversion from/to 0 promote to their common type\n// this also matches function and array types, after their implicit conversion to a pointer type\ntemplate &lt;typename T, typename = typename std::enable_if&lt;std::is_scalar&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, std::nullptr_t&gt;::value &amp;&amp; !std::is_same&lt;T, float&gt;::value&gt;::type&gt;\ndecltype(true ? 0 : std::declval&lt;T&gt;()) default_promote_impl(T);\n\n// scoped enumeration types don't get promoted\ntemplate &lt;typename T, typename = typename std::enable_if&lt;std::is_enum&lt;T&gt;::value&gt;::type&gt;\ntypename std::enable_if&lt;!std::is_convertible&lt;T, typename std::underlying_type&lt;T&gt;::type&gt;::value, T&gt;::type default_promote_impl(T);\n\n// class types don't get promoted\ntemplate &lt;typename T, typename = typename std::enable_if&lt;std::is_class&lt;T&gt;::value || std::is_union&lt;T&gt;::value&gt;::type&gt;\nT default_promote_impl(T);\n\ntemplate &lt;typename T&gt;\nconstexpr bool check_vararg_passable(...) {\n  return true ? true : check_vararg_passable&lt;T&gt;(*(typename std::remove_reference&lt;T&gt;::type *)0);\n}\n\ntemplate &lt;typename T, bool = check_vararg_passable&lt;T&gt;()&gt;\nstruct default_promote {\n  typedef decltype(default_promote_impl(std::declval&lt;T&gt;())) type;\n};\n</code></pre>\n<p><em>Update</em>: passing any type through <code>...</code> is valid in <em>unevaluated</em> expressions, but in <em>potentially evaluated</em> expressions, it's conditionally-supported. The full expression in a <code>constexpr</code> function is <em>potentially evaluated</em> and can be used to force an error on implementations that don't support passing that type through <code>...</code>.</p>\n", "LastEditorUserId": "743382", "LastActivityDate": "2013-12-09T22:23:42.753", "Score": "1", "CreationDate": "2013-12-07T18:23:14.490", "ParentId": "20442347", "CommentCount": "12", "OwnerUserId": "743382", "LastEditDate": "2013-12-09T22:23:42.753"}, "20444531": {"Id": "20444531", "PostTypeId": "2", "Body": "<p>Here's a skeleton of a solution that works for \"most\" types (integral, float, unscoped enumeration, arrays, pointers, pointers-to-member, functions, function pointers).</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;typename U&gt;\nstruct default_promote\n{\n    // Support trait for scoped enums\n\n    template &lt;typename E, bool IsEnum&gt;\n    struct is_unscoped_enum : std::false_type { };\n\n    template &lt;typename E&gt; struct is_unscoped_enum&lt;E, true&gt;\n    : std::is_convertible&lt;E, typename std::underlying_type&lt;E&gt;::type&gt; { };\n\n\n    // Floating point promotion\n\n    static double test(float);\n\n\n    // Integral promotions (includes pointers, arrays and functions)\n\n    template &lt;typename T, typename = typename std::enable_if&lt;!is_unscoped_enum&lt;T, std::is_enum&lt;T&gt;::value&gt;::value&gt;::type&gt;\n    static auto test(T) -&gt; decltype(+ std::declval&lt;T&gt;());\n\n    template &lt;typename T, typename = typename std::enable_if&lt;is_unscoped_enum&lt;T, std::is_enum&lt;T&gt;::value&gt;::value&gt;::type&gt;\n    static auto test(T) -&gt; decltype(+ std::declval&lt;typename std::underlying_type&lt;T&gt;::type&gt;());\n\n\n    // Pointers-to-member (no promotion)\n\n    template &lt;typename T, typename S&gt;\n    static auto test(S T::*) -&gt; S T::*;\n\n\n    using type = decltype(test(std::declval&lt;U&gt;()));\n};\n</code></pre>\n<p>It does not provide diagnostics for types that cannot safely be passed through an ellipsis. Also, this solution subsumes the decay that types undergo when passed as variable function arguments, so it is not strictly about promotion only.</p>\n<p>It works by handling explicitly the pointer-to-member types and the floating point conversion, and by relying on the unary operator <code>+</code> for integral and unscoped enumeration types; e.g. C++11 5.3.1/7:</p>\n<blockquote>\n<p id=\"so_20442347_20444531_0\">The operand of the unary <code>+</code> operator shall have arithmetic, unscoped enumeration, or pointer type and the result is the value of the argument. Integral promotion is performed on integral or enumeration operands. The type of the result is the type of the promoted operand.</p>\n</blockquote>\n<p>Some extra work is needed to handle enumerations, since it is possible to overload operators for enumerations (both scoped and unscoped), and so the naive unary plus operator must be used with care. That is, we must consider the promotion of the <em>underlying type</em> when the enum is unscoped, and forbid scoped enums entirely.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2013-12-07T18:31:45.210", "Score": "3", "CreationDate": "2013-12-07T17:49:55.003", "ParentId": "20442347", "CommentCount": "1", "OwnerUserId": "596781", "LastEditDate": "2013-12-07T18:31:45.210"}, "20443243": {"Id": "20443243", "PostTypeId": "2", "Body": "<pre><code>#include &lt;cstdlib&gt;\n#include &lt;stdarg.h&gt;\n#include &lt;type_traits&gt;\n\n// Utility type if / else\ntemplate &lt;typename T, typename U, bool choose&gt;\nstruct TifChooseU { };\n\ntemplate &lt;typename T, typename U&gt;\nstruct TifChooseU &lt;T, U, true&gt; {\n    using type = T;\n};\n\ntemplate &lt;typename T, typename U&gt;\nstruct TifChooseU &lt;T, U, false&gt; {\n    using type = U;\n};\n\n// Default - No Promotion\ntemplate &lt;typename T&gt;\nstruct promote_me {\n    using type = T;\n};\n\n// http://en.cppreference.com/w/cpp/language/implicit_cast - Let's go in order\n// Signed char - int\ntemplate &lt;&gt;\nstruct promote_me &lt;signed char&gt; {\n    using type = int;\n};\n\n// Signed short - int\ntemplate &lt;&gt;\nstruct promote_me &lt;signed short&gt; {\n    using type = int;\n};\n\n// Unsigned char - int or unsigned int, dependent on inter-stellar configuration\ntemplate &lt;&gt;\nstruct promote_me &lt;unsigned char&gt; {\n    // Doesn't compile without the parens around the operator &gt;\n    using type = TifChooseU &lt;int, unsigned int, (sizeof(int) &gt; sizeof(unsigned char))&gt;::type;\n};\n\n// Unsigned short - int or unsigned int, dependent on inter-stellar configuration\ntemplate &lt;&gt;\nstruct promote_me &lt;unsigned short&gt; {\n    // Doesn't compile without the parens around the operator &gt;\n    using type = TifChooseU &lt;int, unsigned int, (sizeof(int) &gt; sizeof(short))&gt;::type;\n};\n\n// Char - dispatch to unsigned / signed char\ntemplate &lt;&gt;\nstruct promote_me &lt;char&gt; :\n       promote_me &lt;TifChooseU &lt;signed char, unsigned char,\n                               std::is_signed&lt;char&gt;::value&gt;::type&gt; {};\n\n// Wchar_t - int, unsigned int, long, unsigned long, long long, unsigned long long\n// dependent on the amount of goats recently sacrificed\ntemplate &lt;&gt;\nstruct promote_me &lt;wchar_t&gt; {\n    using type =\n        TifChooseU &lt;\n        TifChooseU &lt;int,\n            TifChooseU&lt;long, long long, (sizeof(long) &gt; sizeof(wchar_t))&gt;::type,\n            (sizeof(int) &gt; sizeof(wchar_t))&gt;::type,\n        TifChooseU &lt;unsigned int,\n            TifChooseU&lt;unsigned long, unsigned long long, (sizeof(unsigned long) &gt; sizeof(wchar_t))&gt;::type,\n            (sizeof(int) &gt; sizeof(wchar_t))&gt;::type,\n        std::is_signed&lt;wchar_t&gt;::value\n    &gt;::type;\n};\n\n// Char16_t - int, unsigned int, long, unsigned long, long long, unsigned long long\n// dependent on the amount of goats recently sacrificed\ntemplate &lt;&gt;\nstruct promote_me &lt;char16_t&gt; {\n    using type =\n        TifChooseU &lt;\n        TifChooseU &lt;int,\n            TifChooseU&lt;long, long long, (sizeof(long) &gt; sizeof(char16_t))&gt;::type,\n            (sizeof(int) &gt; sizeof(char16_t))&gt;::type,\n        TifChooseU &lt;unsigned int,\n            TifChooseU&lt;unsigned long, unsigned long long, (sizeof(unsigned long) &gt; sizeof(char16_t))&gt;::type,\n            (sizeof(int) &gt; sizeof(char16_t))&gt;::type,\n        std::is_signed&lt;char16_t&gt;::value\n    &gt;::type;\n};\n\n// Char32_t - int, unsigned int, long, unsigned long, long long, unsigned long long\n// dependent on the amount of goats recently sacrificed\ntemplate &lt;&gt;\nstruct promote_me &lt;char32_t&gt; {\n    using type =\n        TifChooseU &lt;\n        TifChooseU &lt;int,\n            TifChooseU&lt;long, long long, (sizeof(long) &gt; sizeof(char32_t))&gt;::type,\n            (sizeof(int) &gt; sizeof(char32_t))&gt;::type,\n        TifChooseU &lt;unsigned int,\n            TifChooseU&lt;unsigned long, unsigned long long, (sizeof(unsigned long) &gt; sizeof(char32_t))&gt;::type,\n            (sizeof(int) &gt; sizeof(char32_t))&gt;::type,\n        std::is_signed&lt;char32_t&gt;::value\n    &gt;::type;\n};\n\n// Enums and Bitfields - maybe later ^^\n\n// Bool - int\ntemplate &lt;&gt;\nstruct promote_me &lt;bool&gt; {\n    using type = int;\n};\n\nvoid foo(const char* fmt, ...) {\n    va_list va;\n    va_start(va, fmt);\n    unsigned short a = va_arg(va, promote_me&lt;unsigned short&gt;::type);\n    bool           b = va_arg(va, promote_me&lt;bool&gt;::type);\n    char32_t       c = va_arg(va, promote_me&lt;char32_t&gt;::type);\n    unsigned char  d = va_arg(va, promote_me&lt;unsigned char&gt;::type);\n}\n\nint main() {\n\nconst char* fmt;\nunsigned short a = 1;\nbool           b = true;\nchar32_t       c = 'a';\nunsigned char  d = 'c';\n\nfoo(fmt, a, b, c, d);\n\n}\n</code></pre>\n<p>If there is like a one-liner solution to this, I'll consider a suicide :).<br>\nI will probably improve this with <code>fits&lt;T, U&gt;</code> template and I'll also fix<br>\nthe inelegant <code>wchar_t</code> and <code>char16_t</code> <code>char32_t</code> code repetition.</br></br></p>\n", "LastEditorUserId": "1056928", "LastActivityDate": "2013-12-07T16:11:16.020", "Score": "2", "CreationDate": "2013-12-07T15:47:02.880", "ParentId": "20442347", "CommentCount": "13", "OwnerUserId": "1056928", "LastEditDate": "2013-12-07T16:11:16.020"}});