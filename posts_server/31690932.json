post_cb({"31691428": {"ParentId": "31690932", "CommentCount": "1", "CreationDate": "2015-07-29T04:49:15.530", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "31691428", "Score": "0", "Body": "<p>It appears that g++ 4.8.4 also has problems when the member variable is <code>begin</code> or <code>end</code>.</p>\n<p>Using</p>\n<pre><code>struct st{\n    int begin;\n    int end;\n};\n\ntemplate &lt;typename T&gt;\nvoid compare(const T&amp; v1, const T&amp; v2){\n    if(v1.begin &lt; v2.begin)\n    {\n        cout &lt;&lt; \"v1.begin &lt; v2.begin\" &lt;&lt; endl;\n    }\n    if(v1.end &lt; v2.end)\n    {\n        cout &lt;&lt; \"v1.end &lt; v2.end\" &lt;&lt; endl;\n    }\n}\n</code></pre>\n<p>produces the following error message for me.</p>\n<pre><code>socc.cc: In function \u2018void compare(const T&amp;, const T&amp;)\u2019:\nsocc.cc:12:11: error: parse error in template argument list\n     if(v1.begin &lt; v2.begin)\n           ^\nsocc.cc:16:11: error: parse error in template argument list\n     if(v1.end &lt; v2.end)\n           ^\nsocc.cc: In instantiation of \u2018void compare(const T&amp;, const T&amp;) [with T = st]\u2019:\nsocc.cc:25:17:   required from here\nsocc.cc:12:5: error: \u2018begin\u2019 is not a member template function\n     if(v1.begin &lt; v2.begin)\n     ^\nsocc.cc:16:5: error: \u2018end\u2019 is not a member template function\n     if(v1.end &lt; v2.end)\n</code></pre>\n<p>Perhaps someone more familiar with g++ development than me can provide more details.</p>\n<p>One work around is to use avoid using <code>begin</code> and <code>end</code> as member variables.</p>\n<pre><code>struct st{\n    int _begin;\n    int _end;\n};\n</code></pre>\n<p>or</p>\n<pre><code>struct st{\n    int _start;\n    int _end;\n};\n</code></pre>\n", "LastActivityDate": "2015-07-29T04:49:15.530"}, "31752995": {"ParentId": "31690932", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Actually it's the <code>&lt;</code> which confuse the compiler, since it does not know whether it's the start of a template expression, or the comparator.</p>\n<p>Since @R Sahu asked for an official sources, here is the explanation :</p>\n<blockquote>\n<p id=\"so_31690932_31752995_0\">The paragraph that matters here is [basic.lookup.classref]p1:</p>\n<p id=\"so_31690932_31752995_1\">\"In a class member access expression (5.2.5), if the <code>.</code> or <code>-&gt;</code> token is\n  immediately followed by an identifier followed by a &lt;, the identifier\n  must be looked up to determine whether the &lt; is the beginning of a\n  template argument list (14.2) or a less-than operator. The identifier\n  is first looked up in the class of the object expression. If the\n  identifier is not found, it is then looked up in the context of the\n  entire postfix-expression and shall name a class template.\"</p>\n<p id=\"so_31690932_31752995_2\">Since v is dependent, presumably the identifier is not found so we\n  consider what happens if we look in the context of the entire\n  postfix-expression. Since we find a function template, we should not\n  conclude that we have the start of a template-id.</p>\n</blockquote>\n<p>Source : <a href=\"https://stackoverflow.com/questions/10671406/c-confusing-attribute-name-for-member-template\">C++ confusing attribute name for member template</a></p>\n<p>And here is the corresponding <code>gcc</code> bug : <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=10200\" rel=\"nofollow noreferrer\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=10200</a></p>\n<blockquote>\n<p id=\"so_31690932_31752995_3\"><strong>* Paolo Carlini 2015-06-23 15:03:03 UTC *</strong></p>\n<p id=\"so_31690932_31752995_4\">Bug 65878 has been marked as a duplicate of this bug.</p>\n<p id=\"so_31690932_31752995_5\"><strong>* Colin MacKenzie 2015-06-23 22:19:29 UTC *</strong></p>\n<p id=\"so_31690932_31752995_6\">Had this one today. Strange that it compiles fine in 4.4.6 but not in\n  4.8.2.</p>\n</blockquote>\n<pre><code>error: parse error in template argument list \nEx: assert(block.begin &lt;  block.end);\n\nworks when I parenthesize the block.begin \nEx. assert( (block.begin) &lt; block.end);\n</code></pre>\n<blockquote>\n<p id=\"so_31690932_31752995_7\"><strong>* Paolo Carlini 2015-06-23 22:21:28 UTC *</strong></p>\n<p id=\"so_31690932_31752995_8\">This should be fixed ASAP, but I'm not actively working on it at the\n  moment.</p>\n</blockquote>\n", "OwnerUserId": "1741450", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:51:32.000", "Id": "31752995", "Score": "8", "CreationDate": "2015-07-31T18:40:54.387", "LastActivityDate": "2015-08-04T05:49:33.050"}, "31756207": {"ParentId": "31690932", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is clearly a gcc bug (specifically <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=10200\" rel=\"nofollow noreferrer\">10200</a> although there are several dupes with lots of different examples). [temp.names] states:</p>\n<blockquote>\n<p id=\"so_31690932_31756207_0\">When the name of a member template specialization appears after . or -&gt; in a <em>postfix-expression</em> or after a\n  <em>nested-name-specifier</em> in a <em>qualified-id</em>, and the object expression of the <em>postfix-expression</em> is <em>type-dependent</em>\n  or the <em>nested-name-specifier</em> in the <em>qualified-id refers</em> to a dependent type, but the name is not a member of\n  the current instantiation (14.6.2.1), the member template name must be prefixed by the keyword <code>template</code>.\n  <strong>Otherwise the name is assumed to name a non-template.</strong> <em>[ Example:</em></p>\n<pre><code>struct X {\n    template&lt;std::size_t&gt; X* alloc();\n    template&lt;std::size_t&gt; static X* adjust();\n};\n\ntemplate&lt;class T&gt; void f(T* p) {\n    T* p1 = p-&gt;alloc&lt;200&gt;();          // ill-formed: &lt; means less than\n    T* p2 = p-&gt;template alloc&lt;200&gt;(); // OK: &lt; starts template argument list\n    T::adjust&lt;100&gt;();                 // ill-formed: &lt; means less than\n    T::template adjust&lt;100&gt;();        // OK: &lt; starts template argument list\n}\n</code></pre>\n<p id=\"so_31690932_31756207_1\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p><code>v1</code> and <code>v2</code> are <em>type-dependent</em>, so the name should be assumed to name a non-template due to the omitted <code>template</code> keyword and the <code>&lt;</code> should be treated as less than, exactly as in the example above. </p>\n<p>Not to mention that [basic.lookup.classref] states that:</p>\n<blockquote>\n<p id=\"so_31690932_31756207_2\">The identifier is first looked up in the class of the object\n  expression. If the identifier is not found, it is then looked up in the context of the entire <em>postfix-expression</em> and shall name a class template.</p>\n</blockquote>\n<p>And <code>end</code> should clearly be found in the class of the object expression - it's a simple member variable, after all. The fact that it's a failure for <code>end</code> only because of the collision with <code>std::end()</code> further supports the idea of bug since that scope should never have been considered to begin with.</p>\n<p>Amusingly, the simplest solution is simply: <a href=\"https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice\">don't use <code>using namespace std;</code></a>!</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:08:03.397", "Id": "31756207", "Score": "8", "CreationDate": "2015-07-31T22:38:04.803", "LastActivityDate": "2015-07-31T22:38:04.803"}, "bq_ids": {"n4140": {"so_31690932_31756207_0": {"section_id": 72, "quality": 0.9487179487179487, "length": 37}, "so_31690932_31756207_2": {"section_id": 7126, "quality": 0.9411764705882353, "length": 16}, "so_31690932_31752995_1": {"section_id": 7126, "quality": 0.9230769230769231, "length": 36}}, "n3337": {"so_31690932_31756207_0": {"section_id": 67, "quality": 0.9487179487179487, "length": 37}, "so_31690932_31756207_2": {"section_id": 6870, "quality": 0.9411764705882353, "length": 16}, "so_31690932_31752995_1": {"section_id": 6870, "quality": 0.9230769230769231, "length": 36}}, "n4659": {"so_31690932_31756207_2": {"section_id": 8627, "quality": 0.9411764705882353, "length": 16}, "so_31690932_31752995_1": {"section_id": 8627, "quality": 0.9230769230769231, "length": 36}}}, "31690932": {"CommentCount": "4", "AcceptedAnswerId": "31756207", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2015-07-29T03:51:09.073", "LastActivityDate": "2015-08-04T05:49:33.050", "LastEditDate": "2015-07-31T22:19:18.950", "ViewCount": "294", "FavoriteCount": "1", "Title": "\"end\" cannot use in template function", "Id": "31690932", "Score": "9", "Body": "<p>I want to use a simple struct with member variables named <code>start</code> and <code>end</code> in a function template:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct st {\n    int start;\n    int end;\n};\n\ntemplate&lt;typename T&gt;\nvoid compare(const T&amp; v1, const T&amp; v2){\n    if(v1.end &lt; v2.end)\n        cout &lt;&lt; \"v1 &lt; v2\" &lt;&lt; endl;\n}\n\nint main() {\n    st a = {1, 2};\n    st b = {2, 3};\n    compare(a, b);\n    return 0;\n}\n</code></pre>\n<p>But this program fails to compile on mingw g++ 4.8.2 with:</p>\n<pre><code>main.cpp: In function 'void compare(const T&amp;, const T&amp;)':\nmain.cpp:11:11: error: parse error in template argument list\n     if(v1.end &lt; v2.end)\n           ^\nmain.cpp: In instantiation of 'void compare(const T&amp;, const T&amp;) [with T = st]':\nmain.cpp:18:17:   required from here\nmain.cpp:11:5: error: 'end' is not a member template function\n     if(v1.end &lt; v2.end)\n     ^\n</code></pre>\n<p>Why not? What's wrong with my code?</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "5167584", "AnswerCount": "3"}});