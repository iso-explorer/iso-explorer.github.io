post_cb({"bq_ids": {"n4140": {"so_21803992_21803992_0": {"length": 36, "quality": 0.972972972972973, "section_id": 233}}, "n3337": {"so_21803992_21803992_0": {"length": 36, "quality": 0.972972972972973, "section_id": 226}}, "n4659": {"so_21803992_21803992_0": {"length": 36, "quality": 0.972972972972973, "section_id": 243}}}, "21803992": {"ViewCount": "215", "Body": "<p>Here is a short self-contained test case to explain my question. GCC accepts this code, but clang and Intel reject it:</p>\n<pre><code>template &lt;typename T&gt;\nstruct false_t {\n  static const bool value = false;\n};\ntemplate &lt;typename T&gt;\nint f() {\n  static_assert(false_t&lt;T&gt;::value, \"\");\n  return 0;\n}\ntemplate &lt;typename T&gt;\nstruct S {\n  int m = f&lt;T&gt;();\n};\nint s = sizeof(S&lt;int&gt;);\n</code></pre>\n<p>Or, based on pmr's comment, here is a simpler example which too is accepted by gcc and rejected by clang:</p>\n<pre><code>struct S;\ntemplate &lt;typename T&gt; struct X { int x = T(); };\nint s = sizeof(X&lt;S&gt;);\n</code></pre>\n<p><code>sizeof(S&lt;int&gt;)</code> (or <code>sizeof(X&lt;S&gt;)</code>) is supposed to instantiate the bits of the class it needs, but the compilers disagree on which bits those are. Since a non-static data member initializer would only be used by a constructor, GCC performs the instantiation as part of instantiating the class's constructor. clang and Intel do so earlier.</p>\n<p>I'm having trouble understanding what the standard says in [temp.inst]p1:</p>\n<blockquote>\n<p id=\"so_21803992_21803992_0\">The implicit instantiation of a class template specialization causes the implicit\n  instantiation of the declarations, but not of the definitions or default arguments, of the class member functions, member classes, scoped member enumerations, static data members and member templates; and it causes the implicit instantiation of the definitions of unscoped member enumerations and member anonymous unions.</p>\n</blockquote>\n<p>because I don't see where even the declarations of the non-static data members (with or without initialisers) get instantiated at all.</p>\n<p>A bit more details about where I encountered this: I was trying to create a template helper class (that would never be created at runtime) containing a member initialised using <code>std::declval&lt;T&gt;()</code> (which, I should add, I now realise wouldn't be of much use anyway), and libstdc++'s implementation of <code>std::declval</code> contains a static assertion like the one in my example. I can work around the problem without much effort by avoiding <code>std::declval</code>, but I would like to know what the standard requires.</p>\n", "AcceptedAnswerId": "21803993", "Title": "When are template non-static data member initialisers instantiated?", "CreationDate": "2014-02-15T21:40:01.143", "Id": "21803992", "CommentCount": "4", "LastEditDate": "2014-02-15T22:54:19.393", "PostTypeId": "1", "LastEditorUserId": "743382", "LastActivityDate": "2014-02-15T22:54:19.393", "Score": "6", "OwnerUserId": "743382", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "1"}, "21803993": {"Id": "21803993", "PostTypeId": "2", "Body": "<p>While attempting to figure out how to ask this question, I stumbled upon the answer, but thought it might be useful to post anyway.</p>\n<p>This is one of the open issues of the C++ standard, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1396\">issue 1396</a> to be precise. The intent is that the initialisers only get instantiated as needed:</p>\n<blockquote>\n<p id=\"so_21803992_21803993_0\">Non-static data member initializers get the same late parsing as member functions and default arguments, but are they also instantiated as needed like them? And when is their validity checked?</p>\n<p id=\"so_21803992_21803993_1\"><strong>Notes from the October, 2012 meeting:</strong></p>\n<p id=\"so_21803992_21803993_2\">CWG agreed that non-static data member initializers should be handled like default arguments.</p>\n</blockquote>\n<p>but there are quite a number problems with that approach that are still being resolved. Until they are resolved, it's only natural that different compilers perform the instantiation at different times, and code that requires specific behaviour should be rewritten to avoid such a requirement. In my case, that means not using <code>std::declval</code>.</p>\n", "LastActivityDate": "2014-02-15T21:40:01.143", "Score": "6", "CreationDate": "2014-02-15T21:40:01.143", "ParentId": "21803992", "CommentCount": "0", "OwnerUserId": "743382"}});