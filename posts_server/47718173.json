post_cb({"bq_ids": {"n4140": {"so_47718173_47718173_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 176}, "so_47718173_47718173_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 176}}, "n3337": {"so_47718173_47718173_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 170}, "so_47718173_47718173_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 170}}, "n4659": {"so_47718173_47718173_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 181}, "so_47718173_47718173_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 181}}}, "47718173": {"ViewCount": "37", "Body": "<p>Here is two-phase name lookup for template from iso-standard: </p>\n<blockquote>\n<ul>\n<li><p id=\"so_47718173_47718173_0\">When looking for the declaration of a name used in a template definition, the usual lookup rules (6.4.1, 6.4.2) are used for non-dependent names. </p></li>\n<li><p id=\"so_47718173_47718173_1\">The lookup of names dependent on the template parameters is postponed until the actual template argument is known</p></li>\n</ul>\n</blockquote>\n<p>Sample codes: </p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid WithoutTemplate(int) {std::cout &lt;&lt; \"NonTemplate: int\\n\";}\n\ntemplate&lt;typename T&gt;\nvoid WithTemplate(T) {std::cout &lt;&lt; \"no match\\n\";}\n\ntemplate&lt;&gt;\nvoid WithTemplate(int) {std::cout &lt;&lt;\"Template: int\\n\";}\n\ntemplate&lt;typename T&gt;\nvoid test(T)\n{\n    WithTemplate(1.1);\n    WithoutTemplate(1.1);\n}\n\nvoid WithoutTemplate(double) {std::cout &lt;&lt; \"nontemplate: double\\n\";}\n\ntemplate&lt;&gt;\nvoid WithTemplate(double) {std::cout &lt;&lt; \"template: double\\n\";}\n\nint main()\n{\n    test(1.1);\n}\n</code></pre>\n<p>output: </p>\n<blockquote>\n<p id=\"so_47718173_47718173_2\">template: double\n  NonTemplate: int</p>\n</blockquote>\n<p>There are two functions: <code>WithTemplate</code> and <code>WithoutTemplate</code>. The parameter <code>1.1</code> is non-dependent(though it is prvalue, which has no name? I assume it still obey non-dependent name's rules)</p>\n<ul>\n<li>name lookup of <code>WithoutTemplate</code> meets 2-phase lookup, because when calling <code>WithoutTemplate(1.1)</code>, <code>void WithoutTemplate(double)</code> is not visible. So the output <code>NonTemplate: int</code> is easy to understand. </li>\n<li>However, the case which invokes full specialization function quite confuses me. its behaviour is opposite to the standard's rules(2-phase lookup). I thought it should output <code>template: int</code></li>\n</ul>\n<p>So, is there other name lookup rules for specialization? Or something else I misunderstand? </p>\n<p>Here is what I have read: </p>\n<ul>\n<li><p><a href=\"https://stackoverflow.com/questions/3914642/difference-between-instantiation-and-specialization-in-c-templates\">Difference between instantiation and specialization in c++ templates</a></p></li>\n<li><p><a href=\"https://stackoverflow.com/questions/10639053/name-lookups-in-c-templates\">Name lookups in C++ templates</a></p></li>\n</ul>\n", "AcceptedAnswerId": "47718679", "Title": "stragety of the name lookup about full specialization of function?", "CreationDate": "2017-12-08T16:14:03.757", "Id": "47718173", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2017-12-08T16:46:06.467", "Score": "1", "OwnerUserId": "6949852", "Tags": "<c++><templates>", "AnswerCount": "1"}, "47718679": {"Id": "47718679", "PostTypeId": "2", "Body": "<p>Your program has undefined behaviour, because you define the explicit specialization of <code>WithTemplate&lt;double&gt;</code> after it has been implicitly instantiated through the call <code>WithTemplate(1.1)</code>. Explicit specializations must appear before any use of them that would cause instantiation - see e.g. <a href=\"http://en.cppreference.com/w/cpp/language/template_specialization\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/template_specialization</a>.</p>\n<p>So there's no point trying to reconcile the behaviour with what the standard says; the standard explicitly says nothing about what should happen here.</p>\n", "LastActivityDate": "2017-12-08T16:46:06.467", "Score": "4", "CreationDate": "2017-12-08T16:46:06.467", "ParentId": "47718173", "CommentCount": "0", "OwnerUserId": "212870"}});