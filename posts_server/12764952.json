post_cb({"bq_ids": {"n4140": {"so_12764952_12764952_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 6109}, "so_12764952_12764952_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 4283}, "so_12764952_12764952_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 4280}, "so_12764952_12764952_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 4282}}, "n3337": {"so_12764952_12764952_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 5875}, "so_12764952_12764952_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 4124}, "so_12764952_12764952_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 4121}, "so_12764952_12764952_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 4123}}, "n4659": {"so_12764952_12764952_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 7606}, "so_12764952_12764952_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 5539}, "so_12764952_12764952_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 5536}, "so_12764952_12764952_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 5538}}}, "12765739": {"Id": "12765739", "PostTypeId": "2", "Body": "<p>The following example is an attempt to demonstrate the difference between <code>std::auto_ptr&lt;T&gt;</code> and <code>std::unique_ptr&lt;T&gt;</code>.  First consider this program consisting of 2 source files and 1 header:</p>\n<p>The header:</p>\n<pre><code>// test.h\n\n#ifndef TEST_H\n#define TEST_H\n\n#include &lt;memory&gt;\n\ntemplate &lt;class T&gt;\nusing smart_ptr = std::auto_ptr&lt;T&gt;;\n\nstruct T2;\n\nstruct T1\n{\n    smart_ptr&lt;T2&gt; obj;\n\n    T1(T2* p);\n};\n\nT2*\nsource();\n\n#endif  // TEST_H\n</code></pre>\n<p>First source:</p>\n<pre><code>// test.cpp\n\n#include \"test.h\"\n\nint main()\n{\n    T1 t1(source());\n}\n</code></pre>\n<p>Second source:</p>\n<pre><code>// test2.cpp\n\n#include \"test.h\"\n#include &lt;iostream&gt;\n\n\nstruct T2\n{\n    ~T2() {std::cout &lt;&lt; \"~T2()\\n\";}\n};\n\nT1::T1(T2* p)\n    : obj(p)\n{\n}\n\nT2*\nsource()\n{\n    return new T2;\n}\n</code></pre>\n<p>This program should compile (it may compile with a warning, but it should compile).  But at run time it demonstrates undefined behavior.  And it probably won't output:</p>\n<pre><code>~T2()\n</code></pre>\n<p>which indicates that <code>T2</code>'s destructor has not been run.  At least it doesn't on my system.</p>\n<p>If I change test.h to:</p>\n<pre><code>template &lt;class T&gt;\nusing smart_ptr = std::unique_ptr&lt;T&gt;;\n</code></pre>\n<p>Then the compiler is required to output a diagnostic (an error).</p>\n<p>That is, when you make this mistake with <code>auto_ptr</code> you get a run time error.  When you make this mistake with <code>unique_ptr</code> you get a compile time error.  And <strong>that</strong> is the difference between <code>auto_ptr</code> and <code>unique_ptr</code>.</p>\n<p>To fix the compile time error you must outline <code>~T1()</code> after <code>T2</code> is complete.  In test2.cpp add after <code>T2</code>:</p>\n<pre><code>T1::~T1() = default;\n</code></pre>\n<p>Now it should compile and output:</p>\n<pre><code>~T2()\n</code></pre>\n<p>You will likely want to declare and outline move members as well:</p>\n<pre><code>T1::T1(T1&amp;&amp;) = default;\nT1&amp; T1::operator=(T1&amp;&amp;) = default;\n</code></pre>\n<p>You could make these same fixes with <code>auto_ptr</code> and it would again be correct.  But again, the difference between <code>auto_ptr</code> and <code>unique_ptr</code> is that with the former, you don't find out until run time that you have some debugging to do (modulo optional warnings your compiler may give).  With the latter you are guaranteed to find out at compile time.</p>\n", "LastActivityDate": "2012-10-07T02:54:51.570", "CommentCount": "0", "CreationDate": "2012-10-07T02:54:51.570", "ParentId": "12764952", "Score": "8", "OwnerUserId": "576911"}, "12764952": {"ViewCount": "1475", "Body": "<p>I wrote <a href=\"http://kera.name/articles/2012/10/auto_ptr-and-forward-declarations-basically-dont\" rel=\"nofollow noreferrer\">this article</a> and got some comments on it that confused me.</p>\n<p>It basically boils down to my having seen <code>T2</code> used only as a template parameter and mistakenly jumped to the conclusion that I could therefore take the opportunity of forward declaration:</p>\n<pre><code>struct T2;\n\nstruct T1\n{\n    std::auto_ptr&lt;T2&gt; obj;\n};\n</code></pre>\n<p>This invokes UB if I don't go on to define <code>T2</code> somewhere in the same TU, because <code>std::auto_ptr&lt;T2&gt;</code> calls <code>delete</code> on its internal <code>T2*</code>, and <a href=\"https://stackoverflow.com/questions/4325154/delete-objects-of-incomplete-type\">calling <code>delete</code> on an pointer to an object of an incomplete type whose complete type has a non-trivial destructor is undefined</a>:</p>\n<blockquote>\n<p id=\"so_12764952_12764952_0\"><code>[C++11: 5.3.5/5]:</code> If the object being deleted has incomplete class type at the point of deletion and the complete class has a non-trivial destructor or a deallocation function, the behavior is undefined.</p>\n</blockquote>\n<p>The GCC toolchain I happened to be using \u2014 v4.3.3 (Sourcery G++ Lite 2009q1-203) \u2014 was kind enough to let me know with a note:</p>\n<blockquote>\n<p id=\"so_12764952_12764952_1\">note: neither the destructor nor the class-specific operator delete will be called, even if they are declared when the class is defined.</p>\n</blockquote>\n<p>though it seems difficult to get this diagnostic in other GCC versions.</p>\n<p>My gripe was that it would be a lot easier to spot a bug like this if <code>delete</code>ing a pointer to an instance of an incomplete type were <em>ill-formed</em> rather than UB, but that seems like an intractible problem for an implementation to solve, so I understand why it's UB.</p>\n<p>But then I'm told that, if I were to use <code>std::unique_ptr&lt;T2&gt;</code> instead, this would be safe and compliant.</p>\n<p>n3035 allegedly says at 20.9.10.2:</p>\n<blockquote>\n<p id=\"so_12764952_12764952_2\">The template parameter <code>T</code> of <code>unique_ptr</code> may be an incomplete type.</p>\n</blockquote>\n<p>All I can find in C++11 proper is:</p>\n<blockquote>\n<p id=\"so_12764952_12764952_3\"><code>[C++11: 20.7.1.1.1]:</code></p>\n<p id=\"so_12764952_12764952_4\"><strong>/1</strong> The class template <code>default_delete</code> serves as the default deleter (destruction policy) for the class template <code>unique_ptr</code>.</p>\n<p id=\"so_12764952_12764952_5\"><strong>/2</strong> The template parameter <code>T</code> of <code>default_delete</code> may be an incomplete type.</p>\n</blockquote>\n<p>But, <code>default_delete</code>'s <code>operator()</code> does require a complete type:</p>\n<blockquote>\n<p id=\"so_12764952_12764952_6\"><code>[C++11: 20.7.1.1.2/4]:</code> If <code>T</code> is an incomplete type, the program is ill-formed. </p>\n</blockquote>\n<hr>\n<p>I suppose my question is this:</p>\n<p><strong>Are the commenters on my article correct in saying that a translation unit consisting of only the following code is well-formed and well-defined? Or are they wrong?</strong></p>\n<pre><code>struct T2;\n\nstruct T1\n{\n    std::unique_ptr&lt;T2&gt; obj;\n};\n</code></pre>\n<p><strong>If they are correct, how is a compiler expected to implement this, given that there are good reasons for it being UB, at least when an <code>std::auto_ptr</code> is used?</strong></p>\n</hr>", "Title": "Is it true that a unique_ptr declaration, unlike a auto_ptr declaration, is well-defined when its template type is of an incomplete type?", "CreationDate": "2012-10-07T00:01:56.120", "LastActivityDate": "2012-10-07T02:54:51.570", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:33:01.713", "LastEditorUserId": "-1", "Id": "12764952", "Score": "12", "OwnerUserId": "560648", "Tags": "<c++><c++11><language-lawyer><unique-ptr><auto-ptr>", "AnswerCount": "2"}, "12765012": {"Id": "12765012", "PostTypeId": "2", "Body": "<p>According to Herb Sutter in <a href=\"http://herbsutter.com/gotw/_100/\" rel=\"noreferrer\">GOTW #100</a>, <code>unique_ptr</code> suffers from the same problem as <code>auto_ptr</code> with respect to incomplete types.</p>\n<blockquote>\n<p id=\"so_12764952_12765012_0\">...although both unique_ptr and shared_ptr can be instantiated with an\n  incomplete type, unique_ptr\u2019s destructor requires a complete type in\n  order to invoke delete...</p>\n</blockquote>\n<p>His suggestion is to declare the destructor of your containing class (i.e. <code>T1</code>) in the header file, then place it's definition in a translation unit in which <code>T2</code> is a complete type.</p>\n<pre><code>// T1.h\nstruct T2;\n\nstruct T1\n{\n  ~T1();\n  std::unique_ptr&lt; T2 &gt;;\n};\n\n// T1.cpp\n#include \"T2.h\"\n\nT1::~T1()\n{\n}\n</code></pre>\n", "LastEditorUserId": "484307", "LastActivityDate": "2012-10-07T00:23:10.590", "Score": "9", "CreationDate": "2012-10-07T00:14:22.147", "ParentId": "12764952", "CommentCount": "2", "OwnerUserId": "484307", "LastEditDate": "2012-10-07T00:23:10.590"}});