post_cb({"43774769": {"ParentId": "43774223", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You can make it cleaner by using opaque structure definitions. See the second half of the accepted answer here:</p>\n<p><a href=\"https://stackoverflow.com/questions/252780/why-should-we-typedef-a-struct-so-often-in-c\">Why should we typedef a struct so often in C?</a></p>\n<p>Thus the caller is handling pointers to a defined type, but cannot see inside what is being pointed at. The implementation has the actual struct definition, and can work with it. No more casting is required. </p>\n", "OwnerUserId": "2147218", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:01.113", "Id": "43774769", "Score": "0", "CreationDate": "2017-05-04T05:46:05.320", "LastActivityDate": "2017-05-04T05:46:05.320"}, "43774223": {"CommentCount": "17", "ViewCount": "104", "PostTypeId": "1", "LastEditorUserId": "3067276", "CreationDate": "2017-05-04T05:00:44.847", "LastActivityDate": "2017-05-04T14:35:06.173", "Title": "Do C interfaces care about the pointed-to type?", "AcceptedAnswerId": "43774661", "LastEditDate": "2017-05-04T14:35:06.173", "Id": "43774223", "Score": "0", "Body": "<p>I have two pieces of code: The first, inside a C++ program, is where I load and call a function from an external <code>test_lib.so</code>:</p>\n<pre><code>typedef void *(*init_t)(); // init_t is ptr to fcn returning a void*\ntypedef void (*work_t)(void *); // work_t is ptr to fcn taking a void*\n\nvoid *lib = dlopen(\"test_lib.so\", RTLD_NOW);\n\ninit_t init_fcn = dlsym(lib, \"test_fcn\");\nwork_t work_fcn = dlsym(lib, \"work_fcn\");\n\nvoid *data = init_fcn();\nwork_fcn(data);\n</code></pre>\n<p>The second piece of code is the one that compiles to <code>test_lib.so</code>:</p>\n<pre><code>struct Data {\n    // ...\n};\n\nextern \"C\" {\nvoid *init_fcn() {\n    Data *data = new Data; // generate a new Data*...\n    return data; // ...and return it as void*\n}\n\nvoid work_fcn(void *data) { // take a void*...\n    static_cast&lt;Data *&gt;(data)-&gt;blabla(); // ...and treat it as Data*\n    static_cast&lt;Data *&gt;(data)-&gt;bleble();\n}\n}\n</code></pre>\n<p>Now, the first piece of code doesn't need to know what <code>Data</code> is, it just passes the pointer around, so it's a <code>void*</code>. But the library, which works directly with <code>data</code>'s methods and members, needs to know, so it must convert the <code>void*</code>s to <code>Data*</code>s.</p>\n<p>But the interface between the two pieces of code is just some functions with pointer arguments and/or return types. I could just keep the <code>void*</code> in the client, and change every instance of <code>void*</code> in the library to <code>Data*</code>. I did that, and everything works fine (my system is Linux/GCC 6.2.1).</p>\n<p>My question is: was I lucky, or is this guaranteed to work everywhere? If I'm not mistaken, the result of calling some <code>f(Data*)</code> with a <code>void*</code> argument is just as if called <code>reinterpret_cast&lt;Data*&gt;</code> on the <code>void*</code> --- and that couldn't possibly be dangerous. Right?</p>\n<p><strong>EDIT:</strong> No, simply making the <code>Data</code> type transparent to the client code won't work. The client code calls many libraries through the same API, but each library might have its own implementation. For the client, <code>Data</code> could be anything.</p>\n", "Tags": "<c++><pointers><calling-convention><dlopen><abi>", "OwnerUserId": "3067276", "AnswerCount": "3"}, "43774661": {"ParentId": "43774223", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>While this is likely to work in practice, C doesn't guarantee this behavior.</p>\n<p>There are two problems:</p>\n<ol>\n<li><p>Different pointer types can have different sizes and representations. On such an implementation going to <code>void *</code> and back involves an actual conversion at runtime, not just a cast to make the compiler happy. See <a href=\"http://c-faq.com/null/machexamp.html\" rel=\"nofollow noreferrer\">http://c-faq.com/null/machexamp.html</a> for a list of examples, e.g. \"<em>The old HP 3000 series uses a different addressing scheme for byte addresses than for word addresses; like several of the machines above it therefore uses different representations for <code>char *</code> and <code>void *</code> pointers than for other pointers.</em>\"</p></li>\n<li><p>Different pointer types can use different calling conventions. For example, an implementation might pass <code>void *</code> on the stack but other pointers in registers. C doesn't define an ABI, so this is legal.</p></li>\n</ol>\n<p>That said, you're using <code>dlsym</code>, which is a POSIX function. I don't know if POSIX imposes additional requirements that make this code portable (to all POSIX systems).</p>\n<hr>\n<p>On the other hand, why don't you use <code>Data *</code> everywhere? On the client side you can just do</p>\n<pre><code>struct Data;\n</code></pre>\n<p>to leave the type opaque. This fulfills your original requirements (the client can't mess with the internals of <code>Data</code> because it doesn't know what it is, it can only pass pointers around), but also makes the interface a bit safer: You can't accidentally pass the wrong pointer type to it, which would be silently accepted by something taking <code>void *</code>.</p>\n</hr>", "OwnerUserId": "1848654", "LastEditorUserId": "1848654", "LastEditDate": "2017-05-04T05:43:30.963", "Id": "43774661", "Score": "2", "CreationDate": "2017-05-04T05:38:43.800", "LastActivityDate": "2017-05-04T05:43:30.963"}, "bq_ids": {"n4140": {"so_43774223_43774686_0": {"section_id": 6045, "quality": 0.9555555555555556, "length": 43}, "so_43774223_43774686_1": {"section_id": 5988, "quality": 1.0, "length": 18}}, "n3337": {"so_43774223_43774686_0": {"section_id": 5813, "quality": 0.9555555555555556, "length": 43}, "so_43774223_43774686_1": {"section_id": 5756, "quality": 1.0, "length": 18}}, "n4659": {"so_43774223_43774686_0": {"section_id": 7544, "quality": 0.9555555555555556, "length": 43}, "so_43774223_43774686_1": {"section_id": 7488, "quality": 0.7777777777777778, "length": 14}}}, "43774686": {"ParentId": "43774223", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Calling any function through the wrong function type is automatically undefined behavior.  From C++ Standard draft n4604 (roughly C++17) <code>[expr.reinterpret.cast]</code>:</p>\n<blockquote>\n<p id=\"so_43774223_43774686_0\">A function pointer can be explicitly converted to a function pointer of a different type. <strong>The effect of calling a function through a pointer to a function type  that is not the same as the type used in the de\ufb01nition of the function is undefined.</strong> Except that converting a prvalue of type \"pointer to <code>T1</code>\" to the type \"pointer to <code>T2</code>\" (where <code>T1</code> and <code>T2</code> are function types) and back to its original type yields the original pointer value, the\n  result of such a pointer conversion is unspecified.</p>\n</blockquote>\n<p>Calling any function through a function pointer type with the wrong linkage is also undefined behavior.  Your typedefs don't use <code>\"C\"</code> linkage, ergo UB.  From draft n4604 section <code>[expr.call]</code>:</p>\n<blockquote>\n<p id=\"so_43774223_43774686_1\">Calling a function through an expression whose function type has a language linkage that is different from the language linkage of the function type of the called function\u2019s definition is undefined.</p>\n</blockquote>\n<p>Besides that point, different pointer types are not required to have the same representation.  (cv-qualified) <code>void*</code> can hold any object pointer, but its alignment restrictions are the same as <code>char*</code> (that is, no restriction) and as a result, it's not necessarily representation compatible with other object pointer types and <a href=\"https://stackoverflow.com/a/30805279/103167\">may not even be the same size</a>.  (And most definitely, object pointers, function pointers, and the variations on pointer-to-member are frequently different sizes on real-world systems.)</p>\n", "OwnerUserId": "103167", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:54:39.773", "Id": "43774686", "Score": "3", "CreationDate": "2017-05-04T05:40:42.690", "LastActivityDate": "2017-05-04T05:51:36.770"}});