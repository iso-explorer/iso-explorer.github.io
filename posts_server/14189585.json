post_cb({"14189823": {"ParentId": "14189585", "PostTypeId": "2", "CommentCount": "40", "Body": "<p>There is no real reason that lambdas can't have default arguments.  However, there are two main ways to use lambdas, and only one of them would allow default arguments without changing the type system.</p>\n<ol>\n<li><p>You can call the lambda directly, or through a template.  Default parameters would work fine in this case.</p></li>\n<li><p>You can call the lambda through <code>std::function</code>.  Default parameters would not work without changing the type system.</p></li>\n</ol>\n<p>My guess is that new functions that people write in C++11 will <em>usually</em> take <code>std::function</code> parameters because this way, the function won't <em>have</em> to be a template, or it won't have to be instantiated for every single lambda and functor that gets passed to it.</p>\n<h2>Why can't a <code>std::function</code> (or function pointer) take defaults?</h2>\n<p>It's not obvious what the type of such a function would be.</p>\n<ul>\n<li><p>If it's <code>std::function&lt;int(bool)&gt;</code>, then how do you call it with the defaults?  (You can't.)</p></li>\n<li><p>If it's <code>std::function&lt;int(bool=false)&gt;</code>, then what types is it compatible with, and how does conversion work?  Can you convert it to <code>std::function&lt;int()&gt;</code>?  What about <code>std::function&lt;int(bool=true)&gt;</code>?</p></li>\n<li><p>If it's something new like <code>std::function&lt;int(bool=default)&gt;</code>, <em>then</em> what types is it compatible with, and how does conversion work?</p></li>\n</ul>\n<p>Basically, this isn't just a switch you can flip in the standard and make function pointers / <code>std::function</code> handle default arguments.  Default arguments in normal functions are handled using information from the function's declaration, which is not available at the call site for a lambda or function pointer.  So you would have to encode information about the defaults into the function type, and then work out all of the non-obvious rules for conversion and compatibility.</p>\n<p>So you would have to come up with a compelling case for <em>why</em> such a feature would be added, and convince the committee.</p>\n<h2>So, why can't lambdas take defaults?</h2>\n<p>I haven't answered this question.  But I don't think it would be a very useful feature to add.  I would delete this answer if I could, but it's been accepted.  I would downvote it if I could, but it's mine.  C'est la vie.</p>\n", "OwnerUserId": "82294", "LastEditorUserId": "82294", "LastEditDate": "2013-01-07T09:45:25.313", "Id": "14189823", "Score": "13", "CreationDate": "2013-01-07T04:19:09.407", "LastActivityDate": "2013-01-07T09:45:25.313"}, "14189585": {"CommentCount": "24", "AcceptedAnswerId": "14189823", "PostTypeId": "1", "LastEditorUserId": "743214", "CreationDate": "2013-01-07T03:44:15.863", "LastActivityDate": "2013-01-07T17:11:38.703", "LastEditDate": "2013-01-07T08:57:59.803", "ViewCount": "4934", "FavoriteCount": "1", "Title": "What if the lambda expression of C++11 supports default arguments?", "Id": "14189585", "Score": "22", "Body": "<p>I think the following code is very handy and no harmful:</p>\n<pre><code>auto fn = [](bool b = false) -&gt; int // NOT legal in C++11\n{\n    return b ? 1 : 0;\n}; \n</code></pre>\n<p>Why does C++11 explicitly prohibit default arguments of the lambda expression?</p>\n<p>I just wonder the rationales and considerations behind.</p>\n<p>I want to know \"WHY\" rather than \"WHAT\" the C++11 standard says.</p>\n", "Tags": "<c++><c++11><lambda><default-arguments>", "OwnerUserId": "508343", "AnswerCount": "3"}, "14189776": {"ParentId": "14189585", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>As the comments to the question suggest, there's probably no <em>technical</em> reason for there to be no default arguments. But the flip question is \"Is there a <em>practical</em> reason for default arguments?\" I would think the answer to this is \"no\", and here's why.</p>\n<p>In order to call a lambda, one thing you can do is call it right away</p>\n<pre><code>[] { printf(\"foo\"); }();\n</code></pre>\n<p>I'm sure this has limited uses, if any, so let's move on. The only other way to call a lambda is to bind it to a variable first, and there's a few options here.</p>\n<ol>\n<li>Use auto. So we get <code>auto foo = [] { printf(\"foo\"); }; foo();</code></li>\n<li>Bind it to a function pointer: <code>void (*foo)() = [] { printf(\"foo\"); }; foo()</code>. Of course, this only works if the lambda doesn't capture.</li>\n<li>Do the equivalent of either 1 or 2 by passing the lambda to a function or function template.</li>\n</ol>\n<p>Now let's go through the usefulness of default arguments in each case</p>\n<ol>\n<li>We're calling the lambda directly in this case, so the code is probably tight-knit enough that we won't be calling the lambda with various numbers of arguments. If we are, the lambda could (should?) probably be refactored into a more general component. I don't see any practical benefit here.</li>\n<li>(see 1)</li>\n<li>We pass the lambda off to another function. I don't see the practical benefit to a default argument here, either. Think back to good old functors (which can have default arguments) - I can't say I know of too many functions which count on default arguments being present even for these. Since lambdas are effectively just functors, there's no reason for this observation to change suddenly.</li>\n</ol>\n<p>I think these points are enough to say the default arguments to a lambda really aren't that useful. Also, I see some people are talking about issues with the type of a lambda if it had default arguments, but this is a non-issue IMO. You can always write up your own functor that does the same thing, and which <em>does</em> have the default argument. Also, about degrading to a function pointer, there's not much to say either. Take a normal function</p>\n<pre><code>void func(int i = 0)\n{\n}\n</code></pre>\n<p>and take it's address. What do you get? A <code>void (*)(int)</code>. There's no reason a lambda would follow different rules.</p>\n", "OwnerUserId": "616815", "LastEditorUserId": "616815", "LastEditDate": "2013-01-07T04:56:28.660", "Id": "14189776", "Score": "3", "CreationDate": "2013-01-07T04:12:46.207", "LastActivityDate": "2013-01-07T04:56:28.660"}, "bq_ids": {"n4140": {"so_14189585_14196449_1": {"section_id": 3242, "quality": 0.7647058823529411, "length": 26}, "so_14189585_14196449_0": {"section_id": 5768, "quality": 0.631578947368421, "length": 12}, "so_14189585_14196449_2": {"section_id": 3255, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_14189585_14196449_1": {"section_id": 3115, "quality": 0.7647058823529411, "length": 26}, "so_14189585_14196449_0": {"section_id": 5541, "quality": 0.631578947368421, "length": 12}, "so_14189585_14196449_2": {"section_id": 3127, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_14189585_14196449_1": {"section_id": 4000, "quality": 0.7058823529411765, "length": 24}, "so_14189585_14196449_0": {"section_id": 7225, "quality": 0.631578947368421, "length": 12}, "so_14189585_14196449_2": {"section_id": 4013, "quality": 0.8181818181818182, "length": 9}}}, "14196449": {"ParentId": "14189585", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I agree that there is no real \"technical\" restriction <em>per se</em> to allowing default arguments in lambdas to work <em>in some cases</em>. It wouldn't mangle your pointers and <code>auto</code>, because the type of a function is not affected by default arguments. But that's also why this wouldn't be terribly practical.</p>\n<p>Why?</p>\n<p>Because default arguments, while part of a function signature, are not part of a function type:</p>\n<blockquote>\n<p id=\"so_14189585_14196449_0\"><code>[C++11: 1.3.17]:</code><br/>\n<strong>signature</strong><br/>\n  &lt;function&gt; name, parameter type list (8.3.5), and enclosing namespace (if any)<br/>\n  [ <em>Note:</em> Signatures are used as a basis for name mangling and linking. <em>\u2014end note</em> ]</p>\n<p id=\"so_14189585_14196449_1\"><code>[C++11: 8.3.5/6]:</code> <em>[..]</em> The return type, the <em>parameter-type-list</em>, the <em>ref-qualifier</em>, and the <em>cv-qualifier-seq</em>, but not the default arguments (8.3.6) or the exception specification (15.4), are part of the function type. [ <em>Note:</em> Function types are checked during the assignments and initializations of pointers to functions, references to functions, and pointers to member functions. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>They are essentially a piece of syntactic sugar that are \"activated\" by the compiler being able to see the declaration of the function you use, and injected at the point of the function call:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid foo(int x = 5)\n{\n   std::cout &lt;&lt; x &lt;&lt; '\\n';\n}\n\nint main()\n{\n   foo();\n}\n</code></pre>\n<ul>\n<li>Output: <code>5</code></li>\n</ul>\n<p>The default argument is \"visible\".</p>\n<p>However, when you \"hide\" your function behind a pointer:</p>\n<pre><code>int main()\n{\n    void (*bar)(int) = &amp;foo;\n    bar();\n}\n</code></pre>\n<ul>\n<li>Error: <code>too few arguments to function</code></li>\n</ul>\n<p>The type of <code>bar</code> is correct, and the compiler knows that <code>foo</code> has a default, but there's simply no <em>direct</em> syntax that exists to inform the compiler at the point of calling <code>bar</code> that <code>bar</code> is also <code>foo</code>. Sure, in this trivial scenario it could figure it out by observing the assignment, but that's hardly justification for the wider argument.</p>\n<p>For the same reason, default arguments stated only in a definition not visible at the call site are next to useless:</p>\n<pre><code>// a.h\nvoid foo(int);\n\n// a.cpp\n#include \"a.h\"\n#include &lt;iostream&gt;\n\nvoid foo(int x = 5)\n{\n   std::cout &lt;&lt; x &lt;&lt; '\\n';\n}\n\n// main.cpp\n#include \"a.h\"\n\nint main()\n{\n    foo();\n}\n</code></pre>\n<ul>\n<li>Error in main.cpp: <code>too few arguments to function</code></li>\n</ul>\n<p>I imagine that this is the reason for:</p>\n<blockquote>\n<p id=\"so_14189585_14196449_2\"><code>[C++11: 8.3.6/4]:</code> <em>[..]</em> Declarations in different scopes have completely distinct sets of default arguments. <em>[..]</em></p>\n</blockquote>\n<p>We <em>are</em> allowed to \"pile up\" default arguments for class non-template member function definitions (<code>[C++11 8.3.6/6]</code>); the example indicates that this default will still only apply in the same TU, which follows the behaviour we've seen above in my second code snippet.</p>\n<p>So, if default arguments are not part of the function type, and must be unambiguously visible to the call site, then there are only a handful of trivially contrived corner-cases in which they would be useful for lambdas, which is when they are called in the same scope that they are created so the compiler can tractibly figure out how to \"fill in\" the default argument for the call to the lambda and, well, what is the point of that? Not a lot, I tell thee.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2013-01-07T17:11:38.703", "Id": "14196449", "Score": "3", "CreationDate": "2013-01-07T12:56:56.637", "LastActivityDate": "2013-01-07T17:11:38.703"}});