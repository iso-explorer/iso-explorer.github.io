post_cb({"16571948": {"ParentId": "12376461", "CommentCount": "0", "CreationDate": "2013-05-15T18:00:57.963", "OwnerUserId": "827263", "PostTypeId": "2", "Id": "16571948", "Score": "6", "Body": "<p>You asked about both C and C++. The rules are different in the two languages.</p>\n<p>In C, the behavior is undefined only if the caller attempts to use the value returned by the function. If you have:</p>\n<pre><code>int func(void) {\n    /* no return statement */\n}\n\n...\n\nfunc();\n</code></pre>\n<p>then the behavior is well defined.</p>\n<p>In C++, the behavior is undefined (if the function is called at all) whether the caller attempts to use the result or not. (This is for historical reasons; pre-ANSI C didn't have the <code>void</code> keyword, and functions that were not intended to return a value were commonly defined (implicitly) to return <code>int</code>.)</p>\n<p>John Bode's answer already quoted the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"noreferrer\">N1570 draft</a> of the 2011 ISO C standard, 6.9.1p12:</p>\n<blockquote>\n<p id=\"so_12376461_16571948_0\">If the <strong>}</strong> that terminates a function is reached, and the value of the\n  function call is used by the caller, the behavior is undefined.</p>\n</blockquote>\n<p>And paulsm4 cited the C++ standard; quoting the latest 2011 version, 6.6.3p2:</p>\n<blockquote>\n<p id=\"so_12376461_16571948_1\">Flowing off the end of a function is equivalent to a <code>return</code> with no\n  value; this results in undefined behavior in a value-returning\n  function.</p>\n</blockquote>\n<p>The historical reasons that led to C permitting a value-returning function to fail to return a value, as long as the value is not used by the caller, do not apply to C++, whose design was not as strongly influenced by the need to avoid breaking old (pre-ANSI C) code.</p>\n<p>In both C (starting with C99) and C++, the <code>main</code> function is a special case; reaching the closing <code>}</code> of <code>main</code> without executing a return is equivalent to a <code>return 0;</code>. (C permits <code>main</code> to return an implementation-defined type other than <code>int</code>; in that (rare) case, falling off the end returns an unspecified termination status to the host environment.)</p>\n<p>Of course omitting the <code>return</code> statement from a value-returning function, or having a possible execution path that doesn't reach a <code>return</code> statement, is a bad idea. It makes sense only in ancient legacy C code that uses <code>int</code> as a stand-in for <code>void</code>, and in <code>main</code> (though even for <code>main</code>, I personally like to have an explicit <code>return 0;</code>).</p>\n", "LastActivityDate": "2013-05-15T18:00:57.963"}, "12376488": {"ParentId": "12376461", "CommentCount": "3", "CreationDate": "2012-09-11T19:20:40.883", "OwnerUserId": "421195", "PostTypeId": "2", "Id": "12376488", "Score": "11", "Body": "<p>A: No, the missing return would not cause stack corruption</p>\n<p>A: Yes, the behavior would be \"undefined\" if the caller tried to read and/or use the (undefined!) return value.</p>\n<p>PS:</p>\n<p>Here's a citation for C++:</p>\n<blockquote>\n<p id=\"so_12376461_12376488_0\">C++03 \u00a76.6.3/2:</p>\n<p id=\"so_12376461_12376488_1\">Flowing off the end of a function is equivalent to a return with no\n  value; this results in undefined behavior in a value-returning\n  function.</p>\n</blockquote>\n", "LastActivityDate": "2012-09-11T19:20:40.883"}, "12376512": {"ParentId": "12376461", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-09-11T19:22:37.713", "Score": "2", "LastEditorUserId": "1593860", "LastEditDate": "2012-09-11T19:30:38.673", "Id": "12376512", "OwnerUserId": "1593860", "Body": "<p>The compiler is not required to diagnose this because in some cases it's <strong>hard</strong>. So the rule is that the behavior is undefined.</p>\n", "LastActivityDate": "2012-09-11T19:30:38.673"}, "12376529": {"ParentId": "12376461", "CommentCount": "5", "CreationDate": "2012-09-11T19:23:53.823", "OwnerUserId": "16287", "PostTypeId": "2", "Id": "12376529", "Score": "4", "Body": "<p>The standard considers it undefined.</p>\n<p>In practice, memory or a register that has been reserved for the return value will be read.  Whatever's there is whatever's there.</p>\n", "LastActivityDate": "2012-09-11T19:23:53.823"}, "20845670": {"ParentId": "12376461", "CommentCount": "0", "CreationDate": "2013-12-30T18:57:04.320", "OwnerUserId": "971955", "PostTypeId": "2", "Id": "20845670", "Score": "0", "Body": "<p>I did the test in g++.  It seems that you get an object with random stuff in it, i.e. it does dot not call any constructor.  When I'm only dealing with integers, that means that I get a random number.  When I deal with strings, I get a segmentation violation.  I don't know if that's what you meant by corruption, but it's bad.</p>\n<p>As for your first question, I'd go even further.  I want to know why this is a warning that is disabled by default!  It seems pretty important to me.</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nclass X\n{\nprivate:\n  int _x;\npublic:\n  X(int x) : _x(x) { } // No default construcor!                            \n  int get() const { return _x; }\n};\n\nX test1(int x)\n{\n  if (x &gt; 0)\n    return X(x);\n  // warning: control reaches end of non-void function                      \n}\n\nclass Y\n{\nprivate:\n  std::string _y;\npublic:\n  Y(std::string y) : _y(y) { } // No default construcor!                    \n  std::string get() const { return _y; }\n};\n\nY test2(std::string y)\n{\n  if (y.length() &gt; 3)\n    return Y(y);\n  // warning: control reaches end of non-void function                      \n}\n\nint main(int, char**)\n{\n  std::cout&lt;&lt;\"4 -&gt; \"&lt;&lt;test1(4).get()&lt;&lt;std::endl;\n  std::cout&lt;&lt;\"-4 -&gt; \"&lt;&lt;test1(-4).get()&lt;&lt;std::endl;\n  std::cout&lt;&lt;\"stop -&gt; \"&lt;&lt;test2(\"stop\").get()&lt;&lt;std::endl;\n  std::cout&lt;&lt;\"go -&gt; \"&lt;&lt;test2(\"go\").get()&lt;&lt;std::endl;\n}\n</code></pre>\n", "LastActivityDate": "2013-12-30T18:57:04.320"}, "12377086": {"ParentId": "12376461", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2012-09-11T20:05:13.387", "Score": "4", "LastEditorUserId": "134554", "LastEditDate": "2012-09-11T20:13:13.570", "Id": "12377086", "OwnerUserId": "134554", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow\">C 2011 draft N1570</a></p>\n<blockquote id=\"so_12376461_12377086_0\">\n<h3>6.9.1 Function definitions</h3>\n...<br>\n12 If the <code>}</code> that terminates a function is reached, and the value of the function call is used by\nthe caller, the behavior is unde\ufb01ned.\n</br></blockquote>\n<p>\"Undefined\" simply means that the compiler is not required by the language standard to handle this situation in any particular manner; any action is considered \"correct\".  The compiler is free to issue a diagnostic and halt translation, or issue a diagnostic and complete translation (which is what you see), or just ignore the problem completely. </p>\n<p>As to the actual runtime behavior, that depends on things like:</p>\n<ul>\n<li>how is the caller using the return value?</li>\n<li>what is the calling convention being used?</li>\n<li>how does the underlying architecture behave?</li>\n</ul>\n<p>etc.  </p>\n", "LastActivityDate": "2012-09-11T20:13:13.570"}, "12376461": {"CommentCount": "0", "AcceptedAnswerId": "12376488", "PostTypeId": "1", "LastEditorUserId": "16587", "CreationDate": "2012-09-11T19:18:43.177", "LastActivityDate": "2013-12-30T18:57:04.320", "LastEditDate": "2013-05-15T17:37:11.013", "ViewCount": "933", "FavoriteCount": "2", "Title": "What (actually) happens, when a function with the warning \"control reaches end of non-void function\" is called?", "Id": "12376461", "Score": "12", "Body": "<p>I know what this message means, I just wondered why it is <strong>not</strong> an error message, but just a warning?</p>\n<p>What happens in this case? For example, suppose I have a function</p>\n<pre><code>int f()\n{\n}\n</code></pre>\n<p>and what happens when I call it?<br>\nDoes the compiler adds returning of \"non-initialized\" <code>int</code> in this case?<br>\nOr the missing return could cause stack corruption?<br>\nOr it's (absolutely) <em>undefined behavior</em> ?</br></br></br></p>\n<p><sub>Tested with gcc 4.1.2 and 4.4.3</sub></p>\n<hr>\n<p><strong>EDIT:</strong> Reading the answers I understand one thing, reading the comments - another..</p>\n<p>OK, let's summarize: it's <em>undefined behavior</em>. Then, this means, that it is <em>possible</em> to result in stack corruption, right? (it even means, that my computer may start throwing rotten tomatoes over me through the mic jack, screaming - \"what have you done???\").</p>\n<p>But if so, then why the top answer here says, that stack corruption can't happen and, in the same time, that the behaviour is undefined?</p>\n<p>And undefined in respect to? The caller, that tries to use the \"not returned value\", or just the end of the function is undefined, if it must return value, but it doesn't?</p>\n<p>Or it's not undefined behavior, and just the user, who tries to use the value (that is not returned, d'oh!) will \"receive\" undefined <em>value</em>? In other words - just some garbage value and nothing more can happen?</p>\n</hr>", "Tags": "<c++><c>", "OwnerUserId": "435800", "AnswerCount": "7"}, "bq_ids": {"n4140": {"so_12376461_16571948_0": {"section_id": 7182, "quality": 0.6666666666666666, "length": 6}, "so_12376461_16571948_1": {"section_id": 3913, "quality": 1.0, "length": 12}, "so_12376461_12376488_1": {"section_id": 3913, "quality": 1.0, "length": 12}}, "n3337": {"so_12376461_16571948_0": {"section_id": 6926, "quality": 0.6666666666666666, "length": 6}, "so_12376461_16571948_1": {"section_id": 3773, "quality": 1.0, "length": 12}, "so_12376461_12376488_1": {"section_id": 3773, "quality": 1.0, "length": 12}}, "n4659": {"so_12376461_16571948_0": {"section_id": 3923, "quality": 0.6666666666666666, "length": 6}, "so_12376461_16571948_1": {"section_id": 4799, "quality": 0.75, "length": 9}, "so_12376461_12376488_1": {"section_id": 4799, "quality": 0.75, "length": 9}}}, "16573633": {"ParentId": "12376461", "CommentCount": "2", "CreationDate": "2013-05-15T19:40:15.630", "OwnerUserId": "877235", "PostTypeId": "2", "Id": "16573633", "Score": "0", "Body": "<p>I conducted a simple test On Linux 64 bit, GCC 4.63 \nLet's see in practice how does GCC assemble such a thing..</p>\n<p>I created an simple example</p>\n<p><strong>This is the test.c with normal return value</strong></p>\n<pre><code>int main()\n{\n    return 0;\n}\n</code></pre>\n<p><strong>This is the GCC assembler output for test.c:</strong></p>\n<pre><code>main:\n.LFB0:\n    .cfi_startproc\n    pushq   %rbp\n    .cfi_def_cfa_offset 16\n    .cfi_offset 6, -16\n    movq    %rsp, %rbp\n    .cfi_def_cfa_register 6\n    movl    $0, %eax\n    popq    %rbp\n    .cfi_def_cfa 7, 8\n    ret\n    .cfi_endproc\n</code></pre>\n<p><strong>This is the test2.c with no return value</strong></p>\n<pre><code>int main()\n{\n}\n</code></pre>\n<p><strong>This is GCC assembler output for test2.c:</strong></p>\n<pre><code>main:\n.LFB0:\n    .cfi_startproc\n    pushq   %rbp\n    .cfi_def_cfa_offset 16\n    .cfi_offset 6, -16\n    movq    %rsp, %rbp\n    .cfi_def_cfa_register 6\n    popq    %rbp\n    .cfi_def_cfa 7, 8\n    ret\n    .cfi_endproc\n</code></pre>\n<p>Basically we can see that the following line is missing.</p>\n<pre><code>    movl    $0, %eax\n</code></pre>\n<p>This line moves a value to <code>eax</code> register which is the return value of the function. If the function was used in real life situation, the <code>eax</code> register which probably contains garbage value would represent the return value of <code>main()</code>...</p>\n", "LastActivityDate": "2013-05-15T19:40:15.630"}});