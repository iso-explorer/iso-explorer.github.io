post_cb({"bq_ids": {"n4140": {"so_32867939_32868057_0": {"length": 90, "quality": 0.9278350515463918, "section_id": 6106}, "so_32867939_32868057_1": {"length": 41, "quality": 1.0, "section_id": 6107}, "so_32867939_32868057_2": {"length": 49, "quality": 0.8909090909090909, "section_id": 7218}}, "n3337": {"so_32867939_32868057_0": {"length": 90, "quality": 0.9278350515463918, "section_id": 5872}, "so_32867939_32868057_1": {"length": 41, "quality": 1.0, "section_id": 5873}, "so_32867939_32868057_2": {"length": 48, "quality": 0.8727272727272727, "section_id": 6962}}, "n4659": {"so_32867939_32868057_0": {"length": 90, "quality": 0.9278350515463918, "section_id": 7603}, "so_32867939_32868057_1": {"length": 41, "quality": 1.0, "section_id": 7604}, "so_32867939_32868057_2": {"length": 39, "quality": 0.7090909090909091, "section_id": 8727}}}, "32867939": {"ViewCount": "109", "Body": "<p>Is the following code safe? Is there a reference to C++ standard addressing this question?</p>\n<pre><code>// SomeStruct is POD: no constructors or destructor\nSomeStruct *pSS = new SomeStruct();\nvoid *pV = reinterpret_cast&lt;void*&gt;(pSS);\ndelete pV;\n</code></pre>\n", "AcceptedAnswerId": "32868057", "Title": "Is it safe to delete memory with a pointer of different type than the used in new?", "CreationDate": "2015-09-30T13:53:26.317", "Id": "32867939", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-09-30T14:14:09.433", "Score": "3", "OwnerUserId": "1915854", "Tags": "<c++><new-operator><heap-memory><delete-operator>", "AnswerCount": "2"}, "32868057": {"Id": "32868057", "PostTypeId": "2", "Body": "<p>This is only OK when:</p>\n<ol>\n<li><p>you delete a pointer-to-base,</p></li>\n<li><p><em>and</em> that base class has a virtual destructor.</p></li>\n</ol>\n<p>Otherwise, you're in the land of illegal code and undefined behaviour.</p>\n<p>C++14 5.3.5/2</p>\n<blockquote>\n<p id=\"so_32867939_32868057_0\">If the operand has a class type, the operand is converted to a pointer type by calling the above-mentioned conversion function, and the converted operand is used in place of the original operand for the remainder of this section. In the first alternative (<em>delete object</em>), the value of the operand of <code>delete</code> may be a null pointer value, a pointer to a non-array object created by a previous <em>new-expression</em>, or a pointer to a subobject (1.8) representing a base class of such an object (Clause 10). If not, the behavior is undefined. In the second alternative (<em>delete array</em>), the value of the operand of <code>delete</code> may be a null pointer value or a pointer value that resulted from a previous array <em>new-expression</em>. If not, the behavior is undefined. [ <em>Note:</em> this means that the syntax of the <em>delete-expression</em> must match the type of the object allocated by <code>new</code>, not the syntax of the <em>new-expression</em>. \u2014 <em>end note</em> ] [ <em>Note:</em> a pointer to a const type can be the operand of a <em>delete-expression</em>; it is not necessary to cast away the constness (5.2.11) of the pointer expression before it is used as the operand of the <em>delete-expression</em>. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>C++14 5.3.5/3</p>\n<blockquote>\n<p id=\"so_32867939_32868057_1\">In the first alternative (<em>delete object</em>), if the static type of the object to be deleted is different from its dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the static type shall have a virtual destructor or the behavior is undefined. In the second alternative (<em>delete array</em>) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.</p>\n</blockquote>\n<p>Additionally, <code>void</code> is an incomplete type (C++14 3.9.1/9):</p>\n<blockquote>\n<p id=\"so_32867939_32868057_2\">The <code>void</code> type has an empty set of values. The <code>void</code> type is an incomplete type that cannot be completed. It is used as the return type for functions that do not return a value. Any expression can be explicitly converted to type <em>cv</em> <code>void</code> (5.4). An expression of type <code>void</code> shall be used only as an expression statement (6.2), as an operand of a comma expression (5.19), as a second or third operand of <code>?:</code> (5.16), as the operand of <code>typeid</code>, <code>noexcept</code>, or <code>decltype</code>, as the expression in a return statement (6.6.3) for a function with the return type <code>void</code>, or as the operand of an explicit conversion to type <em>cv</em> <code>void</code>.</p>\n</blockquote>\n<hr>\n<p>Also, unless you're interfacing with a C API, <code>void*</code> is something you should strive to avoid completely.</p>\n</hr>", "LastEditorUserId": "256138", "LastActivityDate": "2015-09-30T14:14:09.433", "Score": "7", "CreationDate": "2015-09-30T13:59:05.963", "ParentId": "32867939", "CommentCount": "2", "OwnerUserId": "256138", "LastEditDate": "2015-09-30T14:14:09.433"}, "32868073": {"Id": "32868073", "PostTypeId": "2", "Body": "<p>Not only it is illegal, it is simply a compilation error on modern compilers. Can't delete void*.</p>\n", "LastActivityDate": "2015-09-30T13:59:55.723", "CommentCount": "4", "CreationDate": "2015-09-30T13:59:55.723", "ParentId": "32867939", "Score": "-1", "OwnerUserId": "5245033"}});