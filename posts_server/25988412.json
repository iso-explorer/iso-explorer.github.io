post_cb({"25988568": {"Id": "25988568", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_25988412_25988568_0\">You can actually use <code>operator-&gt;</code> on arrays.</p>\n</blockquote>\n<p>Yes, the standard <em>array-to-pointer</em> conversion means that an expression of array type, like <code>foo</code>, can decay to a pointer to the first array element if it's used in a context where a pointer is expected.</p>\n<blockquote>\n<p id=\"so_25988412_25988568_1\">I thought operator-&gt; was only for pointers to objects</p>\n</blockquote>\n<p>It's for any type that's convertible to an object pointer - including an array - and for any class type that it's overloaded for.</p>\n<blockquote>\n<p id=\"so_25988412_25988568_2\">Even if there were pointers, they'd be dangling pointers because of the <code>Foo</code> temporaries.</p>\n</blockquote>\n<p>No, <code>foo</code> is not a temporary, and neither are the elements it contains. You initialised them by copying temporaries, but the copies in the array last as long as the array itself.</p>\n", "LastActivityDate": "2014-09-23T06:44:16.130", "CommentCount": "0", "CreationDate": "2014-09-23T06:44:16.130", "ParentId": "25988412", "Score": "3", "OwnerUserId": "204847"}, "25988512": {"Id": "25988512", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_25988412_25988512_0\">I thought operator-&gt; was only for pointers to objects, and I don't see any pointers in this code.</p>\n</blockquote>\n<p>An array decays to pointer when used in an expression like you have.</p>\n<blockquote>\n<p id=\"so_25988412_25988512_1\">Even if there were pointers, they'd be dangling pointers because of the Foo temporaries. What makes this possible?</p>\n</blockquote>\n<p>The line </p>\n<pre><code> Foo foo[3] = { Foo(), Foo(), Foo() }\n</code></pre>\n<p>fills <code>foo</code> with three valid objects, not temporaries.</p>\n", "LastActivityDate": "2014-09-23T06:41:22.067", "CommentCount": "0", "CreationDate": "2014-09-23T06:41:22.067", "ParentId": "25988412", "Score": "2", "OwnerUserId": "434551"}, "25988543": {"Id": "25988543", "PostTypeId": "2", "Body": "<p>You declare an array of 3 <code>Foo</code> instances. You initialize the array by creating 3 instances with <code>{ Foo(), Foo(), Foo() }</code> and they are not moved or copied into place in the array, they are actually created there, so no temporaries exist.</p>\n", "LastActivityDate": "2014-09-23T06:43:07.423", "CommentCount": "0", "CreationDate": "2014-09-23T06:43:07.423", "ParentId": "25988412", "Score": "2", "OwnerUserId": "6345"}, "25988504": {"Id": "25988504", "PostTypeId": "2", "Body": "<p>Arrays are allowed to decay to pointers, and these point to the first element of the array. So for example, you can do this:</p>\n<pre><code>void bar(int*) {}\n\nint a[42] = {};\nint* b = a;      // a decayed to int*, got assigned to b\nbar(a);          // a decayed to int* to match bar parameter type\n</code></pre>\n<p>In your example, <code>foo</code> decays to a pointer to the first element of the array <code>foo</code> when you apply the <code>-&gt;</code> operator. The following two are equivalent:</p>\n<pre><code>foo-&gt;bar();\n(&amp;foo[0])-&gt;bar();\n</code></pre>\n<p>Concerning the validity of the object pointed at, an array such as </p>\n<pre><code>Foo foo[3];\n</code></pre>\n<p>always contains 3 default initialized <code>Foo</code> objects. What you have done is initialize them explicitly, but that doesn't change anything. The array contains copies of the objects you used to initialize its elements.</p>\n", "LastActivityDate": "2014-09-23T06:40:49.927", "CommentCount": "0", "CreationDate": "2014-09-23T06:40:49.927", "ParentId": "25988412", "Score": "5", "OwnerUserId": "661519"}, "bq_ids": {"n4140": {"so_25988412_25988540_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 11}}, "n3337": {"so_25988412_25988540_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 8}}, "n4659": {"so_25988412_25988540_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 12}}}, "25988412": {"ViewCount": "82", "Body": "<p>I just discovered this weird syntax by accident. You can actually use operator-&gt; on arrays.</p>\n<pre><code>struct Foo\n{\n    void bar() { }\n};\n\nint main()\n{\n    Foo foo[3] = { Foo(), Foo(), Foo() };\n    foo-&gt;bar();\n}\n</code></pre>\n<p>I thought operator-&gt; was only for pointers to objects, and I don't see any pointers in this code. Even if there were pointers, they'd be dangling pointers because of the Foo temporaries. What makes this possible?</p>\n", "AcceptedAnswerId": "25988504", "Title": "Using -> operator on arrays", "CreationDate": "2014-09-23T06:35:52.723", "Id": "25988412", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-09-23T06:51:24.380", "Score": "3", "OwnerUserId": "4069289", "Tags": "<c++>", "AnswerCount": "5"}, "25988540": {"Id": "25988540", "PostTypeId": "2", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3820.html\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3820.html</a></p>\n<p>\u00a7 4.2 Array-to-pointer conversion [conv.array]</p>\n<blockquote>\n<p id=\"so_25988412_25988540_0\"><sup>1</sup> An lvalue or rvalue of type <code>array of N T</code> or <code>array of unknown\n  bound of T</code> can be converted to an rvalue of type <code>pointer to T.</code>\n  The result is a pointer to the first element of the array.</p>\n</blockquote>\n", "LastEditorUserId": "4069289", "LastActivityDate": "2014-09-23T06:51:24.380", "Score": "2", "CreationDate": "2014-09-23T06:42:54.683", "ParentId": "25988412", "CommentCount": "0", "OwnerUserId": "4069289", "LastEditDate": "2014-09-23T06:51:24.380"}});