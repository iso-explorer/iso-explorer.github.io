post_cb({"23196675": {"ParentId": "10747810", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The <strong>using</strong> syntax has an advantage when used within templates. If you need the type abstraction, but also need to keep template parameter to be possible to be specified in future. You should write something like this.</p>\n<pre><code>template &lt;typename T&gt; struct whatever {};\n\ntemplate &lt;typename T&gt; struct rebind\n{\n  typedef whatever&lt;T&gt; type; // to make it possible to substitue the whatever in future.\n};\n\nrebind&lt;int&gt;::type variable;\n\ntemplate &lt;typename U&gt; struct bar { typename rebind&lt;U&gt;::type _var_member; }\n</code></pre>\n<p>But <strong>using</strong> syntax simplifies this use case.</p>\n<pre><code>template &lt;typename T&gt; using my_type = whatever&lt;T&gt;;\n\nmy_type&lt;int&gt; variable;\ntemplate &lt;typename U&gt; struct baz { my_type&lt;U&gt; _var_member; }\n</code></pre>\n", "OwnerUserId": "2061081", "LastEditorUserId": "2061081", "LastEditDate": "2016-02-24T12:51:25.697", "Id": "23196675", "Score": "134", "CreationDate": "2014-04-21T11:39:59.273", "LastActivityDate": "2016-02-24T12:51:25.697"}, "10747810": {"CommentCount": "7", "AcceptedAnswerId": "10748056", "PostTypeId": "1", "LastEditorUserId": "2034041", "CreationDate": "2012-05-25T02:39:51.960", "LastActivityDate": "2016-12-13T17:33:41.877", "LastEditDate": "2014-05-07T13:16:54.800", "ViewCount": "141444", "FavoriteCount": "146", "Title": "What is the difference between 'typedef' and 'using' in C++11?", "Id": "10747810", "Score": "571", "Body": "<p>I know that in C++11 we can now use <code>using</code> to write type alias, like <code>typedef</code>s:</p>\n<pre><code>typedef int MyInt;\n</code></pre>\n<p>Is, from what I understand, equivalent to:</p>\n<pre><code>using MyInt = int;\n</code></pre>\n<p>And that new syntax emerged from the effort to have a way to express \"<code>template typedef</code>\":</p>\n<pre><code>template&lt; class T &gt; using MyType = AnotherType&lt; T, MyAllocatorType &gt;;\n</code></pre>\n<p>But, with the first two non-template examples, are there any other subtle differences in the standard? For example, <code>typedef</code>s do aliasing in a \"weak\" way. That is it does not create a new type but only a new name (conversions are implicit between those names).</p>\n<p>Is it the same with <code>using</code> or does it generate a new type? Are there any differences?</p>\n", "Tags": "<c++><c++11><typedef><using-declaration>", "OwnerUserId": "2368", "AnswerCount": "3"}, "10748056": {"ParentId": "10747810", "CommentCount": "10", "Body": "<p>They are equivalent, from the standard (emphasis mine) (7.1.3.2):</p>\n<blockquote>\n<p id=\"so_10747810_10748056_0\">A typedef-name can also be introduced by an alias-declaration. The\n  identifier following the using keyword becomes a typedef-name and the\n  optional attribute-specifier-seq following the identifier appertains\n  to that typedef-name. <strong>It has the same semantics as if it were\n  introduced by the typedef specifier.</strong> In particular, it\n  does not define a new type and it shall not appear in the type-id.</p>\n</blockquote>\n", "OwnerUserId": "906773", "PostTypeId": "2", "Id": "10748056", "Score": "387", "CreationDate": "2012-05-25T03:16:42.650", "LastActivityDate": "2012-05-25T03:16:42.650"}, "bq_ids": {"n4140": {"so_10747810_10748056_0": {"section_id": 5408, "quality": 0.967741935483871, "length": 30}}, "n3337": {"so_10747810_10748056_0": {"section_id": 5203, "quality": 0.967741935483871, "length": 30}}, "n4659": {"so_10747810_10748056_0": {"section_id": 6830, "quality": 0.9032258064516129, "length": 28}}}, "32959200": {"ParentId": "10747810", "CommentCount": "1", "Body": "<p>They are largely the same, except that</p>\n<p><code>The alias declaration is compatible with templates, whereas the C style typedef is not.\n</code></p>\n", "OwnerUserId": "2936728", "PostTypeId": "2", "Id": "32959200", "Score": "88", "CreationDate": "2015-10-05T22:58:29.870", "LastActivityDate": "2015-10-05T22:58:29.870"}});