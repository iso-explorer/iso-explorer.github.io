post_cb({"1110147": {"Id": "1110147", "PostTypeId": "2", "Body": "<p>you need to know more about anotherfunc() to tell what will happen when you pass it null. it might be fine, it might crash, depends on the code.</p>\n", "LastActivityDate": "2009-07-10T15:15:30.227", "CommentCount": "4", "CreationDate": "2009-07-10T15:15:30.227", "ParentId": "1110111", "Score": "0", "OwnerUserId": "136328"}, "1110198": {"Id": "1110198", "PostTypeId": "2", "Body": "<p>Although in the standards dereferencing a zero pointer (NULL) is undefined behavior, current processors and operating systems generate a segmentation fault or similar error.</p>\n<p>Maybe that function you called accepts a reference parameter (which IS a pointer) and that function doesn't use the paramenter, so the NULL won't be dereferenced.</p>\n", "LastEditorUserId": "77536", "LastActivityDate": "2009-07-10T15:28:41.640", "Score": "0", "CreationDate": "2009-07-10T15:21:18.300", "ParentId": "1110111", "CommentCount": "0", "OwnerUserId": "77536", "LastEditDate": "2009-07-10T15:28:41.640"}, "1110294": {"Id": "1110294", "PostTypeId": "2", "Body": "<p>There is a concept, in the standard, of a null pointer value.  This is a distinct value that causes undefined behavior when the program attempts to access memory through it.  In practice, lots of modern implementations have it crash the program, which is useful behavior.  After all, such an attempt is a mistake.</p>\n<p>The name of the null pointer value is <code>0</code>, or any other constant integral expression in pointer context (like <code>3 - 3</code>, for example).  There is also a <code>NULL</code> macro, which has to evaluate to 0 in C++ but can be <code>(void *)0</code> in C (C++ insists more on pointers being type-safe).  In C++0x, there will be an explicit value called <code>nullptr</code>, finally giving the null pointer an explicit name.</p>\n<p>The value of the null pointer doesn't have to be an actual zero, although it is on all implementations I'm aware of, and the odd computers where that didn't work have mostly been retired.</p>\n<p>You're misstating what happens in your last example.  <code>*b</code> doesn't resolve into anything.  Passing <code>*b</code> is undefined behavior, which means the implementation can do anything it likes with it.  It may or may not be flagged as an error, and may or may not cause problems.  The behavior can change for no apparent reason, and so doing this is a mistake.</p>\n<p>If a called function is expecting a pointer value, passing it a null pointer value is perfectly legitimate, and the called function should handle it properly.  Dereferencing a null pointer value is never legitimate.</p>\n", "LastActivityDate": "2009-07-10T15:37:10.907", "CommentCount": "3", "CreationDate": "2009-07-10T15:37:10.907", "ParentId": "1110111", "Score": "6", "OwnerUserId": "14148"}, "1110337": {"Id": "1110337", "PostTypeId": "2", "Body": "<p>In the early days, programmers were spending lot of time tracing down memory corruption bugs. One day a light bulb light up in some smart programmer's head. He said \"What if I make it illegal to access the first page of memory and point all invalid pointers to it?\" Once that happened, most memory corruption bugs were quickly found.</p>\n<p>That's the history behind null pointer. I heard the story so many years ago, I can't recall any detail now, but I'm sure someone how's older...I mean wiser can tell us more about it.</p>\n", "LastActivityDate": "2009-07-10T15:43:21.923", "CommentCount": "0", "CreationDate": "2009-07-10T15:43:21.923", "ParentId": "1110111", "Score": "1", "OwnerUserId": "96885"}, "1110196": {"Id": "1110196", "PostTypeId": "2", "Body": "<p>It would still cause a crash because you're still instructing the compiler to attempt to access the memory at location 0 (which is forbidden).  Depending on the signature of <code>anotherfunc</code>, you may be passing a reference (which are forbidden from being initialized with a NULL object), or a <em>copy</em> of <code>*b</code>.</p>\n", "LastActivityDate": "2009-07-10T15:21:06.973", "CommentCount": "0", "CreationDate": "2009-07-10T15:21:06.973", "ParentId": "1110111", "Score": "0", "OwnerUserId": "81214"}, "bq_ids": {"n4140": {"so_1110111_1110540_0": {"length": 19, "quality": 0.95, "section_id": 6064}}, "n3337": {"so_1110111_1110540_0": {"length": 19, "quality": 0.95, "section_id": 5832}}, "n4659": {"so_1110111_1110540_0": {"length": 18, "quality": 0.9, "section_id": 7560}}}, "1110751": {"Id": "1110751", "PostTypeId": "2", "Body": "<p>Tom's comment is correct, I did not initialize correctly therefore the question is ambiguous at best yet most everyone directly answered my question, I unwittingly submitted the question while not logged in (sorry I'm new to stackoverflow)  so can someone with editing powers update the OP?</p>\n<pre><code>//  #2\nsomeObj * b;\nanotherObj * c = new anotherObj();        //initialize c\nb = NULL;\nc-&gt;anotherfunc(*b);   // *b is in question not the c dereference\n</code></pre>\n", "LastEditorUserId": "136396", "LastActivityDate": "2009-07-10T17:10:20.577", "Score": "0", "CreationDate": "2009-07-10T17:04:45.473", "ParentId": "1110111", "CommentCount": "0", "OwnerUserId": "136396", "LastEditDate": "2009-07-10T17:10:20.577"}, "1110540": {"Id": "1110540", "PostTypeId": "2", "Body": "<p>That depends on the declaration of anotherfunc()</p>\n<pre><code>someObj * b;\nanotherObj * c;\nb = NULL;\nc-&gt;anotherfunc(*b); \n</code></pre>\n<p>If anotherfunc() accepts a reference to b then you have not de-referenceed b, you have just converted it into a reference. If on the other hand it is a value parameter then a copy constructor will be invoked and then you have de-referenced it.</p>\n<p>Weather it will crash will depend on many factors (like if it has members). But the act of de-referencing on a NULL is undefined so it has the option of working on your compiler.</p>\n<p>As for the first option of calling a method on a NULL pointer.<br>\nThis also is undefined behavior. Weather it crashes will depend on the compiler and OS. But it is perfectly valid to not crash (the behavior is undefined).</br></p>\n<p>A lot of confusion is derived because people refer to the * in *b as de-reference operator. This may be its common name but in the standard it is the 'unary * operator' and it is defined as:</p>\n<blockquote>\n<h3>5.3.1</h3>\n<p id=\"so_1110111_1110540_0\">The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points.</p>\n</blockquote>\n<p>So the 'unary * operator' returns a reference to the object that was pointed at by the pointer it was applied to. (No de-referencing has happened at this point).</p>\n", "LastEditorUserId": "14065", "LastActivityDate": "2009-07-10T16:28:51.190", "Score": "3", "CreationDate": "2009-07-10T16:21:07.480", "ParentId": "1110111", "CommentCount": "0", "OwnerUserId": "14065", "LastEditDate": "2009-07-10T16:28:51.190"}, "1110197": {"Id": "1110197", "PostTypeId": "2", "Body": "<p>You are wandering in undefined territories.</p>\n<p>You can think of calling a member function like calling a regular function with the additional, implicit <code>this</code> pointer argument. The function call itself is just putting the arguments in place according to call convention and jumping to a memory address.</p>\n<p>So just calling a member function on a NULL object pointer does not necassarily cause a crash (unless it is a virtual function). You get invalid memory access crashes only when you try to access the object's member variables or vtable.</p>\n<p>In case #2 you may or may not get an immediate crash, depending on how <code>anotherfunc</code> is declared. If it takes <code>someObj</code> by value, then you're indirecting NULL in the function call itself, resulting in a crash. If it takes <code>someObj</code> by reference, usually nothing happens since references are implemented using pointers under the hood and the actual indirection is postponed until you try to access member data.</p>\n", "LastActivityDate": "2009-07-10T15:21:09.250", "CommentCount": "0", "CreationDate": "2009-07-10T15:21:09.250", "ParentId": "1110111", "Score": "0", "OwnerUserId": "101361"}, "1110174": {"Id": "1110174", "PostTypeId": "2", "Body": "<p>It would still cause a crash, but that's not necessarily undesired behaviour.  Part of the usefulness of <code>NULL</code> is that, on most platforms, it points to memory that is explicitly inaccessible to your application, and causes a segmentation fault (or access violation) the very moment you try to dereference it.</p>\n<p>Its purpose is to explicitly mark the contents of pointers as invalid.</p>\n", "LastActivityDate": "2009-07-10T15:18:39.037", "CommentCount": "0", "CreationDate": "2009-07-10T15:18:39.037", "ParentId": "1110111", "Score": "2", "OwnerUserId": "120338"}, "1110157": {"Id": "1110157", "PostTypeId": "2", "Body": "<p>NULL is just 0.  Since 0 doesn't point to a real memory address, you can't dereference it.  *b can't just resolve to NULL, since NULL is something that applies to pointers, not objects.</p>\n", "LastActivityDate": "2009-07-10T15:16:36.857", "CommentCount": "1", "CreationDate": "2009-07-10T15:16:36.857", "ParentId": "1110111", "Score": "-1", "OwnerUserId": "112713"}, "1110111": {"ViewCount": "2264", "Body": "<p>I am curious as to what part of the dereferencing a NULL ptr causes undesired behavior.  Example:</p>\n<pre><code>//  #1\nsomeObj * a;\na = NULL;\n(*a).somefunc();   // crash, dereferenced a null ptr and called one of its function\n                   // same as a-&gt;somefunc();\n\n//  #2\nsomeObj * b;\nanotherObj * c;\nb = NULL;\nc-&gt;anotherfunc(*b);   // dereferenced the ptr, but didn't call one of it's functions\n</code></pre>\n<p>Here we see in #2 that I didn't actually try to access data or a function out of b, so would this still cause undesired behavior if *b just resolves to NULL and we're passing NULL into anotherfunc() ?</p>\n", "Title": "What part of dereferencing NULL pointers causes undesired behavior?", "CreationDate": "2009-07-10T15:11:01.530", "LastActivityDate": "2009-07-10T17:10:20.577", "CommentCount": "2", "PostTypeId": "1", "OwnerDisplayName": "BuckFilledPlatypus", "Id": "1110111", "Score": "2", "Tags": "<c++>", "AnswerCount": "16"}, "1110370": {"Id": "1110370", "PostTypeId": "2", "Body": "<p>Whether or not the mere fact of dereferencing a null pointer already results in undefined behavior is currently a gray zone in the Standard, unfortunately. What is certain is that reading a value out of the result of dereferencing a pointer is undefined behavior. </p>\n<p>That it <em>is</em> undefined behavior is stated by various notes throughout the Standard. But notes are not normative: They could say anything, but they will never be able to state any rules. Their purpose is entirely informative. </p>\n<p>That calling a member function on a null pointer formally is undefined behavior too.</p>\n<hr>\n<p>The formal problem with merely dereferencing a null pointer is that determining the identity of the resulting lvalue expression is not possible: Each such expression that results from dereferencing a pointer must unambiguously refer to an object or a function when that expression is evaluated. If you dereference a null pointer, you don't have an object or function that this lvalue identifies. This is the argument the Standard uses to forbid null-references. </p>\n<p>Another problem that adds to the confusion is that the semantics of the <code>typeid</code> operator make part of this misery well defined. It says that if it was given an lvalue that resulted from dereferencing a null pointer, the result is throwing a <code>bad_typeid</code> exception. Although, this is a limited area where there exist an exception (no pun) to the above problem of finding an identity. Other cases exist where similar exception to undefined behavior is made (although much less subtle and with a reference on the affected sections).</p>\n<p>The committee discussed to solve this problem globally, by defining a kind of lvalue that does not have an object or function identity: The so called <em>empty lvalue</em>. That concept, however, still had problems, and they decided <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#232\" rel=\"nofollow noreferrer\">not to adopt it</a>.</p>\n<hr>\n<p>Now, practically, you will not encounter a crash when merely dereferencing a null pointer. The problem of identifying an object or function for an lvalue seems to be entirely language theoretical. What is problematic is when you try to read a value out of the result of dereference. The following case will almost certainly crash, because it tries to read an integer from an address which is most probably not mapped by the affected process</p>\n<pre><code>int a = *(int*)0;\n</code></pre>\n<p>There are few cases where reading out of such an expression probably won't cause a crash. One is when you dereference an array pointer:</p>\n<pre><code>int *pa = *(int(*)[1])0;\n</code></pre>\n<p>Since reading from an array just returns its address using a element pointer type, this will most probably just make a null pointer (but as you dereference a null pointer before, this still is undefined behavior formally). Another case is dereferencing of function null pointers. Here too, reading a function lvalue just give you its address but using a function pointer type:</p>\n<pre><code>void(*pf)() = *(void(*)())0;\n</code></pre>\n<p>Aswell as the other cases, this is undefined behavior too, of course, but will probably <em>not</em> result in a crash.</p>\n<p>Like the above cases, just calling a non-virtual member function on a null pointer isn't practically problematic either, most probably - even though it formally is undefined behavior. Calling the function will jump to the functions address, and don't need to read any data. As soon as you would try to read a nonstatic data-member, the same problem occurs as when reading out of a normal null pointer. Some people place an </p>\n<pre><code>assert(this != NULL);\n</code></pre>\n<p>In front of some member function bodies in case they accidentally called a function on a null pointer. This may be a good idea when there are often cases where such functions are mistakenly called on null pointers, to catch errors early. But from a formal point of view, <code>this</code> can never be a null pointer in a member function. </p>\n</hr></hr>", "LastActivityDate": "2009-07-10T15:47:08.217", "CommentCount": "0", "CreationDate": "2009-07-10T15:47:08.217", "ParentId": "1110111", "Score": "3", "OwnerUserId": "34509"}, "1110202": {"Id": "1110202", "PostTypeId": "2", "Body": "<p>The second example is also undefined behavior, yes. You are only allowed to call member functions on a valid object. And a null pointer does not point to a valid object.</p>\n<p>The reason why it <em>appears</em> to work is that member functions are typically implemented roughly like this:</p>\n<pre><code>void anotherfunc(anotherObj* this, someObj&amp; arg);\n</code></pre>\n<p>That is, the \"this\" pointer is basically passed to the function as a separate argument. So while calling the function, the compiler doesn't check that the <code>this</code> pointer is valid, it just passes it to the function.</p>\n<p>It is still undefined behavior though. The compiler isn't guaranteed to let this work.</p>\n", "LastActivityDate": "2009-07-10T15:22:08.813", "CommentCount": "4", "CreationDate": "2009-07-10T15:22:08.813", "ParentId": "1110111", "Score": "3", "OwnerUserId": "33213"}, "1110195": {"Id": "1110195", "PostTypeId": "2", "Body": "<p>In practice, it doesn't crash until it needs to use the <code>NULL</code> value. This means that you can call non-virtual functions because they are bound at compile time. It calls the function just fine and passes in a <code>NULL</code> <code>this</code> pointer. Now if you try to use any member variables then it will crash because it will try to look them up based on the <code>this</code> pointer passed in. You can also call other non-virtual functions by the same argument. Now if you try to use a virtual function it will immediately crash because it tries to find the <code>vtable</code> from the <code>NULL</code> pointer.  </p>\n<p>We ran into a case like this and I had to write some example code to demonstrate to the other developers that even though it was reporting the error in 2 levels of calls to member functions it was actually a <code>NULL</code> pointer that was being called. The error was manifested when an actual value was used.</p>\n", "LastActivityDate": "2009-07-10T15:21:06.957", "CommentCount": "0", "CreationDate": "2009-07-10T15:21:06.957", "ParentId": "1110111", "Score": "2", "OwnerUserId": "852"}, "1110141": {"Id": "1110141", "PostTypeId": "2", "Body": "<p>Reading from or writing to the invalid memory location causes a crash.</p>\n<p>A call to a member function through an invalid object pointer will usually succeed, if the method is not virtual and the method does not access any members of the object, since this involves no reads or writes related to the object pointer.</p>\n<p>(This is not guaranteed by the standard, even though it work that way on all compilers i ever encountered)</p>\n", "LastActivityDate": "2009-07-10T15:15:00.697", "CommentCount": "0", "CreationDate": "2009-07-10T15:15:00.697", "ParentId": "1110111", "Score": "2", "OwnerUserId": "31317"}, "1110435": {"Id": "1110435", "PostTypeId": "2", "Body": "<p>I agree with Buck, in that in many cases it would be nice if calling a instance function on <code>null</code> resulted in <code>null</code>.  However, I don't think that it should be the default.  Instead there should be another operator (I'll leave what that is up to someone else, but let's say it's <code>-&gt;&gt;</code>).</p>\n<p>One issue in C++, for instance, is that not all return types can be <code>null</code> anyway, such as <code>int</code>.  So a call to <code>a-&gt;&gt;length()</code> would be difficult to know what to return when <code>a</code> itself was <code>null</code>.</p>\n<p>Other languages where everything is a reference type, you would not have this problem.</p>\n<p>Finally, Buck, what everyone else is saying is the way things are, especially for the C++ language: Dereferencing is a mechanical operation in most languages:  It must return something of the same type and <code>null</code> is typically stored as zero.  Older systems would just crash when you tried to resolve zero, newer ones would recognize the special nature of the value when the error occured.</p>\n<p>Also, these lower level languages cannot represent <code>null</code> as an integer (or other basic data types), so you could not in general deference <code>null</code> as <code>null</code> in all cases.</p>\n", "LastActivityDate": "2009-07-10T15:56:40.290", "CommentCount": "0", "CreationDate": "2009-07-10T15:56:40.290", "ParentId": "1110111", "Score": "0", "OwnerUserId": "91361"}, "1110146": {"Id": "1110146", "PostTypeId": "2", "Body": "<p>Dereferencing a NULL pointer is undefined behavior.</p>\n<p>It is not guaranteed to crash, and you are not guaranteed anything when doing it.  For all you know someone somewhere in the world will be punched each time you do it.  That is valid behavior since it is undefined. </p>\n<p>Also your pointers may not be initialized to NULL so if you want them to be for sure NULL you should set them explicitly to NULL.</p>\n", "LastActivityDate": "2009-07-10T15:15:26.593", "CommentCount": "5", "CreationDate": "2009-07-10T15:15:26.593", "ParentId": "1110111", "Score": "0", "OwnerUserId": "3153"}});