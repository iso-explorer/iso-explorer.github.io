post_cb({"bq_ids": {"n4140": {"so_29616985_38713734_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 242}}, "n3337": {"so_29616985_38713734_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 234}}, "n4659": {"so_29616985_38713734_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 249}}}, "38713734": {"Id": "38713734", "PostTypeId": "2", "Body": "<p>I believe Clang is correct to produce this error:</p>\n<p>The [temp.inst] section of the C++ standard in paragraph 10 says:</p>\n<blockquote>\n<p id=\"so_29616985_38713734_0\">If a function template or a member function template specialization is\n  used in a way that involves overload resolution, a declaration of the\n  specialization is implicitly instantiated (14.8.3).</p>\n</blockquote>\n<p>Forming the implicit conversion sequence necessary to rank the overload candidates for the call to TYPE_VALUE's constructor requires the instantiation of the conversion operator. And the use of an incomplete type parameter to the trait doesn't form an invalid type, so this isn't a substitution failure, it is a hard error.</p>\n", "LastActivityDate": "2016-08-02T07:01:57.027", "Score": "1", "CreationDate": "2016-08-02T07:01:57.027", "ParentId": "29616985", "CommentCount": "0", "OwnerUserId": "552038"}, "29616985": {"ViewCount": "546", "Body": "<p>The code below compiles in Visual Studio 2013, gcc 4.8, clang 3.4 and clang 3.5 (Apple LLVM 6.0) but does not compile in clang 3.6 (via Apple LLVM 6.1)</p>\n<p>The code is a simplified version of a complicated class in our codebase which is the minimum required to exhibit the issue.</p>\n<p>The crux of the problem is that the copy construction of <code>TYPED_VALUE</code> is, in 3.6, evaluating the templated conversion operator for type <code>STRING</code> because of the presence of a constructor that accepts a <code>STRING</code>; this causes <code>std::is_constructible</code> to be evaluated which leads to it needing the definition of <code>STRING</code> (which we cannot provide here - would lead to a circular dependency in the full code).</p>\n<pre><code>class STRING;\n\nclass TYPED_VALUE\n{\npublic:\n    TYPED_VALUE( const TYPED_VALUE&amp; ) = default; // explicit or implicit doesn't make a difference\n    TYPED_VALUE( const STRING &amp; ) {}\n\n    template&lt; typename TYPE, typename std::enable_if&lt;!std::is_pointer&lt; TYPE &gt;::value &amp;&amp; !std::is_constructible&lt; TYPE, const STRING&amp; &gt;::value &amp;&amp; !std::is_constructible&lt; TYPE, bool &gt;::value, int &gt;::type = 0 &gt;\n    operator TYPE( void ) const = delete;\n};\n\nclass TYPED_STORAGE\n{\npublic:\n    TYPED_STORAGE( const TYPED_VALUE &amp;v ) : value( v ) {}\n\n    TYPED_VALUE value;\n};\n</code></pre>\n<p>The error message is</p>\n<pre><code>/type_traits:2329:38: error: incomplete type 'SICORE::STRING' used in type trait expression\n    : public integral_constant&lt;bool, __is_constructible(_Tp, _Args...)&gt;\n                                     ^\n/main.cpp:348:99: note: in instantiation of template class 'std::__1::is_constructible&lt;SICORE::STRING, const SICORE::STRING &amp;&gt;' requested here\n        template&lt; typename TYPE, typename std::enable_if&lt;!std::is_pointer&lt; TYPE &gt;::value &amp;&amp; !std::is_constructible&lt; TYPE, const STRING&amp; &gt;::value &amp;&amp; !std::is_constructible&lt; TYPE, bool &gt;::value, int &gt;::type = 0 &gt;\n                                                                                                  ^\n/main.cpp:349:9: note: while substituting prior template arguments into non-type template parameter [with TYPE = SICORE::STRING]\n        operator TYPE( void ) const = delete;\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/main.cpp:355:56: note: while substituting deduced template arguments into function template 'operator type-parameter-0-0' [with TYPE = SICORE::STRING, $1 = (no value)]\n        TYPED_STORAGE( const TYPED_VALUE &amp;v ) : value( v ) {}\n                                                       ^\n/main.cpp:340:11: note: forward declaration of 'SICORE::STRING'\n    class STRING;\n          ^\n</code></pre>\n<p>To me this seems like a bug in 3.6, in previous versions the overload resolution determines that the copy constructor is the best fit without having to evaluate the template arguments - I tried to understand the overload resolution notes in the standard but I think that just confused me more ;)</p>\n<p>(This can be fixed by making either the constructor or the conversion operator explicit I realise, but that is not the behaviour we want)</p>\n<p>Any standard experts out there know the answer?</p>\n", "Title": "Is this change in overload resolution between Clang 3.5 and 3.6 correct or a bug?", "CreationDate": "2015-04-13T23:59:27.313", "LastActivityDate": "2016-08-02T07:01:57.027", "CommentCount": "9", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-06-23T08:25:36.823", "LastEditorUserId": "1782465", "Id": "29616985", "Score": "33", "OwnerUserId": "4785022", "Tags": "<c++11><clang><language-lawyer><overload-resolution><conversion-operator>", "AnswerCount": "3"}, "31994859": {"Id": "31994859", "PostTypeId": "2", "Body": "<p>templates are instantiated as-needed, and I think Clang 3.6 implemented a DR where it needed to instantiate a template earlier than 3.5 did.</p>\n", "LastActivityDate": "2015-08-13T17:31:30.890", "Score": "-1", "CreationDate": "2015-08-13T17:31:30.890", "ParentId": "29616985", "CommentCount": "0", "OwnerUserId": "5224283"}, "38493379": {"Id": "38493379", "PostTypeId": "2", "Body": "<p>The copy constructor of <code>TYPED_VALUE</code> uses a reference to <code>STRING</code>, it should not be evaluated.<br>\nI think this is a clang error.<br>\nI haven't read the new c++ standard for a long time, however, I couldn't make sure it hadn't changed.</br></br></p>\n", "LastActivityDate": "2016-07-21T01:24:13.657", "Score": "0", "CreationDate": "2016-07-21T01:24:13.657", "ParentId": "29616985", "CommentCount": "0", "OwnerUserId": "3600640"}});