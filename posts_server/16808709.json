post_cb({"bq_ids": {"n4140": {"so_16808709_16809114_4": {"length": 10, "quality": 1.0, "section_id": 6170}, "so_16808709_16809114_6": {"length": 14, "quality": 1.0, "section_id": 6172}, "so_16808709_16809114_2": {"length": 26, "quality": 0.9285714285714286, "section_id": 6167}, "so_16808709_16809114_1": {"length": 36, "quality": 1.0, "section_id": 6169}, "so_16808709_16809114_0": {"length": 28, "quality": 1.0, "section_id": 6169}, "so_16808709_16809114_5": {"length": 20, "quality": 0.9090909090909091, "section_id": 6171}, "so_16808709_16809114_7": {"length": 27, "quality": 0.9642857142857143, "section_id": 6172}}, "n3337": {"so_16808709_16809114_4": {"length": 10, "quality": 1.0, "section_id": 5931}, "so_16808709_16809114_6": {"length": 14, "quality": 1.0, "section_id": 5933}, "so_16808709_16809114_2": {"length": 26, "quality": 0.9285714285714286, "section_id": 5928}, "so_16808709_16809114_1": {"length": 36, "quality": 1.0, "section_id": 5930}, "so_16808709_16809114_0": {"length": 28, "quality": 1.0, "section_id": 5930}, "so_16808709_16809114_5": {"length": 20, "quality": 0.9090909090909091, "section_id": 5932}, "so_16808709_16809114_7": {"length": 27, "quality": 0.9642857142857143, "section_id": 5933}}, "n4659": {"so_16808709_16809114_4": {"length": 10, "quality": 1.0, "section_id": 7668}, "so_16808709_16809114_6": {"length": 14, "quality": 1.0, "section_id": 7670}, "so_16808709_16809114_2": {"length": 26, "quality": 0.9285714285714286, "section_id": 7664}, "so_16808709_16809114_1": {"length": 30, "quality": 0.8333333333333334, "section_id": 7667}, "so_16808709_16809114_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 7667}, "so_16808709_16809114_5": {"length": 20, "quality": 0.9090909090909091, "section_id": 7669}, "so_16808709_16809114_7": {"length": 15, "quality": 0.5357142857142857, "section_id": 7667}}}, "16808709": {"ViewCount": "406", "Body": "<p>I'm currently converting a rather large project from VS 2008 to 2012, and have run into a problem with a change in the way conditional operator type conversion seems to be performed.</p>\n<p>Let me start by saying that I accept the semantics of the conditional operator are somewhat complicated and realise what the code was doing originally is probably not correct, but I'm really confused by what happens now in VS 2012 and I was wondering if anyone can explain exactly why it does what it does.</p>\n<pre><code>class DummyString\n{\n    wchar_t wchBuf[32];\n\npublic:\n    DummyString() { *wchBuf = 0; }\n    DummyString(int) { *wchBuf = 0; }\n    DummyString(const DummyString&amp; ds) { *wchBuf = 0; }\n\n    operator const wchar_t*() const { return wchBuf; }\n};\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    DummyString ds;\n    // note: the argc test is simply to stop the conditional operator\n    // being optimised away\n    const wchar_t* pPtr = (argc == 100) ? 0 : ds;\n    assert(pPtr == static_cast&lt;const wchar_t*&gt;(ds));\n    return 0;\n}\n</code></pre>\n<p>In VS 2008, the conditional operator above would result in the <code>operator const wchar_t*()</code> method being called on <code>ds</code> and the assert would not fire. That is, it would implicitly cast <code>ds</code> to a <code>const wchar_t*</code>.</p>\n<p>In VS 2012, the conditional operator results in the following behaviour:</p>\n<ul>\n<li>A temporary <code>DummyString</code> is constructed via the copy constructor</li>\n<li>The cast to <code>const wchar_t*</code> is then performed on that temporary copy</li>\n</ul>\n<p>This results in <code>pPtr</code> being left pointing to a destroyed object, and the assert of course fires.</p>\n<p>Now if I remove the <code>DummyString(int)</code> constructor from the class, the code fails to compile in VS2012 (<em>no conversion from 'DummyString' to 'int'</em>) so clearly the <strong>0</strong> in the conditional is causing the expression to be evaluated as an int rather than a pointer.</p>\n<p>But in that case, why isn't the <code>DummyString(int)</code> constructor being called to convert the 0 to a <code>DummyString</code>? \nAnd why does the compiler create a copy of <code>ds</code> and then cast that to wchar_t*, when it could just as easily perform the cast on the original object?</p>\n<p>I would love to be enlightened! :)</p>\n", "AcceptedAnswerId": "16809114", "Title": "Conditional operator type conversion in VS 2012", "CreationDate": "2013-05-29T08:15:51.747", "Id": "16808709", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-05-29T08:48:14.570", "LastEditorUserId": "1932150", "LastActivityDate": "2013-05-29T10:19:10.707", "Score": "8", "OwnerUserId": "506413", "Tags": "<c++><visual-c++><visual-studio-2012><c++11>", "AnswerCount": "2"}, "16809396": {"Id": "16809396", "PostTypeId": "2", "Body": "<p>If you want, you may avoid invoking the copy constructor by giving this:</p>\n<pre><code>const wchar_t* pPtr = (argc == 100) ? 0 : (pPtr = ds);\n</code></pre>\n", "LastEditorUserId": "1699310", "LastActivityDate": "2013-05-29T09:05:59.123", "Score": "0", "CreationDate": "2013-05-29T08:50:05.200", "ParentId": "16808709", "CommentCount": "0", "OwnerUserId": "1699310", "LastEditDate": "2013-05-29T09:05:59.123"}, "16809114": {"Id": "16809114", "PostTypeId": "2", "Body": "<p>Paragraph 5.16/3 of the C++11 Standard specifies that:</p>\n<blockquote>\n<p id=\"so_16808709_16809114_0\">[...] if the second and third operand have different types and either has (possibly cv-qualified) class\n  type, or if both are glvalues of the same value category and the same type except for cv-qualification, <strong>an\n  attempt is made to convert each of those operands to the type of the other</strong>. [...]</p>\n</blockquote>\n<p>And that:</p>\n<blockquote>\n<p id=\"so_16808709_16809114_1\">[...] If both can be\n  converted, or one can be converted but the conversion is ambiguous, the program is ill-formed. If neither\n  can be converted, the operands are left unchanged and further checking is performed as described below.\n  <strong>If exactly one conversion is possible, that conversion is applied to the chosen operand and the converted\n  operand is used in place of the original operand for the remainder of this section.</strong></p>\n</blockquote>\n<p>In this case, only the conversion from <code>int</code> to <code>DummyString</code> is possible, because in the other direction a <code>const wchar_t*</code> is as far as we can go - there is no standard implicit conversion from a <code>const wchar_t*</code> to an <code>int</code>. </p>\n<p>This is why the compiler complains if you remove the converting constructor that takes an <code>int</code>: if that constructor did not exist, per the above paragraph, the program would be ill-formed (no conversion would exist in either direction).</p>\n<p>Therefore, the second operand (the first choice) is considered to be <code>DummyString(0)</code>. </p>\n<p>However, the fact that the second operand can be converted to a <code>DummyString</code> does <em>not</em> mean that the second operand will be evaluated at all. That depends on the condition, and the condition evaluates to <code>false</code> (unless you pass 100 arguments to the command line), which explains why you are not seeing a call to that constructor. Per paragraph 5.16/1:</p>\n<blockquote>\n<p id=\"so_16808709_16809114_2\">Conditional expressions group right-to-left. The first expression is contextually converted to bool (Clause 4).\n  It is evaluated and if it is true, the result of the conditional expression is the value of the second expression,\n  otherwise that of the third expression. <strong>Only one of the second and third expressions is evaluated.</strong> [...]</p>\n</blockquote>\n<p>But why does your assertion fail then? </p>\n<blockquote>\n<p id=\"so_16808709_16809114_3\">And why does the compiler create a copy of <code>ds</code> and then cast that to <code>wchar_t*</code>, when it could just as easily perform the cast on the original object?</p>\n</blockquote>\n<p>Well, this is due to paragraphs 5.16/4-5:</p>\n<blockquote>\n<p id=\"so_16808709_16809114_4\">If the second and third operands are glvalues of the same value category and have the same type, [...] </p>\n<p id=\"so_16808709_16809114_5\"><strong>Otherwise, the result is a prvalue</strong>. If the second and third operands do not have the same type, and either\n  has (possibly cv-qualified) class type, overload resolution is used to determine the conversions (if any) to be\n  applied to the operands (13.3.1.2, 13.6).</p>\n</blockquote>\n<p><code>0</code> is not a glvalue, so the result of the conditional will be a prvalue. This means that the evaluation of the conditional operator when the condition is <code>false</code> will end up constructing a <em>temporary</em> from <code>ds</code>, which is the behavior you observe.</p>\n<p>This is mandated by paragraph 5.16/6, which says:</p>\n<blockquote>\n<p id=\"so_16808709_16809114_6\">Lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed\n  on the second and third operands. After those conversions, one of the following shall hold:</p>\n<p id=\"so_16808709_16809114_7\">\u2014 The second and third operands have the same type; the result is of that type. <strong>If the operands have\n  class type, the result is a prvalue temporary of the result type, which is copy-initialized from either\n  the second operand or the third operand</strong> depending on the value of the first operand. [...]</p>\n</blockquote>\n<p>The condition `\"<em>the second and third operand have the same type</em>\" holds, because the operands are now being considered <em>after</em> the conversion described in 5.16/3 (see the beginning of this answer).</p>\n<p>To fix your problem, you could perform an explicit cast on the second argument:</p>\n<pre><code>const wchar_t* pPtr = (argc == 100) ? 0 : static_cast&lt;const wchar_t*&gt;(ds);\n</code></pre>\n<p>Since a standard conversion from <code>0</code> to a pointer type exists and results in a null pointer - see paragraph 4.10/1.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-05-29T10:19:10.707", "Score": "13", "CreationDate": "2013-05-29T08:36:51.107", "ParentId": "16808709", "CommentCount": "12", "OwnerUserId": "1932150", "LastEditDate": "2013-05-29T10:19:10.707"}});