post_cb({"32320520": {"ParentId": "32320407", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_32320407_32320520_0\">I use the code in my main function in order to test it, but, to my surprise, if I comment out the specialization and let the compiler instantiate the original template,it works even for the const char arrays (the type of string literal)! How could it possibly be?</p>\n</blockquote>\n<hr>\n<p>The standard doesn't specify that string literals that contains the same sequence of characters have to be stored in the same memory location, as per \u00a72.13.5/16:</p>\n<blockquote>\n<p id=\"so_32320407_32320520_1\">Evaluating a string-literal results in a string literal object with static storage duration, initialized from the given characters as specified above. <strong>Whether all string literals are distinct</strong> (that is, are stored in non-overlapping objects) <strong>and whether successive evaluations of a string-literal yield the same or a different object is unspecified</strong>.</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>but this implementation is allowed, and it's what's happening here: each literal string <code>\"hej\"</code> is stored in the same memory address, so <code>==</code> on <code>const char*</code> is checking wether the address is the same and yielding true.</p>\n<hr>\n<p>To \"prove\" this we just need to take a look at this example:</p>\n<pre><code>int main() {\n    std::vector&lt;const char*&gt; cvec = {\"hi\", \"hi\", \"hallo\", \"hej\", \"hej\", \"hi\", \"hej\", \"hej\", \"hej\"};\n    std::cout &lt;&lt; function(cvec, \"hej\") &lt;&lt; '\\n';\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/37148920ef0f8974\" rel=\"nofollow\"><kbd>Live demo</kbd></a></p>\n<p>This yields <code>5</code> due to the fact that there are 5 literals <code>\"hej\"</code> in the vector. But if we add another <code>char</code> array with the same exact <code>char</code>s in the literal, that we know should have a different address:</p>\n<pre><code>int main() {\n    std::string hej = \"hej\";\n    std::vector&lt;const char*&gt; cvec = {\"hi\", \"hi\", \"hallo\", \"hej\", \"hej\", \"hi\", \"hej\", \"hej\", \"hej\", hej.c_str()};\n    std::cout &lt;&lt; function(cvec, \"hej\") &lt;&lt; std::endl;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/d899b9a1a5d6d33c\" rel=\"nofollow\"><kbd>Live demo</kbd></a></p>\n<p>Then we see that the count doesn't change.</p>\n</hr></hr>", "OwnerUserId": "493122", "LastEditorUserId": "493122", "LastEditDate": "2015-08-31T22:14:15.990", "Id": "32320520", "Score": "4", "CreationDate": "2015-08-31T21:51:27.167", "LastActivityDate": "2015-08-31T22:14:15.990"}, "32320407": {"CommentCount": "2", "AcceptedAnswerId": "32320520", "LastEditDate": "2015-08-31T22:11:44.803", "LastEditorUserId": "493122", "CreationDate": "2015-08-31T21:42:01.193", "LastActivityDate": "2015-08-31T22:14:15.990", "PostTypeId": "1", "ViewCount": "68", "Title": "counting algorithm and pointer types", "Id": "32320407", "OwnerUserId": "4729407", "Body": "<p>I wrote the following code as an exercise about function templates and template specializations. It's a function that counts how many objects of a given type are present in a <code>vector</code>:</p>\n<pre><code>template &lt;typename T&gt;\nint function(const std::vector&lt;T&gt; &amp;vec, T val) {\n    int count = 0;\n    for(typename std::vector&lt;T&gt;::const_iterator it = vec.begin(); it != vec.end(); ++it)\n        if(*it == val)\n            ++count;\n    return count;\n}\n\ntemplate &lt;&gt;\nint function(const std::vector&lt;const char*&gt; &amp;vec, const char* val) {\n    int count = 0;\n    for(std::vector&lt;const char*&gt;::const_iterator it = vec.begin(); it != vec.end(); ++it) {\n        if (std::string(*it) == std::string(val))\n            ++count;\n    }\n    return count;\n}\n</code></pre>\n<p>I wrote the code in the specialization because I want to know if every character in a word is the same as the given literal. To my surprise, if I comment out the specialization and let the compiler instantiate the original template, it works even for the const char arrays:</p>\n<pre><code>int main() {\n    std::vector&lt;const char*&gt; cvec = {\"hi\", \"hi\", \"hallo\", \"hej\", \"hej\", \"hi\", \"hej\", \"hej\", \"hej\"};\n    std::cout &lt;&lt; function(cvec, \"hej\") &lt;&lt; std::endl;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/e9f80ec3cad3e38a\" rel=\"nofollow\"><kbd>Live demo</kbd></a></p>\n<p>How could it possibly be?</p>\n", "Tags": "<c++><arrays><templates><pointers><const-char>", "Score": "1", "AnswerCount": "1"}, "bq_ids": {"n4659": {"so_32320407_32320520_1": {"section_id": 6789, "quality": 1.0, "length": 31}}}});