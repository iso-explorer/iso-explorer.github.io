post_cb({"33723631": {"CommentCount": "4", "ViewCount": "387", "PostTypeId": "1", "LastEditorUserId": "3093378", "CreationDate": "2015-11-15T18:57:48.557", "LastActivityDate": "2015-11-15T23:37:08.423", "Title": "Signed bit field in C++14", "AcceptedAnswerId": "33725514", "LastEditDate": "2015-11-15T23:37:08.423", "Id": "33723631", "Score": "7", "Body": "<p>I believe that until C++14 a bit field of a struct declared as <code>int</code> was still interpreted as either <code>signed</code> or <code>unsigned</code>, the interpretation being implementation defined. Reference: <a href=\"http://en.cppreference.com/w/cpp/language/bit_field\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/bit_field</a>.</p>\n<p>Is this still the case in C++14? I.e., is the code below guaranteed to work as inteded?</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct X\n{\n    int f:3;\n};\n\nint main() \n{\n    X x;\n    x.f = -2; // is this going to be indeed signed? It seems so.\n    std::cout &lt;&lt; x.f &lt;&lt; std::endl; // displays -2\n}\n</code></pre>\n", "Tags": "<c++><c++14><bit-fields>", "OwnerUserId": "3093378", "AnswerCount": "1"}, "33725514": {"ParentId": "33723631", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-11-15T21:49:13.007", "Score": "6", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:59:02.133", "Id": "33725514", "OwnerUserId": "2352671", "Body": "<p>According to C++11 standard <em>\u00a79.6/p3 Bit-fields [class.bit]</em> (<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_33723631_33725514_0\">A bit-field shall not be a static member. A bit-field shall have\n  integral or enumeration type (3.9.1). <strong>It is implementation-defined\n  whether a plain (neither explicitly signed nor unsigned) <code>char</code>, <code>short</code>,\n  <code>int</code>, <code>long</code>, or <code>long long</code> bit-field is signed or unsigned.</strong> A <code>bool</code> value\n  can successfully be stored in a bit-field of any nonzero size. The\n  address-of operator &amp; shall not be applied to a bit-field, so there\n  are no pointers to bitfields. A non-const reference shall not be bound\n  to a bit-field (8.5.3). [ Note: If the initializer for a reference of\n  type const T&amp; is an lvalue that refers to a bit-field, the reference\n  is bound to a temporary initialized to hold the value of the\n  bit-field; the reference is not bound to the bit-field directly. See\n  8.5.3. \u2014end note ]</p>\n</blockquote>\n<p>So you're correct for the first part. Indeed until C++14 a bit field of a struct declared as <code>signed</code> was still interpreted as either <code>signed</code> or <code>unsigned</code>, the interpretation being implementation defined.</p>\n<p>As already mentioned in this comments by <a href=\"https://stackoverflow.com/users/2756719/t-c\">@T.C</a>. Defect reports referring to the issue were made <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#739\" rel=\"nofollow noreferrer\">DR739</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#675\" rel=\"nofollow noreferrer\">DR675</a>. Resulting in the following resolutions in C++14 standard:</p>\n<p>The wording \"It is implementation-defined whether a plain (neither explicitly signed nor unsigned) <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, or <code>long long</code> bit-field is signed or unsigned.\",  was removed, and the C++14 wording now is:</p>\n<blockquote>\n<p id=\"so_33723631_33725514_1\">A bit-field shall not be a static member. A bit-field shall have\n  integral or enumeration type (3.9.1). A bool value can successfully be\n  stored in a bit-field of any nonzero size. The address-of operator &amp;\n  shall not be applied to a bit-field, so there are no pointers to\n  bit-fields. A non-const reference shall not be bound to a bit-field\n  (8.5.3). [ Note: If the initializer for a reference of type const T&amp;\n  is an lvalue that refers to a bit-field, the reference is bound to a\n  temporary initialized to hold the value of the bit-field; the\n  reference is not bound to the bit-field directly. See 8.5.3. \u2014end note\n  ]</p>\n</blockquote>\n<p>Also in <em>\u00a7C.1.8 Clause 9: classes [diff.class]</em> the following section was added:</p>\n<blockquote>\n<p id=\"so_33723631_33725514_2\">9.6</p>\n<p id=\"so_33723631_33725514_3\"><strong>Change:</strong> Bit-fields of type plain int are signed.</p>\n<p id=\"so_33723631_33725514_4\"><strong>Rationale:</strong> Leaving the choice of signedness to implementations could lead to inconsistent definitions of\n  template specializations. For consistency, the implementation freedom was eliminated for non-dependent\n  types, too.</p>\n<p id=\"so_33723631_33725514_5\"><strong>Effect on original feature:</strong> The choice is implementation-defined in C, but not so in C++.</p>\n<p id=\"so_33723631_33725514_6\"><strong>Difficulty of converting:</strong> Syntactic transformation.</p>\n<p id=\"so_33723631_33725514_7\"><strong>How widely used:</strong> Seldom.</p>\n</blockquote>\n<p>Consequently, in C++14 <strong>bit-fields of type plain <code>int</code> are signed</strong> and the code posted is guaranteed to work as intended.</p>\n", "LastActivityDate": "2015-11-15T21:49:13.007"}, "bq_ids": {"n4140": {"so_33723631_33725514_0": {"section_id": 5923, "quality": 0.6571428571428571, "length": 46}, "so_33723631_33725514_1": {"section_id": 5923, "quality": 0.8679245283018868, "length": 46}}, "n3337": {"so_33723631_33725514_3": {"section_id": 5695, "quality": 0.6666666666666666, "length": 4}, "so_33723631_33725514_0": {"section_id": 5695, "quality": 0.8857142857142857, "length": 62}, "so_33723631_33725514_1": {"section_id": 5695, "quality": 0.8679245283018868, "length": 46}}, "n4659": {"so_33723631_33725514_0": {"section_id": 7397, "quality": 0.6571428571428571, "length": 46}, "so_33723631_33725514_1": {"section_id": 7397, "quality": 0.8679245283018868, "length": 46}}}});