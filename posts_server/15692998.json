post_cb({"bq_ids": {"n4140": {"so_15692998_15693393_0": {"length": 78, "quality": 0.9176470588235294, "section_id": 5559}}, "n3337": {"so_15692998_15693393_0": {"length": 78, "quality": 0.9176470588235294, "section_id": 5341}}, "n4659": {"so_15692998_15693393_0": {"length": 76, "quality": 0.8941176470588236, "section_id": 7006}}}, "15693032": {"Id": "15693032", "PostTypeId": "2", "Body": "<p>I <em>believe</em> the default constructor for an iterator is always equivalent to an <code>end</code>. That said, if you pass the same iterator into the function, then that's also by definition an empty range.</p>\n<p>Since all pointers are valid iterators, you should be able to use <code>static_cast&lt;int*&gt;(NULL)</code> as both arguments. (Or <code>vector&lt;int&gt;::iterator()</code>).</p>\n", "LastActivityDate": "2013-03-28T22:07:57.600", "CommentCount": "3", "CreationDate": "2013-03-28T22:07:57.600", "ParentId": "15692998", "Score": "1", "OwnerUserId": "173556"}, "15692998": {"ViewCount": "329", "Body": "<p>I have a function that takes a pair of iterators. I'd like to provide a no-argument version of the function that behaves as if it had been passed an empty range.</p>\n<p>To be concrete, let's say the first function is:</p>\n<pre><code>void f(vector&lt;int&gt;::iterator b, vector&lt;int&gt;::iterator e) { // impl. }\n</code></pre>\n<p>I'd like to write this:</p>\n<pre><code>void f() { f({}, {}); }\n</code></pre>\n<p>Do I have the initialisation correct here, the {}, {} should be two default constructed vector::iterator types? (It compiles).</p>\n<p>Do I have to construct a container to get a pair of iterators that compare equal?</p>\n", "AcceptedAnswerId": "15693393", "Title": "What is a clean/concise way to pass empty range to a function taking a pair of iterators?", "CreationDate": "2013-03-28T22:05:55.297", "Id": "15692998", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-03-28T23:02:32.537", "Score": "7", "OwnerUserId": "710408", "Tags": "<c++><stl><c++11>", "AnswerCount": "2"}, "15693393": {"Id": "15693393", "PostTypeId": "2", "Body": "<p>In my understanding this cannot be done generally in a standard conforming way.</p>\n<p><em>24.2.1/5</em>:</p>\n<blockquote>\n<p id=\"so_15692998_15693393_0\">Iterators can also have singular values that are not associated with\n  any sequence. [ Example: After the declaration of an uninitialized\n  pointer x (as with int* x;), x must always be assumed to have a\n  singular value of a pointer. \u2014 end example ] <strong>Results of most\n  expressions are undefined for singular values</strong>; the only exceptions are\n  destroying an iterator that holds a singular value, the assignment of\n  a non-singular value to an iterator that holds a singular value, and,\n  for iterators that satisfy the <code>DefaultConstructible</code> requirements,\n  using a value-initialized iterator as the source of a copy or move\n  operation. [ Note: This guarantee is not offered for default\n  initialization, although the distinction only matters for types with\n  trivial default constructors such as pointers or aggregates holding\n  pointers. \u2014 end note ] In these cases the singular value is\n  overwritten the same way as any other value. Dereferenceable values\n  are always non-singular.</p>\n</blockquote>\n<p>Default/value initialisation clearly isn't associated with any sequence, so the Iterator is singular.\nComparing two singular Iterators is undefined behaviour.</p>\n<pre><code>std::vector&lt;int&gt;::iterator i;\nstd::vector&lt;int&gt;::iterator j = i; // UB, assignment of a non-a singular value\n                                  // If you pass `i` to a function, a copy is done\n                                  // which also results in UB (as in Andy's answer).\n</code></pre>\n<p>Next try, use value-initialisation</p>\n<pre><code>std::vector&lt;int&gt;::iterator i{};\nstd::vector&lt;int&gt;::iterator j = i; // ok, i is value-initialized\ni == j; // undefined, comparison is not explicitly non-undefined behavour\ni == i; // undefined, comparison is not explicitly non-undefined behavour \n</code></pre>\n<p>Since we don't have more information about <code>vector&lt;int&gt;::iterator</code>, your approach is wrong.</p>\n<p>What you can do is changing your <code>f</code> to a template and use a pointer:</p>\n<pre><code>template &lt;typename Iter&gt;\nvoid f(Iter b, Iter e);\n\nint *p; f(p, p); // ok, defined for pointers\n</code></pre>\n", "LastEditorUserId": "1176973", "LastActivityDate": "2013-03-28T23:02:32.537", "Score": "7", "CreationDate": "2013-03-28T22:39:13.013", "ParentId": "15692998", "CommentCount": "2", "OwnerUserId": "1176973", "LastEditDate": "2013-03-28T23:02:32.537"}});