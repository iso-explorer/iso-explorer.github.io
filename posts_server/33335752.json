post_cb({"bq_ids": {"n4140": {"so_33335752_33335787_2": {"section_id": 7053, "quality": 0.75, "length": 6}, "so_33335752_33335787_1": {"section_id": 7053, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_33335752_33335787_2": {"section_id": 6797, "quality": 0.75, "length": 6}, "so_33335752_33335787_1": {"section_id": 6797, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_33335752_33335787_2": {"section_id": 8550, "quality": 0.75, "length": 6}, "so_33335752_33335787_1": {"section_id": 8550, "quality": 0.7777777777777778, "length": 7}}}, "33338426": {"ParentId": "33335752", "CommentCount": "0", "Body": "<p>Yes, the declaration is perfectly valid and portable in both C and C++.</p>\n<p>In both C and C++, this:</p>\n<pre><code>enum State {DISABLED=0, ENABLED=!DISABLED};\n</code></pre>\n<p>is exactly equivalent to this:</p>\n<pre><code>enum State {DISABLED=0, ENABLED=1};\n</code></pre>\n<p>and to this:</p>\n<pre><code>enum State {DISABLED, ENABLED};\n</code></pre>\n<p>but for subtly different reasons.</p>\n<p>In C, the unary <code>!</code> operator yields a result of type <code>int</code>, with value either <code>0</code> (if the operand is not equal to <code>0</code>) or <code>1</code> (if the operand is equal to <code>0</code>). <code>!x</code> is equivalent to <code>x == 0</code>.  (Any non-zero value is treated as true when used as a condition, but the <code>!</code> and <code>==</code> operators, among others always yield a result of exactly <code>0</code> or <code>1</code>.) Enumeration constants are always of type <code>int</code>; if a value is specified, it's converted to <code>int</code> if necessary.</p>\n<p>(C added type <code>_Bool</code> in the 1999 standard, but all operators that yield logically \"boolean\" values still yield results of type <code>int</code>.)</p>\n<p>In C++, the result of the unary <code>!</code> operator is of type <code>bool</code>. The result is <code>false</code> or <code>true</code> where C's <code>!</code> operator would yield <code>0</code> or <code>1</code>, respectively.  As in C, if a value is specified, it's converted as needed; the <code>bool</code> values <code>false</code> and <code>true</code> convert to <code>0</code> and <code>1</code>, respectively.</p>\n<p>In C, enumeration constants are always of type <code>int</code>.  In C++, they're of the enumeration type, in this case <code>enum State</code>.</p>\n<p>Referring to an earlier enumeration constant within the same type declaration is legal. Each enumeration constant becomes visible after it's declared.</p>\n<p>As for something like:</p>\n<pre><code>enum bool { false = 0, true = !false );\n</code></pre>\n<p>being clearer than</p>\n<pre><code>enum bool { false = 0, true = 1 };\n</code></pre>\n<p>(in C; it would be illegal in C++), I respectfully disagree. The constant <code>1</code> is perfectly clear to anyone familiar with C. Rewriting it as <code>!false</code> is not helpful. In fact, when <code>&lt;stdbool.h&gt;</code> is not available (something that's rare these days), I've used:</p>\n<pre><code>typedef enum { false, true } bool;\n</code></pre>\n<p>The fact that <code>false</code> and <code>true</code> will be given their correct values is IMHO sufficiently obvious.</p>\n<p>As for why C99 didn't use an <code>enum</code> definition like that, I suspect it's because each enumeration type is compatible with some implementation-defined integer type. (For gcc, it's usually <code>unsigned int</code> or <code>int</code>.) The committee wanted <code>_Bool</code> to be a distinct type with a conversion rank lower than any other integer type. (And they couldn't make <code>bool</code> a keyword without breaking existing code.)</p>\n", "OwnerUserId": "827263", "PostTypeId": "2", "Id": "33338426", "Score": "3", "CreationDate": "2015-10-26T04:22:45.437", "LastActivityDate": "2015-10-26T04:22:45.437"}, "33335752": {"CommentCount": "6", "ViewCount": "451", "PostTypeId": "1", "LastEditorUserId": "4764736", "CreationDate": "2015-10-25T22:19:47.670", "LastActivityDate": "2015-10-26T04:22:45.437", "Title": "Is this enum declaration a standard compliant?", "AcceptedAnswerId": "33338426", "LastEditDate": "2015-10-25T22:32:48.540", "Id": "33335752", "Score": "11", "Body": "<p>So normally enum's are for declaring group of \"constant integers\" as another type, that represents something. Eg.</p>\n<pre><code>enum Color {RED=0, BLUE, YELLOW};\n</code></pre>\n<p>This is clear. But recently I met following in code. This was in a compiler for embedded systems.</p>\n<pre><code>enum State {DISABLED=0, ENABLED=!DISABLED};\n</code></pre>\n<p>And it worked just fine. It behaved as a boolean type. My question is, wheather it (this syntax) is ANSI compliant?</p>\n<p>If it is standard compliant, then why would compilers define internally something like _Bool for boolean representation and then in <code>stdbool.h</code> (for C language) they do:</p>\n<pre><code>#define bool _Bool\n... // here goes definitions of true and false\n</code></pre>\n<p>instead of </p>\n<pre><code>enum bool {false=0, true=!false};\n</code></pre>\n<p>Which is much cleaner?</p>\n", "Tags": "<c++><c><enums>", "OwnerUserId": "4764736", "AnswerCount": "3"}, "33335787": {"ParentId": "33335752", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>According to the C Standard (6.2.1 Scopes of identifiers)</p>\n<blockquote>\n<p id=\"so_33335752_33335787_0\">Each enumeration constant has scope that begins just after the\n  appearance of its defining enumerator in an enumerator list</p>\n</blockquote>\n<p>The same is valid in C++ (3.3.2 Point of declaration)</p>\n<blockquote>\n<p id=\"so_33335752_33335787_1\">5 The point of declaration for an enumerator is immediately after its\n  enumerator-definition.[ Example:</p>\n</blockquote>\n<pre><code>const int x = 12;\n{ enum { x = x }; }\n</code></pre>\n<blockquote>\n<p id=\"so_33335752_33335787_2\">Here, the enumerator x is initialized with the value of the constant\n  x, namely 12. \u2014end example ]</p>\n</blockquote>\n<p>So you may use already defined enumerators in definitions of next enumerators in an enumeration.</p>\n<p>As for the C type <code>_Bool</code> then it appeared in the C 99. Before this standard there are used either manifest constants or enumerations in C.</p>\n<p>There is no sense to define an enumeration like this</p>\n<pre><code>enum bool {false=0, true!=false};\n</code></pre>\n<p>because type <code>_Bool</code> is already has two values 0 and 1.</p>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2015-10-25T22:30:47.363", "Id": "33335787", "Score": "3", "CreationDate": "2015-10-25T22:23:37.830", "LastActivityDate": "2015-10-25T22:30:47.363"}, "33335798": {"ParentId": "33335752", "CommentCount": "7", "Body": "<p>Yes, this is standard-compliant.</p>\n<p><code>!DISABLED</code> is a valid <em>constant</em> expression, which is all that is required for an <code>enum</code> value.</p>\n<pre><code>enum State {DISABLED=0, ENABLED= (!DISABLED)};\n//                               ^^^^^^^^^^^\n</code></pre>\n<p>At the point where <code>DISABLED</code> is referenced, the compiler knows its value, so it can compute the value of the expression derived from it, i.e. <code>!DISABLED</code>. It is a fancy way of writing <code>ENABLED=1</code>.</p>\n", "OwnerUserId": "335858", "PostTypeId": "2", "Id": "33335798", "Score": "6", "CreationDate": "2015-10-25T22:25:15.010", "LastActivityDate": "2015-10-25T22:25:15.010"}});