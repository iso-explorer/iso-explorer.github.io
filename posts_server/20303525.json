post_cb({"20303600": {"ParentId": "20303525", "LastEditDate": "2016-01-29T11:27:38.570", "CommentCount": "0", "CreationDate": "2013-11-30T17:50:22.490", "OwnerUserId": "743382", "LastEditorUserId": "3204551", "PostTypeId": "2", "Id": "20303600", "Score": "11", "Body": "<p>The rule was always that fields are <em>always</em> initialised in order of declaration, and C++11 didn't change that. That means <code>bbb</code>'s initialiser runs first, then <code>ccc</code>'s initialiser runs. It doesn't matter whether either initialiser is specified on the field or as part of the constructor.</p>\n", "LastActivityDate": "2016-01-29T11:27:38.570"}, "20303525": {"CommentCount": "4", "CreationDate": "2013-11-30T17:42:52.403", "PostTypeId": "1", "AcceptedAnswerId": "20303600", "LastEditorUserId": "246776", "LastActivityDate": "2016-01-29T11:27:38.570", "LastEditDate": "2013-12-05T01:11:37.307", "ViewCount": "687", "FavoriteCount": "1", "Title": "C++ evaluation order between brace-or-equal initializer and initialization-list?", "Id": "20303525", "Score": "6", "Body": "<p>Where I have this struct,</p>\n<pre><code>struct\nAAA\n{\n    AAA() : bbb(2)\n    {\n        // ccc ???\n    }\n\n    int bbb = 1;\n    int ccc = bbb;\n};\n</code></pre>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/data_members\" rel=\"nofollow\">AFAIK</a>, if there's an initialization-list <code>:bbb(2)</code>, the expression <code>bbb = 1</code> will be ignored. And then, it's vague to me what <code>ccc</code> will become finally.</p>\n<p>Which one of <em>initialization-list</em> or <em>brace-or-equal initializer</em> would be evaluated first? What's the rule between them?</p>\n", "Tags": "<c++><c++11><initialization><order-of-evaluation>", "OwnerUserId": "246776", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_20303525_20303724_0": {"section_id": 436, "quality": 1.0, "length": 16}, "so_20303525_20303724_2": {"section_id": 436, "quality": 0.75, "length": 12}}, "n3337": {"so_20303525_20303724_0": {"section_id": 428, "quality": 1.0, "length": 16}, "so_20303525_20303724_2": {"section_id": 428, "quality": 0.75, "length": 12}}, "n4659": {"so_20303525_20303724_0": {"section_id": 455, "quality": 0.875, "length": 14}, "so_20303525_20303724_2": {"section_id": 455, "quality": 0.75, "length": 12}}}, "20303724": {"ParentId": "20303525", "LastEditDate": "2013-11-30T18:28:30.340", "CommentCount": "6", "CreationDate": "2013-11-30T18:02:25.477", "OwnerUserId": "477878", "LastEditorUserId": "477878", "PostTypeId": "2", "Id": "20303724", "Score": "12", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf\" rel=\"noreferrer\">C++11 draft</a> \u00a712.6.2.9 says;</p>\n<blockquote>\n<p id=\"so_20303525_20303724_0\">If a given non-static data member has both a\n  brace-or-equal-initializer and a  mem-initializer, the initialization\n  specified by the mem-initializer is performed,  and the non-static\n  data member\u2019s brace-or-equal-initializer is ignored. </p>\n<p id=\"so_20303525_20303724_1\">[ Example: Given</p>\n</blockquote>\n<pre><code>struct A {\n  int i = /\u2217 some integer expression with side effects \u2217/ ; \n  A(int arg) : i(arg) { }\n  // ...\n};\n</code></pre>\n<blockquote>\n<p id=\"so_20303525_20303724_2\">the A(int) constructor will simply initialize i to the value of arg,\n  and the side  effects in i\u2019s brace-or- equal-initializer will not take\n  place. \u2014 end example ]</p>\n</blockquote>\n<p>Since initialization is done in declaration order (\u00a712.6.2.10) with the addition of this rule, the value of <code>bbb</code> and <code>ccc</code> will both be 2.</p>\n", "LastActivityDate": "2013-11-30T18:28:30.340"}});