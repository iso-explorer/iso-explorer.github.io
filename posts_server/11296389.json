post_cb({"12610403": {"ParentId": "11296389", "CommentCount": "0", "Body": "<p>The compiler is not following the standard in this case and is buggy. Let's review the relevant sections.</p>\n<p>First from 13.3/3 we have:</p>\n<blockquote>\n<p id=\"so_11296389_12610403_0\">...</p>\n<p id=\"so_11296389_12610403_1\">\u2014 First, a subset of the candidate functions\u2014those that have the\n  proper number of arguments and meet certain other conditions\u2014is\n  selected to form a set of viable functions (13.3.2).</p>\n<p id=\"so_11296389_12610403_2\">\u2014 Then the best viable function is selected based on the implicit\n  conversion sequences (13.3.3.1) needed to match each argument to the\n  corresponding parameter of each viable function.</p>\n</blockquote>\n<p>So both functions have the same number of arguments and are considered candidates. Now we have to find the best viable function, in</p>\n<p>13.3.3:</p>\n<blockquote>\n<p id=\"so_11296389_12610403_3\">let ICSi(F) denote the implicit conversion sequence that converts the\n  ith argument in the list to the type of the ith parameter of viable\n  function F. 13.3.3.1 defines the implicit conversion sequences and\n  13.3.3.2 defines what it means for one implicit conversion sequence to be a better conversion sequence or worse conversion sequence than\n  another</p>\n</blockquote>\n<p>Then we have</p>\n<blockquote>\n<p id=\"so_11296389_12610403_4\">Given these definitions, a viable function F1 is defined to be a\n  better function than another viable function F2 if for all arguments\n  i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</p>\n<p id=\"so_11296389_12610403_5\">\u2014 for some argument j, ICSj(F1) is a better conversion sequence than\n  ICSj(F2), or, if not that, </p>\n<p id=\"so_11296389_12610403_6\">\u2014 F1 is a nontemplate function and F2 is a\n  template function specialization, or, if not that, </p>\n<p id=\"so_11296389_12610403_7\">\u2014 F1 and F2 are\n  template functions, and the function template for F1 is more\n  specialized than the template for F2 according to the partial ordering\n  rules described in 14.5.5.2, or, if not that,</p>\n</blockquote>\n<p>The two functions are equal for the first rule (adding const), and the second rule doesn't apply (both are templates). So we move to the third rule. From 14.5.5.2 (which I will quote if requested) we learn that the <code>const int</code> version of the function is more specialized than the <code>const Item</code> version, and so the best match is the <code>const int</code> overload, which should then be called.</p>\n<p>Your best temporary fix is probably a second overload:</p>\n<pre><code>template&lt;size_t SZ&gt;\nvoid LoopThrough(int (&amp;Item)[SZ])\n{\n    LoopThrough(static_cast&lt;const int (&amp;)[SZ]&gt;(Item));\n}\n</code></pre>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "12610403", "Score": "2", "CreationDate": "2012-09-26T21:06:42.767", "LastActivityDate": "2012-09-26T21:06:42.767"}, "11594059": {"ParentId": "11296389", "CommentCount": "2", "Body": "<p>Your compiler is buggy. Both overloads have their template arguments deduced, and overload resolution should select the most specialized one. So apart from getting a new compiler, what can you do?</p>\n<p>First, it's helpful to realize that -even with conforming compilers- it is generally not a good a idea to have different function template overloads. See e.g. Item 66 of <a href=\"http://rads.stackoverflow.com/amzn/click/0321113586\" rel=\"nofollow\">C++ Coding Standards: 101 Rules, Guidelines, and Best Practices</a> by Herb Sutter and Andrei Alexandrescu. </p>\n<p>Fortunately, that Item also suggests a possible fix. All you have to do is define a single function template and let that function template delegate the work to a class template function object. You can then partially specialize this class template for <code>ints</code>.</p>\n<pre><code>#include &lt;iostream&gt; \n\n#define PRINT_TRACE(STR) \\\nstd::cout &lt;&lt; __FILE__ &lt;&lt; \":\" &lt;&lt; __LINE__ &lt;&lt; \":\" &lt;&lt; STR &lt;&lt; \"\\n\";\n\nnamespace detail {    \n\n// primary template\ntemplate&lt;typename Type, size_t SZ&gt;\nclass LoopThroughHelper\n{\npublic:\n    void operator()(const Type(&amp;Item)[SZ]) \n    {\n        PRINT_TRACE(\"Generic version\");        \n    }\n}; \n\n// partial specialization for int arrays\ntemplate&lt;size_t SZ&gt;\nclass LoopThroughHelper&lt;int, SZ&gt;\n{\npublic:\n    void operator()(const int(&amp;Item)[SZ]) \n    {\n        PRINT_TRACE(\"Specialized version\");\n        for (size_t index = 0; index &lt; SZ; ++index)\n        {\n            std::cout &lt;&lt; Item[index] &lt;&lt; \"\\n\";\n        }\n    }\n}; \n\n} // namespace detail\n\n// one function template to rule them all\ntemplate&lt;typename Type, size_t SZ&gt;\nvoid LoopThrough(const Type(&amp;Item)[SZ])\n{\n     detail::LoopThroughHelper&lt;Type, SZ&gt;()(Item);        \n}\n\nint main()\n{\n    {\n       int arr[] = { 1, 2 };\n       LoopThrough(arr);    \n    }\n}\n</code></pre>\n<p>Most likely, the compiler will inline the call to the function object and completely optimize away the temporary. Hopefully your compiler will also have correctly implemented partial specialization of class templates.</p>\n<p>Output on <a href=\"http://ideone.com/Dqcph\" rel=\"nofollow\">Ideone</a></p>\n", "OwnerUserId": "819272", "PostTypeId": "2", "Id": "11594059", "Score": "1", "CreationDate": "2012-07-21T16:48:43.860", "LastActivityDate": "2012-07-21T16:48:43.860"}, "11296389": {"CommentCount": "21", "ViewCount": "789", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2012-07-02T15:11:04.920", "LastActivityDate": "2012-09-26T21:06:42.767", "Title": "Template compilation error in Sun Studio 12", "AcceptedAnswerId": "12610403", "LastEditDate": "2012-07-21T16:52:11.753", "Id": "11296389", "Score": "6", "Body": "<p>We are migrating to Sun Studio 12.1 and with the new compiler [ CC: Sun C++ 5.10 SunOS_sparc 2009/06/03 ]. I am getting compilation error while compiling a code that compiled fine with earlier version of Sun Compiler [ CC: Sun WorkShop 6 update 2 C++ 5.3 2001/05/15 ].   </p>\n<p>This is the compilation error I get.</p>\n<blockquote>\n<p id=\"so_11296389_11296389_0\">\"Sample.cc\": Error: Could not find a match for LoopThrough(int[2])\n  needed in main(). 1 Error(s) detected.\n  *** Error code 1.</p>\n</blockquote>\n<p><strong>CODE:</strong> </p>\n<pre><code>#include &lt;iostream&gt; \n\n#define PRINT_TRACE(STR) \\\nstd::cout &lt;&lt; __FILE__ &lt;&lt; \":\" &lt;&lt; __LINE__ &lt;&lt; \":\" &lt;&lt; STR &lt;&lt; \"\\n\";\n\ntemplate&lt;size_t SZ&gt;\nvoid LoopThrough(const int(&amp;Item)[SZ])\n{\n    PRINT_TRACE(\"Specialized version\");\n    for (size_t index = 0; index &lt; SZ; ++index)\n    {\n        std::cout &lt;&lt; Item[index] &lt;&lt; \"\\n\";\n    }\n}\n\n\n/*     \n    template&lt;typename Type, size_t SZ&gt;\n    void LoopThrough(const Type(&amp;Item)[SZ])\n    {\n        PRINT_TRACE(\"Generic version\");        \n    }\n */  \n\n\n\nint main()\n{\n    {\n       int arr[] = { 1, 2 };\n       LoopThrough(arr);    \n    }\n}\n</code></pre>\n<p>If I uncomment the code with Generic version, the code compiles fine and the generic version is called. I don't see this problem with MSVC 2010 with extensions disabled and the same case with ideone <a href=\"http://ideone.com/opX6g\" rel=\"nofollow noreferrer\">here</a>.\nThe specialized version of the function is called. Now the question is, is this a bug in Sun Compiler ?  </p>\n<p>If yes, how could we file a bug report ?</p>\n", "Tags": "<c++><templates><overload-resolution><partial-specialization><sunstudio>", "OwnerUserId": "124797", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_11296389_12610403_6": {"section_id": 126, "quality": 1.0, "length": 5}, "so_11296389_12610403_4": {"section_id": 603, "quality": 0.85, "length": 17}, "so_11296389_12610403_3": {"section_id": 603, "quality": 0.8611111111111112, "length": 31}, "so_11296389_12610403_2": {"section_id": 563, "quality": 0.9473684210526315, "length": 18}, "so_11296389_12610403_5": {"section_id": 603, "quality": 0.75, "length": 6}, "so_11296389_12610403_1": {"section_id": 563, "quality": 0.8333333333333334, "length": 15}, "so_11296389_12610403_7": {"section_id": 603, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_11296389_12610403_6": {"section_id": 106, "quality": 0.8, "length": 4}, "so_11296389_12610403_4": {"section_id": 593, "quality": 0.85, "length": 17}, "so_11296389_12610403_3": {"section_id": 593, "quality": 0.8611111111111112, "length": 31}, "so_11296389_12610403_2": {"section_id": 554, "quality": 0.9473684210526315, "length": 18}, "so_11296389_12610403_5": {"section_id": 593, "quality": 0.75, "length": 6}, "so_11296389_12610403_1": {"section_id": 554, "quality": 0.8333333333333334, "length": 15}, "so_11296389_12610403_7": {"section_id": 593, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_11296389_12610403_6": {"section_id": 131, "quality": 1.0, "length": 5}, "so_11296389_12610403_4": {"section_id": 629, "quality": 0.85, "length": 17}, "so_11296389_12610403_3": {"section_id": 629, "quality": 0.8611111111111112, "length": 31}, "so_11296389_12610403_2": {"section_id": 586, "quality": 0.9473684210526315, "length": 18}, "so_11296389_12610403_1": {"section_id": 586, "quality": 0.8333333333333334, "length": 15}, "so_11296389_12610403_5": {"section_id": 629, "quality": 0.75, "length": 6}, "so_11296389_12610403_7": {"section_id": 629, "quality": 0.8571428571428571, "length": 12}}}});