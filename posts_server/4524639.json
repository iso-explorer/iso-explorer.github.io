post_cb({"4524664": {"ParentId": "4524639", "CommentCount": "0", "Body": "<pre><code>Window bRef=*button;\nbRef.Create(); // Output: Base class Window\n</code></pre>\n<p>The static as well as dynamic type of <code>bRef</code> is <code>Window</code> only. Virtual mechanism works only with references and pointers. <code>bRef</code> is an object not a reference or a pointer.</p>\n", "OwnerUserId": "165520", "PostTypeId": "2", "Id": "4524664", "Score": "2", "CreationDate": "2010-12-24T06:41:11.243", "LastActivityDate": "2010-12-24T06:41:11.243"}, "4524668": {"ParentId": "4524639", "CommentCount": "5", "Body": "<p>You have encountered the slicing problem.</p>\n<pre><code>Window bRef   =*button;\n</code></pre>\n<p>Here bRef is not a reference but an object. When you assign a derived type onto bRef you are slicing the derived part off leaving you with just a Window object constructed form a CommandButton.</p>\n<p>What is happening is that bRef is created in the above statement using the compiler generated copy constructor for the class Window. All this constructor does is copy member elements from the RHS to the newly constructed object. Since the class contains no members nothing is happening.</p>\n<p>On a side note:  A class with virtual members should also have a virtual destructor.</p>\n", "OwnerUserId": "14065", "PostTypeId": "2", "Id": "4524668", "Score": "10", "CreationDate": "2010-12-24T06:41:34.093", "LastActivityDate": "2010-12-24T06:41:34.093"}, "4524639": {"CommentCount": "0", "AcceptedAnswerId": "4524668", "CreationDate": "2010-12-24T06:35:52.970", "LastActivityDate": "2010-12-24T07:54:02.400", "PostTypeId": "1", "ViewCount": "1105", "FavoriteCount": "0", "Title": "Behavior of C++ Object Reference", "Id": "4524639", "Score": "5", "Body": "<p>Consider the following code segment:</p>\n<pre><code>class Window // Base class for C++ virtual function example\n     {\n       public:\n          virtual void Create() // virtual function for C++ virtual function example\n          {\n               cout &lt;&lt;\"Base class Window\"&lt;&lt;endl;\n          }\n     };\n\n     class CommandButton : public Window\n     {\n       public:\n          void Create()\n          {\n              cout&lt;&lt;\"Derived class Command Button - Overridden C++ virtual function\"&lt;&lt;endl;\n          }\n     };\n\n     int main()\n     {\n        Window *button = new   CommandButton;\n        Window&amp; aRef = *button;\n        aRef.Create(); // Output: Derived class Command Button - Overridden C++ virtual function\n        Window bRef=*button;\n        bRef.Create(); // Output: Base class Window\n\n        return 0;\n     }\n</code></pre>\n<p>Both <strong>aRef</strong> and <strong>bRef</strong> get assigned <strong>*button</strong>, but why are the two output different.\nWhat is the difference between assigning to Reference type and non Reference type?</p>\n", "Tags": "<c++><polymorphism><virtual-functions><object-reference>", "OwnerUserId": "326820", "AnswerCount": "4"}, "4524670": {"ParentId": "4524639", "PostTypeId": "2", "CommentCount": "0", "Body": "<ul>\n<li><code>aRef</code> has <code>Window</code> <em>static</em> type but <code>CommandButton</code> <em>dynamic</em> type</li>\n<li><code>bRef</code> is simply an object of type <code>Window</code> (<strong>the <code>CommandButton</code> <em>'part'</em> was  lost in the copy</strong>)</li>\n</ul>\n<p>This is commonly known as <a href=\"http://www.google.fr/url?sa=t&amp;source=web&amp;cd=1&amp;sqi=2&amp;ved=0CBkQFjAA&amp;url=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FObject_slicing&amp;ei=skAUTb6BB4iy8gOewYWEBw&amp;usg=AFQjCNHT9ZhdY3b-DeKaKLORDGZ3w1mwVg\" rel=\"nofollow\">object slicing</a> and it usually prevented by making base classes either abstract (by providing a pure virtual function) or non copyable (for example using <code>boost::noncopyable</code>), because either solution would make the code fail to compile on line <code>Window&amp; aRef = *button;</code>.</p>\n<hr>\n<p>Now, why does <code>bRef.Create()</code> call <code>Window::Create</code> ? Well, there is nothing more than a <code>Window</code> in <code>bRef</code> so there really isn't much of an alternative. This is essentially like declaring a <code>Window</code> and calling <code>Create</code> on it : the fact that <code>bRef</code> was copied from a <code>CommandButton</code> instance is irrelevant because the <code>CommandButton</code> portion was lost in the copy.</p>\n<p>I'll try to make this clearer by quoting the standard (10.3/6) :</p>\n<blockquote>\n<p id=\"so_4524639_4524670_0\">[Note: the interpretation of the call\n  of a virtual function depends on the\n  type of the object for which it is\n  called (<strong>the dynamic type</strong>), whereas the\n  interpretation of a call of a\n  nonvirtual member function depends\n  only on the type of the pointer or\n  reference denoting that object (<strong>the\n  static type</strong>) (5.2.2). ]</p>\n</blockquote>\n<p>Only through a pointer or reference indirection can the static type of an object differ from its dynamic type.</p>\n</hr>", "OwnerUserId": "451980", "LastEditorUserId": "451980", "LastEditDate": "2010-12-24T07:54:02.400", "Id": "4524670", "Score": "7", "CreationDate": "2010-12-24T06:42:09.697", "LastActivityDate": "2010-12-24T07:54:02.400"}, "bq_ids": {"n4140": {"so_4524639_4524670_0": {"section_id": 7010, "quality": 0.9230769230769231, "length": 24}}, "n3337": {"so_4524639_4524670_0": {"section_id": 6756, "quality": 0.9230769230769231, "length": 24}}, "n4659": {"so_4524639_4524670_0": {"section_id": 8507, "quality": 0.9230769230769231, "length": 24}}}, "4524665": {"ParentId": "4524639", "CommentCount": "4", "Body": "<pre><code> Window bRef=*button;\n bRef.Create(); // Output: Base class Window\n</code></pre>\n<p>Here <code>bRef</code> is not the reference to <code>button</code> (you just named it so). bRef gets only the base subobject which is <code>Window</code>.</p>\n", "OwnerUserId": "415784", "PostTypeId": "2", "Id": "4524665", "Score": "1", "CreationDate": "2010-12-24T06:41:20.303", "LastActivityDate": "2010-12-24T06:41:20.303"}});