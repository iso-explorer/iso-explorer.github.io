post_cb({"1144631": {"ParentId": "1144264", "CommentCount": "0", "Body": "<p>It's rare that I'll recommend not learning something about the language you're using, but in this case, whether or not pB is initialized isn't useful information.  Just initialize it.  If it's automatically initialized, the compiler will optimize out the extra initialization.  If it isn't, you've added one extra processor instruction and prevented a whole slew of potential bugs.</p>\n", "OwnerUserId": "130640", "PostTypeId": "2", "Id": "1144631", "Score": "0", "CreationDate": "2009-07-17T17:20:49.173", "LastActivityDate": "2009-07-17T17:20:49.173"}, "1144358": {"ParentId": "1144264", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Uninitialised pointers can point to anything.  Some compiler vendors will help you out and make them point to 0 or 0xcdcdcdcd or whatever.</p>\n<p>To make sure your code is safe and portable you should always initialise your pointers.  either to 0 or to a valid value.</p>\n<p>e.g. </p>\n<pre><code>C* pc = 0;\n</code></pre>\n<p>or</p>\n<pre><code>C* pc = new C(...);\n</code></pre>\n<p>If you always initialise pointers to 0 then this is safe : </p>\n<pre><code>if (!pc) \n    pc = new C(...);\n</code></pre>\n<p>If you don't initialise then you've got no way of telling initialised and uninitialised pointers apart.</p>\n<p>As an aside, there's no such keyword in C++ as NULL.  Most compilers define NULL as 0, but it's not considered portable to use it.  The new c++0x standard will introduce a new keyword, nullptr, so when that comes out we'll finally have a portable null pointer constant.</p>\n", "OwnerUserId": "52888", "LastEditorUserId": "52888", "LastEditDate": "2009-07-17T16:31:13.283", "Id": "1144358", "Score": "0", "CreationDate": "2009-07-17T16:26:12.997", "LastActivityDate": "2009-07-17T16:31:13.283"}, "1144435": {"ParentId": "1144264", "CommentCount": "0", "Body": "<p>According to the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf\" rel=\"nofollow noreferrer\">C++0x standard</a> section 12.6.2.4, in the case of your pointer variable, if you don't include it in the initializer list and you don't set it in the body of the constructor, then it has indeterminate value.  0xCDCDCDCD and 0 are two possible such values, as is anything else. :-)</p>\n", "OwnerUserId": "46821", "PostTypeId": "2", "Id": "1144435", "Score": "4", "CreationDate": "2009-07-17T16:40:32.170", "LastActivityDate": "2009-07-17T16:40:32.170"}, "1144359": {"ParentId": "1144264", "CommentCount": "0", "Body": "<p>The value of pB is undefined.  It may or may not be consistently the same value - usually depends on what was previously at the same place in memory prior to the allocation of a particular instance of A.</p>\n", "OwnerUserId": "103912", "PostTypeId": "2", "Id": "1144359", "Score": "0", "CreationDate": "2009-07-17T16:26:20.437", "LastActivityDate": "2009-07-17T16:26:20.437"}, "1144329": {"ParentId": "1144264", "CommentCount": "0", "Body": "<p>I believe this is a artifact from the good old C days when you could not have expectations on what alloc'd memory contains.  As the standards progressed to C++ this \"convention\" was maintained.  As the C++ compilers developed the individual authors took it upon themselves to \"fix\" this problem.  Therefore your mileage may vary depending on your compiler of choice.</p>\n<p>The \"0xcdcdcdcd\" looks to be a readily identifiable pattern that \"helps\" in debugging you code.  That is why it doesn't show in release mode.</p>\n<p>I hope this helped in a little way and good luck.</p>\n", "OwnerUserId": "2894", "PostTypeId": "2", "Id": "1144329", "Score": "1", "CreationDate": "2009-07-17T16:22:17.497", "LastActivityDate": "2009-07-17T16:22:17.497"}, "1144264": {"CommentCount": "2", "ViewCount": "2737", "CreationDate": "2009-07-17T16:11:38.733", "LastActivityDate": "2009-07-17T18:01:08.903", "Title": "C++: member pointer initialised?", "AcceptedAnswerId": "1144404", "PostTypeId": "1", "Id": "1144264", "Score": "8", "Body": "<p>Code sample should explain things:</p>\n<pre><code>class A\n{\n    B* pB;\n    C* pC;\n    D d;\n\n    public : \n    A(int i, int j) : d(j)\n    {\n        pC = new C(i, \"abc\");\n    } // note pB is not initialised, e.g. pB(NULL)\n\n    ...\n};\n</code></pre>\n<p>Obviously pB should be initialised to NULL explicitly to be safe (and clear), but, as it stands, <strong>what is the value of pB after construction of A?</strong> Is it default initialised (which is zero?) or not (i.e. indeterminate and whatever was in memory). I realise initialisation in C++ has a fair few rules.</p>\n<p>I think it isn't default initialised; as running in debug mode in Visual Studio it has set pB pointing to 0xcdcdcdcd - which means the memory has been new'd (on the heap) but not initialised. However in release mode, pB always points to NULL. Is this just by chance, and therefore not to be relied upon; or are these compilers initialising it for me (even if it's not in the standard)? It also seems to be NULL when compiled with Sun's compiler on Solaris.</p>\n<p>I'm really looking for a specific reference to the standard to say one way or the other.</p>\n<p>Thanks.</p>\n", "Tags": "<c++><pointers><default>", "OwnerUserId": "140278", "AnswerCount": "7"}, "1144404": {"ParentId": "1144264", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Here is the relevant passage fromt he standard:</p>\n<blockquote>\n<p id=\"so_1144264_1144404_0\">12.6.2  Initializing bases and members               [class.base.init]</p>\n<p id=\"so_1144264_1144404_1\">4 If  a given nonstatic data member or\n  base class is not named by a mem-<br>\n  initializer-id in the\n  mem-initializer-list, then</br></p>\n<p id=\"so_1144264_1144404_2\">--If the entity is a nonstatic data\n  member of (possibly  cv-qualified)\n      class  type (or array thereof) or a base class, and the entity class\n      is a non-POD class, the entity is default-initialized  (<em>dcl.init</em>).\n      If  the entity is a nonstatic data member of a const-qualified type,\n      the entity class shall have a user-declared default constructor.</p>\n<p id=\"so_1144264_1144404_3\">--<strong>Otherwise, the entity is not \n  initialized</strong>.   If  the  entity  is  of\n      const-qualified  type or reference type, or of a (possibly cv-quali-\n      fied) POD class type (or  array  thereof)  containing  (directly  or\n      indirectly)  a member of a const-qualified type, the program is\n  ill-\n      formed.</p>\n<p id=\"so_1144264_1144404_4\">After the call to a constructor for\n  class X has completed, if a member</p>\n<p id=\"so_1144264_1144404_5\">of  X  is neither specified in the\n  constructor's mem-initializers, nor<br>\n  default-initialized, nor initialized\n  during execution of the  body  of<br>\n  the constructor, the member has\n  indeterminate value.</br></br></p>\n</blockquote>\n", "OwnerUserId": "5963", "LastEditorUserId": "5963", "LastEditDate": "2009-07-17T17:37:30.903", "Id": "1144404", "Score": "11", "CreationDate": "2009-07-17T16:35:38.670", "LastActivityDate": "2009-07-17T17:37:30.903"}, "1144413": {"ParentId": "1144264", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Uninitialised pointers are allow to basically contain a random value, although some compilers tend to fill them with 0 or some other recognisable value, especially in debug mode.</p>\n<p>IMHO this is due to C++'s \"don't pay for what you don't use\" design. If you don't consider it important, the compiler does not need to go through the expense of initialising the variable for you. Of course, once you've chased a random pointer you might find it prudent to initialise it the next time around...</p>\n", "OwnerUserId": "29068", "LastEditorUserId": "29068", "LastEditDate": "2009-07-17T18:01:08.903", "Id": "1144413", "Score": "0", "CreationDate": "2009-07-17T16:37:03.973", "LastActivityDate": "2009-07-17T18:01:08.903"}, "bq_ids": {"n4140": {"so_1144264_1144404_5": {"section_id": 435, "quality": 0.7333333333333333, "length": 11}, "so_1144264_1144404_1": {"section_id": 7043, "quality": 0.5454545454545454, "length": 6}, "so_1144264_1144404_4": {"section_id": 435, "quality": 1.0, "length": 6}}, "n3337": {"so_1144264_1144404_5": {"section_id": 427, "quality": 0.7333333333333333, "length": 11}, "so_1144264_1144404_1": {"section_id": 427, "quality": 0.7272727272727273, "length": 8}, "so_1144264_1144404_4": {"section_id": 427, "quality": 1.0, "length": 6}, "so_1144264_1144404_2": {"section_id": 451, "quality": 0.5483870967741935, "length": 17}}, "n4659": {"so_1144264_1144404_5": {"section_id": 454, "quality": 0.7333333333333333, "length": 11}, "so_1144264_1144404_1": {"section_id": 8540, "quality": 0.5454545454545454, "length": 6}, "so_1144264_1144404_4": {"section_id": 454, "quality": 1.0, "length": 6}}}});