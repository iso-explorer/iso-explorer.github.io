post_cb({"bq_ids": {"n4140": {"so_10339012_10339411_0": {"length": 36, "quality": 0.972972972972973, "section_id": 179}}, "n3337": {"so_10339012_10339411_0": {"length": 36, "quality": 0.972972972972973, "section_id": 173}}, "n4659": {"so_10339012_10339411_0": {"length": 36, "quality": 0.972972972972973, "section_id": 184}}}, "10339012": {"ViewCount": "441", "Body": "<p>I would very much like to be able to provide a functor as a template argument. The functors must be able to provide \"themself\" as that argument.</p>\n<p>I imagine something like this:    </p>\n<pre><code>template&lt;typename T, template&lt;typename&gt; class SumFunctor&gt; class foo;\n\ntemplate&lt;typename T&gt;\nstruct sum_default\n{\n    foo&lt;T, sum_default&gt; operator()(foo&lt;T, sum_default&gt; a, foo&lt;T, sum_default&gt; b) const \n    {\n            T a_data = a.data();\n            T b_data = b.data();\n            return foo&lt;T, sum_default&gt;(a_data + b_data);\n    }\n};\n\ntemplate&lt;typename T&gt;\nstruct sum_awesome\n{\n    foo&lt;T, sum_awesome&gt; operator()(foo&lt;T, sum_awesome&gt; a, foo&lt;T, sum_awesome&gt; b) const \n    {\n            T a_data = a.data();\n            T b_data = b.data();\n            return foo&lt;T, sum_awesome&gt;(a_data - b_data);\n    }\n};\n\ntemplate&lt;typename T=int, template&lt;typename&gt; class SumFunctor=sum_default&gt;\nclass foo\n{\nprivate:\n    T _data;\n    SumFunctor&lt;T&gt; _functor;\npublic:\n    foo&lt;T, SumFunctor&gt;(T data) : _data(data) {}\n\n    T data() { return _data; }\n\n    friend const foo operator +(const foo&amp; lhs, const foo&amp; rhs)\n    {\n            return lhs._functor(lhs,rhs);\n    }\n};\n\nint main(){\n    foo&lt;&gt; a(42); \n    foo&lt;double&gt; b(1.0);\n    foo&lt;double,sum_default&gt; c(4.0);\n    foo&lt;double,sum_awesome&gt; d(4.0);\n\n    a+a;\n    d+d;\n}\n</code></pre>\n<p>Is this possible, and if so, how?</p>\n<p>An alternative solution is to provide the functor to the constructor, but this is very ugly i think, as the user must dynamically allocate the functor himself (As we cannot determine the type of the functor in the constructor. Using RTTI to do so also seems a bit ugly):</p>\n<pre><code>foo&lt;double&gt; a(42, new sum_default&lt;double&gt;() );\n</code></pre>\n<p>This also forces all functors to be derived from some pre-defined base functor.</p>\n<p><strong>UPDATE</strong></p>\n<p>Attempting to add template arguments to the sum_default template argument does not appear to solve the problem:</p>\n<pre><code>template&lt;typename T&gt;\nstruct sum_default\n{\n// Error    1   error C3200: 'sum_default&lt;T&gt;' : invalid template argument for template parameter 'SumFunctor', expected a class template\nfoo&lt;T, sum_default&lt;T&gt; &gt; operator()(foo&lt;T, sum_default&lt;T&gt; &gt; a, foo&lt;T, sum_default&lt;T&gt; &gt; b) const \n{\n    T a_data = a.data();\n    T b_data = b.data();\n    return foo&lt;T, sum_default&lt;T&gt; &gt;(a_data + b_data);\n}\n};\n</code></pre>\n", "AcceptedAnswerId": "10339411", "Title": "Template functors which must provide themself as a template arguments", "CreationDate": "2012-04-26T18:10:47.380", "Id": "10339012", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-04-26T18:29:44.470", "LastEditorUserId": "1202032", "LastActivityDate": "2012-04-26T18:57:35.230", "Score": "1", "OwnerUserId": "1202032", "Tags": "<c++><templates><constructor><functor>", "AnswerCount": "1"}, "10339411": {"Id": "10339411", "PostTypeId": "2", "Body": "<p>What's biting you here is known as \"class name injection\" \u2013 inside of a class template, e.g. <code>Foo&lt;T&gt;</code>, unqualified use of <code>Foo</code> is actually treated as <code>Foo&lt;T&gt;</code>. Citing C++11 \u00a714.6.1/1:</p>\n<blockquote>\n<p id=\"so_10339012_10339411_0\">Like normal (non-template) classes, class templates have an injected-class-name. The injected-class-name can be used as a <em>template-name</em> or a <em>type-name</em>. When it is used with a <em>template-argument-list</em>, as a <em>template-argument</em> for a template <em>template-parameter</em>, or as the final identifier in the <em>elaborated-type-specifier</em> of a friend class template declaration, it refers to the class template itself. Otherwise, it is equivalent to the <em>template-name</em> followed by the <em>template-parameters</em> of the class template enclosed in <code>&lt;&gt;</code>.</p>\n</blockquote>\n<p>Consequently, inside of <code>sum_default&lt;T&gt;</code>, when you have <code>foo&lt;T, sum_default&gt;</code>, it's treated as though you typed <code>foo&lt;T, sum_default&lt;T&gt; &gt;</code> (which obviously won't work as <code>foo</code> wants a template template parameter).</p>\n<p>In order to avoid this behavior, you need to qualify uses of the class template names inside of those class templates. Because your class templates are in the global scope, <code>::</code> is sufficient:</p>\n<pre><code>template&lt;typename T&gt;\nstruct sum_default;\n\ntemplate&lt;typename T = int, template&lt;typename&gt; class SumFunctor = sum_default&gt;\nclass foo\n{\n    T _data;\n    SumFunctor&lt;T&gt; _functor;\n\npublic:\n    foo&lt;T, SumFunctor&gt;(T data) : _data(data) { }\n\n    T data() { return _data; } const\n\n    friend foo operator +(foo const&amp; lhs, foo const&amp; rhs)\n    {\n        return lhs._functor(lhs, rhs);\n    }\n};\n\ntemplate&lt;typename T&gt;\nstruct sum_default\n{\n    foo&lt;T, ::sum_default&gt; operator ()(foo&lt;T, ::sum_default&gt; a,\n                                      foo&lt;T, ::sum_default&gt; b) const\n    {\n        return foo&lt;T, ::sum_default&gt;(a.data() + b.data());\n    }\n};\n\ntemplate&lt;typename T&gt;\nstruct sum_awesome\n{\n    foo&lt;T, ::sum_awesome&gt; operator()(foo&lt;T, ::sum_awesome&gt; a,\n                                     foo&lt;T, ::sum_awesome&gt; b) const\n    {\n        return foo&lt;T, ::sum_awesome&gt;(a.data() - b.data());\n    }\n};\n\nint main()\n{\n    foo&lt;&gt; a(42);\n    foo&lt;double&gt; b(1.0);\n    foo&lt;double, sum_default&gt; c(4.0);\n    foo&lt;double, sum_awesome&gt; d(4.0);\n\n    a + a;\n    d + d;\n}\n</code></pre>\n<p>Note that this also allows you to define <code>foo</code>'s constructor thusly, reducing a bit of noise:</p>\n<pre><code>foo(T data) : _data(data) { }\n</code></pre>\n", "LastEditorUserId": "636019", "LastActivityDate": "2012-04-26T18:57:35.230", "Score": "3", "CreationDate": "2012-04-26T18:38:58.483", "ParentId": "10339012", "CommentCount": "1", "OwnerUserId": "636019", "LastEditDate": "2012-04-26T18:57:35.230"}});