post_cb({"bq_ids": {"n4140": {"so_28187170_28188355_3": {"length": 7, "quality": 1.0, "section_id": 188}, "so_28187170_28188355_4": {"length": 9, "quality": 1.0, "section_id": 7104}}, "n3337": {"so_28187170_28188355_3": {"length": 5, "quality": 0.7142857142857143, "section_id": 182}, "so_28187170_28188355_4": {"length": 9, "quality": 1.0, "section_id": 6848}}, "n4659": {"so_28187170_28188355_3": {"length": 7, "quality": 1.0, "section_id": 193}, "so_28187170_28188355_4": {"length": 9, "quality": 1.0, "section_id": 8605}}}, "28187170": {"ViewCount": "207", "Body": "<p>Is there some way to force C++ compilers to perform name lookup for a given symbol during template instantiation (and not before)?</p>\n<p>Given the following code:</p>\n<pre><code>template &lt;class T&gt;\nauto wrapper( T t ) -&gt; decltype( f( t ) )\n{\n    return f( t );\n}\n\nunsigned char f( int x ) { return x % 256; }\nunsigned char f( unsigned char x ) { return x; }\n\nint main( int, char ** )\n{\n    auto x = wrapper( 3100 );\n    return 0;\n}\n</code></pre>\n<p>Is there anything I can do (apart from moving the definition of <code>f</code> to the top) in order to make that code compile and give the same results as if all definitions of <code>f</code> were available before the definition of <code>wrapper</code>?</p>\n<p>I could not find anything, probably because I do not know how to phrase this question properly. All argument types of <code>f</code> can be assumed to be user-defined types, if this helps.</p>\n", "AcceptedAnswerId": "28188355", "Title": "C++ enforce second-pass name lookup in template function", "CreationDate": "2015-01-28T07:52:08.580", "Id": "28187170", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-01-28T16:44:26.447", "Score": "7", "OwnerUserId": "898813", "Tags": "<c++><templates><name-lookup>", "AnswerCount": "3"}, "28187614": {"Id": "28187614", "PostTypeId": "2", "Body": "<p>The following code is not quite clean, but illustrates how class template specialization can be used in order to solve the problem. It maintains the original interface (i.e. <code>f</code> and <code>wrapper</code> can be used in the same way as before).</p>\n<p>Thank you for giving me the right hints. I am open for a solution that is less verbose though.</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;class ...&gt;\nstruct F;\n\ntemplate &lt;class T&gt;\nauto wrapper( T t )\n    -&gt; decltype( F&lt;typename std::decay&lt;T&gt;::type&gt;::f( t ) )\n{\n    return F&lt;typename std::decay&lt;T&gt;::type&gt;::f( t );\n}\n\ntemplate &lt;&gt;\nstruct F&lt;unsigned char&gt;\n{\n    static unsigned char f( unsigned char x ) { return x; }\n};\n\ntemplate &lt;&gt;\nstruct F&lt;int&gt;\n{\n    static unsigned char f( int x ) { return x % 256; }\n};\n\ntemplate &lt;class T&gt;\nauto f( T t )\n    -&gt; decltype( F&lt;typename std::decay&lt;T&gt;::type&gt;::f( t ) )\n{\n    return F&lt;typename std::decay&lt;T&gt;::type&gt;::f( t );\n}\n\nint main( int, char ** )\n{\n    auto x = wrapper( 3100 );\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2015-01-28T08:24:42.753", "CommentCount": "0", "CreationDate": "2015-01-28T08:24:42.753", "ParentId": "28187170", "Score": "0", "OwnerUserId": "898813"}, "28188355": {"Id": "28188355", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_28187170_28188355_0\">Is there some way to force C++ compilers to perform name lookup for a\n  given symbol during template instantiation (and not before)?</p>\n</blockquote>\n<p>Yes. First of all, the name must be dependent. The name <code>f</code> in <code>wrapper</code> when used as <code>f(t)</code> is dependent because <code>t</code> is type-dependent. [temp.dep]/1:</p>\n<blockquote>\n<p id=\"so_28187170_28188355_1\">In an expression of the form:</p>\n<p id=\"so_28187170_28188355_2\">\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>postfix-expression</em>\n<code>(</code> <em>expression-list</em> <sub>opt</sub> <code>)</code></p>\n<p id=\"so_28187170_28188355_3\">where the <em>postfix-expression</em> is an <em>unqualified-id</em>, the\n  <em>unqualified-id</em> denotes a dependent name if</p>\n<ul>\n<li>any of the expressions in the <em>expression-list</em> is a pack expansion (14.5.3),</li>\n<li><strong>any of the expressions in the <em>expression-list</em> is a type-dependent expression (14.6.2.2)</strong>, or</li>\n<li>if the <em>unqualified-id</em> is a <em>template-id</em> in which any of the template arguments depends on a template parameter.</li>\n</ul>\n</blockquote>\n<p>The problem is that names declared after the template itself, i.e. only in the instantiation but not the definition context, can solely be found using <strong>argument dependent name lookup</strong>. Your <code>f</code> overloads only take fundamental types, but those do not have the global namespace associated with them according to [basic.lookup.argdep]/2:</p>\n<blockquote>\n<p id=\"so_28187170_28188355_4\">If <code>T</code> is a fundamental type, its associated sets of namespaces and\n  classes are both empty.</p>\n</blockquote>\n<p>Thus the <code>f</code>s you declared can never be found if the arguments are of the same type as the parameters. A little trick can help:</p>\n<pre><code>template &lt;typename T&gt;\nstruct refwrap\n{\n    T&amp;&amp; t;\n    refwrap(T&amp;&amp; t) : t(std::forward&lt;T&gt;(t)) {}\n    operator T&amp;&amp;() {return std::forward&lt;T&gt;(t);}\n};\n\ntemplate &lt;typename T&gt;\nauto make_refwrap( T&amp;&amp; t ) -&gt; refwrap&lt;T&gt; // making use of reference collapsing\n{ return {std::forward&lt;T&gt;(t)}; }         // inside refwrap to get forwarding\n</code></pre>\n<p>This template, when declared in the global namespace, will cause ADL to consider it. Rewrite <code>wrapper</code> as follows:</p>\n<pre><code>template &lt;class T&gt;\nauto wrapper( T t ) -&gt; decltype( f( make_refwrap(t) ) )\n{\n    return f( make_refwrap(t) );\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/42588a95d07d19dd\" rel=\"nofollow\"><strong>Demo</strong></a>. This is not the proper way to do it though, as it will fail in more complex scenarios.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-01-28T16:44:26.447", "Score": "2", "CreationDate": "2015-01-28T09:11:31.233", "ParentId": "28187170", "CommentCount": "2", "OwnerUserId": "3647361", "LastEditDate": "2015-01-28T16:44:26.447"}, "28187408": {"Id": "28187408", "PostTypeId": "2", "Body": "<p>This would work with template specialization. Note that you have to decide what the default function is, because i cannot see it in question.</p>\n<pre><code>// default function\ntemplate &lt;class T&gt;\nunsigned char f( T x ) { return x; }\n\n// specialization for int\ntemplate &lt;&gt;\nunsigned char f( int x ) { return x % 256; }\n\nint main( int, char ** )\n{\n    auto x = f( 3100 );\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2015-01-28T08:08:33.843", "CommentCount": "5", "CreationDate": "2015-01-28T08:08:33.843", "ParentId": "28187170", "Score": "1", "OwnerUserId": "1673574"}});