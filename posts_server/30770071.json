post_cb({"30770449": {"ParentId": "30770071", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2015-06-11T02:15:43.753", "Score": "2", "LastEditorUserId": "2756719", "LastEditDate": "2015-06-11T02:41:18.763", "Id": "30770449", "OwnerUserId": "2756719", "Body": "<p>I can reproduce this with <a href=\"http://melpon.org/wandbox/permlink/4cv1HIcpuBzJNCqw\" rel=\"nofollow\">Clang 3.1-3.3 as well as 3.6</a>. Looks like <a href=\"https://llvm.org/bugs/show_bug.cgi?id=16478\" rel=\"nofollow\">bug 16478</a>. </p>\n<p>Simplest fix is to just use a lambda or equivalent. Other completely non-portable workarounds include either disabling extern templates with</p>\n<pre><code>#ifndef _LIBCPP_EXTERN_TEMPLATE\n#define _LIBCPP_EXTERN_TEMPLATE(...)\n#endif\n</code></pre>\n<p>before you include any headers (in essence applying <a href=\"http://llvm.org/viewvc/llvm-project?view=revision&amp;revision=189610\" rel=\"nofollow\">r189610</a>); and doing an explicit instantiation of either the member function (<code>template void std::string::clear();</code>) or the entire class.</p>\n<p>That said, you should not take the address of a member function of a standard library class. [member.functions]/p2:</p>\n<blockquote>\n<p id=\"so_30770071_30770449_0\">An implementation may declare additional non-virtual member function\n  signatures within a class:</p>\n<ul>\n<li>by adding arguments with default values to a member function signature;<sup>187</sup></li>\n<li>by replacing a member function signature with default values by two or more member function signatures with equivalent behavior; and</li>\n<li>by adding a member function signature for a member function name.</li>\n</ul>\n<p id=\"so_30770071_30770449_1\"><sup>187)</sup> Hence, the address of a member function of a class in\n  the C++ standard library has an unspecified type.</p>\n</blockquote>\n", "LastActivityDate": "2015-06-11T02:41:18.763"}, "30770573": {"ParentId": "30770071", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-06-11T02:33:09.783", "Score": "0", "LastEditorUserId": "153285", "LastEditDate": "2015-06-12T00:45:07.367", "Id": "30770573", "OwnerUserId": "153285", "Body": "<p>As for the standard, you can't take a pointer to any standard nonstatic member because the library implementation is allowed to add hidden overloads, defaulted function template parameters, SFINAE in the return type, etc.</p>\n<p>In other words, <code>&amp; std::string::clear</code> is simply not a supported operation.</p>\n<p>In terms of Clang, it looks like an issue with hidden symbol visibility. Each shared object (linker output) file gets its own copy of certain functions to avoid the appearance that third-party shared libraries implement the standard library. With different copies floating around, the equality operator over PTMFs would not work: If you retain the value <code>&amp; std::string::clear</code> from an inline function, it might not compare equal to itself later. However, it's probably a bug, since <code>std::string</code> should be completely implemented by the <code>libc++.so</code> shared library. Only other specializations of <code>std::basic_string</code> could really justify this behavior.</p>\n<p>A good fix would be to use a lambda instead. <code>[]( std::string &amp; o ) { o.clear(); }</code> is a superior alternative to <code>mem_fn</code>. It avoids the indirect call and its <code>sizeof</code> is smaller. Really, you shouldn't use <code>mem_fn</code> unless absolutely necessary.</p>\n", "LastActivityDate": "2015-06-12T00:45:07.367"}, "bq_ids": {"n4140": {"so_30770071_30770449_1": {"section_id": 6341, "quality": 0.7777777777777778, "length": 7}, "so_30770071_30770449_0": {"section_id": 6341, "quality": 1.0, "length": 10}}, "n3337": {"so_30770071_30770449_1": {"section_id": 6098, "quality": 0.7777777777777778, "length": 7}, "so_30770071_30770449_0": {"section_id": 6098, "quality": 1.0, "length": 10}}, "n4659": {"so_30770071_30770449_1": {"section_id": 7709, "quality": 0.6666666666666666, "length": 6}, "so_30770071_30770449_0": {"section_id": 49, "quality": 0.6, "length": 6}}}, "30770071": {"CommentCount": "0", "ViewCount": "88", "CreationDate": "2015-06-11T01:27:54.900", "LastActivityDate": "2015-06-12T00:45:07.367", "Title": "why can't apply mem_fn to member function of std::string?", "AcceptedAnswerId": "30770573", "PostTypeId": "1", "Id": "30770071", "Score": "4", "Body": "<pre><code>struct int_holder {\n    int value;\n    int triple() {return value*3;}\n};\n\nint main(int argc, const char * argv[])\n{\n    std::string abc{\"abc\"};\n    int_holder one{1};\n\n    auto f1 = mem_fn(&amp;std::string::clear);\n    auto f2 = mem_fn(&amp;int_holder::triple);\n    f1(abc);\n    f2(one);\n}\n</code></pre>\n<p>i test such code in Xcode and the compiler issues such error\n<img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/asOuI.png\"/></p>\n<p>it seems mem_fn is fine with member functions of user-defined class but not with member functions of standard string, what's the different, and why?\nthanks for your reading, help me plz!</p>\n", "Tags": "<c++>", "OwnerUserId": "2184663", "AnswerCount": "2"}});