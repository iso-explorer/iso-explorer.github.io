post_cb({"bq_ids": {"n4140": {"so_22680757_22681468_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 7153}}, "n3337": {"so_22680757_22681468_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 6897}}, "n4659": {"so_22680757_22681468_0": {"length": 23, "quality": 0.6571428571428571, "section_id": 8657}}}, "22680757": {"ViewCount": "247", "Body": "<p>I'm trying to initialize a global map</p>\n<pre><code>std::map&lt;long, std::string&gt; Global_ID_Mapper;\n</code></pre>\n<p>with a number of \"init\" classes like:</p>\n<pre><code>struct AGlobalMapperInitializer\n{\n    AGlobalMapperInitializer() \n    {\n        Global_ID_Mapper.insert( std::make_pair(1, \"Value1\") );\n        Global_ID_Mapper.insert( std::make_pair(2, \"Value2\") );\n    }\n};\n</code></pre>\n<p>I want to fill the map automatically during application start. So in one of my cpp files, I just define a global variable of that \"init\" class.</p>\n<pre><code>// AGlobalMapperInitializer.cpp\n\nAGlobalMapperInitializer AGlobalMapperInitializer_Value;\n</code></pre>\n<p>The Mapper filling is a side effect of the <code>AGlobalMapperInitializer_Value</code> creation.</p>\n<p>The problem is that the cpp is obviously ignored by linker if the cpp doesn't contain anything except this global variable. When I put some useful other code into the cpp (or define the global initializer in some non-empty cpp), the constructor is invoked and the global mapper is filled. But if the cpp contains only the global that isn't referenced in no other file, the cpp is compiled, the obj file contains the variable, but the linker doesn't mention it during the link and it is missed in the exe.</p>\n<p>How can I insist on linking the cpp into exe? \nIs there some pragma or dummy code to put into the cpp to get it non-ignored?\nI use the Visual Studio 2012.</p>\n", "AcceptedAnswerId": "22696557", "Title": "cpp file with a single global variable is ignored", "CreationDate": "2014-03-27T07:19:55.767", "Id": "22680757", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-03-30T17:08:21.660", "Score": "3", "OwnerUserId": "940014", "Tags": "<c++><visual-studio-2012><linker>", "AnswerCount": "3"}, "22686424": {"Id": "22686424", "PostTypeId": "2", "Body": "<p>The linker doesn't include the variable and it's initializer when it is not referenced. You can create a reference to this variable inside your code:</p>\n<pre><code>int main()\n{\n    printf(\"\", &amp;AGlobalMapperInitializer_Value));\n}\n</code></pre>\n<p>If you want to avoid this contamination of the source code you cause the same effect with the <code>/INCLUDE</code> argument of the linker. You have to add the decorated name that you can take from the .map file when you have tried the hack above.</p>\n<p>The VS2010 offers this options as <code>Force Symbol Reference</code> in the project properties: Configuration Properies -&gt; Linker -&gt; Input. I hope it's the same for VS2012.</p>\n", "LastActivityDate": "2014-03-27T11:36:08.023", "Score": "1", "CreationDate": "2014-03-27T11:36:08.023", "ParentId": "22680757", "CommentCount": "3", "OwnerUserId": "266487"}, "22681468": {"Id": "22681468", "PostTypeId": "2", "Body": "<p>C++ does not require initialisation of a global variable <code>x</code> to take place if no function or variable from the same file (actually translation unit) as <code>x</code> is ever referenced.</p>\n<p>See C++11 <code>[basic.start.init]\u00a74</code>:</p>\n<blockquote>\n<p id=\"so_22680757_22681468_0\">It is implementation-defined whether the dynamic initialization of a non-local variable with static storage duration is done before the first statement of <code>main</code>. If the initialization is deferred to some point in time after the first statement of <code>main</code>, it shall occur before the first odr-use (3.2) of any function or variable defined in the same translation unit as the variable to be initialized.</p>\n</blockquote>\n<p>So to force the variable initialisation, you have to put it into a file whose other contents you actually use, or directly use the variable somewhere.</p>\n", "LastActivityDate": "2014-03-27T08:01:31.597", "Score": "2", "CreationDate": "2014-03-27T08:01:31.597", "ParentId": "22680757", "CommentCount": "4", "OwnerUserId": "1782465"}, "22696557": {"Id": "22696557", "PostTypeId": "2", "Body": "<p>Thanks for both Angew and harper that helped to find the solution.</p>\n<p>There are 2 possible solutions:</p>\n<ol>\n<li><p>The portable one (but not good because of its performance).</p>\n<p>The initializer instance can be defined not in the dedicated cpp file, but in the h, using the word <code>static</code>.</p>\n<pre><code>// AGlobalMapperInitializer.h\n// It wasn't mentioned before that this h file is included in many cpp files\nstruct AGlobalMapperInitializer\n{\n    AGlobalMapperInitializer() \n    {\n        if( !Global_ID_Mapper.insert( std::make_pair(1, \"Value1\") ).second ) \n            return;\n        Global_ID_Mapper.insert( std::make_pair(2, \"Value2\") );\n    }\n};\n\nstatic AGlobalMapperInitializer AGlobalMapperInitializer_Value;\n</code></pre>\n<p>Since the variable is <code>static</code>, the <code>AGlobalMapperInitializer_Value</code> is created separately in all the cpp files that include the h file. Each of these variables is trying to add values to the global mapper. Definitely, only one of them succeed. The performance problem is partially resolved by checking result of the first insert. If the first value was already inserted - no need to try other values.</p>\n<p><strong>Note</strong>: It is assumed that all these instances will be created within the same thread, otherwise the Global Mapper should implement synchronization of the insert calls.</p></li>\n<li><p>The compiler-specific solution (Visual Studio). </p>\n<p>The linker can be forced to keep class by adding <code>#pragma comment (linker, \"/include:&lt;decorated name&gt;\")</code>. The decorated name can be a class constructor or any other function. The issue is that specifying decorated name hard-code isn't good nor convenient. The decoration method can change with compiler upgrade. So, here the <code>__FUNCDNAME__</code> can be used.</p>\n<pre><code>struct AGlobalMapperInitializer\n{\n    AGlobalMapperInitializer() \n    {\n        // Make sure the class will not be threw away by linker\n        #pragma comment (linker, \"/include:\"__FUNCDNAME__) \n\n        Global_ID_Mapper.insert( std::make_pair(1, \"Value1\") );\n        Global_ID_Mapper.insert( std::make_pair(2, \"Value2\") );\n    }\n};\n</code></pre>\n<p>Fortunately, the <code>#pragma</code> can be specified inside the class constructor.</p></li>\n</ol>\n", "LastEditorUserId": "266487", "LastActivityDate": "2014-03-30T17:08:21.660", "Score": "1", "CreationDate": "2014-03-27T18:49:05.263", "ParentId": "22680757", "CommentCount": "0", "OwnerUserId": "940014", "LastEditDate": "2014-03-30T17:08:21.660"}});