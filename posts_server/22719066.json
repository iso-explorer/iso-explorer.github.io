post_cb({"bq_ids": {"n4140": {"so_22719066_22719985_1": {"length": 17, "quality": 1.0, "section_id": 5962}, "so_22719066_22719985_4": {"length": 6, "quality": 1.0, "section_id": 5962}, "so_22719066_22719985_2": {"length": 5, "quality": 1.0, "section_id": 5962}, "so_22719066_22719985_3": {"length": 6, "quality": 1.0, "section_id": 5962}, "so_22719066_22719985_5": {"length": 6, "quality": 1.0, "section_id": 5962}, "so_22719066_22719985_0": {"length": 33, "quality": 0.868421052631579, "section_id": 5962}}, "n3337": {"so_22719066_22719985_3": {"length": 6, "quality": 1.0, "section_id": 5731}, "so_22719066_22719985_4": {"length": 6, "quality": 1.0, "section_id": 5731}, "so_22719066_22719985_2": {"length": 5, "quality": 1.0, "section_id": 5731}, "so_22719066_22719985_1": {"length": 17, "quality": 1.0, "section_id": 5731}, "so_22719066_22719985_5": {"length": 6, "quality": 1.0, "section_id": 5731}, "so_22719066_22719985_0": {"length": 33, "quality": 0.868421052631579, "section_id": 5731}}, "n4659": {"so_22719066_22719985_3": {"length": 6, "quality": 1.0, "section_id": 7452}, "so_22719066_22719985_1": {"length": 17, "quality": 1.0, "section_id": 7452}, "so_22719066_22719985_4": {"length": 6, "quality": 1.0, "section_id": 7452}, "so_22719066_22719985_5": {"length": 6, "quality": 1.0, "section_id": 7452}, "so_22719066_22719985_2": {"length": 5, "quality": 1.0, "section_id": 7452}}}, "22719066": {"ViewCount": "1742", "Body": "<p>I can't find anything about throwing exceptions during constructing closure object.</p>\n<p>It's oblivious that this expression can throw during copy construction of the vector:</p>\n<pre><code>auto v = std::vector&lt;int&gt;(1000000);\n[v]{};\n</code></pre>\n<p>But what about empty or \"by reference\" capture lists like this:</p>\n<pre><code>[&amp;]{};\n</code></pre>\n<p>I'm speaking only about construction of closure object now. Calling isn't interesting.</p>\n<p>I read <code>5.1.2 Lambda expressions [expr.prim.lambda]</code>, but found nothing special about nothrow guarantee.</p>\n", "AcceptedAnswerId": "22719985", "Title": "Can C++ lambda-expression throw?", "CreationDate": "2014-03-28T17:05:24.290", "Id": "22719066", "CommentCount": "1", "LastEditDate": "2014-03-28T18:31:37.310", "PostTypeId": "1", "LastEditorUserId": "268093", "LastActivityDate": "2014-03-28T21:48:42.897", "Score": "0", "OwnerUserId": "2018010", "Tags": "<c++><exception><c++11><lambda>", "AnswerCount": "1"}, "22719985": {"Id": "22719985", "PostTypeId": "2", "Body": "<p>According to the standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\" title=\"C++ Standard Draft n3337\">draft n3337</a>), \u00a75.1.2/3:</p>\n<blockquote>\n<p id=\"so_22719066_22719985_0\">The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed nonunion\n  class type \u2014 called the closure type \u2014 whose properties are described below. This class type is not\n  an aggregate (8.5.1). The closure type is declared in the smallest block scope, class scope, or namespace\n  scope that contains the corresponding lambda-expression.</p>\n</blockquote>\n<p>In  a nutshell, a lambda expression ultimately instantiates an anonymous type (known only to the compiler), containing member variables that store the values indicated in the capture list. So imagine you saw a class that looked like this:</p>\n<pre><code>class __IgnoreMe__\n{\n    std::vector&lt;int&gt;&amp; _v;\n\npublic:\n    __IgnoreMe__(std::vector&lt;int&gt;&amp; v)\n        : _v(v)\n    {\n    }\n\n    void operator()()\n    {\n    }\n};\n</code></pre>\n<p>(<strong>Note:</strong> this isn't exactly how the class created by the compiler looks. The standard lays out specific requirements for generated classes, which I've left out for brevity's sake.)</p>\n<p>Now imagine you instantiate that class like this:</p>\n<pre><code>auto v = std::vector&lt;int&gt;(1000000);\nauto my_lambda = __IgnoreMe__(v);\n</code></pre>\n<p>Can the instantiation of <code>my_lambda</code> throw an exception? If so, then the construction of the closure object can throw an exception. (It can't, in this case.)</p>\n<p>As for providing nothrow guarantees, the standard doesn't <em>require</em> compilers to account for this, but it doesn't <em>prevent</em> them from doing it either. The end of \u00a75.1.2/3 states:</p>\n<blockquote>\n<p id=\"so_22719066_22719985_1\">An implementation may define the closure\n  type differently from what is described below provided this does not alter the observable behavior of the\n  program other than by changing:</p>\n<p id=\"so_22719066_22719985_2\">\u2014 the size and/or alignment of the closure type,</p>\n<p id=\"so_22719066_22719985_3\">\u2014 whether the closure type is trivially copyable (Clause 9),</p>\n<p id=\"so_22719066_22719985_4\">\u2014 whether the closure type is a standard-layout class (Clause 9), or</p>\n<p id=\"so_22719066_22719985_5\">\u2014 whether the closure type is a POD class (Clause 9).</p>\n</blockquote>\n", "LastEditorUserId": "926713", "LastActivityDate": "2014-03-28T21:48:42.897", "Score": "4", "CreationDate": "2014-03-28T17:56:38.327", "ParentId": "22719066", "CommentCount": "3", "OwnerUserId": "926713", "LastEditDate": "2014-03-28T21:48:42.897"}});