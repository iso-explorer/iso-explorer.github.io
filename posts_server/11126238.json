post_cb({"11126238": {"CommentCount": "10", "AcceptedAnswerId": "11127742", "PostTypeId": "1", "LastEditorUserId": "981959", "CreationDate": "2012-06-20T18:52:12.933", "LastActivityDate": "2012-10-21T16:59:18.840", "LastEditDate": "2012-06-20T21:54:36.347", "ViewCount": "2523", "FavoriteCount": "6", "Title": "Have the ideas behind the Fast Delegate (et al) been used to optimize std::function?", "Id": "11126238", "Score": "21", "Body": "<p>There have been proposals for C++ \"delegates\" which have lower overhead than <code>boost::function</code>:</p>\n<ul>\n<li><a href=\"http://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible\">Member Function Pointers and the Fastest Possible C++ Delegates</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/13287/Fast-C-Delegate\">Fast C++ Delegate</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates\">The Impossibly Fast C++ Delegates</a></li>\n</ul>\n<p>Have any of those ideas been used to implement <code>std::function</code>, resulting in better performance than <code>boost::function</code>? Has anyone compared the performance of <code>std::function</code> vs <code>boost::function</code>?</p>\n<p><strong>I want to know this specifically for the GCC compiler and libstdc++ on Intel 64-bit architectures</strong>, but information on other compilers is welcome (such as Clang).</p>\n", "Tags": "<c++><performance><boost><c++11><std-function>", "OwnerUserId": "245265", "AnswerCount": "2"}, "11127742": {"ParentId": "11126238", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>In libstdc++'s <code>std::function</code> we use a union type that is suitably sized and aligned to store pointers, function pointers or pointers to member functions. We avoid a heap allocation for any function object that can be stored in that size and alignment, <strong>but</strong> only if it is \"location invariant\" </p>\n<pre><code>/**\n *  Trait identifying \"location-invariant\" types, meaning that the\n *  address of the object (or any of its members) will not escape.\n *  Also implies a trivial copy constructor and assignment operator.\n */\n</code></pre>\n<p>The code is based on the <code>std::tr1::function</code> implementation and that part hasn't changed significantly. I think that could be simplified using <code>std::aligned_storage</code> and could be improved by specializing the trait so that more types are identified as location invariant.</p>\n<p>Invoking the target object is done without any virtual function calls, the type erasure is done by storing a single function pointer in the <code>std::function</code> which is the address of a function template specialization.  All operations are done by calling that function template through the stored pointer and passing in an enum identifying what operation it is being asked to perform.  This means no vtable and only a single function pointer needs to be stored in the object.</p>\n<p>This design was contributed by the original <code>boost::function</code> author and I believe it is close to the boost implementation. See the <a href=\"http://www.boost.org/doc/libs/1_49_0/doc/html/function/misc.html#id1550476\" rel=\"noreferrer\">Performance</a> docs for Boost.Function for some rationale.  That means it's pretty unlikely that GCC's <code>std::function</code> is any faster than <code>boost::function</code>, because it's a similar design by the same person.</p>\n<p>N.B. our <code>std::function</code> doesn't support construction with an allocator yet, any allocations it needs to do will be done using <code>new</code>.</p>\n<hr>\n<p>In response to Emile's comment expressing a desire to avoid a heap allocation for a <code>std::function</code> which holds a pointer to member function and an object, here's a little hack to do it (but you didn't hear it from me ;-)</p>\n<pre><code>struct A {\n  int i = 0;\n  int foo() const { return 0; }\n};\n\nstruct InvokeA\n{\n  int operator()() const { return a-&gt;foo(); }\n  A* a;\n};\n\nnamespace std\n{\n  template&lt;&gt; struct __is_location_invariant&lt;InvokeA&gt;\n  { static const bool value = true; };\n}\n\nint main()\n{\n  A a;\n  InvokeA inv{ &amp;a };\n\n  std::function&lt;int()&gt; f2(inv);\n\n  return f2();\n}\n</code></pre>\n<p>The trick is that <code>InvokeA</code> is small enough to fit in the <code>function</code>'s small object buffer, and the trait specialization says it's safe to store in there, so the <code>function</code> holds a copy of that object directly, not on the heap.  This requires <code>a</code> to persist as long as the pointer to it persists, but that would be the case anyway if the <code>function</code>'s target was <code>bind(&amp;A::foo, &amp;a)</code>.</p>\n</hr>", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2012-06-20T21:56:21.963", "Id": "11127742", "Score": "28", "CreationDate": "2012-06-20T20:34:32.587", "LastActivityDate": "2012-06-20T21:56:21.963"}, "bq_ids": {"n4140": {"so_11126238_13000025_0": {"section_id": 4657, "quality": 0.875, "length": 21}}, "n3337": {"so_11126238_13000025_0": {"section_id": 4468, "quality": 0.875, "length": 21}}, "n4659": {"so_11126238_13000025_0": {"section_id": 6026, "quality": 0.875, "length": 21}}}, "13000025": {"ParentId": "11126238", "CommentCount": "0", "Body": "<p>As noted in the comments, std::function is only an interface, and different implementations may do different things, but it's worth noting that the standard does actually have something to say about this matter.  From 20.8.11.2.1/5 (which looks more like an IP address than a part of the standard):</p>\n<blockquote>\n<p id=\"so_11126238_13000025_0\"><em>Note:</em> Implementations are encouraged to avoid the use of dynamically\n  allocated memory for small callable objects, for example, where f\u2019s\n  target is an object holding only a pointer or reference to an object\n  and a member function pointer. <em>\u2014end note</em></p>\n</blockquote>\n<p>This is the standard's way of encouraging implementers to employ the \"small function optimization,\" which was motivated by the cited articles on delegates.  (The articles themselves don't actually talk about delegates in the .NET sense. Rather, they use the term \"delegate\" to mean bound member functions.)</p>\n", "OwnerUserId": "1426649", "PostTypeId": "2", "Id": "13000025", "Score": "3", "CreationDate": "2012-10-21T16:59:18.840", "LastActivityDate": "2012-10-21T16:59:18.840"}});