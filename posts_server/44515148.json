post_cb({"44515148": {"CommentCount": "6", "ViewCount": "218", "CreationDate": "2017-06-13T07:40:06.147", "LastActivityDate": "2017-06-14T04:53:01.040", "Title": "Why is == operator overload of enum ambiguous in MSVC", "AcceptedAnswerId": "44515690", "PostTypeId": "1", "Id": "44515148", "Score": "7", "Body": "<p>The following code compiles fine on all compilers I've checked (clang, mingw, g++) other than MSVC.</p>\n<pre><code>enum class Foo{BAR};\n\nbool operator==(Foo a, Foo b)\n{\n    return (int)a &amp; (int)b;\n}\n\nint main(int argc, char *argv[])\n{\n    Foo::BAR==Foo::BAR;\n    return 0;\n}\n</code></pre>\n<p>MSVC fails with the following error:</p>\n<pre><code>&gt;main.cpp(10): error C2593: 'operator ==' is ambiguous\n&gt;main.cpp(3): note: could be 'bool operator ==(Foo,Foo)'\n&gt;main.cpp(10): note: while trying to match the argument list '(Foo, Foo)'\n</code></pre>\n<p>Any insight would be great, I've been scratching my head about this all day.</p>\n<p>My version of MSVC is 14.0 however I've tested it online with version Version 19.00.23506 and the same error appears.</p>\n<p>The error does not apear with version 19.11.25331.0 however. \nCompiler bug then?</p>\n", "Tags": "<c++><c++11><visual-c++><enums><operator-overloading>", "OwnerUserId": "8152893", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_44515148_44515690_0": {"section_id": 675, "quality": 0.9285714285714286, "length": 117}}, "n3337": {"so_44515148_44515690_0": {"section_id": 665, "quality": 0.9285714285714286, "length": 117}}, "n4659": {"so_44515148_44515690_0": {"section_id": 703, "quality": 0.9285714285714286, "length": 117}}}, "44515690": {"ParentId": "44515148", "LastEditDate": "2017-06-14T04:53:01.040", "CommentCount": "4", "CreationDate": "2017-06-13T08:05:56.570", "OwnerUserId": "817643", "LastEditorUserId": "817643", "PostTypeId": "2", "Id": "44515690", "Score": "7", "Body": "<p>For enumerations, there's a built-in comparison operator. When you define yours, the built-in is supposed to be hidden automatically.</p>\n<p><a href=\"http://eel.is/c++draft/over.built#1\" rel=\"nofollow noreferrer\">[over.built/1]</a></p>\n<blockquote>\n<p id=\"so_44515148_44515690_0\">The candidate operator functions that represent the built-in operators\n  defined in Clause [expr] are specified in this subclause. These\n  candidate functions participate in the operator overload resolution\n  process as described in [over.match.oper] and are used for no other\n  purpose. [\u2009Note: Because built-in operators take only operands with\n  non-class type, and operator overload resolution occurs only when an\n  operand expression originally has class or enumeration type, operator\n  overload resolution can resolve to a built-in operator only when an\n  operand has a class type that has a user-defined conversion to a\n  non-class type appropriate for the operator, or when an operand has an\n  enumeration type that can be converted to a type appropriate for the\n  operator. Also note that some of the candidate operator functions\n  given in this subclause are more permissive than the built-in\n  operators themselves. As described in [over.match.oper], after a\n  built-in operator is selected by overload resolution the expression is\n  subject to the requirements for the built-in operator given in Clause\n  [expr], and therefore to any additional semantic constraints given\n  there. <strong>If there is a user-written candidate with the same name and\n  parameter types as a built-in candidate operator function, the\n  built-in operator function is hidden and is not included in the set of\n  candidate functions.</strong> \u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>To answer your question, yes, it seems like a compiler bug.</p>\n", "LastActivityDate": "2017-06-14T04:53:01.040"}});