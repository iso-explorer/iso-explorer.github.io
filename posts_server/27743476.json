post_cb({"27743476": {"CommentCount": "2", "AcceptedAnswerId": "27748693", "PostTypeId": "1", "LastEditorUserId": "4405663", "CreationDate": "2015-01-02T14:09:45.653", "LastActivityDate": "2015-01-02T21:20:18.723", "LastEditDate": "2015-01-02T14:17:13.723", "ViewCount": "376", "FavoriteCount": "0", "Title": "How to properly use the custom shared_ptr deleter?", "Id": "27743476", "Score": "3", "Body": "<p>I'm still a little confused about the proper way to use a custom deleter with shared_ptr. I have a ResourceManager class which keeps track of resource allocations, and I modified its interface to support automatic release of used resources by making the Release method private, and Allocate method  returning a ResourceHolder:</p>\n<pre><code>// ResourceManager.cpp:\npublic:\n    ResourceHolder&lt;Resource&gt; Allocate(args);\n\nprivate:\n    void Release(Resource*);\n</code></pre>\n<p>And the ResourceHolder class I implement like this:</p>\n<pre><code>// ResourceHolder.h\ntemplate &lt;typename T&gt;\nclass ResourceHolder\n{\npublic:\n    ResourceHolder(\n        _In_ T* resource,\n        _In_ const std::function&lt;void(T*)&gt;&amp; cleanupFunction)\n        : _cleanupFunction(cleanupFunction)\n        , _resource(resource, [&amp;](T* resource)\n        { \n            cleanup(resource); \n        }) // Uses a custom deleter to release the resource.\n    {\n    }\n\nprivate:\n    std::function&lt;void(T*)&gt; _cleanupFunction;\n    std::shared_ptr&lt;T&gt; _resource;\n};\n\n// ResourceManager::Allocate()\n...\nreturn ResourceHolder&lt;Resource&gt;(new Resource(),[this](Resource* r) { Release(r); });\n</code></pre>\n<ol>\n<li><p>In my cleanup method, do I have to delete T? Is it always safe to do it?</p>\n<pre><code>if (nullptr != T) delete T;\n</code></pre></li>\n<li><p>What happens if cleanup() can throw an exception? Can I let it escape the scope under some circumstances, or should I always prevent it?</p></li>\n<li><p>My ResourceManager does not have a dependency on a tracing library I'm using, so I opted for a callback which a caller can provide through its constructor, and which will get called in the release method. So my Release looks something like this:</p>\n<pre><code>void Release(Resource* r)\n{\n    shared_ptr&lt;std::Exception&gt; exc = nullptr;\n    try\n    {\n        // Do cleanup.\n    }\n    catch(Exception* ex)\n    {\n        exc.reset(ex);\n    }\n\n    if (nullptr != r) delete r;\n\n    // Is it now safe to throw?\n    if (nullptr != m_callback)\n        m_callback(args, exc);\n}\n\nvoid Callback(args, shared_ptr&lt;std::Exception&gt; ex)\n{\n    // Emit telemetry, including exception information.\n\n    // If throwing here is ok, what is the correct way to throw exception here?\n    if (nullptr != ex)\n    {\n        throw ex;\n    }\n}\n</code></pre></li>\n</ol>\n<p>Is this a sound design approach? </p>\n", "Tags": "<c++><shared-ptr><resource-management>", "OwnerUserId": "4405663", "AnswerCount": "1"}, "27748693": {"ParentId": "27743476", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_27743476_27748693_0\">In my cleanup method, do I have to delete T? Is it always safe to do it?</p>\n</blockquote>\n<p><em>If</em> the pointer references an object instantiated with <code>new</code> then you need to call <code>delete</code> otherwise you end up with a memory leak and undefined behavior.</p>\n<blockquote>\n<p id=\"so_27743476_27748693_1\">What happens if cleanup() can throw an exception? Can I let it escape the scope under some circumstances, or should I always prevent it?</p>\n</blockquote>\n<p>It shouldn't and you should make every effort to ensure that it doesn't. However if the cleanup code <em>does</em> throw an exception you should catch it, handle it appropriately, and <em>eat</em> it. The reason is the custom deleter can be invoked while in the context of a destructor and there is always the possibility the destructor is being invoked while an exception is already being propagated. If an exception is already in progress and another uncaught exception is thrown the application will terminate. In other words treat the custom deleter and cleanup code as if it were a destructor and follow the same rules and guidelines regarding exception handling.</p>\n<p><a href=\"http://rads.stackoverflow.com/amzn/click/0201924889\" rel=\"nofollow\">Effective C++</a> Item #8 - Prevent exceptions from leaving destructors</p>\n<blockquote>\n<p id=\"so_27743476_27748693_2\">Destructors should never emit exceptions. If functions called in a destructor may throw, the\n  destructor should catch any exceptions, then swallow them or terminate the program.</p>\n</blockquote>\n<p><strong>\u00a7 15.1/7 C++ Standard [except.throw]</strong></p>\n<blockquote>\n<p id=\"so_27743476_27748693_3\">If the exception handling mechanism, after completing evaluation of the expression to be thrown but before the exception is caught, calls a function that exits via an exception, <code>std::terminate</code> is called.</p>\n</blockquote>\n<p>-</p>\n<blockquote>\n<p id=\"so_27743476_27748693_4\">Is this a sound design approach?</p>\n</blockquote>\n<p>With the exception of how you currently intend on handling exceptions, I see nothing wrong with it. The only real changes you need to make is how you are invoking the callback and how the callback handles the exception passed to it. The resulting code after the changes might look something like below.</p>\n<pre><code>void Release(Resource* r)\n{\n    try\n    {\n        // Do cleanup.\n    }\n    catch (Exception&amp; ex)\n    {\n        // Report to callback\n        if (nullptr != m_callback)\n            m_callback(args, &amp;ex);\n\n        // Handle exception completely or terminate\n\n        // Done\n        return;\n    }\n\n    // No exceptions, call with nullptr\n    if (nullptr != m_callback)\n        m_callback(args, nullptr);\n}\n\nvoid Callback(args, const Exception* ex)\n{\n    // Emit telemetry, including exception information.\n\n    //  DO NOT RETHROW ex\n}\n</code></pre>\n", "OwnerUserId": "845568", "PostTypeId": "2", "Id": "27748693", "Score": "1", "CreationDate": "2015-01-02T21:20:18.723", "LastActivityDate": "2015-01-02T21:20:18.723"}, "bq_ids": {"n4140": {"so_27743476_27748693_3": {"section_id": 3340, "quality": 0.7894736842105263, "length": 15}}, "n3337": {"so_27743476_27748693_3": {"section_id": 3210, "quality": 1.0, "length": 19}}, "n4659": {"so_27743476_27748693_3": {"section_id": 4142, "quality": 0.7368421052631579, "length": 14}}}});