post_cb({"5695585": {"ParentId": "5695548", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>That code is equivalent (in <em>almost</em> every way) to:</p>\n<pre><code>class dumb_array\n{\npublic:\n    // ...\n    friend void swap(dumb_array&amp; first, dumb_array&amp; second);\n    // ...\n};\n\ninline void swap(dumb_array&amp; first, dumb_array&amp; second) // nothrow\n{\n    using std::swap; \n    swap(first.mSize, second.mSize); \n    swap(first.mArray, second.mArray);\n}\n</code></pre>\n<p>A friend function defined inside a class is:</p>\n<ul>\n<li>placed in the enclosing namespace</li>\n<li>automatically <code>inline</code></li>\n<li>able to refer to static members of the class without further qualification</li>\n</ul>\n<p>The exact rules are in section <code>[class.friend]</code> (I quote paragraphs 6 and 7 of the C++0x draft):</p>\n<blockquote>\n<p id=\"so_5695548_5695585_0\">A function can be defined in a friend declaration of a class if and only if the class is a non-local class (9.8), the function name is unqualified, and the function has namespace scope.</p>\n<p id=\"so_5695548_5695585_1\">Such a function is implicitly inline.  A friend function defined in a class is in the (lexical) scope of the class in which it is defined. A friend function defined outside the class is not.</p>\n</blockquote>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2011-04-17T19:14:39.750", "Id": "5695585", "Score": "4", "CreationDate": "2011-04-17T18:41:20.073", "LastActivityDate": "2011-04-17T19:14:39.750"}, "5695548": {"CommentCount": "2", "AcceptedAnswerId": "5695855", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-04-17T18:35:02.867", "LastActivityDate": "2017-08-15T10:50:02.930", "LastEditDate": "2017-05-23T12:34:45.403", "ViewCount": "14175", "FavoriteCount": "53", "Title": "public friend swap member function", "Id": "5695548", "Score": "98", "Body": "<p>In the beautiful answer to the <a href=\"https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom#3279550\">copy-and-swap-idiom</a> there is a piece of code I need a bit of help:</p>\n<pre><code>class dumb_array\n{\npublic:\n    // ...\n    friend void swap(dumb_array&amp; first, dumb_array&amp; second) // nothrow\n    {\n        using std::swap; \n        swap(first.mSize, second.mSize); \n        swap(first.mArray, second.mArray);\n    }\n    // ...\n};\n</code></pre>\n<p>and he adds a note</p>\n<blockquote>\n<p id=\"so_5695548_5695548_0\">There are other claims that we should specialize std::swap for our type, provide an in-class swap along-side a free-function swap, etc. But this is all unnecessary: any proper use of swap will be through an unqualified call, and our function will be found through ADL. One function will do.</p>\n</blockquote>\n<p>With <code>friend</code> I am a bit on \"unfriendly\" terms, I must admit. So, my main questions are:</p>\n<ul>\n<li><strong>looks like a free function</strong>, but its inside the class body?</li>\n<li><strong>why isn't this <code>swap</code> static</strong>? It obviously doesn't use any member variables.</li>\n<li><strong>\"Any proper use of swap will find out swap via ADL\"</strong>? ADL will search the namespaces, right? But does it also look inside classes? Or is here where <code>friend</code> comes in?</li>\n</ul>\n<p>Side-questions:</p>\n<ul>\n<li>With C++11, should I mark my <code>swap</code>s with <strong><code>noexcept</code></strong>?</li>\n<li>With C++11 and its <strong>range-for</strong>, should I place <code>friend iter begin()</code> and <code>friend iter end()</code> the same way inside the class? I think the <code>friend</code> is not needed here, right?</li>\n</ul>\n", "Tags": "<c++><c++11><friend><copy-and-swap>", "OwnerUserId": "472245", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_5695548_5695585_1": {"section_id": 6690, "quality": 1.0, "length": 17}, "so_5695548_5695585_0": {"section_id": 6689, "quality": 1.0, "length": 15}}, "n3337": {"so_5695548_5695585_1": {"section_id": 6445, "quality": 1.0, "length": 17}, "so_5695548_5695585_0": {"section_id": 6444, "quality": 1.0, "length": 15}}, "n4659": {"so_5695548_5695585_1": {"section_id": 8165, "quality": 1.0, "length": 17}, "so_5695548_5695585_0": {"section_id": 8164, "quality": 1.0, "length": 15}}}, "5695855": {"ParentId": "5695548", "PostTypeId": "2", "CommentCount": "24", "Body": "<p>There are several ways to write <code>swap</code>, some better than others. Over time, though, it was found a single definition works best. Let's consider how we might think about writing a <code>swap</code> function.</p>\n<hr>\n<p>We first see that containers like <code>std::vector&lt;&gt;</code> have a single-argument member function <code>swap</code>, such as:</p>\n<pre><code>struct vector\n{\n    void swap(vector&amp;) { /* swap members */ }\n};\n</code></pre>\n<p>Naturally, then, our class should too, right? Well, not really. The standard library has <a href=\"http://www.gotw.ca/gotw/084.htm\" rel=\"noreferrer\">all sorts of unnecessary things</a>, and a member <code>swap</code> is one of them. Why? Let's go on.</p>\n<hr>\n<p>What we should do is identify what's canonical, and what our class <em>needs</em> to do to work with it. And the canonical method of swapping is with <code>std::swap</code>. This is why member functions aren't useful: they aren't how we should swap things, in general, and have no bearing on the behavior of <code>std::swap</code>.</p>\n<p>Well then, to make <code>std::swap</code> work we should provide (and <code>std::vector&lt;&gt;</code> should have provided) a specialization of <code>std::swap</code>, right?</p>\n<pre><code>namespace std\n{\n    template &lt;&gt; // important! specialization in std is OK, overloading is UB\n    void swap(myclass&amp;, myclass&amp;)\n    {\n        // swap\n    }\n}\n</code></pre>\n<p>Well that would certainly work in this case, but it has a glaring problem: function specializations cannot be partial. That is, we cannot specialize template classes with this, only particular instantiations:</p>\n<pre><code>namespace std\n{\n    template &lt;typename T&gt;\n    void swap&lt;T&gt;(myclass&lt;T&gt;&amp;, myclass&lt;T&gt;&amp;) // error! no partial specialization\n    {\n        // swap\n    }\n}\n</code></pre>\n<p>This method works some of the time, but not all of the time. There must be a better way.</p>\n<hr>\n<p>There is! We can use a <code>friend</code> function, and find it through ADL:</p>\n<pre><code>namespace xyz\n{\n    struct myclass\n    {\n        friend void swap(myclass&amp;, myclass&amp;);\n    };\n}\n</code></pre>\n<p>When we want to swap something, we associate<sup>\u2020</sup> <code>std::swap</code> and then make an unqualified call:</p>\n<pre><code>using std::swap; // allow use of std::swap...\nswap(x, y); // ...but select overloads, first\n\n// that is, if swap(x, y) finds a better match, via ADL, it\n// will use that instead; otherwise it falls back to std::swap\n</code></pre>\n<p>What is a <code>friend</code> function? There is confusion around this area.</p>\n<p>Before C++ was standardized, <code>friend</code> functions did something called \"friend name injection\", where the code behaved <em>as if</em> if the function had been written in the surrounding namespace. For example, these were equivalent pre-standard:</p>\n<pre><code>struct foo\n{\n    friend void bar()\n    {\n        // baz\n    }\n};\n\n// turned into, pre-standard:    \n\nstruct foo\n{\n    friend void bar();\n};\n\nvoid bar()\n{\n    // baz\n}\n</code></pre>\n<p>However, when ADL was invented this was removed. The <code>friend</code> function could then <em>only</em> be found via ADL; if you wanted it as a free function, it needed to be declared as so (<a href=\"https://stackoverflow.com/questions/4027604/c-c-automatically-cast-void-pointer-into-type-pointer-in-c-in-define-in-cas/4027734#4027734\">see this</a>, for example). But lo! There was a problem.</p>\n<p>If you just use <code>std::swap(x, y)</code>, your overload will <em>never</em> be found, because you've explicitly said \"look in <code>std</code>, and nowhere else\"! This is why some people suggested writing two functions: one as a function to be found via ADL, and the other to handle explicit <code>std::</code> qualifications.</p>\n<p>But like we saw, this can't work in all cases, and we end up with an ugly mess. Instead, idiomatic swapping went the other route: instead of making it the classes' job to provide <code>std::swap</code>, it's the swappers' job to make sure they don't use qualified <code>swap</code>, like above. And this tends to work pretty well, as long as people know about it. But therein lies the problem: it's unintuitive to need to use an unqualified call!</p>\n<p>To make this easier, some libraries like Boost provided the function <code>boost::swap</code>, which just does an unqualified call to <code>swap</code>, with <code>std::swap</code> as an associated namespace. This helps make things succinct again, but it's still a bummer.</p>\n<p>Note that there is no change in C++11 to the behavior of <code>std::swap</code>, which I and others mistakenly thought would be the case. If you were bit by this, <a href=\"https://stackoverflow.com/q/9170247/87234\">read here</a>.</p>\n<hr>\n<p>In short: the member function is just noise, the specialization is ugly and incomplete, but the <code>friend</code> function is complete and works. And when you swap, either use <code>boost::swap</code> or an unqualified <code>swap</code> with <code>std::swap</code> associated.</p>\n<hr>\n<p>\u2020Informally, a name is <em>associated</em> if it will be considered during a function call. For the details, read \u00a73.4.2. In this case, <code>std::swap</code> normally isn't considered; but we can <em>associate</em> it (add it to the set of overloads considered by unqualified <code>swap</code>), allowing it to be found.</p>\n</hr></hr></hr></hr></hr>", "OwnerUserId": "87234", "LastEditorUserId": "404861", "LastEditDate": "2017-08-15T10:50:02.930", "Id": "5695855", "Score": "110", "CreationDate": "2011-04-17T19:24:24.227", "LastActivityDate": "2017-08-15T10:50:02.930"}});