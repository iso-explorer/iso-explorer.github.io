post_cb({"11119641": {"ParentId": "11119588", "CommentCount": "0", "Body": "<p>You should not delete the data receieved from <code>c_str()</code>. It points to internal location of the string and it's up to string to delete it</p>\n", "OwnerUserId": "444088", "PostTypeId": "2", "Id": "11119641", "Score": "1", "CreationDate": "2012-06-20T12:33:03.507", "LastActivityDate": "2012-06-20T12:33:03.507"}, "11119665": {"ParentId": "11119588", "CommentCount": "0", "Body": "<p>You're not supposed to delete the pointer returned via <code>std::string::c_str()</code>. A good rule of thumb to remember is this: If you did not allocate memory for a pointer, you shouldn't be deallocating it. See the standard:</p>\n<blockquote>\n<p id=\"so_11119588_11119665_0\"><strong>21.4.7.1 basic_string accessors</strong></p>\n</blockquote>\n<pre><code> const charT* c_str() const noexcept;\n const charT* data() const noexcept;\n</code></pre>\n<blockquote>\n<p id=\"so_11119588_11119665_1\">1 <em>Returns</em>: A pointer p such that p + i == &amp;operator for each i in [0,size()].</p>\n<p id=\"so_11119588_11119665_2\">2 <em>Complexity</em>: constant time.</p>\n<p id=\"so_11119588_11119665_3\">3 <em>Requires</em>: The program shall not alter any of the values stored in the character array.</p>\n</blockquote>\n", "OwnerUserId": "66692", "PostTypeId": "2", "Id": "11119665", "Score": "1", "CreationDate": "2012-06-20T12:34:33.520", "LastActivityDate": "2012-06-20T12:34:33.520"}, "11119634": {"ParentId": "11119588", "CommentCount": "0", "Body": "<p>The memory returned by <code>std::string::c_str</code> continues to be owned by the string, so it shouldn't be <code>delete</code>d.</p>\n<p>You should only call <code>delete</code> on memory that you have <code>new</code>ed, and you shouldn't use <code>new</code>.</p>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "11119634", "Score": "2", "CreationDate": "2012-06-20T12:32:37.907", "LastActivityDate": "2012-06-20T12:32:37.907"}, "11119667": {"ParentId": "11119588", "CommentCount": "0", "Body": "<p>Couple of quick notes:</p>\n<p>In your first example, you are deleting memory that you have not allocated. The contents of <code>aesKey</code> belong to the string <code>key</code> and you shoudl not delete them... if nothing else, when <code>key</code> is destroyed when it goes out of scope, it will attempt to delete the same block of memory and you'll get a nasty double delete bug.</p>\n<p>In your second example, you are creating a <code>char</code> but assigning to an <code>unsigned char</code>. This is not a good idea, especially when you come to manipulating more complex datatypes.</p>\n", "OwnerUserId": "1450890", "PostTypeId": "2", "Id": "11119667", "Score": "0", "CreationDate": "2012-06-20T12:34:39.127", "LastActivityDate": "2012-06-20T12:34:39.127"}, "11119588": {"CommentCount": "0", "ViewCount": "319", "PostTypeId": "1", "LastEditorUserId": "4370109", "CreationDate": "2012-06-20T12:29:46.473", "LastActivityDate": "2015-08-22T14:27:07.403", "Title": "Error when deleting a pointer", "AcceptedAnswerId": "11119636", "LastEditDate": "2015-08-22T14:27:07.403", "Id": "11119588", "Score": "2", "Body": "<p>I'm beginning and there is something that I don't understand with pointers.\nI have the following code returning an error I don't know why:</p>\n<pre><code>std::string key = \"myKey\";    \nconst unsigned char* aesKey = reinterpret_cast&lt;const unsigned char *&gt; (key.c_str());\n\n// Executing some stuffs\n\ndelete aesKey;\n</code></pre>\n<p>the first time the code executes everything works fine, but the second time i get an error which I don't get if I don't have the <code>delete</code> line (Instead I have a memory leak, quite worst).</p>\n<p>Someone could explain me why this is not working?</p>\n<p>The sample below is working fine in the same context (same method, ...)</p>\n<pre><code>unsigned char* test = new char;\n//doing some stuff\ndelete test;\n</code></pre>\n", "Tags": "<c++><pointers><delete-operator>", "OwnerUserId": "1280608", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_11119588_11119665_3": {"section_id": 1763, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_11119588_11119665_3": {"section_id": 1757, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_11119588_11119665_3": {"section_id": 1929, "quality": 0.7142857142857143, "length": 5}, "so_11119588_11119665_1": {"section_id": 823, "quality": 0.6666666666666666, "length": 4}}}, "11119636": {"ParentId": "11119588", "CommentCount": "2", "Body": "<p><strong>First:</strong> you don't own that C string, so it's not yours to <code>delete[]</code>. The <code>std::string</code> still owns it and will <code>delete[]</code> it later.</p>\n<p><strong>Second:</strong> arrays are deleted with <code>delete[]</code>, not <code>delete</code>. So you're using the wrong operator anyway.</p>\n", "OwnerUserId": "265530", "PostTypeId": "2", "Id": "11119636", "Score": "7", "CreationDate": "2012-06-20T12:32:46.363", "LastActivityDate": "2012-06-20T12:32:46.363"}});