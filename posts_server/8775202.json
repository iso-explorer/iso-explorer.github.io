post_cb({"8775241": {"ParentId": "8775202", "CommentCount": "0", "Body": "<p>Imagine this:</p>\n<pre><code>template &lt;typename T&gt; struct Foo { typedef   T type; }\ntemplate &lt;&gt; struct Foo&lt;char&gt;     { typedef int type; }\n\ntemplate &lt;typename T&gt; using mytype = typename Foo&lt;T&gt;::type;\n\ntemplate &lt;typename T&gt; void f(mytype&lt;T&gt;);\n</code></pre>\n<p>Now if I want <code>int n; f(n);</code>, how could I decide whether I want <code>T = int</code> or <code>T = char</code>? The whole problem, which is unaffected by template aliases, is that you cannot deduce <em>backwards</em> to all the things that could possibly define something.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "8775241", "Score": "1", "CreationDate": "2012-01-08T03:48:52.927", "LastActivityDate": "2012-01-08T03:48:52.927"}, "8775202": {"CommentCount": "6", "ViewCount": "947", "CreationDate": "2012-01-08T03:39:46.923", "LastActivityDate": "2012-01-08T10:49:55.040", "Title": "How do template aliases affect template parameter deduction?", "AcceptedAnswerId": "8776902", "PostTypeId": "1", "Id": "8775202", "Score": "11", "Body": "<p>In C++03, template parameter deduction does not occur in some contexts. For example:</p>\n<pre><code>template &lt;typename T&gt; struct B {};\n\ntemplate &lt;typename T&gt;\nstruct A\n{\n    typedef B&lt;T&gt; type;\n};\n\ntemplate &lt;typename T&gt;\nvoid f(typename A&lt;T&gt;::type);\n\nint main()\n{\n    B&lt;int&gt; b;\n    f(b);  // ERROR: no match\n}\n</code></pre>\n<p>Here, <code>int</code> is not deduced for <code>T</code>, because a nested type such as <code>A&lt;T&gt;::type</code> is a non-deduced context.</p>\n<p>Had I written the function like this:</p>\n<pre><code>template &lt;typename T&gt; struct B {};\n\ntemplate &lt;typename T&gt;\nvoid f(B&lt;T&gt;);\n\nint main()\n{\n    B&lt;int&gt; b;\n    f(b);\n}\n</code></pre>\n<p>everything is fine because <code>B&lt;T&gt;</code> <strong>is</strong> a deduced context.</p>\n<p>In C++11, however, template aliases can be used to disguise a nested type in syntax similar to the second example. For example:</p>\n<pre><code>template &lt;typename T&gt; struct B {};\n\ntemplate &lt;typename T&gt;\nstruct A\n{\n    typedef B&lt;T&gt; type;\n};\n\ntemplate &lt;typename T&gt;\nusing C = typename A&lt;T&gt;::type;\n\ntemplate &lt;typename T&gt;\nvoid f(C&lt;T&gt;);\n\nint main()\n{\n    B&lt;int&gt; b;\n    f(b);\n}\n</code></pre>\n<p>Would template argument deduction work in this case? In other words, are template aliases a deduced context or a non-deduced context? Or do they inherit the deduced/non-deduced status of whatever they alias?</p>\n", "Tags": "<c++><templates><c++11><template-aliases>", "OwnerUserId": "141719", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_8775202_8775296_0": {"section_id": 166, "quality": 0.88, "length": 22}}, "n3337": {"so_8775202_8775296_0": {"section_id": 160, "quality": 0.88, "length": 22}}, "n4659": {"so_8775202_8776902_0": {"section_id": 309, "quality": 0.625, "length": 5}, "so_8775202_8775296_0": {"section_id": 170, "quality": 0.88, "length": 22}}}, "8776902": {"ParentId": "8775202", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_8775202_8776902_0\">In other words, are template aliases a deduced context or a non-deduced context? </p>\n</blockquote>\n<p>They are as deducible as the equivalent code without using template aliases. For example</p>\n<pre><code>template&lt;typename T&gt;\nusing ref = T&amp;;\n\ntemplate&lt;typename T&gt;\nvoid f(ref&lt;T&gt; r);\n</code></pre>\n<p>Now you can call <code>f(x)</code> and <code>T</code> will be deduced perfectly fine. At the definition time of <code>f</code> already, <code>ref&lt;T&gt;</code> is replaced by type <code>T&amp;</code>. And <code>T&amp;</code> is a deduced context. </p>\n<p>In your case <code>C&lt;T&gt;</code> is replaced by <code>typename A&lt;T&gt;::type</code>, and that is a non-deduced context for <code>T</code>, so <code>T</code> cannot be deduced.</p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "8776902", "Score": "8", "CreationDate": "2012-01-08T10:49:55.040", "LastActivityDate": "2012-01-08T10:49:55.040"}, "8775296": {"ParentId": "8775202", "CommentCount": "4", "Body": "<p>I think the relevant quote in the C++ standard is 14.5.7 [temp.alias] paragraph 2:</p>\n<blockquote>\n<p id=\"so_8775202_8775296_0\">When a template-id refers to the specialization of an alias template, it is equivalent to the associated type obtained by substitution of its template-arguments for the template-parameters in the type-id of the alias template. [ Note: An alias template name is never deduced. \u2014 end note ]</p>\n</blockquote>\n<p>There is an example following the quote which effectively spells out that it is pointless to use an alias template in a function template and hoping to deduce the template argument. This apparently applies even for situation which don't involve nested types.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "8775296", "Score": "1", "CreationDate": "2012-01-08T04:04:18.600", "LastActivityDate": "2012-01-08T04:04:18.600"}});