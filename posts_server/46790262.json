post_cb({"bq_ids": {"n4140": {"so_46790262_46790262_0": {"section_id": 3919, "quality": 1.0, "length": 13}}, "n3337": {"so_46790262_46790262_0": {"section_id": 3779, "quality": 1.0, "length": 13}}, "n4659": {"so_46790262_46790262_0": {"section_id": 4805, "quality": 1.0, "length": 13}}}, "46790818": {"ParentId": "46790262", "CommentCount": "1", "Body": "<p>Pretend for a moment that you have two different functions:</p>\n<pre><code>static size_t get_int() {\n    static size_t index = NextIndex();\n    return index;\n}\nstatic size_t get_long() {\n    static size_t index = NextIndex();\n    return index;\n}\n</code></pre>\n<p>Is there any doubt in your mind that calling these two functions from separate threads is <strong>not</strong> thread-safe? Clearly there\u2019s a data race in the calls to <code>NextIndex</code>.</p>\n<p>Creating those functions by instantiating a template function doesn\u2019t get rid of the data race. Templates <strong>are not code</strong>; they are <strong>patterns</strong> for <strong>creating</strong> code. Calling two different instantiations of your template function (for example, <code>Get&lt;int&gt;()</code> and <code>Get&lt;long&gt;()</code>) from two different threads produces a data race.</p>\n", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "46790818", "Score": "17", "CreationDate": "2017-10-17T13:01:51.750", "LastActivityDate": "2017-10-17T13:01:51.750"}, "46790262": {"CommentCount": "13", "ViewCount": "824", "PostTypeId": "1", "LastEditorUserId": "4720935", "CreationDate": "2017-10-17T12:35:29.703", "LastActivityDate": "2017-10-24T14:56:01.687", "Title": "Thread safety of static variable initialization", "LastEditDate": "2017-10-24T14:56:01.687", "Id": "46790262", "Score": "13", "Body": "<p>I want to find out whether 2 calls to <code>Get()</code> with different parameter types in the code below are thread-safe:</p>\n<pre><code>struct MethodTypeIndex\n{\n    template &lt;typename T&gt;\n    static size_t Get(T)\n    {\n        static size_t index = NextIndex();\n        return index;\n    }\nprivate:\n    static size_t NextIndex()\n    {\n        static size_t nextIndex = 0;\n        return nextIndex++;\n    }\n};\n</code></pre>\n<p>On the one hand, <code>NextIndex()</code> is called during the initialization of <code>index</code> and according to standard:</p>\n<pre><code>\u00a76.7 [stmt.dcl] p4\n</code></pre>\n<blockquote>\n<p id=\"so_46790262_46790262_0\">If control enters the declaration concurrently while the variable is\n  being initialized, the concurrent execution shall wait for completion\n  of the initialization.</p>\n</blockquote>\n<p>On the other hand, I don't know if call to <code>NextIndex()</code> is considered as part of initialization of <code>index</code>. And if not, does brace-initialization make difference?</p>\n<pre><code>static size_t index{ NextIndex() };\n</code></pre>\n<p>Or is there any other ways to make it thread safe, if I don't want to make  <code>nextIndex</code> atomic?</p>\n", "Tags": "<c++><multithreading><c++11>", "OwnerUserId": "2198121", "AnswerCount": "1"}});