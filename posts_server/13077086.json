post_cb({"13077086": {"CommentCount": "0", "AcceptedAnswerId": "13077395", "CreationDate": "2012-10-25T20:53:04.063", "LastActivityDate": "2012-10-25T21:35:31.780", "PostTypeId": "1", "ViewCount": "911", "FavoriteCount": "1", "Title": "Small Buffer Optimization and alignment", "Id": "13077086", "Score": "9", "Body": "<p>I am writing a <em>C++</em> wrapper around a legacy API. This API provides me with a pointer value to keep extra data, and I want to implement the <em>Small Buffer Optimization</em> with it.</p>\n<p>I have implemented an <code>is_small_pod</code> <em>metafunction</em> that checks whether a given type is <em>POD</em> and it fits within a <code>void*</code>:</p>\n<pre><code>template&lt; typename Type &gt;\nstruct is_small_pod\n  : std::integral_constant&lt;\n        bool\n      , std::is_pod&lt; Type &gt;::type::value\n        &amp;&amp; sizeof( Type ) &lt;= sizeof( void* )\n    &gt;\n{};\n</code></pre>\n<p>and I'm setting the value like this:</p>\n<pre><code>// void*&amp; param;\nif( detail::is_small_pod&lt; Type &gt;() )\n{\n    *static_cast&lt; Type* &gt;( &amp;param ) = value;\n} else {\n    param = new Type( value );\n}\n</code></pre>\n<p>Am I implementing this optimization correctly? I believe this will fail when the value alignment is not compatible with the <em>alignment</em> of a pointer (odd corner case as it may be). Is that situation even possible, or am I just overthinking it? How should I extend my <em>metafunction</em> to check for compatible <em>alignment</em> as well?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "927034", "AnswerCount": "2"}, "13077395": {"ParentId": "13077086", "CommentCount": "2", "Body": "<p>It is not possible for the alignment of a type to be greater than the size of that type.</p>\n<blockquote>\n<h3>3.11 Alignment [basic.align]</h3>\n<p id=\"so_13077086_13077395_0\">[...] An <em>alignment</em> is an implementation-de\ufb01ned integer value representing the number of bytes between successive addresses at which a given object can be allocated.</p>\n<h3>5.3.3 Sizeof [expr.sizeof]</h3>\n<p id=\"so_13077086_13077395_1\">2 - [...] the size of an array of <em>n</em> elements is <em>n</em> times the size of an element.</p>\n</blockquote>\n<p>So, your code can only break if <code>alignof(void *) &lt; sizeof(void *)</code>, which is not the case on most platforms.</p>\n<p>For safety, you can write:</p>\n<pre><code>template&lt; typename Type &gt;\nstruct is_small_pod\n  : std::integral_constant&lt;\n        bool\n      , std::is_pod&lt; Type &gt;::type::value\n        &amp;&amp; sizeof( Type ) &lt;= sizeof( void* )\n        &amp;&amp; alignof( Type ) &lt;= alignof( void* )\n    &gt;\n{};\n</code></pre>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "13077395", "Score": "7", "CreationDate": "2012-10-25T21:14:46.190", "LastActivityDate": "2012-10-25T21:14:46.190"}, "13077432": {"ParentId": "13077086", "CommentCount": "0", "Body": "<p>Just as a general approach, you can always try testing your theories.  I imagine you would do something like this:</p>\n<pre><code>template&lt; class Type &gt;\nbool TestAlignmentSanity( Type value )\n{\n    // This function is only valid for small POD types\n    if( !detail::is_small_pod&lt; Type &gt;() )\n        return false;\n\n    // Temporary space covering alignments spanning the size of a void*\n    const int nBytes = sizeof(void*);\n    char buffer[sizeof(Type) + nBytes - 1];\n\n    // For each target alignment, test that a copy is successful.\n    for( int i = 0; i &lt; nBytes; i++ )\n    {\n       Type * target = static_cast&lt; Type* &gt;( &amp;buffer[i] );\n\n       // Sanity-check that the pointer was actually aligned as we requested\n       if( (char*)target != &amp;buffer[i] ) return false;\n\n       // Copy and test that the result is as expected.  Assumes '==' operator\n       // is defined...  Otherwise, implement with byte comparisons.\n       *target = value;\n       if( !(*target == value) ) return false;\n    }\n\n    return true;\n}\n</code></pre>\n<p>Here I tested that the data type can be copied into any alignment that spans the size of a <code>void*</code>.  It's just a thought. =)</p>\n", "OwnerUserId": "1553090", "PostTypeId": "2", "Id": "13077432", "Score": "0", "CreationDate": "2012-10-25T21:17:58.033", "LastActivityDate": "2012-10-25T21:17:58.033"}, "bq_ids": {"n4140": {"so_13077086_13077395_0": {"section_id": 7240, "quality": 0.8571428571428571, "length": 12}, "so_13077086_13077395_1": {"section_id": 6077, "quality": 1.0, "length": 6}}, "n3337": {"so_13077086_13077395_0": {"section_id": 6984, "quality": 0.8571428571428571, "length": 12}, "so_13077086_13077395_1": {"section_id": 5845, "quality": 1.0, "length": 6}}, "n4659": {"so_13077086_13077395_0": {"section_id": 8749, "quality": 0.8571428571428571, "length": 12}, "so_13077086_13077395_1": {"section_id": 7573, "quality": 1.0, "length": 6}}}});