post_cb({"31903037": {"CommentCount": "1", "AcceptedAnswerId": "31903140", "PostTypeId": "1", "LastEditorUserId": "1950231", "CreationDate": "2015-08-09T10:03:53.840", "LastActivityDate": "2015-08-10T00:12:08.633", "LastEditDate": "2015-08-10T00:12:08.633", "ViewCount": "901", "FavoriteCount": "1", "Title": "Mutating an int inside a constexpr function", "Id": "31903037", "Score": "23", "Body": "<p>Why can I do this:</p>\n<pre><code>constexpr auto i_can() {\n   int a = 8;\n   a = 9;\n   //...\n}\n</code></pre>\n<p>But I cannot do this:</p>\n<pre><code>constexpr auto i_cannot() {\n    std::array&lt;int, 10&gt; arr{};\n    //I cannot\n    arr[5] = 9;\n}\n</code></pre>\n<p>My questions are:</p>\n<ol>\n<li>If I can mutate an <code>int</code>, why can I not mutate an <code>int</code> that is inside the array?</li>\n<li>Is this a language limitation (C++14) or a standard library spec problem? <code>reference std::array&lt;T, N&gt;::operator[](size_t)</code> is not currently <code>constexpr</code>.</li>\n</ol>\n", "Tags": "<c++><c++14><constexpr>", "OwnerUserId": "429879", "AnswerCount": "2"}, "31903140": {"ParentId": "31903037", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>It is a limitation of the standard library since you <strong>can</strong> modify a plain C array in a <code>constexpr</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nconstexpr auto demo()\n{\n   int arr[10] = {};\n   arr[5] = 9;\n   return arr[5];\n}\n\nint main()\n{\n    static_assert(demo() == 9, \"\");\n    std::cout &lt;&lt; demo() &lt;&lt; std::endl;\n    return 0;\n}   \n</code></pre>\n<p><a href=\"http://melpon.org/wandbox/permlink/Cu8CSW9MNL0k7CMg\" rel=\"noreferrer\">DEMO</a></p>\n<p><strong>output</strong></p>\n<pre><code>9\n</code></pre>\n<p>If you added <code>constexpr</code> to <code>operator[]</code> of an implementation of <code>array</code>, you could also use this operator inside a  <code>constexpr</code>.</p>\n<p><a href=\"http://melpon.org/wandbox/permlink/Lc9Hs7HrsQoOMHXs\" rel=\"noreferrer\">DEMO</a></p>\n", "OwnerUserId": "678093", "LastEditorUserId": "678093", "LastEditDate": "2015-08-09T14:31:56.277", "Id": "31903140", "Score": "16", "CreationDate": "2015-08-09T10:16:30.777", "LastActivityDate": "2015-08-09T14:31:56.277"}, "bq_ids": {"n4140": {"so_31903037_31903244_0": {"section_id": 5421, "quality": 0.9047619047619048, "length": 19}}, "n3337": {"so_31903037_31903244_0": {"section_id": 5216, "quality": 0.6190476190476191, "length": 13}}, "n4659": {"so_31903037_31903244_0": {"section_id": 6843, "quality": 0.8095238095238095, "length": 17}}}, "31903244": {"ParentId": "31903037", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Modification of objects inside <code>constexpr</code> functions has been introduced with C++14. However, while modifying e.g. a scalar by an assignment is fine, modifying a class object through a member function still needs that member function to be <code>constexpr</code>. And unfortunately, as you mentioned, the current <code>std::array</code> specification does not declare the non-<code>const</code> <code>operator[]</code> as <code>constexpr</code>.<br>\nHence, \u00a77.1.5/5 makes your definition ill-formed:</br></p>\n<blockquote>\n<p id=\"so_31903037_31903244_0\">For a non-template, non-defaulted <code>constexpr</code> function [\u2026], if no\n  argument values exist such that an invocation of the function [\u2026]\n  could be an evaluated subexpression of a core constant expression\n  (5.20), [\u2026], the program is ill-formed; no diagnostic required.</p>\n</blockquote>\n<p>You can temporarily use a more modern implementation if you want full <code>constexpr</code>-ness. E.g. <a href=\"https://github.com/Arcoth/Constainer/blob/master/Array.hxx\" rel=\"noreferrer\"><code>Constainer::Array</code></a>.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-08-09T11:05:37.497", "Id": "31903244", "Score": "17", "CreationDate": "2015-08-09T10:30:10.317", "LastActivityDate": "2015-08-09T11:05:37.497"}});