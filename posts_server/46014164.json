post_cb({"46014164": {"ViewCount": "342", "Body": "<p>As explained in <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0532r0.pdf\" rel=\"noreferrer\">P0532R0</a>, in the folowing use case <code>std::launder</code> must be used to avoid undefined behavior (UB):</p>\n<pre><code>struct X{\n  const int i;\n  x(int i):i{i}{}\n  };\n\nunsigned char buff[64];\nauto p = new(buff) X(33);\np-&gt;~X();\nnew(buff) X(42);\np = std::launder(p);\nassert(p-&gt;i==42);\n</code></pre>\n<p>But what happen in the case where more than one object is on the buffer (this is exactly what would happen if one pushes 2 <code>X</code> in a vector, clears the vector and then pushes two new <code>X</code>):</p>\n<pre><code>unsigned char buff[64];\nauto p0 = new(buff) X(33);\nauto p1 = new(p0+1) X(34);\np1-&gt;~X();\np0-&gt;~X();\nnew(buff) X(42);\nnew(p0+1) X(43);\np0 = std::launder(p0);\nassert(p0-&gt;i==42);\nassert(p0[1].i==43);//???\n</code></pre>\n<p>Is the last assertion correct, or <code>p0[1]</code> still invokes UB?</p>\n", "AcceptedAnswerId": "46015752", "Title": "Is the \"laundry\" propagated by pointer arithmetic?", "CreationDate": "2017-09-02T13:09:03.630", "Id": "46014164", "CommentCount": "3", "LastEditDate": "2017-09-02T13:49:10.123", "PostTypeId": "1", "LastEditorUserId": "1554020", "LastActivityDate": "2017-09-02T16:12:12.423", "Score": "7", "OwnerUserId": "5632316", "Tags": "<c++><undefined-behavior><c++1z>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_46014164_46015272_0": {"length": 43, "quality": 1.0, "section_id": 7195}, "so_46014164_46015752_2": {"length": 11, "quality": 1.0, "section_id": 7195}, "so_46014164_46015752_0": {"length": 26, "quality": 0.7647058823529411, "section_id": 6142}}, "n3337": {"so_46014164_46015272_0": {"length": 43, "quality": 1.0, "section_id": 6939}, "so_46014164_46015752_2": {"length": 11, "quality": 1.0, "section_id": 6939}, "so_46014164_46015752_0": {"length": 26, "quality": 0.7647058823529411, "section_id": 5906}}, "n4659": {"so_46014164_46015272_2": {"length": 30, "quality": 1.0, "section_id": 8380}, "so_46014164_46015272_0": {"length": 43, "quality": 1.0, "section_id": 8704}, "so_46014164_46015752_2": {"length": 11, "quality": 1.0, "section_id": 8704}, "so_46014164_46015752_0": {"length": 34, "quality": 1.0, "section_id": 7638}, "so_46014164_46015752_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 7638}, "so_46014164_46015272_1": {"length": 14, "quality": 1.0, "section_id": 8704}}}, "46015272": {"Id": "46015272", "PostTypeId": "2", "Body": "<p>The reason <code>std::launder</code> is needed in the first place is due to this violation from <a href=\"http://eel.is/c++draft/basic.life#8\" rel=\"nofollow noreferrer\">[basic.life]</a></p>\n<blockquote>\n<p id=\"so_46014164_46015272_0\">If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new object is created at the storage location which the original object occupied, a pointer that pointed to the original object, a reference that referred to the original object, or the name of the original object will automatically refer to the new object and, once the lifetime of the new object has started, can be used to manipulate the new object, if: [...]</p>\n<ul>\n<li>the type of the original object is not const-qualified, and, if a class type, does not contain any non-static data member whose type is const-qualified or a reference type, and [...]</li>\n</ul>\n</blockquote>\n<p>Hence without <code>std::launder</code>, <code>p</code> the original pointer would not point to the newly constructed object.</p>\n<blockquote>\n<p id=\"so_46014164_46015272_1\">If these conditions are not met, a pointer to the new object can be obtained from a pointer that represents the address of its storage by calling <code>std\u200b::\u200blaunder</code></p>\n</blockquote>\n<p>Which is why <code>std::launder</code> does <a href=\"https://stackoverflow.com/questions/39382501/what-is-the-purpose-of-stdlaunder\">what it does</a>.</p>\n<p>From <a href=\"http://eel.is/c++draft/ptr.launder#3\" rel=\"nofollow noreferrer\">[ptr.launder]</a>, aptly titled <em>Pointer optimization barrier</em></p>\n<blockquote>\n<p id=\"so_46014164_46015272_2\">If a new object is created in storage occupied by an existing object of the same type, a pointer to the original object can be used to refer to the new object unless the type contains const or reference members; in the latter cases, this function can be used to obtain a usable pointer to the new object.</p>\n</blockquote>\n<p>Which is saying the original pointer cannot be used to refer to the newly constructed object unless laundered.</p>\n<p>From what I can see, it can be interpreted both ways (might be entirely mistaken).</p>\n<ul>\n<li>A pointer computed from a laundered pointer is not the original pointer, so its well-formed</li>\n<li>Nowhere is it mentioned that a pointer computed from a laundered pointer is laundered, so its UB</li>\n</ul>\n<p>I personally believe the first to be true, due to <code>std::launder</code> being a pointer optimization barrier.</p>\n", "LastEditorUserId": "4832499", "LastActivityDate": "2017-09-02T15:49:40.143", "Score": "2", "CreationDate": "2017-09-02T15:21:11.507", "ParentId": "46014164", "CommentCount": "0", "OwnerUserId": "4832499", "LastEditDate": "2017-09-02T15:49:40.143"}, "46015752": {"Id": "46015752", "PostTypeId": "2", "Body": "<p>Your code invokes UB, but not for <code>launder</code> reasons. It's because <code>p0[1].i</code> is itself UB.</p>\n<p>Yes, really ([Expr.Add]/4):</p>\n<blockquote>\n<p id=\"so_46014164_46015752_0\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the expression P points to element x[i] of an array object x with n elements, the expressions P + J and J + P (where J has the value j ) point to the (possibly-hypothetical) element x[i + j] if 0 \u2264 i + j \u2264 n ; otherwise, the behavior is undefined. Likewise, the expression P - J points to the (possibly-hypothetical) element x[i \u2212 j] if 0 \u2264 i \u2212 j \u2264 n; otherwise, the behavior is undefined.</p>\n<p id=\"so_46014164_46015752_1\">An object that is not an array element is considered to belong to a single-element array for this purpose; see 8.3.1. A pointer past the last element of an array x of n elements is considered to be equivalent to a pointer to a hypothetical element x[n] for this purpose; see 6.9.2.</p>\n</blockquote>\n<p><code>[]</code> when applied to a pointer means to do pointer arithmetic. And in the C++ object model, pointer arithmetic can only be used on pointers to elements in an array of the type being pointed to. You can always treat an object as an array of length 1, so you can get a pointer to \"one past the end\" of the single object. Thus, <code>p0 + 1</code> is valid.</p>\n<p>What is <em>not</em> valid is accessing the object stored at that address though the pointer obtained via <code>p0 + 1</code>. That is, <code>p0[1].i</code> is undefined behavior. This is just as UB <em>before</em> laundering it as after.</p>\n<p>Now, let's look at a different possibility:</p>\n<pre><code>X x[2];\nx[1].~X(); //Destroy this object.\nnew(x + 1) X; //Construct a new one.\n</code></pre>\n<p>So let's ask some questions:</p>\n<p>Is <code>x[1]</code> UB? I would say... no, it is not UB. Why? Because <code>x[1]</code> is not:</p>\n<blockquote>\n<p id=\"so_46014164_46015752_2\">a pointer that pointed to the original object, a reference that referred to the original object, or the name of the original object</p>\n</blockquote>\n<p><code>x</code> points to the array and the first element of that array, not the second element. Therefore, it does not point to the original object. It is not a reference, nor is it the name of that object.</p>\n<p>Therefore, it does not qualify for the restrictions stated by [basic.life]/8. So <code>x[1]</code> should point to the newly constructed object.</p>\n<p>Given that, you don't need <code>launder</code> at all.</p>\n<p>So if you're doing this in a way that's legal, then you don't need <code>launder</code> here.</p>\n", "LastActivityDate": "2017-09-02T16:12:12.423", "CommentCount": "11", "CreationDate": "2017-09-02T16:12:12.423", "ParentId": "46014164", "Score": "5", "OwnerUserId": "734069"}});