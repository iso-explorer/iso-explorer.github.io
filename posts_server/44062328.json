post_cb({"44062328": {"CommentCount": "3", "ViewCount": "381", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2017-05-19T05:50:00.917", "LastActivityDate": "2017-05-22T06:19:26.563", "Title": "All versions of GCC struggle with default member initializer, that captures this, combined with inherited constructors", "LastEditDate": "2017-05-23T12:26:27.260", "Id": "44062328", "Score": "10", "Body": "<p>This story is similar to my previous <a href=\"https://stackoverflow.com/q/43993162/966376\">question</a>. All versions of GCC that support <em>C++11</em>, have this exact behaviour. I could not find any other compiler that struggles with my test case.</p>\n<p>The test case:</p>\n<pre><code>struct BaseFooWrapper\n{\n    BaseFooWrapper(int qux)\n    { }\n};\n\nstruct Foo\n{\n    Foo(BaseFooWrapper &amp; foo)\n        : foo(foo)\n    { }\n\n    BaseFooWrapper &amp; foo;\n};\n\nstruct SomeFooWrapper : public BaseFooWrapper\n{\n    using BaseFooWrapper::BaseFooWrapper;\n\n\n    Foo foo{*this};\n};\n\nint main()\n{\n    SomeFooWrapper wrapped_foo(1);\n    return 0;\n}\n</code></pre>\n<hr>\n<p>Live on <a href=\"https://godbolt.org/g/jQGYGB\" rel=\"nofollow noreferrer\">godbolt.com</a></p>\n<hr>\n<p>This piece of code compiles with <strong>clang</strong> (3.4 through 4.0), <strong>icc</strong> (16, 17), <strong>Visual C++</strong> (19.00.23506). </p>\n<p>If I replace constructor inheritance with a hand-written version, then GCC starts to compile the code:</p>\n<pre><code>struct BaseFooWrapper\n{\n    BaseFooWrapper(int qux)\n    { }\n};\n\nstruct Foo\n{\n    Foo(BaseFooWrapper &amp; foo)\n        : foo(foo)\n    { }\n\n    BaseFooWrapper &amp; foo;\n};\n\nstruct SomeFooWrapper : public BaseFooWrapper\n{\n    SomeFooWrapper(int qux)\n        : BaseFooWrapper(qux)\n    { }\n\n\n    Foo foo{*this};\n};\n\nint main()\n{\n    SomeFooWrapper wrapped_foo(1);\n    return 0;\n}\n</code></pre>\n<hr>\n<p>Live on <a href=\"https://godbolt.org/g/bfou2p\" rel=\"nofollow noreferrer\">godbolt.com</a></p>\n<hr>\n<p>Obviously it is not very handy, especially when you have many such classes, and leads to boilerplate code. Basically, the very thing that <em>inheriting constructors</em> are designed to fix. This behaviour of GCC renders this great <em>c++11</em> feature unavailable in such cases. </p>\n<p>So I am really curious whether I am doing something illegal with regard to the standard or this is a bug in GCC?</p>\n<hr>\n<p><strong>Edit:</strong></p>\n<p>Filed a <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=80851\" rel=\"nofollow noreferrer\">bug report</a>.</p>\n</hr></hr></hr></hr></hr>", "Tags": "<c++><c++11><gcc><inheriting-constructors>", "OwnerUserId": "966376", "AnswerCount": "2"}, "44062786": {"ParentId": "44062328", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The problem is not the constructor inheritance, but this line:</p>\n<pre><code>Foo foo{*this};\n</code></pre>\n<p>GCC appears to think it will need a default constructor for struct Foo as well, and since the class has a reference, it is not able to do so.</p>\n<pre><code>error: no matching function for call to 'Foo::Foo()'\n&lt;source&gt;:14:5: note: candidate: Foo::Foo(BaseFooWrapper&amp;)\n     Foo(BaseFooWrapper &amp; foo): foo(foo)\n     ^~~\n&lt;source&gt;:14:5: note:   candidate expects 1 argument, 0 provided\n&lt;source&gt;:10:7: note: candidate: constexpr Foo::Foo(const Foo&amp;)\n</code></pre>\n<p>By adding the default constructor it appears to think it needs, then the code compiles:</p>\n<pre><code>struct Foo\n{\n\n    Foo():foo(*new BaseFooWrapper(0))\n    {\n\n    }\n    Foo(BaseFooWrapper &amp; foo): foo(foo)\n    { \n\n    }\n\n    BaseFooWrapper &amp; foo;\n};\n</code></pre>\n<p>It does look like a bug.</p>\n", "OwnerUserId": "7902545", "LastEditorUserId": "7902545", "LastEditDate": "2017-05-19T06:29:52.433", "Id": "44062786", "Score": "6", "CreationDate": "2017-05-19T06:21:47.510", "LastActivityDate": "2017-05-19T06:29:52.433"}, "bq_ids": {"n4140": {"so_44062328_44063793_0": {"section_id": 5895, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_44062328_44063793_0": {"section_id": 5666, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_44062328_44063793_0": {"section_id": 7378, "quality": 0.9444444444444444, "length": 17}}}, "44063793": {"ParentId": "44062328", "CommentCount": "1", "Body": "<p>I could be wrong, but quoting from the n4527 draft standard in <strong>[class.this]</strong>:</p>\n<blockquote>\n<p id=\"so_44062328_44063793_0\">In the body of a non-static (9.3) member function, the keyword this is a prvalue expression whose value\n  is the address of the object for which the function is called. The type of this in a member function of\n  a class X is X*. </p>\n</blockquote>\n<p>In the OP's code, the initialisation of <code>SomeFooWrapper::foo</code> is not taking place in a member function. Therefore the keyword <code>this</code> has no reasonable meaning as far as the standard is concerned.</p>\n<p>Or have I missed something?</p>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "44063793", "Score": "2", "CreationDate": "2017-05-19T07:17:24.603", "LastActivityDate": "2017-05-19T07:17:24.603"}});