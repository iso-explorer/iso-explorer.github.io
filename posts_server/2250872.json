post_cb({"2250993": {"ParentId": "2250872", "CommentCount": "0", "Body": "<p>This is one of those tricky parts of how the name lookup is performed.</p>\n<p>There are two identifier scopes in C++, one for class types and general identifier scope. The enum value BAD resides in the general identifier scope, while the class type BAR resides in the class identifier scope. That is the reason why you are allowed to have both an enum value and a class with the same name: both names do not collide.</p>\n<p>Within class BAD, the identifier lookup rules will find the class BAD before it finds the enum, and thus the error. Now, if you fully qualify the identifier then the name lookup will first check the global identifier scope and match the enum value. On the opposite end, you will have to add the <code>struct</code> or <code>class</code> keyword to declare variables of type BAD.</p>\n<pre><code>namespace foo {\n   enum bad { BAD; };\n   class BAD {\n      void worse() { bad b = ::foo::BAD; } // fully qualified will match the enum\n   };\n}\nint main() {\n   // foo::BAD b;    // error, foo::BAD is an enum, not a type\n   class foo::BAD b; // correct\n}\n</code></pre>\n<p>Now, I would advice against this usage. It is generally not a good idea to reuse an identifier like this. Code will be more complex, and probably misleading for the casual reader (the same unqualified identifier refers to different things when used in different contexts). If the names do need to be <code>BAD</code>, consider using an enclosing namespace or class for either the class or the enum (prefer the enum there).</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "2250993", "Score": "9", "CreationDate": "2010-02-12T10:09:01.667", "LastActivityDate": "2010-02-12T10:09:01.667"}, "2250872": {"CommentCount": "2", "ViewCount": "3294", "LastActivityDate": "2010-02-12T10:18:00.227", "Body": "<p>I've a class and an enum value which have the same name. Inside the class I want to use the enum which gives an error. Is there any way to use the enum <em>without</em> renaming or moving to a different namespace?</p>\n<p>Example:</p>\n<pre><code>namespace foo {\n    enum bar {\n        BAD\n    };\n\n    class BAD {\n        void worse () {\n            bar b = BAD; // error\n        }\n    };\n};\n</code></pre>\n", "PostTypeId": "1", "AcceptedAnswerId": "2250993", "FavoriteCount": "1", "Title": "use class and enum with same name?", "Id": "2250872", "Score": "10", "CreationDate": "2010-02-12T09:49:23.413", "Tags": "<c++><class><enums>", "OwnerUserId": "184183", "AnswerCount": "4"}, "2250945": {"ParentId": "2250872", "CommentCount": "1", "Body": "<p>This works in VS2008, but gives a warning:</p>\n<pre><code>bar b = bar::BAD;\n</code></pre>\n<p>Its not something I can recommend.</p>\n<p>You should put the enum within another namespace inside <code>foo</code> and qualify both <code>bar</code> and <code>BAD</code> with the new namespace.</p>\n", "OwnerUserId": "4834", "PostTypeId": "2", "Id": "2250945", "Score": "0", "CreationDate": "2010-02-12T10:00:42.107", "LastActivityDate": "2010-02-12T10:00:42.107"}, "2250885": {"ParentId": "2250872", "CommentCount": "0", "Body": "<p>No, there is no way to do that. You should use valid identifier. Valid identifier means that you have to be able to <strong>identify</strong> with it. :)</p>\n", "OwnerUserId": "266159", "PostTypeId": "2", "Id": "2250885", "Score": "0", "CreationDate": "2010-02-12T09:51:11.087", "LastActivityDate": "2010-02-12T09:51:11.087"}, "bq_ids": {"n4140": {"so_2250872_2250898_0": {"section_id": 5857, "quality": 0.9090909090909091, "length": 20}}, "n3337": {"so_2250872_2250898_0": {"section_id": 5627, "quality": 0.9090909090909091, "length": 20}}, "n4659": {"so_2250872_2250898_0": {"section_id": 7336, "quality": 0.9090909090909091, "length": 20}}}, "2250898": {"ParentId": "2250872", "LastEditDate": "2010-02-12T10:18:00.227", "CommentCount": "2", "CreationDate": "2010-02-12T09:53:16.010", "OwnerUserId": "136208", "LastEditorUserId": "136208", "PostTypeId": "2", "Id": "2250898", "Score": "5", "Body": "<pre><code> bar b = foo::BAD;\n</code></pre>\n<p>or if you are in the global namespace</p>\n<pre><code> bar b = ::BAD;\n</code></pre>\n<p>but that name overloading is not something I'd recommend. C++0X will allow</p>\n<pre><code> bar b = bar::BAD;\n</code></pre>\n<p>which is a better solution if the dependency on C++0X is acceptable.</p>\n<p>As promised, the explanation</p>\n<p>9.1/2</p>\n<blockquote>\n<p id=\"so_2250872_2250898_0\">If a class name is declared in a scope where an object, function, or enumerator of the same name is also declared, then both declarations are in scope, the class can be referred to only using an <em>elaborated-type-specifier</em> (3.4.4)</p>\n</blockquote>\n<p>The <em>elaborated-type-specifier</em> is the form</p>\n<pre><code>class BAD b;\n</code></pre>\n<p>This is for compatibility with C where tag names are in a different name space and must be [i]typedef[/i]ed if one want to use them without an elaborated-type-specifier. (A well known example with a function is the struct stat and the function stat in Unix).</p>\n<p>That explain why the overloading of a name to designate a class and an enumerator is possible.  The reason for which BAD designate the class here is that the name of the class is also defined into the class scope and in a member function definition the scope searched are in order:\n   - the member function scope\n   - the class scope\n   - the namespace containing the class definition</p>\n<p>BAD is found at class scope, so the namespace foo is never searched.</p>\n", "LastActivityDate": "2010-02-12T10:18:00.227"}});