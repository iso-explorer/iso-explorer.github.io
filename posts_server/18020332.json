post_cb({"18020416": {"PostTypeId": "2", "Body": "<p>When indexing a pointer, the compiler knows that the index should be advanced by the size of the cell, in this case, a pointer of 4 bytes.  </p>\n", "LastActivityDate": "2013-08-02T15:13:38.593", "Id": "18020416", "CommentCount": "0", "CreationDate": "2013-08-02T15:13:38.593", "ParentId": "18020332", "Score": "1", "OwnerUserId": "2587816"}, "18020414": {"PostTypeId": "2", "Body": "<p>From the C11 <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow\">standard:</a> \u00a76.5.2.1</p>\n<blockquote>\n<p id=\"so_18020332_18020414_0\">A post\ufb01x expression followed by an expression in square brackets [] is a subscripted\n  designation of an element of an array object. The de\ufb01nition of the subscript operator []\n  is that E1[E2] is identical to (*((E1)+(E2))). Because of the conversion rules that\n  apply to the binary + operator, if E1 is an array object (equivalently, a pointer to the\n  initial element of an array object) and E2 is an integer, E1[E2] designates the E2-th\n  element of E1 (counting from zero).</p>\n</blockquote>\n<p>E.G. what you're doing is basically what <code>[]</code> already does</p>\n<p>Also (same standard) explains why pointers increment as you noticed: \u00a76.5.6</p>\n<blockquote>\n<p id=\"so_18020332_18020414_1\">When an expression that has integer type is added to or subtracted from a pointer, the\n  result has the type of the pointer operand. If the pointer operand points to an element of\n  an array object, and the array is large enough, the result points to an element offset from\n  the original element such that the difference of the subscripts of the resulting and original\n  array elements equals the integer expression. In other words, if the expression P points to\n  the i-th element of an array object, the expressions (P)+N (equivalently, N+(P)) and\n  (P)-N (where N has the value n) point to, respectively, the i+n-th and i\u2212n-th elements of\n  the array object, provided they exist. Moreover, if the expression P points to the last\n  element of an array object, the expression (P)+1 points one past the last element of the\n  array object, and if the expression Q points one past the last element of an array object,\n  the expression (Q)-1 points to the last element of the array object. If both the pointer\n  operand and the result point to elements of the same array object, or one past the last\n  element of the array object, the evaluation shall not produce an over\ufb02ow; otherwise, the\n  behavior is unde\ufb01ned. If the result points one past the last element of the array object, it\n  shall not be used as the operand of a unary * operator that is evaluated.</p>\n</blockquote>\n", "LastActivityDate": "2013-08-02T15:34:39.433", "LastEditorUserId": "332733", "Id": "18020414", "CommentCount": "2", "CreationDate": "2013-08-02T15:13:36.203", "ParentId": "18020332", "Score": "5", "OwnerUserId": "332733", "LastEditDate": "2013-08-02T15:34:39.433"}, "18020332": {"ViewCount": "170", "Body": "<p>let <code>int * ptr,array[10]; ptr= array;</code>. Now each of the memory cells in array's contiguous locations have a fixed size. If the address of first cell is 1234 then the next cell must be at 1238 address. But we access it using a pointer as <code>*(ptr+1)</code>.\nI am confused regarding this. Any sources or answers? Thanks.</p>\n", "AcceptedAnswerId": "18020423", "Title": "Accessing array by pointers", "CreationDate": "2013-08-02T15:09:31.677", "Id": "18020332", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-08-02T15:12:19.883", "LastEditorUserId": "1137388", "LastActivityDate": "2013-08-02T15:34:39.433", "Score": "0", "OwnerUserId": "2047167", "Tags": "<c++><c><pointers>", "AnswerCount": "8"}, "18020488": {"PostTypeId": "2", "Body": "<p>The right operand of the + operator, lets call it x,  is not the actual amount you're moving the pointer. Because int is 4 bytes, the compiler knows to actually skip to  x*4.</p>\n", "LastActivityDate": "2013-08-02T15:17:33.423", "Id": "18020488", "CommentCount": "0", "CreationDate": "2013-08-02T15:17:33.423", "ParentId": "18020332", "Score": "0", "OwnerUserId": "2641191"}, "18020423": {"PostTypeId": "2", "Body": "<p>The compiler knows that <code>ptr</code> is a pointer to a 4-byte type, so it knows that <code>ptr+1</code> is 4 bytes further on in the memory.</p>\n<p>If you think for a moment, it's clear that this must be so, as otherwise you couldn't write portable code without knowing the size of (for instance) an integer on your system.</p>\n<p>Further, array indexing is exactly pointer arithmetic under the covers - that is, <code>array[3]</code> is exactly the same as <code>*(array + 3)</code></p>\n", "LastActivityDate": "2013-08-02T15:13:53.797", "Id": "18020423", "CommentCount": "3", "CreationDate": "2013-08-02T15:13:53.797", "ParentId": "18020332", "Score": "3", "OwnerUserId": "93884"}, "bq_ids": {"n4140": {"so_18020332_18020414_1": {"length": 104, "quality": 0.8666666666666667, "section_id": 6142}}, "n3337": {"so_18020332_18020414_1": {"length": 104, "quality": 0.8666666666666667, "section_id": 5906}}}, "18020450": {"PostTypeId": "2", "Body": "<p>Pointer arithmetic considers the size of the pointed type. For instance, if the value of <code>ptr</code> is <code>1234</code>, since <code>ptr</code> is of type <code>int*</code>, then the value of <code>p + 1</code> is <code>1234 + 1 * sizeof(int) == 1234 + 1 * 4 = 1238</code> (assuming <code>sizeof(int) == 4</code>).</p>\n", "LastActivityDate": "2013-08-02T15:15:26.523", "Id": "18020450", "CommentCount": "0", "CreationDate": "2013-08-02T15:15:26.523", "ParentId": "18020332", "Score": "1", "OwnerUserId": "1137388"}, "18020594": {"PostTypeId": "2", "Body": "<p>The units of pointer arithmetic are pointed-to objects, not bytes.</p>\n<p>If <code>p</code> points to <code>int</code> objects, then <code>p+1</code>, <code>p+2</code>, and <code>p+3</code> point to successive <code>int</code> objects, not to successive bytes. If <code>p</code> points to a large structure, then they point to successive instances of the structure.</p>\n<p>The compiler does its work behind the scenes to convert the pointer arithmetic into machine address arithmetic. So it multiplies offsets as necessary to convert from units of objects to units of bytes.</p>\n", "LastActivityDate": "2013-08-02T15:22:37.600", "Id": "18020594", "CommentCount": "0", "CreationDate": "2013-08-02T15:22:37.600", "ParentId": "18020332", "Score": "0", "OwnerUserId": "298225"}, "18020793": {"PostTypeId": "2", "Body": "<p>Pointer arithmetic is a different operation than normal arithmetic. In Pointer arithmetic, one argument has to be a pointer type, the other one has to be an integral type:</p>\n<ol>\n<li><code>intA + intB</code>: Normal arithmetic, result is the sum.</li>\n<li><code>intA + pointerB</code>: Pointer arithmetic, the calculation performed is <code>sizeof(*pointerB)*intA + pointerB</code></li>\n<li><code>pointerA + intB</code>: Pointer arithmetic, the calculation performed is <code>pointerA + sizeof(*pointerA)*intB</code></li>\n<li><code>pointerA + pointerB</code>: Illegal</li>\n</ol>\n<p><code>pointerA[intB]</code> is just a shorthand for case 2 (<code>pointerA + intB</code>), which is why it is equivalent to <code>intB[pointerA]</code> (resolves to case 3), but that's only of use in the IOCCC.</p>\n", "LastActivityDate": "2013-08-02T15:31:56.017", "Id": "18020793", "CommentCount": "0", "CreationDate": "2013-08-02T15:31:56.017", "ParentId": "18020332", "Score": "0", "OwnerUserId": "2445184"}, "18020693": {"PostTypeId": "2", "Body": "<p>My guess is that according to you  <code>(ptr + 1)</code> should give you <code>1235</code> but obviously it doesn't. </p>\n<p>In addition to the answers given by others as to why it adds <code>4</code> and gives you <code>1238</code>, consider the case if it gave you <code>1235</code>, at <code>1235</code> you don't have an integer element(i.e. the 2nd element of the array). \nBut your pointer should point to an integer . Hence it doesn't work out this way.</p>\n", "LastActivityDate": "2013-08-02T15:26:57.933", "Id": "18020693", "CommentCount": "0", "CreationDate": "2013-08-02T15:26:57.933", "ParentId": "18020332", "Score": "0", "OwnerUserId": "1634969"}});