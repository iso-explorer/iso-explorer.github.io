post_cb({"23716391": {"CommentCount": "3", "AcceptedAnswerId": "23716762", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-05-17T21:47:21.813", "LastActivityDate": "2015-05-03T23:05:47.400", "LastEditDate": "2017-05-23T12:14:16.440", "ViewCount": "137", "FavoriteCount": "1", "Title": "Set a value to POD within 1 atomic operation in VC++", "Id": "23716391", "Score": "-2", "Body": "<p>I am trying to find a way to set a POD (int, byte, long etc.) as atomic operation.\nNotice std::atomic is not good for me because it is not POD.</p>\n<p>I also looked in VC intrensic functions, but didn't find exactly what I wanted (guess due to lack of documentation).</p>\n<p>Does anyone know how to do it?</p>\n<p>EDIT: I did not know that std::atomic is POD, therefore my question was wrong, I'll reask it in a new question. I don't want to delete or alter this question because the answer is really good an informative. Thanks!!! My actual question: <a href=\"https://stackoverflow.com/questions/23719457/set-a-value-to-pod-that-doesnt-have-constructor-desctructor-within-1-atomic-o\">Set a value to POD (that doesn't have constructor/desctructor) within 1 atomic operation in VC++</a></p>\n", "Tags": "<c++><visual-c++><atomic>", "OwnerUserId": "324827", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_23716391_23716762_7": {"section_id": 1169, "quality": 0.9545454545454546, "length": 21}, "so_23716391_23716762_5": {"section_id": 5854, "quality": 1.0, "length": 11}, "so_23716391_23716762_1": {"section_id": 4706, "quality": 1.0, "length": 4}, "so_23716391_23716762_4": {"section_id": 5854, "quality": 0.8888888888888888, "length": 8}, "so_23716391_23716762_3": {"section_id": 5850, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_23716391_23716762_4": {"section_id": 5624, "quality": 0.8888888888888888, "length": 8}, "so_23716391_23716762_7": {"section_id": 1167, "quality": 0.9545454545454546, "length": 21}, "so_23716391_23716762_3": {"section_id": 5620, "quality": 0.8888888888888888, "length": 8}, "so_23716391_23716762_1": {"section_id": 4515, "quality": 1.0, "length": 4}, "so_23716391_23716762_5": {"section_id": 5624, "quality": 1.0, "length": 11}}, "n4659": {"so_23716391_23716762_4": {"section_id": 7333, "quality": 0.8888888888888888, "length": 8}, "so_23716391_23716762_3": {"section_id": 7329, "quality": 0.6666666666666666, "length": 6}, "so_23716391_23716762_1": {"section_id": 6103, "quality": 1.0, "length": 4}, "so_23716391_23716762_5": {"section_id": 7333, "quality": 1.0, "length": 11}}}, "23716762": {"ParentId": "23716391", "CommentCount": "2", "Body": "<p>Use <code>std::atomic&lt;T&gt;</code>, contrary to what your question states it is a POD type. Let's go through the POD requirements one by one:</p>\n<blockquote>\n<p id=\"so_23716391_23716762_0\"><strong>9 Classes [class]</strong></p>\n<p id=\"so_23716391_23716762_1\">6 A <em>trivially copyable class</em> is a class that:</p>\n<ul>\n<li>has no non-trivial copy constructors (12.8),</li>\n<li>has no non-trivial move constructors (12.8),</li>\n<li>has no non-trivial copy assignment operators (13.5.3, 12.8),</li>\n<li>has no non-trivial move assignment operators (13.5.3, 12.8), and</li>\n</ul>\n</blockquote>\n<p><code>std::atomic&lt;T&gt;</code> has no non-trivial copy or move constructors or assignment operators: it simply doesn't have them at all (they're deleted). It does have non-trivial non-copy non-move constructors and assignment operators, but that doesn't prevent the class from being trivially copyable.</p>\n<blockquote id=\"so_23716391_23716762_2\">\n<ul>\n<li>has a trivial destructor (12.4).</li>\n</ul>\n</blockquote>\n<p><code>std::atomic&lt;T&gt;</code> has a trivial destructor, see 29.5.</p>\n<blockquote>\n<p id=\"so_23716391_23716762_3\">A <em>trivial class</em> is a class that has a trivial default constructor (12.1) and is trivially copyable.</p>\n</blockquote>\n<p><code>std::atomic&lt;T&gt;</code> has a trivial default constructor, see 29.5.</p>\n<p>The requirements add up: <code>std::atomic&lt;T&gt;</code> is a trivial class.</p>\n<blockquote>\n<p id=\"so_23716391_23716762_4\">10 A <em>POD struct</em> is a non-union class that is both a trivial class and a standard-layout class,</p>\n</blockquote>\n<p><code>std::atomic&lt;T&gt;</code> is a non-union class, is a trivial class, and is a standard-layout class, see 29.5.</p>\n<blockquote>\n<p id=\"so_23716391_23716762_5\">and has no non-static data members of type non-POD struct, non-POD union (or array of such types).</p>\n</blockquote>\n<p>If <code>std::atomic&lt;T&gt;</code> had any members of type non-POD struct or union, one of those members would have to be a non-trivial class or a non-standard-layout class. That would prevent <code>std::atomic&lt;T&gt;</code> from being a trivial class or a standard-layout class<sup>*</sup>, and since we have already determined that it <em>is</em> a trivial class and a standard-layout class, it cannot have such a member.</p>\n<p>In the above, I've referred to 29.5. The relevant bit is p5:</p>\n<blockquote>\n<p id=\"so_23716391_23716762_6\"><strong>29.5 Atomic types [atomics.types.generic]</strong></p>\n<p id=\"so_23716391_23716762_7\">5 The atomic integral specializations and the specialization <code>atomic&lt;bool&gt;</code> shall have standard layout. They shall each have a trivial default constructor and a trivial destructor. They shall each support aggregate initialization syntax.</p>\n</blockquote>\n<p><sub>* There is one exception: it is hypothetically possible for a trivial class to contain a non-trivial class member. For this to apply to <code>std::atomic&lt;T&gt;</code>, it pretty much requires malice on the part of the implementer, so outside of a hypothetical DeathStation 9000, I'm discounting that possibility.</sub></p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "23716762", "Score": "3", "CreationDate": "2014-05-17T22:38:52.610", "LastActivityDate": "2014-05-17T22:38:52.610"}});