post_cb({"702111": {"Id": "702111", "PostTypeId": "2", "Body": "<p>It is <em>not</em> valid to have an object that contains an auto_ptr in a standard container. You run into undefined behavior. Two common problems:</p>\n<ul>\n<li>std::vector&lt;&gt;::resize copies its argument into each created element. The first copy will \"succeed\" (see below why not), but each further copy will be empty, because the element copied is also empty!</li>\n<li>If something during reallocation throws, you can happen to have some elements copied (to a new buffer) - but the copy being thrown away - and other elements not, because <code>push_back</code> must not have any effects if an exception is being thrown. Thus some of your elements are now empty. </li>\n</ul>\n<p>As this is all about undefined behavior it does not really matter. But even <em>if</em> we try to come up with this behavior based on what we think is valid, we would fail anyway. All the member functions like <code>push_back</code>, <code>resize</code> and so on have a const reference that takes an object of type T. Thus, a reference of type <code>T const&amp;</code> is tried to copied into elements of the vector. But the implicitly created copy constructor/copy assignment operator looks like <code>T(T&amp;)</code> - that is, it requires a <em>non-const</em> object to be copied from! Good implementations of the Standard library check that, and fail to compile if necessary. </p>\n<p>Until the next C++ version, you have to live with this. The next one will support element types that are merely <em>movable</em>. That is, a moved object does not need to be equal to the object moved to. That will allow putting <em>streams</em>, <em>transfer-of-ownership pointers</em> and <em>threads</em> into containers. </p>\n<p>See what the Standard says for this (<code>17.4.3.6</code>):</p>\n<blockquote>\n<p id=\"so_700588_702111_0\">In certain cases (replacement functions, handler functions, operations on types used to instantiate standard library template components), the C++ Standard Library depends on components supplied by a C++ program. If these components do not meet their requirements, the Standard places no requirements on the implementation.</p>\n<p id=\"so_700588_702111_1\">In particular, the effects are undefined in the following cases:</p>\n<ul>\n<li>for types used as template arguments when instantiating a template component, if the operations on the type do not implement the semantics of the applicable Requirements subclause (20.1.5, 23.1, 24.1, 26.1). </li>\n</ul>\n</blockquote>\n", "OwnerDisplayName": "litb", "LastActivityDate": "2009-03-31T17:19:58.810", "Score": "3", "CreationDate": "2009-03-31T17:19:58.810", "ParentId": "700588", "CommentCount": "8", "OwnerUserId": "34509"}, "702875": {"Body": "<p>If you want to use a class that uses auto_ptr in a container, you can just provide a copy-constructor and assignment operator yourself:</p>\n<pre><code>class MyClass\n{\nprivate:\n  const std::auto_ptr&lt;MyOtherClass&gt; obj; // Note const here to keep the pointer from being modified.\n\npublic:\n  MyClass(const MyClass &amp;other) : obj(new MyOtherClass(*other.obj)) {}\n  MyClass &amp;operator=(const MyClass &amp;other)\n  {\n      *obj = *other.obj;\n      return *this;\n  }\n};\n</code></pre>\n<p>But as mentioned elsewhere, the standard lets containers make copies and assignments and assumes that the contained classes will behave in a specific manner that <code>auto_ptr</code> violates.  By defining the methods above, you can make a class that contains an auto_ptr behave.  Even if your implementation works fine with <code>auto_ptrs</code>, you run the risk of finding another implementation doesn't work.  The standard only make guarantees of performance and observable behaviour, not implementation.  </p>\n", "CreationDate": "2009-03-31T20:22:43.223", "ParentId": "700588", "CommentCount": "0", "LastEditDate": "2009-04-01T16:58:55.360", "PostTypeId": "2", "LastEditorDisplayName": "Josh", "LastActivityDate": "2009-04-01T16:58:55.360", "LastEditorUserId": "8701", "Id": "702875", "OwnerDisplayName": "Josh", "Score": "1", "OwnerUserId": "8701"}, "700588": {"ViewCount": "509", "Body": "<p>I can't use shared_ptr in my project, no boost :(</p>\n<p>So, I'm having a class roughly similar to the one below:</p>\n<pre><code>class MyClass\n{\nprivate:\n  std::auto_ptr&lt;MyOtherClass&gt; obj;\n};\n</code></pre>\n<p>Now, I want to store the instances of above class in std::vector. Is it safe? I've <a href=\"https://stackoverflow.com/questions/111478/why-is-it-wrong-to-use-stdautoptr-with-stl-containers\">read here</a> that it's wrong to use std::auto_ptr with STL containers. Does it apply to my situation here?</p>\n", "AcceptedAnswerId": "700614", "Title": "Is it safe to store objects of a class which has an std::auto_ptr as its member variable in std::vector?", "CreationDate": "2009-03-31T08:35:15.110", "Id": "700588", "CommentCount": "1", "LastEditDate": "2017-05-23T12:34:54.180", "PostTypeId": "1", "OwnerDisplayName": "Srikanth", "LastEditorUserId": "-1", "LastActivityDate": "2009-04-01T17:01:34.013", "Score": "3", "OwnerUserId": "7205", "Tags": "<c++><memory-management><stl>", "AnswerCount": "8"}, "700614": {"Body": "<blockquote>\n<p id=\"so_700588_700614_0\">I've posted a question as a follow-up\n  to this answer, see\n  <a href=\"https://stackoverflow.com/questions/704780/class-containing-autoptr-stored-in-vector\">Class containing auto_ptr stored in vector</a>.</p>\n</blockquote>\n<p>Assming your class does not have a user-defined copy constructor, then no, it is probably (see below) not safe. When your class is copied (as will happen when it is added to a vector) the copy constructor of the auto_ptr will be used. This has the weird behaviour of tranferring ownership of the thing being copied to the copy and, so the thing being copied's pointer is now null.</p>\n<p>It is possible, though unlikely, that you actually want this behaviour, in which case an auto_ptr is safe. Assuming you do not, you should either:</p>\n<ul>\n<li>add a copy constructor to manage the copying</li>\n</ul>\n<p><strong>Note this is not enough - see the follow-up question mentioned above for more info.</strong></p>\n<p>or:</p>\n<ul>\n<li>use a smarter, possibly reference counted pointer, such as one of the boost smart pointers</li>\n</ul>\n", "CreationDate": "2009-03-31T08:43:04.920", "ParentId": "700588", "CommentCount": "11", "LastEditDate": "2017-05-23T10:32:49.587", "PostTypeId": "2", "LastEditorDisplayName": "anon", "OwnerDisplayName": "anon", "LastEditorUserId": "-1", "LastActivityDate": "2009-04-01T17:01:34.013", "Id": "700614", "Score": "2"}, "bq_ids": {"n4140": {"so_700588_702111_1": {"length": 5, "quality": 1.0, "section_id": 6324}, "so_700588_702111_0": {"length": 22, "quality": 0.88, "section_id": 6323}}, "n3337": {"so_700588_702111_1": {"length": 5, "quality": 1.0, "section_id": 6081}, "so_700588_702111_0": {"length": 22, "quality": 0.88, "section_id": 6080}}, "n4659": {"so_700588_702111_1": {"length": 5, "quality": 1.0, "section_id": 7834}, "so_700588_702111_0": {"length": 22, "quality": 0.88, "section_id": 7833}}}, "700682": {"Id": "700682", "PostTypeId": "2", "Body": "<p>As Neil Butterworth said, auto_ptr is probably not the way to go.</p>\n<p><a href=\"http://www.boost.org/doc/libs/1_38_0/libs/smart_ptr/shared_ptr.htm\" rel=\"nofollow noreferrer\">boost::shared_ptr</a> clearly is, but you say you can't use boost.</p>\n<p>Let me mention that you could download boost, extract what you need for shared\\ptr only using the <a href=\"http://www.boost.org/doc/libs/1_38_0/tools/bcp/bcp.html\" rel=\"nofollow noreferrer\">bcp tool</a> and use <a href=\"http://www.boost.org/doc/libs/1_38_0/libs/smart_ptr/shared_ptr.htm\" rel=\"nofollow noreferrer\">boost::shared_ptr</a>. It would only mean a few added hpp files in your project. I believe it's the right way to go.</p>\n", "OwnerDisplayName": "Beno&#238;t", "LastActivityDate": "2009-03-31T09:03:51.453", "Score": "3", "CreationDate": "2009-03-31T09:03:51.453", "ParentId": "700588", "CommentCount": "1", "OwnerUserId": "31640"}, "700632": {"Body": "<p>It is not safe, bacause when container will copy MyClass instnace default copy operator will call copy for all members - and for auto_ptr member too and we will have same situation as you describe in your question ( storing auto_ptr in container )</p>\n<p>BTW: for avoid confusion at compile time add  </p>\n<pre><code>private:\n  MyClass&amp; operator=( const MyClass&amp; );  \n  MyClass( const MyClass&amp; );\n</code></pre>\n<p>compiler output error if you will try use copy operators, this can save you from hours of debug.</p>\n", "CreationDate": "2009-03-31T08:49:35.730", "ParentId": "700588", "CommentCount": "2", "LastEditDate": "2009-03-31T08:55:00.070", "PostTypeId": "2", "LastEditorDisplayName": "bb", "LastActivityDate": "2009-03-31T08:55:00.070", "LastEditorUserId": "72000", "Id": "700632", "OwnerDisplayName": "bb", "Score": "6", "OwnerUserId": "72000"}, "700667": {"Body": "<p>The reason why it is not safe to instanciate a vector of auto_pointer is that there is an algorithm : sort(), that will do a copy of one object in your container on the stack. (sort() implements quicksort which needs a \"pivot\")\nAnd therefore deleting it when going out of scpope of the sort() function.\nAs well any algorithm, or function of your own that are able to take your container as parameter, and copy one of its object on the stack will cause this issue as a result.</p>\n<p>Well in your case, it is simple you must ensure your class does not behaves as an auto_ptr, or ensure you will never call such function/algorithm that can delete your underlying objects. The first solution is best, according to me :)</p>\n<p>So your copy constructor and your affectation operator as well, should not give away property of the pointer object.</p>\n<p>The best way to achieve that is to wrapp a boost smart pointer instead of an auto_ptr, to make your container safe when calling such function/algorithm.</p>\n<p>By the way according to me, defining a better copy constructor/affectation operator to bypass this issue is not a good solution: I can't see a good copy constructor implementation (and affectation operator as well) that could keep safe the result of applying the sort() algorithm.</p>\n", "CreationDate": "2009-03-31T09:00:52.270", "ParentId": "700588", "CommentCount": "0", "LastEditDate": "2009-03-31T13:21:44.577", "PostTypeId": "2", "LastEditorDisplayName": "yves Baumes", "LastActivityDate": "2009-03-31T13:21:44.577", "LastEditorUserId": "83331", "Id": "700667", "OwnerDisplayName": "yves Baumes", "Score": "1", "OwnerUserId": "83331"}, "700615": {"Id": "700615", "PostTypeId": "2", "Body": "<p>Copying MyClass object will cause either call to assignment operator or copy constructor. If they are not overloaded to handle auto_ptr&lt;&gt; in unusual way, they will propagate the call to copy constructor (or assignment operator) to the auto_ptr&lt;&gt; member. This may lead to problems described in question you had linked.</p>\n", "OwnerDisplayName": "anon", "LastActivityDate": "2009-03-31T08:45:49.797", "Score": "1", "CreationDate": "2009-03-31T08:43:35.073", "ParentId": "700588", "CommentCount": "0"}, "700643": {"Id": "700643", "PostTypeId": "2", "Body": "<p>It will not work. auto_ptr doesn't count references which means at the first destructor call your pointer will be freed. </p>\n<p>Use boost::shared_ptr instead.</p>\n", "OwnerDisplayName": "Edouard A.", "LastActivityDate": "2009-03-31T08:52:29.920", "Score": "0", "CreationDate": "2009-03-31T08:52:29.920", "ParentId": "700588", "CommentCount": "0", "OwnerUserId": "41363"}});