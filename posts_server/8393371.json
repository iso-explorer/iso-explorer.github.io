post_cb({"8393371": {"CommentCount": "15", "AcceptedAnswerId": "8490060", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-12-05T23:27:22.957", "LastActivityDate": "2012-05-06T08:38:44.863", "LastEditDate": "2017-05-23T12:34:51.097", "ViewCount": "981", "FavoriteCount": "4", "Title": "Is it possible trigger a compiler / linker error if a template has not been instantiated with a certain type?", "Id": "8393371", "Score": "17", "Body": "<p>Follow-up question to <a href=\"https://stackoverflow.com/questions/8379002/does-a-casting-to-a-pointer-to-a-template-instantiate-that-template\">[Does casting to a pointer to a template instantiate that template?]</a>.</p>\n<p>The question is just as the title says, with the rest of the question being constraints and usage examples of the class template, aswell as my tries to achieve the goal.</p>\n<p>An important constraint: The user instantiates the template by subclassing my class template (and not through explicitly instantiating it like in my tries below). As such, it is important to me that, if possible, the user doesn't need to do any extra work. Just subclassing and it should work (the subclass actually registers itself in a dictionary already without the user doing anything other than subclassing an additional class template with CRTP and the subclass is never directly used by the user who created it). I am willing to accept answers where the user needs to do extra work however (like deriving from an additional base), if there really is no other way.</p>\n<hr>\n<p>A code snippet to explain how the class template is going to be used:</p>\n<pre><code>// the class template in question\ntemplate&lt;class Resource&gt;\nstruct loader\n{\n  typedef Resource res_type;\n  virtual res_type load(std::string const&amp; path) const = 0;\n  virtual void unload(res_type const&amp; res) const = 0;\n};\n\ntemplate&lt;class Resource, class Derived&gt;\nstruct implement_loader\n  : loader&lt;Resource&gt;\n  , auto_register_in_dict&lt;Derived&gt;\n{\n};\n\ntemplate&lt;class Resource&gt;\nResource load(std::string const&amp; path){\n  // error should be triggered here\n  check_loader_instantiated_with&lt;Resource&gt;();\n\n  // search through resource cache\n  // ...\n\n  // if not yet loaded, load from disk\n  // loader_dict is a mapping from strings (the file extension) to loader pointers\n  auto loader_dict = get_all_loaders_for&lt;Resource&gt;();\n  auto loader_it = loader_dict.find(get_extension(path))\n  if(loader_it != loader_dict.end())\n    return (*loader_it)-&gt;load(path);\n  // if not found, throw some exception saying that\n  // no loader for that specific file extension was found\n}\n\n// the above code comes from my library, the code below is from the user\n\nstruct some_loader\n  : the_lib::implement_loader&lt;my_fancy_struct, some_loader&gt;\n{\n  // to be called during registration of the loader\n  static std::string extension(){ return \"mfs\"; }\n  // override the functions and load the resource\n};\n</code></pre>\n<p>And now in tabular form:</p>\n<ul>\n<li>User calls <code>the_lib::load&lt;my_fancy_struct&gt;</code> with a resource path</li>\n<li>Inside <code>the_lib::load&lt;my_fancy_struct&gt;</code>, if the resource identified by the path isn't cached already, I load it from disk</li>\n<li>The specific <code>loader</code> to be used in this case is created at startup time and saved in a dictionary</li>\n<li>There is a dictionary for every resource type, and they map [file extension -&gt; <code>loader</code> pointer]</li>\n<li>If the dictionary is empty, the user either\n\n<ul>\n<li>didn't create a loader for that specific extension or</li>\n<li>didn't create a loader for that specific resource</li>\n</ul></li>\n<li>I only want the first case to have me throw a runtime exception</li>\n<li>The second case should be detected at compile / link time, since it involves templates</li>\n</ul>\n<p><strong>Rationale:</strong> I'm heavily in favor of early errors and if possible I want to detect as many errors as possible before runtime, i.e. at compile and link time. Since checking if a loader for that resource exists would only involve templates, I hope it's possible to do this.</p>\n<hr>\n<p>The goal in my tries: Trigger a linker error on the call to <code>check_error&lt;char&gt;</code>.</p>\n<pre><code>// invoke with -std=c++0x on Clang and GCC, MSVC10+ already does this implicitly\n#include &lt;type_traits&gt;\n\n// the second parameter is for overload resolution in the first test\n// literal '0' converts to as well to 'void*' as to 'foo&lt;T&gt;*'\n// but it converts better to 'int' than to 'long'\ntemplate&lt;class T&gt;\nvoid check_error(void*, long = 0);\n\ntemplate&lt;class T&gt;\nstruct foo{\n  template&lt;class U&gt;\n  friend typename std::enable_if&lt;\n    std::is_same&lt;T,U&gt;::value\n  &gt;::type check_error(foo&lt;T&gt;*, int = 0){}\n};\n\ntemplate struct foo&lt;int&gt;;\n\nvoid test();\n\nint main(){ test(); }\n</code></pre>\n<p>Given the above code, the following <code>test</code> definition does achieve the goal for MSVC, GCC 4.4.5 and <a href=\"http://ideone.com/7FRrU\" rel=\"nofollow noreferrer\">GCC 4.5.1</a>:</p>\n<pre><code>void test(){\n  check_error&lt;int&gt;(0, 0); // no linker error\n  check_error&lt;char&gt;(0, 0); // linker error for this call\n}\n</code></pre>\n<p>However, it should not do that, as passing a null pointer does not trigger ADL. Why is ADL needed? Because the standard says so:</p>\n<p><code>\u00a77.3.1.2 [namespace.memdef] p3</code></p>\n<blockquote>\n<p id=\"so_8393371_8393371_0\">[...] If a <code>friend</code> declaration in a nonlocal class first declares a class or function the friend class or function is a member of the innermost enclosing namespace. <strong>The name of the friend is not found by unqualified lookup or by qualified lookup until a matching declaration is provided in that namespace scope</strong> (either before or after the class definition granting friendship). [...]</p>\n</blockquote>\n<p>Triggering ADL through a cast, as in the following definition of <code>test</code>, achieves the goal on Clang 3.1 and GCC 4.4.5, but <a href=\"http://ideone.com/0kAMz\" rel=\"nofollow noreferrer\">GCC 4.5.1 already links fine</a>, as does MSVC10:</p>\n<pre><code>void test(){\n  check_error&lt;int&gt;((foo&lt;int&gt;*)0);\n  check_error&lt;char&gt;((foo&lt;char&gt;*)0);\n}\n</code></pre>\n<p>Sadly, GCC 4.5.1 and MSVC10 have the correct behaviour here, as discussed in the linked question and specifically <a href=\"https://stackoverflow.com/a/8383216/500104\">this answer</a>.</p>\n</hr></hr>", "Tags": "<c++><templates><casting><compiler-errors><c++11>", "OwnerUserId": "500104", "AnswerCount": "3"}, "8490242": {"ParentId": "8393371", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>The compiler instatiates a template function whenever it is referenced and a full specification of the template is available. If none is available, the compiler doesn't and hopes that some other translation unit will instantiate it. The same is true for, say, the default constructor of your base class.</p>\n<p>File header.h:</p>\n<pre><code>template&lt;class T&gt;\nclass Base\n{\npublic:\n   Base();\n};\n\n#ifndef OMIT_CONSTR\ntemplate&lt;class T&gt;\nBase&lt;T&gt;::Base() { }\n#endif\n</code></pre>\n<p>File client.cc:</p>\n<pre><code>#include \"header.h\"\n\nclass MyClass : public Base&lt;int&gt;\n{\n};\n\n\nint main()\n{\n   MyClass a;\n   Base&lt;double&gt; b;\n}\n</code></pre>\n<p>File check.cc:</p>\n<pre><code>#define OMIT_CONSTR\n#include \"header.h\"\n\nvoid checks()\n{\n   Base&lt;int&gt; a;\n   Base&lt;float&gt; b;\n}\n</code></pre>\n<p>Then:</p>\n<pre><code> $ g++ client.cc check.cc\n/tmp/cc4X95rY.o: In function `checks()':\ncheck.cc:(.text+0x1c): undefined reference to `Base&lt;float&gt;::Base()'\ncollect2: ld returned 1 exit status\n</code></pre>\n<p>EDIT:\n(trying to apply this to the concrete example)</p>\n<p>I'll call this file \"loader.h\":</p>\n<pre><code>template&lt;class Resource&gt;\nstruct loader{\n  typedef Resource res_type;\n  virtual res_type load(std::string const&amp; path) const = 0;\n  virtual void unload(res_type const&amp; res) const = 0;\n\n  loader();\n};\n\ntemplate&lt;class Resource&gt;\nclass check_loader_instantiated_with : public loader&lt;Resource&gt; {\n  virtual Resource load(std::string const&amp; path) const { throw 42; }\n  virtual void unload(Resource const&amp; res) const { }\n};\n\ntemplate&lt;class Resource&gt;\nResource load(std::string const&amp; path){\n  // error should be triggered here\n  check_loader_instantiated_with&lt;Resource&gt; checker;\n  // ...\n}\n</code></pre>\n<p>And another file, \"loader_impl.h\":</p>\n<pre><code>#include \"loader.h\"\ntemplate&lt;class Resource&gt;\nloader&lt;Resource&gt;::loader() { }\n</code></pre>\n<p>This solution has one weak point that I know of. Each compilation unit has a choice of including either only loader.h or loader_impl.h. You can only define loaders in compilation units that include loader_impl, and in those compilation units, the error checking is disabled for all loaders.</p>\n", "OwnerUserId": "317562", "LastEditorUserId": "317562", "LastEditDate": "2011-12-13T22:19:58.810", "Id": "8490242", "Score": "3", "CreationDate": "2011-12-13T13:45:18.057", "LastActivityDate": "2011-12-13T22:19:58.810"}, "bq_ids": {"n4140": {"so_8393371_8393371_0": {"section_id": 5485, "quality": 0.8611111111111112, "length": 31}}, "n3337": {"so_8393371_8393371_0": {"section_id": 5271, "quality": 0.9722222222222222, "length": 35}}, "n4659": {"so_8393371_8393371_0": {"section_id": 6920, "quality": 0.8611111111111112, "length": 31}}}, "8406594": {"ParentId": "8393371", "PostTypeId": "2", "CommentCount": "7", "Body": "<pre><code>template &lt;class T&gt;\nclass Wrapper {};\n\nvoid CheckError(Wrapper&lt;int&gt; w);\n\ntemplate &lt;class T&gt;\nclass GenericCheckError\n{\npublic:\n    GenericCheckError()\n    {\n        Wrapper&lt;T&gt; w;\n        CheckError(w); \n    }\n};\n\nint main()\n{\n    GenericCheckError&lt;int&gt; g1; // this compiles fine\n    GenericCheckError&lt;char&gt; g2; // this causes a compiler error because Wrapper&lt;char&gt; != Wrapper&lt;int&gt;\n    return 0;\n}\n</code></pre>\n<p>Edit:</p>\n<p>Alright this is as close as I can get. If they subclass and either instantiate OR define a constructor that calls the parent's constructor, they will get a compiler error with the wrong type. Or if the child class is templatized and they subclass and instantiate with the wrong type, they will get a compiler error.</p>\n<pre><code>template &lt;class T&gt; class Wrapper {};\nvoid CheckError(Wrapper&lt;int&gt; w) {}\n\ntemplate &lt;class T&gt;\nclass LimitedTemplateClass\n{\npublic:\n    LimitedTemplateClass()\n    {\n        Wrapper&lt;T&gt; w;\n        CheckError(w);\n    }\n};\n\n// this causes no compiler error\nclass UserClass : LimitedTemplateClass&lt;int&gt;\n{\n    UserClass() : LimitedTemplateClass&lt;int&gt;() {}\n};\n\n// this alone (no instantiation) causes a compiler error\nclass UserClass2 : LimitedTemplateClass&lt;char&gt;\n{\n    UserClass2() : LimitedTemplateClass&lt;char&gt;() {}\n};\n\n// this causes no compiler error (until instantiation with wrong type)\ntemplate &lt;class T&gt;\nclass UserClass3 : LimitedTemplateClass&lt;T&gt;\n{\n};\n\nint main()\n{\n    UserClass u1; // this is fine\n    UserClass2 u2; // this obviously won't work because this one errors after subclass declaration\n    UserClass3&lt;int&gt; u3; // this is fine as it has the right type\n    UserClass3&lt;char&gt; u4; // this one throws a compiler error\n    return 0;\n}\n</code></pre>\n<p>Obviously you can add other accepted types by defining additional CheckError functions with those types. </p>\n", "OwnerUserId": "710360", "LastEditorUserId": "710360", "LastEditDate": "2011-12-06T21:31:43.513", "Id": "8406594", "Score": "1", "CreationDate": "2011-12-06T20:45:24.963", "LastActivityDate": "2011-12-06T21:31:43.513"}, "8490060": {"ParentId": "8393371", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>After thinking a bit about your problem, I don't see any way to achieve this. You need a way to make the instantiation \"export\" something outside the template so that it can be accessed without referencing the instantiation. A <code>friend</code> function with ADL was a good idea, but unfortunately it was shown that <a href=\"https://stackoverflow.com/a/8383216/20984\">for ADL to work, the template had to be instantiated</a>. I tried to find another way to \"export\" something from the template, but failed to find one.</p>\n<p>The usual solution to your problem is to have the user specializes a trait class:</p>\n<pre><code>template &lt; typename Resource &gt;\nstruct has_loader : boost::mpl::false_ {};\n\ntemplate &lt;&gt;\nstruct has_loader&lt; my_fancy_struct &gt; : boost::mpl::true_ {};\n</code></pre>\n<p>To hide this from the user, you could provide a macro:</p>\n<pre><code>#define LOADER( loaderName, resource ) \\\ntemplate &lt;&gt; struct has_loader&lt; resource &gt; : boost::mpl::true_ {}; \\\nclass loaderName \\\n  : the_lib::loader&lt; resource &gt; \\\n  , the_lib::auto_register_in_dict&lt; loaderName &gt;\n\nLOADER( some_loader, my_fancy_struct )\n{\n  public:\n    my_fancy_struct load( std::string const &amp; path );\n};\n</code></pre>\n<p>It is up to you to determine whether having this macro is acceptable or not.</p>\n", "OwnerUserId": "20984", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:29:40.617", "Id": "8490060", "Score": "2", "CreationDate": "2011-12-13T13:29:18.180", "LastActivityDate": "2011-12-13T13:29:18.180"}});