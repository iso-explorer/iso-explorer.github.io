post_cb({"24152599": {"ParentId": "24152435", "CommentCount": "6", "Body": "<p>One use that I can think of is the return of zero length arrays is possible and has functionality to be checked specifically. </p>\n<p>For example see the documentation on the <code>std::array</code> function <code>empty()</code>. It has the following return value:</p>\n<pre><code>true if the array size is 0, false otherwise.\n</code></pre>\n<p><a href=\"http://www.cplusplus.com/reference/array/array/empty/\" rel=\"nofollow\">http://www.cplusplus.com/reference/array/array/empty/</a></p>\n<p>I think the ability to return and check for 0 length arrays is in line with the standard for other implementations of stl types, for eg. Vectors and maps and is therefore useful.</p>\n", "OwnerUserId": "1294207", "PostTypeId": "2", "Id": "24152599", "Score": "4", "CreationDate": "2014-06-10T23:46:41.190", "LastActivityDate": "2014-06-10T23:46:41.190"}, "24156329": {"ParentId": "24152435", "CommentCount": "0", "Body": "<p>As with other container classes, it is useful to be able to have an object that represents an array of things, and to have it possible for that array to be or become empty. If that were not possible, then one would need to create another object, or a managing class, to represent that state in a legal way. Having that ability already contained in all container classes, is very helpful. In using it, one then just needs to be in the habit of relating to the array as a container that might be empty, and checking the size or index before referring to a member of it in cases where it might not point to anything.</p>\n", "OwnerUserId": "471736", "PostTypeId": "2", "Id": "24156329", "Score": "1", "CreationDate": "2014-06-11T06:47:59.850", "LastActivityDate": "2014-06-11T06:47:59.850"}, "24152608": {"ParentId": "24152435", "CommentCount": "0", "Body": "<p>If you have a generic function it is bad if that function randomly breaks for special parameters. For example, lets say you could have a template function that takes <code>N</code> random elements form a vector:</p>\n<pre><code>template&lt;typename T, size_t N&gt;\nstd::array&lt;T, N&gt; choose(const std::vector&lt;T&gt; &amp;v) {\n   ...\n}\n</code></pre>\n<p>Nothing is gained if this causes undefined behavior or compiler errors if <code>N</code> for some reason turns out to be zero. </p>\n<p>For raw arrays a reason behind the restriction is that you don't want types with <code>sizeof T == 0</code>, this leads to strange effects in combination with pointer arithmetic. An array with zero elements would have size zero, if you don't add any special rules for it.</p>\n<p>But <code>std::array&lt;&gt;</code> is a class, and classes always have size &gt; 0. So you don't run into those problems with <code>std::array&lt;&gt;</code>, and a consistent interface without an arbitrary restriction of the template parameter is preferable.</p>\n", "OwnerUserId": "56338", "PostTypeId": "2", "Id": "24152608", "Score": "40", "CreationDate": "2014-06-10T23:47:37.393", "LastActivityDate": "2014-06-10T23:47:37.393"}, "24158017": {"ParentId": "24152435", "CommentCount": "0", "Body": "<p>There are actually quite a few cases where you want to be able to do this. It's present in a lot of other languages too. For example Java actually has <code>Collections.emptyList()</code> which returns a list which is not only size zero but cannot be expanded or resized or modified.</p>\n<p>An example usage might be if you had a class representing a bus and a list of passengers within that class. The list might be lazy initialized, only created when passengers board. If someone calls <code>getPassengers()</code> though then an empty list can be returned rather than creating a new list each time just to report empty.</p>\n<p>Returning null would also work for the internal efficiency of the class - but would then make life a lot more complicated for everyone using the class since whenever you call <code>getPassengers()</code> you would need to null check the result. Instead if you get an empty list back then so long as your code doesn't make assumptions that the list is not empty you don't need any special code to handle it being null.</p>\n", "OwnerUserId": "3049628", "PostTypeId": "2", "Id": "24158017", "Score": "1", "CreationDate": "2014-06-11T08:23:35.770", "LastActivityDate": "2014-06-11T08:23:35.770"}, "bq_ids": {"n4140": {"so_24152435_24152435_3": {"section_id": 790, "quality": 0.8571428571428571, "length": 6}, "so_24152435_24152435_2": {"section_id": 789, "quality": 0.625, "length": 5}, "so_24152435_24152435_0": {"section_id": 787, "quality": 0.8, "length": 4}, "so_24152435_24152435_1": {"section_id": 788, "quality": 0.8, "length": 8}}, "n3337": {"so_24152435_24152435_3": {"section_id": 777, "quality": 0.8571428571428571, "length": 6}, "so_24152435_24152435_2": {"section_id": 776, "quality": 0.625, "length": 5}, "so_24152435_24152435_0": {"section_id": 774, "quality": 0.8, "length": 4}, "so_24152435_24152435_1": {"section_id": 775, "quality": 0.8, "length": 8}}, "n4659": {"so_24152435_24152435_3": {"section_id": 851, "quality": 0.5714285714285714, "length": 4}, "so_24152435_24152435_2": {"section_id": 850, "quality": 0.625, "length": 5}, "so_24152435_24152435_0": {"section_id": 848, "quality": 0.8, "length": 4}, "so_24152435_24152435_1": {"section_id": 849, "quality": 0.8, "length": 8}}}, "24152435": {"CommentCount": "10", "AcceptedAnswerId": "24152608", "PostTypeId": "1", "LastEditorUserId": "16287", "CreationDate": "2014-06-10T23:26:23.883", "LastActivityDate": "2017-05-10T03:23:29.740", "LastEditDate": "2017-05-10T03:23:29.740", "ViewCount": "2900", "FavoriteCount": "3", "Title": "Is there a reason for zero sized std::array in C++11?", "Id": "24152435", "Score": "37", "Body": "<p>Consider the following piece of code, which is perfectly acceptable by a C++11 compiler:</p>\n<pre><code>#include &lt;array&gt;\n#include &lt;iostream&gt;\n\nauto main() -&gt; int {\n  std::array&lt;double, 0&gt; A;\n\n  for(auto i : A) std::cout &lt;&lt; i &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>\n<p>According to the standard \u00a7 23.3.2.8 [<em>Zero sized arrays</em>]:</p>\n<blockquote>\n<p id=\"so_24152435_24152435_0\"><code>1</code> Array shall provide support for the special case <code>N == 0</code>.</p>\n<p id=\"so_24152435_24152435_1\"><code>2</code> In the case that <code>N == 0</code>, <code>begin() == end() ==</code> unique value. The return value of<br>\n<code>data()</code> is unspeci\ufb01ed.</br></p>\n<p id=\"so_24152435_24152435_2\"><code>3</code> The e\ufb00ect of calling <code>front()</code> or <code>back()</code> for a zero-sized array is unde\ufb01ned.</p>\n<p id=\"so_24152435_24152435_3\"><code>4</code> Member function <code>swap()</code> shall have a noexcept-speci\ufb01cation which is equivalent to \n     <code>noexcept(true)</code>.</p>\n</blockquote>\n<p>As displayed above, zero sized <code>std::array</code>s are perfectly allowable in C++11, in contrast with zero sized arrays (e.g., <code>int A[0];</code>) where they are explicitly forbidden, yet they are allowed by some compilers (e.g., GCC) in the cost of undefined behaviour. </p>\n<p>Considering this \"contradiction\", I have the following questions:</p>\n<ul>\n<li><p>Why the C++ committee decided to allow zero sized <code>std::array</code>s?</p></li>\n<li><p>Are there any valuable uses? </p></li>\n</ul>\n", "Tags": "<c++><arrays><c++11><c++14><stdarray>", "OwnerUserId": "2352671", "AnswerCount": "4"}});