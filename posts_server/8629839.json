post_cb({"8629943": {"ParentId": "8629839", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>I suspect that all those functions are free functions. When you declare a free function <code>static</code>, it gains internal linkage. Non-type template parameters, in C++03, <em>must</em> have external linkage<sup>\u2020</sup>. Just remove <code>static</code> in front of the functions.</p>\n<pre><code>template &lt;\n    bool src_alpha,\n    int sbpp, int dbpp,\n    typename T1, typename T2,\n    char (*getFunc)(T1 data, unsigned* addr),\n    void (*putFunc)(T2 data, unsigned* addr, char c)\n&gt;\nvoid OperateOnSurfaces(){}\n\ntemplate&lt;bool alpha, int bpp&gt;\nchar GetPixel(void* format, unsigned* addr);\n\ntemplate&lt;bool alpha, bool alphablend, int bpp&gt;\nvoid PutPixel(void* format, unsigned* addr, char col);\n\nint main(){\n    OperateOnSurfaces&lt;\n        true,\n        32, 32,\n        void*, void*,\n        GetPixel&lt;true,32&gt;, PutPixel&lt;true,true,32&gt; &gt;();\n}\n</code></pre>\n<p>This modified example compiles fine on Clang 3.1 and GCc 4.4.5 in C++98 and C++11 mode, no warnings. If I leave the <code>static</code> in, I get a similar error + note to what you got with Clang, and GCC spits out the vital information (scroll to the right, \"has not external linkage\"):</p>\n<pre><code>15:02:38 $ g++ t.cpp\nt.cpp: In function \u2018int main()\u2019:\nt.cpp:21: error: \u2018GetPixel&lt;true, 32&gt;\u2019 is not a valid template argument for type \u2018char (*)(void*, unsigned int*)\u2019 because function \u2018char GetPixel(void*, unsigned int*) [with bool alpha = true, int bpp = 32]\u2019 has not external linkage\nt.cpp:21: error: \u2018PutPixel&lt;true, true, 32&gt;\u2019 is not a valid template argument for type \u2018void (*)(void*, unsigned int*, char)\u2019 because function \u2018void PutPixel(void*, unsigned int*, char) [with bool alpha = true, bool alphablend = true, int bpp = 32]\u2019 has not external linkage\nt.cpp:21: error: no matching function for call to \u2018OperateOnSurfaces()\u2019\n</code></pre>\n<hr>\n<p>\u2020 <code>(C++03) \u00a714.3.2 [temp.arg.nontype] p1</code></p>\n<blockquote>\n<p id=\"so_8629839_8629943_0\">A <em>template-argument</em> for a non-type, non-template <em>template-parameter</em> shall be one of:</p>\n<ul>\n<li><p id=\"so_8629839_8629943_1\">[...]</p></li>\n<li><p id=\"so_8629839_8629943_2\"><strong>the address of an object or function <em>with external linkage</em></strong> [...]</p></li>\n<li><p id=\"so_8629839_8629943_3\">[...]</p></li>\n</ul>\n</blockquote>\n<p>Note that C++11 changed the wording and allows functions with internal linkage too now:</p>\n<p><code>(C++11) \u00a714.3.2 [temp.arg.nontype] p1</code></p>\n<blockquote>\n<p id=\"so_8629839_8629943_4\">A <em>template-argument</em> for a non-type, non-template <em>template-parameter</em> shall be one of:</p>\n<ul>\n<li><p id=\"so_8629839_8629943_5\">[...]</p></li>\n<li><p id=\"so_8629839_8629943_6\">a constant expression (5.19) that designates the address of an object with static storage duration and external or internal linkage <strong>or a function with external <em>or internal linkage</em></strong> [...]</p></li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>Clang does currently not obey to this in C++11 mode, it still only allows functions with external linkage.</p>\n</hr>", "OwnerUserId": "500104", "LastEditorUserId": "500104", "LastEditDate": "2011-12-25T14:19:21.933", "Id": "8629943", "Score": "6", "CreationDate": "2011-12-25T14:07:11.310", "LastActivityDate": "2011-12-25T14:19:21.933"}, "8629839": {"CommentCount": "9", "ViewCount": "5203", "PostTypeId": "1", "LastEditorUserId": "133374", "CreationDate": "2011-12-25T13:39:30.087", "LastActivityDate": "2011-12-25T14:19:21.933", "Title": "C++: candidate template ignored: invalid explicitly-specified argument for template parameter", "AcceptedAnswerId": "8629943", "LastEditDate": "2011-12-25T13:56:39.357", "Id": "8629839", "Score": "4", "Body": "<p>I have this function header:</p>\n<pre><code>template &lt;\n    bool src_alpha,\n    int sbpp, int dbpp,\n    typename T1, typename T2,\n    Color (*getFunc)(T1 data, Uint8* addr),\n    void (*putFunc)(T2 data, Uint8* addr, Color c)\n&gt;\nstatic void OperateOnSurfaces(T1 data1, T2 data2, SDL_Surface * bmpDest, SDL_Surface * bmpSrc, SDL_Rect&amp; rDest, SDL_Rect&amp; rSrc)\n</code></pre>\n<p>This is how I use it:</p>\n<pre><code>OperateOnSurfaces&lt;\n    true,\n    32, 32,\n    SDL_PixelFormat*, SDL_PixelFormat*,\n    GetPixel&lt;true,32&gt;, PutPixel&lt;true,true,32&gt; &gt;(\n    bmpSrc-&gt;format, bmpDest-&gt;format,\n    bmpDest, bmpSrc, rDest, rSrc);\n</code></pre>\n<p>This is <code>GetPixel</code> and <code>PutPixel</code>:</p>\n<pre><code>template&lt;bool alpha, int bpp&gt;\nstatic Color GetPixel(SDL_PixelFormat* format, Uint8* addr) { /* .. */ }\n\ntemplate&lt;bool alpha, bool alphablend, int bpp&gt;\nstatic void PutPixel(SDL_PixelFormat* format, Uint8* addr, Color col) { /* .. */ }\n</code></pre>\n<p>And I get this error:</p>\n<p><code>note: candidate template ignored: invalid explicitly-specified argument for template parameter 'getFunc' [3]</code></p>\n<p>Why?</p>\n", "Tags": "<c++><templates><template-function>", "OwnerUserId": "133374", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_8629839_8629943_4": {"section_id": 87, "quality": 1.0, "length": 5}, "so_8629839_8629943_6": {"section_id": 87, "quality": 0.9375, "length": 15}, "so_8629839_8629943_0": {"section_id": 87, "quality": 1.0, "length": 5}, "so_8629839_8629943_2": {"section_id": 87, "quality": 1.0, "length": 5}}, "n3337": {"so_8629839_8629943_4": {"section_id": 82, "quality": 1.0, "length": 5}, "so_8629839_8629943_6": {"section_id": 82, "quality": 0.9375, "length": 15}, "so_8629839_8629943_0": {"section_id": 82, "quality": 1.0, "length": 5}, "so_8629839_8629943_2": {"section_id": 82, "quality": 1.0, "length": 5}}, "n4659": {"so_8629839_8629943_2": {"section_id": 6853, "quality": 0.8, "length": 4}}}});