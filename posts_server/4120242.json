post_cb({"4120429": {"ParentId": "4120242", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>This behavior is defined in <a href=\"http://www.lcdf.org/c++/clause8.html#s8.3.6\" rel=\"nofollow\">\u00a7 8.3.6</a> 5 of c++03: </p>\n<blockquote>\n<p id=\"so_4120242_4120429_0\">A default argument expression is implicitly converted (<a href=\"http://www.lcdf.org/c++/clause4.html\" rel=\"nofollow\">clause 4</a>) to the parameter type. The default argument expression has the same semantic constraints as the initializer expression in a declaration of a variable of the parameter type, using the copy-initialization semantics (<a href=\"http://www.lcdf.org/c++/clause8.html#s8.5\" rel=\"nofollow\">8.5</a>).</p>\n</blockquote>\n<p>That is, <code>const Type&amp; var = val</code> is a valid parameter declaration only if it's also a valid variable declaration. According to <a href=\"http://www.lcdf.org/c++/clause8.html#s8.5.3\" rel=\"nofollow\">\u00a7 8.5.3</a> 5, it is. For <code>const Allocator&amp; = Allocator()</code>, the following applies:</p>\n<blockquote>\n<ul>\n<li>Otherwise, the reference shall be to a non-volatile const type (i.e., <i>cv1</i> shall be const). [...]\n      <ul>\n<li><p id=\"so_4120242_4120429_1\">If the initializer expression is an rvalue, with <b>T2</b> a class type, and \"<i>cv1</i> <b>T1</b>\" is reference-compatible with \"<i>cv2</i> <b>T2</b>,\" the reference is bound in one of the following ways (the choice is implementation defined):</p>\n<ul>\n<li>The reference is bound to the object represented by the rvalue (see <a href=\"http://www.lcdf.org/c++/clause3.html#s3.10\" rel=\"nofollow\">3.10</a>) or to a sub-object within that object.</li>\n<li>A temporary of type \"<i>cv2</i> <b>T2</b>\" [sic] is created, and a constructor is called to copy the entire rvalue object into the temporary. The reference is bound to the temporary or to a sub-object within the temporary.</li>\n</ul>\n<p id=\"so_4120242_4120429_2\">The constructor that would be used to make the copy shall be callable whether or not the copy is actually done. [...]</p>\n</li>\n<li><p id=\"so_4120242_4120429_3\">Otherwise, [...]</p></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>For <code>const int&amp; iValue=5</code>, the next case applies:</p>\n<blockquote>\n<ul>\n<li>Otherwise, the reference shall be to a non-volatile const type (i.e., <i>cv1</i> shall be const). [...]\n      <ul>\n<li><p id=\"so_4120242_4120429_4\">If the initializer expression is an rvalue[...]</p></li>\n<li><p id=\"so_4120242_4120429_5\">Otherwise, a temporary of type \"<i>cv1</i> <b>T1</b>\" is created and initialized from the initializer expression using the rules for a non-reference copy initialization (<a href=\"http://www.lcdf.org/c++/clause8.html#s8.5\" rel=\"nofollow\">8.5</a>). The reference is then bound to the temporary. If <b>T1</b> is reference-related to <b>T2</b>, <i>cv1</i> must be the same cv-qualification as, or greater cv-qualification than, <i>cv2</i>; otherwise, the program is ill-formed. [Example:\n<pre>\n          const double&amp; rcd2 = 2;         // rcd2  refers to temporary with value 2.0\n          const volatile int cvi = 1;\n          const int&amp; r = cvi;             //  error: type qualifiers dropped\n</pre>\n---end example]\n        </p></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>In short, a real, though perhaps temporary, variable is created so the reference can refer to it. It's allowed in parameter declarations exactly so that reference parameters can take default values. Otherwise, it would be a needless restriction. The more <a href=\"http://mindprod.com/jgloss/orthogonal.html\" rel=\"nofollow\">orthogonal</a> a language is, the easier it is to keep in your head, as you don't need to remember as many exceptions to the rules (though, arguably, allowing const references but not non-const references to be bound to rvalues is less orthogonal than disallowing any reference to be bound to an rvalue).</p>\n", "OwnerUserId": "90527", "LastEditorUserId": "90527", "LastEditDate": "2010-11-08T00:21:19.830", "Id": "4120429", "Score": "2", "CreationDate": "2010-11-08T00:15:35.057", "LastActivityDate": "2010-11-08T00:21:19.830"}, "4120242": {"CommentCount": "3", "ViewCount": "7414", "PostTypeId": "1", "LastEditorUserId": "229044", "CreationDate": "2010-11-07T23:15:22.827", "LastActivityDate": "2010-11-08T00:21:19.830", "Title": "Function takes a reference parameter with a default value", "AcceptedAnswerId": "4120256", "LastEditDate": "2010-11-07T23:24:04.483", "Id": "4120242", "Score": "3", "Body": "<p>Based on \n<a href=\"http://www.cplusplus.com/reference/stl/vector/vector/\" rel=\"nofollow\">http://www.cplusplus.com/reference/stl/vector/vector/</a></p>\n<pre><code>explicit vector ( const Allocator&amp; = Allocator() );\n</code></pre>\n<p>This vector constructor takes a reference parameter which has default value of Allocator(). What I learn from this function signature is that a function can take a reference parameter with default value.</p>\n<p>This the demo code I play with VS2010.</p>\n<pre><code>#include \"stdafx.h\"\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid funA(const int&amp; iValue=5) // reference to a template const int 5 why?\n{\n    cout &lt;&lt; iValue &lt;&lt; endl;\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    funA();\n    funA(10);\n    return 0;\n}\n</code></pre>\n<p>are there some rules to guide this syntax usage (i.e. a reference parameter with a default value)?</p>\n", "Tags": "<c++>", "OwnerUserId": "391104", "AnswerCount": "3"}, "4120256": {"ParentId": "4120242", "CommentCount": "9", "Body": "<p>Const references may be bound to temporary objects, in which case the lifetime of the temporary extends to the lifetime of the reference.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "4120256", "Score": "12", "CreationDate": "2010-11-07T23:19:27.480", "LastActivityDate": "2010-11-07T23:19:27.480"}, "4120433": {"ParentId": "4120242", "CommentCount": "0", "Body": "<p>The only rules I can think of are (a) that the reference must be const, because you can't bind a non-const reference to a temporary, and (b) that it's generally better <em>not</em> to use const references to pass built-in types. In other words:</p>\n<p>(a)</p>\n<pre><code>void f(T&amp; t = T(23)) {} // bad\n\nvoid g(const T&amp; t = T(23)) {} // fine\n</code></pre>\n<p>(b)</p>\n<pre><code>void f(const int&amp; i = 23) {} // sort of ok\n\nvoid g(int i = 23) {} // better\n</code></pre>\n", "OwnerUserId": "499449", "PostTypeId": "2", "Id": "4120433", "Score": "2", "CreationDate": "2010-11-08T00:16:45.237", "LastActivityDate": "2010-11-08T00:16:45.237"}, "bq_ids": {"n4140": {"so_4120242_4120429_0": {"section_id": 3256, "quality": 0.5833333333333334, "length": 14}}, "n3337": {"so_4120242_4120429_0": {"section_id": 3128, "quality": 0.7916666666666666, "length": 19}}, "n4659": {"so_4120242_4120429_0": {"section_id": 4014, "quality": 0.5833333333333334, "length": 14}}}});