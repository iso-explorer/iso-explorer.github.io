post_cb({"bq_ids": {"n4140": {"so_31495877_31798593_0": {"length": 10, "quality": 1.0, "section_id": 5404}}, "n3337": {"so_31495877_31798593_0": {"length": 10, "quality": 1.0, "section_id": 5199}}, "n4659": {"so_31495877_31798593_0": {"length": 9, "quality": 0.9, "section_id": 6853}}}, "31798593": {"Id": "31798593", "PostTypeId": "2", "Body": "<p><strong>EDIT</strong>: This is a complete rewrite of the answer. With much more details.</p>\n<hr>\n<p>I think that this question deserves more elaborated answer. Especially that there are things that were not mentioned so far.</p>\n<p><strong>Dependency Walker</strong></p>\n<p>Let me start with referring to the \u201c<a href=\"http://www.dependencywalker.com/\" rel=\"nofollow noreferrer\">Dependency Walker</a>\u201d program.</p>\n<p>It is a nice program (although these days a bit old-schoolish in its look &amp; feel) that allows analyzing Windows binaries (both EXE and DLL) for symbols that they export/import and their own dependencies to other DLLs. Also it allows showing undecorated symbol names but this seems to be working only with MSVC build binaries. (And some more but that is not important here.)</p>\n<p>Thanks to this program crucial information (for this question) can be uncovered. So I encourage you to use it during experiments.</p>\n<p><strong>Exporting policy on Linux vs. Windows</strong></p>\n<p><a href=\"https://stackoverflow.com/a/31496055/422489\">SHR already pointed this out</a> but I will mention it also for completeness of the answer. And some extra details.</p>\n<p>On Linux every symbol gets exported from a shared library by default. On the other hand on Windows you have to explicitly state which symbols to export from a shared library.</p>\n<p>GCC seems however to provide some means of controlling exports in \"Windows style\". See for example <a href=\"https://gcc.gnu.org/wiki/Visibility\" rel=\"nofollow noreferrer\">Visibility entry on GCC Wiki</a>.</p>\n<p>Also note that there are various ways of exporting on both Linux and Windows. For example both seem to support exporting selectively by providing linker with a list of names for symbols to export. But it also seems that nowadays (on Windows at least) this isn't really used much. <code>__declspec</code> approach seems to be preferred.</p>\n<p><strong>What can be exported?</strong></p>\n<p>After that general introduction let's now stick to Windows case. Nowadays you export/import symbols from shared libraries by using the <code>__declspec</code>. Just as shown in the question. <em>(Well maybe not exactly that - typically you use a <code>#define</code> to handle bi-directionality as shown in already mentioned <a href=\"https://gcc.gnu.org/wiki/Visibility\" rel=\"nofollow noreferrer\">Visibility entry on GCC Wiki</a>.)</em></p>\n<p>But the declaration can be applied not only to functions, methods and global variables. It can also be applied to types. For example you can have:</p>\n<pre><code>class __declspec(dllexport) Counter { /* ... */ };\n</code></pre>\n<p>Such exporting/importing means in general that all members get exported/imported.</p>\n<p><strong><em>Not so easy!</em></strong></p>\n<p>But it would be too easy, wouldn't it? The complication is that GCC and MSVC handle exporting types differently.</p>\n<p>My notes here are based mostly on experiments (checks done using <a href=\"http://www.dependencywalker.com/\" rel=\"nofollow noreferrer\">Dependency Walker</a>) so I can be wrong or not precise enough. But I did observe differences in behavior.</p>\n<p>In tests I used MSVC 2013 from the Express Edition with update 5. For GCC I used <a href=\"http://nuwen.net/mingw.html\" rel=\"nofollow noreferrer\">MinGW distro from nuwen.net</a>, version 13.0.</p>\n<p>MSVC, when exporting entire type, exports each and every member. Including implicitly defined members (like compiler generated copy constructor). And including inlined functions. Furthermore if inlined function has some <code>static</code> local variables they get exported to (!).</p>\n<p>GCC on the other hand seems to be far more restrictive. It doesn't export implicitly defined members. Nor it doesn't export inlined members.</p>\n<p><strong><em>Exporting/Importing inline functions</em></strong></p>\n<p>If instead of exporting entire type you would explicitly export an inlined function then and only then will GCC really export it. But still it will not export <code>static</code> local variables in that function.</p>\n<p>Further more if you try to import an inlined function GCC will error. With GCC you cannot define symbols that you are importing. And this happens when you import inlined (and so defined) symbol. So in fact it doesn't make any sense to export inlined functions with GCC.</p>\n<p>MSVC allows to import inlined functions. In all cases I checked it didn't seem to actually inline the function but instead called the imported version.</p>\n<p>Yet note that because MSVC in case of inlined function exports also its <code>static</code> local variables it would be possible for it to really inline the function (rather than import it) while maintaining a single copy of <code>static</code> local variables. For ordinary programs such behavior is mandated by the Standard (N3337, C++11), in point 7.1.2 ([dcl.fct.spec]) at $4 we can read:</p>\n<blockquote>\n<p id=\"so_31495877_31798593_0\">(\u2026) A static local variable in an extern inline function always refers to the same object. (\u2026)</p>\n</blockquote>\n<p>But a program and a shared library are actually more like two programs so they are out of scope for the Standard. Yet MSVC even in that case acts (or better to say: could act) as one would expect from a single program.</p>\n<p><strong>Solution</strong></p>\n<p>Denis Bakhvalov <a href=\"https://stackoverflow.com/questions/31495877/i-receive-different-results-on-unix-and-win-when-use-static-members-with-static/31798593#comment51013919_31496055\">in a comment</a> provided solution for his own question. The solution is to move <code>getCount</code> function from header to source file and export/import it.</p>\n<p>This seems to be the only solution portable between GCC and MSVC. Or to be more precise MSVC allows more solutions to this problem but none of them will work when program is build under GCC.</p>\n<p><strong><em>The variable trick</em></strong></p>\n<p>The above is not entirely true. There is another workaround that will work consistently between GCC and MSVC.</p>\n<p>This is to stop using <code>static</code> local variable. Instead make it a global variable (most likely by making it <code>static</code> variable in the <code>class</code>) and export it. This will make the trick as well.</p>\n<p>Sadly there is no way (or I don't know any) to directly force exporting/importing <code>static</code> local variables. You have to change them to global variables to do that.</p>\n<p><strong><em>MSVC solutions</em></strong></p>\n<p>With MSVC you have more options.</p>\n<p>As mentioned before exporting/importing the inlined function itself (whether directly or through type) will do the job.</p>\n<p><strong>Summary</strong></p>\n<p>As described above even consistency between GCC and MSVC on Windows only requires care. You have to limit yourself to stay in common subset of allowed solutions.</p>\n<p>Keeping the program (source) interoperable between Linux and Windows even if with same compiler (GCC) also requires care.</p>\n<p>Luckily there is a common subset for all three environments: GCC on Linux, GCC on Windows and MSVC on Windows. That common subset is described already by mentioned Denis' <a href=\"https://stackoverflow.com/questions/31495877/i-receive-different-results-on-unix-and-win-when-use-static-members-with-static/31798593#comment51013919_31496055\">comment</a>.</p>\n<p>So do not inline functions that you intend to export/import. Keep them in sources. And on Windows builds (regardless of compiler) export them explicitly (otherwise you will get linker error anyway since the functions in sources of a shared library will not be available when building program).</p>\n<p>Note that this is actually a reasonable approach on its own. Inlining function from shared library doesn't seem wise. It freezes not only the interface but also implementation (of that function). You can no longer change this function freely (and deliver new version of your shared library) since all clients would have to be rebuild since they could have inlined that function. So it is a wise approach by itself not to inline from shared library. And as a bonus it assures that your sources are multi-platform friendly.</p>\n<p>Also do have a look into the mentioned <a href=\"https://gcc.gnu.org/wiki/Visibility\" rel=\"nofollow noreferrer\">Visibility entry on GCC Wiki</a>. It might be reasonable to use that approach (of explicit exports) on Linux as well since it seems cleaner (from design point of view) and more efficient at runtime. While it fits well what you have to do for Windows anyway.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-08-06T07:48:08.443", "Score": "1", "CreationDate": "2015-08-03T23:56:18.103", "ParentId": "31495877", "CommentCount": "0", "OwnerUserId": "422489", "LastEditDate": "2017-05-23T12:25:10.080"}, "31495877": {"ViewCount": "131", "Body": "<p>Please consider following peace of code:</p>\n<pre><code>// 1. Single header file. Imagine that it is some static library.\n// Counter.h\n#pragma once\n\nstruct Counter\n{\n    Counter()\n    { \n        ++getCount();\n    }\n\n    static int&amp; getCount()\n    {\n        static int counter = 0;\n        return counter;\n    }\n};\n\n// 2. Shared library (!) : \n// main_DLL.cpp\n#include &lt;iostream&gt;\n#include \"counter.h\"\n\nextern \"C\"\n{\n   __declspec(dllexport) // for WIN\n   void main_DLL()  \n   {\n       Counter c;\n       std::cout &lt;&lt; \"main_DLL : ptr = \" &lt;&lt; &amp;Counter::getCount()&lt;&lt; \" value = \" &lt;&lt; Counter::getCount() &lt;&lt; std::endl;\n   }\n}\n\n// 3. Executable. Shared library statically (!) linked to the executable file.\n// main.cpp\n\n#include \"counter.h\"\n#include &lt;iostream&gt;\n\nextern \"C\"\n{\n    __declspec(dllimport) // for WIN\n    void main_DLL();\n}\n\nint main()\n{\n    main_DLL();\n    Counter c;\n    std::cout &lt;&lt; \"main_EXE : ptr = \" &lt;&lt; &amp;Counter::getCount() &lt;&lt; \" value = \" &lt;&lt; Counter::getCount() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Results:</p>\n<pre><code>Results for WIN (Win8.1 gcc 5.1.0):\nmain_DLL : ptr = 0x68783030 value = 1\nmain_EXE : ptr = 0x403080 value = 1\n// conclusion: two different counters\n\nResults for UNIX (Red Hat &lt;I don\u2019t remember version exactly&gt; gcc 4.8.3):\nmain_DLL : ptr = 0x75693214 value = 1\nmain_EXE : ptr = 0x75693214 value = 2\n// conclusion: the same counter addressed\n</code></pre>\n<p>Building:</p>\n<pre><code>Building for WIN:\ng++ -c -Wall -Werror -o main_DLL.o main_DLL.cpp\ng++ -shared -Wl,--out-implib=libsharedLib.a -o libsharedLib.so main_DLL.o\ng++ -Wall \u2013Werror -o simpleExample main.cpp -L./ -lsharedLib\n\nBuilding for UNIX:\ng++ -c -Wall -Werror -fPIC -o main_DLL.o main_DLL.cpp\ng++ -shared -fPIC -o libsharedLib.so main_DLL.o\ng++ -Wall \u2013Werror -fPIC -o simpleExample main.cpp -L./ -lsharedLib\n</code></pre>\n<p>So, you see that I added \u2013fPIC on UNIX and there is no need to create import library for UNIX, because all exports symbols are included inside shared library. On Windows I use __declspec for it.</p>\n<p>For me, results on Windows are pretty much expected. Because shared library and executable are building separately and they should know about static variable in Counter::getCount. They should simply allocate memory for it, that\u2019s why they have different static counters.</p>\n<p>I did quite some analysis using tools like nm, objdump. Although I\u2019m not a big expert in them, so I haven\u2019t found anything suspicious. I can provide their output if needed.</p>\n<p>Using ldd tool I can see that library linked statically in both cases.</p>\n<p>Why I can\u2019t see the same results on Unix for me it\u2019s strange. Could the root cause lie in building options (\u2013fPIC, for example), or I\u2019m missing something?</p>\n", "AcceptedAnswerId": "31496055", "Title": "I receive different results on UNIX and WIN when use static members with static linking of shared library to executable. Please explain why?", "CreationDate": "2015-07-18T21:43:03.410", "Id": "31495877", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-08-06T07:48:08.443", "Score": "4", "OwnerUserId": "4611411", "Tags": "<c++><unix><gcc>", "AnswerCount": "2"}, "31496055": {"Id": "31496055", "PostTypeId": "2", "Body": "<p>In windows, A DLL is not exporting global and static symbols unless you add the <code>dllexport</code> statement, therefore, the linker doesn't even know they exists, so it allocate new instance for the static member.</p>\n<p>In linux/unix a shared lib is exporting all the global and static symbols, so when the linker find the existence of the static member in the shared lib, it just use its address.</p>\n<p>That is the reason for the different result.</p>\n", "LastEditorUserId": "2852165", "LastActivityDate": "2015-07-18T22:18:19.127", "Score": "4", "CreationDate": "2015-07-18T22:08:44.753", "ParentId": "31495877", "CommentCount": "5", "OwnerUserId": "2852165", "LastEditDate": "2015-07-18T22:18:19.127"}});