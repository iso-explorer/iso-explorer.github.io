post_cb({"21884499": {"CommentCount": "7", "ViewCount": "232", "PostTypeId": "1", "LastEditorUserId": "1314789", "CreationDate": "2014-02-19T15:09:12.237", "LastActivityDate": "2014-02-19T15:38:03.557", "Title": "Can std::initalizer_list cause lifetime issues?", "AcceptedAnswerId": "21884973", "LastEditDate": "2014-02-19T15:38:03.557", "Id": "21884499", "Score": "3", "Body": "<p>When using <code>std::initializer_list</code> I have experienced some difficulties. It didn't take long to realise that I thought of it more as a container, when in fact it has reference semantics. So my question is, which of the following examples might cause problems and if not, why do they work?\nI should add that I'm using VS2013 and <code>std::initializer_list</code> is implemented using only a begin and end pointer. </p>\n<h3>Example 1</h3>\n<pre><code>const auto tmpList = {1, 2, 3};\nconst vector&lt;int&gt; test(tmpList);\n</code></pre>\n<p>This may work if the literals 1, 2 and 3 are stored in a contiguous block of memory. But is this guaranteed?</p>\n<h3>Example 2</h3>\n<pre><code>const string a(\"foo\");\nint someOtherVariable = 10;\nconst string b(\"bar\");\nconst auto tmpList = {a, b};\nconst vector&lt;string&gt; test(tmpList);\n</code></pre>\n<p>This should not work, since a and b might be in different places on the stack (remember <code>std::initializer_list</code> simply keeps a pointer to the first string). But then again, the compiler should be able to handle this somehow, since this should work in my understanding:</p>\n<pre><code>const vector&lt;string&gt; test({a, b});\n</code></pre>\n<p>Or does it?</p>\n<h3>Example 3</h3>\n<pre><code>const auto tmpList = {string(\"foo\"), string(\"bar\")};\nconst vector&lt;string&gt; test(tmpList);\n</code></pre>\n<p>In my point of view the initializer list points to already destroyed temporaries when passed to the vector. </p>\n<h3>Conclusions</h3>\n<p>I think all these examples show that <code>std::initializer_list</code> should not be used as a temporary container. If that is the case, shouldn't storing an initializer list anywhere (except as parameter to a function) be prohibited? Maybe I'm also just missing on some compiler magic which sees to it that the pointers always point to valid, contiguous memory. </p>\n<h2>Solution &amp; Background</h2>\n<p>It seems all of the above examples are well defined. There seems to be a bug either in my program or in the VS2013 C++ compiler. The problem arose first when I used an initializer list like this:</p>\n<pre><code>const auto tmpList = {join(myList1), join(myList2)};\nconst vector&lt;string&gt; test(tmpList);\n</code></pre>\n<p><code>join</code> is a function which returns a <code>std::string</code>. In this case the initializer list contained 2 entries, but the first one was empty. Splitting it up into this resolves the problem:</p>\n<pre><code>const auto str1 = join(myList1);\nconst auto str2 = join(myList2);\nconst auto tmpList = {str1, str2};\nconst vector&lt;string&gt; test(tmpList);\n</code></pre>\n<p>Now that I think of it, it looks like a compiler bug to me, but it led me to believe that the initializer list actually stored pointers directly to the literals, stack variables and so on instead of first copying them to a local array. </p>\n", "Tags": "<c++><c++11><initializer-list><object-lifetime>", "OwnerUserId": "1314789", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_21884499_21884973_0": {"section_id": 3327, "quality": 0.96875, "length": 31}, "so_21884499_21884973_1": {"section_id": 3327, "quality": 0.8571428571428571, "length": 6}, "so_21884499_21884973_3": {"section_id": 3328, "quality": 0.9047619047619048, "length": 19}}, "n3337": {"so_21884499_21884973_0": {"section_id": 3197, "quality": 0.90625, "length": 29}, "so_21884499_21884973_1": {"section_id": 3197, "quality": 0.8571428571428571, "length": 6}, "so_21884499_21884835_0": {"section_id": 3198, "quality": 0.625, "length": 5}}, "n4659": {"so_21884499_21884973_0": {"section_id": 4093, "quality": 0.84375, "length": 27}, "so_21884499_21884973_3": {"section_id": 4094, "quality": 0.9047619047619048, "length": 19}, "so_21884499_21884973_1": {"section_id": 4093, "quality": 0.8571428571428571, "length": 6}}}, "21884973": {"ParentId": "21884499", "CommentCount": "2", "Body": "<p>All your examples have well defined behavior. From <em>\u00a78.5.4/5</em></p>\n<blockquote>\n<p id=\"so_21884499_21884973_0\">An object of type <code>std::initializer_list&lt;E&gt;</code> is constructed from an initializer list as if the implementation allocated a temporary array of <code>N</code> elements of type <code>const E</code>, where <code>N</code> is the number of elements in the initializer list. Each element of that array is copy-initialized with the corresponding element of the initializer list, and the <code>std::initializer_list&lt;E&gt;</code> object is constructed to refer to that array. ... [ <em>Example:</em></p>\n</blockquote>\n<pre><code> struct X {\nX(std::initializer_list&lt;double&gt; v);\n};\nX x{ 1,2,3 };\n</code></pre>\n<blockquote>\n<p id=\"so_21884499_21884973_1\">The initialization will be implemented in a way roughly equivalent to this:</p>\n</blockquote>\n<pre><code>const double __a[3] = {double{1}, double{2}, double{3}};\nX x(std::initializer_list&lt;double&gt;(__a, __a+3));\n</code></pre>\n<blockquote>\n<p id=\"so_21884499_21884973_2\">...\u2014<em>end example</em> ]</p>\n</blockquote>\n<p>Also, <em>\u00a78.5.4/6</em> is relevant</p>\n<blockquote>\n<p id=\"so_21884499_21884973_3\">The array has the same lifetime as any other temporary object (12.2), except that initializing an initializer_list object from the array extends the lifetime of the array exactly like binding a reference to a temporary.</p>\n</blockquote>\n<p>The standard even gives examples of valid and invalid code after that. The invalid code sample is this:</p>\n<pre><code>struct A {\n    std::initializer_list&lt;int&gt; i4;\n    A() : i4{ 1, 2, 3 } {} // creates an A with a dangling reference\n};\n</code></pre>\n<p>It's invalid because the lifetime of the temporary array created for the initializer list ends when the constructor body ends, leaving <code>i4</code> with dangling references.</p>\n", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "21884973", "Score": "4", "CreationDate": "2014-02-19T15:26:45.253", "LastActivityDate": "2014-02-19T15:26:45.253"}, "21884835": {"ParentId": "21884499", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_21884499_21884835_0\">C++11 8.5.4/6 The lifetime of the array is the same as that of the <code>initializer_list</code> object.</p>\n</blockquote>\n<p>So there are no lifetime issues in any of your examples. You'd need to do something convoluted like</p>\n<pre><code>std::initializer_list&lt;int&gt; bad;\n{\n    bad = {1,2,3};\n}\nstd::vector&lt;int&gt; test(bad);  // Boom!\n</code></pre>\n<p>to encounter problems.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "21884835", "Score": "4", "CreationDate": "2014-02-19T15:21:49.077", "LastActivityDate": "2014-02-19T15:21:49.077"}});