post_cb({"bq_ids": {"n4140": {"so_38028871_38028905_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 6071}}, "n3337": {"so_38028871_38028905_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 5839}}, "n4659": {"so_38028871_38028905_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 7567}}}, "38028871": {"ViewCount": "63", "Body": "<p>I prefer to use size_t to deal with vector index. But when shifting index, is it safe? For example,</p>\n<pre><code>size_t n = 10000000;\nvector&lt;int&gt; v(n);\n\nsize_t i = 500000;\nsize_t shift = 20000;\nint a = v(i - (-1) * shift); // Is this ok? what is `(-1) * shift` type, size_t?\nint b = v(-shift + i); // Is this ok? what is `-shift` type, size_t?\n</code></pre>\n", "AcceptedAnswerId": "38028895", "Title": "Is it safe to use size_t to shift vector index?", "CreationDate": "2016-06-25T13:10:29.737", "Id": "38028871", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2016-06-25T13:33:03.753", "Score": "1", "OwnerUserId": "1899020", "Tags": "<c++><integer>", "AnswerCount": "3"}, "38029066": {"Id": "38029066", "PostTypeId": "2", "Body": "<p>Surely, you meant <code>v[...]</code>  instead of <code>v()</code>; <code>std::vector</code> has no <code>operator(int)</code>.</p>\n<p>Anyway, empirically, </p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint main(){\n    unsigned foo = 1;\n    cout&lt;&lt;(-1)*foo&lt;&lt;'\\n';\n    cout&lt;&lt;-foo&lt;&lt;'\\n';\n    cout&lt;&lt;foo*(-1)&lt;&lt;'\\n';\n    cout&lt;&lt;static_cast&lt;int&gt;(-foo)&lt;&lt;'\\n';\n    cout&lt;&lt;static_cast&lt;int&gt;(foo)*-1&lt;&lt;'\\n';\n}\n</code></pre>\n<p>yields:</p>\n<pre><code>4294967295\n4294967295\n4294967295\n-1\n-1\n</code></pre>\n<p>ergo a negated unsigned or an unsigned multiplied by -1 overflows by wrapping around its maximum value (this should be the theoretical behavior too).</p>\n<p>As for passing size_t to \n<a href=\"http://en.cppreference.com/w/cpp/container/vector/operator_at\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/container/vector/operator_at</a>, if by chance <code>std::vector&lt;T&gt;::size_type</code> isn't <code>size_t</code> (unlikely but possible), passing a <code>size_t</code> within the bounds of your vector's <code>size()</code> should be safe and not lead to UB, as <code>size_t</code> must be large enough to index an array of any size.</p>\n", "LastActivityDate": "2016-06-25T13:33:03.753", "CommentCount": "0", "CreationDate": "2016-06-25T13:33:03.753", "ParentId": "38028871", "Score": "0", "OwnerUserId": "1084774"}, "38028895": {"Id": "38028895", "PostTypeId": "2", "Body": "<p>Multiplying a <code>size_t</code> with <code>(-1)</code> is safe, it wraps around the maximum value of <code>size_t</code>, as <code>size_t</code> is an unsigned type. So <code>(-1) * shift</code> is the same as <code>std::numeric_limits&lt;size_t&gt;::max-shift+1</code>.</p>\n", "LastEditorUserId": "1848654", "LastActivityDate": "2016-06-25T13:18:30.167", "Score": "1", "CreationDate": "2016-06-25T13:13:29.187", "ParentId": "38028871", "CommentCount": "0", "OwnerUserId": "3093378", "LastEditDate": "2016-06-25T13:18:30.167"}, "38028905": {"Id": "38028905", "PostTypeId": "2", "Body": "<p>Negating an <code>unsigned</code> quantity is a valid operation. Section 5.3.2 of C++11:</p>\n<blockquote>\n<p id=\"so_38028871_38028905_0\">The negative of an unsigned quantity is computed by subtracting its\n  value from 2^n , where n is the number of bits in the promoted\n  operand. The type of the result is the type of the promoted operand.</p>\n</blockquote>\n<p>So, this is \"safe\", in so far as this is defined behavior.</p>\n", "LastActivityDate": "2016-06-25T13:14:29.003", "CommentCount": "0", "CreationDate": "2016-06-25T13:14:29.003", "ParentId": "38028871", "Score": "2", "OwnerUserId": "3943312"}});