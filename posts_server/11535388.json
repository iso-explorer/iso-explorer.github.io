post_cb({"11535388": {"CommentCount": "9", "AcceptedAnswerId": "11535695", "PostTypeId": "1", "LastEditorUserId": "383306", "CreationDate": "2012-07-18T06:22:26.953", "LastActivityDate": "2012-07-18T07:49:15.603", "LastEditDate": "2012-07-18T06:32:05.793", "ViewCount": "651", "FavoriteCount": "1", "Title": "Understanding 'most vexing parse' - why allow ambiguous syntax?", "Id": "11535388", "Score": "3", "Body": "<p>While trying to understand the \"Most vexing parse\" problem in C/C++, this question immediately springs to mind - why have a syntax that causes this problem to begin with?</p>\n<p>For example,</p>\n<pre><code>class Timer\n{\npublic:\n    Timer();\n};\n\nclass TimeKeeper\n{\npublic:\n    TimeKeeper(const Timer&amp; t);\n\n    int get_time()\n    {\n        return 1;\n    }\n};\n\nint main()\n{\n    TimeKeeper time_keeper(Timer());\n    // the above is eq to this: TimeKeeper time_keeper(Timer (*)());\n}\n</code></pre>\n<p>So why not simply disallow <code>TimeKeeper time_keeper(Timer())</code> to be a function declaration that takes an unnamed function ptr returning type Timer? Is <code>TimeKeeper time_keeper(Timer (*)())</code> inferior as a function declarator?</p>\n<p>Is it not due to this syntax that we even get this ambiguity or am I missing something?</p>\n<p>EDIT: Personally, I've never used <code>TimeKeeper time_keeper(Timer())</code> as a function declaration. I've always used the <code>Timer (*)()</code> to specify a function pointer as I find it clearer.</p>\n", "Tags": "<c++><most-vexing-parse>", "OwnerUserId": "383306", "AnswerCount": "2"}, "11535695": {"ParentId": "11535388", "PostTypeId": "2", "CommentCount": "25", "Body": "<blockquote>\n<p id=\"so_11535388_11535695_0\">So why not simply disallow TimeKeeper time_keeper(Timer()) to be a function declaration that takes an unnamed function ptr returning type Timer?</p>\n</blockquote>\n<p>Suppose for a while that this function declaration is diallowed, because it uses <em>unnamed</em>  parameter. If that is so, then the following <em>declarations</em> will be disallowed as well:</p>\n<pre><code>int max(int,int);  //error (in hypothetical C++)\nint min(int,int);  //error (in hypothetical C++)\n</code></pre>\n<p>And <em>then</em> the programmers will be <em>forced</em> to write the parameter <em>name</em>, in the declarations as well:</p>\n<pre><code>int max(int a,int b);  //ok \nint min(int a,int b);  //ok \n</code></pre>\n<p>But then someone else would stand up and ask : <em>\"Why am I forced to write the parameter name(s) in the declarations when it doesn't use it? Why is it not optional?</em>\"</p>\n<p>I think this guy is rational and what he asked has point. It is indeed irrational to <em>force</em> programmers to name the parameter in the declarations.</p>\n<p>--</p>\n<p>Reading your comment, it seems that you think the following declarations are <em>exactly</em> same:</p>\n<pre><code>int max(Timer());\nint max(Timer(*)());\n</code></pre>\n<p>No. They're not <em>exactly</em> same from the <em>syntax</em> point of view, though they are exactly same from the <em>behavior</em> point of view. </p>\n<p>The subtle difference is that in the former, the parameter type is a function which takes nothing, and returns <code>Timer</code>, while in the later, the parameter type is a <em>pointer</em> to a function which takes nothing, and returns <code>Timer</code>. Do you see the difference?</p>\n<p>But then the question is, why are they same behavior-wise? Well the answer is, in the former declaration, the parameter type is <em>adjusted</em> and then <em>becomes</em> a pointer type, and so it behaves the same as the second declaration. </p>\n<p>The C++03 Standard says in \u00a713.1/3,</p>\n<blockquote>\n<p id=\"so_11535388_11535695_1\">Parameter declarations that differ only in that one is a <em>function type</em>\n  and the other is <em>a pointer to the same function type</em> are equivalent.\n  <strong>That is, the function type is adjusted to become a pointer to function\n  type</strong> (8.3.5).</p>\n</blockquote>\n<p>I hope it is same in C++11 also.</p>\n<p>--</p>\n<p>Your doubt (taken from the comment):</p>\n<blockquote>\n<p id=\"so_11535388_11535695_2\">Still not any closer to understanding why we need the 2 syntax?</p>\n</blockquote>\n<p>Because they are two <em>different</em> types. Function type, and pointer to function type. Only as parameter type, they behaves same. Otherwise, they're different. See my answer here to see where they behave differently:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/7321993/reference-to-function-syntax-with-and-without\">Reference to Function syntax - with and without &amp;</a></li>\n</ul>\n<p>And since they behave differently in other situations, we <em>have</em> them, we <em>need</em> them. The Standard doesn't (and should not) disallow one syntax, just because as parameter type they behave same.</p>\n", "OwnerUserId": "415784", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:33:15.757", "Id": "11535695", "Score": "8", "CreationDate": "2012-07-18T06:46:21.053", "LastActivityDate": "2012-07-18T07:11:02.560"}, "bq_ids": {"n4140": {"so_11535388_11535695_1": {"section_id": 558, "quality": 0.9047619047619048, "length": 19}}, "n3337": {"so_11535388_11535695_1": {"section_id": 549, "quality": 0.9047619047619048, "length": 19}}, "n4659": {"so_11535388_11535695_1": {"section_id": 581, "quality": 0.9047619047619048, "length": 19}}}, "11536627": {"ParentId": "11535388", "CommentCount": "4", "Body": "<p>Just a note that... you have been heard :)</p>\n<p>C++11 specifically addressed this issue with the introduction of the uniform initialization syntax. Now you can write <code>TimeKeeper time_keeper{Timer{}};</code> and there is no parse ambiguity.</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "11536627", "Score": "3", "CreationDate": "2012-07-18T07:49:15.603", "LastActivityDate": "2012-07-18T07:49:15.603"}});