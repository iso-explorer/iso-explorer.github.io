post_cb({"36059162": {"ParentId": "36053305", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I add another answer, that is completely different from the previous one and could solve your issue.<br>\nThe idea is to use another class and the right mix of explicit and non-explicit constructors.<br>\nIt follows a minimal, working example:</br></br></p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;class C, int(C::*M)()&gt;\nstruct Arg {\n    std::function&lt;int(C*)&gt; fn;\n    Arg(int i): fn{[i](C*){ return i; }} { } \n    explicit Arg(): fn{[](C* c){ return (c-&gt;*M)(); }} { }\n};\n\nstruct S {\n    int f() { return 1; }\n    int h() { return 2; }\n    void g(int arg0,\n          Arg&lt;S, &amp;S::f&gt; arg1 = Arg&lt;S, &amp;S::f&gt;{},\n          Arg&lt;S, &amp;S::h&gt; arg2 = Arg&lt;S, &amp;S::h&gt;{})\n    {\n        std::cout &lt;&lt; \"arguments\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"arg0: \" &lt;&lt; arg0 &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"arg1: \" &lt;&lt; arg1.fn(this) &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"arg2: \" &lt;&lt; arg2.fn(this) &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    S s{};\n    s.g(42, 41, 40);\n    s.g(0);\n}\n</code></pre>\n<p>The example shows how you can mix both default parameters and non defaulted ones.<br>\nIt's quite simple to modify it and let <code>g</code> be a function having an empty argument list, as in the original question.<br>\nI'm also quite sure that one can refine the example and end with something better than that, anyway it should be a good point from which to start.</br></br></p>\n<p>It follows the solution applied to the original example from the question:</p>\n<pre><code>#include &lt;functional&gt;\n\ntemplate&lt;class C, int(C::*M)()&gt;\nstruct Arg {\n    std::function&lt;int(C*)&gt; fn;\n    Arg(int i): fn{[i](C*){ return i; }} { } \n    explicit Arg(): fn{[](C* c){ return (c-&gt;*M)(); }} { }\n};\n\nstruct S {\n    int f() { return 1; }\n    int g(Arg&lt;S, &amp;S::f&gt; arg = Arg&lt;S, &amp;S::f&gt;{}) {\n        return arg.fn(this);\n    }\n};\n\nint main() {   \n    S s{}; \n    return s.g();\n}\n</code></pre>\n<p>And that's all, it's possible to do that, even without <code>static</code> methods or global variables.<br>\nOf course, we can use our <em>this</em> somehow. It's a matter of bending the language a bit...</br></p>\n", "OwnerUserId": "4987285", "LastEditorUserId": "4987285", "LastEditDate": "2016-03-17T11:46:51.107", "Id": "36059162", "Score": "3", "CreationDate": "2016-03-17T11:25:55.263", "LastActivityDate": "2016-03-17T11:46:51.107"}, "36053505": {"ParentId": "36053305", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>If you are allowed to use experimental features from C++17, you can use <code>std::optional</code> from the STL (see <a href=\"http://en.cppreference.com/w/cpp/utility/optional\" rel=\"nofollow\">here</a> for further details).</p>\n<p>In other terms something like:</p>\n<pre><code>int g(std::optional&lt;int&gt; oarg = std::optional&lt;int&gt;{}) {\n    int arg = oarg ? *oarg : f();\n    // go further\n}\n</code></pre>\n<p><strong>EDIT</strong></p>\n<p>As suggested in the comments, the code above should be logically equivalent to the one below:</p>\n<pre><code>int g(std::optional&lt;int&gt; oarg = std::optional&lt;int&gt;{}) {\n    int arg = oarg.value_or(f());\n    // go further\n}\n</code></pre>\n<p>This one is a bit more readable (isn't it?), but please note that it executes <code>f</code> in any case.<br>\nIf that function is expensive, maybe it doesn't worth it.</br></p>\n", "OwnerUserId": "4987285", "LastEditorUserId": "4987285", "LastEditDate": "2016-03-18T07:05:26.630", "Id": "36053505", "Score": "5", "CreationDate": "2016-03-17T06:54:56.783", "LastActivityDate": "2016-03-18T07:05:26.630"}, "36053305": {"CommentCount": "2", "ViewCount": "633", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-03-17T06:41:21.763", "LastActivityDate": "2016-03-18T07:05:26.630", "Title": "Is it possible to use member function call as default argument?", "FavoriteCount": "4", "LastEditDate": "2017-05-23T12:24:15.203", "Id": "36053305", "Score": "14", "Body": "<p>Here is my code:</p>\n<pre><code>struct S\n{\n   int f() { return 1; }\n   int g(int arg = f()) { return arg; }\n};\n\nint main()\n{\n    S s;\n    return s.g();\n}\n</code></pre>\n<p>This fails to compile with the error:</p>\n<pre><code>error: cannot call member function 'int S::f()' without object\n</code></pre>\n<p>Trying <code>this-&gt;f()</code> doesn't work either, as <code>this</code> may not be used in that context.</p>\n<p>Is there a way to make this work, still using the default argument?  </p>\n<hr>\n<p>Of course it can be worked around by not using default arguments at all:</p>\n<pre><code>int g(int arg) { return arg; }\nint g() { return g(f()); }\n</code></pre>\n<p>however that gets verbose considering that in the \"real code\" there are more parameters before <code>arg</code>, and several functions following this pattern. (And even more ugly if there were multiple default arguments in the one function).</p>\n<p>NB. <a href=\"https://stackoverflow.com/questions/29502745/cannot-pass-my-member-function-as-default-parameter-for-my-template-class-c\">This question</a> looks similar at first, but in fact he is asking how to form a closure, which is a different problem (and the linked solution doesn't apply to my situation).</p>\n</hr>", "Tags": "<c++><member-functions><default-arguments>", "OwnerUserId": "1505939", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_36053305_36053478_1": {"section_id": 3259, "quality": 0.8333333333333334, "length": 5}, "so_36053305_36053478_0": {"section_id": 3260, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_36053305_36053478_1": {"section_id": 3131, "quality": 0.8333333333333334, "length": 5}, "so_36053305_36053478_0": {"section_id": 3132, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_36053305_36053478_1": {"section_id": 4017, "quality": 0.8333333333333334, "length": 5}, "so_36053305_36053478_0": {"section_id": 4018, "quality": 0.7222222222222222, "length": 13}}}, "36053478": {"ParentId": "36053305", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You can only use members there if they are <code>static</code>. From a C++11 draft (n3299), \u00a78.3.6/9:</p>\n<blockquote>\n<p id=\"so_36053305_36053478_0\">Similarly, a non-static member shall not be used in a default argument, even if it is not evaluated, unless it appears as the <em>id-expression</em> of a class member access expression (5.2.5) or unless it is\n  used to form a pointer to member (5.3.1).</p>\n</blockquote>\n<p>e.g. this works:</p>\n<pre><code>struct S {\n  static int f() { return 1; }\n  int g(int arg = f()) { return arg; }\n};\n\nint main()\n{\n  S s;\n  return s.g();\n}\n</code></pre>\n<p>This also works (I think that's what the first expression means):</p>\n<pre><code>struct S {\n  int f() { return 42; }\n  int g(int arg);\n};\n\nstatic S global;\n\nint S::g(int arg = global.f()) { return arg; }\n\nint main()\n{\n  S s;\n  return s.g();\n}\n</code></pre>\n<p>As for <code>this</code>, it is indeed not allowed (\u00a78.3.6/8):</p>\n<blockquote>\n<p id=\"so_36053305_36053478_1\">The keyword <code>this</code> shall not be used in a default argument of a member function. </p>\n</blockquote>\n<p>The <a href=\"http://en.cppreference.com/w/cpp/language/default_arguments\">default arguments</a> page on cppreference.com has a lot of details regarding the subjet - it can get quite complex.</p>\n", "OwnerUserId": "635608", "LastEditorUserId": "635608", "LastEditDate": "2016-03-17T06:58:12.750", "Id": "36053478", "Score": "12", "CreationDate": "2016-03-17T06:53:04.877", "LastActivityDate": "2016-03-17T06:58:12.750"}});