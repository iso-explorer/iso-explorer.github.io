post_cb({"8379871": {"Id": "8379871", "PostTypeId": "2", "Body": "<p>In case it helps with syntax, here is how I declare a friend user-defined literal operator in a class, where the operator itself is in a namespace:</p>\n<pre><code>class Integer;\nnamespace literals {\n  Integer operator \"\" _I (const char *);\n}\n\n// Infinite precision integer \nclass Integer {\n  public:\n\n  // Basic constructor &amp; destructor\n   Integer ();\n  ~Integer ();\n\n... rest of the interface ...\n\n  // Literal operator\n  friend Integer literals::operator \"\" _I (const char *);\n\n  private:\n\n  struct Detail;\n  std::unique_ptr&lt;Detail&gt; detail;\n\n};\n</code></pre>\n<p>Users pull in the operator with a <code>using namespace literals;</code> statement only if they want it. (And, actually, all of this is in a parent namespace, but you get the idea).</p>\n", "LastEditorUserId": "631429", "LastActivityDate": "2011-12-05T18:06:41.900", "Score": "1", "CreationDate": "2011-12-05T00:48:27.173", "ParentId": "7358233", "CommentCount": "0", "OwnerUserId": "631429", "LastEditDate": "2011-12-05T18:06:41.900"}, "7358233": {"ViewCount": "650", "Body": "<p><strong>Will it be possible and/or useful to define an <code>operator \"\" (...)</code> as a friend function?</strong></p>\n<pre><code>class Puzzle {\n  friend Puzzle operator \"\" _puzzle(const char*, size_t);\n  ...\n};\nvoid solve(Puzzle);\nint main() {\n  solve(\"oxo,xox\"_puzzle);\n};\n</code></pre>\n<p>I am thinking about \"useful\" especially, because of the rule that <code>operator \"\"</code> shall be defined in a namespace only -- not the least because identifiers beginning with <code>_</code> are reserved in global namespace. Is this <code>friend</code> breaking this rule here? So, there would be no benefit with this not-quite encapsulation, right?</p>\n", "AcceptedAnswerId": "7375891", "Title": "C++0x, user-defined literals with friend operator \"\"()", "CreationDate": "2011-09-09T07:06:23.900", "Id": "7358233", "CommentCount": "0", "LastEditDate": "2011-12-05T23:48:22.820", "PostTypeId": "1", "LastEditorUserId": "500104", "LastActivityDate": "2011-12-05T23:48:22.820", "Score": "5", "OwnerUserId": "472245", "Tags": "<c++><c++11><friend-function><user-defined-literals>", "AnswerCount": "3"}, "7366781": {"Id": "7366781", "PostTypeId": "2", "Body": "<p>According to the standard, yes, a friend declaration should be legal.\nBy the way, the name is fine for user code since it starts with an underscore even in global namespace.</p>\n<p>The friend declaration would allow the operator to access class-private data.</p>\n<p>I am beginning to question the usefulness of friend literal operators.  Because the user-defined operators can only have a few argument lists there is no way to put the class in the arguments.  So there is now way for argument dependent look-up to find the right function.  Am I right?</p>\n", "LastActivityDate": "2011-09-09T19:55:16.417", "CommentCount": "3", "CreationDate": "2011-09-09T19:55:16.417", "ParentId": "7358233", "Score": "0", "OwnerUserId": "680359"}, "7375891": {"Id": "7375891", "PostTypeId": "2", "Body": "<p>The Standard addresses this directly in the only place it mentions any restrictions on the declarations of user-defined literals, \u00a713.5.8/2:</p>\n<blockquote>\n<p id=\"so_7358233_7375891_0\">A declaration whose declarator-id is a literal-operator-id shall be a declaration of a namespace-scope function or function template (<strong>it could be a friend function (11.3)</strong>), an explicit instantiation or specialization of a function template, or a using-declaration (7.3.3).</p>\n</blockquote>\n<p>If the friend is also declared at namespace scope, then there is no distinction between definition in class or namespace scope. Note that there is no requirement for definition at namespace scope, which your question as currently worded asserts.</p>\n<p>If not declared at namespace scope, since it cannot be found by ADL, the friend could be used privately inside the class where it is scope by regular unqualified name lookup. This is the only way of declaring a literal operator which is not an external interface.</p>\n<p>If the friend is defined inside a class template, then two instantiations of the template will generate two identically-named functions at namespace scope, which collide even though they are both invisible outside the class scope.</p>\n", "LastActivityDate": "2011-09-11T02:11:37.010", "CommentCount": "3", "CreationDate": "2011-09-11T02:11:37.010", "ParentId": "7358233", "Score": "2", "OwnerUserId": "153285"}, "bq_ids": {"n4140": {"so_7358233_7375891_0": {"length": 18, "quality": 0.9, "section_id": 668}}, "n3337": {"so_7358233_7375891_0": {"length": 18, "quality": 0.9, "section_id": 658}}, "n4659": {"so_7358233_7375891_0": {"length": 18, "quality": 0.9, "section_id": 696}}}});