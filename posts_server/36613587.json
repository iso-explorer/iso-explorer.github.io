post_cb({"36613587": {"CommentCount": "0", "ViewCount": "109", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2016-04-14T03:53:47.857", "LastActivityDate": "2016-06-30T11:03:07.610", "Title": "is static thread_local memory async signal safet in c++14?", "AcceptedAnswerId": "36613757", "LastEditDate": "2016-04-14T04:13:36.153", "Id": "36613587", "Score": "1", "Body": "<p>Let's assume that I have this function: </p>\n<pre><code>int my_thread_id(){\n  static int counter {0};\n  thread_local int tid{++counter};\n  return tid;\n}\n</code></pre>\n<p>Is this function (my_thread_id) async-signal-safe, even on the first call? </p>\n", "Tags": "<c++><c++11><signals><c++14>", "OwnerUserId": "2856298", "AnswerCount": "2"}, "38121257": {"ParentId": "36613587", "CommentCount": "0", "Body": "<p>This answer can be considered an addendum to the answer given by ildjarn. When strictly speaking about the C++ 14 standard, using data with thread_local storage from a signal handler results in undefined behavior.</p>\n<p>On certain platforms, however, such use might be permissible. For example, most POSIX systems implement thread-local storage by using a special data segment that is allocated per-thread (like the stack). Please refer to <a href=\"https://www.akkadia.org/drepper/tls.pdf\" rel=\"nofollow\">this document</a> for detailed explanations. In this case, access to thread-local data is async signal safe because it does not involve any locks.</p>\n<p>However, the data read or written by the signal handler might still be inconsistent unless only atomics are accessed or access is fenced by using <code>std::atomic_signal_fence</code>. The reason for this is that the compiler has now idea when a signal handler might interrupt execution and might thus reorder read and write instructions. <code>std::atomic_signal_fence</code> prohibits this reordering and reordering by the CPU is not a problem because the execution happens within the same thread and the CPU is only allowed to reorder instructions when the result (within the thread) is the same as if the instructions had been executed in order.</p>\n<p>In addition to std::atomic_signal_fence, using variables of type std::atomic is safe, as long they are lock free (as indicated by std::is_lock_free).</p>\n<p>On Linux (and I believe most other POSIX platforms), the question whether a signal is dispatched to a specific thread depends on how this signal is generated and the exact type of the signal. For example, <code>SIGSEGV</code> and <code>SIGBUS</code> are always dispatched to the thread that caused the error resulting in the signal. In this case, using thread-local storage can be a convenient way to recover from such errors. However, there is no way to do this while keeping the code portable to all platforms supporting the C++ standard.</p>\n", "OwnerUserId": "2326830", "PostTypeId": "2", "Id": "38121257", "Score": "0", "CreationDate": "2016-06-30T11:03:07.610", "LastActivityDate": "2016-06-30T11:03:07.610"}, "bq_ids": {"n4140": {"so_36613587_36613757_2": {"section_id": 5834, "quality": 0.90625, "length": 29}, "so_36613587_36613757_0": {"section_id": 5813, "quality": 1.0, "length": 22}, "so_36613587_36613757_3": {"section_id": 5802, "quality": 0.9090909090909091, "length": 30}, "so_36613587_36613757_1": {"section_id": 5834, "quality": 1.0, "length": 4}}, "n3337": {"so_36613587_36613757_2": {"section_id": 5605, "quality": 0.625, "length": 20}}, "n4659": {"so_36613587_36613757_0": {"section_id": 7276, "quality": 0.5909090909090909, "length": 13}, "so_36613587_36613757_2": {"section_id": 7296, "quality": 0.90625, "length": 29}, "so_36613587_36613757_3": {"section_id": 7274, "quality": 0.8484848484848485, "length": 28}, "so_36613587_36613757_1": {"section_id": 7296, "quality": 1.0, "length": 4}}}, "36613757": {"ParentId": "36613587", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>No.</p>\n<p>Signal handlers have no notion of which thread they're executing on, so <code>thread_local</code> has no valid semantics there. [intro.multithread]p2:</p>\n<blockquote>\n<p id=\"so_36613587_36613757_0\">A signal handler that is executed as a result of a call to the <code>raise</code> function belongs to the same thread of execution as the call to the <code>raise</code> function. Otherwise it is unspecified which thread of execution contains a signal handler invocation.</p>\n</blockquote>\n<p>Also relevant is p23:</p>\n<blockquote>\n<p id=\"so_36613587_36613757_1\">Two actions are <em>potentially concurrent</em> if</p>\n<ul>\n<li>they are performed by different threads, or</li>\n<li>they are unsequenced, and at least one is performed by a signal handler.</li>\n</ul>\n<p id=\"so_36613587_36613757_2\">The execution of a program contains a <em>data race</em> if it contains two potentially concurrent conflicting actions, at least one of which is not atomic, and neither happens before the other, except for the special case for signal handlers described below. Any such data race results in undefined behavior.</p>\n</blockquote>\n<p>(The special case for signal handlers being referred to is only regarding the type <code>volatile sig_atomic_t</code> and does not apply here.)</p>\n<p>The second bullet pertains because of [intro.execution]p6:</p>\n<blockquote>\n<p id=\"so_36613587_36613757_3\">If a signal handler is executed as a result of a call to the <code>raise</code> function, then the execution of the handler is sequenced after the invocation of the <code>raise</code> function and before its return. [ <em>Note:</em> When a signal is received for another reason, the execution of the signal handler is usually unsequenced with respect to the rest of the program. \u2014<em>end note</em> ]</p>\n</blockquote>\n", "OwnerUserId": "636019", "LastEditorUserId": "636019", "LastEditDate": "2016-04-14T06:22:07.103", "Id": "36613757", "Score": "2", "CreationDate": "2016-04-14T04:13:24.590", "LastActivityDate": "2016-04-14T06:22:07.103"}});