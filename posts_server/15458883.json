post_cb({"15458897": {"ParentId": "15458883", "CommentCount": "5", "CreationDate": "2013-03-17T08:26:42.973", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "15458897", "Score": "5", "Body": "<p>Yes use a typedef and then say</p>\n<pre><code>ArrayType{1, 2, 3, 0}\n</code></pre>\n<p>Alternatively use an alias template and then</p>\n<pre><code>AliasTemplate&lt;char[]&gt;{1, 2, 3, 0}\n</code></pre>\n", "LastActivityDate": "2013-03-17T08:26:42.973"}, "18163000": {"ParentId": "15458883", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2013-08-10T14:46:22.080", "Score": "13", "LastEditorUserId": "2670646", "LastEditDate": "2013-08-10T22:29:14.133", "Id": "18163000", "OwnerUserId": "2670646", "Body": "<p>1) I suffered with this problem for some time. Compiling the following program, g++ 4.7.1 (tdm64-1) gives the error: \"teste1.cpp:6:33: error: taking address of temporary array\"</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nint main()\n{ char t[]={1,2,3,0};\n  if (strcmp((char[]){1,2,3,0},t)==0)  //error\n    cout &lt;&lt; \"equal\\n\";\n  else \n    cout &lt;&lt; \"different\\n\";\n}\n</code></pre>\n<p>However, if you add the keyword \"const\", the error disappears and the program runs smoothly:</p>\n<pre><code>if (strcmp((const char[]){1,2,3,0},t)==0) //correct\n</code></pre>\n<p>2) In some cases, just adding the keyword \"const\" may not be enough. For example, g++ 4.7.1 gives \"error: taking address of temporary array\" when compiling the following program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nvoid f(char* p)\n{ for (int i=0; p[i]!=0; i++) \n    cout &lt;&lt; int(p[i]) &lt;&lt; \" \";\n  cout &lt;&lt; endl;\n}\n\nint main() {\n  f((char[]){1,2,3,0}); // error\n}\n</code></pre>\n<p>If you add the keyword \"const\", the compiler gives another kind of error: \"invalid conversion from 'const char*' to 'char*' [-fpermissive]\":</p>\n<pre><code>f((const char[]){1,2,3,0}); //error\n</code></pre>\n<p>To successfully compile the program, you can either compile it with option \"-fpermissive\" or make a explicit type conversion:</p>\n<pre><code>f((char*)(const char[]){1,2,3,0}); // correct\n</code></pre>\n", "LastActivityDate": "2013-08-10T22:29:14.133"}, "26786353": {"ParentId": "15458883", "CommentCount": "0", "CreationDate": "2014-11-06T18:06:01.197", "OwnerUserId": "4224044", "PostTypeId": "2", "Id": "26786353", "Score": "2", "Body": "<p>It seems that this problem can be solved using C++11 \"move\". Compiling in g++ 4.8.1 the program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\ntypedef char CA[];\nint main() {\n  cout &lt;&lt; CA{'a','b','c',0} &lt;&lt; endl;\n}\n</code></pre>\n<p>results in \"error: taking address of temporary array\". However, using \"move\":</p>\n<pre><code>cout &lt;&lt; move(CA{'a','b','c',0}) &lt;&lt; endl;\n</code></pre>\n<p>the program compiles and runs correctly. The compiler must be invoked to use C++11 dialect:</p>\n<pre><code>g++ prog1.cpp -o prog.exe -std=c++11\n</code></pre>\n<p>Similarly,</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nint main()\n{ char t[]={1,2,3,0};\n  if (strcmp( move((char[]){1,2,3,0}) ,t)==0)  //OK\n    cout &lt;&lt; \"equal\\n\";\n  else \n    cout &lt;&lt; \"different\\n\";\n}\n</code></pre>\n<p>also compiles and runs correctly, using -std=c++11 flag.</p>\n", "LastActivityDate": "2014-11-06T18:06:01.197"}, "bq_ids": {"n4140": {"so_15458883_15458883_0": {"section_id": 11, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_15458883_15458883_0": {"section_id": 8, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_15458883_15458883_0": {"section_id": 12, "quality": 0.9444444444444444, "length": 17}}}, "15458883": {"CommentCount": "2", "ViewCount": "6636", "PostTypeId": "1", "LastEditorUserId": "1131467", "CreationDate": "2013-03-17T08:24:50.173", "LastActivityDate": "2014-11-06T18:06:01.197", "Title": "Using array init list as temporary in C++11?", "FavoriteCount": "2", "LastEditDate": "2013-03-17T09:14:06.460", "Id": "15458883", "Score": "19", "Body": "<p>I can create a named variable with an array as follows:</p>\n<pre><code>char s[] = {1, 2, 3, 0};\nif (strcmp(s, t))\n    ...\n</code></pre>\n<p>However the following doesn't work:</p>\n<pre><code>if (strcmp(char[]{1,2,3,0}, t))\n    ...\n</code></pre>\n<p>Is there some way to specify a temporary unnamed array with an initializer list? (In this case a string literal would work, but for arrays other than char arrays?)</p>\n<p><strong>Update:</strong></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\ntypedef char CA[];\n\nint main()\n{\n        cout &lt;&lt; CA{1,2,3, 0} &lt;&lt; endl;\n}\n</code></pre>\n<p>gives <code>error: taking address of temporary array</code> (<code>g++-4.7.2 -std=gnu++11</code>)</p>\n<p><strong>Update 2:</strong></p>\n<p>I think (maybe) what is happening is that string literals are specially blessed as <em>lvalues</em>, however temporary arrays are <em>prvalues</em>, and as such you cant take their address.  This is a wild guess though, I'm not sure.</p>\n<p><strong>Update 3:</strong></p>\n<p>Actually that should be wrong I think:</p>\n<blockquote>\n<p id=\"so_15458883_15458883_0\">An lvalue or rvalue of type \u201carray of N T\u201d or \u201carray of unknown bound of T\u201d can be converted to a prvalue\n  of type \u201cpointer to T\u201d. The result is a pointer to the first element of the array.</p>\n</blockquote>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1131467", "AnswerCount": "3"}});