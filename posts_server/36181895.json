post_cb({"36181895": {"CommentCount": "0", "ViewCount": "369", "PostTypeId": "1", "LastEditorUserId": "453925", "CreationDate": "2016-03-23T15:11:38.003", "LastActivityDate": "2016-03-23T15:53:11.840", "Title": "Is it legal to use variadic templates in operator overloading?", "AcceptedAnswerId": "36182152", "LastEditDate": "2016-03-23T15:31:31.567", "Id": "36181895", "Score": "9", "Body": "<p>I would like to be able to write something along these lines:</p>\n<pre><code>struct bar {};\n\ntemplate &lt;typename ... Args&gt;\nbar operator+(bar, Args ...)\n{}\n</code></pre>\n<p>I just checked with clang/gcc and the overloaded operator is picked up both by binary expressions (<code>a+b</code>) and unary expressions (<code>+a</code>), as I would expect. However operators are more restricted than normal functions, in the sense that - for instance - you cannot overload <code>operator+()</code> with three arguments.</p>\n<p>Is the usage above legal and portable?</p>\n<p><strong>EDIT</strong> To give a bit of context, I am clearly not expecting to be able to define variadic operators or anything of the sort. The reason I am interested in this is for a ugly hack: I would like to make some operators variadic so that I can \"override\" them with other non-variadic implementations. Since variadic templates are considered to be less specialised than non-variadic templates in the function template overloading rules, I could override a variadic operator with a non-variadic one. Yes it's pretty horrid :)</p>\n", "Tags": "<c++><templates><operator-overloading><language-lawyer><variadic-templates>", "OwnerUserId": "453925", "AnswerCount": "2"}, "36182152": {"ParentId": "36181895", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2016-03-23T15:22:47.187", "Score": "5", "LastEditorUserId": "3647361", "LastEditDate": "2016-03-23T15:53:11.840", "Id": "36182152", "OwnerUserId": "3647361", "Body": "<p>First off, the definition fine, because there exist valid specializations with non-empty packs<sup>1</sup>.  </p>\n<p>Now, specific expressions <code>a+b</code> or <code>+a</code> are i.a. transformed into non-member calls of the form <code>operator+(a, b)</code> and <code>operator+(a)</code>, respectively (<a href=\"http://eel.is/c++draft/over.match.oper#2\" rel=\"nofollow\">[over.match.oper]/2</a>). Name lookup then finds the operator function template, whose specialization becomes part of the candidates. Finally, <a href=\"http://eel.is/c++draft/over.match.oper#6\" rel=\"nofollow\">[over.match.oper]/6</a> just delegates to overload resolution as usual:</p>\n<blockquote>\n<p id=\"so_36181895_36182152_0\">The set of candidate functions for overload resolution is the union of\n  the member candidates, the non-member candidates, and the built-in\n  candidates. <strong>The argument list contains all of the operands of the\n  operator. The best function from the set of candidate functions is\n  selected according to 13.3.2 and 13.3.3.</strong> </p>\n</blockquote>\n<p>Your code will also work as intended, since overload resolution and partial ordering will respect the operator function template like all others.</p>\n<hr>\n<p><sup>1</sup> declaring the above for unary operators, except perhaps postfix <code>--</code> and <code>++</code>, is ill-formed, no diagnostic required. Cf. <a href=\"http://eel.is/c++draft/temp.res#8\" rel=\"nofollow\">[temp.res]/(8.2)</a>.</p>\n</hr>", "LastActivityDate": "2016-03-23T15:53:11.840"}, "36182442": {"ParentId": "36181895", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-03-23T15:34:57.943", "Score": "3", "LastEditorUserId": "567292", "LastEditDate": "2016-03-23T15:47:21.847", "Id": "36182442", "OwnerUserId": "567292", "Body": "<p>The standard restricts the number of arguments (and the presence of default arguments) for <em>operator function</em>s, in <a href=\"http://eel.is/c++draft/over.oper\" rel=\"nofollow\"><strong>[over.oper]</strong></a>:</p>\n<blockquote>\n<p id=\"so_36181895_36182442_0\">8 - An operator function cannot have default arguments ([dcl.fct.default]), except where explicitly stated below. Operator\n  functions cannot have more or fewer parameters than the number required for the corresponding operator,\n  as described in the rest of this subclause.</p>\n</blockquote>\n<p>However, what you have declared is an <em>operator function template</em>, which has no such restrictions. This means that your code is fine; the use of unary or binary <code>+</code> will be transformed into a call to <code>operator+</code> with one or two arguments and an appropriate instantiation of your template will be generated accordingly.</p>\n<p>It would be illegal if you were to specialize or explicitly instantiate the operator function template with an illegal number of arguments, since (<strong>[over.oper]</strong>):</p>\n<blockquote>\n<p id=\"so_36181895_36182442_1\">1 - [...] A specialization of an operator function template is also an operator\n  function. [...]</p>\n</blockquote>\n<hr>\n<p>Note that a similar effect obtains if we write a non-variadic operator function template that can be instantiated with incorrect types:</p>\n<pre><code>template&lt;class T&gt; int operator+(T, T) { return 0; }  // OK\nstruct bar {}; template int operator+(bar, bar);     // OK\ntemplate int operator+(int, int);                    // Error is here\n</code></pre>\n</hr>", "LastActivityDate": "2016-03-23T15:47:21.847"}, "bq_ids": {"n4140": {"so_36181895_36182152_0": {"section_id": 587, "quality": 0.8333333333333334, "length": 25}, "so_36181895_36182442_0": {"section_id": 655, "quality": 0.9629629629629629, "length": 26}, "so_36181895_36182442_1": {"section_id": 648, "quality": 1.0, "length": 7}}, "n3337": {"so_36181895_36182152_0": {"section_id": 577, "quality": 0.8333333333333334, "length": 25}, "so_36181895_36182442_0": {"section_id": 645, "quality": 0.9629629629629629, "length": 26}, "so_36181895_36182442_1": {"section_id": 638, "quality": 1.0, "length": 7}}, "n4659": {"so_36181895_36182152_0": {"section_id": 610, "quality": 0.8333333333333334, "length": 25}, "so_36181895_36182442_0": {"section_id": 683, "quality": 0.9629629629629629, "length": 26}, "so_36181895_36182442_1": {"section_id": 676, "quality": 1.0, "length": 7}}}});