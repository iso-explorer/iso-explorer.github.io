post_cb({"8245027": {"CommentCount": "9", "AcceptedAnswerId": "8246688", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-11-23T15:44:16.633", "LastActivityDate": "2011-12-21T12:10:50.543", "LastEditDate": "2017-05-23T11:44:15.090", "ViewCount": "427", "FavoriteCount": "3", "Title": "Am I right in saying that const_cast followed by modification on a ref-to-const bound to a temporary is okay?", "Id": "8245027", "Score": "18", "Body": "<p>I would like to check my understanding and conclusions on this matter.</p>\n<hr>\n<p>On IRC, it was asked:</p>\n<blockquote>\n<p id=\"so_8245027_8245027_0\">Is it acceptable to <code>const_cast</code> a <code>const</code> reference that's bound to a temporary object?</p>\n</blockquote>\n<p><strong>Translating:</strong> he has a ref-to-const bound to a temporary, and he wants to cast away its <code>const</code>-ness to modify it.</p>\n<p>My response was that I'd asked <a href=\"https://stackoverflow.com/questions/6466253/if-temporaries-are-implicitly-non-modifiable-how-does-this-work\">a similar question</a> previously, where the consensus seemed to be that temporaries themselves are not inherently <code>const</code>, and thus that you can cast off the <code>const</code>-ness of a reference you have to them, and modify them through the result. And, as long as that original ref-to-<code>const</code> still exists, this won't affect the temporary's lifetime.</p>\n<p>That is:</p>\n<pre><code>int main()\n{\n   const int&amp; x = int(3);\n\n   int&amp; y = const_cast&lt;int&amp;&gt;(x);\n   y = 4;\n\n   cout &lt;&lt; x;\n}\n// Output: 4\n// ^ Legal and safe\n</code></pre>\n<p>Am I right?</p>\n<hr>\n<p><sup>(Of course, whether or not such code is actually advisable is another matter entirely!)</sup></p>\n</hr></hr>", "Tags": "<c++><reference><const><const-cast><temporary-objects>", "OwnerUserId": "560648", "AnswerCount": "2"}, "8247251": {"ParentId": "8245027", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The answer depends on how the temporary is created and how the reference is initialized.</p>\n<p>If you explicitly created the temporary yourself as an object of non-const type and the situation guarantees that the const-reference is attached specifically to the temporary you created, then you can safely cast away the constness of the reference and modify the object.</p>\n<p>On the other hand, if the temporary was implicitly created for you by the compiler, then the temporary itself will be const. In that case modifying that temporary leads to UB.</p>\n<p>Unfortunately, the C++ language standard by itself does not seem to seem to guarantee any situations where the first initialization approach is necessarily taken. In any context the compiler is allowed to introduce an extra temporary copy of your original temporary. The new temporary will be const (as stated above) and therefore non-modifiable. Whether this happens or not is implementation-defined, as stated in 8.5.3/5.</p>\n<p>So, in general case the answer is no, while an implementation-specific answer might be different.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2011-11-23T18:31:35.483", "Id": "8247251", "Score": "1", "CreationDate": "2011-11-23T18:25:47.643", "LastActivityDate": "2011-11-23T18:31:35.483"}, "8246688": {"ParentId": "8245027", "PostTypeId": "2", "CommentCount": "10", "Body": "<p><strong>No.</strong></p>\n<p>First, as far as I can tell, whether it is a literal or not is\nirrelevant.  Rvalues of non-class types always have non-cv qualified\ntypes (\u00a73.10/9), however, in \u00a78.5.3 (initialization of a reference), we\nhave:</p>\n<blockquote>\n<p id=\"so_8245027_8246688_0\">A reference to type \u201ccv1 T1\u201d is initialized by an expression of type \u201ccv2 T2\u201d as follows:</p>\n<p id=\"so_8245027_8246688_1\">[...]</p>\n<p id=\"so_8245027_8246688_2\">-- </p>\n<p id=\"so_8245027_8246688_3\">Otherwise, a temporary of type \u201ccv1 T1\u201d is created and initialized from the initializer expression using the rules for a non-reference copy initialization (8.5). The reference is then bound to the temporary.  If T1 is reference-related to T2, cv1 must be the same cv-qualification as, or greater cvqualification\n  than, cv2; otherwise, the program is ill-formed.</p>\n</blockquote>\n<p>(All of the preceding points concern either lvalues or class types.)</p>\n<p>In our case, we have:</p>\n<pre><code>int const&amp; x = ...;\n</code></pre>\n<p>So <em>cv1 T1</em> is <code>int const</code>, and the temporary object we create has type\n<code>int const</code>.  This is a top level const (on the object), so any attempt\nto modify it is undefined behavior.</p>\n<p>At least, that's my interpretation.  I wish the standard were a bit clearer about this.</p>\n", "OwnerUserId": "649665", "LastEditorUserId": "560648", "LastEditDate": "2011-11-23T18:21:41.460", "Id": "8246688", "Score": "8", "CreationDate": "2011-11-23T17:41:29.447", "LastActivityDate": "2011-11-23T18:21:41.460"}, "bq_ids": {"n4140": {"so_8245027_8246688_0": {"section_id": 3321, "quality": 0.75, "length": 6}, "so_8245027_8246688_3": {"section_id": 3321, "quality": 0.5517241379310345, "length": 16}, "so_8245027_8245027_0": {"section_id": 5992, "quality": 0.625, "length": 5}}, "n3337": {"so_8245027_8246688_0": {"section_id": 3191, "quality": 0.75, "length": 6}, "so_8245027_8246688_3": {"section_id": 3191, "quality": 0.6896551724137931, "length": 20}, "so_8245027_8245027_0": {"section_id": 5760, "quality": 0.625, "length": 5}}, "n4659": {"so_8245027_8246688_0": {"section_id": 4087, "quality": 0.75, "length": 6}, "so_8245027_8245027_0": {"section_id": 7494, "quality": 0.625, "length": 5}}}});