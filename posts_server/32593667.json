post_cb({"32593667": {"CommentCount": "4", "AcceptedAnswerId": "32593988", "LastEditDate": "2017-05-23T12:22:06.720", "LastEditorUserId": "-1", "CreationDate": "2015-09-15T19:03:17.250", "LastActivityDate": "2015-09-15T21:32:45.793", "PostTypeId": "1", "ViewCount": "411", "Title": "Bug with std::deque?", "Id": "32593667", "OwnerUserId": "2471910", "Body": "<p>I am trying to delete an element from a deque using a loop and an iterator.  I am following <a href=\"https://stackoverflow.com/a/2874533/2471910\">online examples</a> but seeing a bug.</p>\n<p>I am using g++ (GCC) 4.8.3 20140911 (Red Hat 4.8.3-9).</p>\n<p>Here is the code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\n\n// Display the contents of a queue\nvoid disp_deque(deque&lt;int&gt;&amp; deque) {\n  cout &lt;&lt; \"deque contains: \";\n  for (auto itr = deque.begin(); itr!=deque.end(); ++itr)\n    cout &lt;&lt; *itr &lt;&lt; ' ';\n  cout &lt;&lt; '\\n';\n}\n\nint main(int argc, char** argv) {\n  deque&lt;int&gt; mydeque;\n\n  // Put 10 integers in the deque.\n  for (int i=1; i&lt;=10; i++) mydeque.push_back(i);\n  disp_deque(mydeque);\n\n  auto it = mydeque.begin(); \n  while (it!=mydeque.end()) {\n    cout &lt;&lt; \"Checking \" &lt;&lt; *it &lt;&lt; ',';\n    // Delete even numbered values.\n    if ((*it % 2) == 0) {\n      cout &lt;&lt; \"Deleting \" &lt;&lt; *it &lt;&lt; '\\n';\n      mydeque.erase(it++);\n      disp_deque(mydeque);\n    } else ++it;\n  }\n}\n</code></pre>\n<p>It is pretty straight forward - create a list of 10 elements and delete the even ones.</p>\n<p>Notice the following (fluff excluded):</p>\n<pre><code>if ((*it % 2) == 0) {\n  mydeque.erase(it++);\n} else it++;\n</code></pre>\n<p>It is the recommended way to delete using an iterator so that your iterator does not get invalidated as mentioned in the link above.</p>\n<p>However, when I run this, I get the following:</p>\n<pre><code>$ ./test\ndeque contains: 1 2 3 4 5 6 7 8 9 10 \nChecking 1,Checking 2,Deleting 2\ndeque contains: 1 3 4 5 6 7 8 9 10 \nChecking 3,Checking 4,Deleting 4\ndeque contains: 1 3 5 6 7 8 9 10 \nChecking 5,Checking 6,Deleting 6\ndeque contains: 1 3 5 7 8 9 10 \nChecking 7,Checking 8,Deleting 8\ndeque contains: 1 3 5 7 9 10 \nChecking 10,Deleting 10\ndeque contains: 1 3 5 7 9 \nChecking 10,Deleting 10\ndeque contains: 1 3 5 7 \nChecking 0,Deleting 0\ndeque contains: 1 3 5 \nChecking 0,Deleting 0\ndeque contains: 1 3 \nChecking 0,Deleting 0\ndeque contains: 1 \nChecking 0,Deleting 0\ndeque contains: \nChecking 0,Deleting 0\nSegmentation fault (core dumped)\n</code></pre>\n<p>Looking through it, it seems pretty good up until it deletes 8.  In fact, number 9 is skipped altogether and never checked! What I expect should happen is this:</p>\n<pre><code>$ ./test\ndeque contains: 1 2 3 4 5 6 7 8 9 10 \nChecking 1,Checking 2,Deleting 2\ndeque contains: 1 3 4 5 6 7 8 9 10 \nChecking 3,Checking 4,Deleting 4\ndeque contains: 1 3 5 6 7 8 9 10 \nChecking 5,Checking 6,Deleting 6\ndeque contains: 1 3 5 7 8 9 10 \nChecking 7,Checking 8,Deleting 8\ndeque contains: 1 3 5 7 9 10 \nChecking 9,Checking 10,Deleting 10\ndeque contains: 1 3 5 7 9 \n</code></pre>\n<p>In fact, this is exactly what I get when I change the code to this:</p>\n<pre><code>if ((*it % 2) == 0) {\n  it=mydeque.erase(it);\n} else it++;\n</code></pre>\n<p>So, why does one method work, but the other not?  Can anyone explain it?</p>\n<p>Even if I create a temporary iterator to delete, I see the exact same problem output:</p>\n<pre><code>  while (it!=mydeque.end()) {\n    cout &lt;&lt; \"Checking \" &lt;&lt; *it &lt;&lt; ',';\n    auto tmp_it = it++;\n    // Delete even numbered values.\n    if ((*tmp_it % 2) == 0) {\n      cout &lt;&lt; \"Deleting \" &lt;&lt; *tmp_it &lt;&lt; '\\n';\n      cout &lt;&lt; \"IT before delete: \" &lt;&lt; *it &lt;&lt; '\\n';\n      mydeque.erase(tmp_it);\n      cout &lt;&lt; \"IT after delete: \" &lt;&lt; *it &lt;&lt; '\\n';\n      disp_deque(mydeque);\n    } \n  }\n</code></pre>\n<p>Here I store a copy of it in tmp_it and then increment it.  I added some more debug statements and saw some really weird stuff:</p>\n<pre><code>...\ndeque contains: 1 3 5 6 7 8 9 10 \nChecking 5,Checking 6,Deleting 6\nIT before delete: 7\nIT after delete: 7\ndeque contains: 1 3 5 7 8 9 10 \nChecking 7,Checking 8,Deleting 8\nIT before delete: 9\nIT after delete: 10\ndeque contains: 1 3 5 7 9 10 \nChecking 10,Deleting 10\nIT before delete: 10\nIT after delete: 10\n...\n</code></pre>\n<p>However, the deletion of element 8 makes it point to element 10, skipping 9!  On previous deletes, it was pointing to the previous element (e.g. when 6 was deleted, it was pointing to 7 before and after the delete). </p>\n<p>I looked up the implementation of <a href=\"http://www.cplusplus.com/reference/deque/deque/erase\" rel=\"nofollow noreferrer\">deque</a> and see under \"Iterator Validity\" the following (emphasis mine):</p>\n<blockquote>\n<p id=\"so_32593667_32593667_0\">Iterator validity If the erasure operation includes the last element\n  in the sequence, the end iterator and the iterators, pointers and\n  references referring to the erased elements are invalidated. If the\n  erasure includes the first element but not the last, only those\n  referring to the erased elements are invalidated. <strong>If it happens\n  anywhere else in the deque, all iterators, pointers and references\n  related to the container are invalidated.</strong></p>\n</blockquote>\n<p>So does that mean that in my code, my iterator is being invalidated even though I did a post increment on it before it is deleted?  i.e. an iterator other than the one I deleted is being invalidated?</p>\n<p>If so, then that it fine, but it seems like a little known bug.  It means that <a href=\"https://stackoverflow.com/a/596180/2471910\">common</a> implementations of iterator deletion within a loop are not valid when using deque.</p>\n", "Tags": "<c++><c++11><iterator><deque>", "Score": "3", "AnswerCount": "4"}, "32593737": {"ParentId": "32593667", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_32593667_32593737_0\">So does that mean that in my code, my iterator is being invalidated even though I did a post increment on it before it is deleted?</p>\n</blockquote>\n<p>That's exactly what it means. Whether that invalidation has any effect on your results or not, that depends on the implementation of the <code>dequeue</code> in your runtime library. It might also go well for many cases and then fail all the sudden, like for your 8.</p>\n<p>The post incrementation trick only works for containers, where the <code>erase</code> only invalidates the iterator to the erased element (like for <code>list</code>s and <code>set</code>s). In those cases the post increment creates an iterator to the <em>next</em> element, and does so <em>before</em> the element is erased. That iterator to the <em>next</em> element is therefore immune to the invalidations related to the erase. In the case of the <code>dequeue</code>, however, the specification says that <em>all</em> iterators are invalidated.</p>\n", "OwnerUserId": "5339233", "LastEditorUserId": "5339233", "LastEditDate": "2015-09-15T19:22:17.977", "Id": "32593737", "Score": "1", "CreationDate": "2015-09-15T19:06:48.303", "LastActivityDate": "2015-09-15T19:22:17.977"}, "32593988": {"ParentId": "32593667", "CommentCount": "3", "Body": "<p>The code you quoted is for <strong>associative containers</strong> only (<code>set</code>, <code>map</code> etc.).</p>\n<p>Scott Meyers's <a href=\"http://rads.stackoverflow.com/amzn/click/0201749629\" rel=\"nofollow\"><strong>Effective STL</strong></a> Item 9 (aptly named \"Choose carefully among erasing options\") shows how it's done for <strong>sequence containers</strong> (vector, deque, string)</p>\n<pre><code>for (SeqContainer&lt;int&gt;::iterator it = c.beqin(); it != c.end();) {\n    if (predicate(*it)){\n        it = c.erase(it); // keep it valid by assigning\n    }                     // erase's return value to it\n    else ++it;\n}\n</code></pre>\n<p>Here, the <code>erase()</code> return value is exactly what we need: it's a\nvalid iterator pointing to the element following the erased element once the erase has been accomplished.</p>\n", "OwnerUserId": "819272", "PostTypeId": "2", "Id": "32593988", "Score": "2", "CreationDate": "2015-09-15T19:21:35.157", "LastActivityDate": "2015-09-15T19:21:35.157"}, "32596020": {"ParentId": "32593667", "CommentCount": "0", "Body": "<p>C++14 introduces generic <code>erase_if</code> algorithm that works correctly with all types of standard containers.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/experimental/deque/erase_if\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/experimental/deque/erase_if</a></p>\n<p>This is equivalent to the last code block provided by @Barry:</p>\n<pre><code>#include &lt;experimental/deque&gt;\nstd::experimental::erase_if(mydeque, [](int i){return i%2 == 0; });\n</code></pre>\n<p>It is also better to use this generic algorithm compared to direct erase/remove-if pattern, because if you ever decide to replace your container to <code>std::set</code>, for example, you will not need to update the code that handles removal.</p>\n", "OwnerUserId": "4256624", "PostTypeId": "2", "Id": "32596020", "Score": "1", "CreationDate": "2015-09-15T21:32:45.793", "LastActivityDate": "2015-09-15T21:32:45.793"}, "bq_ids": {"n4659": {"so_32593667_32593864_0": {"section_id": 802, "quality": 0.5333333333333333, "length": 8}}}, "32593864": {"ParentId": "32593667", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From cppreference on <a href=\"http://en.cppreference.com/w/cpp/container/deque/erase\" rel=\"nofollow noreferrer\"><code>deque::erase()</code></a>:</p>\n<blockquote>\n<p id=\"so_32593667_32593864_0\"><strong>All iterators and references are invalidated</strong>, unless the erased elements are at the end or the beginning of the container, in which case only the iterators and references to the erased elements are invalidated.</p>\n</blockquote>\n<p><strong>All</strong> iterators. All of them. When you do this:</p>\n<pre><code>mydeque.erase(it++);\n</code></pre>\n<p>It doesn't matter that you post-incremented <code>it</code>, that new iterator is invalidated too. This is precisely why <code>erase()</code> <em>returns</em>:</p>\n<blockquote>\n<p id=\"so_32593667_32593864_1\">Iterator following the last removed element. If the iterator pos refers to the last element, the end() iterator is returned.</p>\n</blockquote>\n<p>So that you can do:</p>\n<pre><code>it = mydeque.erase(it); // erase old it, new it is valid\n</code></pre>\n<p>Although even better would be to avoid this source of error entirely by using the erase-remove idiom:</p>\n<pre><code>mydeque.erase(\n   std::remove_if(mydeque.begin(), mydeque.end(), [](int i){return i%2 == 0; }),\n   mydeque.end()\n);\n</code></pre>\n<p>See also <a href=\"https://stackoverflow.com/q/6438086/2069064\">this question</a> for more information about iterator invalidation. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:14:12.537", "Id": "32593864", "Score": "7", "CreationDate": "2015-09-15T19:14:55.163", "LastActivityDate": "2015-09-15T19:14:55.163"}});