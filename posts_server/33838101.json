post_cb({"bq_ids": {"n4140": {"so_33838101_33838558_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 87}, "so_33838101_33838558_5": {"length": 31, "quality": 0.96875, "section_id": 6186}, "so_33838101_33838558_8": {"length": 9, "quality": 0.8181818181818182, "section_id": 87}, "so_33838101_33838558_7": {"length": 4, "quality": 0.6666666666666666, "section_id": 87}, "so_33838101_33838558_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 87}, "so_33838101_33838558_10": {"length": 31, "quality": 0.96875, "section_id": 6186}}, "n3337": {"so_33838101_33838558_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 82}, "so_33838101_33838558_5": {"length": 27, "quality": 0.84375, "section_id": 5947}, "so_33838101_33838558_8": {"length": 9, "quality": 0.8181818181818182, "section_id": 82}, "so_33838101_33838558_7": {"length": 4, "quality": 0.6666666666666666, "section_id": 82}, "so_33838101_33838558_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 82}, "so_33838101_33838558_10": {"length": 27, "quality": 0.84375, "section_id": 5947}}, "n4659": {"so_33838101_33838558_8": {"length": 7, "quality": 0.6363636363636364, "section_id": 4776}, "so_33838101_33838558_5": {"length": 27, "quality": 0.84375, "section_id": 7689}, "so_33838101_33838558_2": {"length": 7, "quality": 0.6363636363636364, "section_id": 4776}, "so_33838101_33838558_10": {"length": 27, "quality": 0.84375, "section_id": 7689}}}, "33838122": {"Id": "33838122", "PostTypeId": "2", "Body": "<p>My clang refuses to compile this:</p>\n<pre><code>test.cpp|24 col 8| error: non-type template argument evaluates to -1, which cannot be narrowed to type 'std::size_t' (aka 'unsigned long') [-Wc++11-narrowing]\n E1&lt;-1&gt;::apply();\n    ^\ntest.cpp|25 col 5| error: no matching function for call to 'E2'\n E2&lt;-1, -2, -3&gt;(); \n ^~~~~~~~~~~~~~\ntest.cpp|16 col 6| note: candidate template ignored: invalid explicitly-specified argument for template parameter 'Is'\n void E2()\n</code></pre>\n<p>So, in c++11 it should already be disallowed.</p>\n<p>Other than that, it's a non-issue, because the template argument will actually not be negative. Maybe add a static assertion that the value is within a specific range.</p>\n", "LastActivityDate": "2015-11-21T00:10:50.850", "CommentCount": "0", "CreationDate": "2015-11-21T00:10:50.850", "ParentId": "33838101", "Score": "3", "OwnerUserId": "85371"}, "33838558": {"Id": "33838558", "PostTypeId": "2", "Body": "<p>This is actually a GCC bug, as there should be a diagnostic(<em>warning or error</em>) for narrowing here. The bug report is <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60715\" rel=\"nofollow\">Narrowing conversions not caught in non-type template parameters</a> and it has the following example:</p>\n<pre><code>template&lt;        char&gt; void   f () {}\ntemplate&lt;unsigned int&gt; void   g () {}\n\n\ntemplate&lt;unsigned int&gt; struct A {};\n\nint main () {\n\n  f&lt;1024&gt; (); // ill-formed, `char { 1024 }` is a narrowing conversion,\n              // see [dcl.init.list]p7\n\n  g&lt;-123&gt; (); // ill-formed, `unsigned int { -123 }` is a narrowing\n              // conversion, see [dcl.init.list]p7   \n\n  A&lt;-123&gt;  a; // ill-formed, see previous comment\n}\n</code></pre>\n<p>and it points out the relevant quotes from the C++ standard:</p>\n<blockquote>\n<p id=\"so_33838101_33838558_0\">[temp.arg.nontype]p1;</p>\n<blockquote>\n<p id=\"so_33838101_33838558_7\">A template-argument for a non-type, non-template template\n    parameeter shall be one of:</p>\n<ul>\n<li><p id=\"so_33838101_33838558_8\">for a non-type template-aprameter of integral or enumeration\n    type, a converted constant expression (5.19) of the type of\n    the template-parameter</p>\n<p id=\"so_33838101_33838558_9\">&lt;snip /&gt;</p></li>\n</ul>\n</blockquote>\n<p id=\"so_33838101_33838558_4\">[expr.const]p3;</p>\n<blockquote>\n<p id=\"so_33838101_33838558_10\">A converted constant expression of type <code>T</code> is an expression,\n    implicitly converted to a prvalue of type <code>T</code>, where the converted\n    expression is a core constant expression and the implicit\n    conversion sequence contains only user-defined conversions,\n    lvalue-to-rvalue conversions (4.1), integral promotions (4.5), and\n    integral conversions (4.7) other than narrowing conversions\n    (8.5.4).</p>\n</blockquote>\n<hr>\n<p id=\"so_33838101_33838558_6\">[ Note: <code>gcc</code> accepts testcase.cpp, while <code>clang</code> (correctly) issues\n  the relevant diagnostics. ]</p>\n</hr></blockquote>\n<p>as sehe noted clang correctly produces a diagnostic for this with the following error:</p>\n<pre><code>error: non-type template argument evaluates to -1, which cannot be narrowed to type 'std::size_t' (aka 'unsigned long') [-Wc++11-narrowing]\nE1&lt;-1&gt;::apply();\n   ^\n\nerror: no matching function for call to 'E2'\nE2&lt;-1, -2, -3&gt;(); \n^~~~~~~~~~~~~~\n</code></pre>\n<p>As a work-around you can use <code>-Wsign-conversion -Werror</code>(<em><a href=\"https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html\" rel=\"nofollow\">both documented here</a></em>) to warn about this case and turn it into an error (<em><a href=\"http://melpon.org/wandbox/permlink/c5ahz1TvZ1thdGJ3\" rel=\"nofollow\">see it live</a></em>). I originally thought this would be caught by <code>-Wconversion</code> but <code>-Wsign-conversion</code> is turned off by default in C++.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-12-04T19:51:49.960", "Score": "7", "CreationDate": "2015-11-21T01:07:41.790", "ParentId": "33838101", "CommentCount": "1", "OwnerUserId": "1708801", "LastEditDate": "2015-12-04T19:51:49.960"}, "33838101": {"ViewCount": "189", "Body": "<p>I usually use <code>std::size_t</code> where integral constants are needed in template parameters. What I notice though, is that the type system doesn't protect me from users that are happy to pass negative numbers as arguments to those parameters. </p>\n<p>For example the following compiles giving disastrous results : </p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;std::size_t I&gt;\nstruct E1\n{\n     static void apply()\n     {\n         std::cout &lt;&lt; I &lt;&lt; std::endl;\n     }\n};\n\ntemplate&lt;typename T&gt;\nconstexpr T a = T { -1 }; \n\ntemplate&lt;std::size_t... Is&gt;\nvoid E2()\n{\n    for (auto&amp;&amp; i : {Is...}) std::cout &lt;&lt; i &lt;&lt; \" \"; \n    std::cout &lt;&lt; std::endl;\n}\n\nint main()\n{\n    E1&lt;-1&gt;::apply();\n    E2&lt;-1, -2, -3&gt;(); \n    //std::cout &lt;&lt; a&lt;std::size_t&gt;; \n}\n</code></pre>\n<p><kbd><a href=\"http://coliru.stacked-crooked.com/a/2b2012622b37f039\" rel=\"nofollow\">Demo</a></kbd></p>\n<p>Interestingly this is not allowed for variable templates (uncommenting the last line in <code>main</code> causes a compilation error). </p>\n<p>Is there any solution/workaround for the <code>struct</code> and <code>function</code> case ? </p>\n", "AcceptedAnswerId": "33838558", "Title": "Guard against type violations in non type template parameters", "CreationDate": "2015-11-21T00:07:52.410", "Id": "33838101", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-12-04T19:51:49.960", "Score": "4", "OwnerUserId": "4224575", "Tags": "<c++><templates><c++14>", "AnswerCount": "2"}});