post_cb({"bq_ids": {"n4140": {"so_33436150_33436457_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 5975}, "so_33436150_33436340_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 5975}}, "n3337": {"so_33436150_33436457_0": {"length": 21, "quality": 0.7777777777777778, "section_id": 5743}, "so_33436150_33436340_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 5743}}, "n4659": {"so_33436150_33436457_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 7475}, "so_33436150_33436340_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 7475}}}, "33436150": {"ViewCount": "121", "Body": "<p>Is there any overhead in using a default capture mode?</p>\n<pre><code>{\n   Foo foo = ...;\n   Bar bar = ...;\n   [&amp;]()\n   {\n       write(foo);\n   }\n}\n\n{\n   Foo foo = ...;\n   Bar bar = ...;\n   [&amp;foo]()\n   {\n       write(foo);\n   }\n}\n</code></pre>\n<p>To clarify is there any cost in using the former related to bar being capture even if not used?</p>\n", "AcceptedAnswerId": "33436457", "Title": "Closure default capture overhead", "CreationDate": "2015-10-30T12:36:47.007", "Id": "33436150", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-10-30T13:09:59.967", "LastEditorUserId": "1708801", "LastActivityDate": "2015-10-31T16:38:47.197", "Score": "6", "OwnerUserId": "491807", "Tags": "<c++><lambda><c++14>", "AnswerCount": "2"}, "33436457": {"Id": "33436457", "PostTypeId": "2", "Body": "<p>It is unspecified how the lambda deals with entities captured by reference, from the draft C++14 standard(<code>N4140</code>) section <code>5.1.2</code> [expr.prim.lambda]:</p>\n<blockquote>\n<p id=\"so_33436150_33436457_0\">An entity is captured by reference if it is implicitly or explicitly\n  captured but not captured by copy. It is unspecified whether\n  additional unnamed non-static data members are declared in the closure\n  type for entities captured by reference. A member of an anonymous\n  union shall not be captured by reference</p>\n</blockquote>\n<p>This wording was purposely left open to allow implementations to optimize around this, see <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#750\" rel=\"nofollow\">defect report 750:  Implementation constraints on reference-only closure objects </a> which references <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf\" rel=\"nofollow\">N2927</a> which says:</p>\n<blockquote>\n<p id=\"so_33436150_33436457_1\">The new wording no longer specifies any rewrite or closure members for\n  \"by reference\" capture. Uses of entities captured \"by reference\"\n  affect the original entities, and the mechanism to achieve this is\n  left entirely to the implementation.</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-10-31T16:38:47.197", "Score": "3", "CreationDate": "2015-10-30T12:52:10.087", "ParentId": "33436150", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2015-10-31T16:38:47.197"}, "33436340": {"Id": "33436340", "PostTypeId": "2", "Body": "<p>N3337 5.1.2/15 or N4527 (C++14 final draft) 5.1.2/16</p>\n<blockquote>\n<p id=\"so_33436150_33436340_0\">An entity is captured by reference if it is implicitly or explicitly\n  captured but not captured by copy. <strong>It is unspecified whether\n  additional unnamed non-static data members are declared in the closure\n  type for entities captured by reference.</strong></p>\n</blockquote>\n", "LastEditorUserId": "1498580", "LastActivityDate": "2015-10-30T12:53:34.117", "Score": "2", "CreationDate": "2015-10-30T12:46:51.530", "ParentId": "33436150", "CommentCount": "1", "OwnerUserId": "1498580", "LastEditDate": "2015-10-30T12:53:34.117"}});