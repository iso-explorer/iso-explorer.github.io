post_cb({"41757976": {"ParentId": "41757634", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>According to the C++ standard <em>\u00a74.14/p1 Boolean conversions [conv.bool]</em> (<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_41757634_41757976_0\">A prvalue of arithmetic, unscoped enumeration, <strong>pointer</strong>, or pointer to\n  member type <strong>can be converted to a prvalue of type bool. A zero value,\n  null pointer value, or null member pointer value is converted to\n  false; any other value is converted to true.</strong> For direct-initialization\n  (8.6), a prvalue of type std::nullptr_t can be converted to a prvalue\n  of type bool; the resulting value is false.</p>\n</blockquote>\n<p>That is, according the C++ standard, conversion from a string literal (i.e., pointer) to a boolean is a standard conversion and thus what you're experiencing is perfectly normal/standard language behavior.</p>\n<p>You can restrict your function to explicitly accept only bool values by defining a generic overload of your function as deleted:</p>\n<pre><code>template&lt;typename T&gt; void func(T&amp;&amp;) = delete;\n\nvoid func(bool a) {\n  // do something...\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/8c0cba9b4ae0d858\" rel=\"nofollow noreferrer\"><strong>Live Demo</strong></a></p>\n", "OwnerUserId": "2352671", "LastEditorUserId": "2352671", "LastEditDate": "2017-01-20T07:18:27.863", "Id": "41757976", "Score": "4", "CreationDate": "2017-01-20T07:11:51.033", "LastActivityDate": "2017-01-20T07:18:27.863"}, "41757825": {"ParentId": "41757634", "CommentCount": "0", "Body": "<p>Pointers can be implicitly converted to <code>bool</code>; The value is <code>false</code>, if the pointer is <code>NULL</code>, and it is <code>true</code> if the pointer is <code>!NULL</code>. Hence, since you pass a pointer to <code>char *</code>-literal <code>\"false\"</code>, this pointer is <code>! NULL</code> and yields <code>true</code>. See the following definition in the <a href=\"http://en.cppreference.com/w/cpp/language/implicit_conversion\" rel=\"nofollow noreferrer\">cpp reference concerning of implicit conversion</a>:</p>\n<blockquote>\n<p id=\"so_41757634_41757825_0\">Boolean conversions</p>\n<p id=\"so_41757634_41757825_1\">A prvalue of integral, floating-point, unscoped\n  enumeration, pointer, and pointer-to-member types can be converted to\n  a prvalue of type bool. The value zero (for integral, floating-point,\n  and unscoped enumeration) and the null pointer and the null\n  pointer-to-member values become false. All other values become true</p>\n</blockquote>\n", "OwnerUserId": "2630032", "PostTypeId": "2", "Id": "41757825", "Score": "2", "CreationDate": "2017-01-20T07:00:37.057", "LastActivityDate": "2017-01-20T07:00:37.057"}, "41757634": {"CommentCount": "6", "ViewCount": "170", "PostTypeId": "1", "LastEditorUserId": "2378300", "CreationDate": "2017-01-20T06:48:02.007", "LastActivityDate": "2017-05-15T08:42:00.320", "Title": "Why a function with Bool argument accepts String?", "AcceptedAnswerId": "41757736", "LastEditDate": "2017-05-15T08:42:00.320", "Id": "41757634", "Score": "2", "Body": "<p>I have a function which accepts an bool as an argument:</p>\n<pre><code>void func(bool a)\n{\n    doing something;\n}\n</code></pre>\n<p>But when I'm calling the function and passed string to it:</p>\n<pre><code>func(\"false\");\n</code></pre>\n<p>Actually it should accept only.</p>\n<pre><code>func(false);\n</code></pre>\n<p>It accepts string without any error.</p>\n<p>why?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "7378636", "AnswerCount": "4"}, "41759169": {"ParentId": "41757634", "CommentCount": "0", "Body": "<p>@101010's answer is good. But for the benefit of those with older compilers (which I suspect do not accept that syntax), there is an alternative approach.</p>\n<p>First:<br>\nA template function <em>declaration</em> with no <em>definition/implementation</em>. That way, if you call it accidentally with <code>func(\"false\")</code> or <code>func('y')</code> or <code>func(0)</code> (an int), the linker will complain. Which will make you look for the problem.</br></p>\n<pre><code>template&lt;typename T&gt; void func(T a);  // prototype only\n</code></pre>\n<p>Declare this alongside your real <code>void func(bool a)</code> function.</p>\n<p>If you have this inside a class, you can make the template function/method private, which will make the error into a compiler error (easier to understand, but if the accidental mis-typed call comes from within a class or friend, it will still be a linker error).</p>\n", "OwnerUserId": "7428768", "PostTypeId": "2", "Id": "41759169", "Score": "1", "CreationDate": "2017-01-20T08:30:47.900", "LastActivityDate": "2017-01-20T08:30:47.900"}, "41757736": {"ParentId": "41757634", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Literal string is a char pointer, and pointer will be implicitly converted to bool. </p>\n<ul>\n<li>Null pointer -&gt; <code>false</code></li>\n<li>Non-null pointer -&gt; <code>true</code></li>\n</ul>\n<p>In this case, the <em>func</em> will receive a <code>true</code> value from the non-null <em>\"false\"</em> string , which is <code>const char*</code> type.</p>\n<p>You may need an interpreter function to able to read \"false\", \"0\", \"no\", etc from keyboard typing and convert to bool false which the program can understand.</p>\n", "OwnerUserId": "2210478", "LastEditorUserId": "2210478", "LastEditDate": "2017-01-20T07:16:17.607", "Id": "41757736", "Score": "4", "CreationDate": "2017-01-20T06:54:33.833", "LastActivityDate": "2017-01-20T07:16:17.607"}, "bq_ids": {"n4140": {"so_41757634_41757976_0": {"section_id": 44, "quality": 0.975609756097561, "length": 40}}, "n3337": {"so_41757634_41757976_0": {"section_id": 41, "quality": 0.9512195121951219, "length": 39}}, "n4659": {"so_41757634_41757976_0": {"section_id": 45, "quality": 0.975609756097561, "length": 40}}}});