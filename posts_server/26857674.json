post_cb({"bq_ids": {"n4140": {"so_26857674_26857674_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 3321}, "so_26857674_26857674_2": {"length": 6, "quality": 1.0, "section_id": 3321}, "so_26857674_26857732_3": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_26857674_26857732_0": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_26857674_26857732_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 3321}, "so_26857674_26857674_1": {"length": 5, "quality": 1.0, "section_id": 3321}, "so_26857674_26857674_0": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_26857674_26857674_6": {"length": 9, "quality": 0.8181818181818182, "section_id": 5938}, "so_26857674_26857674_3": {"length": 44, "quality": 0.88, "section_id": 3321}}, "n3337": {"so_26857674_26857674_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 3191}, "so_26857674_26857732_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 3191}, "so_26857674_26857674_2": {"length": 6, "quality": 1.0, "section_id": 3191}, "so_26857674_26857732_3": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_26857674_26857732_0": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_26857674_26857674_6": {"length": 9, "quality": 0.8181818181818182, "section_id": 5710}, "so_26857674_26857674_1": {"length": 5, "quality": 1.0, "section_id": 3191}, "so_26857674_26857674_0": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_26857674_26857674_3": {"length": 44, "quality": 0.88, "section_id": 3191}}, "n4659": {"so_26857674_26857674_5": {"length": 12, "quality": 1.0, "section_id": 4087}, "so_26857674_26857732_1": {"length": 12, "quality": 1.0, "section_id": 4087}, "so_26857674_26857674_2": {"length": 6, "quality": 1.0, "section_id": 4087}, "so_26857674_26857732_3": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_26857674_26857732_0": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_26857674_26857674_6": {"length": 9, "quality": 0.8181818181818182, "section_id": 7422}, "so_26857674_26857674_1": {"length": 5, "quality": 1.0, "section_id": 4087}, "so_26857674_26857674_0": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_26857674_26857674_3": {"length": 47, "quality": 0.94, "section_id": 4087}}}, "26857674": {"ViewCount": "295", "Body": "<p>I've written the following example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvolatile int&amp;&amp; bar()\n{\n    return 1;\n}\n\nint main()\n{\n    const int&amp; i = bar(); //error: binding of reference to type 'const int' \n                          //to a value of type 'volatile int' drops qualifiers\n}\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/b54a5c0f73a3f559\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>But if we replace <code>int&amp;&amp;</code> with <code>int</code> it works fine:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvolatile int bar()\n{\n    return 1;\n}\n\nint main()\n{\n    const int&amp; i = bar(); //OK\n\n}\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/87b7778545007a7e\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>that's not exactly clear. What the Standard says is (<code>8.5.3/5  [dcl.init.ref]</code>):</p>\n<blockquote>\n<p id=\"so_26857674_26857674_0\">A reference to type \u201ccv1 T1\u201d is initialized by an expression of type\n  \u201ccv2 T2\u201d as follows: </p>\n<p id=\"so_26857674_26857674_1\">\u2014 If the reference is an lvalue reference and the\n  initializer expression </p>\n<ul>\n<li><p id=\"so_26857674_26857674_2\">is an lvalue (but is not a bit-field), and \u201ccv1 T1\u201d is reference-compatible with \u201ccv2 T2,\u201d or </p></li>\n<li><p id=\"so_26857674_26857674_3\">has a class type (i.e., T2 is a class type), where T1 is not reference-related to T2,\n  and can be converted to an lvalue of type \u201ccv3 T3,\u201d where \u201ccv1 T1\u201d is reference-compatible with \n  \u201ccv3 T3\u201d 108 (this conversion is selected by enumerating the applicable conversion functions \n  (13.3.1.6) and choosing the best one through overload resolution (13.3)), then the\n  reference is bound to the initializer expression lvalue in the first\n  case and to the lvalue result of the conversion in the second case\n  (or, in either case, to the appropriate base class subobject of the\n  object). </p></li>\n</ul>\n<p id=\"so_26857674_26857674_4\">[...]</p>\n<p id=\"so_26857674_26857674_5\">\u2014 <em>Otherwise, the reference shall be an lvalue reference to a</em>\n<em>non-volatile const type (i.e., cv1 shall be const), or the reference</em>\n<em>shall be an rvalue reference.</em> </p>\n</blockquote>\n<p>Well, in the first example we have an rvalue of type <code>volatile int&amp;&amp;</code>. And the <code>'otherwise'</code> case is applicable to both two examples. But <code>5/5 [expr]</code> says:</p>\n<blockquote>\n<p id=\"so_26857674_26857674_6\">If an expression initially has the type \u201creference to T\u201d (8.3.2,\n  8.5.3), the type is adjusted to T prior to any further analysis</p>\n</blockquote>\n<p>So, essentially we have an rvalue of type <code>volatile int</code> instead of <code>volatile int&amp;&amp;</code>, which means both these two examples shall work in the same way.</p>\n", "AcceptedAnswerId": "26857732", "Title": "Why can't we initialize a reference to const int with an rvalue volatile int&&?", "CreationDate": "2014-11-11T04:47:30.360", "Id": "26857674", "CommentCount": "0", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastActivityDate": "2014-11-11T05:25:57.143", "Score": "3", "Tags": "<c++><reference>", "AnswerCount": "1"}, "26857732": {"Id": "26857732", "PostTypeId": "2", "Body": "<p>The difference between the two cases is that in Case 1, the references <em>binds directly</em> and in Case 2, it does not bind directly (i.e. the reference binds to a temporary; definition can be found in  the last paragraph of <code>[dcl.init.ref]</code>).</p>\n<p>The direct binding fails because <em>T2</em> is volatile-qualified and <em>T1</em> isn't (in the Standard terminology, <em>T1</em> is not <em>reference-compatible</em> with <em>T2</em>).</p>\n<p>The indirect binding succeeds because when a temporary <code>int</code> is initialized from the reference returned by <code>bar()</code>, the temporary is not <code>volatile</code>. (The temporary has type <em>cv1 T1</em>).</p>\n<hr>\n<p>To see why Case 1 is a direct binding. Firstly, <code>bar()</code> is an <strong>xvalue</strong> here. See <code>[basic.lval]/1</code> \"The result of calling a function whose return type is an rvalue reference is an xvalue\".</p>\n<p>From <code>[dcl.init.ref]/5</code>:</p>\n<blockquote id=\"so_26857674_26857732_0\">\n<ul>\n<li>If the reference is an lvalue reference and the initializer expression [is an lvalue] or [has class type]</li>\n</ul>\n</blockquote>\n<p>Not applicable: the initializer is an xvalue (not an lvalue), and it is a reference so it does not have class type.</p>\n<blockquote id=\"so_26857674_26857732_1\">\n<ul>\n<li>Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e., cv1 shall be const), or the reference shall be an rvalue reference</li>\n</ul>\n</blockquote>\n<p>This does apply: <code>const int &amp;</code> is an lvalue reference to non-volatile const type. Going down this tree:</p>\n<blockquote>\n<p id=\"so_26857674_26857732_2\">If the initializer expression</p>\n<ul>\n<li>is an xvalue (but not a bit-field), class prvalue, array prvalue or function lvalue and \u201ccv1 T1\u201d is reference-compatible with \u201ccv2 T2\u201d, or</li>\n<li>[another case]</li>\n</ul>\n<p id=\"so_26857674_26857732_3\">then the reference is bound to the value of the initializer expression in the first case [...]</p>\n</blockquote>\n<p>This does apply because <code>bar()</code> is an xvalue. So the reference is bound to the xvalue and this is known as <em>direct binding</em> because it is not bound to a temporary.</p>\n<hr>\n<p>NB. All Standard references are from C++14 (N3936) . This section changed from C++11 due to DR1288.</p>\n</hr></hr>", "LastEditorUserId": "1505939", "LastActivityDate": "2014-11-11T05:25:57.143", "Score": "3", "CreationDate": "2014-11-11T04:52:26.103", "ParentId": "26857674", "CommentCount": "11", "OwnerUserId": "1505939", "LastEditDate": "2014-11-11T05:25:57.143"}});