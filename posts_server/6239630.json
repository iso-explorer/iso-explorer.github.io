post_cb({"bq_ids": {"n4140": {"so_6239630_6239654_0": {"length": 67, "quality": 0.9305555555555556, "section_id": 562}}, "n3337": {"so_6239630_6239654_0": {"length": 67, "quality": 0.9305555555555556, "section_id": 553}}, "n4659": {"so_6239630_6239654_0": {"length": 67, "quality": 0.9305555555555556, "section_id": 585}}}, "6239630": {"ViewCount": "1753", "Body": "<p>I have a class that looks something like this:</p>\n<pre><code>class ClassA\n{\n  public:\n    float Get(int num) const;\n  protected:\n    float&amp; Get(int num);\n}\n</code></pre>\n<p>Outside of the class, I call the Get() function. </p>\n<pre><code>float foo = classAInstance.Get(i);\n</code></pre>\n<p>I expect this to call the public version, but instead Visual Studio errors out:</p>\n<pre><code>error C2248: 'ClassA::Get' : cannot access protected member declared in class 'ClassA'\n</code></pre>\n<p>When commenting out the protected overload and removing all references to it, the code compiles. </p>\n<p>Why does the compiler try to use the inaccessible member when an accessible one is available? Is there an accepted way to force the compiler to choose the correct overload? Is there a reference to the resolution rules for member functions somewhere?</p>\n", "AcceptedAnswerId": "6239654", "Title": "Trouble with const/non-const overload resolution", "CreationDate": "2011-06-04T21:52:23.933", "Id": "6239630", "CommentCount": "0", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2011-06-04T22:11:49.423", "Score": "8", "OwnerUserId": "1631", "Tags": "<c++><visual-studio-2010><method-overloading><overload-resolution>", "AnswerCount": "2"}, "6239656": {"Id": "6239656", "PostTypeId": "2", "Body": "<p>Overload resolution is done first, and access check later.</p>\n<p>If you have both a const and a non-const overload, this is resolved by the constness of the object the function is called for.</p>\n", "LastActivityDate": "2011-06-04T21:58:33.827", "CommentCount": "0", "CreationDate": "2011-06-04T21:58:33.827", "ParentId": "6239630", "Score": "5", "OwnerUserId": "597607"}, "6239654": {"Id": "6239654", "PostTypeId": "2", "Body": "<p>It's true, overload resolution takes place before accessibility checks.  Section 13.3 of the standard (<code>[over.match]</code>) says:</p>\n<blockquote>\n<p id=\"so_6239630_6239654_0\">Overload resolution is a mechanism for selecting the best function to call given a list of expressions that are\n  to be the arguments of the call and a set of candidate functions that can be called based on the context of\n  the call.  The selection criteria for the best function are the number of arguments, how well the arguments\n  match the parameter-type-list of the candidate function, how well (for non-static member functions) the\n  object matches the implicit object parameter, and certain other properties of the candidate function. [ Note:\n  The function selected by overload resolution is not guaranteed to be appropriate for the context.  Other\n  restrictions, such as the accessibility of the function, can make its use in the calling context ill-formed.\n  \u2014 end note ]</p>\n</blockquote>\n<p>The usual fix is to give the public and protected functions different names.</p>\n<hr>\n<p>Note, this is useful sometimes, example:</p>\n<pre><code>class Blah\n{\n    const std::string&amp; name_ref;\n\n    Blah(const char*) = delete;\n\npublic:\n    Blah(const std::string&amp; name) : name_ref(name) {}\n\n    void do_something_with_name_ref() const;\n};\n\nstd::string s = \"Blam\";\nBlah b(s); // ok\n</code></pre>\n<p>Note that <code>name_ref</code> will only be read from, so it's appropriate to make it <code>const</code>.  However, <code>const</code> references can bind to temporaries, and binding <code>name_ref</code> to a temporary would be a dangling reference, resulting in undefined behavior in <code>do_something_with_name_ref()</code>.</p>\n<pre><code>Blah c(\"Kablooey!\"); // would be undefined behavior\n                     // the constructor overload makes this a compile error\n</code></pre>\n<p>The private constructor overload prevents a temporary <code>std::string</code> from being implicitly constructed and bound.</p>\n</hr>", "LastEditorUserId": "103167", "LastActivityDate": "2011-06-04T22:11:49.423", "Score": "7", "CreationDate": "2011-06-04T21:58:21.670", "ParentId": "6239630", "CommentCount": "3", "OwnerUserId": "103167", "LastEditDate": "2011-06-04T22:11:49.423"}});