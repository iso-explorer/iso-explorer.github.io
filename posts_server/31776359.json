post_cb({"31776359": {"CommentCount": "11", "CreationDate": "2015-08-02T20:39:04.293", "PostTypeId": "1", "AcceptedAnswerId": "31776975", "LastEditorUserId": "3093378", "LastActivityDate": "2017-02-21T20:03:28.407", "LastEditDate": "2015-08-02T21:50:30.977", "ViewCount": "1003", "FavoriteCount": "1", "Title": "Explicit copy constructor and uniform initialization", "Id": "31776359", "Score": "24", "Body": "<p>Explicit copy constructors disallow something like <code>Foo foo = bar;</code>, and enforce the copy usage as <code>Foo foo(bar);</code>. In addition, explicit copy constructors also disallow returning objects by value from a function. However, I tried replacing the copy initialization with braces, like so</p>\n<pre><code>struct Foo\n{\n    Foo() = default;\n    explicit Foo(const Foo&amp;) = default;\n};\n\nint main()\n{\n    Foo bar;\n    Foo foo{bar}; // error here\n}\n</code></pre>\n<p>and I am getting the error (g++5.2)</p>\n<blockquote>\n<p id=\"so_31776359_31776359_0\">error: no matching function for call to 'Foo::Foo(Foo&amp;)'</p>\n</blockquote>\n<p>or (clang++)</p>\n<blockquote>\n<p id=\"so_31776359_31776359_1\">error: excess elements in struct initializer</p>\n</blockquote>\n<p>Removing the <code>explicit</code> makes the code compilable under g++, clang++ still fails with the same error (thanks @Steephen). What's going on here? Is the uniform initialization considered as an initializer-list constructor (which trumps all others)? But if that's the case, why does the program compile when the copy constructor is non-explicit?</p>\n", "Tags": "<c++><c++11><language-lawyer><copy-constructor><uniform-initialization>", "OwnerUserId": "3093378", "AnswerCount": "1"}, "31776975": {"ParentId": "31776359", "LastEditDate": "2017-02-21T20:03:28.407", "CommentCount": "2", "CreationDate": "2015-08-02T21:48:47.580", "OwnerUserId": "4326278", "LastEditorUserId": "4326278", "PostTypeId": "2", "Id": "31776975", "Score": "23", "Body": "<p>You've encountered a case that was addressed by the resolution of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1467\" rel=\"nofollow noreferrer\">Core issue 1467</a> immediately after C++14 was finalized.</p>\n<p>Let's first note that class <code>foo</code> is an aggregate. Your code is doing <em>direct-list-initialization</em> for <code>foo</code>. The rules for list-initialization are in [8.5.4p3]. </p>\n<p>In C++14 (quoting from N4140, the working draft closest to the published standard), the paragraph above started with:</p>\n<blockquote>\n<p id=\"so_31776359_31776975_0\">List-initialization of an object or reference of type <code>T</code> is defined\n  as follows:</p>\n<ul>\n<li>If <code>T</code> is an aggregate, aggregate initialization is performed (8.5.1).</li>\n</ul>\n<p id=\"so_31776359_31776975_1\">[...]</p>\n</blockquote>\n<p>So, if your class is an aggregate, the compiler tries to do aggregate initialization, which fails.</p>\n<p>This was recognized as a problem, and fixed in the working draft. Quoting from the current version, N4527, the above-mentioned paragraph now starts with:</p>\n<blockquote>\n<p id=\"so_31776359_31776975_2\">List-initialization of an object or reference of type <code>T</code> is defined\n  as follows:</p>\n<ul>\n<li>If <code>T</code> is a class type and the initializer list has a single element of type <em>cv</em> <code>U</code>, where <code>U</code> is <code>T</code> or a class derived from <code>T</code>, the\n  object is initialized from that element (by copy-initialization for\n  copy-list-initialization, or by direct-initialization for\n  direct-list-initialization).</li>\n<li>Otherwise, if <code>T</code> is a character array and the initializer list has a single element that is an appropriately typed string literal\n  (8.5.2), initialization is performed as described in that section.</li>\n<li>Otherwise, if <code>T</code> is an aggregate, aggregate initialization is performed (8.5.1).</li>\n</ul>\n<p id=\"so_31776359_31776975_3\">[...]</p>\n</blockquote>\n<p>Your example now falls within the case described by the first bullet point, and <code>foo</code> is <em>direct-list-initialized</em> using the defaulted copy constructor (regardless of whether it's <code>explicit</code>, since it's direct initialization).</p>\n<p>That is... if the compiler implements the resolution in the defect report.</p>\n<ul>\n<li>GCC 5.2.0 (and 6.0.0 trunk) seems to do so, but seems to have a bug related to that <code>explicit</code>.</li>\n<li>Clang 3.6.0 doesn't, but 3.8.0 trunk does, and does it correctly (<code>explicit</code> doesn't matter).</li>\n<li>MSVC 14 does, but IntelliSense in the IDE doesn't (squiggles under <code>bar</code> - looks like the EDG compiler used by IntelliSense wasn't updated either).</li>\n</ul>\n<hr>\n<p>Update: Since this answer was written, the working draft has been further amended in a couple of ways that are relevant to the example in the question and the explanation above:</p>\n<ul>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#2137\" rel=\"nofollow noreferrer\">CWG 2137</a> indicates that the first bullet in the paragraph quoted above went a bit too far by applying that exception to all class types (the issue notes contain a relevant example). The beginning of the bullet now reads:\n\n<blockquote id=\"so_31776359_31776975_4\">\n<ul>\n<li>If <code>T</code> is an aggregate class and [...]</li>\n</ul>\n</blockquote></li>\n<li>The resolution of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1518\" rel=\"nofollow noreferrer\">CWG 1518</a> contained in paper <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0398r0.html\" rel=\"nofollow noreferrer\">P0398R0</a> indicates that classes that declare an <code>explicit</code> constructor (even defaulted) are no longer aggregates.</li>\n</ul>\n<p>This doesn't change the fact that, after all the changes are implemented, the example in the question is intended to work, with or without the <code>explicit</code>; it's just worth knowing that the underlying mechanisms that make it work have changed slightly.</p>\n<p>Note that all these changes are resolutions of defect reports, so they're supposed to apply when compilers are in C++14 and C++11 modes as well.</p>\n</hr>", "LastActivityDate": "2017-02-21T20:03:28.407"}, "bq_ids": {"n4140": {"so_31776359_31776975_0": {"section_id": 3325, "quality": 1.0, "length": 6}, "so_31776359_31776975_2": {"section_id": 3325, "quality": 1.0, "length": 6}}, "n3337": {"so_31776359_31776975_0": {"section_id": 3195, "quality": 1.0, "length": 6}, "so_31776359_31776975_2": {"section_id": 3195, "quality": 1.0, "length": 6}}, "n4659": {"so_31776359_31776975_0": {"section_id": 4091, "quality": 1.0, "length": 6}, "so_31776359_31776975_2": {"section_id": 4091, "quality": 1.0, "length": 6}}}});