post_cb({"22055550": {"Id": "22055550", "PostTypeId": "2", "Body": "<p>No.</p>\n<p>C++ 14.7.1/1-2, emphasis mine:</p>\n<blockquote>\n<p id=\"so_22055403_22055550_0\">The implicit instantiation of a class template specialization causes the implicit instantiation of the declarations, but <strong>not</strong> of the definitions or default arguments, of the <strong>class member functions</strong>, member classes, scoped member enumerations, static data members and member templates; and it causes the implicit instantiation of the definitions of unscoped member enumerations and member anonymous unions.</p>\n<p id=\"so_22055403_22055550_1\">Unless a member of a class template or a member template has been explicitly instantiated or explicitly specialized, <strong>the specialization of the member is implicitly instantiated when the specialization is referenced in a context that requires the member definition to exist</strong>....</p>\n</blockquote>\n<p>So your example would even be correct if for example plugging in <code>double</code> for the definition <code>double Foo&lt;double&gt;::foo1()</code> would cause an error.</p>\n<p>On the other hand, if you used an explicit instantiation of the class:</p>\n<pre><code>template class Foo&lt;double&gt;;\n</code></pre>\n<p>then all members are instantiated.</p>\n", "LastActivityDate": "2014-02-26T23:10:48.507", "CommentCount": "0", "CreationDate": "2014-02-26T23:10:48.507", "ParentId": "22055403", "Score": "2", "OwnerUserId": "459640"}, "bq_ids": {"n4140": {"so_22055403_22055550_1": {"length": 22, "quality": 0.9565217391304348, "section_id": 234}, "so_22055403_22055570_0": {"length": 20, "quality": 1.0, "section_id": 243}, "so_22055403_22055550_0": {"length": 36, "quality": 0.972972972972973, "section_id": 233}}, "n3337": {"so_22055403_22055550_1": {"length": 22, "quality": 0.9565217391304348, "section_id": 227}, "so_22055403_22055570_0": {"length": 20, "quality": 1.0, "section_id": 235}, "so_22055403_22055550_0": {"length": 36, "quality": 0.972972972972973, "section_id": 226}}, "n4659": {"so_22055403_22055550_1": {"length": 22, "quality": 0.9565217391304348, "section_id": 244}, "so_22055403_22055570_0": {"length": 18, "quality": 0.9, "section_id": 250}, "so_22055403_22055550_0": {"length": 36, "quality": 0.972972972972973, "section_id": 243}}}, "22055545": {"Id": "22055545", "PostTypeId": "2", "Body": "<p>This is easily tested. When I put your code in a file and compile it with gcc </p>\n<pre><code>g++ -g a.cpp\n</code></pre>\n<p>I get a binary a.out. Now I can look into it with <a href=\"http://linux.die.net/man/1/nm\" rel=\"nofollow\"><code>nm</code></a> </p>\n<pre><code>nm a.out | grep foo\n</code></pre>\n<p>which gives </p>\n<pre><code>00000000004004dc W _ZN3FooIdE4foo3Ev\n</code></pre>\n<p>So, no <code>foo1</code> or any other beside <code>foo3</code></p>\n", "LastActivityDate": "2014-02-26T23:10:27.373", "CommentCount": "0", "CreationDate": "2014-02-26T23:10:27.373", "ParentId": "22055403", "Score": "0", "OwnerUserId": "1741542"}, "22055403": {"ViewCount": "96", "Body": "<p>Suppose I have a template static class in a \"Foo.h\" file like following:</p>\n<pre><code>template&lt;typename T&gt; class Foo\n{\n    public:\n        static T foo1();\n        static T foo2();\n        static T foo3();\n        static T foo4();\n        static T foo5();\n};\n\n// definitions...\n</code></pre>\n<p>Now, suppose I have a \"main.cpp\" file like this:</p>\n<pre><code>#include \"Foo.h\"\nmain()\n{\n    double value = Foo&lt;double&gt;::foo3();\n\n    // Do something with value\n\n    return 0;\n}\n</code></pre>\n<p>When I compile this file, will the methods <code>foo1()</code>, <code>foo2()</code>, <code>foo4()</code>, and <code>foo5()</code> be also there in the generated code?</p>\n", "AcceptedAnswerId": "22055543", "Title": "C++ template static class code generation", "CreationDate": "2014-02-26T23:01:13.207", "Id": "22055403", "CommentCount": "2", "LastEditDate": "2014-02-26T23:03:36.893", "PostTypeId": "1", "LastEditorUserId": "701092", "LastActivityDate": "2014-02-26T23:25:46.917", "Score": "0", "OwnerUserId": "2956770", "Tags": "<c++><class><templates>", "AnswerCount": "4"}, "22055570": {"Id": "22055570", "PostTypeId": "2", "Body": "<p>No.</p>\n<blockquote>\n<h1>C++ Standard 14.7.1/10</h1>\n<p id=\"so_22055403_22055570_0\">An implementation shall not implicitly instantiate a function template, a member template, a non-virtual\n  member function, a member class, or a static data member of a class template that does not require instantiation. (...)</p>\n</blockquote>\n<p>It is an extremely useful technique, especially combined with policy based design. You can basically define member functions that only work for some template parameters; if you don't use them in such cases you won't get a compile error.</p>\n", "LastEditorUserId": "461632", "LastActivityDate": "2014-02-26T23:25:46.917", "Score": "3", "CreationDate": "2014-02-26T23:12:00.987", "ParentId": "22055403", "CommentCount": "2", "LastEditDate": "2014-02-26T23:25:46.917", "OwnerUserId": "461632"}, "22055543": {"Id": "22055543", "PostTypeId": "2", "Body": "<p>No, only <code>foo3</code> will be instantiated. Member functions of a class template are treated as separate templates, and each is only instantiated if it's used (or explicitly instantiated).</p>\n<p>You can see this yourself by putting code in one of the unused functions which wouldn't compile when instantiated with <code>double</code>, like</p>\n<pre><code>static T foo1() {return T().nonsense;}  // double has no members\n</code></pre>\n<p>Your code, which only uses <code>foo3</code>, will still compile since it won't try to instantiate this.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2014-02-26T23:21:01.463", "Score": "2", "CreationDate": "2014-02-26T23:10:26.230", "ParentId": "22055403", "CommentCount": "0", "LastEditDate": "2014-02-26T23:21:01.463", "OwnerUserId": "204847"}});