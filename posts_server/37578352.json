post_cb({"bq_ids": {"n4140": {"so_37578352_37578390_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 6305}}, "n3337": {"so_37578352_37578390_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 6062}}, "n4659": {"so_37578352_37578390_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 7816}}}, "37578390": {"Id": "37578390", "PostTypeId": "2", "Body": "<p>Just</p>\n<pre><code>using std::string;\n</code></pre>\n<hr>\n<p>If you want a slightly different name, e.g.</p>\n<pre><code>using String = std::string;\n</code></pre>\n<hr>\n<p>Avoid macros, they don't respect scopes and are generally Evil\u2122.</p>\n<p>For example, the proposed macro</p>\n<pre><code>#define string std::string\n</code></pre>\n<p>\u2026 yields formal Undefined Behavior if you include any standard library header, because it defines a name used by the standard library.</p>\n<b>C++11 \u00a717.6.4.2.2/1</b> [macro.names]:\n\n<blockquote>\n<p id=\"so_37578352_37578390_0\"><strong>\u201d</strong> A translation unit that includes a standard library header shall not <code>#define</code> or <code>#undef</code> names declared in any standard library header.</p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "464581", "LastActivityDate": "2016-06-01T21:10:11.933", "Score": "11", "CreationDate": "2016-06-01T20:40:40.837", "ParentId": "37578352", "CommentCount": "4", "OwnerUserId": "464581", "LastEditDate": "2016-06-01T21:10:11.933"}, "37578455": {"Id": "37578455", "PostTypeId": "2", "Body": "<p>Writing</p>\n<pre><code>using std::string;\n</code></pre>\n<p>is the best way. That has the effect of bringing the standard c++ library string class into the current namespace.</p>\n<p>But really you should learn to read code that contains scope resolution operators fluently. In writing</p>\n<pre><code>std::string\n</code></pre>\n<p>folk reading your code know exactly what is going on.</p>\n", "LastActivityDate": "2016-06-01T20:44:24.867", "CommentCount": "4", "CreationDate": "2016-06-01T20:44:24.867", "ParentId": "37578352", "Score": "4", "OwnerUserId": "2380830"}, "37578391": {"Id": "37578391", "PostTypeId": "2", "Body": "<p>You should use <code>using</code> if you only want not to write namespace</p>\n<pre><code>using std::string;\n</code></pre>\n<p>Neither will be more performant since all of them are compile time.</p>\n<p>For more complex cases you may use other form of <code>using</code></p>\n<pre><code>using short_name = complex_name&lt;possibly, with, templates&gt;;\n</code></pre>\n", "LastActivityDate": "2016-06-01T20:40:48.047", "CommentCount": "0", "CreationDate": "2016-06-01T20:40:48.047", "ParentId": "37578352", "Score": "4", "OwnerUserId": "768110"}, "37578352": {"ViewCount": "432", "Body": "<p>If I wanted to rename the <code>std::string</code> type to a simpler and more naturally looking <code>string</code>, which of these two methods should I use (based on performance and what is usually the standard)</p>\n<p>Should I rename it as a preprocessed directive</p>\n<pre><code>#define string std::string\n</code></pre>\n<p>Or do it with a type definition</p>\n<pre><code>typedef std::string string;\n</code></pre>\n<p>What's the most performant method? What is also more familiar and recognized to the community?</p>\n", "AcceptedAnswerId": "37578390", "Title": "What's the best \"type renaming\" method?", "CreationDate": "2016-06-01T20:38:18.213", "Id": "37578352", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2016-06-01T21:10:11.933", "Score": "1", "OwnerUserId": "6245072", "Tags": "<c++><typedef><user-defined-types><preprocessor-directive>", "AnswerCount": "3"}});