post_cb({"29764109": {"Id": "29764109", "PostTypeId": "2", "Body": "<p>I'm no C++ expert but the main difference is that</p>\n<pre><code>test{a{}}\n</code></pre>\n<p>Does not have an overload for <code>initializer_list&lt;a&gt;</code> so that constructor is not available.</p>\n<p>On the other hand <code>test{t{v}}</code> does have an <code>initializer_list&lt;test&gt;</code> constructor available to it because you can create a <code>test</code> from vector. It can use the (I don't know the name of the rule) 1 cast transformation.</p>\n<pre><code>test{t{v}} -&gt; test{test(t{v})}\n</code></pre>\n", "LastActivityDate": "2015-04-21T06:01:31.213", "CommentCount": "2", "CreationDate": "2015-04-21T06:01:31.213", "ParentId": "29763339", "Score": "1", "OwnerUserId": "551045"}, "29763864": {"Id": "29763864", "PostTypeId": "2", "Body": "<p>The type of <code>t{v}</code> is <code>std::vector&lt;test&gt;</code>. The idea is that init-list constructors are always preferred wrt any other constructors, so <code>test{t{v}}</code> will first try to call an init-list constructor, if one exists, and if the types are compatible. In your case, this is possible, since <code>test</code> itself can be implicitly constructed from a <code>std::vector&lt;test&gt;</code> (via your first 2 constructors), so the compiler ends up delegating to the init-list constructor, hence the error.</p>\n<p>In the second case, there is no ambiguity, since the type <code>a{}</code>is not implicitly convertible anymore to <code>std::initializer_list&lt;b&gt;</code>.</p>\n<p>Make the constructors <code>explicit</code> in the first example, or call the base constructor with <code>test(t{v})</code> instead, and your ambiguity will disappear (the compiler won't perform the implicit conversion anymore).</p>\n<p>A simpler example (live <a href=\"http://ideone.com/dy3ygx\" rel=\"nofollow\">here</a>) that exhibits essentially the same behaviour as your first example is:</p>\n<pre><code>#include &lt;initializer_list&gt;\n\nstruct test\n{\n    /*explicit*/ test(int){} // uncomment explicit and no more errors\n    test( std::initializer_list&lt;test&gt; v)\n        : test{42} {} // error, implicitly converts 42 to test(42) via the test(int)\n};\n\nint main(){}\n</code></pre>\n<p>The relevant part of the standard that deals with init-list constructors is <em>\u00a713.3.1.7/1</em> <strong>[over.match.list]</strong> - citation below taken from a now-deleted answer of @Praetorian -</p>\n<blockquote>\n<p id=\"so_29763339_29763864_0\">When objects of non-aggregate class type <em>T</em> are list-initialized such that 8.5.4 specifies that overload resolution is performed according to the rules in this section, overload resolution selects the constructor in two phases:<br/>\n  \u2014 <strong>Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class <code>T</code> and the argument list consists of the initializer list as a single argument.</strong><br/>\n  \u2014 If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class <code>T</code> and the argument list consists of the elements\n  of the initializer list.</p>\n</blockquote>\n", "LastEditorUserId": "3093378", "LastActivityDate": "2015-05-31T15:35:16.433", "Score": "7", "CreationDate": "2015-04-21T05:43:37.843", "ParentId": "29763339", "CommentCount": "4", "OwnerUserId": "3093378", "LastEditDate": "2015-05-31T15:35:16.433"}, "29763339": {"ViewCount": "646", "Body": "<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;initializer_list&gt;\n#include &lt;vector&gt;\n\nstruct test\n{\n    using t = std::vector&lt;test&gt;;\n    test(t const &amp;v)\n    {\n    }\n    test(t &amp;&amp;v)\n    {\n    }\n    test(std::initializer_list&lt;test&gt; v)\n    : test{t{v}} //error\n    {\n    }\n};\n</code></pre>\n<p>Both <a href=\"http://coliru.stacked-crooked.com/a/9f6c9ea6421cc0c0\">Clang</a> and <a href=\"http://ideone.com/c06v0O\">GCC</a> complain that the third constructor, the one taking the initializer list, delegates to itself. I don't understand how this is possible though, because you can't construct an initializer list from a vector.</p>\n<p>It is trivial to fix the error by replacing the outer curly braces with round parenthesis, but why would this be an issue in the first place? This almost identical program compiles just fine:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;initializer_list&gt;\n\nstruct a {};\nstruct b {};\n\nstruct test\n{\n    test(a const &amp;)\n    {\n    }\n    test(a &amp;&amp;)\n    {\n    }\n    test(std::initializer_list&lt;b&gt; v)\n    : test{a{}} //no error, still using curly braces\n    {\n    }\n};\n</code></pre>\n<p>Interestingly, with the above second example, the error reappears if you substitute <code>b</code> with <code>test</code>. Can someone explain what is going on here?</p>\n", "AcceptedAnswerId": "29763864", "Title": "What causes this constructor to delegate to itself when it takes an initializer list and delegates a vector?", "CreationDate": "2015-04-21T05:04:14.177", "Id": "29763339", "CommentCount": "2", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2015-04-21T05:51:39.367", "LastEditorUserId": "1959975", "LastActivityDate": "2015-05-31T15:35:16.433", "Score": "7", "OwnerUserId": "1959975", "Tags": "<c++><c++11><c++14>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_29763339_29763864_0": {"length": 45, "quality": 0.8181818181818182, "section_id": 599}}, "n3337": {"so_29763339_29763864_0": {"length": 45, "quality": 0.8181818181818182, "section_id": 589}}, "n4659": {"so_29763339_29763864_0": {"length": 53, "quality": 0.9636363636363636, "section_id": 622}}}, "29763588": {"Id": "29763588", "PostTypeId": "2", "Body": "<p>The problem in your code is that you're writing a function calling itself.</p>\n<pre><code>test(std::initializer_list&lt;test&gt; v)\n    : test{t{v}} //error\n    {\n    }\n</code></pre>\n<p><code>test{t{v}}</code> will first call the initializer-list of <code>vector&lt;test&gt;</code> with v as parameter. But <code>vector</code> will call the function again to initialize the value which will fail.</p>\n<p>The compiler doesn't know how to resolve the problem. Changing the initialization to use parentheses will (as you said) fix this because it will then call an implicit copy constructor in the <code>vector</code> (doing nothing because the your structure isn't doing anything).</p>\n<p>The second example starts with this call: <code>a{}</code></p>\n<p>It is resolved fine because <code>a</code> is a basic structure with implicitly defined constructors. The second call is the <code>test{...}</code> one</p>\n<p>Because the type is <code>a</code> and there is a constructor for <code>a</code> it runs just fine.</p>\n", "LastEditorUserId": "3748622", "LastActivityDate": "2015-04-21T05:58:05.807", "Score": "0", "CreationDate": "2015-04-21T05:22:24.077", "ParentId": "29763339", "CommentCount": "11", "OwnerUserId": "3748622", "LastEditDate": "2015-04-21T05:58:05.807"}});