post_cb({"32735690": {"ParentId": "32735296", "LastEditDate": "2015-09-23T10:53:52.003", "CommentCount": "1", "CreationDate": "2015-09-23T09:23:14.973", "OwnerUserId": "981959", "LastEditorUserId": "981959", "PostTypeId": "2", "Id": "32735690", "Score": "2", "Body": "<blockquote>\n<p id=\"so_32735296_32735690_0\">May I take it that the d-tor in this case is trivial?</p>\n</blockquote>\n<p>No.  A trivial destructor is a formal defined term in C++ and a non-empty destructor is never trivial. Triviality is a compile-time property of a type, so a destructor that has to perform a run-time test and conditionally call a deleter cannot be trivial.</p>\n<p>However, it is always valid to omit destroying an object if the program's correctness doesn't rely on the destructor's effects. </p>\n<p>[basic.life] p4:</p>\n<blockquote>\n<p id=\"so_32735296_32735690_1\">For an object of a class type with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage which the object occupies is reused or released; however, if there is no explicit call to the destructor or if a <em>delete-expression</em> (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and any program that depends on the side effects produced by the destructor has undefined behavior.</p>\n</blockquote>\n<p>Since the <code>unique_ptr</code> has no side effects when it is empty the program does not depend on it, so it is OK to omit running the destructor.</p>\n", "LastActivityDate": "2015-09-23T10:53:52.003"}, "32735296": {"CommentCount": "1", "ViewCount": "184", "PostTypeId": "1", "LastEditorUserId": "1430927", "CreationDate": "2015-09-23T09:05:15.270", "LastActivityDate": "2015-09-23T10:53:52.003", "Title": "Is destructor of empty unique_ptr w/o custom deleter trivial", "LastEditDate": "2015-09-23T09:27:17.790", "Id": "32735296", "Score": "3", "Body": "<p>Given a code (really pseudocode):</p>\n<pre><code>struct A { /* ... */ }; // assume is non-trivial\nstruct B { /* ... */ }; // assume is non-trivial\n\nusing UA = std::unique_ptr&lt; A &gt;;\nusing UB = std::unique_ptr&lt; B &gt;;\n\nunion U\n{\n\n    UA a;\n    UB b;\n\n};\n\nU u{std::make_unique&lt; A &gt;(/* init */)};\nu.a = nullptr; // destructor of underlying type A called\n// u.a.~UA(); // destructor of smart pointer itself\n::new (&amp;U.b) UB{std::make_unique&lt; B &gt;(/* init */)};\n</code></pre>\n<p>Is it permittable to omit calling of destructor for <code>U::a</code> member? The question is inspired by following <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr/~unique_ptr\" rel=\"nofollow\">quote</a> regarding <code>std::unique_ptr::~unique_ptr</code>:</p>\n<blockquote>\n<p id=\"so_32735296_32735296_0\">If get() == nullptr there are no effects.</p>\n</blockquote>\n<p>May I take it that the d-tor in this case is trivial (in described below sense)?</p>\n<p>I think internal (and sole in case of <code>std::unique_ptr</code> w/o custom deleter) data member (say <code>p</code>) of <code>std::unique_ptr&lt; T &gt;</code> is of type <code>T *</code>. After assigning <code>p = nullptr;</code> it seems permittable to do exactly nothing with such a <code>std::unique_ptr</code> in order to use its storage for another purposes. Is it right conclusion?</p>\n", "Tags": "<c++><destructor><c++14><smart-pointers><unique-ptr>", "OwnerUserId": "1430927", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_32735296_32735296_0": {"section_id": 4319, "quality": 1.0, "length": 4}, "so_32735296_32735690_1": {"section_id": 7192, "quality": 0.9428571428571428, "length": 33}}, "n3337": {"so_32735296_32735296_0": {"section_id": 4160, "quality": 1.0, "length": 4}, "so_32735296_32735690_1": {"section_id": 6936, "quality": 0.9428571428571428, "length": 33}}, "n4659": {"so_32735296_32735296_0": {"section_id": 5576, "quality": 1.0, "length": 4}, "so_32735296_32735690_1": {"section_id": 8701, "quality": 0.9428571428571428, "length": 33}}}});