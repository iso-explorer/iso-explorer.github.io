post_cb({"bq_ids": {"n4140": {"so_24077253_24077619_1": {"section_id": 6021, "quality": 0.88, "length": 22}, "so_24077253_24077253_0": {"section_id": 6185, "quality": 0.5833333333333334, "length": 7}, "so_24077253_24077619_2": {"section_id": 6021, "quality": 0.88, "length": 22}, "so_24077253_24077606_6": {"section_id": 6021, "quality": 0.8333333333333334, "length": 15}, "so_24077253_24077606_4": {"section_id": 6182, "quality": 0.9607843137254902, "length": 49}, "so_24077253_24077577_0": {"section_id": 6021, "quality": 0.8095238095238095, "length": 34}}, "n3337": {"so_24077253_24077619_1": {"section_id": 5789, "quality": 0.64, "length": 16}, "so_24077253_24077606_4": {"section_id": 5943, "quality": 0.9607843137254902, "length": 49}, "so_24077253_24077619_2": {"section_id": 5789, "quality": 0.64, "length": 16}, "so_24077253_24077606_6": {"section_id": 5789, "quality": 0.8333333333333334, "length": 15}, "so_24077253_24077606_1": {"section_id": 4515, "quality": 0.6, "length": 6}, "so_24077253_24077577_0": {"section_id": 5789, "quality": 0.8095238095238095, "length": 34}}, "n4659": {"so_24077253_24077619_2": {"section_id": 7520, "quality": 0.88, "length": 22}, "so_24077253_24077606_6": {"section_id": 7520, "quality": 0.8333333333333334, "length": 15}, "so_24077253_24077619_1": {"section_id": 7520, "quality": 0.88, "length": 22}, "so_24077253_24077606_4": {"section_id": 7684, "quality": 0.9411764705882353, "length": 48}, "so_24077253_24077577_0": {"section_id": 7520, "quality": 0.8095238095238095, "length": 34}}}, "24077619": {"ParentId": "24077253", "PostTypeId": "2", "CommentCount": "2", "Body": "<h3>Explanation</h3>\n<p>Since <em>C++</em> is a <a href=\"https://stackoverflow.com/q/1517582/1090079\"><em>statically typed</em></a> language the type of every expression is known at compile-time, even in cases that involves polymorphic behavior.</p>\n<p>Whether a certain class is polymorphic or not is known at the time of compilation, this property will and cannot be changed between program executions.</p>\n<p>If the compiler sees that the <em>expr</em> in <code>typeid(expr)</code> will not yield a value of polymorphic class type, it will simply make <em>expr</em> <em>\"unevaluated\"</em>, which is equivalent of not executing it during run-time.</p>\n<hr>\n<p><strong>! ! !</strong></p>\n<p>It is important to note that the <em>expr</em> must still be valid, we cannot use <code>typeid</code> to potentially ignore a ill-formed expression; a compiler diagnostic must still be issued if the expression is ill-formed.</p>\n<p>Just because the <em>expr</em> will be <em>\"unevaluated\"</em> does not mean that we can have it contain an ill-formed sub-expression.</p>\n<pre><code>struct A { }; // not polymorphic\n\n...\n\nA * ptr = ...;\ntypeid (dynamic_cast&lt;void*&gt; (ptr), *ptr); // ill-formed\n</code></pre>\n<p>Since <code>ptr</code> is not a pointer to a polymorphic class we cannot use it in <code>dynamic_cast&lt;T&gt;</code> where <code>T = void*</code>, as specified in <code>[expr.dynamic.cast]p6</code>.</p>\n<hr>\n<h3>Dereferencing a potential <em>nullptr</em>?</h3>\n<p>This will make <code>typeid</code> throw an exception, so it will not yield <em>undefined behavior</em> but one should be prepared to handle an exception if one uses such implementation.</p>\n<blockquote>\n<p id=\"so_24077253_24077619_0\"><code>5.2.8p2</code> <strong>Type identification</strong> <code>[expr.typeid]</code></p>\n<blockquote>\n<p id=\"so_24077253_24077619_2\">(...) If the glvalue expression is obtained by applying the unary <code>*</code> operator to a pointer and the pointer is a null pointer value (4.10), the <em>typeid</em> expression throws an exception (15.1) of a type that would match a handler of type <code>std::bad_typeid</code> exception (18.8.3)</p>\n</blockquote>\n</blockquote>\n<hr>\n<h3>Clarification</h3>\n<blockquote>\n<p id=\"so_24077253_24077619_3\">It means q=dynamic_cast(p) will be evaluated if the result type is an lvalue of polymorphic class type. The result means the result of evaluating dynamic_cast(p) (I guess).</p>\n</blockquote>\n<p>No, what the author is saying is that if the resulting type of the <strong>entire</strong> expression is a polymorphic class type, than the expression will be evaluated.</p>\n<p><sub><strong>Note</strong>: The <em>\"entire expression\"</em> refers to the <code>...</code> in <code>typeid(...)</code>, in your case; <code>q=dynamic_cast&lt;void*&gt;(p),*p</code>. </sub></p>\n<hr>\n<p><em>The Comma Operator</em></p>\n<p>The comma operator will take two operands <em>expr1</em> and <em>expr2</em>, it will start off by evaluating <em>expr1</em> and then discard this value, after which it will evaluate <em>expr2</em> and yield the value of this expression.</p>\n<ul>\n<li><strong><a href=\"https://stackoverflow.com/a/114404/1090079\">How does the comma operator work?</a></strong></li>\n</ul>\n<hr>\n<p><em>Putting it together</em></p>\n<p>This means that the resulting type of using a comma operator is as if it only consisted of the right-hand-side expression, and in the following line the compiler will check so that the result of <em>expr2</em> is a type which is a <em>polymorphic class</em>.</p>\n<pre><code>typeid (expr1, expr2)\n</code></pre>\n<p><sup></sup></p>\n<pre><code>typeid (q=dynamic_cast&lt;void*&gt;(p), *p)\n\n// expr1 = q=dynamic_cast&lt;void*&gt;(p)\n// expr2 = *p\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_24077253_24077619_4\"><sup><strong>Note</strong>: In C++03 the resulting type had to be a <em>polymorphic <b>lvalue</b></em>, in C++11 this has been changed to <em>glvalues</em> of polymorphic class type. </sup></p>\n</blockquote>\n</hr></hr></hr></hr></hr></hr>", "OwnerUserId": "1090079", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:28:14.717", "Id": "24077619", "Score": "5", "CreationDate": "2014-06-06T08:42:33.143", "LastActivityDate": "2014-06-06T15:53:34.313"}, "24077253": {"CommentCount": "2", "AcceptedAnswerId": "24077871", "PostTypeId": "1", "LastEditorUserId": "63550", "CreationDate": "2014-06-06T08:19:20.237", "LastActivityDate": "2014-06-06T15:53:34.313", "LastEditDate": "2014-06-06T14:17:57.973", "ViewCount": "616", "FavoriteCount": "1", "Title": "Comma operator with typeid", "Id": "24077253", "Score": "14", "Body": "<p>I was studying <em><a href=\"http://www.justsoftwaresolutions.co.uk/articles/genericptr.pdf\" rel=\"nofollow\">A Generic Non-intrusive Smart Pointer Implementation</a></em>. I have some confusion in <em>section 4</em>. One statement is</p>\n<blockquote>\n<p id=\"so_24077253_24077253_0\">the expression supplied as the argument to the typeid operator is only evaluated if the result type is an lvalue of polymorphic class type.</p>\n</blockquote>\n<p>And associated example code is:</p>\n<pre><code>template&lt;typename T&gt;\n  void* startOfObject(T* p) {\n  void* q=static_cast&lt;void*&gt;(p);\n  typeid(q=dynamic_cast&lt;void*&gt;(p),*p); // This line\n  return q;\n}\n</code></pre>\n<p>AFAIU, it means <code>q=dynamic_cast&lt;void*&gt;(p)</code> will be evaluated if the <em>result type</em> is an <em>lvalue of polymorphic class type</em>. The <em>result</em> means the result of evaluating <code>dynamic_cast&lt;void*&gt;(p)</code> (I guess), so the <code>dynamic_cast</code> has to be applied in any case. The articles states (as I understand) that if <code>p</code> is not <em>polymorphic</em> then <code>dynamic_cast</code> will not be applied, but why? Before applying it, how can it be known whether the <em>result</em> is polymorphic or not? It will be helpful if someone describes in details how the full statement will be executed.</p>\n<p>Another statement is</p>\n<blockquote>\n<p id=\"so_24077253_24077253_1\">There is also a problem if p is NULL \u2013 the typeid will throw a std::bad cast.</p>\n</blockquote>\n<p>The problem I see is with de-referencing if <code>p</code> is <code>NULL</code>, not with <code>typeid</code> (although it may throw bad_typeid, but that is not because of casting). <code>dynamic_cast</code> will return a <code>NULL</code> pointer of type <code>void*</code> if <code>p</code> is <code>NULL</code>, and <code>typeid</code> should be able to deduce the type information. Is that a typo, or am I missing something?</p>\n", "Tags": "<c++><comma><dynamic-cast><typeid>", "OwnerUserId": "1390091", "AnswerCount": "4"}, "24077871": {"ParentId": "24077253", "CommentCount": "4", "Body": "<p>It's a fancy trick to write essentially the following code</p>\n<pre><code>if (T is polymorphic)\n  return dynamic_cast&lt;void*&gt;(p);\nelse\n  return static_cast&lt;void*&gt;(p);\n</code></pre>\n<p>The trick used is that <code>typeid(expr)</code> is evaluated in one of two ways. If the compiler determines that <code>expr</code> has a non-polymorphic type, it goes ahead and uses its static type. But if <code>expr</code> has a dynamic type, it evaluates <code>expr</code> at runtime. The assignment before the comma operator is therefore evaluatad if and only if <code>*p</code> after the comma is polymorphic.</p>\n<p>The null case is complex for that reason. If T is not polymorphic, then <code>typeid(*p)</code> is replaced by the compiler at compile time, and the runtime null pointer doesn't matter at all. If <code>T</code> is polymorphic, special handling of null pointer dereferences applies, and that special handling states that a <code>std::bad_typeid</code> exception is thrown.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "24077871", "Score": "11", "CreationDate": "2014-06-06T08:56:47.290", "LastActivityDate": "2014-06-06T08:56:47.290"}, "24077577": {"ParentId": "24077253", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The comma operator has left-to-right associativity and is evaluated from left to right. That means the result of the expression <code>q=dynamic_cast&lt;void*&gt;(p),*p</code> is <code>*p</code>. So the dynamic cast is only evaluated if the type of <code>*p</code> is polymorphic.</p>\n<p>Regarding the <code>NULL</code> problem the standard states:</p>\n<blockquote>\n<p id=\"so_24077253_24077577_0\">When typeid is applied to an lvalue expression whose type is a\n  polymorphic class type (10.3), the result refers to a type_info object\n  representing the type of the most derived object (1.8) (that is, the\n  dynamic type) to which the lvalue refers. <strong>If the lvalue expression is\n  obtained by applying the unary * operator to a pointer and the pointer\n  is a null pointer value (4.10), the typeid expression throws the\n  bad_typeid exception (18.5.3).</strong></p>\n</blockquote>\n", "OwnerUserId": "1680318", "LastEditorUserId": "1680318", "LastEditDate": "2014-06-06T09:14:25.453", "Id": "24077577", "Score": "5", "CreationDate": "2014-06-06T08:40:15.037", "LastActivityDate": "2014-06-06T09:14:25.453"}, "24077606": {"ParentId": "24077253", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_24077253_24077606_0\">The result means the result of evaluating dynamic_cast(p) (I\n  guess), so the dynamic_cast has to be applied in any case. The\n  articles states (as I understand) that if p is not polymorphic then\n  dynamic_cast will not be applied</p>\n</blockquote>\n<p><code>dynamic_cast</code> will not be applied if any of the involved types have no polymorphic relationship with each other, with the exception of being able to cast to <code>void*</code>.</p>\n<p>Now for the whole construct, if you run it through a compiler that has good warnings, you will either see</p>\n<blockquote>\n<p id=\"so_24077253_24077606_1\">error: cannot dynamic_cast 'p' (of type 'struct A*') to type 'void*' (source type is not polymorphic)</p>\n</blockquote>\n<p>or when A is polymorphic, you will see</p>\n<blockquote>\n<p id=\"so_24077253_24077606_2\">warning: value computed is not used [-Wunused-value]</p>\n</blockquote>\n<p>for</p>\n<blockquote id=\"so_24077253_24077606_3\">\n<pre><code>typeid(q=dynamic_cast&lt;void*&gt;(p),*p); // this line\n</code></pre>\n</blockquote>\n<p>So in my opinion, <em>the whole line makes no sense at all</em>, other than to possibly prevent compilation when the source type is not polymorphic.</p>\n<p>As to the built in comma operator that is being used here: It is being evaluated from left to right, always unconditionally, and its result is the last element. That is, the result is equivalent to</p>\n<pre><code>typeid(*p);\n</code></pre>\n<p>which is not being used and thus a pretty useless construct. Would it compile for non polymorphic source types in the <code>dynamic_cast</code>, then it would not be evaluated at runtime at all since the type of <code>*p</code> is known at compile time.</p>\n<p>ISO14882:2001(e) \u00a75.18-1</p>\n<blockquote>\n<p id=\"so_24077253_24077606_4\">A pair of expressions separated by a comma is evaluated left-to-right;\n  the left expression is a discarded-value expression (Clause 5).<sup>83</sup> Every\n  value computation and side effect associated with the left expression\n  is sequenced before every value computation and side effect associated\n  with the right expression. The type and value of the result are the\n  type and value of the right operand; the result is of the same value\n  category as its right operand, and is a bit-field if its right operand\n  is a glvalue and a bit-field.</p>\n</blockquote>\n<p>Regarding the <code>nullptr</code> issue </p>\n<blockquote>\n<p id=\"so_24077253_24077606_5\">There is also a problem if p is NULL \u2013 the typeid will throw a std::bad cast.</p>\n</blockquote>\n<p>There is a special case in the standard to make this not undefined behaviour:</p>\n<blockquote>\n<p id=\"so_24077253_24077606_6\">If the glvalue expression is obtained by applying the unary * operator to a\n  pointer<sup>68</sup> and the pointer is a null pointer value (4.10), the typeid expression throws the std::bad_typeid\n  exception (18.7.3).</p>\n</blockquote>\n", "OwnerUserId": "833362", "LastEditorUserId": "1390091", "LastEditDate": "2014-06-06T10:35:20.787", "Id": "24077606", "Score": "3", "CreationDate": "2014-06-06T08:41:41.097", "LastActivityDate": "2014-06-06T10:35:20.787"}});