post_cb({"30381108": {"ParentId": "30380787", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The other answers are correct about why the error happens at the template definition rather than the instantiation.</p>\n<blockquote>\n<p id=\"so_30380787_30381108_0\">I need an error to be thrown when trying to instantiate something like `more_than_99 &lt;0&gt; x;' on the line where I try to instantiate it. Something like \"hey, this type doesn't exist\".</p>\n</blockquote>\n<p>How about something like this?</p>\n<pre><code>template &lt;unsigned int N, bool B = (N&gt;=100)&gt;\nstruct more_than_99;\n\ntemplate &lt;unsigned int N&gt;\nstruct more_than_99&lt;N,true&gt;\n{};\n\nint main()\n{\n    more_than_99 &lt;0&gt; c; // error: implicit instantiation of undefined template 'more_than_99&lt;0, false&gt;'\n}\n</code></pre>\n<p>To make it a bit more robust, and to attempt to prevent accidentally instantiating <code>more_than_99&lt;0,true&gt;</code>, this also works (C++11):</p>\n<pre><code>template &lt;unsigned int N, bool B&gt;\nstruct _impl_more_than_99;\n\ntemplate &lt;unsigned int N&gt;\nstruct _impl_more_than_99&lt;N,true&gt;\n{};\n\ntemplate &lt;unsigned int N&gt;\nusing more_than_99 = _impl_more_than_99&lt;N, (N&gt;=100)&gt;;\n\nint main()\n{\n    more_than_99 &lt;0&gt; c; // error: implicit instantiation of undefined template '_impl_more_than_99&lt;0, false&gt;'\n}\n</code></pre>\n<p>Although the error message references the <code>_impl_</code> type.</p>\n<p>You could hide the <code>_impl_</code> in a detail namespace or something, and just document the <code>more_than_99</code> alias as if it were the actual type.</p>\n<p>However, you will not be able to prevent malicious instantiation of <code>_impl_more_than_99&lt;0,true&gt;</code>.</p>\n", "OwnerUserId": "640397", "LastEditorUserId": "640397", "LastEditDate": "2015-05-21T18:49:29.540", "Id": "30381108", "Score": "2", "CreationDate": "2015-05-21T17:58:48.377", "LastActivityDate": "2015-05-21T18:49:29.540"}, "30380981": {"ParentId": "30380787", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>N</code> is not a dependent non-type template parameter; [temp.dep.temp]/p2</p>\n<blockquote>\n<p id=\"so_30380787_30380981_0\">A non-type template-argument is dependent if its type is dependent or the constant expression it specifies is value-dependent.</p>\n</blockquote>\n<p>Therefore instead of a substitution failure occurring, the error is emitted directly from the ill-formed code.</p>\n", "OwnerUserId": "701092", "LastEditorUserId": "701092", "LastEditDate": "2015-05-21T18:00:20.843", "Id": "30380981", "Score": "1", "CreationDate": "2015-05-21T17:52:00.740", "LastActivityDate": "2015-05-21T18:00:20.843"}, "30381014": {"ParentId": "30380787", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/types/enable_if\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/types/enable_if</a>: (emphasis mine)</p>\n<blockquote>\n<p id=\"so_30380787_30381014_0\">This metafunction is a convenient way to leverage SFINAE to <strong>conditionally remove functions from overload resolution based on type traits and to provide separate function overloads and specializations for different type traits</strong>. <code>std::enable_if</code> can be used as an additional function argument (not applicable to operator overloads), as a return type (not applicable to constructors and destructors), or as a class template or function template parameter. </p>\n</blockquote>\n<p>You cannot use it to enable or disable a <code>class</code> or a <code>struct</code>.</p>\n<p>Perhaps you are looking for something like:</p>\n<pre><code>namespace detail\n{\n   struct more_than_99 {};\n\n   template &lt;bool&gt; Helper;\n\n   template &lt;&gt; Helper&lt;true&gt;\n   {\n      using type = more_than_99;\n   };\n}\n\ntemplate &lt;unsigned int N&gt; struct selector\n{\n   using type = typename detail::Helper&lt;N &gt;= 100&gt;::type\n};\n\nusing type = selector&lt;10&gt;::type; // Error.\n\nusing type = selector&lt;100&gt;::type; // OK.\n                                  // type == detail::more_than_99\n</code></pre>\n", "OwnerUserId": "434551", "LastEditorUserId": "434551", "LastEditDate": "2015-05-21T18:02:44.430", "Id": "30381014", "Score": "0", "CreationDate": "2015-05-21T17:53:33.793", "LastActivityDate": "2015-05-21T18:02:44.430"}, "30383537": {"ParentId": "30380787", "CommentCount": "0", "Body": "<p><code>enable_if</code> makes sense if you have a class specialization (or a function overload). It is used to <em>choose</em> between one implementation and another depending on a template parameter, not to trigger an error if the condition is not met. </p>\n<p>The idea is \"enable this specialization if the condition is met, otherwise fall back to the non-specialized version\".</p>\n<p>In your case, you probably want something like this:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nusing namespace std;\n\ntemplate&lt;unsigned int N, typename = void &gt;\nstruct more_than_99\n{\n    // Implementation if N &lt;= 99\n    enum { value = false };\n};\n\ntemplate &lt;unsigned int N&gt; \nstruct more_than_99&lt;N, typename enable_if &lt;N &gt;= 100&gt; :: type&gt;\n{\n    // Implementation if N &gt;= 100\n    enum { value = true };\n};\n\nint main()\n{\n    cout &lt;&lt; more_than_99 &lt;0&gt;::value &lt;&lt; endl; //false\n    cout &lt;&lt; more_than_99 &lt;100&gt;::value &lt;&lt; endl; //true\n}\n</code></pre>\n", "OwnerUserId": "666785", "PostTypeId": "2", "Id": "30383537", "Score": "1", "CreationDate": "2015-05-21T20:15:38.320", "LastActivityDate": "2015-05-21T20:15:38.320"}, "30380787": {"CommentCount": "5", "ViewCount": "1264", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2015-05-21T17:41:36.627", "LastActivityDate": "2015-05-21T20:15:38.320", "Title": "enable_if cannot be used to disable this declaration", "AcceptedAnswerId": "30381108", "LastEditDate": "2015-05-21T18:14:29.687", "Id": "30380787", "Score": "4", "Body": "<p>I evidently have not enough experience with SFINAE to handle this problem. I actually have the impression that it worked until now, and this kind of problem started to appear like in the last half an hour, everywhere in my code.</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;unsigned int N, typename = typename enable_if &lt;N &gt;= 100&gt; :: type&gt; \nstruct more_than_99\n{\n};\n\nint main()\n{\n    more_than_99 &lt;0&gt; c;\n}\n</code></pre>\n<p>It says</p>\n<pre><code>No type named 'type' in 'std::__1::enable_if&lt;false, void&gt;'; 'enable_if' cannot be used to disable this declaration\n</code></pre>\n<p>on the line corresponding to the template declaration. What is going on? I have always used this kind of syntax to enable and disable my template classes and it has always thrown errors on the line of instantiation, rather than on the line of the declaration..</p>\n<p>Could you please pedantically explain what am I doing wrong here?</p>\n", "Tags": "<c++><templates><sfinae>", "OwnerUserId": "774236", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_30380787_30380981_0": {"section_id": 211, "quality": 1.0, "length": 10}}, "n3337": {"so_30380787_30380981_0": {"section_id": 205, "quality": 1.0, "length": 10}}, "n4659": {"so_30380787_30380981_0": {"section_id": 219, "quality": 1.0, "length": 10}}}});