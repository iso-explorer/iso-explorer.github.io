post_cb({"3015507": {"CommentCount": "2", "CreationDate": "2010-06-10T14:48:11.067", "PostTypeId": "1", "AcceptedAnswerId": "3015678", "LastEditorUserId": "344351", "LastActivityDate": "2010-06-10T15:10:00.030", "LastEditDate": "2010-06-10T14:55:11.550", "ViewCount": "409", "FavoriteCount": "2", "Title": "C++ template member specialization - is this a compiler limitation?", "Id": "3015507", "Score": "4", "Body": "<p>Is it possible to do this kind of specialization?<br>\nIf so, how?</br></p>\n<p>The specialization in question is marked <b>//THIS SPECIALIZATION WILL NOT COMPILE</b>\nI have used VS2008, VS2010, gcc 4.4.3 and neither can compile this.</p>\n<p>I know i can avoid this by overloading <b>func</b> but i want to know if there is a way to do this with template specialization. (impractical/inadvisable though it may be)</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\n\nusing namespace std;\n\ntemplate &lt;typename ALPHA&gt;\nclass klass{\n    public:\n        template &lt;typename BETA&gt;\n        void func(BETA B);\n};\n\ntemplate &lt;typename ALPHA&gt; template &lt;typename BETA&gt;\nvoid klass&lt;ALPHA&gt;::func(BETA B){\n    cout &lt;&lt; \"I AM A BETA FUNC: \" &lt;&lt; B &lt;&lt;endl;\n}\n\n//THIS SPECIALIZATION WILL NOT COMPILE\ntemplate &lt;typename ALPHA&gt; template &lt;&gt;\nvoid klass&lt;ALPHA&gt;::func(string B){\n    cout &lt;&lt; \"I AM A SPECIAL BETA FUNC: \" &lt;&lt; B &lt;&lt;endl;\n}\n\nint main(){\n    klass&lt;string&gt; k;\n    k.func(1);\n    k.func(\"hello\");\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><templates>", "OwnerUserId": "344351", "AnswerCount": "2"}, "3015554": {"ParentId": "3015507", "LastEditDate": "2010-06-10T15:08:09.583", "CommentCount": "2", "CreationDate": "2010-06-10T14:53:02.320", "OwnerUserId": "39375", "LastEditorUserId": "39375", "PostTypeId": "2", "Id": "3015554", "Score": "6", "Body": "<p>Just make the <code>string</code> version of <code>func</code> a regular non-template member function that overloads with the template version:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\n\nusing namespace std;\n\ntemplate &lt;typename ALPHA&gt;\nclass klass{\n    public:\n        template &lt;typename BETA&gt;\n        void func(BETA B);\n        void func(string b);\n};\n\ntemplate &lt;typename ALPHA&gt; template &lt;typename BETA&gt;\nvoid klass&lt;ALPHA&gt;::func(BETA B){\n    cout &lt;&lt; \"I AM A BETA FUNC: \" &lt;&lt; B &lt;&lt;endl;\n}\n\ntemplate &lt;typename ALPHA&gt;\nvoid klass&lt;ALPHA&gt;::func(string B){\n    cout &lt;&lt; \"I AM A SPECIAL BETA FUNC: \" &lt;&lt; B &lt;&lt;endl;\n}\n\nint main(){\n    klass&lt;string&gt; k;\n    k.func(1);\n    k.func(\"hello\");\n    return 0;\n}\n</code></pre>\n<p>In addition to it compiling, there's another benefit here in that you will get more intuitive behavior. See <a href=\"http://www.gotw.ca/publications/mill17.htm\" rel=\"nofollow noreferrer\">\"Why Not Specialize Function Templates?\" from GOTW</a>.</p>\n<p><strong>Edit:</strong> To directly answer your original question, no this is not a compiler limitation, it is something that is disallowed by the C++ standard.</p>\n<p>The C++ Standard, 14.7.3/18 says (in part):</p>\n<blockquote>\n<p id=\"so_3015507_3015554_0\">In an explicit specialization\n  declaration for a member of a class\n  template or a member template that\n  appears in namespace scope, the member\n  template and some of its enclosing\n  class templates may remain\n  unspecialized, except that <strong>the\n  declaration shall not explicitly\n  specialize a class member template if\n  its enclosing class templates are not\n  explicitly specialized as well.</strong></p>\n</blockquote>\n<p>This means that since <code>klass</code> is a template, you cannot specialize <code>klass::func</code> without also specializing <code>klass</code>.</p>\n", "LastActivityDate": "2010-06-10T15:08:09.583"}, "3015678": {"ParentId": "3015507", "CommentCount": "0", "Body": "<p>To answer the question you ask in the title: no, this is not a compiler limitation. This is a language limitation. In C++, in order to explicitly specialize a nested template (be that a class template or a member function template) you have to also explicitly specialize the enclosing template.</p>\n<p>You are trying to explicitly specialize the nested template without specializing the enclosing template. This will not compile.</p>\n<p>When it comes to member function templates, when template parameter is associated with some function parameter (as in your case), you can often replace explicit specialization with overloading, as suggested in Tyler's answer. In other situations you'd have to use a different workaround.</p>\n", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "3015678", "Score": "3", "CreationDate": "2010-06-10T15:10:00.030", "LastActivityDate": "2010-06-10T15:10:00.030"}, "bq_ids": {"n4140": {"so_3015507_3015554_0": {"section_id": 278, "quality": 1.0, "length": 35}}, "n3337": {"so_3015507_3015554_0": {"section_id": 269, "quality": 1.0, "length": 35}}, "n4659": {"so_3015507_3015554_0": {"section_id": 285, "quality": 1.0, "length": 35}}}});