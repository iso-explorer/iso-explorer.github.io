post_cb({"14154290": {"CommentCount": "2", "AcceptedAnswerId": "14154318", "PostTypeId": "1", "ClosedDate": "2013-01-04T14:59:24.030", "LastEditorUserId": "-1", "CreationDate": "2013-01-04T09:21:16.863", "LastActivityDate": "2013-01-04T13:31:04.370", "LastEditDate": "2017-05-23T11:44:24.167", "ViewCount": "605", "FavoriteCount": "5", "Title": "why isn't the copy constructor called", "Id": "14154290", "Score": "17", "Body": "<blockquote>\n<p id=\"so_14154290_14154290_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/12953127/what-are-copy-elision-and-return-value-optimization\">What are copy elision and return value optimization?</a> </br></p>\n</blockquote>\n<p>I am having difficulty understanding why in the following piece of code the copy constructor is not called.</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Test\n{\npublic:\n  Test(int){std::cout &lt;&lt; \"Test()\" &lt;&lt; std::endl;}\n  Test(const Test&amp;){std::cout &lt;&lt; \"Test(const Test&amp;)\" &lt;&lt; std::endl;}\n};\n\nint main()\n{\n  // Test test;\n  Test test2(Test(3));\n\n  return 0;\n}\n</code></pre>\n<p>Can someone explain why only the constructor is called and no copy constructor ?<br>\nThanks.</br></p>\n", "Tags": "<c++>", "OwnerUserId": "340554", "AnswerCount": "3"}, "14154614": {"ParentId": "14154290", "CommentCount": "0", "Body": "<p>As others have already well mentioned this is because of optimization from your compiler.</p>\n<p>I haven't checked it but you could probably compile your code with optimization and again without and have a look at the assembler code. Then you should also definetely see some differences.</p>\n", "OwnerUserId": "664010", "PostTypeId": "2", "Id": "14154614", "Score": "0", "CreationDate": "2013-01-04T09:41:44.880", "LastActivityDate": "2013-01-04T09:41:44.880"}, "14154323": {"ParentId": "14154290", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It is because of the optimization performed by your compiler. Compilers are <em>permitted</em> to perform such optimizations, though it is not a <em>requirement</em>, thus <strong>not</strong> guaranteed.</p>\n<p>Note an important point that even though the copy-constructor is not invoked eventually, it is <strong>semantically required</strong> to be <em>accessible</em>. That is, if you make the copy-constructor <code>private</code>, your code will <strong>not</strong> compile!! It is because the semantic-check is done much before the optimization phase, means the compiler first checks that the copy-constructor is accessible or not; <strong>if</strong> it is <em>accessible</em>, then only comes the optimization phase where the copy-construction is elided.</p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2013-01-04T09:36:36.687", "Id": "14154323", "Score": "11", "CreationDate": "2013-01-04T09:22:59.857", "LastActivityDate": "2013-01-04T09:36:36.687"}, "bq_ids": {"n4140": {"so_14154290_14154318_0": {"section_id": 480, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_14154290_14154318_0": {"section_id": 471, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_14154290_14154318_0": {"section_id": 502, "quality": 0.8333333333333334, "length": 10}}}, "14154318": {"ParentId": "14154290", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This is called as <strong>copy elision</strong>.<br>\nThe compilers are allowed to do this optimization. Though it is not guaranteed by the standard any commercial compiler will perform this optimization whenever it can.</br></p>\n<hr>\n<p><strong>Standard Reference</strong>:      </p>\n<p><strong>C++03 12.8.15:</strong> </p>\n<blockquote>\n<p id=\"so_14154290_14154318_0\">[...] This elision of copy operations is\n  permitted in the following\n  circumstances (which may be combined\n  to eliminate multiple copies):</p>\n<p id=\"so_14154290_14154318_1\">[...]</p>\n<ul>\n<li>when a temporary class object that has\n  not been bound to a reference (12.2)\n  would be copied to a class object with\n  the same cv-unqualified type, the copy\n  operation can be omitted by\n  constructing the temporary object\n  directly into the target of the\n  omitted copy</li>\n</ul>\n</blockquote>\n<hr>\n<p>You might use some compiler settings to disable this optimization, like in case of gcc, from the <strong><a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/C_002b_002b-Dialect-Options.html\">man page</a></strong>:</p>\n<pre><code>-fno-elide-constructor\n</code></pre>\n<blockquote>\n<p id=\"so_14154290_14154318_2\">The C++ standard allows an implementation to omit creating a temporary which is only used to initialize another object of the same type.  Specifying this option disables that optimization, and \n  forces G++ to call the copy constructor in all cases.</p>\n</blockquote>\n<p>However, using this makes your code non portable across different compilers.</p>\n</hr></hr>", "OwnerUserId": "452307", "LastEditorUserId": "452307", "LastEditDate": "2013-01-04T09:27:58.830", "Id": "14154318", "Score": "22", "CreationDate": "2013-01-04T09:22:47.053", "LastActivityDate": "2013-01-04T09:27:58.830"}});