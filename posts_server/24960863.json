post_cb({"bq_ids": {"n4140": {"so_24960863_24961075_0": {"length": 19, "quality": 0.5757575757575758, "section_id": 234}}, "n3337": {"so_24960863_24961075_0": {"length": 19, "quality": 0.5757575757575758, "section_id": 227}}, "n4659": {"so_24960863_24961075_0": {"length": 18, "quality": 0.5454545454545454, "section_id": 244}}}, "24961033": {"Id": "24961033", "PostTypeId": "2", "Body": "<p>Think of it this way: building a templated object needs a type at compile-type.  When you compile this, what is the compiler substituting for T when it instantiates instance?  It can't do all possible values of T, so it won't instantiate anything.  Some compilers will complain that instance is even there.  Providing an int makes it possible to actually instantiate something.</p>\n", "LastActivityDate": "2014-07-25T17:12:21.660", "CommentCount": "1", "CreationDate": "2014-07-25T17:12:21.660", "ParentId": "24960863", "Score": "-1", "OwnerUserId": "3877819"}, "24960863": {"ViewCount": "77", "Body": "<pre><code>template &lt;typename T&gt;\nclass A\n{\n    public:\n    A() {p = this;}\n    static A *GetP() {return p;}\n\n    private:\n    static A *p;\n    static A instance;\n}\n\ntemplate &lt;typename T&gt;\nA&lt;T&gt; *A&lt;T&gt;::p = (A&lt;T&gt; *)4534;    //just test value to check whether p is initiallized or not.\n\ntemplate &lt;typename T&gt;\nA&lt;T&gt; A&lt;T&gt;::instance;\n</code></pre>\n<p>And I call <code>A&lt;int&gt;::GetP()</code>. I hope it returns the address of instance,\nbut it returns <code>(A&lt;int&gt; *)4534</code>.\nIn addition, the constructor wasn't called.</p>\n<p>I think it means p is initialized well, but instance isn't.</p>\n<p>However, if I speciallize it like this, </p>\n<pre><code>A&lt;int&gt; A&lt;int&gt;::instance\n</code></pre>\n<p>It works well.\nWhy does this phenomenon happen?</p>\n", "Title": "Why isn't this static member of template class initialized?", "CreationDate": "2014-07-25T17:03:19.217", "LastActivityDate": "2014-07-25T17:22:34.103", "CommentCount": "0", "LastEditDate": "2014-07-25T17:11:46.373", "PostTypeId": "1", "LastEditorUserId": "1321576", "Id": "24960863", "Score": "1", "OwnerUserId": "1321576", "Tags": "<c++><templates><static-members>", "AnswerCount": "2"}, "24961075": {"Id": "24961075", "PostTypeId": "2", "Body": "<p>14.7.1 Implicit instantiation <strong>[temp.inst]</strong>:</p>\n<blockquote>\n<p id=\"so_24960863_24961075_0\">2 - [...] [T]he initialization (and any associated side-effects) of a static data member does not occur unless the static data member is itself used in a way\n  that requires the definition of the static data member to exist. [...] <br/>\n  8 - The implicit instantiation of a class template does not cause any static data members of that class to be implicitly instantiated.</p>\n</blockquote>\n<p>In general, implicit instantiation is <em>lazy</em>; only those methods you call and members you access will be instantiated. This is a good thing, in part for efficiency and also because it means that e.g. member functions that are only valid for some instantiations can still be written in the general template; they will only be instantiated, possibly making the program ill-formed, if they are called.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2014-07-25T17:22:34.103", "Score": "5", "CreationDate": "2014-07-25T17:14:35.920", "ParentId": "24960863", "CommentCount": "0", "OwnerUserId": "567292", "LastEditDate": "2014-07-25T17:22:34.103"}});