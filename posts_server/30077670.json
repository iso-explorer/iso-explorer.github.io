post_cb({"30077670": {"CommentCount": "17", "AcceptedAnswerId": "30077824", "PostTypeId": "1", "LastEditorUserId": "2660176", "CreationDate": "2015-05-06T13:05:21.810", "LastActivityDate": "2017-06-28T17:42:01.700", "LastEditDate": "2015-10-22T07:04:13.457", "ViewCount": "365", "FavoriteCount": "1", "Title": "initialization of structs/classes without constructors in stack vs heap", "Id": "30077670", "Score": "2", "Body": "<p>I would like to know the rule for zeroing-out structs (or classes) that have no default constructor in C++. </p>\n<p>In particular, it seems that if stored in the stack (say, as a local variable) they are uninitialized, but if allocated on the heap, they are zero-initialized (tested with GCC 4.9.1). <strong>Is this guaranteed to be portable</strong>?</p>\n<p>Example program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\nusing namespace std;\n\nstruct X {\n    int i, j, k;\n    void show() { cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; \" \" &lt;&lt; k &lt;&lt; endl; }\n};\n\nint fib(int i) {\n    return (i &gt; 1) ? fib(i-1) + fib(i-2) : 1;\n}\n\nint main() {\n    map&lt;int, X&gt; m;            \n    fib(10);                  // fills the stack with cruft\n    X x1;                     // local\n    X &amp;x2 = m[1];             // heap-allocated within map\n    X *x3 = new X();          // explicitly heap-allocated\n    x1.show();  // --&gt; outputs whatever was on the heap in those positions\n    x2.show();  // --&gt; outputs 0 0 0 \n    x3-&gt;show(); // --&gt; outputs 0 0 0     \n    return 0;\n}\n</code></pre>\n<hr>\n<p>Edited: removed an \"or should I just use a constructor\" in the bolded part; because what made me ask is that I want to know if it is guaranteed behaviour or not - we can all agree that readable code is better of with explicit constructors.</p>\n</hr>", "Tags": "<c++><struct><initialization>", "OwnerUserId": "15472", "AnswerCount": "3"}, "30077824": {"ParentId": "30077670", "CommentCount": "5", "Body": "<p>It's not the dynamic allocation that's zero-initialising your <code>struct</code> members; it's your syntax:</p>\n<pre><code>X* ptr = new X();\n//            ^^\n// \n// as opposed to just:\nX* ptr = new X;\n</code></pre>\n<p>If you want it guaranteed, just keep writing that. :)</p>\n<p>An alternative, which meshes well with the automatic-storage-duration equivalent, is to use the newer <code>{}</code> syntax:</p>\n<pre><code>X* ptr = new X{};   // dynamic\nX  obj{};           // automatic\n</code></pre>\n<p>And objects with static storage duration are always pre-zero-initialised no matter what, so you're covered there by default.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "30077824", "Score": "5", "CreationDate": "2015-05-06T13:11:43.373", "LastActivityDate": "2015-05-06T13:11:43.373"}, "30077755": {"ParentId": "30077670", "CommentCount": "4", "Body": "<p>Always use a constructor if you want to give your class's members particular values. That's literally what constructors are for. The only time you don't need to write a constructor that sets the values you want is if the language pre-provides one for you like copy constructor. Default constructor is not on this list for <code>int</code> and other such types so you have to add a constructor to your own type that sets them appropriately.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "30077755", "Score": "3", "CreationDate": "2015-05-06T13:09:11.967", "LastActivityDate": "2015-05-06T13:09:11.967"}, "30083769": {"ParentId": "30077670", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As long as you don't have any constructors, all members are public, and there is no inheritance involved, your struct/class is likely an aggregate.</p>\n<p>To get portable zero-initialization, simply use <code>X x = {};</code> which performs zero intialization.</p>\n<p><strong>Here is the standard quote about aggregates (8.5.1):</strong></p>\n<blockquote>\n<p id=\"so_30077670_30083769_0\">An aggregate is an array or a class (Clause 9) with no user-provided\n  constructors (12.1), no brace-or-equal-initializers for non-static\n  data members (9.2), no private or protected non-static data members\n  (Clause 11), no base classes (Clause 10), and no virtual functions\n  (10.3).</p>\n</blockquote>\n<p>reference: <a href=\"https://stackoverflow.com/questions/16983539/why-can-i-not-brace-initialize-a-struct-derived-from-another-struct\">Why can I not brace initialize a struct derived from another struct?</a></p>\n", "OwnerUserId": "1552766", "LastEditorUserId": "2757035", "LastEditDate": "2017-06-28T17:42:01.700", "Id": "30083769", "Score": "0", "CreationDate": "2015-05-06T17:34:03.020", "LastActivityDate": "2017-06-28T17:42:01.700"}, "bq_ids": {"n4140": {"so_30077670_30083769_0": {"section_id": 3298, "quality": 0.6956521739130435, "length": 16}}, "n3337": {"so_30077670_30083769_0": {"section_id": 3168, "quality": 0.8695652173913043, "length": 20}}, "n4659": {"so_30077670_30083769_0": {"section_id": 4063, "quality": 0.5217391304347826, "length": 12}}}});