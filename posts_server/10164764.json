post_cb({"10169130": {"Id": "10169130", "PostTypeId": "2", "Body": "<pre><code>int main()\n{\n    int **p = (int **) new int(7);\n    cout &lt;&lt; *p;\n}\n</code></pre>\n<p>So, <code>new int(7)</code> allocates <code>sizeof(int)</code> bytes of memory and returns a pointer to it.  Let's say that the memory happens to be at address X.  Then X is cast to <code>(int**)</code> and stored in <code>p</code>.</p>\n<p><code>*p</code> dereferences the <code>int**</code>, which means it intreprets the <code>int</code> value 7 at address <code>X</code> as an <code>int*</code>.</p>\n<ul>\n<li><p>If <code>sizeof(int*)</code> is larger than <code>sizeof(int)</code>, then reading as an <code>int*</code> will read beyond the buffer allocated with <code>new</code> - always undefined behaviour regardless of the data types and any reintrepretation.</p></li>\n<li><p>If it is the same size, the CPU will attempt to read the memory containing the integer 7 as an <code>int*</code> - this will typically yield the value <code>int*(7)</code>, but looking at the Standard 5.2.10.5:</p></li>\n</ul>\n<blockquote>\n<p id=\"so_10164764_10169130_0\">A value of integral type or enumeration type can be explicitly converted to a pointer.* \n  [Footnote: Converting an integral constant expression (expr.const) with value zero always yields a null pointer (conv.ptr), but converting other expressions that happen to have value zero need not yield a null pointer. --- end foonote]\n  A pointer converted to an integer of sufficient size (if any such exists on the implementation) and back to the same pointer type will have its original value; mappings between pointers and integers are otherwise implementation-defined. </p>\n</blockquote>\n<p>So, the integer value is guaranteed to convert to some pointer value - nothing undefined - but the value is implementation defined.  Still, being a reversible operation it's <em>overwhelmingly likely</em> that the <code>int</code> 7 will yield an <code>int*</code> with value 7 - that explains the observed behaviour of outputting \"7\".</p>\n<ul>\n<li>If the pointer size is smaller than the <code>int</code> size, it will read a slice of the <code>int</code> value and interpret that as a pointer.  Depending on endianness that slice may be 0 or 7 or even something else, but again as an <code>int</code> it must be convertible to some pointer value that will be displayed.</li>\n</ul>\n", "LastEditorUserId": "410767", "LastActivityDate": "2012-04-16T05:55:59.850", "Score": "0", "CreationDate": "2012-04-16T05:33:57.720", "ParentId": "10164764", "CommentCount": "0", "OwnerUserId": "410767", "LastEditDate": "2012-04-16T05:55:59.850"}, "10164900": {"Id": "10164900", "PostTypeId": "2", "Body": "<p>The proper answer would be <em>None of the above</em> unless you are given some extra constraints. Basically the code is allocating an <code>int</code> and interpreting that memory as if it was an <code>int*</code> (through a <code>reinterpret_cast</code>). The first problem is that, being a <code>reinterpret_cast</code>, the result is <em>unspecified</em> in the general case, and if the size of <code>int</code> is smaller than the size of <code>int*</code> (think a 64bit architecture) the result is <em>undefined behavior</em> as you are reading beyond the size allocated in the <code>new</code> call.</p>\n", "LastActivityDate": "2012-04-15T18:40:02.110", "CommentCount": "3", "CreationDate": "2012-04-15T18:40:02.110", "ParentId": "10164764", "Score": "5", "OwnerUserId": "36565"}, "bq_ids": {"n4140": {"so_10164764_10169130_0": {"length": 31, "quality": 0.5254237288135594, "section_id": 6044}}, "n3337": {"so_10164764_10169130_0": {"length": 31, "quality": 0.5254237288135594, "section_id": 5812}}, "n4659": {"so_10164764_10169130_0": {"length": 31, "quality": 0.5254237288135594, "section_id": 7543}}}, "10164821": {"Id": "10164821", "PostTypeId": "2", "Body": "<pre><code>new int(7);\n</code></pre>\n<p>allocates memory for an <code>int</code> whose value is <code>7</code> and returns a pointer to it.</p>\n<pre><code>int **p = (int **) new int(7);\n</code></pre>\n<p>tells the compiler to interpret that memory as an <code>int**</code>.</p>\n<pre><code>cout &lt;&lt; *p;\n</code></pre>\n<p>tells the compiler that at the address <code>*p</code> is an <code>int *</code> and to output its value. The value is <code>0x07</code>. (it treats the int <code>7</code> as an address). An extra dereference would result in a crash (well, undefined behavior to be precise).</p>\n", "LastActivityDate": "2012-04-15T18:30:52.160", "CommentCount": "2", "CreationDate": "2012-04-15T18:30:52.160", "ParentId": "10164764", "Score": "0", "OwnerUserId": "673730"}, "10164880": {"Id": "10164880", "PostTypeId": "2", "Body": "<pre><code>int main()\n{\n    int **p;                  // declare pointer to pointer called p\n    p = (int **) new int(7);  // new allocates integer initialized to value of 7 and returns a pointer.  Cast the pointer to a point to pointer.  p now represents a pointer to a pointer with contents of 0x7.  If you called **p you would get the contents at address 0x7.\n    cout &lt;&lt; *p; // dereference p, this yields a pointer, which is an int of value 0x7.\n}\n</code></pre>\n<p>The question was most likely meant to test your knowledge of pointers, but doesn't seem very practical.</p>\n", "LastActivityDate": "2012-04-15T18:37:25.267", "CommentCount": "0", "CreationDate": "2012-04-15T18:37:25.267", "ParentId": "10164764", "Score": "0", "OwnerUserId": "1131254"}, "10164764": {"ViewCount": "215", "Body": "<p>I came across this code in an interview. </p>\n<pre><code>int main()\n{\n    int **p;\n    p = (int **) new int(7);\n    cout&lt;&lt;*p; \n    return 0;\n}\n</code></pre>\n<p>I was expecting some run time error at *p. But when I ran the code , it executed successfully with output \"0x7\". Can someone please explain me how is this working. Thanks.</p>\n", "AcceptedAnswerId": "10164900", "Title": "Explicit casting of ptr to \"ptr to a ptr\"", "CreationDate": "2012-04-15T18:23:27.297", "Id": "10164764", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-04-15T18:25:03.750", "LastEditorUserId": "635608", "LastActivityDate": "2012-04-16T09:49:30.697", "Score": "7", "OwnerUserId": "892759", "Tags": "<c++><pointers><casting>", "AnswerCount": "5"}, "10164794": {"Id": "10164794", "PostTypeId": "2", "Body": "<p>You create a new int and initialize it with value 7.</p>\n<pre><code>int *x = new int(7);\n</code></pre>\n<p>You than cast it to a pointer (eg memory address 7 or 0x07)</p>\n<pre><code>int **p = (int**) new int(7);\n</code></pre>\n<p>Then you show this address with cout.</p>\n<pre><code>*p is equal to (int*)7\n</code></pre>\n<p>It's a pointer with value 7.</p>\n", "LastActivityDate": "2012-04-15T18:27:20.130", "CommentCount": "1", "CreationDate": "2012-04-15T18:27:20.130", "ParentId": "10164764", "Score": "4", "OwnerUserId": "819072"}});