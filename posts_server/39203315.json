post_cb({"bq_ids": {"n4140": {"so_39203315_39203893_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 72}}, "n3337": {"so_39203315_39203893_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 67}}}, "39203315": {"ViewCount": "38", "Body": "<p>I am working on Tag dispatching implementation in my SW and am facing weird behavior of my code. Let the code tells more:</p>\n<p>I have tag system as follows:</p>\n<pre><code>struct GEAR_EXPORT GearParams\n{\n    struct ParameterType\n    {\n        using IDType = int;\n    };\n\n    struct GEAR_EXPORT NUM_OF_TEETH : public ParameterType\n    {\n        /* NUM_OF_TEETH parameter's unit type definition */\n        using UnitType = si::dimensionless;\n        /* NUM_OF_TEETH parameter's data type definition */\n        using DataType = short;\n        /* NUM_OF_TEETH parameter's DesignRules DB ID */\n        using ID = std::integral_constant&lt;ParameterType::IDType, 1&gt;;\n    };\n\n    struct GEAR_EXPORT MODULE : public ParameterType\n    {\n        /* MODULE parameter's unit type definition */\n        using UnitType = si::length;\n        /* MODULE parameter's data type definition */\n        using DataType = double;\n        /* MODULE parameter's DesignRules DB ID */\n        using ID = std::integral_constant&lt;ParameterType::IDType, 2&gt;;\n    };\n\n    /* ... many others similarly defined as above follows */\n};\n</code></pre>\n<p>I know the tags should be left empty classes so that compiler can optimize them away but the advantage of having the type definitions inside exceeds the compiler optimization benefit. <strong>I hope this is not the cause of my troubles as described below?</strong></p>\n<p>Then I have a ParameterContainer class which supplies a set of templated methods like this one:</p>\n<pre><code>template&lt;typename PARAM_IDENTIFICATION&gt;\nbool isSet( void ) const\n{\n    /* Once the find() reaches the end of the container, the parameter is not in */\n    if( mStorage.find( PARAM_IDENTIFICATION::ID::value ) == mStorage.end() )\n        return( false );\n    else\n        return( true );\n}\n</code></pre>\n<p>It accepts single template parameter PARAM_IDENTIFICATION which acts as the Tag (Tag dispatching by type). The method is used as follows <strong><em>[WORKS]</em></strong>:</p>\n<pre><code>if( TestContainer.isSet&lt;GearParams::NUM_OF_TEETH&gt;() == true )\n{\n    /* do something */\n}\n</code></pre>\n<p>This is working fine. But once I try to use it in templated method like this <strong><em>[FAILS]</em></strong>:</p>\n<pre><code>template&lt;typename PARAM_IDENTIFICATION&gt;\nbool check( void ) const\n{\n    return( mParameters.isSet&lt;PARAM_IDENTIFICATION&gt;() );\n}\n</code></pre>\n<p>But even the compilation fails bacause of:</p>\n<pre><code>error: expected primary-expression before \u2018&gt;\u2019 token\n    return( mParameters.isSet&lt;PARAM_IDENTIFICATION&gt;() );\n                                                  ^\n</code></pre>\n<p>and</p>\n<pre><code>error: expected primary-expression before \u2018)\u2019 token\n    return( mParameters.isSet&lt;PARAM_IDENTIFICATION&gt;() );\n                                                    ^\n</code></pre>\n<p>I know the primary expression error is usually cause by type/instance mixup.\nWhat I do not understand is that when I use the <code>isSet()</code> method with a complete type <code>GearParams::NUM_OF_TEETH</code> it works but fails when using the same via templated method:</p>\n<pre><code>check&lt;GearParams::NUM_OF_TEETH&gt;();\n</code></pre>\n<p>What is the difference? What's wrong with my code? I would expect the same implementation would behave somehow consistently... am I missing something in my code?</p>\n<p>Many thanks in advance to anybody willing to help...</p>\n", "AcceptedAnswerId": "39203893", "Title": "Tag dispatching by type invokes expected primary-expression error", "CreationDate": "2016-08-29T09:52:40.757", "Id": "39203315", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-08-29T10:22:33.277", "Score": "0", "OwnerUserId": "5677080", "Tags": "<templates><c++11>", "AnswerCount": "1"}, "39203893": {"PostTypeId": "2", "Body": "<p>Try <code>mParameters.template isSet&lt;PARAM_IDENTIFICATION&gt;()</code>.</p>\n<p>According to the latest standard draft, $14.2.4:</p>\n<blockquote>\n<p id=\"so_39203315_39203893_0\">When the name of a member template specialization appears after . or -&gt; in a postfix-expression or after a\n  nested-name-specifier in a qualified-id, and the object expression of the postfix-expression is type-dependent\n  or the nested-name-specifier in the qualified-id refers to a dependent type, but the name is not a member of\n  the current instantiation (14.6.2.1), the member template name must be prefixed by the keyword template.\n  Otherwise the name is assumed to name a non-template.</p>\n</blockquote>\n", "LastActivityDate": "2016-08-29T10:22:33.277", "Id": "39203893", "CommentCount": "1", "CreationDate": "2016-08-29T10:22:33.277", "ParentId": "39203315", "Score": "1", "OwnerUserId": "598696"}});