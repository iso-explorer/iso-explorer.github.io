post_cb({"bq_ids": {"n4140": {"so_16865225_16865452_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 152}}, "n3337": {"so_16865225_16865452_0": {"length": 26, "quality": 1.0, "section_id": 146}}, "n4659": {"so_16865225_16865452_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 156}}}, "16865225": {"ViewCount": "1088", "Body": "<p>To my surprise this program compiles in both MSCV and GCC:</p>\n<pre><code>class A\n{\npublic:\n  int add() { return 0; }\n  template&lt;typename T&gt;\n  T add() { return T(); }\n};\n\nint main() { \n  A a;\n  a.add();\n  a.add&lt;int&gt;();\n  return 0; \n}\n</code></pre>\n<p>Obviously, due to the fact that the type of the templated method cannot be deduced and needs to be explicitly stated, so the situation isn't ambigious - still it seems a bit shady - if it were a non-templated method that would be obviously incorrect.</p>\n<p>I've tried googling and looking through the last draft of the standard, but couldn't find the answer - is same naming of a template method and a normal method that only differ by return type legal in C++, or are the compilers just being permissive?</p>\n", "AcceptedAnswerId": "16865452", "Title": "Method name same as template method name in C++", "CreationDate": "2013-05-31T20:13:27.530", "Id": "16865225", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2013-05-31T21:02:16.390", "Score": "10", "OwnerUserId": "233522", "Tags": "<c++><templates>", "AnswerCount": "1"}, "16865452": {"Id": "16865452", "PostTypeId": "2", "Body": "<p>This has always been legal C++.</p>\n<p>14.5.6/2:</p>\n<blockquote>\n<p id=\"so_16865225_16865452_0\">A function template can be overloaded with other function templates and with normal (non-template) functions.  A normal function is not related to a function template (i.e., it is never considered to be a specialization), even if it has the same name and type as a potentially generated function template specialization.</p>\n</blockquote>\n<p>When using the \"template-id\" syntax like <code>add&lt;int&gt;</code>, only template functions with enough template parameters are considered.  So <code>a.add&lt;int&gt;()</code> doesn't even look at whether the non-template <code>add</code> matches.</p>\n<p>When an identifier names both a plain function and a function template, the compiler will try to deduce template arguments for the function template to get a template function specialization.  Then all plain functions and all template function specializations are compared by the usual function overload logic.  [See 13.3.1/7.]</p>\n<p>In your example, the call <code>a.add()</code> can't deduce the template argument <code>T</code> for the template version.  So the only viable function is the non-template overload.</p>\n<p>There's also another rule that comes up in a similar situation: if a non-template function and a template function specialization would otherwise be an ambiguous overload, the non-template function wins. [This rule is in section 13.3.3, in the middle of the definition of what makes one function better than another for a given set of arguments.]</p>\n<pre><code>class B\n{\npublic:\n  int f(int n) { return n+1; }\n\n  template&lt;typename T&gt;\n  T f(T n) { return n; }\n};\n\nint main() {\n  B b;\n  b.f(1);       // both are viable, non-template wins\n  b.f&lt;int&gt;(1);  // only the template is viable\n  return 0;\n}\n</code></pre>\n<p>This makes sense because the template can still be used by other specializations, or by explicitly using the <code>&lt;</code>angle brackets<code>&gt;</code>.  So overloading a function template with a non-template function is sort of like adding an explicit specialization, but with fewer headaches.</p>\n", "LastEditorUserId": "459640", "LastActivityDate": "2013-05-31T21:02:16.390", "Score": "9", "CreationDate": "2013-05-31T20:27:34.457", "ParentId": "16865225", "CommentCount": "1", "LastEditDate": "2013-05-31T21:02:16.390", "OwnerUserId": "459640"}});