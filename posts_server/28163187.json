post_cb({"28163187": {"CommentCount": "7", "ViewCount": "801", "PostTypeId": "1", "LastEditorUserId": "3510483", "CreationDate": "2015-01-27T04:19:32.493", "LastActivityDate": "2015-02-20T04:38:04.273", "Title": "Why \"override\" is at the end in C++11?", "AcceptedAnswerId": "28163251", "LastEditDate": "2015-01-27T04:37:58.087", "Id": "28163187", "Score": "14", "Body": "<p>I'm trying to see the reason why, in C++11, they had to add the <code>override</code> keyword at the end of the method instead of the beginning like <code>virtual</code>. I don't see the interest of being able to write both <code>virtual</code> and <code>override</code> in the declaration of a method.</p>\n<p>Is there a technical reason why the committee didn't choose to simply be able to write <code>override</code> instead of <code>virtual</code> when it was needed?</p>\n<p>Thanks!</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1842511", "AnswerCount": "2"}, "28165912": {"ParentId": "28163187", "CommentCount": "14", "Body": "<p>There certainly is a technical reason for it! You can read all about it in <a href=\"http://bulldozer00.com/2014/04/17/context-sensitive-keywords/\">this article</a>.</p>\n<p>Briefly, <code>override</code> is a context-sensitive keyword, which means that you can also use it as an identifier. It was done this way to avoid breaking existing code that uses this identifier. That means that it has to appear in a position where identifiers are not allowed, namely immediately after the closing parenthesis of a function declaration.</p>\n", "OwnerUserId": "428857", "PostTypeId": "2", "Id": "28165912", "Score": "9", "CreationDate": "2015-01-27T08:17:14.430", "LastActivityDate": "2015-01-27T08:17:14.430"}, "bq_ids": {"n4140": {"so_28163187_28163251_6": {"section_id": 5334, "quality": 0.9142857142857143, "length": 32}}, "n3337": {"so_28163187_28163251_6": {"section_id": 5131, "quality": 0.8571428571428571, "length": 30}}, "n4659": {"so_28163187_28163251_6": {"section_id": 6755, "quality": 0.9142857142857143, "length": 32}}}, "28163251": {"ParentId": "28163187", "LastEditDate": "2015-01-27T21:37:23.093", "CommentCount": "10", "CreationDate": "2015-01-27T04:27:09.153", "OwnerUserId": "3510483", "LastEditorUserId": "3510483", "PostTypeId": "2", "Id": "28163251", "Score": "14", "Body": "<p>The proposal for the addition of the keywords controlling override (<a href=\"http://en.cppreference.com/w/cpp/language/override\" rel=\"nofollow\"><code>override</code></a>/<a href=\"http://en.cppreference.com/w/cpp/language/final\" rel=\"nofollow\"><code>final</code></a>) , paper <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3151.html\" rel=\"nofollow\">N3151</a> , gives us some insight about this choice (emphasis mine) :</p>\n<blockquote>\n<p id=\"so_28163187_28163251_0\">It is preferable to put such virtual control keywords at the end of\n  the declaration so that they don't clash with eg. return types at the\n  beginning of declarations.</p>\n<p id=\"so_28163187_28163251_1\">[...]</p>\n<p id=\"so_28163187_28163251_2\">For context-insensitive, normal keywords, it's less important where\n  the keywords are placed because the words are reserved. We could put\n  them at the beginning of declarations or at the end.</p>\n<p id=\"so_28163187_28163251_3\">During the discussion of attributes, Francis Glassborow pointed out\n  that the beginning of declarations is becoming crowded. If we put the\n  virtual control keywords at the beginning, we can end up with examples\n  like the one below:</p>\n</blockquote>\n<pre><code>struct B\n{\n   virtual volatile const unsigned long int f()\n      volatile const noexcept;\n   void f(int g);\n};\n\nstruct D : B\n{\n   virtual hides_name virtual_override final_overrider volatile const unsigned long int f()\n      volatile const noexcept;\n};\n</code></pre>\n<blockquote>\n<p id=\"so_28163187_28163251_4\">Putting the new keywords at the end at least alleviates the situation\n  somewhat:</p>\n</blockquote>\n<pre><code>struct B\n{\n   virtual volatile const unsigned long int f()\n      volatile const noexcept;\n   void f(int g);\n};\n\nstruct D : B\n{\n   virtual volatile const unsigned long int f()\n      hides_name virtual_override final_overrider volatile const noexcept;\n};\n</code></pre>\n<blockquote>\n<p id=\"so_28163187_28163251_5\"><strong>There are people who think these control keywords should be in the\n  same place with virtual. As mentioned, that place is already crowded.</strong></p>\n</blockquote>\n<hr>\n<p><strong>Note:</strong></p>\n<p>The C++ 11 Standard defines context sensitive keywords in section \u00a7 2.11 / 2 [lex.name] :</p>\n<blockquote>\n<p id=\"so_28163187_28163251_6\">The identifiers in Table 3 have a special meaning when appearing in a\n  certain context. When referred to in the grammar, these identifiers\n  are used explicitly rather than using the identifier grammar\n  production. Unless otherwise specified, any ambiguity as to whether a\n  given identifier has a special meaning is resolved to interpret the\n  token as a regular identifier.</p>\n<p id=\"so_28163187_28163251_7\">Table3:</p>\n<p id=\"so_28163187_28163251_8\"><strong>final override</strong></p>\n</blockquote>\n</hr>", "LastActivityDate": "2015-01-27T21:37:23.093"}});