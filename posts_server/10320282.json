post_cb({"10320385": {"ParentId": "10320282", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_10320282_10320385_0\">\u00a7 12.3.1/1 \"Type conversions of class objects can be specified by constructors and by conversion functions. These conversions are called user-defined conversions and are used for implicit type conversions (Clause 4), for initialization (8.5), and for explicit type conversions (5.4, 5.2.9).\"</p>\n</blockquote>\n<p>Yes, we can make conversions, but only if one or both sides is a user-defined type, so we can't make one for <code>double</code> to <code>int</code>.</p>\n<pre><code>struct demostruct {\n    demostruct(int x) :data(x) {} //used for conversions from int to demostruct\n    operator int() {return data;} //used for conversions from demostruct to int\n    int data;\n};\n\nint main(int argc, char** argv) {\n    demostruct ds = argc; //conversion from int to demostruct\n    return ds; //conversion from demostruct to int\n}\n</code></pre>\n<p>As Rob\u1d69 pointed out, you can add the <code>explicit</code> keyword to either of those conversion functions, which requires the user to explicitly cast them with a <code>(demostruct)argc</code> or <code>(int)ds</code> like in your code, instead of having them implicitly convert.  If you convert to and from the same type, it's usually best to have one or both as <code>explicit</code>, otherwise you might get compilation errors.</p>\n", "OwnerUserId": "845092", "LastEditorUserId": "845092", "LastEditDate": "2012-04-25T17:14:50.743", "Id": "10320385", "Score": "4", "CreationDate": "2012-04-25T17:01:19.407", "LastActivityDate": "2012-04-25T17:14:50.743"}, "10320356": {"ParentId": "10320282", "CommentCount": "4", "Body": "<p>You can\u2019t overload operators for built-in types, but you can write a conversion operator for a user-defined type:</p>\n<pre><code>struct Double {\n    double value;\n    operator int() const {\n        shenanigans();\n        return value;\n    }\n};\n</code></pre>\n<p>Since your question arose from a need to find explicit casts in code, also be aware that C++ has explicit casting operators. These are not only clearer than C-style casts, but also eminently searchable:</p>\n<pre><code>static_cast&lt;T&gt;(x)      // Cast based on static type conversion.\ndynamic_cast&lt;T&gt;(x)     // Cast based on runtime type information.\nconst_cast&lt;T&gt;(x)       // Add or remove const or volatile qualification.\nreinterpret_cast&lt;T&gt;(x) // Cast between unrelated pointer and integral types.\n</code></pre>\n", "OwnerUserId": "246886", "PostTypeId": "2", "Id": "10320356", "Score": "2", "CreationDate": "2012-04-25T16:59:22.077", "LastActivityDate": "2012-04-25T16:59:22.077"}, "10320369": {"ParentId": "10320282", "CommentCount": "0", "Body": "<p>Yes, but only for your own types. Look at this:</p>\n<pre><code>#include &lt;iostream&gt;\nstruct D {\n  // \"explicit\" keyword requires C++11\n  explicit operator int() { std::cout &lt;&lt; __FUNCTION__ &lt;&lt; \"\\n\"; }\n};\n\nint main () {\n  int i;\n  D d;\n  //i = d;\n  i = (int)d;\n}\n</code></pre>\n<p>So, you cannot create <code>double::operator int()</code>, but you could create <code>MyDouble::operator int()</code>.</p>\n", "OwnerUserId": "8747", "PostTypeId": "2", "Id": "10320369", "Score": "3", "CreationDate": "2012-04-25T17:00:02.993", "LastActivityDate": "2012-04-25T17:00:02.993"}, "10320340": {"ParentId": "10320282", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Conversions to other types are overloadable operators in C++ (<a href=\"http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=/com.ibm.xlcpp8a.doc/language/ref/cplr383.htm\" rel=\"nofollow\">some examples here</a>), but this fact will not help you.</p>\n<p>Stroustrup <a href=\"http://www2.research.att.com/~bs/whitespace98.pdf\" rel=\"nofollow\">wanted</a> the language to be extensible, but not mutable.  Therefore, overloading an operator only extends the operations to new types, but you cannot redefine what happens with any old types.</p>\n<p>\"<em>However, to avoid absurdities, it is (still) not allowed to provide new meanings for the built-in operators for built-in types. Thus, the language remains extensible but not mutable.</em>\"</p>\n", "OwnerUserId": "1235565", "LastEditorUserId": "1235565", "LastEditDate": "2012-04-25T18:01:36.190", "Id": "10320340", "Score": "1", "CreationDate": "2012-04-25T16:58:13.007", "LastActivityDate": "2012-04-25T18:01:36.190"}, "10320282": {"CommentCount": "5", "ViewCount": "165", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-04-25T16:54:34.750", "LastActivityDate": "2012-04-25T18:01:36.190", "Title": "are casts overridable operations? if so, how?", "AcceptedAnswerId": "10320385", "LastEditDate": "2017-05-23T10:34:50.447", "Id": "10320282", "Score": "3", "Body": "<p>Is it possible to override (C-style) casts in C++?</p>\n<p>Suppose I have the code</p>\n<pre><code>double x = 42;\nint k = (int)x;\n</code></pre>\n<p>Can I make the cast in the second line execute some code I wrote? Something like</p>\n<pre><code>// I don't know C++\n// I have no idea if this has more syntax errors than words\noperator (int)(double) {\n    std::cout &lt;&lt; \"casting from double to int\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p><sup>The reason I ask is because of the question <a href=\"https://stackoverflow.com/questions/10318646/is-there-any-way-to-get-gcc-or-clang-to-warn-on-explicit-casts\">\"Is there any way to get gcc or clang to warn on explicit casts?\"</a> and my suggestion there.</sup></p>\n", "Tags": "<c++><casting><override>", "OwnerUserId": "25324", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_10320282_10320385_0": {"section_id": 383, "quality": 0.8333333333333334, "length": 20}}, "n3337": {"so_10320282_10320385_0": {"section_id": 374, "quality": 0.8333333333333334, "length": 20}}, "n4659": {"so_10320282_10320385_0": {"section_id": 400, "quality": 0.8333333333333334, "length": 20}}}});