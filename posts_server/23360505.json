post_cb({"23361149": {"ParentId": "23360505", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_23360505_23361149_0\"><code>[C++11: 15.1/3]:</code> <strong>A <em>throw-expression</em> initializes a temporary object, called the exception object</strong>, the type of which is determined by removing any top-level cv-qualifiers from the static type of the operand of throw and adjusting the type from \u201carray of T\u201d or \u201cfunction returning T\u201d to \u201cpointer to T\u201d or \u201cpointer to function returning T\u201d, respectively. <strong>The temporary is an lvalue and is used to initialize the variable named in the matching handler</strong> (15.3). If the type of the exception object would be an incomplete type or a pointer to an incomplete type other than (possibly cv-qualified) void the program is ill-formed. Except for these restrictions and the restrictions on type matching mentioned in 15.3, <strong>the operand of <code>throw</code> is treated exactly as a function argument in a call</strong> (5.2.2) or the operand of a return statement.</p>\n</blockquote>\n<p>In short, <em>you're slicing it</em>, despite the exception handler having accepted a reference.</p>\n<p>Re-throwing should be accomplished by writing simply <code>throw</code>, on its own. This is exactly its purpose:</p>\n<blockquote>\n<p id=\"so_23360505_23361149_1\"><code>[C++11: 15.1/8]:</code> A <em>throw-expression</em> with no operand rethrows the currently handled exception (15.3). <strong>The exception is reactivated with the existing temporary; no new temporary exception object is created.</strong> <em>[..]</em></p>\n</blockquote>\n<p>So:</p>\n<pre><code>throw e;  // no\nthrow;    // yes\n</code></pre>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "23361149", "Score": "3", "CreationDate": "2014-04-29T09:47:35.460", "LastActivityDate": "2014-04-29T09:47:35.460"}, "23360505": {"CommentCount": "0", "ViewCount": "420", "PostTypeId": "1", "LastEditorUserId": "1302312", "CreationDate": "2014-04-29T09:17:53.123", "LastActivityDate": "2014-04-29T09:47:35.460", "Title": "How to catch derived (polymorphic) exception object and re-throw it to second level?", "AcceptedAnswerId": "23361149", "LastEditDate": "2014-04-29T09:27:27.960", "Id": "23360505", "Score": "1", "Body": "<p>How to catch derived (polymorphic) exception object and re-throw it to second level?\nIn my case derived object is preserved till 'Level 1' only.</p>\n<p>I understand 'Return value optimization' done by c++ compilers.\nIn my opinion in the below code reference of 'e' should no longer be valid at 'Level 2' but compiler is doing some implicit creation of local base class Exception object and I am loosing my original ExtException thrown from 'Level 0'.</p>\n<p>My question is\nHow could I preserve 'ExtException' object till 'Level 2' ?</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nusing std::endl;\n\ntypedef std::string pstring;\n\n\nclass Exception\n{\n    public:\n        Exception ( ) {\n            my_id = ++static_count;\n            std:: cout &lt;&lt; \"+Exception obj created.  ID: \" &lt;&lt; my_id &lt;&lt; \"  (Total: \" &lt;&lt; static_count &lt;&lt; \")\" &lt;&lt; endl;\n        }\n\n        Exception ( const Exception &amp;e ) {\n            my_id = ++static_count;\n            std:: cout &lt;&lt; \"+Exception obj created.  ID: \" &lt;&lt; my_id &lt;&lt; \"  (Total: \" &lt;&lt; static_count &lt;&lt; \")\" &lt;&lt; endl;\n        }\n\n        virtual ~Exception() {\n            --static_count;\n            std:: cout &lt;&lt; \"-Exception obj deleted.  ID: \" &lt;&lt; my_id &lt;&lt; \"  (Total: \" &lt;&lt; static_count &lt;&lt; \")\" &lt;&lt; endl;\n        }\n\n    private:\n        static int static_count;\n        int        my_id;\n};\nint Exception:: static_count = 0;\n\n\n\nclass ExtException : public Exception {\n    public:\n        ExtException () : Exception()\n        { \n            std:: cout &lt;&lt; \"++ExtException obj created\" &lt;&lt; endl;\n        }\n\n        ExtException ( const ExtException &amp;e ) : Exception()\n        { \n            std:: cout &lt;&lt; \"++ExtException obj created\" &lt;&lt; endl;\n        }\n\n        ~ExtException () {\n            std:: cout &lt;&lt; \"--ExtException obj deleted\" &lt;&lt; endl;\n        }\n};\n\n\n\n\n\nvoid foo2 () {\n    throw ExtException();   // Level 0 throw\n}\n\n\nvoid foo1 () \n{\n    try {\n        foo2 ();\n    } catch ( Exception &amp;e ) {\n        // In my normal understanding of c++ 'e' should no longer be valid here \n        // as it was created on a stack which is no longer exists (i.e Level 0 is scoped out).\n        //\n        // _BUT_  (actually it is valid. and it is valid because of RVO compiler \"Return value optimization\"\n\n        std:: cout &lt;&lt; \"\\n--- foo1 catch\" &lt;&lt; endl;\n        throw e;  // Level 1 throw\n    }\n}\n\n\nvoid foo () \n{\n    try {\n        foo1 ();\n    } catch ( Exception &amp;e ) {\n        // !!! CAUTION !!!\n        // In my opinion 'e' must not be valid here as the original \"ExtException\" must be destroyed till \n        // this point (which is actually destroyed check output trace).\n        // It is destroyed because RVO works for one level only...\n        //\n        // wait a minute... here the compiler has not left 'e' for FMR hit, instead it has created a new temporary object of 'Exception' class and\n        //  'e' is referring to that.\n        //\n        // Here comes my real question!!!  'e' is no longer referring to an actual  ExtException object but the temporary one, \n        // how could I modify this code to access ExtException object created at 'Level 0'?\n\n        std:: cout &lt;&lt; \"\\n--- foo catch\" &lt;&lt; endl;\n        throw e;  // Level 2 throw\n    }\n}\n\n\nint main (void) {\n\n    try {\n        foo  ();\n    } catch (...) { }\n    return 1;\n}\n</code></pre>\n<p>Below is the result for above code:</p>\n<pre><code>+Exception obj created.  ID: 1  (Total: 1)\n++ExtException obj created\n\n--- foo1 catch\n+Exception obj created.  ID: 2  (Total: 2)\n--ExtException obj deleted\n-Exception obj deleted.  ID: 1  (Total: 1)\n\n--- foo catch\n+Exception obj created.  ID: 2  (Total: 2)\n-Exception obj deleted.  ID: 2  (Total: 1)\n-Exception obj deleted.  ID: 2  (Total: 0)\n</code></pre>\n", "Tags": "<c++><exception><exception-handling><try-catch>", "OwnerUserId": "1302312", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_23360505_23361149_1": {"section_id": 3341, "quality": 0.6842105263157895, "length": 13}}, "n3337": {"so_23360505_23361149_1": {"section_id": 3211, "quality": 0.7894736842105263, "length": 15}, "so_23360505_23361149_0": {"section_id": 3206, "quality": 0.8857142857142857, "length": 62}}, "n4659": {"so_23360505_23361149_1": {"section_id": 7673, "quality": 0.6842105263157895, "length": 13}}}, "23360910": {"ParentId": "23360505", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Prefer \"throw\" over \"throw e\" for polymorphic exceptions.</p>\n<p>Reference:</p>\n<p><a href=\"http://ptgmedia.pearsoncmg.com/images/0321113586/items/sutter_item73.pdf\" rel=\"nofollow\">http://ptgmedia.pearsoncmg.com/images/0321113586/items/sutter_item73.pdf</a></p>\n", "OwnerUserId": "2542312", "LastEditorUserId": "560648", "LastEditDate": "2014-04-29T09:45:33.493", "Id": "23360910", "Score": "3", "CreationDate": "2014-04-29T09:36:02.673", "LastActivityDate": "2014-04-29T09:45:33.493"}});