post_cb({"48580559": {"ViewCount": "102", "Body": "<p>I am trying to cast a pointer to data member of derived class to a pointer to data member of  base class, but the following code does not compile:</p>\n<pre><code>class Base \n{\npublic:\n    virtual void f() {}\n};\n\nclass Derived : public Base \n{\npublic:\n    void f() override {}\n};\n\nclass Enclosing\n{\npublic:\n    Derived member;\n};\n\nint main()\n{\n    Derived Enclosing::*p = &amp;Enclosing::member;\n    auto bp = static_cast&lt;Base Enclosing::*&gt;(p); // compile error\n}\n</code></pre>\n<p>So I used <code>reinterpret_cast</code> instead, and the code compiles:</p>\n<pre><code>auto bp = reinterpret_cast&lt;Base Enclosing::*&gt;(p); // passes compile\n</code></pre>\n<p>And I tried to use <code>bp</code> straightforwardly:</p>\n<pre><code>Enclosing instance;\n(instance.*bp).f(); // calls Base::f\n</code></pre>\n<p>This is not what I expected because the member in <code>Enclosing</code> is actually <code>Derived</code> type.\nThen I tried this:</p>\n<pre><code>(&amp;(instance.*bp))-&gt;f(); // calls Derived::f\n</code></pre>\n<p>It works on my environment, but is this behavior guaranteed?</p>\n", "Title": "Upcasting a pointer to data member and its polymorphic behavior", "CreationDate": "2018-02-02T10:21:49.503", "LastActivityDate": "2018-02-02T12:05:58.603", "CommentCount": "1", "PostTypeId": "1", "Id": "48580559", "Score": "6", "OwnerUserId": "3720890", "Tags": "<c++><pointers>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_48580559_48582082_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 42}, "so_48580559_48582082_6": {"length": 27, "quality": 0.9642857142857143, "section_id": 6049}, "so_48580559_48582082_7": {"length": 13, "quality": 0.8666666666666667, "section_id": 6131}, "so_48580559_48582082_2": {"length": 19, "quality": 1.0, "section_id": 43}, "so_48580559_48582082_5": {"length": 20, "quality": 0.9523809523809523, "section_id": 6049}, "so_48580559_48582082_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 0}, "so_48580559_48582082_4": {"length": 26, "quality": 0.9629629629629629, "section_id": 6049}, "so_48580559_48582082_3": {"length": 34, "quality": 0.8717948717948718, "section_id": 6038}}, "n3337": {"so_48580559_48582082_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 39}, "so_48580559_48582082_6": {"length": 27, "quality": 0.9642857142857143, "section_id": 5817}, "so_48580559_48582082_7": {"length": 13, "quality": 0.8666666666666667, "section_id": 5895}, "so_48580559_48582082_2": {"length": 19, "quality": 1.0, "section_id": 40}, "so_48580559_48582082_5": {"length": 20, "quality": 0.9523809523809523, "section_id": 5817}, "so_48580559_48582082_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 0}, "so_48580559_48582082_4": {"length": 26, "quality": 0.9629629629629629, "section_id": 5817}, "so_48580559_48582082_3": {"length": 34, "quality": 0.8717948717948718, "section_id": 5806}}, "n4659": {"so_48580559_48582082_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 42}, "so_48580559_48582082_6": {"length": 27, "quality": 0.9642857142857143, "section_id": 7548}, "so_48580559_48582082_7": {"length": 13, "quality": 0.8666666666666667, "section_id": 7628}, "so_48580559_48582082_2": {"length": 19, "quality": 1.0, "section_id": 43}, "so_48580559_48582082_5": {"length": 20, "quality": 0.9523809523809523, "section_id": 7548}, "so_48580559_48582082_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 0}, "so_48580559_48582082_4": {"length": 26, "quality": 0.9629629629629629, "section_id": 7548}, "so_48580559_48582082_3": {"length": 27, "quality": 0.6923076923076923, "section_id": 7537}}}, "48582082": {"Id": "48582082", "PostTypeId": "2", "Body": "<p>You cannot have what you want. You can get polymorphism with data members only in this situation: <code>pointer to member of D of type T</code> converted to <code>pointer of member of B of type T</code> where <code>B</code> is a base class of <code>D</code>.</p>\n<p>What you want, converting <code>pointer to member of X of type T1</code> to <code>pointer to member of X of type T2</code> is not allowed or Undefined Behavior.</p>\n<p>To achieve polymorphism you need something like this:</p>\n<pre><code>Enclosing e;\nDerived Enclosing::* d = &amp;Enclosing::d;\n\nBase* b = &amp;(e.*d);\nreturn b-&gt;foo();    // calls Derived::foo\n</code></pre>\n<hr>\n<blockquote>\n<h1>\u00a74 Standard conversions [conv]</h1>\n<p id=\"so_48580559_48582082_0\">Standard conversions are implicit conversions with built-in meaning.</p>\n<h2>\u00a74.11 Pointer to member conversions [conv.mem]</h2>\n<ol>\n<li><p id=\"so_48580559_48582082_1\">A null pointer constant (4.10) can be converted to a pointer to member type. [...]</p></li>\n<li><p id=\"so_48580559_48582082_2\">A prvalue of type \u201cpointer to member of B of type cv T\u201d, where B is a class type, can be converted to a prvalue of type \u201cpointer to member\n  of D of type cv T\u201d, where D is a derived class (Clause 10) of B. [...]</p></li>\n</ol>\n</blockquote>\n<p>So we see that for standard conversion (implicit conversions) your conversion is not allowed</p>\n<blockquote id=\"so_48580559_48582082_3\">\n<h2>\u00a75.2.9 Static cast [expr.static.cast]</h2>\n<ol start=\"12\">\n<li>A prvalue of type \u201cpointer to member of D of type cv1 T\u201d can be converted to a prvalue of type \u201cpointer to member of B\u201d of type cv2 T,\n  where B is a base class (Clause 10) of D, if a valid standard\n  conversion from \u201cpointer to member of B of type T\u201d to \u201cpointer to\n  member of D of type T\u201d exists (4.11), and cv2 is the same\n  cv-qualification as, or greater cv-qualification than, cv1. [...]</li>\n</ol>\n</blockquote>\n<p>For <code>static_cast</code> we see that basically only the standard conversion are allowed for pointer to member casts. Which is what you observed, the <code>static_cast</code> is a compiler error.</p>\n<blockquote>\n<h2>\u00a7 5.2.10 Reinterpret cast [expr.reinterpret.cast]</h2>\n<p id=\"so_48580559_48582082_4\">A prvalue of type \u201cpointer to member of X of type T1\u201d can be\n  explicitly converted to a prvalue of a different type \u201cpointer to\n  member of Y of type T2\u201d if T1 and T2 are both function types or both\n  object types. [...]. The result of this conversion is unspecified,\n  except in the following cases:</p>\n<p id=\"so_48580559_48582082_5\">(10.1) converting a prvalue of type \u201cpointer to member function\u201d to a\n  different pointer to member function type and back to its original\n  type yields the original pointer to member value.</p>\n<p id=\"so_48580559_48582082_6\">(10.2) converting a prvalue of type \u201cpointer to data member of X of\n  type T1\u201d to the type \u201cpointer to data member of Y of type T2\u201d (where\n  the alignment requirements of T2 are no stricter than those of T1) and\n  back to its original type yields the original pointer to member value.</p>\n</blockquote>\n<p>For <code>reinterpret_cast</code> we see the cast is allowed (as you've seen there is no compiler error. However the result is <strong>unspecified</strong>, except in the 2 mentioned cases which imply converting back to the original value. It doesn't apply to our situation, which means that your code with <code>reinterpret_cast</code> has Undefined Behavior.</p>\n<p>Furthermore</p>\n<blockquote>\n<h2>\u00a75.5 Pointer-to-member operators [expr.mptr.oper]</h2>\n<p id=\"so_48580559_48582082_7\">Abbreviating pm-expression .*cast-expression as E1.*E2, E1 is called\n  the object expression . If the dynamic type of E1 does not contain the\n  member to which E2 refers, the behavior is undefined.</p>\n</blockquote>\n<p>This is proof that <code>instance.*bp</code> is valid iff the object pointed by <code>bp</code> must exist in instance. That implies the type of <code>bp</code>.</p>\n</hr>", "LastEditorUserId": "2805305", "LastActivityDate": "2018-02-02T12:05:58.603", "Score": "3", "CreationDate": "2018-02-02T11:49:31.160", "ParentId": "48580559", "CommentCount": "0", "OwnerUserId": "2805305", "LastEditDate": "2018-02-02T12:05:58.603"}});