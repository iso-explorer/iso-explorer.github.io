post_cb({"bq_ids": {"n4140": {"so_5031524_5031773_1": {"length": 22, "quality": 0.8148148148148148, "section_id": 6700}}, "n3337": {"so_5031524_5031773_1": {"length": 22, "quality": 0.8148148148148148, "section_id": 6455}}, "n4659": {"so_5031524_5031773_1": {"length": 22, "quality": 0.8148148148148148, "section_id": 8174}}}, "5031699": {"Id": "5031699", "PostTypeId": "2", "Body": "<p><code>C</code> is nested class of <code>B</code>. Nested class cannot access private and protected members of enclosing class. That is why the code doesn't compile, and correctly gives compilation error.</p>\n<p>The C++ Standard (2003) says in $11.8/1 [class.access.nest],</p>\n<blockquote>\n<p id=\"so_5031524_5031699_0\"><strong>The members of a nested class have no\n  special access to members of an\n  enclosing class</strong>, nor to classes or\n  functions that have granted friendship\n  to an enclosing class; the usual\n  access rules (clause 11) shall be\n  obeyed. The members of an enclosing\n  class have no special access to\n  members of a nested class; the usual\n  access rules (clause 11) shall be\n  obeyed.</p>\n</blockquote>\n<p>Example from the Standard itself:</p>\n<pre><code>class E \n{\n    int x;\n    class B { };\n    class I \n    {\n        B b; // error: E::B is private\n        int y;\n        void f(E* p, int i)\n        {\n           p-&gt;x = i; // error: E::x is private\n        }\n   };\n   int g(I* p)\n   {\n       return p-&gt;y; // error: I::y is private\n   }\n};\n</code></pre>\n<p>So according to it, presence or absence of <code>D</code> should not effect anything. It should give compilation error, even if D is absent.</p>\n<p>Similar topic was created yesterday: <a href=\"https://stackoverflow.com/questions/5013717/are-inner-classes-in-c-automatically-friends\">Are inner classes in C++ automatically friends?</a></p>\n<hr>\n<p>By the way, it's a defect in C++03 which has been corrected in C++0x.</p>\n<p>This is allowed in C++0x. See this <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#45\" rel=\"nofollow noreferrer\">Access to nested classes</a></p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2011-02-17T16:35:30.967", "Score": "0", "CreationDate": "2011-02-17T16:30:24.480", "ParentId": "5031524", "CommentCount": "1", "LastEditDate": "2017-05-23T12:20:39.183", "OwnerUserId": "415784"}, "5031524": {"ViewCount": "1150", "Body": "<p>This code does not work (MS VS 2005),</p>\n<pre><code>b-&gt;funcA();\nB::iterator iter;\n</code></pre>\n<p>cant access protected members declared in class A.</p>\n<p>If I remove class D, everything compiles nicely.</p>\n<p>I wonder if it's just a bug or standard?</p>\n<pre><code>class A\n{\nprotected:\n    void funcA() {  }\n    class iterator {    };\n};\n\nclass D {\n    class B : public A {\n        class C {\n            B* b;\n        public:\n            void funcC() {\n                b-&gt;funcA();\n                B::iterator iter;\n            }\n        };\n    public:\n        void funcB() {\n            funcA();\n        }\n    };\n};\n</code></pre>\n<p>Thanks!</p>\n", "Title": "Nested C++ class outer members' access", "CreationDate": "2011-02-17T16:13:26.463", "LastActivityDate": "2011-03-24T18:17:27.590", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-03-24T18:17:27.590", "LastEditorUserId": "52626", "Id": "5031524", "Score": "5", "OwnerUserId": "621722", "Tags": "<c++>", "AnswerCount": "3"}, "5031773": {"Id": "5031773", "PostTypeId": "2", "Body": "<p>The current C++ standard (C++03) has the following restriction that would make your code ill-formed:</p>\n<blockquote>\n<p id=\"so_5031524_5031773_0\">The members of a nested class have no special access to members of an enclosing class, nor to classes or functions that have granted friendship to an enclosing class; the usual access rules shall be obeyed (C++03 11.8/1).</p>\n</blockquote>\n<p>However, this rule has been reversed in the forthcoming C++ standard (C++0x).  The paragraph now reads:</p>\n<blockquote>\n<p id=\"so_5031524_5031773_1\">A nested class is a member and as such has the same access rights as any other member. The members of an enclosing class have no special access to members of a nested class; the usual access rules shall be obeyed (C++0x Draft N3225 11.8/1).</p>\n</blockquote>\n<p>So, under the old interpretation, your code is incorrect but under the new interpretation it is correct.  This is basically a defect in the original C++ Standard; the defect was noted in 1998 and the correction was agreed to in 2001.  You can find details on that in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#45\" rel=\"nofollow\">CWG Defect 45</a>.</p>\n<hr>\n<p>Note that regardless which interpretation you want to use, I think there is still a bug in the compiler.  The following is the minimal repro, and generates the same error when using Visual C++ 2010:</p>\n<pre><code>class A {\nprotected:\n    void f() { }\n};\n\nstruct D {\n    struct B : A {\n        struct C {\n            void g() { \n                B().f(); \n            }\n        };\n    };\n};\n</code></pre>\n<p>However, if you remove <code>D</code> and put <code>B</code> in the global namespace, the compiler accepts the code.</p>\n</hr>", "LastActivityDate": "2011-02-17T16:38:09.720", "Score": "3", "CreationDate": "2011-02-17T16:38:09.720", "ParentId": "5031524", "CommentCount": "5", "OwnerUserId": "151292"}, "5031654": {"Id": "5031654", "PostTypeId": "2", "Body": "<p>The fact that C is nested in B doesn't give C special access to B's members. </p>\n<p>Solutions for funcA():\n(1) Make funcA() public.\nor (2) Call funcB() instead (delegating to funcA()).</p>\n<p>Solution for iterator: Make iterator public.</p>\n", "LastActivityDate": "2011-02-17T16:26:24.643", "Score": "0", "CreationDate": "2011-02-17T16:26:24.643", "ParentId": "5031524", "CommentCount": "6", "OwnerUserId": "44615"}});