post_cb({"bq_ids": {"n4140": {"so_18867889_18869108_0": {"length": 16, "quality": 1.0, "section_id": 190}, "so_18867889_18869108_1": {"length": 38, "quality": 0.95, "section_id": 6066}}, "n3337": {"so_18867889_18869108_0": {"length": 16, "quality": 1.0, "section_id": 184}, "so_18867889_18869108_1": {"length": 38, "quality": 0.95, "section_id": 5834}}, "n4659": {"so_18867889_18869108_0": {"length": 11, "quality": 0.6875, "section_id": 195}, "so_18867889_18869108_1": {"length": 38, "quality": 0.95, "section_id": 7562}}}, "18868085": {"Id": "18868085", "PostTypeId": "2", "Body": "<p>I'm going to assume that the behaviour you want is best described by the workaround</p>\n<pre><code>&amp;s = TempBase&lt;T&gt;::m_str;\n</code></pre>\n<p>(which you provide in the question) and not by the workaround</p>\n<pre><code>&amp;s = this-&gt;m_str;\n</code></pre>\n<p>which would work too in your example.</p>\n<p>Solution: &amp;(TempBase::m_str)</p>\n<p>Reason: TempBase::m_str is a qualified-id, (TempBase::m_str) is not.</p>\n<p>Code example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\ntemplate &lt;class T&gt; class TempBase\n{\nprotected:\n  string m_str;\n};\n\ntemplate &lt;class T&gt; class Temp: public TempBase&lt;T&gt;\n{\npublic:\n  void method()\n  {\n    string* ps3 = &amp;(TempBase&lt;T&gt;::m_str); //this is workaround, works fine\n    (*ps3) += \"ciao\";\n    cout &lt;&lt; *ps3 &lt;&lt; endl;\n  }\n};\n\nvoid f()\n{\n  Temp&lt;int&gt; t;\n  t.method();\n}\n\nint main( int argc, char* argv[] ) \n{\n    f();\n\n}\n</code></pre>\n<p>which you can try <a href=\"http://coliru.stacked-crooked.com/a/705a16eb95d13cb9\" rel=\"nofollow\">here</a></p>\n", "LastEditorUserId": "2528057", "LastActivityDate": "2013-09-18T09:48:05.387", "Score": "2", "CreationDate": "2013-09-18T09:09:02.380", "ParentId": "18867889", "CommentCount": "8", "OwnerUserId": "2528057", "LastEditDate": "2013-09-18T09:48:05.387"}, "18867889": {"ViewCount": "86", "Body": "<p>Just a sample code:</p>\n<pre><code>template &lt;class T&gt; class TempBase\n{\nprotected:\n  string m_str;\n};\n\ntemplate &lt;class T&gt; class Temp: public TempBase&lt;T&gt;\n{\npublic:\n  void method()\n  {\n    string\n        &amp;s = TempBase&lt;T&gt;::m_str //reference works fine\n        /*NOTE compile failed:\n        error: \u2018std::string TempBase&lt;int&gt;::m_str\u2019 is protected\n        error: within this context\n        error: cannot convert \u2018std::string TempBase&lt;int&gt;::* {aka std::basic_string&lt;char&gt; TempBase&lt;int&gt;::*}\u2019 to \u2018std::string* {aka std::basic_string&lt;char&gt;*}\u2019 in initialization\n        */\n      , *ps = &amp;TempBase&lt;T&gt;::m_str \n      , *ps2 = &amp;m_str //compile failed, obviously: \u2018m_str\u2019 was not declared in this scope\n      , *ps3 = &amp;s //this is workaround, works fine\n    ;\n  }\n};\n\nvoid f()\n{\n  Temp&lt;int&gt; t;\n  t.method();\n}\n</code></pre>\n<p>Goal: init pointer of type <code>std::string *</code> with ancestor member <code>TempBase&lt;T&gt;::m_str</code>.</p>\n<p>Problem: correct syntax unknown</p>\n<p>Comments: previous code contains 2 intentional compile errors:</p>\n<ol>\n<li>attempt to convert member pointer to data pointer</li>\n<li>templated ancestry members must be fully qualified</li>\n</ol>\n<p>and 1 workaround.</p>\n<p>Question: what is a correct syntax in this case to obtain pointer to ancestor data?</p>\n", "AcceptedAnswerId": "18869108", "Title": "How init pointer to data of templated ancestor", "CreationDate": "2013-09-18T08:58:55.977", "Id": "18867889", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-07-30T06:50:49.997", "Score": "0", "OwnerUserId": "1329132", "Tags": "<c++><templates>", "AnswerCount": "2"}, "18869108": {"Id": "18869108", "PostTypeId": "2", "Body": "<p>The reason why <code>&amp;m_str</code> doesn't work: [temp.dep]/3</p>\n<blockquote>\n<p id=\"so_18867889_18869108_0\">In the definition of a class or class template, if a base class depends on a <em>template-parameter</em>, the base class scope is not examined during unqualified name lookup [...]</p>\n</blockquote>\n<p>However, <code>this-&gt;m_str</code> denotes a dependent name (because <code>this</code> is dependent per [temp.dep.expr]/2). In this case, dependent name lookup is used, which finds the base class member.</p>\n<p>The problem is more obvious if we add a specialization of the template and a name outside the class scope:</p>\n<pre><code>string m_str;\n\ntemplate&lt;class T&gt; struct A { string m_str; };\ntemplate&lt;&gt; struct A&lt;int&gt; { /* no member */ };\n\ntemplate&lt;class T&gt; struct B : A\n{\n    void foo() { m_str = \"hello\"; }\n};\n\nB&lt;int&gt;().foo();    // clearly modifies the global `m_str`\nB&lt;double&gt;().foo(); // modifies what?\n</code></pre>\n<p>If the base class scope was searched, it would not be known before the instantiation (before the template argument is known) what <code>m_str</code> refers to. Also, this could easily lead to unexpected results.</p>\n<p>Therefore, base class scope is not searched (if the base class is dependent and if we're in a \"template context\").</p>\n<hr>\n<p>The reason why <code>&amp;s = TempBase&lt;T&gt;::m_str</code> works:</p>\n<p>The <em>id-expression</em> <code>TempBase&lt;T&gt;::m_str</code> is using a <em>qualified-id</em>, therefore the scope of <code>TempBase&lt;T&gt;</code> is searched and the member <code>m_str</code> is found.</p>\n<hr>\n<p>The reason why <code>&amp;TempBase&lt;T&gt;::m_str</code> doesn't work, but <code>&amp;(TempBase&lt;T&gt;::m_str)</code> does: [expr.unary.op]/3</p>\n<blockquote>\n<p id=\"so_18867889_18869108_1\">The result of the unary <code>&amp;</code> operator is a pointer to its operand. The operand shall be an lvalue or a <em>qualified-id</em>. If the operand is a <em>qualified-id</em> naming a non-static member <code>m</code> of some class <code>C</code> with type <code>T</code>, the result has type \u201cpointer to member of class <code>C</code> of type <code>T</code>\u201d and is a prvalue designating <code>C::m</code>. Otherwise, if the type of\n  the expression is <code>T</code>, the result has type \u201cpointer to <code>T</code>\u201d and is a prvalue that is the address of the designated object (1.7) or a pointer to the designated function.</p>\n</blockquote>\n<p>The paranthesized expression <code>(TempBase&lt;T&gt;::m_str)</code> is not a <em>qualified-id</em> and therefore <code>&amp;(TempBase&lt;T&gt;::m_str)</code> doesn't form a pointer-to-member, but an ordinary pointer to the object denoted by <code>(TempBase&lt;T&gt;::m_str)</code>.</p>\n</hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2015-07-30T06:50:49.997", "Score": "1", "CreationDate": "2013-09-18T09:54:36.977", "ParentId": "18867889", "CommentCount": "2", "OwnerUserId": "420683", "LastEditDate": "2015-07-30T06:50:49.997"}});