post_cb({"17242295": {"ParentId": "17241614", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>It is not easy to understand these concepts without getting formal. The primer probably does not want to confuse you and avoids introducing terms such as \"<em>lvalue</em>\", \"<em>rvalue</em>\", and \"<em>xvalue</em>\". Unfortunately, these are fundamental in order to understand how <code>decltype</code> works.</p>\n<p>First of all, the type of an evaluated expression is never a reference type, nor a top-level <code>const</code>-qualified type for non-class types (e.g. <code>int const</code> or <code>int&amp;</code>). If the type of an expression turns out to be <code>int&amp;</code> or <code>int const</code>, it gets immediately transformed into <code>int</code> prior to any further evaluation. </p>\n<p>This is specified in paragraphs 5/5 and 5/6 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_17241614_17242295_0\">5 If an expression initially has the type \u201creference to T\u201d (8.3.2, 8.5.3), the type is adjusted to <code>T</code> prior to\n  any further analysis. The expression designates the object or function denoted by the reference, and the\n  expression is an <em>lvalue</em> or an <em>xvalue</em>, depending on the expression.</p>\n<p id=\"so_17241614_17242295_1\">6 If a <em>prvalue</em> initially has the type \u201ccv T,\u201d where <code>T</code> is a cv-unqualified non-class, non-array type, the type of\n  the expression is adjusted to <code>T</code> prior to any further analysis.</p>\n</blockquote>\n<p>So much for expressions. What does <code>decltype</code> do? Well, the rules that determine the result of <code>decltype(e)</code> for a given expression <code>e</code> are specified in paragraph 7.1.6.2/4:</p>\n<blockquote>\n<p id=\"so_17241614_17242295_2\">The type denoted by <code>decltype(e)</code> is defined as follows:</p>\n<p id=\"so_17241614_17242295_3\">\u2014 if <code>e</code> is an unparenthesized <em>id-expression</em> or an unparenthesized class member access (5.2.5), <code>decltype(e)</code>\n  is the type of the entity named by <code>e</code>. If there is no such entity, or if <code>e</code> names a set of overloaded functions,\n  the program is ill-formed;</p>\n<p id=\"so_17241614_17242295_4\">\u2014 otherwise, if <code>e</code> is an <em>xvalue</em>, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where <code>T</code> is the type of <code>e</code>;</p>\n<p id=\"so_17241614_17242295_5\">\u2014 otherwise, if <code>e</code> is an <em>lvalue</em>, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of <code>e</code>;</p>\n<p id=\"so_17241614_17242295_6\">\u2014 otherwise, <code>decltype(e)</code> is the type of <code>e</code>.</p>\n<p id=\"so_17241614_17242295_7\">The operand of the <code>decltype</code> specifier is an unevaluated operand (Clause 5).</p>\n</blockquote>\n<p>This can indeed sound confusing. Let's try to analyze it part by part. First of all:</p>\n<blockquote>\n<p id=\"so_17241614_17242295_8\">\u2014 if <code>e</code> is an unparenthesized <em>id-expression</em> or an unparenthesized class member access (5.2.5), <code>decltype(e)</code>\n  is the type of the entity named by <code>e</code>. If there is no such entity, or if <code>e</code> names a set of overloaded functions,\n  the program is ill-formed;</p>\n</blockquote>\n<p>This is simple. If <code>e</code> is just the name of a variable and you do not put it within parentheses, then the result of <code>decltype</code> is the type of that variable. So</p>\n<pre><code>bool b; // decltype(b) = bool\nint x; // decltype(x) = int\nint&amp; y = x; // decltype(y) = int&amp;\nint const&amp; z = y; // decltype(z) = int const&amp;\nint const t = 42; // decltype(t) = int const\n</code></pre>\n<p>Notice, that the result of <code>decltype(e)</code> here is not necessarily the same as the type of the evaluated expression <code>e</code>. For instance, the evaluation of the expression <code>z</code> yields a value of type <code>int const</code>, not <code>int const&amp;</code> (because by paragraph 5/5 the <code>&amp;</code> gets stripped away, as we have seen previously).</p>\n<p>Let's see what happens when the expression is not just an identifier:</p>\n<blockquote>\n<p id=\"so_17241614_17242295_9\">\u2014 otherwise, if <code>e</code> is an <em>xvalue</em>, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where <code>T</code> is the type of <code>e</code>;</p>\n</blockquote>\n<p>This is getting complicated. What is an <em>xvalue</em>? Basically, it is one of the three categories an expression can belong to (<em>xvalue</em>, <em>lvalue</em>, or <em>prvalue</em>). An <em>xvalue</em> is normally obtained when invoking a function with a return type which is an <em>rvalue</em> reference type, or as the result of a static cast to an <em>rvalue</em> reference type. The typical example is a call to <code>std::move()</code>.</p>\n<p>To use the wording from the Standard:</p>\n<blockquote>\n<p id=\"so_17241614_17242295_10\">[ Note: An expression is an <em>xvalue</em> if it is:</p>\n<p id=\"so_17241614_17242295_11\">\u2014 the result of calling a function, whether implicitly or explicitly, whose return type is an <em>rvalue</em> reference\n  to object type,</p>\n<p id=\"so_17241614_17242295_12\">\u2014 a cast to an <em>rvalue</em> reference to object type,</p>\n<p id=\"so_17241614_17242295_13\">\u2014 a class member access expression designating a non-static data member of non-reference type in which\n  the object expression is an <em>xvalue</em>, or</p>\n<p id=\"so_17241614_17242295_14\">\u2014 a <code>.*</code> pointer-to-member expression in which the first operand is an <em>xvalue</em> and the second operand is\n  a pointer to data member.</p>\n<p id=\"so_17241614_17242295_15\">In general, the effect of this rule is that named <em>rvalue</em> references are treated as <em>lvalues</em> and unnamed <em>rvalue</em>\n  references to objects are treated as <em>xvalues</em>; <em>rvalue</em> references to functions are treated as <em>lvalues</em> whether\n  named or not. \u2014end note ]</p>\n</blockquote>\n<p>So for instance, the expressions <code>std::move(x)</code>, <code>static_cast&lt;int&amp;&amp;&gt;(x)</code>, and <code>std::move(p).first</code> (for an object <code>p</code> of type <code>pair</code>) are xvalues. When you apply <code>decltype</code> to an <em>xvalue</em> expression, <code>decltype</code> appends <code>&amp;&amp;</code> to the type of the expression:</p>\n<pre><code>int x; // decltype(std::move(x)) = int&amp;&amp;\n       // decltype(static_cast&lt;int&amp;&amp;&gt;(x)) = int&amp;&amp;\n</code></pre>\n<p>Let's continue:</p>\n<blockquote>\n<p id=\"so_17241614_17242295_16\">\u2014 otherwise, if <code>e</code> is an <em>lvalue</em>, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of <code>e</code>;</p>\n</blockquote>\n<p>What is an <em>lvalue</em>? Well, informally, <em>lvalue</em> expression are expressions which denote objects that can be repeatably referenced in your program - for instance variables with a name and/or objects you can take the address of. </p>\n<p>For an expression <code>e</code> of type <code>T</code> that is an <em>lvalue</em> expression, <code>decltype(e)</code> yields <code>T&amp;</code>. So for instance:</p>\n<pre><code>int x; // decltype(x) = int (as we have seen)\n       // decltype((x)) = int&amp; - here the expression is parenthesized, so the\n       // first bullet does not apply and decltype appends &amp; to the type of\n       // the expression (x), which is int\n</code></pre>\n<p>A function call for a function whose return type is <code>T&amp;</code> is also an <em>lvalue</em> expression, so:</p>\n<pre><code>int&amp; foo() { return x; } //  decltype(foo()) = int&amp; \n</code></pre>\n<p>Finally:</p>\n<blockquote>\n<p id=\"so_17241614_17242295_17\">\u2014 otherwise, <code>decltype(e)</code> is the type of <code>e</code>.</p>\n</blockquote>\n<p>If the expression is not an <em>xvalue</em> nor an <em>lvalue</em> (in other words, if it is a <em>prvalue</em>), the result of <code>decltype(e)</code> is simply the type of <code>e</code>. Unnamed temporaries and literals are <em>prvalues</em>. So for instance:</p>\n<pre><code>int foo() { return x; } // Function calls for functions that do not return\n                        // a reference type are prvalue expressions\n\n// decltype(foo()) = int\n// decltype(42) = int\n</code></pre>\n<hr>\n<p>Let's apply the above to the examples from your question. Given these declarations:</p>\n<pre><code>int i = 3, *ptr = &amp;i, &amp;ref = i;\ndecltype(ref + 0) j;\ndecltype(*ptr) k;\ndecltype(a = b) l;\n</code></pre>\n<p>The type of <code>j</code> will be <code>int</code>, because <code>operator +</code> returns a <em>prvalue</em> of type <code>int</code>. The type of <code>k</code> will be <code>int&amp;</code>, because the unary <code>operator *</code> yields an <em>lvalue</em> (see paragraph 5.3.1/1). The type of <code>l</code> is also <code>int&amp;</code>, because the result of <code>operator =</code> is an <em>lvalue</em> (see paragraph 5.17/1).</p>\n<p>Concerning this part of your question:</p>\n<blockquote>\n<p id=\"so_17241614_17242295_18\">But going by the second rule, as the expression yields the type of an object that can stand on the left hand side of an assignment (in this case int), shouldn't the decltype yield a ref to int(int&amp;) type?</p>\n</blockquote>\n<p>You probably misinterpreted that passage from the book. Not <em>all</em> objects of type <code>int</code> can be on the left side of an assignment. For instance, the assignment below is illegal:</p>\n<pre><code>int foo() { return 42; }\n\nfoo() = 24; // ERROR! foo() is a prvalue expression, cannot be on the left\n            // side of an assignment\n</code></pre>\n<p>Whether or not an expression can appear on the left side of an assignment (notice, that we are talking about the <em>built-in</em> assignment operator for fundamental data types here) depends on the <em>value category</em> of that expression (<em>lvalue</em>, <em>xvalue</em>, or <em>prvalue</em>), and the value category of an expression is independent from its type.</p>\n</hr>", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-06-23T16:42:39.987", "Id": "17242295", "Score": "35", "CreationDate": "2013-06-21T18:46:36.733", "LastActivityDate": "2013-06-23T16:42:39.987"}, "17241614": {"CommentCount": "0", "AcceptedAnswerId": "17242295", "PostTypeId": "1", "LastEditorUserId": "3980929", "CreationDate": "2013-06-21T18:04:05.700", "LastActivityDate": "2017-08-31T11:35:34.060", "LastEditDate": "2017-08-31T11:35:34.060", "ViewCount": "3156", "FavoriteCount": "12", "Title": "What expressions yield a reference type when decltype is applied to them?", "Id": "17241614", "Score": "27", "Body": "<p>I was reading C++ Primer and couldn't quite understand when an expression yields an object type, and when it yields a reference type to the object.</p>\n<p>I quote from the book: </p>\n<blockquote id=\"so_17241614_17241614_0\">\n<ol>\n<li>When we apply decltype to an expression that is not a variable, we get the type that  &gt; that expression yields.</li>\n<li>Generally speaking, decltype returns a reference type for expressions that yield \n  objects that can stand on the left-hand side of the assignment.</li>\n</ol>\n</blockquote>\n<p>Considering the code below:</p>\n<pre><code>int i = 3, *ptr = &amp;i, &amp;ref = i;\ndecltype(ref + 0) j;\n</code></pre>\n<p>In the above code, the expression \"ref + 0\" results in an inherent operation of addition of  value of the object that ref refers to, i and 0. Hence, going by the first rule the expression yields an int type.\nBut going by the second rule, as the expression yields the type of an object that can stand on the left hand side of an assignment (in this case int), shouldn't the decltype yield a ref to int(int&amp;) type? </p>\n<p>The book also says, for the following code</p>\n<pre><code>decltype(*ptr) k;\n</code></pre>\n<p>k has type int&amp; and not int, the type which the expression results in.</p>\n<p>It also says that for an assignment expression like in code below</p>\n<pre><code>decltype(a = b) l;\n</code></pre>\n<p>l would have the type of reference to object on the left hand side of the assignment operation.</p>\n<p>How would we know which expressions yield the object type and which yield the reference to the object type?</p>\n", "Tags": "<c++><c++11><decltype>", "OwnerUserId": "1290303", "AnswerCount": "2"}, "17241894": {"ParentId": "17241614", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>For expressions, as in your examples decltype will provide a reference type if the argument is lvalue.</p>\n<p>7.1.6.2p4:</p>\n<pre><code>The type denoted by decltype(e) is defined as follows:\n  \u2014 if e is an unparenthesized id-expression or an unparenthesized class member access (5.2.5), decltype(e)     is the type of the entity named by e. If there is no such entity, or if e names a set of overloaded functions,     the program is ill-formed;\n  \u2014 otherwise, if e is an xvalue, decltype(e) is T&amp;&amp;, where T is the type of e;\n  \u2014 otherwise, if e is an lvalue, decltype(e) is T&amp;, where T is the type of e;\n  \u2014 otherwise, decltype(e) is the type of e.\nThe operand of the decltype specifier is an unevaluated operand (Clause 5).\n[ Example:\nconst int&amp;&amp; foo();\nint i;\nstruct A { double x; };\nconst A* a = new A();\ndecltype(foo()) x1 = i; // type is const int&amp;&amp;\ndecltype(i) x2; // type is int\ndecltype(a-&gt;x) x3; // type is double\ndecltype((a-&gt;x)) x4 = x3; // type is const double&amp;\n\u2014end example ]\n</code></pre>\n", "OwnerUserId": "2422194", "LastEditorUserId": "2422194", "LastEditDate": "2013-06-21T18:33:37.597", "Id": "17241894", "Score": "3", "CreationDate": "2013-06-21T18:21:55.500", "LastActivityDate": "2013-06-21T18:33:37.597"}, "bq_ids": {"n4140": {"so_17241614_17242295_11": {"section_id": 5940, "quality": 1.0, "length": 13}, "so_17241614_17242295_2": {"section_id": 5440, "quality": 0.8333333333333334, "length": 5}, "so_17241614_17242295_14": {"section_id": 5940, "quality": 1.0, "length": 10}, "so_17241614_17242295_5": {"section_id": 5440, "quality": 1.0, "length": 5}, "so_17241614_17242295_7": {"section_id": 5440, "quality": 0.8571428571428571, "length": 6}, "so_17241614_17242295_8": {"section_id": 5440, "quality": 0.9473684210526315, "length": 18}, "so_17241614_17242295_12": {"section_id": 5940, "quality": 1.0, "length": 5}, "so_17241614_17242295_15": {"section_id": 5940, "quality": 0.9130434782608695, "length": 21}, "so_17241614_17242295_3": {"section_id": 5440, "quality": 0.9473684210526315, "length": 18}, "so_17241614_17242295_16": {"section_id": 5440, "quality": 1.0, "length": 5}, "so_17241614_17242295_0": {"section_id": 5938, "quality": 0.8695652173913043, "length": 20}, "so_17241614_17242295_13": {"section_id": 5940, "quality": 1.0, "length": 13}, "so_17241614_17242295_1": {"section_id": 5939, "quality": 1.0, "length": 14}, "so_17241614_17242295_9": {"section_id": 5440, "quality": 1.0, "length": 5}, "so_17241614_17242295_4": {"section_id": 5440, "quality": 1.0, "length": 5}}, "n3337": {"so_17241614_17242295_11": {"section_id": 5711, "quality": 1.0, "length": 13}, "so_17241614_17242295_2": {"section_id": 5235, "quality": 0.8333333333333334, "length": 5}, "so_17241614_17242295_14": {"section_id": 5711, "quality": 1.0, "length": 10}, "so_17241614_17242295_5": {"section_id": 5235, "quality": 1.0, "length": 5}, "so_17241614_17242295_7": {"section_id": 5235, "quality": 0.8571428571428571, "length": 6}, "so_17241614_17242295_8": {"section_id": 5235, "quality": 0.9473684210526315, "length": 18}, "so_17241614_17242295_12": {"section_id": 5711, "quality": 1.0, "length": 5}, "so_17241614_17242295_15": {"section_id": 5711, "quality": 0.9130434782608695, "length": 21}, "so_17241614_17242295_3": {"section_id": 5235, "quality": 0.9473684210526315, "length": 18}, "so_17241614_17242295_16": {"section_id": 5235, "quality": 1.0, "length": 5}, "so_17241614_17242295_0": {"section_id": 5710, "quality": 0.8695652173913043, "length": 20}, "so_17241614_17242295_13": {"section_id": 5711, "quality": 1.0, "length": 13}, "so_17241614_17242295_9": {"section_id": 5235, "quality": 1.0, "length": 5}, "so_17241614_17242295_4": {"section_id": 5235, "quality": 1.0, "length": 5}}, "n4659": {"so_17241614_17242295_11": {"section_id": 7424, "quality": 1.0, "length": 13}, "so_17241614_17242295_2": {"section_id": 6867, "quality": 0.8333333333333334, "length": 5}, "so_17241614_17242295_14": {"section_id": 7424, "quality": 1.0, "length": 10}, "so_17241614_17242295_0": {"section_id": 7422, "quality": 0.8695652173913043, "length": 20}, "so_17241614_17242295_5": {"section_id": 6867, "quality": 1.0, "length": 5}, "so_17241614_17242295_7": {"section_id": 6867, "quality": 0.8571428571428571, "length": 6}, "so_17241614_17242295_8": {"section_id": 6867, "quality": 0.9473684210526315, "length": 18}, "so_17241614_17242295_12": {"section_id": 7424, "quality": 1.0, "length": 5}, "so_17241614_17242295_15": {"section_id": 7424, "quality": 0.9130434782608695, "length": 21}, "so_17241614_17242295_3": {"section_id": 6867, "quality": 0.9473684210526315, "length": 18}, "so_17241614_17242295_13": {"section_id": 7424, "quality": 1.0, "length": 13}, "so_17241614_17242295_16": {"section_id": 6867, "quality": 1.0, "length": 5}, "so_17241614_17242295_1": {"section_id": 7423, "quality": 1.0, "length": 14}, "so_17241614_17242295_9": {"section_id": 6867, "quality": 1.0, "length": 5}, "so_17241614_17242295_4": {"section_id": 6867, "quality": 1.0, "length": 5}}}});