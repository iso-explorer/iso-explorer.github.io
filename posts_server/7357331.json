post_cb({"7357331": {"CommentCount": "0", "ViewCount": "907", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-09-09T05:01:35.480", "LastActivityDate": "2011-09-09T05:44:49.073", "Title": "Is the at() const accessor for map standard in C++11?", "AcceptedAnswerId": "7357352", "LastEditDate": "2017-05-23T11:51:15.873", "Id": "7357331", "Score": "8", "Body": "<p>I was trying to figure out how to return a value from a map in a const method and I stumbled on the at() method for map in gcc 4.6.</p>\n<p>When I looked this up I realized it was non-standard:</p>\n<p><a href=\"https://stackoverflow.com/questions/262853/c-map-access-discards-qualifiers-const\">C++ map access discards qualifiers (const)</a></p>\n<p>But it sure is a whole lot less verbose than the find() approach. I was wondering if the C++11 has rectified this - is at() for map part of the new standard?</p>\n", "Tags": "<c++><stl><map><c++11>", "OwnerUserId": "722869", "AnswerCount": "1"}, "7357352": {"ParentId": "7357331", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Yes.  <code>std::map</code> has an <code>at</code> member function in C++11 with the following specification (23.4.4.3/9):</p>\n<blockquote>\n<pre><code>T&amp;       at(const key_type&amp; x);\nconst T&amp; at(const key_type&amp; x) const;\n</code></pre>\n<p id=\"so_7357331_7357352_0\"><em>Returns:</em> A reference to the mapped_type corresponding to <code>x</code> in <code>*this</code>.</p>\n<p id=\"so_7357331_7357352_1\"><em>Throws:</em> An exception object of type <code>out_of_range</code> if no such element is present.</p>\n<p id=\"so_7357331_7357352_2\"><em>Complexity:</em> logarithmic.</p>\n</blockquote>\n<p>Note however that this member function has been added specifically to <code>std::map</code>.  It is not required by the more general <em>associative container</em> requirement.  If you are writing generic code that requires some associative container type, you can't use this new <code>at</code>.  Instead, you should continue to use <code>find</code>, which is part of the <em>associative container</em> concept, or write your own non-member helper:</p>\n<pre><code>template &lt;typename AssociativeContainer&gt;\ntypename AssociativeContainer::mapped_type&amp;\nget_mapped_value(AssociativeContainer&amp;                          container,\n                 typename AssociativeContainer::key_type const&amp; key)\n{\n    typename AssociativeContainer::iterator it(container.find(key));\n    return it != container.end() ? it-&gt;second : throw std::out_of_range(\"key\");\n}\n\ntemplate &lt;typename AssociativeContainer&gt;\ntypename AssociativeContainer::mapped_type const&amp;\nget_mapped_value(AssociativeContainer const&amp;                    container,\n                 typename AssociativeContainer::key_type const&amp; key)\n{\n    typename AssociativeContainer::const_iterator it(container.find(key));\n    return it != container.end() ? it-&gt;second : throw std::out_of_range(\"key\");\n}\n</code></pre>\n<p>Or, if you have an implementation that supports rvalue references and <code>decltype</code>, you don't need two overloads:</p>\n<pre><code>template &lt;typename AssociativeContainer, typename Key&gt;\nauto get_mapped_value(AssociativeContainer&amp;&amp; container, Key const&amp; key)\n    -&gt; decltype(std::declval&lt;AssociativeContainer&gt;().begin()-&gt;second)&amp;\n{\n    auto const it(container.find(key));\n    return it != container.end() ? it-&gt;second : throw std::out_of_range(\"key\");\n}\n</code></pre>\n<p>(Or something close to that; one fun thing about C++11 is that no two compilers have the same bugs and all seem to accept slightly different subsets of valid--and invalid--C++11 code.)</p>\n", "OwnerUserId": "151292", "LastEditorUserId": "151292", "LastEditDate": "2011-09-09T05:44:49.073", "Id": "7357352", "Score": "17", "CreationDate": "2011-09-09T05:05:16.063", "LastActivityDate": "2011-09-09T05:44:49.073"}, "bq_ids": {"n4140": {"so_7357331_7357352_1": {"section_id": 1016, "quality": 0.875, "length": 7}}, "n3337": {"so_7357331_7357352_1": {"section_id": 1001, "quality": 0.875, "length": 7}}, "n4659": {"so_7357331_7357352_1": {"section_id": 1073, "quality": 0.875, "length": 7}}}});