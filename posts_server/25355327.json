post_cb({"bq_ids": {"n4140": {"so_25355327_25355423_0": {"length": 41, "quality": 0.9534883720930233, "section_id": 5965}}, "n3337": {"so_25355327_25355423_0": {"length": 38, "quality": 0.8837209302325582, "section_id": 5734}}, "n4659": {"so_25355327_25355423_0": {"length": 37, "quality": 0.8604651162790697, "section_id": 7456}}}, "25355404": {"Id": "25355404", "PostTypeId": "2", "Body": "<p>Being invokable with signature <code>int()</code> does not mean it can be converted to a <code>int(*)()</code>.  Anything with an overloaded <code>int operator()()</code> is invokable that way.</p>\n<p>Lambdas create pretty bog standard classes with such an overload, then wrap them in some syntactic sugar.  (not true, but true enough)<sup>1</sup></p>\n<p>Stateless lambdas (ones that capture nothing) come with a bonus <code>operator int(*)()</code> overload (or <code>operator Signature*</code> in general), but that is just a bonus, not core to a lambda's being.</p>\n<p>A function pointer is, in practice, the address that execution jumps to when you invoke the function.  There is no room for a data pointer as well (to store the state of your captured variables).  In theory you could allocate space for the data alongside or within the execution code, but many systems block marking writable pages as executable as well for security reasons, which makes that system impractical.  There have been people who have proposed that kind of extension.</p>\n<hr>\n<p><sup>1</sup> As with many things in the C++ standard, things are specified in terms of behavior not implementation.  Most features of lambdas can be duplicated by implementing bog standard classes \"auto-written\" for you, but even then the compiler doesn't have to do it.  Some lambda implementations (like stack frame capture based <code>[&amp;]</code> lambdas) cannot be implemented within the C++ language.</p>\n</hr>", "LastEditorUserId": "1774667", "LastActivityDate": "2014-09-02T17:58:45.803", "Score": "2", "CreationDate": "2014-08-18T01:55:08.380", "ParentId": "25355327", "CommentCount": "0", "LastEditDate": "2014-09-02T17:58:45.803", "OwnerUserId": "1774667"}, "25355423": {"Id": "25355423", "PostTypeId": "2", "Body": "<p>The C++ Standard, section \u00a7 5.1.2 / 6 , defines how a lambda can convert to a (possibly template) function pointer.</p>\n<p>Particulary :</p>\n<blockquote>\n<p id=\"so_25355327_25355423_0\">The closure type for a non-generic lambda-expression <strong>with no\n  lambda-capture has a public non-virtual non-explicit const conversion\n  function to pointer to function</strong> with C\n  ++ language linkage (7.5) having the same parameter and return types as the closure type\u2019s function call operator. The value returned by\n  this conversion function shall be the address of a function that, when\n  invoked, has the same effect as invoking the closure type\u2019s function\n  call operator</p>\n</blockquote>\n<p>Since your lambda has a capture, it can't convert to a function pointer.</p>\n<hr>\n<p><strong>Note:</strong></p>\n<ul>\n<li>Beware that captures can be implicit or default with a lamdba.</li>\n</ul>\n<p>i.e. the following is not valid either:</p>\n<pre><code>int i = 0;\nfunc =\n    [&amp;]()-&gt;int {\n        std::cout &lt;&lt; \"func(): i= \" &lt;&lt; i &lt;&lt; std::endl;\n        return 0;\n    }\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/a99bc9866e44b67f\" rel=\"nofollow\">Live demo</a></strong></p>\n</hr>", "LastEditorUserId": "3510483", "LastActivityDate": "2014-08-26T17:07:58.383", "Score": "9", "CreationDate": "2014-08-18T01:57:17.753", "ParentId": "25355327", "CommentCount": "0", "LastEditDate": "2014-08-26T17:07:58.383", "OwnerUserId": "3510483"}, "25355490": {"Id": "25355490", "PostTypeId": "2", "Body": "<p>You cannot convert a lambda to a function pointer if it carries state. If you think twice, you will see that an ordinary function pointer cannot carry state from its environment. </p>\n<p>So your second lambda is not convertible, but the first it is, because the first lambda amounts to a function pointer.</p>\n", "LastEditorUserId": "429879", "LastActivityDate": "2014-08-21T08:54:21.553", "Score": "2", "CreationDate": "2014-08-18T02:09:56.097", "ParentId": "25355327", "CommentCount": "0", "LastEditDate": "2014-08-21T08:54:21.553", "OwnerUserId": "429879"}, "25355327": {"ViewCount": "475", "Body": "<p>I've encountered a situation that challenges my nascent understanding of C++ lambdas, and I've distilled it down to the following:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid test()\n{\n    int (*func)();\n\n    func =\n        []()-&gt;int {\n            std::cerr &lt;&lt; \"func()\" &lt;&lt; std::endl;\n            return 0;\n        };\n\n    int i = 0;\n    func =\n        [i]()-&gt;int {\n            std::cerr &lt;&lt; \"func(): i= \" &lt;&lt; i &lt;&lt; std::endl;\n            return 0;\n        };\n}\n</code></pre>\n<p>In the first case, I'm assigning a very simple lambda to a function pointer, and it seems to work as I would expect. What I'm trying to do in the second case is to provide the lambda with access to the value of <code>i</code>. My understanding of <code>[i]()-&gt;int {</code><em>code</em><code>}</code> is that it defines a nameless function that takes no arguments, returns an <code>int</code> and, through the magic of the C++11 unicorns, knows the current value of <code>i</code>. I would expect that this lambda should be callable as <code>int(*)()</code>.</p>\n<pre><code>test.cpp: In function \u2018void test()\u2019:\ntest.cpp:14:7: error: cannot convert \u2018test()::__lambda1\u2019 to \u2018int (*)()\u2019 in assignment\n  func =\n       ^\n</code></pre>\n<p>It would seem that gcc 4.8.1 and 4.8.2 disagree with my assessment (4.4.1 refused to even discuss the matter).</p>\n<p>This seems to suggest that the type of that second lambda is not assignment-compatible with the function pointer. I don't understand why that would be the case, given that that expression should be callable as \"<code>int(*)()</code>\".</p>\n<p>Where has my understanding (or the unicorns) failed me?</p>\n", "AcceptedAnswerId": "25355404", "Title": "Why does this C++11 lambda not behave as I expect?", "CreationDate": "2014-08-18T01:43:06.990", "Id": "25355327", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-09-02T17:58:45.803", "Score": "8", "OwnerUserId": "1440841", "Tags": "<c++><c++11><lambda><closures>", "AnswerCount": "3"}});