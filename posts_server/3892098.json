post_cb({"3892098": {"ViewCount": "1042", "Body": "<p>I had a hard time debugging a crash on production. Just wanted to confirm with folks here about the semantics. We have a class like ...</p>\n<pre><code>class Test {\npublic:\n  Test()\n  {\n    // members initialized ...\n    m_str = m_str;\n  }\n  ~Test() {}\nprivate:\n  // other members ...\n  std::string m_str;\n};\n</code></pre>\n<p>Someone changed the initialization to use ctor initialization-lists which is reasonably correct within our code semantics. The order of initialization and their initial value is correct among other things. So the class looks like ...</p>\n<pre><code>class Test {\npublic:\n  Test() \n    : /*other inits ,,, */ m_str(m_str)\n  {\n  }\n  ~Test() {}\nprivate:\n  // other members ...\n  std::string m_str;\n};\n</code></pre>\n<p>But the code suddenly started crashing! I isolated the long list of inits to this piece of code <code>m_str(m_str)</code>. I confirmed this via <a href=\"http://codepad.org/VF0YT1Lz\" rel=\"nofollow\">link text</a>.</p>\n<p>Does it have to crash? What does the standard say about this? (Is it undefined behavior?)</p>\n", "AcceptedAnswerId": "3892209", "Title": "Ctor Initializer: self initialization causes crash?", "CreationDate": "2010-10-08T15:37:55.173", "Id": "3892098", "CommentCount": "9", "LastEditDate": "2010-10-30T09:10:46.883", "PostTypeId": "1", "LastEditorDisplayName": "Roger Pate", "LastActivityDate": "2010-10-30T09:10:46.883", "Score": "2", "OwnerUserId": "79298", "Tags": "<c++><constructor><ctor-initializer>", "AnswerCount": "5"}, "3892136": {"Id": "3892136", "PostTypeId": "2", "Body": "<p><code>m_str</code> is <em>constructed</em> in the initialization list. Therefore, at the time you are assigning it to itself, it is not fully constructed. Hence, undefined behavior.</p>\n<p>(What is that self-assignment supposed to do anyway?)</p>\n", "LastActivityDate": "2010-10-08T15:42:03.150", "CommentCount": "4", "CreationDate": "2010-10-08T15:42:03.150", "ParentId": "3892098", "Score": "2", "OwnerUserId": "148146"}, "bq_ids": {"n4140": {"so_3892098_3892154_0": {"length": 40, "quality": 0.7407407407407407, "section_id": 5768}}, "n3337": {"so_3892098_3892154_0": {"length": 40, "quality": 0.7407407407407407, "section_id": 5541}}, "n4659": {"so_3892098_3892154_0": {"length": 40, "quality": 0.7407407407407407, "section_id": 7225}}}, "3892206": {"Id": "3892206", "PostTypeId": "2", "Body": "<p>This is the same difference as between </p>\n<pre><code>std::string str;\nstr = str;\n</code></pre>\n<p>and </p>\n<pre><code>std::string str(str);\n</code></pre>\n<p>The former works (although it's nonsense), the latter doesn't, since it tries to copy-construct an object from a not-yet-constructed object.</p>\n<p>Of course, the way to go would be </p>\n<pre><code>Test() : m_str() {}\n</code></pre>\n", "LastEditorUserId": "140719", "LastActivityDate": "2010-10-08T15:57:28.867", "Score": "0", "CreationDate": "2010-10-08T15:50:24.743", "ParentId": "3892098", "CommentCount": "0", "OwnerUserId": "140719", "LastEditDate": "2010-10-08T15:57:28.867"}, "3892235": {"Id": "3892235", "PostTypeId": "2", "Body": "<p>The original \"initialization\" by assignment is completely superfluous.</p>\n<p>It didn't do any harm, other than wasting processor cycles, because at the time of the assignment the m_str member had already been initialized, by default.</p>\n<p>In the second code snippet the default initialization is overridden to use the as-yet-uninitialized member to initialize itself. That's Undefined Behavior. And it's completely unnecessary: just remove that (and don't re-introduce the original time-waster, just, remove).</p>\n<p>By turning up the warning level of your compiler you may be able to get warnings about this and similar trivially ungood code.</p>\n<p>Unfortunately the problem you're having is not this technical one, it's much more fundamental. It's like a worker in a car factory poses a question about the square wheels they're putting on the new car brand. Then the problem isn't that the square wheels don't work, it's that a whole lot of engineers and managers have been involved in the decision to use the fancy looking square wheels and none of them objected  --  some of them undoubtedly didn't understand that square wheels don't work, but most of them, I suspect, were simply afraid to say what that they were 100% sure of. So it's most probably a management problem. I'm sorry, but I don't know a fix for that...</p>\n", "LastActivityDate": "2010-10-08T15:52:55.130", "CommentCount": "2", "CreationDate": "2010-10-08T15:52:55.130", "ParentId": "3892098", "Score": "2", "OwnerUserId": "464581"}, "3892154": {"Id": "3892154", "PostTypeId": "2", "Body": "<p>Undefined behavior doesn't have to lead to a crash -- it can do just about anything, from continuing to work as if there was no problem at all, to crashing immediately, to doing something really strange that causes seemingly unrelated problems later. The canonical claim is that it makes \"demons fly out of your nose\" (aka, \"causes nasal demons\"). At one time the inventor of the phase had a (pretty cool) web site telling about the nuclear war that started from somebody causing undefined behavior in the \"DeathStation 9000\".</p>\n<p>Edit: The exact wording from the standard is (\u00a7:1.3.12):</p>\n<p>1.3.12 undefined behavior [defns.undefined]</p>\n<blockquote>\n<p id=\"so_3892098_3892154_0\">behavior, such as might arise upon use of an erroneous program construct or erroneous data, for which this\n  International Standard imposes no requirements. Undefined behavior may also be expected when this\n  International Standard omits the description of any explicit definition of behavior. [Note: permissible undefined\n  behavior ranges from ignoring the situation completely with unpredictable results, to behaving during\n  translation or program execution in a documented manner characteristic of the environment (with or without\n  the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a\n  diagnostic message).</p>\n</blockquote>\n", "LastEditorUserId": "179910", "LastActivityDate": "2010-10-08T16:00:09.937", "Score": "1", "CreationDate": "2010-10-08T15:44:15.557", "ParentId": "3892098", "CommentCount": "0", "OwnerUserId": "179910", "LastEditDate": "2010-10-08T16:00:09.937"}, "3892209": {"Id": "3892209", "PostTypeId": "2", "Body": "<p>The first constructor is equivalent to </p>\n<pre><code>  Test()\n  : m_str()\n  {\n    // members initialized ...\n    m_str = m_str;\n  }\n</code></pre>\n<p>that is, by the time you get to the assignment within the constructor, <code>m_str</code> <em>has already been implicitly initialized</em> to an empty string. So the assignment to self, although completely meaningless and superfluous, causes no problems (since <code>std::string::operator=()</code>, as any well written assignment operator should, checks for self assignment and does nothing in this case).</p>\n<p>However, in the second constructor, you are trying to initialize <code>m_str</code> with itself in the initializer list - at which point <em>it is not yet initialized</em>. So the result is undefined behaviour.</p>\n<p><strong>Update:</strong> For primitive types, this is still undefined behaviour (resulting in a field with garbage value), but it does not crash (usually - see the comments below for exceptions) because primitive types by definition have no constructors, destructors and contain no pointers to other objects.</p>\n<p>Same is true for any type that does not contain pointer members with ownership semantics. <code>std::string</code> is hereby demonstrated to be not one of these :-)</p>\n", "LastEditorUserId": "265143", "LastActivityDate": "2010-10-10T16:15:46.893", "Score": "13", "CreationDate": "2010-10-08T15:50:40.947", "ParentId": "3892098", "CommentCount": "5", "OwnerUserId": "265143", "LastEditDate": "2010-10-10T16:15:46.893"}});