post_cb({"26874140": {"CommentCount": "3", "ViewCount": "161", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-11-11T20:40:55.903", "LastActivityDate": "2014-11-12T07:57:25.920", "Title": "check for whether a type instance can be streamed", "FavoriteCount": "1", "LastEditDate": "2017-05-23T12:12:43.280", "Id": "26874140", "Score": "3", "Body": "<p>I've puzzled over this meta-function for a long time. It seems to work, but I suspect it to contain UB, when it checks for size of a possibly undefined reference type? Is there a problem with this meta-function?</p>\n<pre><code>template &lt;class S, class C, typename = void&gt;\nstruct is_streamable : ::std::false_type { };\n\ntemplate &lt;class S, class C&gt;\nstruct is_streamable&lt;S,\n  C,\n  decltype(void(sizeof(decltype(::std::declval&lt;S&amp;&gt;() &lt;&lt;\n    ::std::declval&lt;C const&amp;&gt;()))))\n&gt; : ::std::true_type\n{\n};\n</code></pre>\n<p>EDIT: The motivation for my question (and worries) was this <a href=\"https://stackoverflow.com/questions/10711952/how-to-detect-existence-of-a-class-using-sfinae\">question</a>. Why did he not use a similar trick (checking size of a reference type)?</p>\n", "Tags": "<c++><c++11><iostream><template-meta-programming><sfinae>", "OwnerUserId": "1095108", "AnswerCount": "1"}, "26874374": {"ParentId": "26874140", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_26874140_26874374_0\">when it checks for size of a possibly undefined reference type?</p>\n</blockquote>\n<p>That never induces UB. It would just result in a deduction failure (according to [temp.deduct]/8), causing the <em>primary</em> template to be instantiated. [expr.sizeof]:</p>\n<blockquote>\n<p id=\"so_26874140_26874374_1\">When applied to a reference or a reference type, the result is the\n  size of the referenced type.</p>\n</blockquote>\n<p>\n<blockquote>\n<p id=\"so_26874140_26874374_2\">The <code>sizeof</code> operator shall not be applied to an expression that has\n  [\u2026] incomplete type [\u2026].</p>\n</blockquote>\n<p>But a yet incomplete <code>ostream</code> is regarded \"streamable\" for a <code>string</code> if the global <code>operator&lt;&lt;</code> is overloaded. <br>\nTo fix that,  define the partial specialization as</br></p>\n<pre><code>template &lt;class S, class C&gt;\nstruct is_streamable&lt;S, C,\n    decltype(void( std::declval&lt;S&amp;&gt;() &lt;&lt; std::declval&lt;C const&amp;&gt;() ))\n    &gt; : ::std::true_type\n{};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/e07ddaddd443b73f\" rel=\"nofollow\"><strong>Demo</strong></a>.</p>\n</p>", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2014-11-11T21:14:38.720", "Id": "26874374", "Score": "2", "CreationDate": "2014-11-11T20:54:20.727", "LastActivityDate": "2014-11-11T21:14:38.720"}, "bq_ids": {"n4140": {"so_26874140_26874374_2": {"section_id": 6076, "quality": 0.8571428571428571, "length": 6}, "so_26874140_26874374_0": {"section_id": 763, "quality": 0.5714285714285714, "length": 4}, "so_26874140_26874374_1": {"section_id": 6077, "quality": 1.0, "length": 9}}, "n3337": {"so_26874140_26874374_2": {"section_id": 5844, "quality": 0.8571428571428571, "length": 6}, "so_26874140_26874374_0": {"section_id": 750, "quality": 0.5714285714285714, "length": 4}, "so_26874140_26874374_1": {"section_id": 5845, "quality": 1.0, "length": 9}}, "n4659": {"so_26874140_26874374_2": {"section_id": 7572, "quality": 0.8571428571428571, "length": 6}, "so_26874140_26874374_0": {"section_id": 823, "quality": 0.5714285714285714, "length": 4}, "so_26874140_26874374_1": {"section_id": 7573, "quality": 1.0, "length": 9}}}});