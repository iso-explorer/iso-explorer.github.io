post_cb({"bq_ids": {"n4140": {"so_27189541_27189594_2": {"length": 18, "quality": 0.8181818181818182, "section_id": 7164}}, "n3337": {"so_27189541_27189594_2": {"length": 18, "quality": 0.8181818181818182, "section_id": 6908}}, "n4659": {"so_27189541_27189594_2": {"length": 18, "quality": 0.8181818181818182, "section_id": 8672}}}, "27189594": {"Id": "27189594", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_27189541_27189594_0\">Can they really be altered at run time?</p>\n</blockquote>\n<p>Yes. Unless you declare them as <code>const</code>, of course.</p>\n<blockquote>\n<p id=\"so_27189541_27189594_1\">I was under the impression that a static and/or global variable\n  remained immutable throughout an application, I thought this was the\n  point of their existence.</p>\n</blockquote>\n<p>No, you're describing constants. Variables with so-called <em>static storage duration</em> have, how the name implies, a different lifetime. [basic.stc.static]:</p>\n<blockquote>\n<p id=\"so_27189541_27189594_2\">All variables which do not have dynamic storage duration, do not have\n  thread storage duration, and are not local have <em>static storage\n  duration</em>. <strong>The storage for these entities shall last for the duration\n  of the program</strong> (3.6.2, 3.6.3).</p>\n</blockquote>\n<p>Just think about <code>cout</code>, a global stream object that you modify by inserting data into it.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-11-28T13:25:35.460", "Score": "5", "CreationDate": "2014-11-28T13:20:08.450", "ParentId": "27189541", "CommentCount": "1", "OwnerUserId": "3647361", "LastEditDate": "2014-11-28T13:25:35.460"}, "27189541": {"ViewCount": "163", "Body": "<p>As I was reviewing memory organisation and storage in C/C++ I came upon this:</p>\n<p>\"Initialized data segment, usually called simply the Data Segment. A data segment is a portion of virtual address space of a program, which contains the global variables and static variables that are initialized by the programmer.</p>\n<p>Note that, data segment is not read-only, since the values of the variables can be altered at run time.\"</p>\n<p>(found in <a href=\"http://www.geeksforgeeks.org/memory-layout-of-c-program/\" rel=\"nofollow\">http://www.geeksforgeeks.org/memory-layout-of-c-program/</a> )</p>\n<p>I was under the impression that a static and/or global variable remained immutable throughout an application, I thought this was the point of their existence. Can they really be altered at run time?</p>\n", "AcceptedAnswerId": "27189594", "Title": "Static and global variable storage clarification", "CreationDate": "2014-11-28T13:17:47.657", "Id": "27189541", "CommentCount": "4", "LastEditDate": "2016-03-18T10:52:03.143", "PostTypeId": "1", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-18T10:52:03.143", "Score": "4", "OwnerUserId": "4143110", "Tags": "<c++><c><memory><global-variables>", "AnswerCount": "2"}, "27189811": {"Id": "27189811", "PostTypeId": "2", "Body": "<p>You'll generally find better documentation on a site that more people take an interest in updating, for example - <a href=\"http://en.wikipedia.org/wiki/Data_segment\" rel=\"nofollow\">from Wikipedia</a>:</p>\n<blockquote>\n<p id=\"so_27189541_27189811_0\">In computing, a data segment (often denoted <code>.data</code>) is a portion of an object file or the corresponding virtual address space of a program that contains initialized static variables, that is, global variables and static local variables. The size of this segment is determined by the size of the values in the program's source code, and does not change at run time.</p>\n<p id=\"so_27189541_27189811_1\">The <strong><em>data segment is read-write</em></strong>, since the values of variables can be altered at run time. This is <strong><em>in contrast to the read-only data segment</em></strong> (<code>rodata</code> segment or <code>.rodata</code>), which contains static constants rather than variables; it also contrasts to the <code>code</code> segment, also known as the <code>text</code> segment, which is read-only on many architectures. Uninitialized data, both variables and constants, is instead in the <code>BSS</code> segment.</p>\n</blockquote>\n<p>So, it's just a matter of definition:</p>\n<ul>\n<li><p>the data segment holds the read-write variables</p></li>\n<li><p>the \"read only\" data segment holds the constants</p></li>\n</ul>\n<p>On some old/hockey systems they might not both with a read only data segment and just lump it all together - the main thing with the read only segment is that it means a few more bugs are reported more dramatically, rather than letting the program corrupt that data and potentially spew bogus results.  That's probably why <code>.data</code> is general and sometime later - as OS/compiler writers had time and motivation to care - <code>.rodata</code> ended up being contrasted with it, but <code>.data</code> wasn't renamed to e.g. <code>.rwdata</code>.  These names - <code>.data</code>, <code>.rodata</code>, <code>test</code>, <code>BSS</code> etc. were and are often used in assembly languages to denote where variables should be located.</p>\n<p>As far as things go... global variables and <code>static</code> variables are similar in that the [possibly virtual] memory address for them - and indeed their total size - can typically be calculated (at least relative to some supporting CPU \"segment\" register that's left at a convenient value most of the time) at compile time.  That's in contrast to automatic (stack) and dynamic (heap) variables, where the memory's transient.  Most systems only have control over write-access to memory on a per-page basis (e.g. 4k, 8k), so it's far less practical to keep granting and removing write access to put transient <code>const</code> automatic and heap-based variables into memory that seems read-only to the process, and it's impractical when you consider the race conditions in a threaded application.  That's why this whole distinction between read-write and read-only memory's normally discussed in the context of global and static variables.</p>\n", "LastEditorUserId": "410767", "LastActivityDate": "2014-11-28T13:40:13.953", "Score": "2", "CreationDate": "2014-11-28T13:31:41.823", "ParentId": "27189541", "CommentCount": "0", "OwnerUserId": "410767", "LastEditDate": "2014-11-28T13:40:13.953"}});