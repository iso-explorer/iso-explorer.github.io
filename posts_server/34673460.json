post_cb({"bq_ids": {"n4140": {"so_34673460_34673980_2": {"length": 20, "quality": 0.9523809523809523, "section_id": 380}, "so_34673460_34673460_0": {"length": 11, "quality": 1.0, "section_id": 3343}, "so_34673460_34673460_2": {"length": 21, "quality": 1.0, "section_id": 5997}, "so_34673460_34673460_1": {"length": 9, "quality": 1.0, "section_id": 3913}, "so_34673460_34673980_0": {"length": 17, "quality": 0.6071428571428571, "section_id": 3913}}, "n3337": {"so_34673460_34673980_2": {"length": 20, "quality": 0.9523809523809523, "section_id": 371}, "so_34673460_34673460_0": {"length": 11, "quality": 1.0, "section_id": 3213}, "so_34673460_34673980_0": {"length": 17, "quality": 0.6071428571428571, "section_id": 3773}, "so_34673460_34673460_1": {"length": 9, "quality": 1.0, "section_id": 3773}, "so_34673460_34673460_2": {"length": 21, "quality": 1.0, "section_id": 5765}}, "n4659": {"so_34673460_34673980_2": {"length": 20, "quality": 0.9523809523809523, "section_id": 395}, "so_34673460_34673460_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 4109}, "so_34673460_34673980_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 4799}, "so_34673460_34673460_1": {"length": 6, "quality": 0.6666666666666666, "section_id": 4799}, "so_34673460_34673980_1": {"length": 21, "quality": 0.84, "section_id": 4800}, "so_34673460_34673460_2": {"length": 21, "quality": 1.0, "section_id": 7498}}}, "34673980": {"Id": "34673980", "PostTypeId": "2", "Body": "<p>Function return values are considered temporaries, and the construction of the return value is sequenced before the destruction of locals.</p>\n<p>Unfortunately, this is underspecified in the standard. There is an <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1885\" rel=\"noreferrer\">open defect</a> which describes this and offers some wording to fix the issue</p>\n<blockquote>\n<p id=\"so_34673460_34673980_0\">[...] A return statement with an operand of type void shall be used only in a function whose return type is cv void. A return statement with any other operand shall be used only in a function whose return type is not cv void; the return statement initializes the object or reference to be returned by copy-initialization (8.5 [dcl.init]) from the operand. [...]</p>\n<p id=\"so_34673460_34673980_1\">The copy-initialization of the returned entity is sequenced before the destruction of temporaries at the end of the full-expression established by the operand of the return statement, which, in turn, is sequenced before the destruction of local variables (6.6 [stmt.jump]) of the block enclosing the return statement.</p>\n</blockquote>\n<p>Since function return values are temporaries, they aren't covered by the <code>destructors are invoked for all automatic objects</code> quote at the start of your post. However, <code>[class.temporary]/3</code> says:</p>\n<blockquote>\n<p id=\"so_34673460_34673980_2\">[...] Temporary objects are destroyed as the last step in evaluating the full-expression that (lexically) contains the point where they were created. <strong>This is true even if that evaluation ends in throwing an exception</strong>. [...]</p>\n</blockquote>\n<p>So I think you could consider this a bug in GCC and Clang.</p>\n<p>Don't throw from destructors ;)</p>\n", "LastEditorUserId": "496161", "LastActivityDate": "2016-01-08T10:16:51.850", "Score": "45", "CreationDate": "2016-01-08T09:50:42.547", "ParentId": "34673460", "CommentCount": "3", "OwnerUserId": "496161", "LastEditDate": "2016-01-08T10:16:51.850"}, "34673684": {"Id": "34673684", "PostTypeId": "2", "Body": "<p>This is a bug, and for once, MSVC actually gets it right: it prints \"~A\".</p>\n", "LastActivityDate": "2016-01-08T09:36:59.823", "CommentCount": "6", "CreationDate": "2016-01-08T09:36:59.823", "ParentId": "34673460", "Score": "7", "OwnerUserId": "8922"}, "34673955": {"Id": "34673955", "PostTypeId": "2", "Body": "<p>I modified your code and I think that now from the output we can see that A is not destructed. </p>\n<pre><code>#include&lt;iostream&gt;\n\nusing namespace std;\n\nstruct A {\n    ~A() { cout &lt;&lt; \"~A\\n\"; }\n    A() { cout &lt;&lt; \"A()\"; }\n};\n\nstruct B {\n    ~B() noexcept( false ) { cout &lt;&lt; \"~B\\n\"; throw(0); }\n    B() { cout &lt;&lt; \"B()\"; }\n};\n\nA foo() {\n    B b;\n    return;\n}\n\nint main() {\n    try { foo(); }\n    catch (...) {}\n}\n</code></pre>\n<p>And the output is:</p>\n<blockquote>\n<p id=\"so_34673460_34673955_0\">B()A()~B</p>\n</blockquote>\n<p>So yes it could be a bug.</p>\n", "LastEditorUserId": "4789375", "LastActivityDate": "2016-01-08T13:03:42.587", "Score": "7", "CreationDate": "2016-01-08T09:49:37.597", "ParentId": "34673460", "CommentCount": "0", "OwnerUserId": "4879854", "LastEditDate": "2016-01-08T13:03:42.587"}, "34673460": {"ViewCount": "1875", "Body": "<p>In [except.ctor] the standard (<a href=\"https://stackoverflow.com/questions/81656/where-do-i-find-the-current-c-or-c-standard-documents\">N4140</a>) guarantees that:</p>\n<blockquote>\n<p id=\"so_34673460_34673460_0\">...destructors are invoked for\n  all automatic objects constructed since the try block was\n  entered...</p>\n</blockquote>\n<p>However in the following example the empty <a href=\"http://coliru.stacked-crooked.com/a/1dd0994a6102b75e\" rel=\"nofollow noreferrer\">output</a> proves that the return value of function <code>foo</code> is not destructed, although it has been constructed. Compiled using g++ (5.2.1) and clang++ (3.6.2-1) and with options <code>-O0 -fno-elide-constructors -std=c++14</code>. </p>\n<pre><code>struct A { ~A() { cout &lt;&lt; \"~A\\n\"; } };\n\nstruct B { ~B() noexcept(false) { throw 0; } };\n\nA foo() {\n  B b;\n  return {};\n}\n\nint main() {\n  try { foo(); }\n  catch (...) { }\n}\n</code></pre>\n<p>Is this a bug both in g++ and clang++, or are function return values not\nconsidered automatic objects, or is it a loop hole in the C++ language?</p>\n<p>In none of [stmt.return], [expr.call] or [dcl.fct] I have been able to find\na clear statement whether a function return value is considered an automatic\nobject. The closest hints I found are 6.3.3 p2:</p>\n<blockquote>\n<p id=\"so_34673460_34673460_1\">...A return statement can\n  involve the construction and copy or move of a temporary object...</p>\n</blockquote>\n<p>and 5.2.2 p10:</p>\n<blockquote>\n<p id=\"so_34673460_34673460_2\">A function call is an lvalue if the result type is an lvalue\n  reference type or an rvalue reference to function type, an xvalue if the\n  result type is an rvalue reference to object type, and a prvalue otherwise.</p>\n</blockquote>\n", "AcceptedAnswerId": "34673980", "Title": "Are function return values automatic objects and thus guaranteed to be destructed?", "CreationDate": "2016-01-08T09:25:59.017", "Id": "34673460", "CommentCount": "0", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:50:38.397", "LastEditorUserId": "-1", "LastActivityDate": "2016-01-09T11:13:41.783", "Score": "56", "OwnerUserId": "1306466", "Tags": "<c++><exception-handling><return><return-value><language-lawyer>", "AnswerCount": "3"}});