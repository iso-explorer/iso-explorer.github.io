post_cb({"bq_ids": {"n4140": {"so_44306607_44310738_2": {"length": 27, "quality": 0.9642857142857143, "section_id": 3296}, "so_44306607_44310738_5": {"length": 14, "quality": 1.0, "section_id": 599}, "so_44306607_44310738_4": {"length": 21, "quality": 0.875, "section_id": 3325}, "so_44306607_44310738_3": {"length": 8, "quality": 1.0, "section_id": 594}, "so_44306607_44310738_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 3296}}, "n3337": {"so_44306607_44310738_2": {"length": 27, "quality": 0.9642857142857143, "section_id": 3166}, "so_44306607_44310738_5": {"length": 14, "quality": 1.0, "section_id": 589}, "so_44306607_44310738_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 3166}, "so_44306607_44310738_3": {"length": 8, "quality": 1.0, "section_id": 584}, "so_44306607_44310738_4": {"length": 21, "quality": 0.875, "section_id": 3195}}, "n4659": {"so_44306607_44310738_2": {"length": 27, "quality": 0.9642857142857143, "section_id": 4058}, "so_44306607_44310738_5": {"length": 14, "quality": 1.0, "section_id": 622}, "so_44306607_44310738_1": {"length": 7, "quality": 1.0, "section_id": 4058}, "so_44306607_44310738_3": {"length": 8, "quality": 1.0, "section_id": 617}, "so_44306607_44310738_4": {"length": 21, "quality": 0.875, "section_id": 4091}}}, "44310738": {"Id": "44310738", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_44306607_44310738_0\">Where is the hole in my understanding?</p>\n</blockquote>\n<p>tltldr; Nobody understands initialization.</p>\n<p>tldr; List-initialization prefers <code>std::initializer_list&lt;T&gt;</code> constructors, but it doesn't fall-back to non-list-initialization. It only falls back to considering constructors. Non-list-initialization will consider conversion functions, but the fallback does not. </p>\n<hr/>\n<p>All of the initialization rules come from <a href=\"http://eel.is/c++draft/dcl.init#17\" rel=\"nofollow noreferrer\">[dcl.init]</a>. So let's just go from first principles. </p>\n<p><a href=\"http://eel.is/c++draft/dcl.init#17.1\" rel=\"nofollow noreferrer\">[dcl.init]/17.1</a>:</p>\n<blockquote id=\"so_44306607_44310738_1\">\n<ul>\n<li>If the initializer is a (non-parenthesized) <em>braced-init-list</em> or is = <em>braced-init-list</em>, the object or reference is list-initialized.</li>\n</ul>\n</blockquote>\n<p>The first first bullet point covers any list-initialization. This jumps <code>X x{y}</code>  and <code>X x = {y}</code> over to <a href=\"http://eel.is/c++draft/dcl.init.list\" rel=\"nofollow noreferrer\">[dcl.init.list]</a>. We'll get back to that. The other case is easier. Let's look at <code>X x = y</code>. We call straight down into:</p>\n<p><a href=\"http://eel.is/c++draft/dcl.init#17.6.3\" rel=\"nofollow noreferrer\">[dcl.init]/17.6.3</a>:</p>\n<blockquote id=\"so_44306607_44310738_2\">\n<ul>\n<li>Otherwise (i.e., for the remaining copy-initialization cases), user-defined conversion sequences that can convert from the source type to the destination type or (when a conversion function is used) to a derived class thereof are enumerated as described in <a href=\"http://eel.is/c++draft/over.match.copy\" rel=\"nofollow noreferrer\">[over.match.copy]</a>, and the best one is chosen through overload resolution.</li>\n</ul>\n</blockquote>\n<p>The candidates in [over.match.copy] are:</p>\n<blockquote>\n<ul>\n<li>The converting constructors of <code>T</code> [in our case, <code>X</code>] are candidate functions.</li>\n<li>When the type of the initializer expression is a class type \u201c<em>cv</em> <code>S</code>\u201d, the non-explicit conversion functions of <code>S</code> and its base classes are considered.  </li>\n</ul>\n<p id=\"so_44306607_44310738_3\">In both cases, the argument list has one argument, which is the initializer expression.</p>\n</blockquote>\n<p>This gives us candidates:</p>\n<pre><code>X(Y const &amp;);     // from the 1st bullet\nY::operator X();  // from the 2nd bullet\n</code></pre>\n<p>The 2nd is equivalent to having had a <code>X(Y&amp; )</code>, since the conversion function is not cv-qualified. This makes for a less cv-qualified reference than the converting constructor, so it's preferred. Note, there is no invocation of <code>X(X&amp;&amp; )</code> here in C++17. </p>\n<hr/>\n<p>Now let's go back to the list-initialization cases. The first relevant bullet point is <a href=\"http://eel.is/c++draft/dcl.init.list#3.6\" rel=\"nofollow noreferrer\">[dcl.init.list]/3.6</a>:</p>\n<blockquote>\n<p id=\"so_44306607_44310738_4\">Otherwise, if <code>T</code> is a class type, constructors are considered. The applicable constructors are enumerated and the best one is chosen through overload resolution ([over.match], [over.match.list]). If a narrowing conversion (see below) is required to convert any of the arguments, the program is ill-formed.</p>\n</blockquote>\n<p>which in both cases takes us to <a href=\"http://eel.is/c++draft/over.match.list\" rel=\"nofollow noreferrer\">[over.match.list]</a> which defines two-phase overload resolution:</p>\n<blockquote>\n<ul>\n<li>Initially, the candidate functions are the initializer-list constructors ([dcl.init.list]) of the class T and the argument list consists of the initializer list as a single argument.</li>\n<li>If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class T and the argument list consists of the elements of the initializer list.</li>\n</ul>\n<p id=\"so_44306607_44310738_5\">If the initializer list has no elements and T has a default constructor, the first phase is omitted. In copy-list-initialization, if an explicit constructor is chosen, the initialization is ill-formed.</p>\n</blockquote>\n<p>The candidates are the constructors of <code>X</code>. The only difference between <code>X x{y}</code> and <code>X x = {y}</code> are that if the latter chooses an <code>explicit</code> constructor, the initialization is ill-formed. We don't even have any <code>explicit</code> constructors, so the two are equivalent. Hence, we enumerate our constructors:</p>\n<ul>\n<li><code>X(Y const&amp; )</code></li>\n<li><code>X(X&amp;&amp; )</code> by way of <code>Y::operator X()</code></li>\n</ul>\n<p>The former is a direct reference binding that is an Exact Match. The latter requires a user-defined conversion. Hence, we prefer <code>X(Y const&amp; )</code> in this case. </p>\n<hr/>\n<p>Note that gcc 7.1 gets this wrong in C++1z mode, so I've filed <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=80943\" rel=\"nofollow noreferrer\">bug 80943</a>.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-06-01T20:00:41.313", "Score": "7", "CreationDate": "2017-06-01T14:48:32.027", "ParentId": "44306607", "CommentCount": "4", "OwnerUserId": "2069064", "LastEditDate": "2017-06-01T20:00:41.313"}, "44306607": {"ViewCount": "414", "Body": "<p>Given the following:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nclass X;\n\nclass Y\n{\npublic:\n  Y() { printf(\"  1\\n\"); }             // 1\n  // operator X(); // 2\n};\n\nclass X\n{\npublic:\n  X(int) {}\n  X(const Y&amp; rhs) { printf(\"  3\\n\"); } // 3\n  X(Y&amp;&amp; rhs) { printf(\"  4\\n\"); }      // 4\n};\n\n// Y::operator X() { printf(\"   operator X() - 2\\n\"); return X{2}; }\n\nint main()\n{\n  Y y{};     // Calls (1)\n\n  printf(\"j\\n\");\n  X j{y};    // Calls (3)\n  printf(\"k\\n\");\n  X k = {y}; // Calls (3)\n  printf(\"m\\n\");\n  X m = y;   // Calls (3)\n  printf(\"n\\n\");\n  X n(y);    // Calls (3)\n\n  return 0;\n}\n</code></pre>\n<p>So far, so good. Now, if I enable the conversion operator <code>Y::operator X()</code>, I get this;-</p>\n<pre><code>  X m = y; // Calls (2)\n</code></pre>\n<p>My understanding is that this happens because (2) is 'less const' than (3) and\ntherefore preferred. The call to the <code>X</code> constructor is elided</p>\n<p>My question is, why doesn't the definition <code>X k = {y}</code> change its behavior in the same way? I know that <code>= {}</code> is technically 'list copy initialization', but in the absence of a constructor taking an <code>initializer_list</code> type, doesn't this revert to 'copy initialization' behavior? ie - the same as for <code>X m = y</code></p>\n<p>Where is the hole in my understanding?</p>\n", "AcceptedAnswerId": "44310738", "Title": "Copy initialization of the form '= {}'", "CreationDate": "2017-06-01T11:43:43.427", "Id": "44306607", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-06-02T13:43:51.787", "LastEditorUserId": "951890", "LastActivityDate": "2017-06-02T13:43:51.787", "Score": "14", "OwnerUserId": "8097224", "Tags": "<c++><c++11><c++14><list-initialization><copy-initialization>", "AnswerCount": "2"}, "44316224": {"Id": "44316224", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_44306607_44316224_0\">My question is, why doesn't the definition X k = {y} change its behavior in the same way? </p>\n</blockquote>\n<p>Because, conceptually speaking, a <code>= { .. }</code> is an <em>initialization</em> for something that automatically chooses the \"best\" way to initialize the target <em>from the braces</em>, while <code>= value</code> is also an initialization, but conceptually also a conversion of the <em>value</em> to a different value. The conversion is completely symmetric: If will look into the source value to see whether it provides a way to create the target, and will look into the target to see whether it provides a way to accept the source. </p>\n<p>If your target type is <code>struct A { int x; }</code> then using <code>= { 10 }</code> will not try to convert the <code>10</code> to <code>A</code> (which will fail). But it will seek the best (in their eyes) form of initialization, which here amounts to aggregate initialization. However if <code>A</code> is not an aggregate (add constructors), then it will call the constructors, where in your case it finds the <code>Y</code> accepted readily without a conversion needed. There is no such symmetry between the source and the target like there is with the conversion when using the <code>= value</code> form.</p>\n<p>Your suspicion about the \"less const\" of the conversion function is exactly right. If you make the conversion function a const member, then it will become ambiguous. </p>\n", "LastActivityDate": "2017-06-01T20:06:09.150", "CommentCount": "0", "CreationDate": "2017-06-01T20:06:09.150", "ParentId": "44306607", "Score": "0", "OwnerUserId": "34509"}});