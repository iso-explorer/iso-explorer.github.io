post_cb({"28184888": {"CommentCount": "2", "CreationDate": "2015-01-28T04:55:21.073", "PostTypeId": "1", "AcceptedAnswerId": "28184997", "LastEditorUserId": "16287", "LastActivityDate": "2015-01-28T22:13:47.383", "LastEditDate": "2015-01-28T04:59:28.283", "ViewCount": "290", "FavoriteCount": "1", "Title": "How implicit conversion works for non-type template parameters?", "Id": "28184888", "Score": "11", "Body": "<p>I guess (certain) implicit conversions apply when passing non-type template parameters. For example, there should be a conversion from <code>int</code> to <code>std::size_t</code> for expressions like <code>std::array&lt;int, 7&gt;</code>. However, consider the following code:</p>\n<pre><code>template &lt;bool&gt;\nvoid f() {\n    std::cout &lt;&lt; \"false\\n\";\n}\n\ntemplate &lt;&gt;\nvoid f&lt;true&gt;() {\n    std::cout &lt;&lt; \"true\\n\";\n}\n\nint main() {\n    f&lt;1&gt;();\n    f&lt;4&gt;();\n    f&lt;0&gt;();\n}\n</code></pre>\n<p>I expect <code>int</code> to be implicitly converted to <code>bool</code> here. But the behaviors are different on VC, GCC, and clang.</p>\n<p>On VC, <code>true</code>, <code>false</code>, and <code>false</code> are printed, which is really weird to me.</p>\n<p>On GCC, <code>true</code>, <code>true</code>, and <code>false</code> are printed, which is what I expect. </p>\n<p>While on clang, the code does not compile at all due to the statement <code>f&lt;4&gt;();</code>.</p>\n<blockquote>\n<p id=\"so_28184888_28184888_0\">candidate template ignored: invalid explicitly-specified argument for 1st template parameter</p>\n</blockquote>\n<p>So, what does the standard say about this? What is the implicit conversion rule for non-type template parameters?</p>\n", "Tags": "<c++><templates><type-conversion><implicit-conversion><template-specialization>", "OwnerUserId": "1348273", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28184888_28184888_0": {"section_id": 355, "quality": 0.5555555555555556, "length": 5}, "so_28184888_28184997_1": {"section_id": 6186, "quality": 0.8666666666666667, "length": 65}, "so_28184888_28184997_0": {"section_id": 91, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_28184888_28184997_1": {"section_id": 5947, "quality": 0.64, "length": 48}, "so_28184888_28184888_0": {"section_id": 345, "quality": 0.5555555555555556, "length": 5}, "so_28184888_28184997_0": {"section_id": 86, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_28184888_28184888_0": {"section_id": 365, "quality": 0.5555555555555556, "length": 5}, "so_28184888_28184997_1": {"section_id": 7689, "quality": 0.5733333333333334, "length": 43}}}, "28184997": {"ParentId": "28184888", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>From the standard (\u00a714.3.2/5):</p>\n<blockquote>\n<p id=\"so_28184888_28184997_0\">The following conversions are performed on each expression used as a non-type <em>template-argument</em>. If a\n  non-type <em>template-argument</em> cannot be converted to the type of the corresponding <em>template-parameter</em> then\n  the program is ill-formed.</p>\n<ul>\n<li>For a non-type <em>template-parameter</em> of integral or enumeration type, conversions permitted in a converted constant expression (5.19) are applied.</li>\n</ul>\n</blockquote>\n<p>In \u00a75.19, we learn (emphasis mine):</p>\n<blockquote>\n<p id=\"so_28184888_28184997_1\">An <em>integral constant expression</em> is an expression of integral or unscoped enumeration type, implicitly converted\n  to a prvalue, where the converted expression is a core constant expression. ... A <em>converted constant expression</em> of\n  type <code>T</code> is an expression, implicitly converted to a prvalue of type T, where the converted expression is a core\n  constant expression and the implicit conversion sequence contains only user-defined conversions, lvalue-to-rvalue\n  conversions (4.1), integral promotions (4.5), and integral conversions (4.7) <strong>other than narrowing conversions\n  (8.5.4)</strong>. <em>[ Note:</em> such expressions may be used in new expressions (5.3.4), as case expressions (6.4.2),\n  as enumerator initializers if the underlying type is fixed (7.2), as array bounds (8.3.4), and as integral or\n  enumeration non-type template arguments (14.3). <em>\u2014end note ]</em></p>\n</blockquote>\n<p>So narrowing conversions (like converting <code>4</code> to <code>bool</code>) are explicitly disallowed for integral constant expressions, which are required in this case as a non-type template argument. That makes the call <code>f&lt;4&gt;()</code> ill-formed. </p>\n<p>I believe Clang is correct in issuing an error, and GCC and VC are both nonconforming for not issuing any diagnostic.</p>\n<p>[Update] This is <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57891\" rel=\"nofollow\">GCC Bug #57891</a>, looks like it's currently unassigned. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-01-28T22:13:47.383", "Id": "28184997", "Score": "13", "CreationDate": "2015-01-28T05:05:25.393", "LastActivityDate": "2015-01-28T22:13:47.383"}});