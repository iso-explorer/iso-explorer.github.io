post_cb({"26947349": {"ParentId": "26947324", "LastEditDate": "2014-11-15T18:47:09.227", "CommentCount": "14", "CreationDate": "2014-11-15T15:22:22.643", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "PostTypeId": "2", "Id": "26947349", "Score": "3", "Body": "<p>What about <a href=\"http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution/param\" rel=\"nofollow\"><code>param</code></a>?</p>\n<pre><code>dist.param( decltype(dist)::param_type(otherMin, otherMax) );\n</code></pre>\n<p>C++11 standard (and following ones), [rand.req.dist]/9:</p>\n<blockquote>\n<p id=\"so_26947324_26947349_0\">For each of the constructors of <code>D</code> taking arguments corresponding to\n  parameters of the distribution, <strong><code>P</code> shall have a corresponding\n  constructor subject to the same requirements and taking arguments\n  identical in number, type, and default values.</strong></p>\n</blockquote>\n", "LastActivityDate": "2014-11-15T18:47:09.227"}, "26948927": {"ParentId": "26947324", "LastEditDate": "2014-11-15T18:05:01.303", "CommentCount": "0", "CreationDate": "2014-11-15T17:58:18.507", "OwnerUserId": "4156577", "LastEditorUserId": "4156577", "PostTypeId": "2", "Id": "26948927", "Score": "1", "Body": "<p><code>&lt;random&gt;</code> has some decent parts, and the generators it contains are at least servicable for many purposes. However, the library and its interfaces are very far from mature. Hence you need to build your own header/library to supply the missing parts, or roll out big guns like boost or the code from Numeric Recipes.</p>\n<p>One quick and easy way of obtaining uniform integer derivates is to multiply uniform floats in the range [0,1) with the modulus and truncating. That spreads the bias all over the range and it is good enough for many off-the-cuff uses. </p>\n<p>By contrast, the standard method of taking the remainder of an integer derivate modulo the range collects the bias at the beginning of the range. E.g. the famous <code>rand() % modulus</code>. </p>\n<p>Case in point: if your modulus happens to be 2/3 of the derivate's natural modulus (e.g. 0xAAAAAAAAu for 2^32) then all results in the first half the result range are exactly twice as likely as those in the upper half of the result range. <strong>Not</strong> recommended for quality code.</p>\n<p>To get an unbiassed integer derivate, use the rejection method. Here is one example that uses a full-size random integers as a basis. You can template it on word size and generator, stuff it in your 'fix-the-std' header and be done for all time:</p>\n<pre><code>uint64_t random_uint64 ();\n\nuint64_t random_uint64 (uint64_t modulus)\n{\n   if (modulus)\n   {\n      for ( ; ; )\n      {\n         uint64_t raw_bits = random_uint64();\n         uint64_t result = raw_bits % modulus;\n         uint64_t check = uint64_t(raw_bits - result + modulus);\n\n         if (check &gt;= raw_bits || check == 0)\n         {\n            return result;\n         }\n      }\n   }\n\n   return 0;\n}\n</code></pre>\n<p><code>std::uniform_int_distribution&lt;&gt;</code> does something very similar internally... but there the logic is well protected against industrial esponiage by the usual hundreds of lines of fluff, and the awkward interface ensures that people cannot simply use that functionality just because they feel like it.</p>\n<p>Just for completeness, here's a simple and fast generator of excellent, proven quality (Sebastiano Vigna's <a href=\"http://arxiv.org/pdf/1404.0390.pdf\" rel=\"nofollow\">xorshift64*</a>) that makes a nice all-round generator when the extremely long period of a big gun like <a href=\"http://xorshift.di.unimi.it/\" rel=\"nofollow\">xorshift1024*</a> is not needed:</p>\n<pre><code>uint64_t random_seed64 = 42;\n\nuint64_t random_uint64 ()\n{\n   uint64_t x = random_seed64;\n\n   x ^= x &gt;&gt; 12;  x ^= x &lt;&lt; 25;  x ^= x &gt;&gt; 27;\n\n   random_seed64 = x;\n\n   return x * 2685821657736338717ull;\n}\n</code></pre>\n<p>The generators included in the standard all have their peculiarities and problems, you have to know their strengths and weaknesses in order to make a good choice. If you're not aiming for a PhD in random number generation and computational statistics then you might be better off using tried and trusted code that is of proven quality.</p>\n", "LastActivityDate": "2014-11-15T18:05:01.303"}, "bq_ids": {"n4140": {"so_26947324_26947349_0": {"section_id": 3518, "quality": 0.9523809523809523, "length": 20}}, "n3337": {"so_26947324_26947349_0": {"section_id": 3383, "quality": 0.9523809523809523, "length": 20}}, "n4659": {"so_26947324_26947349_0": {"section_id": 4281, "quality": 0.9523809523809523, "length": 20}}}, "26947324": {"CommentCount": "0", "ViewCount": "211", "CreationDate": "2014-11-15T15:18:00.077", "LastActivityDate": "2014-11-15T18:47:09.227", "Title": "C++ numerics lib: std::uniform_int_distribution<>, change bounds of distribution between calls", "AcceptedAnswerId": "26947349", "PostTypeId": "1", "Id": "26947324", "Score": "1", "Body": "<p>I have code similar to the following:</p>\n<pre><code>    vector&lt;int&gt; vec;\n    // stuff vector here\n\n    random_device rd;\n    minstd_rand generator(rd());\n    uniform_int_distribution&lt;unsigned&gt; dist(0 , vec.size() - 1);\n    while (vec.size() &gt; 0)\n    {\n       auto it = vec.begin() + dist(generator);\n       // use *it for something\n       swap(*it, *(vec.end() - 1));\n       vec.pop_back();\n   }\n</code></pre>\n<p>I know I can construct/destruct a local distribution inside the loop. But I'd rather just adjust the bounds of <code>dist</code> inside the loop. Can I do this?</p>\n", "Tags": "<c++><c++11><random>", "OwnerUserId": "540815", "AnswerCount": "2"}});