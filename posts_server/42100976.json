post_cb({"42100976": {"CommentCount": "8", "ViewCount": "142", "PostTypeId": "1", "LastEditorUserId": "2104697", "CreationDate": "2017-02-07T22:09:59.587", "LastActivityDate": "2017-02-13T19:30:40.757", "Title": "Is this definition of constexpr offset_of is correct according to the standard?", "AcceptedAnswerId": "42212056", "LastEditDate": "2017-02-13T13:50:03.037", "Id": "42100976", "Score": "3", "Body": "<p>I wonder if this definition of a constexpr <code>offset_of</code> is correct according to the c++11 standard.</p>\n<p>According to <a href=\"http://thecppzoo.blogspot.ca/2016/10/constexpr-offsetof-practical-way-to.html\" rel=\"nofollow noreferrer\">this article</a>, C++98 allowed conversion in a declaration of an array. I tweaked the code in the article to allow some of my cases. Can I do the following? If not, is there a better way?</p>\n<pre><code>template&lt;typename T&gt;\nstruct declval_helper { static T value; };\n\ntemplate&lt;typename T, typename Z, typename U, Z U::*MPtr&gt;\nstruct offset_helper {\n    using TV = declval_helper&lt;T&gt;;\n\n    static char for_sizeof[1 + (\n        (char *)&amp;(TV::value.*MPtr) -\n        (char *)&amp;TV::value\n    )];\n};\n\ntemplate&lt;typename T, typename Z, typename U, Z U::*MPtr&gt;\nconstexpr std::size_t offset_of() {\n    return sizeof(detail::offset_helper&lt;T, Z, U, MPtr&gt;::for_sizeof) - 1;\n}\n</code></pre>\n<p>A use case:</p>\n<pre><code>struct Base { int data; };\nstruct Derived : Base { float data; };\n\nconstexpr std::size_t offset = offset_of&lt;Derived, int, Base, &amp;Base::data&gt;();\n</code></pre>\n", "Tags": "<c++><c++11><language-lawyer><constexpr>", "OwnerUserId": "2104697", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_42100976_42212056_2": {"section_id": 6185, "quality": 0.875, "length": 14}, "so_42100976_42212056_1": {"section_id": 6186, "quality": 1.0, "length": 13}, "so_42100976_42212056_0": {"section_id": 3228, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_42100976_42212056_0": {"section_id": 3101, "quality": 0.6923076923076923, "length": 9}, "so_42100976_42212056_1": {"section_id": 5947, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_42100976_42212056_2": {"section_id": 7687, "quality": 0.75, "length": 12}, "so_42100976_42212056_1": {"section_id": 7689, "quality": 0.8461538461538461, "length": 11}, "so_42100976_42212056_0": {"section_id": 3985, "quality": 0.9230769230769231, "length": 12}}}, "42212056": {"ParentId": "42100976", "CommentCount": "0", "CreationDate": "2017-02-13T19:30:40.757", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "42212056", "Score": "1", "Body": "<p>No, it's ill-formed.</p>\n<p>From [dcl.array]:</p>\n<blockquote>\n<p id=\"so_42100976_42212056_0\">If the <em>constant-expression</em> (5.20) is present, it shall be a converted constant expression of type <code>std::size_t</code> and its value shall be greater than\n  zero.</p>\n</blockquote>\n<p>The <em>constant-expression</em> here refers to the array bound, which is optional. A converted constant expression is, from [expr.const]:</p>\n<blockquote>\n<p id=\"so_42100976_42212056_1\">A <em>converted constant expression</em> of type <code>T</code> is an expression, implicitly converted to type <code>T</code>, where the converted expression is a constant expression [...]</p>\n</blockquote>\n<p>and a constant expression is:</p>\n<blockquote>\n<p id=\"so_42100976_42212056_2\">A <em>conditional-expression</em> <code>e</code> is a <em>core constant expression</em> unless the evaluation of <code>e</code>, following the rules of the\n  abstract machine (1.9), would evaluate one of the following expressions: [...] \u2014 a <code>reinterpret_cast</code> (5.2.10);</p>\n</blockquote>\n<p>This declaration:</p>\n<pre><code>static char for_sizeof[1 + (\n    (char *)&amp;(TV::value.*MPtr) -\n    (char *)&amp;TV::value\n)];\n</code></pre>\n<p>uses an implicit <code>reinterpret_cast</code> in the array bound of an array, which makes it not a constant expression, so it's ill-formed. </p>\n", "LastActivityDate": "2017-02-13T19:30:40.757"}});