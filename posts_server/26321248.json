post_cb({"bq_ids": {"n4140": {"so_26321248_26321248_1": {"length": 33, "quality": 0.868421052631579, "section_id": 7230}}, "n3337": {"so_26321248_26321248_1": {"length": 33, "quality": 0.868421052631579, "section_id": 6974}}}, "26321248": {"ViewCount": "198", "Body": "<p>In an Stack Overflow answer <a href=\"https://stackoverflow.com/a/9964002/1128289\">here</a>, Kerrek posts the following code.</p>\n<pre><code>Foo &amp;&amp; g()\n{\n    Foo y;\n    // return y;         // error: cannot bind \u2018Foo\u2019 lvalue to \u2018Foo&amp;&amp;\u2019\n    return std::move(y); // OK type-wise (but undefined behaviour, thanks @GMNG)\n}\n</code></pre>\n<p>GManNickG points out that this results in undefined behavior.</p>\n<p>Kerrek adds</p>\n<blockquote>\n<p id=\"so_26321248_26321248_0\">True; you don't really return &amp;&amp; from anything but forward and move.\n  It's a contrived example.</p>\n</blockquote>\n<p>What confuses me is that the C++11 standard uses a function call that returns an rvalue reference as an example of an expression that is an xvalue.</p>\n<blockquote>\n<p id=\"so_26321248_26321248_1\">An xvalue (an \u201ceXpiring\u201d value) also refers to an object, usually near\n  the end of its lifetime (so that its resources may be moved, for\n  example). An xvalue is the result of certain kinds of expressions\n  involving rvalue references (8.3.2). [ Example: The result of calling\n  a function whose return type is an rvalue reference is an xvalue. \u2014end\n  example ]</p>\n</blockquote>\n<p>So when exactly does returning an rvalue reference result in undefined behavior? Does it always result in undefined behavior except for <code>std::move</code> and <code>std::forward</code> and is the standard just being terse? Or would you have to access the return value for undefined behavior to result?</p>\n<p>*By \"when\" I mean \"under what circumstances\". I realize that there's no meaningful concept of time here.</p>\n", "AcceptedAnswerId": "26321330", "Title": "When does returning an rvalue reference result in undefined behavior?", "CreationDate": "2014-10-12T02:28:29.683", "Id": "26321248", "CommentCount": "5", "LastEditDate": "2017-05-23T10:33:34.950", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-12T03:16:58.303", "Score": "3", "OwnerUserId": "1128289", "Tags": "<c++><c++11><undefined-behavior><rvalue-reference>", "AnswerCount": "1"}, "26321330": {"PostTypeId": "2", "Body": "<p>Casting into a reference does not extend the lifetime of the local variable.</p>\n<p>As such, using that reference to the local after the local expires is undefined behaviour.</p>\n<p>As the local expires when the function completes, there is no way to use the return value.</p>\n<p><code>std::move</code> or <code>std::forward</code> takes a reference, and returns a reference of possibly different type.  Neither extend the lifetime of their arguement, and neither return a reference to a variable local to their own body.</p>\n<p>The UB here is not returning an rvalue reference, but rather object lifetime based.  It occurs on use, not on cast or return.</p>\n<p>That said, it is almost never a good idea to return an rvalue reference: return a copy instead.  Copies can particiate in lifetime extension.  The exception is when you are writing something like <code>forward_as_tuple</code>.</p>\n", "LastActivityDate": "2014-10-12T03:03:04.120", "LastEditorUserId": "1774667", "Id": "26321330", "CommentCount": "3", "CreationDate": "2014-10-12T02:43:10.237", "ParentId": "26321248", "Score": "7", "OwnerUserId": "1774667", "LastEditDate": "2014-10-12T03:03:04.120"}});