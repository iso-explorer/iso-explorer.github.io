post_cb({"34840115": {"CommentCount": "1", "ViewCount": "207", "CreationDate": "2016-01-17T15:33:57.943", "LastActivityDate": "2016-01-17T17:04:03.763", "Title": "Why an access to a volatile glvalue is considered a side effect by [intro.execution]/12?", "AcceptedAnswerId": "34840257", "PostTypeId": "1", "Id": "34840115", "Score": "2", "Body": "<p>What is the relevance of the term <code>volatile</code> in [intro.execution]/12?</p>\n<p><a href=\"http://eel.is/c++draft/intro.execution#12\" rel=\"nofollow\">[intro.execution]/12</a>:</p>\n<blockquote>\n<p id=\"so_34840115_34840115_0\">Reading an object designated by a <code>volatile</code> glvalue ([basic.lval]),\n  modifying an object, calling a library I/O function, or calling a\n  function that does any of those operations are all side effects, which\n  are changes in the state of the execution environment. Evaluation of\n  an expression (or a sub-expression) in general includes both value\n  computations (including determining the identity of an object for\n  glvalue evaluation and fetching a value previously assigned to an\n  object for prvalue evaluation) and initiation of side effects. When a\n  call to a library I/O function returns or an access to a <code>volatile</code>\n  object is evaluated the side effect is considered complete, even\n  though some external actions implied by the call (such as the I/O\n  itself) or by the volatile access may not have completed yet.</p>\n</blockquote>\n", "Tags": "<c++><language-lawyer><volatile>", "OwnerUserId": "1042389", "AnswerCount": "1"}, "34840257": {"ParentId": "34840115", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The entire purpose of <code>volatile</code> is to indicate to the compiler that \"you don't really know exactly what the result of accessing this variable is, so don't mess about with it\". </p>\n<p>Say for example we have:</p>\n<pre><code> int x = 7;\n ...\n int func1()\n {\n   return x;\n }\n ...\n int func2()\n {\n    return func1() + func1();\n }\n</code></pre>\n<p>the compiler could (some would argue should) convert this to <code>return 2 * func1();</code> [which is trivially calculated by a single add].</p>\n<p>However, if <code>x</code> is a hardware register [so that <code>return x;</code> actually behaves like <code>return x++;</code>], which changes with each read (e.g. it's a counter register), then <code>func1()+func1()</code> can not, and should not be optimised to <code>2 * func1();</code> - to avoid the compiler doing so <code>volatile int x;</code> will make that happen [unfortunately, there is no way to cause this behaviour in plain C++ code / some real hardware is required]</p>\n<p>Hardware registers, which is the normal use-case for <code>volatile</code> (typically in conjunction with pointers, but doesn't have to be), the read of a register will potentially have actual side-effects on the hardware - for example reading a fifo-register on a serial port [or network card, hard disk, or whatever], will affect the state of the hardware, since the fifo has now \"moved on\" one step. Skipping over, duplicating, caching the result of, or some other such optimisation would definitely cause a piece of driver code and hardware to behave in a different way than the programmer wanted - which would be the case if <code>volatile</code> wasn't considered as having a side-effect.</p>\n", "OwnerUserId": "1919155", "LastEditorUserId": "1919155", "LastEditDate": "2016-01-17T17:04:03.763", "Id": "34840257", "Score": "4", "CreationDate": "2016-01-17T15:47:34.990", "LastActivityDate": "2016-01-17T17:04:03.763"}, "bq_ids": {"n4140": {"so_34840115_34840115_0": {"section_id": 5808, "quality": 0.9459459459459459, "length": 70}}, "n3337": {"so_34840115_34840115_0": {"section_id": 5581, "quality": 0.9459459459459459, "length": 70}}, "n4659": {"so_34840115_34840115_0": {"section_id": 7269, "quality": 0.9459459459459459, "length": 70}}}});