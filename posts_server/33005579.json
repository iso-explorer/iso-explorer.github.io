post_cb({"33005607": {"ParentId": "33005579", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As per <code>C++11 17.6.4.3.2 Global names</code> (though this restriction has been around for a while):</p>\n<blockquote>\n<p id=\"so_33005579_33005607_0\">Certain sets of names and function signatures are always reserved to the implementation:</p>\n<ul>\n<li>Each name that contains a double underscore _ _ or begins with an underscore followed by an uppercase letter is reserved to the implementation for any use.</li>\n<li>Each name that begins with an underscore is reserved to the implementation for use as a name in the global namespace.</li>\n</ul>\n</blockquote>\n<p>So you really should be using <em>neither</em> if you want your software to be portable though, having said that, plenty of people <em>do</em> use both varieties.</p>\n<p>It would be \"safer\" to use something like <code>GUARD_X_H</code> or <code>X_H_INCLUDED</code> though, of course, you still need to be wary of clashes. You might take the Java way and end up with macros like:</p>\n<pre><code>AU_COM_POWERFIELD_DATASTRUCTURES_TREES_BALANCED_BTREE_H\n</code></pre>\n<p>as long as you stay below the implementation limits for macro names (which, from memory, is at least 1024 characters).</p>\n<p>Alternatively, if you want to sacrifice portability (but not <em>much</em> portability since it's supported in a great many compilers), you could look into <code>#pragma once</code>, where you don't have to worry about coming up with unique names.</p>\n", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2015-10-08T02:50:19.680", "Id": "33005607", "Score": "8", "CreationDate": "2015-10-08T02:29:35.987", "LastActivityDate": "2015-10-08T02:50:19.680"}, "33005611": {"ParentId": "33005579", "CommentCount": "0", "Body": "<p>From the 2003 C++ Standard (these rules still apply):</p>\n<blockquote>\n<p id=\"so_33005579_33005611_0\">17.4.3.2.1 Global names [lib.global.names]</p>\n<p id=\"so_33005579_33005611_1\">Certain sets of names and function signatures are always reserved to\n  the implementation:</p>\n<p id=\"so_33005579_33005611_2\">Each name that contains a double underscore (_ _) or begins with an\n  underscore followed by an uppercase letter (2.11) is reserved to the\n  implementation for any use. \n  Each name that begins with an underscore\n  is reserved to the implementation for use as a name in the global\n  namespace.165 165) Such names are also reserved in namespace ::std\n  (17.4.3.1).</p>\n</blockquote>\n", "OwnerUserId": "1249278", "PostTypeId": "2", "Id": "33005611", "Score": "2", "CreationDate": "2015-10-08T02:29:55.690", "LastActivityDate": "2015-10-08T02:29:55.690"}, "bq_ids": {"n4140": {"so_33005579_33005607_0": {"section_id": 6307, "quality": 1.0, "length": 8}, "so_33005579_33005611_2": {"section_id": 6307, "quality": 0.71875, "length": 23}, "so_33005579_33005611_1": {"section_id": 6307, "quality": 1.0, "length": 8}}, "n3337": {"so_33005579_33005607_0": {"section_id": 6064, "quality": 1.0, "length": 8}, "so_33005579_33005611_2": {"section_id": 6064, "quality": 0.71875, "length": 23}, "so_33005579_33005611_1": {"section_id": 6064, "quality": 1.0, "length": 8}}, "n4659": {"so_33005579_33005611_1": {"section_id": 7844, "quality": 0.625, "length": 5}, "so_33005579_33005611_2": {"section_id": 6756, "quality": 0.65625, "length": 21}, "so_33005579_33005607_0": {"section_id": 7844, "quality": 0.625, "length": 5}}}, "33005579": {"CommentCount": "5", "ViewCount": "84", "PostTypeId": "1", "LastEditorUserId": "5244653", "CreationDate": "2015-10-08T02:25:14.150", "LastActivityDate": "2015-10-08T04:37:59.720", "Title": "Header Guarding questions in C++", "AcceptedAnswerId": "33005607", "LastEditDate": "2015-10-08T02:53:54.257", "Id": "33005579", "Score": "4", "Body": "<p>I am new to writing my own headers, but due to necessity, I must learn. </p>\n<p>I am writing a header, and I'm trying to grok header guards. Is there a difference between having one or two underscores before and after the included header file?</p>\n<p>Take this hypothetical example: x.h</p>\n<pre><code>//x.h\n#ifndef __X_H_INCLUDED__\n#define __X_H_INCLUDED__\n//functions n stuff\n#endif\n</code></pre>\n<p>versus:</p>\n<pre><code>//x.h\n#ifndef _X_H_INCLUDED_\n#define _X_H_INCLUDED_\n//functions n stuff\n#endif\n</code></pre>\n<p>Is one more or less right than the other? Is there a difference? </p>\n", "Tags": "<c++><header><macros>", "OwnerUserId": "2401996", "AnswerCount": "3"}, "33005686": {"ParentId": "33005579", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I like to follow a particular structure for include guards which matches the structure of the project.</p>\n<pre><code>#ifndef PROJECT_PATH_TO_FILE_HPP\n// etc. etc.\n</code></pre>\n<p>So if the project is names \"skittles\", and the path to the header is <code>taste/the/rainbow.hpp</code> then my include guard becomes:</p>\n<pre><code>#ifndef SKITTLES_TASTE_THE_RAINBOW_HPP\n// etc. etc.\n</code></pre>\n<p>This works pretty well, you just have to be wary of name clashes with file names and directories. For example, one file in the project root called <code>foo_bar.hpp</code>, and one at <code>foo/bar.hpp</code>. This will cause a name clash which would have to be worked around.</p>\n<p>Another option is to use namespaces instead of paths:</p>\n<pre><code>#define PROJECT_NAMESPACE_MODULE_HPP\n</code></pre>\n<p>I've also seen people append the date and time the file was created, or use a UUID, to add further safety against name clashes.</p>\n", "OwnerUserId": "184741", "LastEditorUserId": "184741", "LastEditDate": "2015-10-08T04:37:59.720", "Id": "33005686", "Score": "1", "CreationDate": "2015-10-08T02:39:29.873", "LastActivityDate": "2015-10-08T04:37:59.720"}});