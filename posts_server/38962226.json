post_cb({"38962226": {"CommentCount": "12", "AcceptedAnswerId": "38962644", "PostTypeId": "1", "LastEditorUserId": "96282", "CreationDate": "2016-08-15T20:03:49.563", "LastActivityDate": "2016-08-15T22:24:38.773", "LastEditDate": "2016-08-15T20:58:49.493", "ViewCount": "129", "FavoriteCount": "2", "Title": "Why isn't array of const structs placed in .rodata when it references a const struct by name?", "Id": "38962226", "Score": "3", "Body": "<p>I have the following arrangement of structs:</p>\n<pre><code>typedef struct { \n    int a;       \n} Foo;\n\nconst Foo END = {0};   \n\nconst Foo table_1[] = {\n    {2}, {0}           \n};                     \n\nconst Foo table_2[] = {         \n    {2}, END                    \n};                              \n</code></pre>\n<p>Basically, I have a struct, and a couple of arrays of that struct. Now, the contents of these arrays never change: they are some lookup tables, that are used during runtime so, being in an embedded environment, I want that data to reside in ROM (I am <em>very</em> RAM-constrained, literally fighting for every couple of bytes). One would imagine, that there's nothing stopping all of those tables to reside in ROM (everything is const).</p>\n<p>Actually, <code>table_1</code> ends up in <code>.rodata</code> (so it does not get copied into RAM during startup) and <code>table_2</code> - in <code>.data</code> (consumes both ROM and RAM). When disassembling the object file I can also see some code, that initializes <code>table_2</code>.</p>\n<p>I want all aforementioned arrays to end up in <code>.rodata</code>, but it seems, that it will only happen if I write out the struct initializations \"in full\" (sorry, not sure, what is the correct term for this).</p>\n<p>What is the difference in these initializations? Because it is only the initializations that are different - types are the same and the actual data is also the same. Is it some kind of optimization going on (wonder what's being optimized here)? Is there a way to disable it? I mean, I can just <code>#define</code> away all the common table members and be done with it, but it seems like a hack and, besides, I really want to understand what is going on here.</p>\n<p>I am using gcc-arm-none-eabi toolchain, building with <code>-Os</code>, gcc version is 4.8.1.</p>\n", "Tags": "<c++><arrays><gcc><struct>", "OwnerUserId": "96282", "AnswerCount": "2"}, "38962465": {"ParentId": "38962226", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Assuming C++. </p>\n<p>The initialisation of <code>table_2</code> is not a constant expression as per C++ standard. A constant expression is everything that does not have (among other things) a lvalue to rvalue conversion (which you have when you use <code>END</code>), unless the lvalue (the <code>END</code>):</p>\n<blockquote id=\"so_38962226_38962465_0\">\n<ol>\n<li>Has integral or enumeration type and refers to a complete non-volatile\n  const object, which is initialized with a constant expression.</li>\n</ol>\n</blockquote>\n<p><code>END</code> is neither integral nor enum.</p>\n<blockquote id=\"so_38962226_38962465_1\">\n<ol start=\"2\">\n<li>Is a non-volatile glvalue that refers to an element of a string\n  literal</li>\n</ol>\n</blockquote>\n<p><code>END</code> is not a string literal.</p>\n<blockquote id=\"so_38962226_38962465_2\">\n<ol start=\"3\">\n<li>Has literal type and refers to a non-volatile object defined with constexpr or to its non-mutable subobject</li>\n</ol>\n</blockquote>\n<p><code>END</code> is not defined with constexpr. </p>\n<blockquote id=\"so_38962226_38962465_3\">\n<ol start=\"4\">\n<li>Has literal type and refers to a non-volatile object whose lifetime began within the evalution of this expression</li>\n</ol>\n</blockquote>\n<p><code>END</code>'s lifetime did not start within the evaluation of <code>table_2</code>.</p>\n<p>So the compiler has no choice but to move the <code>table_2</code> initialisation away from static context. If you declared <code>END</code> with <code>constexpr</code>, I think the condition 3 will be satisfied and you will end up with everything nicely in <code>rodata</code>.</p>\n<p>The relevant text from the C++ standard is in [expr.const] section, paragraph 2.7.2.</p>\n", "OwnerUserId": "1043352", "LastEditorUserId": "1043352", "LastEditDate": "2016-08-15T21:04:48.080", "Id": "38962465", "Score": "3", "CreationDate": "2016-08-15T20:21:56.803", "LastActivityDate": "2016-08-15T21:04:48.080"}, "bq_ids": {"n4140": {"so_38962226_38962465_2": {"section_id": 6185, "quality": 0.8181818181818182, "length": 9}, "so_38962226_38962465_3": {"section_id": 6185, "quality": 0.8333333333333334, "length": 10}, "so_38962226_38962465_1": {"section_id": 6185, "quality": 0.6666666666666666, "length": 4}, "so_38962226_38962644_0": {"section_id": 7152, "quality": 1.0, "length": 18}, "so_38962226_38962465_0": {"section_id": 6185, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_38962226_38962465_2": {"section_id": 5946, "quality": 0.6363636363636364, "length": 7}, "so_38962226_38962465_3": {"section_id": 5946, "quality": 0.5833333333333334, "length": 7}, "so_38962226_38962465_1": {"section_id": 5946, "quality": 0.6666666666666666, "length": 4}, "so_38962226_38962644_0": {"section_id": 6896, "quality": 1.0, "length": 18}, "so_38962226_38962465_0": {"section_id": 5946, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_38962226_38962465_1": {"section_id": 7687, "quality": 0.8333333333333334, "length": 5}, "so_38962226_38962465_3": {"section_id": 7687, "quality": 0.8333333333333334, "length": 10}, "so_38962226_38962465_2": {"section_id": 7687, "quality": 0.8181818181818182, "length": 9}, "so_38962226_38962644_0": {"section_id": 8653, "quality": 0.9444444444444444, "length": 17}, "so_38962226_38962465_0": {"section_id": 7687, "quality": 0.9166666666666666, "length": 11}}}, "38962644": {"ParentId": "38962226", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>gcc 5.1 and above perform this optimization; it is not mandated but considered by the C++ Standard, in [basic.start.init]:</p>\n<blockquote>\n<p id=\"so_38962226_38962644_0\">3 - An implementation is <strong>permitted</strong> to perform the initialization of a non-local variable with static storage\n  duration as a static initialization even if such initialization is <strong>not required</strong> to be done statically, provided\n  that</p>\n<ul>\n<li>the dynamic version of the initialization does not change the value of any other object of namespace\n  scope prior to its initialization, and</li>\n<li>the static version of the initialization produces the same value in the initialized variable as would be\n  produced by the dynamic initialization if all variables not required to be initialized statically were\n  initialized dynamically.</li>\n</ul>\n</blockquote>\n<p>If your version of gcc supports <code>constexpr</code>, then marking <code>END</code> <code>constexpr</code> should be enough to get it to statically-initialize <code>table_2</code>; you can also mark <code>table_2</code> <code>constexpr</code> to be sure (ibid):</p>\n<blockquote>\n<p id=\"so_38962226_38962644_1\">2 - Constant initialization is performed: [...]</p>\n<ul>\n<li>if [...] every full-expression that appears in its initializer is a constant expression.</li>\n</ul>\n</blockquote>\n<p>Why do we need <code>constexpr</code> here - why isn't <code>const</code> sufficient? It's because a <code>const</code> object can still have a <code>mutable</code> member (possibly a member of a member, etc.) and that would allow it to be changed between the initialization of <code>END</code> and the initialization of <code>table_2</code>:</p>\n<pre><code>struct Bar { mutable int a; };\nconst Bar END = {0};\nint unused = ++END.a; // !!\nstruct Foo { int a; };\nconst Foo table_2[] = { {2}, {END.a} };\n</code></pre>\n<p><code>constexpr</code> prevents this in general, since [expr.const]/2 ensures that a composite object with a <code>mutable</code> member can't be used in the initialization of a <code>constexpr</code> object. A <code>constexpr</code> object can still have a <code>mutable</code> member of its own, but that would prevent it being used to initialize another <code>constexpr</code> object.</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2016-08-15T22:24:38.773", "Id": "38962644", "Score": "8", "CreationDate": "2016-08-15T20:36:07.487", "LastActivityDate": "2016-08-15T22:24:38.773"}});