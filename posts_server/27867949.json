post_cb({"bq_ids": {"n4140": {"so_27867949_27868077_0": {"length": 11, "quality": 1.0, "section_id": 175}}, "n3337": {"so_27867949_27868077_0": {"length": 11, "quality": 1.0, "section_id": 169}}, "n4659": {"so_27867949_27868077_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 180}}}, "27868093": {"Id": "27868093", "PostTypeId": "2", "Body": "<p>Everything is not 1,2,3,4 (for which specific specializations exist)  will go into the \"master\" definition, that have to assert for every value of D it will be called.</p>\n<p>So you need <em>an expression that contains D</em> and that is <em>always false</em>, to cause the compiler to evaluate it <em>in dependency of D</em></p>\n<p>If you just use 0, it will be anymore dependent and the compiler will evaluate as it matches during parsing, causing the assertion to always take place. Even if it will not be the class you will instantiate.</p>\n", "LastActivityDate": "2015-01-09T19:48:58.523", "CommentCount": "1", "CreationDate": "2015-01-09T19:48:58.523", "ParentId": "27867949", "Score": "0", "OwnerUserId": "924727"}, "27868077": {"Id": "27868077", "PostTypeId": "2", "Body": "<p>\u00a714.6 [temp.res]/p8:</p>\n<blockquote>\n<p id=\"so_27867949_27868077_0\">If no valid specialization can be generated for a template, and that\n  template is not instantiated, the template is ill-formed, no\n  diagnostic required.</p>\n</blockquote>\n<p>In both cases no valid specialization can be generated for the primary template due to the <code>static_assert</code> (<code>D &amp;&amp; 0</code> is never true no matter the value of <code>D</code>). Since no diagnostic is required, the compiler is free to diagnose one (when you use <code>0</code>) but not the other (when you use <code>D &amp;&amp; 0</code>).</p>\n<p>Workaround:</p>\n<pre><code>template &lt;unsigned int D&gt; struct always_false : std::false_type {};\n\ntemplate &lt;typename T, unsigned int D&gt; struct Vec\n{\n    static_assert(always_false&lt;D&gt;::value, \"Invalid dimension for vector!\");\n};\n</code></pre>\n<p>The compiler can no longer reject this at definition time, as there might be an explicit specialization of <code>always_false</code> whose <code>value</code> member is <code>true</code>.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2015-01-09T19:52:50.087", "Score": "6", "CreationDate": "2015-01-09T19:47:39.820", "ParentId": "27867949", "CommentCount": "10", "OwnerUserId": "2756719", "LastEditDate": "2015-01-09T19:52:50.087"}, "27867949": {"ViewCount": "187", "Body": "<p>I've noticed strange behavior of <code>static_assert</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T, unsigned int D&gt; struct Vec\n{\n    static_assert(D &amp;&amp; 0, \"Invalid dimension for vector!\");\n};\n\ntemplate &lt;typename T&gt; struct Vec&lt;T, 1&gt;             {union {T x, r;};};\ntemplate &lt;typename T&gt; struct Vec&lt;T, 2&gt; : Vec&lt;T, 1&gt; {union {T y, g;};};\ntemplate &lt;typename T&gt; struct Vec&lt;T, 3&gt; : Vec&lt;T, 2&gt; {union {T z, b;};};\ntemplate &lt;typename T&gt; struct Vec&lt;T, 4&gt; : Vec&lt;T, 3&gt; {union {T w, a;};};\n\nint main()\n{\n    Vec&lt;float, 3&gt; v;\n    v.x = 1;\n    v.y = 2;\n    v.z = 3;\n\n    return 0;\n}\n</code></pre>\n<p>It compiles fine: <a href=\"http://ideone.com/wHbJYP\" rel=\"nofollow\">http://ideone.com/wHbJYP</a> . I would expect</p>\n<pre><code>static_assert(0, \"Invalid dimension for vector!\");\n</code></pre>\n<p>to give me same result, but it causes static assertion failure: <a href=\"http://ideone.com/UEu9Kv\" rel=\"nofollow\">http://ideone.com/UEu9Kv</a> .\nIs gcc correct in both cases? If so, why? Or is it a gcc bug? Then, in which case gcc is correct?</p>\n", "AcceptedAnswerId": "27868077", "Title": "Why static_assert in template gives me different result with equivalent expressions?", "CreationDate": "2015-01-09T19:39:09.753", "Id": "27867949", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2015-01-09T19:58:43.207", "Score": "3", "OwnerUserId": "2752075", "Tags": "<c++><templates><gcc><static-assert>", "AnswerCount": "2"}});