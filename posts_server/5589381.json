post_cb({"5590050": {"ParentId": "5589381", "PostTypeId": "2", "CommentCount": "25", "Body": "<p>What does the C header look like? Somewhere, the C source must enumerate the callback types allowed. You should take that opportunity to have a series of macros that generate prototypes to individual stub functions, with a corresponding sequence of macros  in the C++ source generating <code>extern \"C\"</code> stubs.</p>\n<hr>\n<p>As to the second question: Yes, that works, but the <code>typedef</code> is not inside a template. I attempted to put such a typedef inside a class, but it turns out that even class templates are not allowed inside the <code>extern \"C\"</code>. So you can have a function template, but no parameters of dependent type.</p>\n<p>Merely defining that function is easy:</p>\n<pre><code>extern \"C\" typedef void ftype(int);\n\ntemplate&lt;typename T&gt;\nstatic ftype f; // &lt;- added \"static\" here\n\ntemplate&lt; typename T &gt;\nvoid f(int q) {}\n</code></pre>\n<p>Aha, variadic functions!</p>\n<pre><code>extern \"C\" typedef void ftype( int, ... );\n\ntemplate&lt;typename T&gt;\nstatic ftype f;\n\ntemplate&lt; typename T &gt;\nstatic void f( int z, ... ) {\n    va_list va;\n    va_start( va, z );\n    T v = va_arg( va, T );\n    va_end( va );\n\n    std::cout &lt;&lt; v;\n}\n</code></pre>\n<p>You don't really need type deduction since it's just a callback, so you can pass this <code>&amp; f&lt;int&gt;</code> to the C code, all callbacks having the same type, and it can make the type determination at runtime and pass whatever it wants through the varargs.</p>\n</hr>", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2011-04-08T04:44:24.083", "Id": "5590050", "Score": "3", "CreationDate": "2011-04-08T03:20:29.740", "LastActivityDate": "2011-04-08T04:44:24.083"}, "5589381": {"CommentCount": "0", "CreationDate": "2011-04-08T01:10:14.260", "PostTypeId": "1", "AcceptedAnswerId": "5590050", "LastEditorUserId": "34509", "LastActivityDate": "2011-04-08T07:07:01.447", "LastEditDate": "2011-04-08T03:51:02.417", "ViewCount": "3462", "FavoriteCount": "7", "Title": "Calling function template specialization using C calling conventions", "Id": "5589381", "Score": "13", "Body": "<p>I have the following template</p>\n<pre><code>template&lt;typename T&gt; void f(T t) { }\n</code></pre>\n<p>And I want to pass the address of a specific specialization of it to a C function</p>\n<pre><code>g(&amp;f&lt;int&gt;);\n</code></pre>\n<p>But as I want to be portable, I want the calling convention of \"f\" to match the one of C. So I experimented how language linkage affects calling convention and found</p>\n<ul>\n<li>The language linkage of the <em>function type</em> affects calling convention to use</li>\n<li>The language linkage of the <em>function name</em> affects mangling</li>\n</ul>\n<p>The language linkage section of the C++ spec says</p>\n<blockquote>\n<p id=\"so_5589381_5589381_0\">In a linkage-specification, the speci\ufb01ed language linkage applies to the function types of all function declarators, function names with external linkage, and variable names with external linkage declared within the linkage-specification.</p>\n</blockquote>\n<p>So to prevent disabling of mangling, which is needed for templates to distinguish different specializations from each other in the object file, I went as follows</p>\n<pre><code>extern \"C\" {\n    /* function name will not be affected */\n    template&lt;typename T&gt; static void f(T t) { }\n}\n</code></pre>\n<p>But it gives me a compiler error saying that templates cannot have C language linkage, which I take it to mean that it complains about the function template's function type. And in fact, I found the spec to say</p>\n<blockquote>\n<p id=\"so_5589381_5589381_1\">A template, a template explicit specialization (14.7.3), and a class template partial specialization shall not have C linkage</p>\n</blockquote>\n<p>Now it's obvious to me that we don't want to change the <em>name</em>'s linkage, because we rely on mangling to work. But what is the reason for forbidding to change the <em>type</em>'s linkage? It seems to restrict us to having to use C++ calling convention; does someone know the reason, and whether there is an easy work around to achieve my initial goal?</p>\n<hr>\n<p>I changed the way I try to give linkage to only the type now, as follows</p>\n<pre><code>extern \"C\" typedef void ftype(int);\n\ntemplate&lt;typename T&gt;\nftype f;\n</code></pre>\n<p>And this works fine. Sadly, I don't see a way to define <code>f</code> when using this technique. But anyway, no compiler I tried diagnoses this (tried EDG/comeau, GCC and clang), even though this looks like exactly the same situation as before: The name should have no C language linkage, but only the type has. </p>\n<p>Can anyone explain this?</p>\n</hr>", "Tags": "<c++><templates>", "OwnerUserId": "34509", "AnswerCount": "3"}, "5589713": {"ParentId": "5589381", "CommentCount": "0", "Body": "<p>I don't know the reason for the restriction, but can't you use a wrapper <code>extern \"C\"</code> function that calls the specific template instantiation you care about?</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "5589713", "Score": "1", "CreationDate": "2011-04-08T02:17:34.947", "LastActivityDate": "2011-04-08T02:17:34.947"}, "bq_ids": {"n4140": {"so_5589381_5589381_0": {"section_id": 5520, "quality": 0.9523809523809523, "length": 20}, "so_5589381_5589381_1": {"section_id": 51, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_5589381_5589381_0": {"section_id": 5306, "quality": 0.9523809523809523, "length": 20}, "so_5589381_5589381_1": {"section_id": 46, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_5589381_5589381_0": {"section_id": 6955, "quality": 0.9523809523809523, "length": 20}, "so_5589381_5589381_1": {"section_id": 52, "quality": 0.9090909090909091, "length": 10}}}, "5591649": {"ParentId": "5589381", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_5589381_5591649_0\">...whether there is an easy work around to achieve my initial goal?</p>\n</blockquote>\n<p>you can approach it from a few angles, depending on how you want to configure and declare them.</p>\n<p>four approaches follow, one namespace demonstrates each. 'Type' is probably the simplest for your usage.</p>\n<pre><code>#include &lt;stdio.h&gt; // favored to reduce exports in later demonstration\n\n#define FUNC_NAME __PRETTY_FUNCTION__\n// or __func__ or __FUNCTION__ or...\n\nextern \"C\" {\n\n    /* C prototype */\n    typedef void ftype(int a);\n\n    /* the c function all our functions are piped into */\n    void call(ftype* a);\n\n    /* helper which serves as the implementation for our functions */\n    void print(int a, const char* const func);\n\n    /* C definitions (used in namespace examples below) */\n    static void static_float(int a) {\n        print(a, FUNC_NAME);\n    }\n\n    static void static_double(int a) {\n        print(a, FUNC_NAME);\n    }\n\n    void extern_float(int a);\n    void extern_float(int a) {\n        print(a, FUNC_NAME);\n    }\n\n    void extern_double(int a);\n    void extern_double(int a) {\n        print(a, FUNC_NAME);\n    }\n\n    static void static_function_float(int a) {\n        print(a, FUNC_NAME);\n    }\n\n    static void static_function_double(int a) {\n        print(a, FUNC_NAME);\n    }\n\n} /* &lt;&lt; extern C */\n\nnamespace Extern {\n\n    /**\n     interface demonstrates C functions as template arguments\n    */\n    template&lt;ftype Fn&gt;\n    struct t_func {\n        static ftype* Function() {\n            return Fn;\n        }\n    };\n\n    template&lt;typename T&gt; struct bind;\n\n    template&lt;&gt; struct bind&lt;float&gt; {\n        typedef t_func&lt;extern_float&gt; F;\n    };\n\n    template&lt;&gt; struct bind&lt;double&gt; {\n        typedef t_func&lt;extern_double&gt; F;\n    };\n\n    template&lt;typename T&gt;\n    void Call(T a) {\n        (void) a;\n        call(bind&lt;T&gt;::F::Function());\n    }\n\n} /* &lt;&lt; Extern */\n\nnamespace Static {\n\n    /**\n     interface demonstrates template types wrapping static C functions\n     */\n    template&lt;typename T&gt; struct bind;\n\n    template&lt;&gt; struct bind&lt;float&gt; {\n        static ftype* F() {\n            return static_float;\n        }\n    };\n\n    template&lt;&gt; struct bind&lt;double&gt; {\n        static ftype* F() {\n            return static_double;\n        }\n\n    };\n\n    template&lt;typename T&gt;\n    void Call(T a) {\n        (void) a;\n        call(bind&lt;T&gt;::F());\n    }\n\n} /* &lt;&lt; Static */\n\nnamespace Function {\n\n    /**\n     interface demonstrates template functions wrapping static C functions\n     */\n\n    template&lt;typename T&gt; ftype* bind();\n\n    template&lt;&gt; ftype* bind&lt;float&gt; () {\n        return static_function_float;\n    }\n\n    template&lt;&gt; ftype* bind&lt;double&gt; () {\n        return static_function_double;\n    }\n\n    template&lt;typename T&gt;\n    void Call(T a) {\n        (void) a;\n        call(bind&lt;T&gt; ());\n    }\n\n} /* &lt;&lt; Function */\n\nnamespace Type {\n\n    /**\n     interface demonstrates template types implementing static functions.\n     although gcc4.2 and clang both compile it, i'm uncertain that this is conforming.\n    */\n\n    template&lt;typename T&gt; struct bind {\n        static void F(int a);\n    };\n\n    template&lt;&gt; void bind&lt;float&gt;::F(int a) {\n        print(a, FUNC_NAME);\n    }\n\n    template&lt;&gt; void bind&lt;double&gt;::F(int a) {\n        print(a, FUNC_NAME);\n    }\n\n    template&lt;typename T&gt;\n    void Call(T a) {\n        (void) a;\n        call(bind&lt;T&gt;::F);\n    }\n\n} /* &lt;&lt; Type */\n\nint main(int argc, const char * argv[]) {\n    (void) argc;\n    (void) argv;\n\n    const float f(1.0f);\n    const double d(5.0);\n\n    Extern::Call(f);\n    Extern::Call(d);\n\n    Static::Call(f);\n    Static::Call(d);\n\n    Function::Call(f);\n    Function::Call(d);\n\n    Type::Call(f);\n    Type::Call(d);\n\n    return 0;\n}\n\nvoid call(ftype* a) {\n    a(11);\n}\n\nvoid print(int a, const char* const func) {\n    printf(\"%i: %s\\n\", a, func);\n}\n</code></pre>\n<p>outputs:</p>\n<pre><code>11: void extern_float(int)\n11: void extern_double(int)\n11: void static_float(int)\n11: void static_double(int)\n11: void static_function_float(int)\n11: void static_function_double(int)\n11: static void Type::bind&lt;T&gt;::F(int) [with T = float]\n11: static void Type::bind&lt;T&gt;::F(int) [with T = double]\n</code></pre>\n<p>producing:</p>\n<pre><code>nm unstripped:\n    0000000100000daf s  stub helpers\n    0000000100001048 D _NXArgc\n    0000000100001050 D _NXArgv\n    0000000100000bde T __ZN4Type4bindIdE1FEi\n    0000000100000bc0 T __ZN4Type4bindIfE1FEi\n    0000000100000d98 s __ZZ12extern_floatE19__PRETTY_FUNCTION__\n    0000000100000c98 s __ZZ12static_floatE19__PRETTY_FUNCTION__\n    0000000100000d80 s __ZZ13extern_doubleE19__PRETTY_FUNCTION__\n    0000000100000cb0 s __ZZ13static_doubleE19__PRETTY_FUNCTION__\n    0000000100000d60 s __ZZ21static_function_floatE19__PRETTY_FUNCTION__\n    0000000100000d38 s __ZZ22static_function_doubleE19__PRETTY_FUNCTION__\n    0000000100000cc8 s __ZZN4Type4bindIdE1FEiE19__PRETTY_FUNCTION__\n    0000000100000d00 s __ZZN4Type4bindIfE1FEiE19__PRETTY_FUNCTION__\n    0000000100001060 D ___progname\n    0000000100000000 A __mh_execute_header\n    0000000100001058 D _environ\n                     U _exit\n    0000000100000c00 T _extern_double\n    0000000100000b20 T _extern_float\n    0000000100000c20 T _main\n                     U _printf\n    0000000100000b60 t _static_double\n    0000000100000b40 t _static_float\n    0000000100000ba0 t _static_function_double\n    0000000100000b80 t _static_function_float\n                     U dyld_stub_binder\n    0000000100000ae0 T start\n\n\nnm stripped:\n    0000000100000000 A __mh_execute_header\n                     U _exit\n                     U _printf\n                     U dyld_stub_binder\n</code></pre>\n<p>sorry, i'm not poring over standards tonight -- hope that helps. good luck!</p>\n", "OwnerUserId": "191596", "PostTypeId": "2", "Id": "5591649", "Score": "1", "CreationDate": "2011-04-08T07:07:01.447", "LastActivityDate": "2011-04-08T07:07:01.447"}});