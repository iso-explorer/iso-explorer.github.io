post_cb({"bq_ids": {"n4140": {"so_46450437_46450695_1": {"length": 6, "quality": 1.0, "section_id": 7043}, "so_46450437_46450695_0": {"length": 31, "quality": 0.96875, "section_id": 7043}}, "n3337": {"so_46450437_46450695_1": {"length": 6, "quality": 1.0, "section_id": 6788}, "so_46450437_46450695_0": {"length": 31, "quality": 0.96875, "section_id": 6788}}, "n4659": {"so_46450437_46450695_1": {"length": 6, "quality": 1.0, "section_id": 8540}, "so_46450437_46450695_0": {"length": 31, "quality": 0.96875, "section_id": 8540}}}, "46450699": {"Id": "46450699", "PostTypeId": "2", "Body": "<p>You define each class twice, which is incorrect.</p>\n<p>In your <code>.cpp</code> files it needs to provide definitions for functions declared but not defined in the headers.</p>\n<p>E.g., <code>Windows.cpp</code> should include <code>Windows.hpp</code> and contain:</p>\n<pre><code>bool Windows::IsDone() {\n    return m_isDone;\n}\n</code></pre>\n", "LastActivityDate": "2017-09-27T14:37:47.503", "CommentCount": "0", "CreationDate": "2017-09-27T14:37:47.503", "ParentId": "46450437", "Score": "1", "OwnerUserId": "412080"}, "46450437": {"ViewCount": "24", "Body": "<p>Believe me when I tell you that I searched online, but did not find the answer.</p>\n<p>I have 5 files:</p>\n<p>main.cpp</p>\n<p>Game.cpp</p>\n<p>Game.hpp</p>\n<p>Window.cpp</p>\n<p>Window.hpp</p>\n<p>The content is below : </p>\n<pre><code>#include \"Window.hpp\"\n#include \"Game.hpp\"\n\nint main()\n{\n    // Program entry point\n    Game game;\n    while (!game.GetWindow()-&gt;IsDone()){\n        // game loop here\n        game.HandleInput();\n        game.Update();\n        game.Render();\n    }\n    return 0;\n}\n</code></pre>\n<p>This is the Game.cpp</p>\n<pre><code>#include \"Window.hpp\"\n\nclass Game {\n    public:\n        Game(): m_window(\"Chapter 2\", sf::Vector2u(800,600)) {\n\n            m_mushroomTexture.loadFromFile(\"images.png\");\n            m_mushroom.setTexture(m_mushroomTexture);\n        }\n        ~Game(){}\n\n        void HandleInput() {\n\n        }\n        void Update() {\n            m_window.Update();\n            MoveMushroom();\n        }\n        void Render() {\n            m_window.BeginDraw();\n            m_window.Draw(m_mushroom);\n            m_window.EndDraw();\n        }\n        // Getting a point to the window\n        Window* GetWindow(){\n\n        }\n\n    private:\n        void MoveMushroom(){\n            sf::Vector2u l_windSize = m_window.GetWindowSize();\n            sf::Vector2u l_textSize = m_mushroomTexture.getSize();\n\n            if ((m_mushroom.getPosition().x &gt; l_windSize.x - l_textSize.x and m_increment.x &gt; 0) or \\\n                (m_mushroom.getPosition().x &lt; 0 and m_increment.x &lt; 0)) {\n                m_increment.x = -m_increment.x;\n            }\n            if ((m_mushroom.getPosition().y &gt; l_windSize.y - l_textSize.y and m_increment.y &gt; 0) or \\\n                (m_mushroom.getPosition().y &lt; 0 and m_increment.y &lt; 0)) {\n                m_increment.y = -m_increment.y;\n            }\n            m_mushroom.setPosition( m_mushroom.getPosition().x + m_increment.x, m_mushroom.getPosition().y + m_increment.y);\n        }\n        Window m_window;\n        sf::Texture m_mushroomTexture;\n        sf::Sprite m_mushroom;\n        sf::Vector2i m_increment;\n};\n</code></pre>\n<p>Game.hpp</p>\n<pre><code>#pragma once\n\n#include \"Window.hpp\"\n#include &lt;SFML/Graphics.hpp&gt;\n\nclass Game {\npublic:\n    Game();\n    ~Game();\n\n    void HandleInput();\n    void Update();\n    void Render();\n    // Getting a point to the window\n    Window* GetWindow();\n\nprivate:\n    void MoveMushroom();\n    Window m_window;\n    sf::Texture m_mushroomTexture;\n    sf::Sprite m_mushroom;\n    sf::Vector2i m_increment;\n};\n</code></pre>\n<p>Window.cpp</p>\n<pre><code>#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;string&gt;\n\n\nclass Window {\npublic:\n    // constructor\n    Window() {Setup(\"Window\", sf::Vector2u(640,480));}\n    // we have 2 constructors because there 2 ways to instantiate a class\n\n    Window(const std::string&amp; l_title, const sf::Vector2u&amp; l_size) {\n\n        Setup(l_title, l_size);\n    }\n    ~Window() { Destroy(); }\n\n    void BeginDraw(){\n        m_window.clear(sf::Color::Black);\n    }\n    void EndDraw(){\n        m_window.display();\n    }\n\n    void Update(){\n\n        sf::Event event;\n        while (m_window.pollEvent(event)) {\n            if (event.type == event.Closed) {\n                m_isDone = true;\n            } else if (event.type == sf::Event::KeyPressed and event.key.code == sf::Keyboard::F5){\n                ToggleFullscreen();\n            }\n        }\n\n    }\n\n    bool IsDone(){\n        return m_isDone;\n    }\n    bool IsFullscreen(){\n        return m_isFullscreen;\n    }\n\n    sf::Vector2u GetWindowSize() {\n        return m_windowSize;\n    }\n\n    void ToggleFullscreen(){\n        m_isFullscreen = !m_isFullscreen;\n        Destroy();\n        Create();\n    }\n\n    void Draw(sf::Drawable&amp; l_drawable){\n        m_window.draw(l_drawable);\n    }\n\nprivate:\n    void Setup(const std::string&amp; l_title, const sf::Vector2u&amp; l_size) {\n        m_windowTitle = l_title;\n        m_windowSize = l_size;\n        m_isFullscreen = false;\n        m_isDone = false;\n        Create();\n    }\n\n    void Destroy(){\n        m_window.close();\n    }\n\n    void Create() {\n        // the same as \n        // if (m_isFullscreen) {\n        //      auto_style = sf::Style::Fullscreen;\n        // } else {\n        //      auto_style = sf::Style::Default;\n        // }\n        auto style = (m_isFullscreen ? sf::Style::Fullscreen : sf::Style::Default);\n        m_window.create({m_windowSize.x, m_windowSize.y, 32}, m_windowTitle, style);\n    }\n\n    sf::RenderWindow m_window;\n    sf::Vector2u m_windowSize;\n    std::string m_windowTitle;\n    bool m_isDone;\n    bool m_isFullscreen;\n\n};\n</code></pre>\n<p>Window.hpp</p>\n<pre><code>#pragma once\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;string&gt;\n\nclass Window {\npublic:\n    // constructor\n    Window();\n    // we have 2 constructors because there 2 ways to instantiate a class\n    Window(const std::string&amp; l_title, const sf::Vector2u&amp; l_size);\n    ~Window();\n\n    void BeginDraw();\n    void EndDraw();\n\n    void Update();\n\n    bool IsDone();\n    bool IsFullscreen();\n    sf::Vector2u GetWindowSize();\n\n    void ToggleFullscreen();\n\n    void Draw(sf::Drawable&amp; l_drawable);\nprivate:\n    void Setup(const std::string&amp; l_title, const sf::Vector2u&amp; l_size);\n    void Destroy();\n    void Create();\n\n    sf::RenderWindow m_window;\n    sf::Vector2u m_windowSize;\n    std::string m_windowTitle;\n    bool m_isDone;\n    bool m_isFullscreen;\n\n};\n</code></pre>\n<p>The problem is that when i try to build my project i get a linker error. </p>\n<pre><code>/tmp/ccxbe5nA.o: In function `main':\nmain.cpp:(.text+0x26): undefined reference to `Game::Game()'\nmain.cpp:(.text+0x35): undefined reference to `Game::GetWindow()'\nmain.cpp:(.text+0x3d): undefined reference to `Window::IsDone()'\nmain.cpp:(.text+0x53): undefined reference to `Game::HandleInput()'\nmain.cpp:(.text+0x62): undefined reference to `Game::Update()'\nmain.cpp:(.text+0x71): undefined reference to `Game::Render()'\nmain.cpp:(.text+0x87): undefined reference to `Game::~Game()'\nmain.cpp:(.text+0xac): undefined reference to `Game::~Game()'\ncollect2: error: ld returned 1 exit status\n</code></pre>\n<p>I am compiling first with the following command : </p>\n<pre><code>g++ -std=c++11  -c main.cpp Window.cpp Game.cpp\n</code></pre>\n<p>No errors during the compilation stage. When I try to link it, I get the error message from above. The command used is this : </p>\n<pre><code>g++ main.o Game.o Window.o -o sfml-app -lsfml-graphics -lsfml-window -lsfml-system\n</code></pre>\n", "AcceptedAnswerId": "46450695", "Title": "Undefined reference to xx::xx()", "CreationDate": "2017-09-27T14:25:56.713", "Id": "46450437", "CommentCount": "0", "LastEditDate": "2017-09-27T14:36:45.993", "PostTypeId": "1", "LastEditorUserId": "3604851", "LastActivityDate": "2017-09-27T14:37:47.503", "Score": "0", "OwnerUserId": "3604851", "Tags": "<c++11><linker>", "AnswerCount": "2"}, "46450695": {"Id": "46450695", "PostTypeId": "2", "Body": "<p>By defining the same class differently in different places, your program violates One Definition Rule:</p>\n<blockquote>\n<p id=\"so_46450437_46450695_0\"><strong>[basic.def.odr]/5</strong> There can be more than one definition of a class type ... in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. Given such an entity named <code>D</code> defined in more than one translation unit, then</p>\n<p id=\"so_46450437_46450695_1\">\u2014 each definition of <code>D</code> shall <strong>consist of the same sequence of tokens</strong>; and...</p>\n</blockquote>\n<p>Emphasis mine.</p>\n<p>Remove class definition from <code>Game.cpp</code>, only leave member function definitions, like this:</p>\n<pre><code>Game::Game(): m_window(\"Chapter 2\", sf::Vector2u(800,600)) {...}\nvoid Game::Update() {...}\n// and so on for other members\n</code></pre>\n<p>And similarly for <code>Window</code>.</p>\n", "LastActivityDate": "2017-09-27T14:37:38.307", "CommentCount": "2", "CreationDate": "2017-09-27T14:37:38.307", "ParentId": "46450437", "Score": "2", "OwnerUserId": "1670129"}});