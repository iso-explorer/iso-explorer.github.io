post_cb({"38593126": {"ParentId": "38593014", "LastEditDate": "2016-07-26T15:01:52.047", "CommentCount": "2", "CreationDate": "2016-07-26T14:48:06.320", "OwnerUserId": "841108", "LastEditorUserId": "841108", "PostTypeId": "2", "Id": "38593126", "Score": "7", "Body": "<p>Read <em>carefully</em> <a href=\"http://man7.org/linux/man-pages/man3/basename.3.html\" rel=\"noreferrer\">basename(3)</a> and notice:</p>\n<blockquote>\n<p id=\"so_38593014_38593126_0\">Warning: there are <em>two</em> different functions <code>basename()</code> - see below.</p>\n</blockquote>\n<p>and take care of the <em>NOTES</em> saying</p>\n<blockquote>\n<p id=\"so_38593014_38593126_1\">There are two different versions of <code>basename()</code> - the POSIX version\n  described above, and the GNU version, which one gets after</p>\n<pre><code>      #define _GNU_SOURCE         /* See feature_test_macros(7) */\n      #include &lt;string.h&gt;\n</code></pre>\n<p id=\"so_38593014_38593126_2\">The GNU version <strong>never modifies</strong> its argument, and returns the empty\n  string when path has a trailing slash</p>\n</blockquote>\n<p><sup>(emphasis is mine)</sup></p>\n<p>Because it is said that the GNU version does not modify its argument, using it is safe with <code>__FILE__</code></p>\n<p>BTW, you could consider customizing your GCC (e.g. with <a href=\"http://gcc-melt.org/\" rel=\"noreferrer\">MELT</a>) to define some <code>__builtin_basename</code> which would compute the basename at compile time if given a string literal like <code>__FILE__</code> or else invoke <code>basename</code> at runtime.</p>\n<p>Notice that <code>libgen.h</code> has <code>#define basename    __xpg_basename</code></p>\n", "LastActivityDate": "2016-07-26T15:01:52.047"}, "38594108": {"ParentId": "38593014", "LastEditDate": "2016-07-26T16:44:50.280", "CommentCount": "3", "CreationDate": "2016-07-26T15:30:26.543", "OwnerUserId": "1275169", "LastEditorUserId": "1275169", "PostTypeId": "2", "Id": "38594108", "Score": "4", "Body": "<blockquote>\n<p id=\"so_38593014_38594108_0\">what is the type of __FILE__? Isn't it a string literal / const char*?</p>\n</blockquote>\n<p>Yes. It's a string literal.</p>\n<blockquote>\n<p id=\"so_38593014_38594108_1\">But if it is, why there's no a compile-time error (const char* to char*)?</p>\n</blockquote>\n<p>Possibly because the implementation you use (glibc's) may be returning a pointer within the string literal you pass (i.e. it doesn't modify its input).\nIn any case, you can't rely on it for the above stated below.</p>\n<p>C standard (c11, \u00a7 6.10.8.1) says the <code>__FILE__</code> is a string literal:</p>\n<blockquote>\n<p id=\"so_38593014_38594108_2\"><code>__FILE__</code> The presumed name of the current source \ufb01le (a character string siteral).</p>\n</blockquote>\n<p><a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/basename.html\" rel=\"nofollow\">POSIX</a> says:</p>\n<blockquote>\n<p id=\"so_38593014_38594108_3\">The basename() function may <strong>modify the string pointed to by path</strong>,\n  and may return a pointer to internal storage. The returned pointer\n  might be invalidated or the storage might be overwritten by a\n  subsequent call to basename().</p>\n</blockquote>\n<p>(emphasis mine).</p>\n<p>So, no, it's not safe to call <code>basename()</code> with <code>__FILE__</code>. You can simply take a copy of <code>__FILE__</code> and do <code>basename()</code> on it:</p>\n<pre><code>char *filename = strdup(__FILE__);\nif (filename) {\n    /* error */\n}\nchar *file_basename = basename(filename);\nfree(filename);\n</code></pre>\n<hr>\n<p>Since <code>__FILE__</code> is a string literal, using an <em>array</em> is another option:</p>\n<pre><code>char filename[] = __FILE__;\nchar *file_basename = basename(filename);\n</code></pre>\n</hr>", "LastActivityDate": "2016-07-26T16:44:50.280"}, "38593014": {"CommentCount": "10", "ViewCount": "326", "PostTypeId": "1", "LastEditorUserId": "5446052", "CreationDate": "2016-07-26T14:43:07.223", "LastActivityDate": "2016-07-26T17:17:23.610", "Title": "Is it safe to use `basename` with __FILE__?", "AcceptedAnswerId": "38593126", "LastEditDate": "2016-07-26T17:17:23.610", "Id": "38593014", "Score": "1", "Body": "<p>The title is pretty clear: Is it safe to use <code>basename</code> (<code>man 3 basename</code>) with <code>__FILE__</code> ?.</p>\n<hr>\n<p>It compiles and <em>seems</em> to work fine, <strong>but</strong> <code>basename</code>'s argument is <code>char*</code> (not <code>const char*</code>) and the <code>man</code>-page says:</p>\n<blockquote>\n<p id=\"so_38593014_38593014_0\">Both dirname() and basename() may modify the contents of path, so it may be desirable to pass a copy when calling one of these functions.</p>\n</blockquote>\n<p>So, this makes me worry.</p>\n<p>Maybe the question should be more like: what is the type of <code>__FILE__</code>? Isn't it a string literal / <code>const char*</code>? But if it is, why there's no a compile-time error (<code>const char*</code> to <code>char*</code>)?</p>\n</hr>", "Tags": "<c++><c><posix>", "OwnerUserId": "435800", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_38593014_38594108_2": {"section_id": 550, "quality": 0.6, "length": 6}}, "n3337": {"so_38593014_38594108_2": {"section_id": 541, "quality": 0.6, "length": 6}}, "n4659": {"so_38593014_38594108_2": {"section_id": 571, "quality": 0.6, "length": 6}}}});