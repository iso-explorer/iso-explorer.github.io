post_cb({"bq_ids": {"n4140": {"so_31129484_31129679_0": {"length": 70, "quality": 0.9459459459459459, "section_id": 447}}, "n3337": {"so_31129484_31129679_0": {"length": 70, "quality": 0.9459459459459459, "section_id": 438}}, "n4659": {"so_31129484_31129679_0": {"length": 70, "quality": 0.9459459459459459, "section_id": 469}}}, "31129599": {"Id": "31129599", "PostTypeId": "2", "Body": "<p>The first thing you have to understand here is that a call to <code>foo()</code> made while the constructor of class <code>A</code> is active is dispatched to <code>A::foo()</code>, even if the full object under construction has type <code>B</code> and <code>B</code> overrides <code>foo()</code>. The presence of <code>B::foo()</code> is simply ignored.</p>\n<p>This means that your code attempts to call <code>A::foo()</code>. Since <code>A::foo()</code> is a pure virtual function, the behavior of your code is undefined.</p>\n<p>C++ language make no guarantees of what kind of \"error\" should occur in such cases. Which means that your expectations of \"linker error\" are completely unfounded. If a programs makes an attempt to perform a virtual call to a pure virtual function the behavior is simply <em>undefined</em>. That is the only thing that can be said here from the C++ language point of view.</p>\n<p>How this undefined behavior will manifest itself in practical implementations depends on the implementation. Undefined behavior is allowed to manifest itself through compile-time errors, for example.</p>\n<p>In your case, your program attempts to make a virtual call to pure virtual function <code>A::foo()</code>. In general case the compiler dispatches virtual calls <em>dynamically</em>, through a run-time mechanism that implements polymorphism (so called <em>virtual method table</em> is the most popular one). In some cases, when compiler can determine the exact type of the object used in the call, it optimizes the code and makes an ordinary direct (non-dynamic) call to a virtual function.</p>\n<p>In practice, if a function pure virtual, its virtual method table entry contains a null pointer. A dynamic call to such function typically leads to run-time error. Meanwhile, a direct (optimized) call to such function typically leads to a compiler or linker error.</p>\n<p>In your example the compiler did not optimize the call. It made a full-fledged dynamic call to <code>A::foo()</code> through the virtual method table. The null pointer in that table triggered the run-time error.</p>\n<p>If you call your pure virtual function directly from the constructor</p>\n<pre><code> A() { foo(); } \n</code></pre>\n<p>a typical compiler will normally make a direct (optimized) call to <code>foo()</code>, which will typically lead to a linker error.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2015-06-30T04:58:25.343", "Score": "2", "CreationDate": "2015-06-30T04:31:16.510", "ParentId": "31129484", "CommentCount": "3", "OwnerUserId": "187690", "LastEditDate": "2015-06-30T04:58:25.343"}, "31129679": {"Id": "31129679", "PostTypeId": "2", "Body": "<p>Your error is result of calling virtual functions from within constructors. The function called is the function in A, not more derived functions. C++ standard, section 12.7.4 states,</p>\n<blockquote>\n<p id=\"so_31129484_31129679_0\">Member functions, including virtual functions (10.3), can be called\n  during construction or destruction (12.6.2). <strong>When a virtual function\n  is called directly or indirectly from a constructor or from a\n  destructor, including during the construction or destruction of the\n  classes non-static data members, and the object to which the call\n  applies is the object (call it x) under construction or destruction,\n  the function called is the final overrider in the constructor's or\n  destructor's class and not one overriding it in a more-derived class.</strong>\n  If the virtual function call uses an explicit class member access\n  (5.2.5) and the object expression refers to the complete object of x\n  or one of that object's base class subobjects but not x or one of its\n  base class subobjects, the behavior is undefined.</p>\n</blockquote>\n<p>Now, you are cheating in your example. You are calling a normal function from your constructor and then a virtual function from your normal function. Change your code to,</p>\n<pre><code>struct A\n{\n    virtual void foo() = 0;\n    A(){ foo(); }\n};\n</code></pre>\n<p>and you'll get your error,</p>\n<pre><code>warning: pure virtual \u2018virtual void A::foo()\u2019 called from constructor [enabled by default]\n_ZN1AC2Ev[_ZN1AC5Ev]+0x1f): undefined reference to `A::foo()'\n</code></pre>\n", "LastActivityDate": "2015-06-30T04:39:52.243", "CommentCount": "0", "CreationDate": "2015-06-30T04:39:52.243", "ParentId": "31129484", "Score": "0", "OwnerUserId": "3427419"}, "31129484": {"ViewCount": "80", "Body": "<p>I wrote the following program with virtual functions:</p>\n<pre><code>struct A\n{\n    virtual void foo() = 0;\n    A(){ init(); }\n    void init(){ foo(); }\n};\n\nstruct B : A\n{\n    virtual void foo(){ }\n};\n\nB a;\n\nint main(){\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/a75c44b81a39f042\" rel=\"nofollow\">DEMO</a></p>\n<p>I thought some linker-error should be ccured becuase there's no implementation of the <code>foo</code> was found. We got runtime error instead. Why? Why not the linker error?</p>\n", "AcceptedAnswerId": "31129599", "Title": "Understanding linker errors", "CreationDate": "2015-06-30T04:18:22.227", "Id": "31129484", "CommentCount": "11", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastActivityDate": "2015-06-30T04:58:25.343", "Score": "1", "Tags": "<c++><virtual>", "AnswerCount": "3"}, "31129608": {"Id": "31129608", "PostTypeId": "2", "Body": "<p><code>B</code> does have an implementation of <code>foo</code> so there's no problem for the linker.</p>\n<p>As far as I know, the fact that <code>A</code> is calling <code>foo</code> at a bad time is something the compiler/linker isn't required to figure out. (And although it might be simple to do such a check in this case, I'm sure we could come up with much more complicated cases that would be harder or perhaps impossible to catch.)</p>\n", "LastActivityDate": "2015-06-30T04:32:22.097", "CommentCount": "2", "CreationDate": "2015-06-30T04:32:22.097", "ParentId": "31129484", "Score": "1", "OwnerUserId": "126027"}});