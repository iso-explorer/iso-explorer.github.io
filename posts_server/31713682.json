post_cb({"31713682": {"CommentCount": "1", "ViewCount": "559", "PostTypeId": "1", "LastEditorUserId": "184741", "CreationDate": "2015-07-30T01:09:53.743", "LastActivityDate": "2015-07-30T09:46:00.420", "Title": "Multiple Declarations in C++", "AcceptedAnswerId": "31713993", "LastEditDate": "2015-07-30T06:14:25.073", "Id": "31713682", "Score": "4", "Body": "<p>In [basic.scope.declarative]p4, one reads</p>\n<blockquote>\n<p id=\"so_31713682_31713682_0\">Given a set of declarations in a single declarative region, each of which specifies the same unqualified name, \u2014 (4.1) they shall all refer to the same entity \u2026</p>\n</blockquote>\n<p>A na\u00efve reading might imply that the following code might be valid because \"both declarations refer to the same entity\":</p>\n<pre><code>int x;\nint x;\n</code></pre>\n<p>One then might remember the one definition rule [basic.def.odr]p1. The above reasoning might apply only to declarations not to definitions. The distinction is spelled out in [basic.def]p2. For example, the following code is certainly valid:</p>\n<pre><code>extern int x;\nextern int x;\n</code></pre>\n<p>The last example in [basic.def]p2 suggests then that the following code should be valid, but it does not compile (using MSVC2015).</p>\n<pre><code>struct B\n{\n    int y;\n};\n\nstruct D : B\n{\n    using B::y;\n    using B::y;\n};\n</code></pre>\n<p><strong>Where is the problem?</strong></p>\n<hr>\n<p>The error message is </p>\n<blockquote>\n<p id=\"so_31713682_31713682_1\">the using-declaration for 'B::y' cannot co-exist with the existing using-declaration for 'B::y'</p>\n</blockquote>\n</hr>", "Tags": "<c++><c++11><language-lawyer>", "OwnerUserId": "2549876", "AnswerCount": "2"}, "31720357": {"ParentId": "31713682", "CommentCount": "0", "Body": "<p>You almost answered your own question by citing namespace.udecl/10. The example underneath (N3936) shows a location where multiple equivalent <code>using</code>-declarations are allowed:</p>\n<pre><code>namespace A {\n    int i;\n}\nnamespace A1 {\n    using A::i;\n    using A::i; // OK: double declaration\n}\nvoid f() {\n    using A::i;\n    using A::i; // error: double declaration\n}\nstruct B {\n    int i;\n};\nstruct X : B {\n    using B::i;\n    using B::i; // error: double member declaration\n};\n</code></pre>\n<p>Multiple <code>using</code>-declarations for a function are also allowed, at namespace <em>and</em> block scope. As to why they are not allowed for variables (objects) at block scope, I have no idea. Multiple equivalent member declarations are probably disallowed for two reasons:</p>\n<ul>\n<li>large potential for initialization order bugs</li>\n<li>it wasn't necessary historically, because the bodies of methods defined inline \"see\" members declared later in the same class (with the introduction of <code>decltype</code> in C++11, this reason is no longer as definitive)</li>\n</ul>\n", "OwnerUserId": "4083309", "PostTypeId": "2", "Id": "31720357", "Score": "0", "CreationDate": "2015-07-30T09:46:00.420", "LastActivityDate": "2015-07-30T09:46:00.420"}, "31713993": {"ParentId": "31713682", "CommentCount": "1", "Body": "<p>This example from [namespace.udecl]p10 is exactly the same as yours:</p>\n<pre><code>struct B {\n   int i;\n};\nstruct X : B {\n   using B::i;\n   using B::i; // error: double member declaration\n};\n</code></pre>\n<p>The error is backed up by [class.mem]p1:</p>\n<blockquote>\n<p id=\"so_31713682_31713993_0\">A member shall not be declared twice in the <em>member-specification</em>,\n  except that a nested class or member class template can be declared\n  and then later defined, and except that an enumeration can be\n  introduced with an <em>opaque-enum-declaration</em> and later redeclared with\n  an <em>enum-specifier</em>.</p>\n</blockquote>\n<p>So you're on the right track. Multiple declarations are OK, as long as they don't break other rules (e.g. one definition, member specifications etc.)</p>\n<p>The following, for example, is fine:</p>\n<pre><code>struct X;\nstruct X;\n</code></pre>\n<p>Or a more complex example:</p>\n<pre><code>struct X \n{\n    struct A;\n    struct A\n    {\n       int y;\n    };\n}; \n\nstruct X;\nstruct X::A;\n</code></pre>\n", "OwnerUserId": "184741", "PostTypeId": "2", "Id": "31713993", "Score": "4", "CreationDate": "2015-07-30T01:53:28.120", "LastActivityDate": "2015-07-30T01:53:28.120"}, "bq_ids": {"n4140": {"so_31713682_31713682_0": {"section_id": 7047, "quality": 1.0, "length": 16}, "so_31713682_31713993_0": {"section_id": 5861, "quality": 1.0, "length": 23}}, "n3337": {"so_31713682_31713682_0": {"section_id": 6792, "quality": 1.0, "length": 16}, "so_31713682_31713993_0": {"section_id": 5631, "quality": 1.0, "length": 23}}, "n4659": {"so_31713682_31713682_0": {"section_id": 8544, "quality": 1.0, "length": 16}, "so_31713682_31713993_0": {"section_id": 7344, "quality": 0.9565217391304348, "length": 22}}}});