post_cb({"25152301": {"CommentCount": "3", "ViewCount": "1243", "PostTypeId": "1", "LastEditorUserId": "2756719", "CreationDate": "2014-08-06T04:35:53.253", "LastActivityDate": "2014-09-02T00:21:40.373", "Title": "What C++14 rule prohibits constexpr functions from making assignments to data members?", "LastEditDate": "2014-08-06T04:56:04.303", "Id": "25152301", "Score": "4", "Body": "<p>My understanding is that this (nonsensical) code is not valid C++14:</p>\n<pre><code>class Point  {\npublic:\n  constexpr double setX(double newX) { return x = newX; }\nprivate:\n  double x;\n};\n</code></pre>\n<p>I'm trying to figure out what part of the (still officially draft) C++14 Standard disallows it. The restrictions on constexpr functions are listed in 7.1.5/2. (Sorry for the mangled formatting. I can't figure out how to beat markdown into making it look right.)</p>\n<blockquote>\n<p id=\"so_25152301_25152301_0\">The definition of a constexpr function shall satisfy the following\n  constraints:</p>\n<ul>\n<li>it shall not be virtual (10.3);</li>\n<li>its return type shall be a literal type;</li>\n<li>each of its parameter types shall be a literal type;</li>\n<li>its function-body shall be = delete, = default, or a  compound-statement that does not contain\n  <ul>\n<li>an asm-definition, </li>\n<li>a goto statement, </li>\n<li>a try-block, or</li>\n<li>a definition of a variable of non-literal type or of static or thread storage duration or for which no initialization is performed.</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>There's nothing there that prohibits assignments to data members. There is such a prohibition in 5.19/2 (bullet 15) (again with mangled formatting, sorry):</p>\n<blockquote>\n<p id=\"so_25152301_25152301_1\">A conditional-expression e is a core constant expression unless the\n  evaluation of e, following the rules of the abstract machine (1.9),\n  would evaluate one of the following expressions:\n  [...]\n  modification of an object (5.17, 5.2.6, 5.3.2) unless it is applied to a non-volatile lvalue of literal type\n  that refers to a non-volatile object whose lifetime began within the evaluation of e;</p>\n</blockquote>\n<p>But I don't see how 5.19 applies to 7.1.5. Can somebody clarify?</p>\n", "Tags": "<c++><constexpr><c++14>", "OwnerUserId": "1426649", "AnswerCount": "2"}, "25153962": {"ParentId": "25152301", "CommentCount": "0", "Body": "<p>If you add an in-class initializer to <code>x</code>, e.g. <code>{}</code>, then it compiles on Clang 3.4 in <code>-std=c++1y</code> mode:</p>\n<pre><code>class Point  {\npublic:\n  constexpr double setX(double newX) { return x = newX; }\n  constexpr double getX() const { return x; }\nprivate:\n  double x {}; // without init: \"error: constexpr function never produces a constant expression [-Winvalid-constexpr]\"\n};\n\nconstexpr Point f()\n{\n    Point p;\n    p.setX(1.0);\n    return p;\n}\n\nint main()\n{\n    auto constexpr p = f();        \n    static_assert(p.getX() == 1.0, \"\");\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/655c408b7884a7ba\" rel=\"nofollow\"><strong>Live Example</strong></a>.</p>\n<p>If you have other constructors for <code>Point</code>, you need to add <code>constexpr Point() = default;</code> in order for it to work.</p>\n", "OwnerUserId": "819272", "PostTypeId": "2", "Id": "25153962", "Score": "3", "CreationDate": "2014-08-06T06:51:06.497", "LastActivityDate": "2014-08-06T06:51:06.497"}, "bq_ids": {"n4140": {"so_25152301_25152301_1": {"section_id": 6185, "quality": 0.875, "length": 28}, "so_25152301_25152301_0": {"section_id": 5419, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_25152301_25152301_0": {"section_id": 5214, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_25152301_25152301_1": {"section_id": 7687, "quality": 0.8125, "length": 26}, "so_25152301_25152301_0": {"section_id": 6841, "quality": 0.7142857142857143, "length": 5}}}, "25152803": {"ParentId": "25152301", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>It is valid C++14. You can modify members of a literal class type as long as the lifetime of the object is contained within the evaluation of the constant expression.</p>\n<p>The use of <code>Point</code> in a constant expression is controversial (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1452\" rel=\"nofollow\">CWG DR 1452</a>), but it is allowed by current implementations. It would be a literal class except that it is not aggregate (\u00a73.9.1/10) because it has a private field (\u00a78.5.1/1). However its construction does not invoke its non-constexpr constructor because it is trivially-constructible. Anyway, this issue is fixed by adding a declaration <code>constexpr Point() = default;</code>.</p>\n<p>\u00a75.19 restricts what can be evaluated in a constant expression. One restriction is that only <code>constexpr</code> functions may be entered. \u00a77.1.5 specifies what functions may be marked <code>constexpr</code>, but note that <code>constexpr</code> functions may contain (in a conditional statement) things that cannot be evaluated in a constant expression.</p>\n<p>See the proposal papers, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html\" rel=\"nofollow\">second</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3597.html\" rel=\"nofollow\">first</a> drafts.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2014-09-02T00:21:40.373", "Id": "25152803", "Score": "4", "CreationDate": "2014-08-06T05:24:00.783", "LastActivityDate": "2014-09-02T00:21:40.373"}});