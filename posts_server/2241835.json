post_cb({"2241878": {"ParentId": "2241835", "CommentCount": "4", "CreationDate": "2010-02-11T02:40:15.560", "OwnerUserId": "235825", "PostTypeId": "2", "Id": "2241878", "Score": "6", "Body": "<p>You can't assign Base to Child, because Child might not be base. To use the typical animal example, what you have here is:</p>\n<pre><code>const Animal animal;\nDog dog;\ndog = animal;\n</code></pre>\n<p>But animal might be a cat, and you certainly can't assign a cat to a dog.</p>\n<p>That being said, you couldn't do it the other way round either:</p>\n<pre><code>const Dog dog;\nAnimal animal;\nanimal = dog;\n</code></pre>\n<p>A dog certainly is an animal, but you have a size issue here. <code>animal</code> takes up <code>sizeof(Animal)</code> space on the stack, but <code>dog</code> takes up <code>sizeof(Dog)</code> space, and those two amounts may be different.</p>\n<p>When working with polymorphism in C++, you need to be working with either references or pointers. For example, the following is fine:</p>\n<pre><code>Dog* const dog;\nAnimal* animal;\nanimal = dog;\n</code></pre>\n<p>Here, the size of a pointer is the same regardless of what it points to, so the assignment is possible. Note that you still need to maintain the correct hierarchy conversions. Even when using a pointer, you can't assign a Base to a Child, because of the reason I explained earlier: A Base may be something entirely different from the Child.</p>\n", "LastActivityDate": "2010-02-11T02:40:15.560"}, "2241865": {"ParentId": "2241835", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2010-02-11T02:37:12.123", "Score": "2", "LastEditorUserId": "12725", "LastEditDate": "2010-02-11T02:49:48.683", "Id": "2241865", "OwnerUserId": "12725", "Body": "<p>Because a base isn't a child.  Consider:</p>\n<pre><code>class Child : public Base \n{ \npublic: \n   SomeFunc();\n};\n\nvoid func() \n{ \n  const Base base; \n  Child child; \n  child = base; \n  child.SomeFunc();     // whatcha gonna call?\n} \n</code></pre>\n<p>UPDATE: TO answer the question in the comment, <code>child.SomeFunc();</code> is perfectly legal -- it's only a problem if th value of <code>child</code> isn't really a Child object.  The compiler cannot allow <code>child = base;</code> because it would create a situation where the legal call fails.</p>\n", "LastActivityDate": "2010-02-11T02:49:48.683"}, "2246604": {"ParentId": "2241835", "CommentCount": "1", "CreationDate": "2010-02-11T18:18:01.303", "OwnerUserId": "65313", "PostTypeId": "2", "Id": "2246604", "Score": "6", "Body": "<p>The code below is the behavior I wanted since the beginning, and it compiles,</p>\n<pre><code>class Base\n{\npublic:\n  void operator = ( const Base&amp; base_)\n  {\n  }\n};\n\nclass Child : public Base\n{\n};\n\nvoid func()\n{\n  const Base base;\n\n  Child child;\n\n  child.Base::operator=(base);\n}\n</code></pre>\n<p>I never knew that you can explicitly call something like:</p>\n<pre><code>  child.Base::operator=(base);\n</code></pre>\n<p>Anyway, I learned a lot. Thank you for all the people that posted answers here.</p>\n", "LastActivityDate": "2010-02-11T18:18:01.303"}, "2241835": {"CommentCount": "4", "AcceptedAnswerId": "2241884", "PostTypeId": "1", "LastEditorUserId": "65313", "CreationDate": "2010-02-11T02:27:53.970", "LastActivityDate": "2010-02-11T19:16:51.827", "LastEditDate": "2010-02-11T17:46:17.620", "ViewCount": "6140", "FavoriteCount": "1", "Title": "C++ How come I can't assign a base class to a child class?", "Id": "2241835", "Score": "5", "Body": "<p>I have code like this:</p>\n<pre><code>class Base\n{\npublic:\n  void operator = (const Base&amp; base_)\n  {\n  }\n};\n\nclass Child : public Base\n{\npublic:\n\n};\n\nvoid func()\n{\n  const Base base;\n  Child child;\n  child = base;\n}\n</code></pre>\n<p>My question is: since Child derives from Base (hence it should inherit Base's operator= ), how come when the statement</p>\n<pre><code>child = base;\n</code></pre>\n<p>is executed, I get a compiler error like this:</p>\n<pre><code>&gt;.\\main.cpp(78) : error C2679: binary '=' : no operator found which takes a right-hand operand of type 'const Base' (or there is no acceptable conversion)\n1&gt;        .\\main.cpp(69): could be 'Child &amp;Child::operator =(const Child &amp;)'\n1&gt;        while trying to match the argument list '(Child, const Base)'\n</code></pre>\n<p>The behavior that I want is for the Child class to recognize that it's being assigned a Base class, and just \"automatically\" call the its parent's operator=.</p>\n<p>Once I added this code to the Child class</p>\n<pre><code>void operator = (const Base&amp; base_)\n{\n  Base::operator=(base_);\n}\n</code></pre>\n<p>then everything compiled fine. Though I dont think this would be good because if I have like 5 different classes that inherit from Base, then I have to repeat the same code in every single derived class.</p>\n<p><strong>NOTE:</strong> My intention for copying the <code>Base</code> to <code>Child</code> is to simply copying the members that are <em>common</em> to both <code>Base</code> and <code>Child</code> (which would be all the members of <code>Base</code>). Even after reading all of the answers below, I really don't see why C++ doesn't allow one to do this, especially if there's an explicit <code>operator=</code> defined in the <code>Base</code> class.</p>\n", "Tags": "<c++><inheritance>", "OwnerUserId": "65313", "AnswerCount": "8"}, "2241863": {"ParentId": "2241835", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2010-02-11T02:36:33.870", "Score": "0", "LastEditorUserId": "115018", "LastEditDate": "2010-02-11T02:42:11.877", "Id": "2241863", "OwnerUserId": "115018", "Body": "<p>The problem is that you can't assign a constant value to a non-constant variable.  If you could, you could potentially modify the constant value by modifying the non-constant variable.  </p>\n<p>Is it necessary that base is const?  I ask because you're really running into two problems: const correctness, and inheritence/polymorphism.</p>\n<p>EDIT: I'm second guessing myself now regarding my first statement.  Any clarification?</p>\n", "LastActivityDate": "2010-02-11T02:42:11.877"}, "2241884": {"ParentId": "2241835", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2010-02-11T02:41:26.687", "Score": "12", "LastEditorUserId": "12711", "LastEditDate": "2010-02-11T02:54:26.490", "Id": "2241884", "OwnerUserId": "12711", "Body": "<p>The standard provides the reason for your specific question in 12.8/10 \"Copying class objects\" (emphasis added):</p>\n<blockquote>\n<p id=\"so_2241835_2241884_0\">Because a copy assignment operator is implicitly declared for a class if not declared by the user, <strong>a base class copy assignment operator is always hidden by the copy assignment operator of a derived class</strong> (13.5.3).</p>\n</blockquote>\n<p>So since there's an implicitly declared <code>operator=(const Child&amp;)</code> when the compiler is performing the name lookup/overload resolution for a <code>Child::operator=()</code>, the <code>Base</code> class's function signature is never even considered (it's hidden).</p>\n", "LastActivityDate": "2010-02-11T02:54:26.490"}, "2241928": {"ParentId": "2241835", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2010-02-11T02:52:03.117", "Score": "1", "LastEditorUserId": "221955", "LastEditDate": "2010-02-11T02:59:02.100", "Id": "2241928", "OwnerUserId": "221955", "Body": "<p>The answer is scarier than I thought.\nYou <em>can</em> do this. The standard evens has a little note about it in section 7.3.3\nThe main problem is that the operator= that gets defined by default in Child hides the operator= from Base so you need to import it back into the class scope using \"using\".</p>\n<p>This compiles OK for me. However I find this idea very scary, and potentially fraught with undefined behaviour if stuff in Child needs to get initialised.</p>\n<pre><code>class Base\n{\npublic:\n  void operator = (const Base&amp; base_)\n  {\n  }\n};\n\nclass Child : public Base\n{\npublic:\nusing Base::operator=;\n\n};\n\nint main()\n{\n  const Base base = Base();\n  Child child;\n  child = base;\n}\n</code></pre>\n<p>EDIT: Made the base const again and avoid \"uninitialised const\" error.</p>\n", "LastActivityDate": "2010-02-11T02:59:02.100"}, "2247042": {"ParentId": "2241835", "CommentCount": "0", "CreationDate": "2010-02-11T19:16:51.827", "OwnerUserId": "14148", "PostTypeId": "2", "Id": "2247042", "Score": "2", "Body": "<p>This isn't actually an answer, but the how-to question has been answered.  This is the why-not.</p>\n<p>Classes should mean something.  There should be useful things you can say about any well-formed object in the class (\"class invariants\"), because that way you can reason about programs on the basis of how a class works.  If a class is just a collection of data members, you can't do that, and have to reason about the program on the basis of each individual data element.</p>\n<p>The proposed assignment operator will change every data member in the base class, but won't touch the ones defined in the child class.  This means one of two things.</p>\n<p>If a Child object is well-formed after another Base object is dumped into its Base component, it means that the additional data members have no real connection with the the Base data members.  In that case, Child isn't really a subtype of Base, and public inheritance is the wrong relation.  Child isn't in a \"is-a\" relation to Base, but rather a \"has-a\" relation.  This is usually expressed by composition (Child has a Base data member), and can also be expressed by private inheritance.</p>\n<p>If a Child object is not well-formed after another Base object is dumped into its Base component, the proposed assignment operator is a really fast and convenient method to mess up a variable.</p>\n<p>For an example, let's have a Mammal base class and two child classes, Cetacean and Bat.  Animal has things like size and weight, and the child classes have fields related to what they eat and how they move.  We assign a Cetacean to a Mammal, which is reasonable (all Cetacean-specific fields are just dropped), and now we assign that Mammal to a Bat.  Suddenly, we've got an twenty-ton bat.</p>\n<p>With a well-designed set of classes, the only way I can conceive of this assignment operator even being thought of is if the child classes have no additional data members, only additional behavior, and even then it's suspect.</p>\n<p>Therefore, my only advice is to redo your class design.  Many people, particularly those familiar with Java and other languages that tend to deep inheritance hierarchies, use inheritance far too much in C++.  C++ generally works best with a large number of base classes and a relatively shallow hierarchy.</p>\n", "LastActivityDate": "2010-02-11T19:16:51.827"}, "bq_ids": {"n4140": {"so_2241835_2241884_0": {"section_id": 660, "quality": 0.9090909090909091, "length": 20}}, "n3337": {"so_2241835_2241884_0": {"section_id": 650, "quality": 0.9090909090909091, "length": 20}}, "n4659": {"so_2241835_2241884_0": {"section_id": 688, "quality": 0.9090909090909091, "length": 20}}}, "2241870": {"ParentId": "2241835", "CommentCount": "4", "CreationDate": "2010-02-11T02:38:49.063", "OwnerUserId": "35829", "PostTypeId": "2", "Id": "2241870", "Score": "1", "Body": "<p>When you don't declare copy assignment explicitly, the C++ compiler will create copy assignment for you . In your case, it would be </p>\n<pre><code>class Child : public Base\n{\npublic:\nChild&amp; operator=(const Child&amp; rhs) { ... }\n\n};\n</code></pre>\n<p>And that's why you get this compiler error. Also, it makes more sense to return a reference to itself when you provide a copy assignment because it will allow you to chain operator together.</p>\n<p>It's not a good idea to declare a copy assignment like this.</p>\n<pre><code>void operator = (const Base&amp; base_)\n{\n  Base::operator=(base_);\n}\n</code></pre>\n<p>I don't see why you only want to copy the base class portion when you do a copy assignment.</p>\n", "LastActivityDate": "2010-02-11T02:38:49.063"}});