post_cb({"6444871": {"Id": "6444871", "PostTypeId": "2", "Body": "<p>To provide a standard reference for the behavior, 7.1.6.4 [dcl.spec.auto] paragraph 6 reads:</p>\n<blockquote>\n<p id=\"so_6443230_6444871_0\">Once the type of a declarator-id has been determined according to 8.3, the type of the declared variable using the declarator-id is determined from the type of its initializer using the rules for template argument deduction. Let T be the type that has been determined for a variable identifier d. Obtain P from T by replacing the occurrences of auto with ... a new invented type template parameter U ... The type deduced for the variable d is then the deduced A determined using the rules of template argument deduction from a function call (14.8.2.1), where P is a function template parameter type and the initializer for d is the corresponding argument. If the deduction fails, the declaration is ill-formed.</p>\n</blockquote>\n<p>So we need to look elsewhere, specifically 14.8.2.1 [tmp.deduct.call] paragraph 2:</p>\n<blockquote>\n<p id=\"so_6443230_6444871_1\">If P is not a reference type: \u2014 If A is an array type, the pointer type produced by the array-to-pointer standard conversion (4.2) is used in place of A for type deduction</p>\n</blockquote>\n<p>For completeness sake, 4.2 [conv.array] paragraph 1:</p>\n<blockquote>\n<p id=\"so_6443230_6444871_2\">An lvalue or rvalue of type \u201carray of N T\u201d or \u201carray of unknown bound of T\u201d can be converted to a prvalue of type \u201cpointer to T\u201d. The result is a pointer to the first element of the array.</p>\n</blockquote>\n<p>To step through it, <code>auto x = arr;</code> creates an imaginary function <code>template&lt;typename P&gt; f(P);</code> and attempts to deduce <code>P</code> from the call <code>f(arr)</code>.  <code>A</code> in this case is <code>array of 10 int</code>, and <code>P</code> is not a reference type, so <code>A</code> becomes <code>pointer to int</code> instead.  Which percolates up the chain back into the final type of <code>x</code>.</p>\n<p>So basically, it is treated as a pointer because the rules say it must.  The behavior is simply more useful this way, since arrays are not assignable.  Otherwise, your <code>auto x = arr;</code> would fail to compile rather than do something useful.</p>\n", "LastEditorUserId": "563765", "LastActivityDate": "2013-08-09T19:40:40.263", "Score": "5", "CreationDate": "2011-06-22T18:41:54.633", "ParentId": "6443230", "CommentCount": "0", "OwnerUserId": "293791", "LastEditDate": "2013-08-09T19:40:40.263"}, "6443230": {"ViewCount": "958", "Body": "<p>See the below example:</p>\n<pre><code>int arr[10];\nint *p = arr; // 1st valid choice\nint (&amp;r)[10] = arr; // 2nd valid choice\n</code></pre>\n<p>Now when we use <code>auto</code> against <code>arr</code> then, it chooses the 1st choice.</p>\n<pre><code>auto x = arr; // x is equivalent to *p\n</code></pre>\n<p>Is there a reason for <a href=\"http://www.ideone.com/pCV3J\" rel=\"noreferrer\">choosing a pointer and not reference</a> for array ?</p>\n", "AcceptedAnswerId": "6443267", "Title": "When auto is used against array, why it's converted to pointer and not reference?", "CreationDate": "2011-06-22T16:22:28.917", "Id": "6443230", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2011-06-22T17:49:54.333", "LastEditorUserId": "33732", "LastActivityDate": "2013-08-09T19:40:40.263", "Score": "18", "OwnerUserId": "514235", "Tags": "<c++><arrays><c++11><language-design>", "AnswerCount": "4"}, "6443256": {"Id": "6443256", "PostTypeId": "2", "Body": "<p><code>auto</code> produces values. It will not produce references. With this in mind, then the pointer is the trivial conversion to a value that the array offers.</p>\n", "LastActivityDate": "2011-06-22T16:24:25.970", "CommentCount": "6", "CreationDate": "2011-06-22T16:24:25.970", "ParentId": "6443230", "Score": "4", "OwnerUserId": "298661"}, "bq_ids": {"n4140": {"so_6443230_6444871_1": {"length": 12, "quality": 1.0, "section_id": 303}, "so_6443230_6444871_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 11}, "so_6443230_6444871_0": {"length": 36, "quality": 0.5806451612903226, "section_id": 5451}}, "n3337": {"so_6443230_6444871_1": {"length": 12, "quality": 1.0, "section_id": 294}, "so_6443230_6444871_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 8}, "so_6443230_6444871_0": {"length": 58, "quality": 0.9354838709677419, "section_id": 5245}}, "n4659": {"so_6443230_6444871_1": {"length": 12, "quality": 1.0, "section_id": 310}, "so_6443230_6444871_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 12}, "so_6443230_6444871_0": {"length": 33, "quality": 0.532258064516129, "section_id": 6889}}}, "6443479": {"Id": "6443479", "PostTypeId": "2", "Body": "<p>For an array <code>arr</code>, the expression <code>arr</code> itself means <code>&amp;arr[0]</code>. This rule comes from C. Therefore, IMO, auto chooses pointer.</p>\n", "LastActivityDate": "2011-06-22T16:45:39.150", "CommentCount": "3", "CreationDate": "2011-06-22T16:45:39.150", "ParentId": "6443230", "Score": "0", "OwnerUserId": "264325"}, "6443267": {"Id": "6443267", "PostTypeId": "2", "Body": "<p>Yes. In that expression, the array decays into pointer type, due to <code>lvalue-to-rvalue</code> conversion.</p>\n<p>If you want <em>array</em> type , not <em>pointer</em> type, then do this:</p>\n<pre><code>auto &amp; x = arr; //now it doesn't decay into pointer type!\n</code></pre>\n<p><code>&amp;</code> in the target type prevents the array from decaying into pointer type!</p>\n<hr>\n<p><code>x</code> is an array and not a pointer, can be proved as:</p>\n<pre><code>void f(int (&amp;a)[10]) \n{\n    std::cout &lt;&lt; \"f() is called. that means, x is an array!\" &lt;&lt; std::endl;\n}\nint main() {\n     int arr[10];\n     auto &amp; x = arr; \n     f(x); //okay iff x is an int array of size 10, else compilation error!\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>f() is called. that means, x is an array!\n</code></pre>\n<p>Demo at ideone : <a href=\"http://www.ideone.com/L2Ifp\" rel=\"noreferrer\">http://www.ideone.com/L2Ifp</a></p>\n<p>Note that <code>f</code> <em>cannot</em> be called with <em>pointer</em> type. It can be called with an <code>int</code> array of size <code>10</code>.  Attempting to call it with <em>any</em> other type, will result in compilation error.</p>\n</hr>", "LastEditorUserId": "415784", "LastActivityDate": "2011-06-22T16:49:16.883", "Score": "24", "CreationDate": "2011-06-22T16:25:05.013", "ParentId": "6443230", "CommentCount": "5", "OwnerUserId": "415784", "LastEditDate": "2011-06-22T16:49:16.883"}});