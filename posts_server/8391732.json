post_cb({"8391732": {"CommentCount": "10", "AcceptedAnswerId": "8392047", "PostTypeId": "1", "LastEditorUserId": "830320", "CreationDate": "2011-12-05T20:54:19.913", "LastActivityDate": "2012-05-08T13:11:08.680", "LastEditDate": "2012-05-08T13:11:08.680", "ViewCount": "839", "FavoriteCount": "1", "Title": "Is -1u valid c++?", "Id": "8391732", "Score": "10", "Body": "<p>Is for example</p>\n<pre><code>size_t x = -1u;\n\nif (x == -1u)\n    ...\n</code></pre>\n<p>valid?</p>\n<p>If this is valid it would prevent a warning.\nof course on a 32 bit system x should be 0xffffffff and on a 64 bit\nsystem it should be 0xffffffffffffffff.</p>\n<p>-Jochen</p>\n", "Tags": "<c++><platform-independent>", "OwnerUserId": "898383", "AnswerCount": "5"}, "8392046": {"ParentId": "8391732", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is likely what you want:</p>\n<pre><code>size_t x = -1ull;\n\nif (x == -((size_t)-1ull))\n    ...\n</code></pre>\n<p><code>x</code> will be set to the largest integer possible, which may not be all bits set. Use ~0 for that.</p>\n", "OwnerUserId": "964135", "LastEditorUserId": "964135", "LastEditDate": "2011-12-05T21:31:53.557", "Id": "8392046", "Score": "0", "CreationDate": "2011-12-05T21:21:55.377", "LastActivityDate": "2011-12-05T21:31:53.557"}, "8392047": {"ParentId": "8391732", "CommentCount": "0", "Body": "<p><code>1u</code> has the type <code>unsigned int</code>.  This is then negated using the unary <code>-</code> operator.  The behavior is as follows:</p>\n<blockquote>\n<p id=\"so_8391732_8392047_0\">The negative of an unsigned quantity is computed by subtracting its value from 2<sup>n</sup>, where n is the number of bits in the promoted operand (C++11 5.3.1/8).</p>\n</blockquote>\n<p><code>-1u</code> is thus guaranteed to give you the largest value representable by <code>unsigned int</code>.</p>\n<p>To get the largest value representable by an arbitrary unsigned type, you can cast <code>-1</code> to that type.  For example, for <code>std::size_t</code>, consider\n <code>static_cast&lt;std::size_t&gt;(-1)</code>.</p>\n", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "8392047", "Score": "6", "CreationDate": "2011-12-05T21:21:58.370", "LastActivityDate": "2011-12-05T21:21:58.370"}, "8391813": {"ParentId": "8391732", "CommentCount": "4", "Body": "<p>While this is <em>technically</em> valid code, you are depending on implementation dependent behavior: overflow handling of converting a negative number to unsigned. However, if you need to meaningful compare a size_t with -1 because the API calls you are using require it, the system is already screwed up but your code is likely to work because they would have had to do the same thing on the other side of the API.</p>\n", "OwnerUserId": "14768", "PostTypeId": "2", "Id": "8391813", "Score": "0", "CreationDate": "2011-12-05T21:00:19.277", "LastActivityDate": "2011-12-05T21:00:19.277"}, "8391986": {"ParentId": "8391732", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Compiler implementation dependant behavior is annoying. You should be able to do this, though:</p>\n<pre><code>size_t x = 0;\nx--;\n\nif ((x+1) == 0)\n</code></pre>\n", "OwnerUserId": "2915", "LastEditorUserId": "964135", "LastEditDate": "2011-12-05T21:36:49.090", "Id": "8391986", "Score": "1", "CreationDate": "2011-12-05T21:16:38.470", "LastActivityDate": "2011-12-05T21:36:49.090"}, "bq_ids": {"n4140": {"so_8391732_8392047_0": {"section_id": 6071, "quality": 0.8, "length": 12}}, "n3337": {"so_8391732_8392047_0": {"section_id": 5839, "quality": 0.8, "length": 12}}, "n4659": {"so_8391732_8392047_0": {"section_id": 7567, "quality": 0.8, "length": 12}}}, "8391816": {"ParentId": "8391732", "CommentCount": "5", "Body": "<p>I've always used ~0U for the purpose of \"unsigned, all bits on\". </p>\n", "OwnerUserId": "291737", "PostTypeId": "2", "Id": "8391816", "Score": "5", "CreationDate": "2011-12-05T21:00:57.660", "LastActivityDate": "2011-12-05T21:00:57.660"}});