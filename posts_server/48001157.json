post_cb({"bq_ids": {"n4140": {"so_48001157_48025071_0": {"length": 13, "quality": 1.0, "section_id": 5442}}, "n3337": {"so_48001157_48025071_0": {"length": 13, "quality": 1.0, "section_id": 5237}}, "n4659": {"so_48001157_48025071_0": {"length": 13, "quality": 1.0, "section_id": 6869}}}, "48025071": {"Id": "48025071", "PostTypeId": "2", "Body": "<p>Yes, this is a bug. </p>\n<p>According to <a href=\"http://www.eel.is/c++draft/dcl.type.elab#1\" rel=\"nofollow noreferrer\">[dcl.type.elab]/1</a>, </p>\n<blockquote>\n<p id=\"so_48001157_48025071_0\">... If an <a href=\"http://www.eel.is/c++draft/dcl.type.elab#nt:elaborated-type-specifier\" rel=\"nofollow noreferrer\"><em>elaborated-type-specifier</em></a> is the sole constituent of a declaration, the declaration is ill-formed unless it is an explicit specialization, an explicit instantiation or it has one of the following forms:</p>\n<ul>\n<li><strong><em>class-key attribute-specifier-seq<sub>opt</sub> identifier</em></strong> ;</li>\n<li><code>friend</code> <em>class-key</em> <code>::</code><sub><em>opt</em></sub> <em>identifier</em> ;</li>\n<li><code>friend</code> <em>class-key</em> <code>::</code><sub><em>opt</em></sub> <em>simple-template-id</em> ;</li>\n<li><code>friend</code> <em>class-key nested-name-specifier identifier</em> ;</li>\n<li><code>friend</code> <em>class-key nested-name-specifier</em> <code>template</code><sub><em>opt</em></sub> <em>simple-template-id</em> ;</li>\n</ul>\n</blockquote>\n<p>your declaration <code>class N1::Other</code> is neither an explicit specialization, nor an explicit instantiation, so it has to have the emphasized form (ignoring those <code>friend</code> declaration). Note no <a href=\"http://www.eel.is/c++draft/expr.prim.id.qual#nt:nested-name-specifier\" rel=\"nofollow noreferrer\"><em>nested-name-specifier</em></a> is allowed before <em>identifier</em> in the emphasized form, so the declaration is ill-formed. The compiler error of Clang in the following example without template shows this problem.</p>\n<pre><code>namespace N {\n    struct S;\n}\nstruct N::S; // error: forward declaration of struct cannot have a nested name specifier\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/vYivUwXYTUWvXfmU\" rel=\"nofollow noreferrer\">LIVE EXAMPLE</a> (BTW, GCC accepts this code and just gives a warning about nothing new to be declared. I guess it is a bug of GCC.)</p>\n<p>Here the  <a href=\"http://www.eel.is/c++draft/temp#nt:template-head\" rel=\"nofollow noreferrer\"><em>template-head</em></a> <code>template &lt;typename&gt;</code> does not help, because <code>class N1::Other</code> itself should form a <em>declaration</em> according to the grammar definition of <em>template-head</em>, thus the paragragh above applies.</p>\n<p>Roughly speaking, a declaration for class in different scope from the scope where a class with the same name is declared should either introduce a new class, in which case <em>nested-name-specifier</em> should not be used, or define the  previously declared class, in which case the grammar forms a <a href=\"http://www.eel.is/c++draft/class#nt:class-specifier\" rel=\"nofollow noreferrer\"><em>class-specifier</em></a> rather than an <em>elaborated-type-specifier</em>, thus the paragraph above does not apply. As a conclusion, this rule is reasonable.</p>\n", "LastEditorUserId": "5376789", "LastActivityDate": "2017-12-29T16:05:10.883", "Score": "1", "CreationDate": "2017-12-29T15:53:25.743", "ParentId": "48001157", "CommentCount": "0", "OwnerUserId": "5376789", "LastEditDate": "2017-12-29T16:05:10.883"}, "48001157": {"ViewCount": "130", "Body": "<p>I have an example1 and an example2, which uses a forward declaration of a class template prefixed with the namespace of the corresponding class template. The first example compiles fine with visual-studio, while the second example does not. I checked the both examples against other compilers (<a href=\"http://rextester.com\" rel=\"nofollow noreferrer\">http://rextester.com</a>). Now I have 2 questions:</p>\n<ul>\n<li><p>Using here a namespace in the forward declaration seems to be illegal. Why exactly? </p></li>\n<li><p>Visual studio (2015 and 2017) seems to allow the forward declaration with the additional namespace in the <strong>first</strong> example, but in the second example not. Is this a bug?</p></li>\n</ul>\n<p><strong>Example 1:</strong> </p>\n<pre><code>#include &lt;vector&gt;\n\nnamespace N1\n{\n    template &lt;typename T&gt; struct MySystem {};\n    template &lt;typename T&gt; class Other {};\n\n    struct MyClass\n    {\n        MyClass() { typename Dependencies::TYPE_A oTYPE_A; }\n\n        struct Dependencies\n        {\n            template &lt;typename&gt;\n            class N1::Other;\n\n            struct TypeX_Dependencies;\n\n            using TYPE_A = N1::MySystem&lt;N1::Other&lt;TypeX_Dependencies&gt;&gt;;\n\n            struct TypeX_Dependencies\n            {\n                using TYPE_A = typename Dependencies::TYPE_A;\n            };\n\n            using TYPE_X = N1::Other&lt;TypeX_Dependencies&gt;;\n        };\n    };\n}\n\nint main(){ return 0; }\n</code></pre>\n<p>c++  (gcc 5.4.0)<br>\n<code>source_file.cpp:15:23: error: invalid use of template-name \u2018N1::Other\u2019 without an argument list class N1::Other;</code> </br></p>\n<p>c++ (clang 3.8.0)<br>\n<code>source_file.cpp:15:23: error: non-friend class member 'Other' cannot have a qualified name class N1::Other;<br>\nsource_file.cpp:15:19: error: forward declaration of class cannot have a nested name specifier class N1::Other;</br></code> </br></p>\n<p>c++ (vc++ 19.00.23506 for x64 / also vs community 2017 15.4.4)<br>\n<code>compiles fine</code></br></p>\n<p><strong>Example 2:</strong> </p>\n<pre><code>#include &lt;vector&gt;\n\nnamespace N1\n{\n    template &lt;typename T&gt; struct MySystem {};\n    template &lt;typename T&gt; class Other {};\n\n    template &lt;typename T&gt;\n    struct MyClass\n    {\n        MyClass() { typename Dependencies::TYPE_A oTYPE_A; }\n\n        struct Dependencies\n        {\n            template &lt;typename&gt;\n            class N1::Other;\n\n            struct TypeX_Dependencies;\n\n            using TYPE_A = N1::MySystem&lt;N1::Other&lt;TypeX_Dependencies&gt;&gt;;\n\n            struct TypeX_Dependencies\n            {\n                using TYPE_A = typename Dependencies::TYPE_A;\n            };\n\n            using TYPE_X = N1::Other&lt;TypeX_Dependencies&gt;;\n        };\n    };\n}\n\nint main(){ return 0; }\n</code></pre>\n<p>c++  (gcc 5.4.0)<br>\n<code>source_file.cpp:16:23: error: invalid use of template-name \u2018N1::Other\u2019 without an argument list class N1::Other;</code> </br></p>\n<p>c++ (clang 3.8.0)<br>\n<code>source_file.cpp:16:23: error: non-friend class member 'Other' cannot have a qualified name class N1::Other;<br>\nsource_file.cpp:16:19: error: forward declaration of class cannot have a nested name specifier class N1::Other;</br></code> </br></p>\n<p>c++ (vc++ 19.00.23506 for x64 / also vs community 2017 15.4.4)<br>\n<code>source_file.cpp(16): error C3855: 'N1::Other': template parameter 'T' is incompatible with the declaration<br>\nsource_file.cpp(24): note: see reference to class template instantiation 'N1::MyClass&lt;T&gt;::Dependencies' being compiled<br>\nsource_file.cpp(29): note: see reference to class template instantiation 'N1::MyClass&lt;T&gt;' being compiled<br>\nsource_file.cpp(20): error C3203: 'Other': unspecialized class template can't be used as a template argument for template parameter 'T', expected a real type</br></br></br></code> </br></p>\n", "AcceptedAnswerId": "48025071", "Title": "forward declaration of a class template including a namespace causes compile-error", "CreationDate": "2017-12-28T03:09:20.490", "LastActivityDate": "2017-12-29T16:05:10.883", "CommentCount": "8", "LastEditDate": "2017-12-29T12:34:51.297", "PostTypeId": "1", "LastEditorUserId": "9098890", "Id": "48001157", "Score": "2", "OwnerUserId": "9098890", "Tags": "<c++><templates><compiler-errors><namespaces><forward-declaration>", "AnswerCount": "1"}});