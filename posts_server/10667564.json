post_cb({"10667694": {"ParentId": "10667564", "CommentCount": "6", "Body": "<p>I think you're fine. Here's 3.6.3 on \"Termination\":</p>\n<blockquote>\n<p id=\"so_10667564_10667694_0\">If the completion of the constructor or dynamic initialization of an object with static storage duration is sequenced before that of another, the completion of the destructor of the second is sequenced before the initiation of the destructor of the first.</p>\n</blockquote>\n<p>Suppose you have the following setup:</p>\n<pre><code>struct A;\n\nstruct B\n{\n    static B &amp; get() { static B impl; return impl; }\n    void registrate(A *);\n\nprivate:\n    B() { /* complex stuff */ }\n    // ...\n};\n\nstruct A { A() { B::get().registrate(this); } };\n\nA a1;\n</code></pre>\n<p>Now whatever happens, the first constructor of a static <code>A</code>-type object will call <code>B::get()</code>, which sequences the construction of the static <code>impl</code> object before the completion of the first <code>A</code>-constructor. By the above clause, this guarantees that the destructor of the <code>B impl</code>-object is sequenced <em>after</em> all the <code>A</code>-destructors.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "10667694", "Score": "4", "CreationDate": "2012-05-19T18:11:23.567", "LastActivityDate": "2012-05-19T18:11:23.567"}, "10667588": {"ParentId": "10667564", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The <code>B</code> instance is static, so it will outlive any <code>A</code> instance created after the <code>B</code> singleton has been created. </p>\n", "OwnerUserId": "661519", "LastEditorUserId": "661519", "LastEditDate": "2012-05-19T18:02:01.190", "Id": "10667588", "Score": "2", "CreationDate": "2012-05-19T17:54:07.887", "LastActivityDate": "2012-05-19T18:02:01.190"}, "10667564": {"CommentCount": "3", "ViewCount": "257", "PostTypeId": "1", "LastEditorUserId": "712302", "CreationDate": "2012-05-19T17:51:12.820", "LastActivityDate": "2012-05-19T18:39:29.647", "Title": "How to enforce calling order of destructors", "AcceptedAnswerId": "10667694", "LastEditDate": "2012-05-19T18:39:29.647", "Id": "10667564", "Score": "5", "Body": "<p>I am trying to get the following setup right:</p>\n<p>A given application (with multiple source files, compilation units) has global variables of type <code>class A</code> defined in many compilation units.\nThese should be \"managed\" by a new to introduce <code>class B</code> (where only 1 instance should exist) in the sense that upon creation they \"register\" themselves at instance of class B and at destruction \"sign off\".</p>\n<p>Setting the thing up for the constructors to work is fairly straight-forward. One can use:</p>\n<p><code>types.h</code>:</p>\n<pre><code>class B {\n  static B&amp; Instance() {\n    static B singleton;\n    return singleton;\n  }\n  void registerA( const A&amp; a ) { \n  // whatever\n  }\n};\n\n\nclass A {\n  A() { B::Instance().registerA( this ); }\n};\n</code></pre>\n<p>How to get the destructors right? If using:</p>\n<pre><code>class A {\n  A() { B::Instance().registerA( this ); }\n  ~A() { B::Instance().signoffA( this ); }\n};\n</code></pre>\n<p>then the destructor of <code>B</code> might be called before the destructor of <code>A</code>.\nThen the instance of class <code>A</code> signs off at a just newly created instance of <code>B</code>.</p>\n<p>The test case would be a multi source file setup with definitions of instances of <code>class A</code> in a namespace:</p>\n<p><code>file1.cc</code></p>\n<pre><code>#include \"types.h\"\nnamespace C {\n   A a;\n}\n</code></pre>\n<p><code>file2.cc</code></p>\n<pre><code>#include \"types.h\"\nnamespace C {\n   A b;\n}\n</code></pre>\n<p>I guess on can do such thing easily with Boost smart pointers. However, if possible I would like to avoid using additional libraries to keep dependence as low as possible.</p>\n<p>One thing that might help: All global variables are in a named namespace.</p>\n", "Tags": "<c++><constructor><destructor>", "OwnerUserId": "712302", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_10667564_10667694_0": {"section_id": 7156, "quality": 1.0, "length": 19}}, "n3337": {"so_10667564_10667694_0": {"section_id": 6900, "quality": 1.0, "length": 19}}, "n4659": {"so_10667564_10667694_0": {"section_id": 8663, "quality": 1.0, "length": 19}}}});