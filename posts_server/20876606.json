post_cb({"bq_ids": {"n4140": {"so_20876606_20876606_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 7240}, "so_20876606_20876606_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 7241}}, "n3337": {"so_20876606_20876606_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 6984}, "so_20876606_20876606_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 6985}}, "n4659": {"so_20876606_20876606_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 8749}, "so_20876606_20876606_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 8750}}}, "20876786": {"Id": "20876786", "PostTypeId": "2", "Body": "<p>It's because <code>D</code> is derived from <code>B</code> using <em>virtual inheritance</em>. This means if you define yet another object type, derived from <code>D</code> as well as <code>B</code> (again virtually),</p>\n<pre><code>struct E : D , virtual B\n{ /*...*/ };\n</code></pre>\n<p>then the <code>B</code> subobject will be present in <code>E</code> objects <em>only once</em>, not twice. Hence the <code>D</code> subobject of an <code>E</code> object may not contain the <code>B</code> subobject and therefore enjoy relaxed alignment requirements. (The <code>E</code> object as a whole would still be subject to the full alignment requirement.)</p>\n", "LastActivityDate": "2014-01-02T05:16:58.030", "CommentCount": "0", "CreationDate": "2014-01-02T05:16:58.030", "ParentId": "20876606", "Score": "0", "OwnerUserId": "777186"}, "20876606": {"ViewCount": "134", "Body": "<p>C+11 [basic.align] says:</p>\n<blockquote>\n<p id=\"so_20876606_20876606_0\">An object type imposes an alignment requirement on every object of that type; stricter alignment can be requested using the alignment speci\ufb01er</p>\n</blockquote>\n<p>Then shortly after gives an example:</p>\n<pre><code>struct B { long double d; };\nstruct D : virtual B { char c; }\n</code></pre>\n<p>And says the following of the example:</p>\n<blockquote>\n<p id=\"so_20876606_20876606_1\">When D is the type of a complete object, it will have a subobject of type B, so it must be aligned appropriately for a long double. If D appears as a subobject of another object that also has B as a virtual base class, the B subobject might be part of a di\ufb00erent subobject, reducing the alignment requirements on the D subobject.</p>\n</blockquote>\n<p>So what of the alignment requirement imposed upon all objects with object type D? I understand the D subobject to have object type D, which would make it subject to this same requirement. How can the appearance of D as a subobject remove these requirements when they apply to all subobjects? Or should I understand this to mean that complete D objects have further requirements to those imposed by the object type and that these requirements may be weakened when D appears as a subobject?</p>\n", "Title": "C++11 subobject alignment", "CreationDate": "2014-01-02T04:59:52.373", "LastActivityDate": "2014-01-02T05:20:21.360", "CommentCount": "0", "PostTypeId": "1", "Id": "20876606", "Score": "1", "OwnerUserId": "3152450", "Tags": "<c++><c++11><memory-alignment>", "AnswerCount": "2"}, "20876812": {"Id": "20876812", "PostTypeId": "2", "Body": "<p>The hypothetical class inheriting that \"another object\" that has <code>D</code> as a base, will still have that strictest alignment requirement. It's <em>just</em> the <code>D</code> subobject that may be relaxed, as the <code>B</code> context gets taken away from it. It's just quibbling: no loosening on the final object.</p>\n", "LastActivityDate": "2014-01-02T05:20:21.360", "CommentCount": "2", "CreationDate": "2014-01-02T05:20:21.360", "ParentId": "20876606", "Score": "0", "OwnerUserId": "560648"}});