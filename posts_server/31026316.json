post_cb({"31026708": {"Id": "31026708", "PostTypeId": "2", "Body": "<p>The problem with your current union is that it does not specify which member should initially be active.</p>\n<p>C++11 does have a feature called <em>anonymous union</em> in which no member is active initially, and you activate each one as needed. This feature is essential for implementing a Variant-like object as you are trying to do, if there were no types in the list with non-trivial constructors.</p>\n<p>However your union is not anonymous because it has a named instance <code>value</code>.</p>\n<p>If a non-anonymous union contains any member with a non-trivial constructor (such as your <code>glm</code> classes), then that union <em>must</em> have a constructor which initializes exactly one of the members.  (Even providing a <em>brace-or-equal-initializer</em> instead is not sufficient).</p>\n<hr>\n<p>Another option for you, besides Barry's fine suggestion, is to switch to using the anonymous union:</p>\n<pre><code>union\n{\n    float f;\n    int i;\n    glm::vec2 v2;\n    glm::vec3 v3;\n    glm::vec4 v4;\n    glm::mat4 m4;\n};\n// ^^^^^ no name\n</code></pre>\n<p>When this happens, <code>f</code>, <code>i</code>, <code>v2</code> etc. are \"promoted\" up to be names at the level of <code>UniformVariant</code>. You can now write:</p>\n<pre><code>UniformVariant v;\nv.i = 1;\n</code></pre>\n<p>To explain the initialization again: when a struct contains an anonymous union, it actually does not initialize any of the members. You must manually construct and destruct a member when you are using it.</p>\n<p>For primitive types like <code>int</code> you can just activate them by assigning to them, and no deactivation is needed. But for class types you must use placement-new and destructor calls, for example:</p>\n<pre><code>new(&amp;v2) glm::vec2(...args...);\n</code></pre>\n<p>and when you are done with that member:</p>\n<pre><code>v2.~vec2();\n</code></pre>\n<p>To avoid mistakes, you probably want to make the union be in the <code>private</code> section and give <code>X</code> member functions for setting the active member.</p>\n</hr>", "LastEditorUserId": "1505939", "LastActivityDate": "2015-06-24T12:49:47.657", "Score": "1", "CreationDate": "2015-06-24T12:33:58.463", "ParentId": "31026316", "CommentCount": "0", "LastEditDate": "2015-06-24T12:49:47.657", "OwnerUserId": "1505939"}, "bq_ids": {"n4140": {"so_31026316_31026693_0": {"length": 28, "quality": 0.8, "section_id": 5914}}, "n3337": {"so_31026316_31026693_0": {"length": 28, "quality": 0.8, "section_id": 5686}}, "n4659": {"so_31026316_31026693_0": {"length": 28, "quality": 0.8, "section_id": 7406}}}, "31026316": {"ViewCount": "899", "Body": "<p>Here's my tagged union:</p>\n<pre><code>struct UniformVariant\n{\n    enum class UNIFORM_TYPE {FLOAT, INT32, VEC2, VEC3, VEC4, MAT4} type;\n    union\n    {\n        float f;\n        int i;\n        glm::vec2 v2;\n        glm::vec3 v3;\n        glm::vec4 v4;\n        glm::mat4 m4;\n    } value;\n};\n</code></pre>\n<p>If I try to use it like so:</p>\n<pre><code>void some_function()\n{\n    UniformVariant v;\n    some_other_function(v);\n}\n</code></pre>\n<p>I get a compilation error <code>use of deleted function 'UniformVariant::UniformVariant()'</code></p>\n<p>It further says that it was implicitly deleted because the default definition would be ill-formed. So I've tried adding a constructor to the <code>UniformVariant</code></p>\n<pre><code>UniformVariant() : value(0.0f), type(UNIFORM_TYPE::FLOAT) { };\n</code></pre>\n<p>But similar issues. I believe it has to do with the inclusion of class types in the union; but I can't figure out the syntax to use this correctly.</p>\n", "AcceptedAnswerId": "31026693", "Title": "How do I create an instance of this tagged union? Compiler errors about deleted constructor", "CreationDate": "2015-06-24T12:16:55.660", "Id": "31026316", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2015-06-24T12:49:47.657", "Score": "3", "OwnerUserId": "1862823", "Tags": "<c++>", "AnswerCount": "2"}, "31026693": {"Id": "31026693", "PostTypeId": "2", "Body": "<p>From a note in [class.union]:</p>\n<blockquote>\n<p id=\"so_31026316_31026693_0\">If any non-static data member\n  of a union has a non-trivial default constructor (12.1), copy constructor (12.8), move constructor (12.8),\n  copy assignment operator (12.8), move assignment operator (12.8), or destructor (12.4), the corresponding\n  member function of the union must be user-provided or it will be implicitly deleted (8.4.3) for the union.</p>\n</blockquote>\n<p>One of the types in that union has a non-trivial default constructor, so you can't default-construct the union. Consider this simpler reproduction:</p>\n<pre><code>struct X {\n    X() { }  \n};\n\nstruct Y {\n    union {\n        float f;\n        X x;\n    } value;\n};\n\nint main()\n{\n    Y y;\n}\n</code></pre>\n<p><code>X</code> has a non-trivial default constructor, so <code>Y::Y()</code> is implicitly deleted because the anonymous union default constructor is implicitly deleted.</p>\n<p>However, you can just provide your own default constructor for that union:</p>\n<pre><code>union U {\n    U() : f(0.f) { }\n\n    float f;\n    X x;\n} value;\n</code></pre>\n<p>And now the example compiles.</p>\n<p>However, if you're just implementing your own tagged union, I would highly recommend using <a href=\"http://www.boost.org/doc/libs/1_58_0/doc/html/variant.html\" rel=\"noreferrer\">Boost.Variant</a>. It's quite useful and solves exactly this problem. </p>\n", "LastActivityDate": "2015-06-24T12:33:16.773", "Score": "6", "CreationDate": "2015-06-24T12:33:16.773", "ParentId": "31026316", "CommentCount": "1", "OwnerUserId": "2069064"}});