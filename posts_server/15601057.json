post_cb({"15601057": {"CommentCount": "2", "AcceptedAnswerId": "15601145", "PostTypeId": "1", "LastEditorUserId": "1932150", "CreationDate": "2013-03-24T16:36:01.213", "LastActivityDate": "2013-03-24T16:55:17.860", "LastEditDate": "2013-03-24T16:48:04.683", "ViewCount": "420", "FavoriteCount": "1", "Title": "c++ template function overlading argument deduction with const argument", "Id": "15601057", "Score": "1", "Body": "<p>I am having the following setup:</p>\n<pre><code>template &lt;typename T&gt;\nvoid foo(T&amp; t);\nvoid foo(const int&amp; t);\n\nvoid f()\n{\n    int i;\n    foo(i); //Unresolved reference to \"void foo&lt;int&gt;(int &amp;)\"\n    foo(const_cast&lt;const int&amp;&gt;(i)); //Unresolved reference to \"void foo(int const &amp;)\"\n}\n</code></pre>\n<p>In the first call to foo, the compiler tries to call the template version, since the argument of the non-template one does not match the type of <strong>i</strong>. In the second call the non-template version is called. I am using the Microsoft C++ compiler version 10. Is this standard behavior? If the type is not exactly matched, even if it only has a const modifier, then the template function is called?</p>\n<p>EDIT: I know those two functions don't have definition, I am just pointing out what the linker complains about, to make it more clear what the compiler wants to call.</p>\n", "Tags": "<c++><templates><overloading>", "OwnerUserId": "324204", "AnswerCount": "3"}, "15601139": {"ParentId": "15601057", "CommentCount": "1", "Body": "<p>This should work</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nvoid foo(T&amp; t) {}\nvoid foo(const int&amp; t){}\n\nvoid f() \n{\n    int i;\n    foo(i); //Unresolved reference to \"void foo&lt;int&gt;(int &amp;)\"\n    foo(const_cast&lt;const int&amp;&gt;(i)); //Unresolved reference to \"void foo(int const &amp;);\n}\n\nint main()\n{\n    f();\n}\n</code></pre>\n", "OwnerUserId": "2182394", "PostTypeId": "2", "Id": "15601139", "Score": "-1", "CreationDate": "2013-03-24T16:43:41.643", "LastActivityDate": "2013-03-24T16:43:41.643"}, "15601145": {"ParentId": "15601057", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_15601057_15601145_0\">Is this standard behavior? If the type is not exactly matched, even if it only has a const modifier, then the template function is called?</p>\n</blockquote>\n<p>Yes,  that is well-defined by the Standard.</p>\n<p>If there is no EXACT match, the template is used, because instantiated template version is always a <em>better</em> match than the one which requires conversion (even be it <code>int &amp;</code> to <code>int const&amp;</code> conversion).</p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2013-03-24T16:49:35.020", "Id": "15601145", "Score": "2", "CreationDate": "2013-03-24T16:44:11.807", "LastActivityDate": "2013-03-24T16:49:35.020"}, "bq_ids": {"n4140": {"so_15601057_15601166_0": {"section_id": 603, "quality": 0.85, "length": 17}, "so_15601057_15601166_1": {"section_id": 603, "quality": 0.75, "length": 6}, "so_15601057_15601166_2": {"section_id": 603, "quality": 0.9259259259259259, "length": 25}, "so_15601057_15601166_3": {"section_id": 111, "quality": 1.0, "length": 5}}, "n3337": {"so_15601057_15601166_0": {"section_id": 593, "quality": 0.85, "length": 17}, "so_15601057_15601166_1": {"section_id": 593, "quality": 0.75, "length": 6}, "so_15601057_15601166_2": {"section_id": 593, "quality": 0.9259259259259259, "length": 25}, "so_15601057_15601166_3": {"section_id": 106, "quality": 1.0, "length": 5}}, "n4659": {"so_15601057_15601166_0": {"section_id": 629, "quality": 0.85, "length": 17}, "so_15601057_15601166_1": {"section_id": 629, "quality": 0.75, "length": 6}, "so_15601057_15601166_2": {"section_id": 629, "quality": 0.9259259259259259, "length": 25}, "so_15601057_15601166_3": {"section_id": 115, "quality": 1.0, "length": 5}}}, "15601166": {"ParentId": "15601057", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong>Yes</strong>, this behavior is correct according to the C++11 Standard.</p>\n<p>In the first case, the argument is a reference to a non-<code>const</code> integer. Both overloads are viable to resolve this call, but the function template allows a perfect match, while the non-template overload requires a qualification conversion.</p>\n<p>In the second case, both are a perfect match, but one of the overloads is <strong>not</strong> a function template, and therefore it is a better candidate than the function template. Per \u00a7 13.3.3/1, in fact:</p>\n<blockquote>\n<p id=\"so_15601057_15601166_0\">Given these definitions, <strong>a viable function F1 is defined to be a better function than another viable function\n  F2 if</strong> for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</p>\n<p id=\"so_15601057_15601166_1\">\u2014 for some argument j, ICSj(F1) is a better conversion sequence than ICSj(F2), or, if not that,</p>\n<p id=\"so_15601057_15601166_2\">\u2014 the context is an initialization by user-defined conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the\n  standard conversion sequence from the return type of F1 to the destination type (i.e., the type of the\n  entity being initialized) is a better conversion sequence than the standard conversion sequence from\n  the return type of F2 to the destination type. [ ... ] or, if not that,</p>\n<p id=\"so_15601057_15601166_3\">\u2014 <strong>F1 is a non-template function and F2 is a function template specialization</strong>, or, if not that,</p>\n<p id=\"so_15601057_15601166_4\">\u2014 [...]</p>\n</blockquote>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-03-24T16:55:17.860", "Id": "15601166", "Score": "4", "CreationDate": "2013-03-24T16:46:09.500", "LastActivityDate": "2013-03-24T16:55:17.860"}});