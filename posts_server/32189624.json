post_cb({"32189624": {"AcceptedAnswerId": "32190132", "OwnerUserId": "3699691", "LastActivityDate": "2015-09-24T10:49:07.090", "CreationDate": "2015-08-24T18:53:15.053", "Score": "5", "LastEditDate": "2015-08-24T20:18:07.473", "CommentCount": "3", "Title": "Memory-layout compatibility between C and C++", "AnswerCount": "5", "PostTypeId": "1", "Tags": "<c++><c>", "Body": "<p>I'm building a <strong>C++</strong> library which uses many functions and <code>struct</code>'s defined in a <strong>C</strong> library. To avoid porting any code to C++, I add the typical conditional preprocessing to the C header files. For example,</p>\n<pre><code>//my_struct.h of the C library\n#include &lt;complex.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n  double d1,d2,d3;\n#ifdef __cplusplus\n  std::complex&lt;double&gt; z1,z2,z3;\n  std::complex&lt;double&gt; *pz;\n#else\n  double complex z1,z2,z3;\n  double complex *pz;\n#endif\n  int i,j,k;\n} my_struct;\n\n//Memory allocating + initialization function\nmy_struct *\nalloc_my_struct(double);\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>\n<p>The implementation of <code>alloc_my_struct()</code> is compiled in <strong>C</strong>. It simply allocates memory via <code>malloc()</code> and initializes members of <code>my_struct</code>. </p>\n<p>Now when I do the following in my <strong>C++</strong> code,</p>\n<pre><code>#include \"my_struct.h\"\n...\n  my_struct *const ms = alloc_my_struct(2.);\n</code></pre>\n<p>I notice that <code>*ms</code> always have the expected memory layout, i.e., any access such as <code>ms-&gt;z1</code> evaluates to the expected value. I find this really cool considering that (CMIIW) the memory layout of <code>my_struct</code> during allocation is decided by the C compiler (in my case <code>gcc -std=c11</code>), while during access by the C++ compiler (in my case <code>g++ -std=c++11</code>).</p>\n<p>My question is : Is this compatibility standardized? If not, is there any way around it?</p>\n<p><strong>NOTE</strong> : I don't have enough knowledge to argue against alignment, padding, and other implementation-defined specifics. But it is noteworthy that the GNU scientific library, which is C-compiled, is implementing the same approach (although their <code>struct</code>s do not involve C99 complex numbers) for use in C++. On the other hand, I've done sufficient research to conclude that C++11 guarantees layout compatibility between C99 <code>double complex</code> and <code>std::complex&lt;double&gt;</code>.</p>\n", "Id": "32189624", "ViewCount": "605", "LastEditorUserId": "3699691"}, "32190132": {"PostTypeId": "2", "ParentId": "32189624", "Body": "<p>C and C++ do share memory layout rules. In both languages structs are placed in memory in the same way. And even if C++ did want to do things a little differently, placing the struct inside <code>extern \"C\" {}</code> guarantees C layout.</p>\n<p>But what your code is doing relies on C++ std::complex and C99 complex to be the same.</p>\n<p>So see:</p>\n<ul>\n<li><a href=\"https://gcc.gnu.org/ml/libstdc++/2007-02/msg00161.html\" rel=\"nofollow noreferrer\">https://gcc.gnu.org/ml/libstdc++/2007-02/msg00161.html</a></li>\n<li><a href=\"https://stackoverflow.com/questions/10540228/c-complex-numbers-in-c\">C Complex Numbers in C++?</a></li>\n</ul>\n", "CreationDate": "2015-08-24T19:24:03.873", "Score": "5", "LastEditDate": "2017-05-23T11:51:54.140", "CommentCount": "7", "Id": "32190132", "OwnerUserId": "13422", "LastEditorUserId": "-1", "LastActivityDate": "2015-08-24T19:26:04.557"}, "32189924": {"PostTypeId": "2", "ParentId": "32189624", "Body": "<p>It may not always be identical!</p>\n<p>In this case looks like <code>sizeof(std::complex&lt;double&gt;)</code> is identical to <code>sizeof(double complex)</code>.\nAlso pay attention to the fact that the compilers may (or may not) add padding to the structs to make them aligned to a specific value, based on the optimization configuration. And the padding may not always be identical resulting in different structure sizes (between C and c++).</p>\n<p>Links to related posts:</p>\n<p><a href=\"https://stackoverflow.com/questions/27832888/c-c-struct-memory-layout-equivalency\">C/C++ Struct memory layout equivalency</a></p>\n<blockquote>\n<p id=\"so_32189624_32189924_0\">I would add compiler-specific attributes to \"pack\" the fields,\n  thereby guaranteeing all the ints are adjacent and compact. This is\n  less about C vs. C++ and more about the fact that you are likely using\n  two \"different\" compilers when compiling in the two languages, even if\n  those compilers come from a single vendor.</p>\n<p id=\"so_32189624_32189924_1\">Adding a constructor will not change the layout (though it will make\n  the class non-POD), but adding access specifiers like private between\n  the two fields may change the layout (in practice, not only in\n  theory).</p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/questions/2748995/c-struct-memory-layout\">C struct memory layout?</a></p>\n<blockquote>\n<p id=\"so_32189624_32189924_2\">In C, the compiler is allowed to dictate some alignment for every\n  primitive type. Typically the alignment is the size of the type. But\n  it's entirely implementation-specific.</p>\n<p id=\"so_32189624_32189924_3\">Padding bytes are introduced so every object is properly aligned.\n  Reordering is not allowed.</p>\n<p id=\"so_32189624_32189924_4\">Possibly every remotely modern compiler implements #pragma pack which\n  allows control over padding and leaves it to the programmer to comply\n  with the ABI. (It is strictly nonstandard, though.)</p>\n<blockquote>\n<p id=\"so_32189624_32189924_8\">From C99 \u00a76.7.2.1:</p>\n<p id=\"so_32189624_32189924_9\">12 Each non-bit-field member of a structure or union object is aligned\n    in an implementation- defined manner appropriate to its type.</p>\n<p id=\"so_32189624_32189924_10\">13 Within a structure object, the non-bit-field members and the units\n    in which bit-fields reside have addresses that increase in the order\n    in which they are declared. A pointer to a structure object, suitably\n    converted, points to its initial member (or if that member is a\n    bit-field, then to the unit in which it resides), and vice versa.\n    There may be unnamed padding within a structure object, but not at its\n    beginning.</p>\n</blockquote>\n</blockquote>\n", "CreationDate": "2015-08-24T19:10:56.297", "Score": "3", "LastEditDate": "2015-08-24T19:22:32.003", "CommentCount": "0", "Id": "32189924", "OwnerUserId": "5218277", "LastEditorUserId": "5218277", "LastActivityDate": "2015-08-24T19:22:32.003"}, "32189991": {"PostTypeId": "2", "ParentId": "32189624", "Body": "<p>Your program has undefined behaviour: your definitions of <code>my_struct</code> are not lexically identical.</p>\n<p>You're gambling that alignment, padding and various other things will not change between the two compilers, which is bad enough\u2026 but since this is UB anything could happen even if it were true!</p>\n", "CreationDate": "2015-08-24T19:15:40.760", "Score": "3", "CommentCount": "1", "Id": "32189991", "OwnerUserId": "560648", "LastActivityDate": "2015-08-24T19:15:40.760"}, "32190051": {"PostTypeId": "2", "ParentId": "32189624", "Body": "<p>Also note that by <code>malloc()</code> a struct with C++ object (<code>std::complex&lt;double&gt;</code>) you skipped the ctor and this is also UB - even if you expect the ctor is empty or just zero the value and harmless to be skipped, you can't complain if this breaks. So your program work is by pure luck.</p>\n", "CreationDate": "2015-08-24T19:19:08.303", "Score": "2", "LastEditDate": "2015-08-24T19:32:08.043", "CommentCount": "0", "Id": "32190051", "OwnerUserId": "1094101", "LastEditorUserId": "1094101", "LastActivityDate": "2015-08-24T19:32:08.043"}, "32759314": {"PostTypeId": "2", "ParentId": "32189624", "Body": "<p>In general, C and C++ have compatible struct layouts, because the layout is dictated by the platform's ABI rules, not just by the language, and (for most implementations) C and C++ follow the same ABI rules for type sizes, data layout, calling conventions etc.</p>\n<p>C++11 even defined a new term, <em>standard-layout</em>, which means the type will have a compatible layout to a similar type in C. That means it can't use virtual functions, private data members, multiple inheritance (and a few other things). A C++ standard-layout type should have the same layout as an equivalent C type.</p>\n<p>As noted in other answers, your specific code is not safe in general because <code>std::complex&lt;double&gt;</code> and <code>complex double</code> are <em>not</em> equivalent types, and there is no guarantee that they are layout-compatible. <strong>However</strong> GCC's C++ standard library ensures it will work because <code>std::complex&lt;double&gt;</code> and <code>std::complex&lt;float&gt;</code> are implemented in terms of the underlying C types. Instead of containing two double, GCC's <code>std::complex&lt;double&gt;</code> has a single member of type <code>__complex__ double</code>, which the compiler implements identically to the equivalent C type.</p>\n<p>GCC does this specifically to support code like yours, because it's a reasonable thing to want to do.</p>\n<p>So combining GCC's special efforts for <code>std::complex</code> with the <em>standard-layout</em> rules and the platform ABI, means that your code will work with that implementation.</p>\n<p><strong>This is not necessarily portable to other C++ implementations.</strong></p>\n", "CreationDate": "2015-09-24T10:42:35.550", "Score": "2", "LastEditDate": "2015-09-24T10:49:07.090", "CommentCount": "2", "Id": "32759314", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastActivityDate": "2015-09-24T10:49:07.090"}, "bq_ids": {"n3337": {"so_32189624_32189924_7": {"quality": 0.575, "length": 23, "section_id": 5650}, "so_32189624_32189924_10": {"quality": 0.575, "length": 23, "section_id": 5650}}}});