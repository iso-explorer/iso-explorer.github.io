post_cb({"bq_ids": {"n4140": {"so_1689195_1689267_1": {"length": 5, "quality": 1.0, "section_id": 7008}, "so_1689195_1689267_4": {"length": 29, "quality": 0.90625, "section_id": 7009}, "so_1689195_1689267_2": {"length": 17, "quality": 1.0, "section_id": 7008}, "so_1689195_1689267_0": {"length": 24, "quality": 0.96, "section_id": 7008}, "so_1689195_1689267_3": {"length": 19, "quality": 1.0, "section_id": 7008}}, "n3337": {"so_1689195_1689267_4": {"length": 31, "quality": 0.96875, "section_id": 6755}, "so_1689195_1689267_2": {"length": 17, "quality": 1.0, "section_id": 6754}, "so_1689195_1689267_0": {"length": 24, "quality": 0.96, "section_id": 6754}, "so_1689195_1689267_3": {"length": 19, "quality": 1.0, "section_id": 6754}, "so_1689195_1689267_1": {"length": 5, "quality": 1.0, "section_id": 6754}}, "n4659": {"so_1689195_1689267_4": {"length": 29, "quality": 0.90625, "section_id": 8506}, "so_1689195_1689267_2": {"length": 17, "quality": 1.0, "section_id": 8505}, "so_1689195_1689267_0": {"length": 23, "quality": 0.92, "section_id": 8505}, "so_1689195_1689267_3": {"length": 19, "quality": 1.0, "section_id": 8505}, "so_1689195_1689267_1": {"length": 5, "quality": 1.0, "section_id": 8505}}}, "1689195": {"ViewCount": "324", "Body": "<p>Like in the example below, what is allowed, how and why?    </p>\n<pre><code>class Shape {\n      public:\n        //...\n        virtual Shape *clone() const = 0; // Prototype\n        //...\n    };\n    class Circle : public Shape {\n      public:\n        Circle *clone() const;\n        //...\n    };\n</code></pre>\n", "AcceptedAnswerId": "1689267", "Title": "What the C++ rules in regard to covariant return types?", "CreationDate": "2009-11-06T17:45:34.137", "Id": "1689195", "CommentCount": "6", "LastEditDate": "2009-11-06T19:50:03.917", "PostTypeId": "1", "LastEditorUserId": "149045", "LastActivityDate": "2009-11-06T19:50:03.917", "Score": "5", "OwnerUserId": "149045", "Tags": "<c++>", "AnswerCount": "2"}, "1689346": {"Id": "1689346", "PostTypeId": "2", "Body": "<p>Pff, too long standard quoting.</p>\n<p>You can use another type as covariant if (a) it is a pointer/reference (b) it can be casted to the prior return type by mere addition of a constant known at compilation time (c) it is compliant to all constant-volatile qualifiers.</p>\n", "LastActivityDate": "2009-11-06T18:13:31.107", "Score": "4", "CreationDate": "2009-11-06T18:13:31.107", "ParentId": "1689195", "CommentCount": "2", "OwnerUserId": "158676"}, "1689267": {"Id": "1689267", "PostTypeId": "2", "Body": "<p>C++ Standard 2003. 10.3.5</p>\n<blockquote>\n<p id=\"so_1689195_1689267_0\">The return type of an overriding\n  function shall be either identical to\n  the return type of the overridden\n  function or <strong>covariant</strong> with the classes\n  of the functions.  If a function D::f\n  overrides a function B::f, the return\n  types of the functions are covariant\n  if they satisfy the following\n  criteria:</p>\n<p id=\"so_1689195_1689267_1\">\u2014  both are pointers to classes or\n  references to classes</p>\n<p id=\"so_1689195_1689267_2\">\u2014  the class in the return type of\n  B::f is the same class as the class in\n  the return type of D::f, or <strong>is an\n  unambiguous and accessible direct or\n  indirect base class of the class in\n  the return type of D::f</strong></p>\n<p id=\"so_1689195_1689267_3\">\u2014  both pointers or references have\n  the same cv-qualification and the\n  class type in the return type of D::f\n  has the same cv-qualification as or\n  less cv-qualification than the class\n  type in the return type of B::f.</p>\n<p id=\"so_1689195_1689267_4\">If the return type of D::f differs\n  from the return type of B::f, the\n  class type in the return type of D::f\n  shall be complete at the point of\n  declaration of D::f or shall be the\n  class type D.  When the overriding\n  function is called as the final\n  overrider of the overridden function,\n  its result is converted to the type\n  returned by the (statically chosen)\n  overridden function (5.2.2).</p>\n</blockquote>\n<p>Example:</p>\n<pre><code>class B {};\nclass D : private B { friend class Derived; };\nstruct Base {\n  virtual B*  vf4();\n  virtual B*  vf5();\n};\nclass A;\nstruct Derived : public Base {\n  D* vf4();  // OK: returns pointer to derived class\n  A* vf5();  // error: returns pointer to incomplete class\n};\n</code></pre>\n", "LastEditorUserId": "124161", "LastActivityDate": "2009-11-06T18:12:19.387", "Score": "10", "CreationDate": "2009-11-06T18:00:14.857", "ParentId": "1689195", "CommentCount": "0", "LastEditDate": "2009-11-06T18:12:19.387", "OwnerUserId": "124161"}});