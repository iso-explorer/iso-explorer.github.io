post_cb({"14012718": {"Id": "14012718", "PostTypeId": "2", "Body": "<p>I'm giving this to <a href=\"https://stackoverflow.com/users/464581/cheers-and-hth-alf\">Alf</a> but I wanted to add a couple of notes for future reference.</p>\n<p>As Alf says, <code>std::is_*_assignable</code> really only check for the existence (explicit or implicit) of an appropriate assignment operator. They don't necessarily check to see whether it will be well-formed if instantiated. This works fine for the default assignment operators. If there is a member declared <code>const</code>, the default assignment operators will be deleted. If a base class has a deleted assignment operator, the default assignment operator will be deleted. So if you just let the defaults do their thing, it should be fine.</p>\n<p>However, if you do declare <code>operator=</code>, it becomes your responsibility (if you care) to ensure that it is appropriately deleted. For example, this will compile and run (at least with clang), and reports that <code>C</code> is_assignable:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n#include &lt;tuple&gt;\nusing namespace std;\n\nstruct A { const int x; A() : x() {}};\n\nstruct C { \n  struct A a;\n  C&amp; operator=( C const&amp; other);\n};\n\ntemplate&lt; class Type &gt;\nbool isAssignable() { return is_assignable&lt; Type&amp;, const Type&amp; &gt;::value;  }\n\nint main()\n{\n    wcout &lt;&lt; boolalpha;\n    wcout &lt;&lt; isAssignable&lt; A &gt;() &lt;&lt; endl; // false\n    wcout &lt;&lt; isAssignable&lt; C &gt;() &lt;&lt; endl; // true\n    C c1;\n    C c2;\n}\n</code></pre>\n<p>The absence of the assignment operator's definition isn't noted until link-time, and in this case not at all because the assignment operator is never used. But note that a use of <code>C::operator=</code> contingent on <code>std::is_assignable</code> would be allowed to compile. Of course, I couldn't have defined <code>C::operator=</code> in a way that resulted in assigning to its member <code>a</code>, because that member isn't assignable.</p>\n<p>That's not a particularly interesting example though. What get's interesting is the use of templates, such as the <code>std::tuple</code> issue which started this whole question. Let's add a couple of templates into the above, and actually define <code>C::operator=</code> through assignment to its member <code>a</code>:</p>\n<pre><code>using namespace std;\n\ntemplate&lt;bool&gt; struct A {\n  A() : x() {}\n  const int x;\n};\n\ntemplate&lt;bool B&gt; struct C {\n  struct A&lt;B&gt; a;\n  C&amp; operator=( C const&amp; other) {\n    this-&gt;a = other.a;\n    return *this;\n  }\n};  \n\ntemplate&lt; class Type &gt;\nbool isAssignable() { return is_assignable&lt; Type&amp;, const Type&amp; &gt;::value;  }\n\nint main()\n{   \n    wcout &lt;&lt; boolalpha;\n    wcout &lt;&lt; isAssignable&lt; A&lt;false&gt; &gt;() &lt;&lt; endl; // false\n    wcout &lt;&lt; isAssignable&lt; C&lt;false&gt; &gt;() &lt;&lt; endl; // true\n    C&lt;false&gt; c1;\n    C&lt;false&gt; c2;\n    c1 = c2;                                     // Bang\n    return 0;\n}   \n</code></pre>\n<p>Without the assignment at the end, the code compiles and runs (under clang 3.3) and reports that <code>A&lt;false&gt;</code> is not assignable (correct) but that <code>C&lt;false&gt;</code> is assignable (surprise!).  The actual attempt to use <code>C::operator=</code> reveals the truth, because it is not until that point that the compiler attempts to actually instantiate that operator. Up to then, and through the instantiations of <code>is_assignable</code>, the operator was just a declaration of a public interface, which is -- as Alf says -- all that <code>std::is_assignable</code> is really looking for.</p>\n<p>Phew.</p>\n<p>So bottom line, I think this is a deficiency in both the standard and the standard library  implementations with respect to standard aggregate objects whose <code>operator=</code> should be deleted if any of the component types is not assignable. For <code>std::tuple</code>, \u00a7 20.4.2.2 lists as requirements for <code>operator=</code> that all component types be assignable, and there ae similar requirements for other types, but I don't think that requirement requires library implementors to delete inapplicable <code>operator=</code>.</p>\n<p>But, then, as far as I can see, nothing stops library implementations from doing the deletion (except the annoyance factor of conditionally deleting assignment operators). In my opinion after obsessing about this for a couple of days, they should do so, and furthermore the standard should require them to do so. Otherwise, reliable use of <code>is_assignable</code> impossible.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-12-24T05:18:09.490", "Score": "4", "CreationDate": "2012-12-23T16:43:14.340", "ParentId": "14009120", "CommentCount": "4", "OwnerUserId": "1566221", "LastEditDate": "2017-05-23T12:01:51.443"}, "bq_ids": {"n4140": {"so_14009120_14009579_0": {"length": 45, "quality": 0.8823529411764706, "section_id": 4706}}, "n3337": {"so_14009120_14009579_0": {"length": 45, "quality": 0.8823529411764706, "section_id": 4515}}, "n4659": {"so_14009120_14009579_0": {"length": 45, "quality": 0.8823529411764706, "section_id": 6103}}}, "14009120": {"ViewCount": "3910", "Body": "<p>C++11 removed the requirement that the value type of all containers be CopyConstructible and Assignable (although specific operations on containers may impose these requirements). In theory, that should make it possible to define, for example, <code>std::deque&lt;const Foo&gt;</code>, which was not possible in C++03.</p>\n<p>Unexpectedly, gcc 4.7.2 produced its usual vomit of incomprehensible errors [1] when I tried this, but clang at least made the error readable and clang with libc++ compiled it with no errors.</p>\n<p>Now, when two different compilers produce different results, it always makes me wonder what the correct answer is, and so I searched out all the references I could find to const/assignable/value types/containers, etc., etc. I found almost a decade's worth of very similar questions and answers, some of them here on SO and others in the various C++ mailing lists, amongst other places, including the Gnu buganizer, all of which basically can be summarized as following dialogue.</p>\n<p>Q: Why can't I declare <code>std::vector&lt;const int&gt;</code> (as a simplified example)</p>\n<p>A: Why on earth would you want to do that? It's nonsensical.</p>\n<p>Q: Well, it makes sense to me. Why can't I do it?</p>\n<p>A: Because the Standard requires value types to be assignable.</p>\n<p>Q: But I'm not planning on assigning them. I want them to be const after I've created them.</p>\n<p>A: That's not the way it works. Next question!</p>\n<p>with a mild dashing of:</p>\n<p>A2: C++11 has decided to allow that. You'll just have to wait. In the meantime, rethink your ridiculous design.</p>\n<p>These don't seem like very compelling answers, although possibly I'm biased because I fall into the category of \"but it makes sense to me\". In my case, I'd like to have a stack-like container in which things pushed onto the stack are immutable until they are popped, which doesn't strike me as a particularly odd thing to want to be able to express with a type system.</p>\n<p>Anyway, I started thinking about the answer, \"the standard requires all containers' value types to be assignable.\" And, as far as I can see, now that I found an old copy of a draft of the C++03 standard, that's true; it did.</p>\n<p>On the other hand, the value type of <code>std::map</code> is <code>std::pair&lt;<b>const</b> Key, T&gt;</code> which doesn't look to me like it's assignable. Still, I tried again with <code>std::deque&lt;std::tuple&lt;const Foo&gt;&gt;</code>, and gcc proceeded to compile it without batting an eye. So at least I have some kind of workaround.</p>\n<p>Then I tried printing out the value of <code>std::is_assignable&lt;const Foo, const Foo&gt;</code> and <code>std::is_assignable&lt;std::tuple&lt;const Foo&gt;, const std::tuple&lt;const Foo&gt;&gt;</code>, and it turns out that the former is reported as not assignable, as you'd expect, but the latter is reported as assignable (by both clang and gcc). Of course, it's not really assignable; attempting to compile <code>a = b;</code> is rejected by gcc with the complaint <code>error: assignment of read-only location</code> (this was just about the only error message I encountered in this quest which was actually easy to understand). However, without the attempt to do an assignment, both clang and gcc are equally happy to instantiate the <code>deque&lt;const&gt;</code>, and the code seems to run fine.</p>\n<p>Now, if <code>std::tuple&lt;const int&gt;</code> really is assignable, then I can't complain about the inconsistency in the <code>C++03</code> standard -- and, really, who cares -- but I find it disturbing that two different standard library implementations report that a type is assignable when in fact, attempting to assign to a reference of it will lead to a (very sensible) compiler error. I might at some point want to use the test in a template SFINAE, and based on what I saw today, it doesn't look very reliable.</p>\n<p>So is there anyone who can shed some light on the question (in the title): <em>What does Assignable really mean?</em> And two bonus questions:</p>\n<p>1) Did the committee really mean to allow instantiating containers with <code>const</code> value types, or did they have some other non-assignable case in mind?, and</p>\n<p>2) Is there really a significant difference between the constnesses of <code>const Foo</code> and <code>std::tuple&lt;const Foo&gt;</code>?</p>\n<hr>\n<p>[1] For the truly curious, here's the error message produced by gcc when trying to compile the declaration of <code>std::deque&lt;const std::string&gt;</code> (with a few line-endings added, and an explanation if you scroll down far enough):</p>\n<pre><code>In file included from /usr/include/x86_64-linux-gnu/c++/4.7/./bits/c++allocator.h:34:0,\n                 from /usr/include/c++/4.7/bits/allocator.h:48,\n                 from /usr/include/c++/4.7/string:43,\n                 from /usr/include/c++/4.7/random:41,\n                 from /usr/include/c++/4.7/bits/stl_algo.h:67,\n                 from /usr/include/c++/4.7/algorithm:63,\n                 from const_stack.cc:1:\n/usr/include/c++/4.7/ext/new_allocator.h: In instantiation of \u2018class __gnu_cxx::new_allocator&lt;const std::basic_string&lt;char&gt; &gt;\u2019:\n/usr/include/c++/4.7/bits/allocator.h:89:11:   required from \u2018class std::allocator&lt;const std::basic_string&lt;char&gt; &gt;\u2019\n/usr/include/c++/4.7/bits/stl_deque.h:489:61:   required from \u2018class std::_Deque_base&lt;const std::basic_string&lt;char&gt;, std::allocator&lt;const std::basic_string&lt;char&gt; &gt; &gt;\u2019\n/usr/include/c++/4.7/bits/stl_deque.h:728:11:   required from \u2018class std::deque&lt;const std::basic_string&lt;char&gt; &gt;\u2019\nconst_stack.cc:112:27:   required from here\n/usr/include/c++/4.7/ext/new_allocator.h:83:7:\n  error: \u2018const _Tp* __gnu_cxx::new_allocator&lt; &lt;template-parameter-1-1&gt; &gt;::address(\n  __gnu_cxx::new_allocator&lt; &lt;template-parameter-1-1&gt; &gt;::const_reference) const [\n  with _Tp = const std::basic_string&lt;char&gt;;\n  __gnu_cxx::new_allocator&lt; &lt;template-parameter-1-1&gt; &gt;::const_pointer =\n    const std::basic_string&lt;char&gt;*;\n  __gnu_cxx::new_allocator&lt; &lt;template-parameter-1-1&gt; &gt;::const_reference =\n    const std::basic_string&lt;char&gt;&amp;]\u2019 cannot be overloaded\n/usr/include/c++/4.7/ext/new_allocator.h:79:7:\n  error: with \u2018_Tp* __gnu_cxx::new_allocator&lt; &lt;template-parameter-1-1&gt; &gt;::address(\n  __gnu_cxx::new_allocator&lt; &lt;template-parameter-1-1&gt; &gt;::reference) const [\n  with _Tp = const std::basic_string&lt;char&gt;;\n  __gnu_cxx::new_allocator&lt; &lt;template-parameter-1-1&gt; &gt;::pointer = const std::basic_string&lt;char&gt;*;\n  __gnu_cxx::new_allocator&lt; &lt;template-parameter-1-1&gt; &gt;::reference = const std::basic_string&lt;char&gt;&amp;]\u2019\n</code></pre>\n<p>So what's going on here is that the standard (\u00a7 20.6.9.1) insists that the default allocator have member functions:</p>\n<pre><code>pointer address(reference x) const noexcept;\nconst_pointer address(const_reference x) const noexcept;\n</code></pre>\n<p>but if you instantiate it with a <code>const</code> template argument (which is apparently UB), then <code>reference</code> and <code>const_reference</code> are the same type, and so the declarations are duplicated. (The body of the definition is identical, for what it's worth.) Consequently, no allocator-aware container can deal with an explicitly <code>const</code> value type. Hiding the <code>const</code> inside a <code>tuple</code> allows the allocator to instantiate. This allocator requirement from the standard was used to justify closing at least a couple of old libstdc++ bugs about problems with  <code>std::vector&lt;const int&gt;</code>, although it doesn't strike me as a solid point of principle. Also libc++ works around the problem in the obvious simple way, which is to provide a specialization of <code>allocator&lt;const T&gt;</code> with the duplicate function declarations removed.</p>\n</hr>", "AcceptedAnswerId": "14009579", "Title": "What does \"Assignable\" really mean?", "CreationDate": "2012-12-23T06:25:47.507", "Id": "14009120", "CommentCount": "10", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2012-12-24T05:18:09.490", "Score": "24", "OwnerUserId": "1566221", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "2"}, "14009579": {"Id": "14009579", "PostTypeId": "2", "Body": "<p>In C++03, <code>Assignable</code> was defined by table 64 in \u00a723.1/4,</p>\n<pre>\n    Expression    Return type    Post-condition\n    t = u         T&amp;             t is equivalent to u\n</pre>\n<p>On the one hand this requirement was not met for <code>std::map</code>. On the other hand it was too strict a requirement for <code>std::list</code>. And C++11 demonstrated that it's not even necessary for <code>std::vector</code>, in general, but is imposed by use of certain operations (such as assignment).</p>\n<p>In C++11 the corresponding requirement is named <code>CopyAssignable</code> and is defined by table 23 in \u00a717.6.3.1/2,</p>\n<pre>\n    Expression    Return type    Return value    Post-condition\n    t = v         T&amp;             t               t is equivalent to v, the\n                                                 value of v is unchanged\n</pre>\n<p>The main differences are that container elements no longer need to be <code>CopyAssignable</code>, and that there's a corresponding requirement <code>MoveAssignable</code>.</p>\n<p>Anyway, a structure with a <code>const</code> data member is clearly not assignable unless one chooses to read \u201cequivalent to\u201d with a very peculiar interpretation.</p>\n<p>The only operation-independent element type requirement in C++11 is, as far as I can see (from table 96 in \u00a723.2.1/4) that it must be <code>Destructible</code>.</p>\n<hr>\n<p>Regarding <code>std::is_assignable</code>, it does not quite test the <code>CopyAssignable</code> criterion.</p>\n<p>Here\u2019s what <code>std::is_assignable&lt;T, U&gt;</code> implies, according to table 49 in C++11 \u00a720.9.4.3/3:</p>\n<blockquote>\n<p id=\"so_14009120_14009579_0\">\u201cThe expression\n  <code>declval&lt;T&gt;() = declval&lt;U&gt;()</code> is\n  well-formed when treated\n  as an unevaluated operand\n  (Clause 5). Access\n  checking is performed as if\n  in a context unrelated to <code>T</code>\n  and <code>U</code>. Only the validity of\n  the immediate context of\n  the assignment expression\n  is considered. [<em>Note:</em> The\n  compilation of the\n  expression can result in\n  side effects such as the\n  instantiation of class\n  template specializations\n  and function template\n  specializations, the\n  generation of\n  implicitly-defined\n  functions, and so on. Such\n  side effects are not in the\n  \u201cimmediate context\u201d and\n  can result in the program\n  being ill-formed. <em>\u2014end\n  note</em> ]\u201d</p>\n</blockquote>\n<p>Essentially this implies an access/existence + argument type compatibility check of <code>operator=</code>, and nothing more.</p>\n<p>However, Visual C++ 11.0 doesn't appear to do the access check, while g++ 4.7.1 chokes on it:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n#include &lt;tuple&gt;\nusing namespace std;\n\nstruct A {};\nstruct B { private: B&amp; operator=( B const&amp; ); };\n\ntemplate&lt; class Type &gt;\nbool isAssignable() { return is_assignable&lt; Type, Type &gt;::value;  }\n\nint main()\n{\n    wcout &lt;&lt; boolalpha;\n    wcout &lt;&lt; isAssignable&lt; A &gt;() &lt;&lt; endl;              // OK.\n    wcout &lt;&lt; isAssignable&lt; B &gt;() &lt;&lt; endl;              // Uh oh.\n}\n</code></pre>\n<p>Building with Visual C++ 11.0:</p>\n<pre>\n[D:\\dev\\test\\so\\assignable]\n&gt; <i>cl assignable.cpp</i>\nassignable.cpp\n\n[D:\\dev\\test\\so\\assignable]\n&gt; _\n</pre>\n<p>Building with g++ 4.7.1:</p>\n<pre>\n[D:\\dev\\test\\so\\assignable]\n&gt; <i>g++ assignable.cpp</i>\nd:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/type_traits: In substitution of 'template static decltype (((declval)()=(declval)(), std::__sfinae_types::__one()))std::__is_assignable_helper::__test(int) [with _\nTp1 = _Tp1; _Up1 = _Up1; _Tp = B; _Up = B] [with _Tp1 = B; _Up1 = B]':\nd:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/type_traits:1055:68:   required from 'constexpr const bool std::__is_assignable_helper::value'\nd:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/type_traits:1060:12:   required from 'struct std::is_assignable'\nassignable.cpp:10:59:   required from 'bool isAssignable() [with Type = B]'\nassignable.cpp:16:32:   required from here\nassignable.cpp:7:24: error: 'B&amp; B::operator=(const B&amp;)' is private\nIn file included from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/bits/move.h:57:0,\n                 from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/bits/stl_pair.h:61,\n                 from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/bits/stl_algobase.h:65,\n                 from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/bits/char_traits.h:41,\n                 from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/ios:41,\n                 from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/ostream:40,\n                 from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/iostream:40,\n                 from assignable.cpp:1:\nd:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/type_traits:1049:2: error: within this context\nd:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/type_traits: In substitution of 'template static decltype (((declval)()=(declval)(), std::__sfinae_types::__one())) std::__is_assignable_helper::__test(int) [with _\nTp1 = _Tp1; _Up1 = _Up1; _Tp = B; _Up = B] [with _Tp1 = B; _Up1 = B]':\nd:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/type_traits:1055:68:   required from 'constexpr const bool std::__is_assignable_helper::value'\nd:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/type_traits:1060:12:   required from 'struct std::is_assignable'\nassignable.cpp:10:59:   required from 'bool isAssignable() [with Type = B]'\nassignable.cpp:16:32:   required from here\nassignable.cpp:7:24: error: 'B&amp; B::operator=(const B&amp;)' is private\nIn file included from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/bits/move.h:57:0,\n                 from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/bits/stl_pair.h:61,\n                 from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/bits/stl_algobase.h:65,\n                 from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/bits/char_traits.h:41,\n                 from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/ios:41,\n                 from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/ostream:40,\n                 from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/iostream:40,\n                 from assignable.cpp:1:\nd:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/type_traits:1049:2: error: within this context\nd:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/type_traits: In instantiation of 'constexpr const bool std::__is_assignable_helper::value':\nd:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/type_traits:1060:12:   required from 'struct std::is_assignable'\nassignable.cpp:10:59:   required from 'bool isAssignable() [with Type = B]'\nassignable.cpp:16:32:   required from here\nassignable.cpp:7:24: error: 'B&amp; B::operator=(const B&amp;)' is private\nIn file included from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/bits/move.h:57:0,\n                 from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/bits/stl_pair.h:61,\n                 from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/bits/stl_algobase.h:65,\n                 from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/bits/char_traits.h:41,\n                 from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/ios:41,\n                 from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/ostream:40,\n                 from d:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/iostream:40,\n                 from assignable.cpp:1:\nd:\\bin\\mingw\\bin\\../lib/gcc/i686-pc-mingw32/4.7.1/../../../../include/c++/4.7.1/type_traits:1055:68: error: within this context\n\n[D:\\dev\\test\\so\\assignable]\n&gt; _\n</pre>\n<p>So, summing up, the standard's <code>std::is_assignable</code> appears to be of very limited utility, and as of this writing it can't be relied on for portable code.</p>\n<hr>\n<p><strong>EDIT:</strong> Replaced <code>&lt;utility&gt;</code> with correct <code>&lt;type_traits</code>. Interestingly it didn't matter for g++. Not even for the error message, so I just let that be as it was.</p>\n</hr></hr>", "LastEditorUserId": "464581", "LastActivityDate": "2012-12-23T11:25:16.757", "Score": "11", "CreationDate": "2012-12-23T08:14:29.787", "ParentId": "14009120", "CommentCount": "9", "OwnerUserId": "464581", "LastEditDate": "2012-12-23T11:25:16.757"}});