post_cb({"34842454": {"CommentCount": "1", "ViewCount": "405", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-01-17T19:09:55.557", "LastActivityDate": "2016-01-18T22:15:46.763", "Title": "Time complexity of priority_queue::push() in Visual Studio?", "AcceptedAnswerId": "34842591", "LastEditDate": "2017-05-23T11:44:52.873", "Id": "34842454", "Score": "2", "Body": "<p>I use Windows and Visual Studio 2015. As far as I can see from references and others' questions, priority_queue::push() should have O(log(n)) time complexity. This means of course that this simple code:</p>\n<pre><code>#include &lt;queue&gt;\nusing namespace std;\nint main()\n{\n    priority_queue&lt;int&gt; q;\n    const int n=100000; //We can vary this\n    for (int i = 0; i &lt; n; i++)\n    {\n        q.push(i);\n    }\n}\n</code></pre>\n<p>should have complexity O(nlog(n)), which means for n=100 000 as above it should be piece of cake. It takes several minutes for me (the same thing with std::set takes just a second).</p>\n<p>I have debugged this code and stopped it at multiples of 10 seconds, and plotted the squares of i for those times. They very (!) accurately lie on a line, which would mean the above code has complexity of O(n^2).</p>\n<p>My question is, is not priority_queue::push() guaranteed to run in O(log(n)) or am I doing something very wrong?</p>\n<p>Thanks in advance!</p>\n<p><strong>EDIT:</strong> I have tried the tip in <a href=\"https://stackoverflow.com/questions/3666387/c-priority-queue-underlying-vector-container-capacity-resize\">this post</a>. It didn't improve things, so I suppose reallocating the underlying container is not my issue.</p>\n<p><strong>EDIT: SOLVED</strong> As usual the answer is very simple. I had run the program in debug mode, which apparently changes the complexity of some functions. I was not aware of this, though I suppose it is quite reasonable...</p>\n", "Tags": "<c++><visual-studio-2015><big-o><time-complexity><priority-queue>", "OwnerUserId": "5802327", "AnswerCount": "2"}, "34842591": {"ParentId": "34842454", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Several minutes for <code>n=100000</code> seems like a very long time.</p>\n<p>Are you by any chance testing in debug mode?</p>\n<hr>\n<h2>About complexity and performance:</h2>\n<p>From <a href=\"http://www.cplusplus.com/reference/queue/priority_queue/\" rel=\"nofollow noreferrer\"><code>std::priority_queue</code></a>:</p>\n<blockquote>\n<p id=\"so_34842454_34842591_0\">Priority queues are a type of container adaptors, specifically\n  designed <strong>such that its first element is always the greatest</strong> of the\n  elements it contains</p>\n</blockquote>\n<p>And:</p>\n<blockquote>\n<p id=\"so_34842454_34842591_1\">By default, if no container class is specified for a particular\n  priority_queue class instantiation, <strong>the standard container vector is\n  used</strong>.</p>\n</blockquote>\n<p>Which would mean that in a loop where <code>i</code> gets incremented, the new item needs to be inserted at the beginning of the vector, meaning that all other elements have to be shifted one - this for each iteration. Since all elements in vector are stored contiguously (while <code>push_back</code> is actually used to insert the items, <code>push_heap</code> is called to rearrange them).</p>\n<p>Turning that around (using the default vector container) almost takes no time, even in debug mode.</p>\n<p>From <a href=\"https://stackoverflow.com/questions/849168/are-stdvector-elements-guaranteed-to-be-contiguous\">Are std::vector elements guaranteed to be contiguous?</a>:</p>\n<blockquote>\n<p id=\"so_34842454_34842591_2\"><strong>23.2.6 Class template vector [vector]</strong></p>\n<p id=\"so_34842454_34842591_3\">1 A vector is a sequence container that supports random access iterators. In addition, it supports (amortized) constant time insert\n  and erase operations at the end; insert and erase in the middle take\n  linear time. Storage management is handled automatically, though hints\n  can be given to improve efficiency. <strong>The elements of a vector are\n  stored contiguously</strong>, meaning that if v is a vector where T is some\n  type other than bool, then it obeys the identity &amp;v[n] == &amp;v[0] + n\n  for all 0 &lt;= n &lt; v.size().</p>\n</blockquote>\n<p>A solution could be to specify a different container type:</p>\n<pre><code>template &lt;class T, class Container = vector&lt;T&gt;\n</code></pre>\n<p>So, as for complexity of O(log(n)) for <code>priority_queue::push()</code>, it would be hard to guarantee that, since the underlying container type can differ, and each has it's own implementation for inserting/rearranging items. But O(log(n)) would be the best possible scenario.</p>\n<p>But perhaps even more important is the time each operation takes, apart from the complexity factor.</p>\n<blockquote>\n<p id=\"so_34842454_34842591_4\">EDIT (question): I have tried the tip in <a href=\"https://stackoverflow.com/questions/3666387/c-priority-queue-underlying-vector-container-capacity-resize\">this</a> post. It didn't improve things, so\n  I suppose reallocating the underlying container is not my issue.</p>\n</blockquote>\n<p>It's not so much about reallocating memory for storage of the elements (vector will do that in blocks anyway - although for larger containers preallocation is always desirable), but about inserting eacht element before the first one (if that is really the case, which seems to be so). Even if enough space is allocated, to insert an element in front in a vector, all other elements need to be moved exactly one <em>element-size</em>. It's that moving that takes time.</p>\n</hr>", "OwnerUserId": "5708620", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:31:24.053", "Id": "34842591", "Score": "1", "CreationDate": "2016-01-17T19:23:34.050", "LastActivityDate": "2016-01-17T20:08:24.920"}, "bq_ids": {"n4140": {"so_34842454_34842591_3": {"section_id": 955, "quality": 0.96, "length": 48}}, "n3337": {"so_34842454_34842591_3": {"section_id": 943, "quality": 0.96, "length": 48}}, "n4659": {"so_34842454_34842591_3": {"section_id": 1016, "quality": 0.54, "length": 27}}}, "34842694": {"ParentId": "34842454", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The answer is no, it is not guaranteed to run in O(log(n)) at all. That guarantee would be impossible to implement.</p>\n", "OwnerUserId": "298661", "LastEditorUserId": "2642204", "LastEditDate": "2016-01-17T20:22:50.403", "Id": "34842694", "Score": "2", "CreationDate": "2016-01-17T19:32:09.590", "LastActivityDate": "2016-01-17T20:22:50.403"}});