post_cb({"bq_ids": {"n4140": {"so_41573959_41573959_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 3304}}, "n3337": {"so_41573959_41573959_0": {"length": 17, "quality": 0.7727272727272727, "section_id": 3174}}, "n4659": {"so_41573959_41573959_0": {"length": 16, "quality": 0.7272727272727273, "section_id": 4070}}}, "41574587": {"Id": "41574587", "PostTypeId": "2", "Body": "<p>You declare <code>a</code> with initializers for all its members: <code>b1</code>, <code>b2</code> and <code>x</code>.  That means we construct as if</p>\n<pre><code>a.b1 = B{ 1, 2, 3, 4 };\na.b2 = B{ 1 };\na.x = 5;\n</code></pre>\n<p><code>B</code>'s definition says that <code>B{ 1, 2, 3, 4 }</code> means <code>B{ 1, 2, 3, 4, 23 }</code> and that <code>B{ 1 }</code> means <code>B{ 1, 0, 22, 0, 23 }</code>.  And that's exactly the result you get.</p>\n<hr>\n<p>If you had written</p>\n<pre><code>A a = { { 1, 2, 3, 4 }, };\n</code></pre>\n<p>then <code>a.b2</code> would have been initialized using its default of { 11, 12 }:</p>\n<pre><code>a.b1 = B{ 1, 2, 3, 4 };\na.b2 = B{ 11, 12 };\na.x = {};\n</code></pre>\n<hr>\n<p>It may help to think of those brace-expressions such as <code>{ 1 }</code> and <code>{ 11, 12 }</code> in your example as being fully-constructed <code>B</code> objects, long before <code>A</code>'s constructor even sees them.</p>\n</hr></hr>", "LastActivityDate": "2017-01-10T17:19:31.870", "CommentCount": "2", "CreationDate": "2017-01-10T17:19:31.870", "ParentId": "41573959", "Score": "6", "OwnerUserId": "4850040"}, "41574230": {"Id": "41574230", "PostTypeId": "2", "Body": "<p>In this example <code>{1, 2, 3, 4}</code> is an initializer for <code>B b1</code>. The compiler already has an initializer, so now it won't look at <code>{ 11, 12 }</code> anymore.</p>\n", "LastActivityDate": "2017-01-10T17:00:07.610", "CommentCount": "0", "CreationDate": "2017-01-10T17:00:07.610", "ParentId": "41573959", "Score": "2", "OwnerUserId": "1460794"}, "41573959": {"ViewCount": "264", "Body": "<p>Having this structure:</p>\n<pre><code>struct A {\n    struct B {\n        int a = 21;\n        int b;\n        int c = 22;\n        int d;\n        int e = 23;\n    };\n    B b1  = { 11, 12 };\n    B b2  = { 11, 12, 13 };\n    int x;\n};\n</code></pre>\n<p>And declaring:</p>\n<pre><code>A a = { { 1, 2, 3, 4 }, { 1 }, 5 };\n</code></pre>\n<p>According to both Clang (3.8.0) and GCC (5.4.0), these are the values of the 8 possible combinations (a.b1.e and a.b2.a are repeated cases), regarding where the initial value is taken from (or not), :</p>\n<pre><code>a.b1.a = 1   // 111\na.b1.b = 2   // 110\na.b1.c = 3   // 101\na.b1.d = 4   // 100\na.b2.b = 0   // 010    // Why not 12 instead of  0? -&gt; Explained in N3605\na.b2.c = 22  // 011    // Why not  0 instead of 22 ?  Why not 13 ?\na.b2.d = 0   // 000\na.b2.e = 23  // 001    // Why not  0 instead of 23 ?\n</code></pre>\n<p>Taking into account the example in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3605.html?cm_mc_uid=02271754051914834448186&amp;cm_mc_sid_50200000=1484048606\" rel=\"nofollow noreferrer\">N3605</a> and the C++14 Standard (ISO/IEC 14882:2014), Section 8.5.1, Paragraph 7:</p>\n<blockquote>\n<p id=\"so_41573959_41573959_0\">If there are fewer <em>initializer-clauses</em> in the list than there are members in the aggregate, then each member not explicitly initialized shall be initialized from its <em>brace-or-equal-initializer</em> or, if there is no <em>brace-or-equal-initializer</em>, from an empty initializer list (8.5.4).</p>\n</blockquote>\n<p>I assume case 010 is correct. Then, why cases 011 (a.b2.c) and 001 (a.b2.e) are not also equal to zero? Case 010 is zero because a.b2 \"does have an initializer\", therefore \"the non-static data member initializer is ignored\" (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3605.html?cm_mc_uid=02271754051914834448186&amp;cm_mc_sid_50200000=1484048606\" rel=\"nofollow noreferrer\">N3605</a> again). Why the default member initializers are not ignored as well? </p>\n<p>In fact, reading the C++14 Standard quote it would make more sense to me that case 010 would be 12 (it is zero) and cases 011 and 001 would be zero (as they actually are). So what I don't understand is why a.b2 is sometimes considered to \"have an initializer\" and other times it is not.</p>\n", "AcceptedAnswerId": "41574587", "Title": "Aggregate Member Initialization in C++14", "CreationDate": "2017-01-10T16:46:25.557", "Id": "41573959", "CommentCount": "1", "LastEditDate": "2017-01-11T08:46:36.033", "PostTypeId": "1", "LastEditorUserId": "6892577", "LastActivityDate": "2017-01-11T08:46:36.033", "Score": "3", "OwnerUserId": "6892577", "Tags": "<c++><aggregate><c++14><member-initialization>", "AnswerCount": "2"}});