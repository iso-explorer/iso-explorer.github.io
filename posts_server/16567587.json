post_cb({"16567705": {"ParentId": "16567587", "CommentCount": "0", "Body": "<p>You can only do <code>p += X;</code> as long as it still points within the array/container or one past the end of the array/container (\u00a75.7):</p>\n<blockquote>\n<p id=\"so_16567587_16567705_0\">If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>The same is true for comparisons between pointers. They must both be pointing at the same array or one past the end. They cannot be pointing further than that.</p>\n", "OwnerUserId": "150634", "PostTypeId": "2", "Id": "16567705", "Score": "4", "CreationDate": "2013-05-15T14:24:16.173", "LastActivityDate": "2013-05-15T14:24:16.173"}, "16567735": {"ParentId": "16567587", "CommentCount": "0", "Body": "<p>(I assume you're talking about random-access iterators, since this probably won't even compile for most bidirectional, non-random-access iterators.)</p>\n<p>No, this is not safe for general iterators.  In fact, it isn't even safe for pointers.  According to the standard, a pointer can only safely point to within an array or the one-past-the-end element of an array, and pointers into different arrays aren't portably comparable to each other.  (On modern hardware, general pointer comparisons usually work, but this isn't guaranteed.  If you want portability, you'd need to use <code>std::less&lt;&gt;</code>.)</p>\n", "OwnerUserId": "798193", "PostTypeId": "2", "Id": "16567735", "Score": "2", "CreationDate": "2013-05-15T14:25:21.923", "LastActivityDate": "2013-05-15T14:25:21.923"}, "16567587": {"CommentCount": "1", "ViewCount": "65", "PostTypeId": "1", "LastEditorUserId": "727238", "CreationDate": "2013-05-15T14:19:35.920", "LastActivityDate": "2013-05-15T14:32:24.197", "Title": "Is it safe to use iterator pointing beyond indexable collection in calculations?", "AcceptedAnswerId": "16567705", "LastEditDate": "2013-05-15T14:32:24.197", "Id": "16567587", "Score": "3", "Body": "<p>When I have simple pointer I can safely wrap array like this:</p>\n<pre><code>p+=X;   // p pointer p can point beyond end of array\nif(p&gt;=array+array_size) p-=array_size;    // forget about potential multiple wrap\n</code></pre>\n<p>can I do the same safely for iterator over any indexable container, esp. deque?:</p>\n<pre><code>p+=x;\nif(p&gt;=mydeque.end()) p-=mydeque.size(); // forget about potential multiple wrap\n</code></pre>\n<p>In other words: is it safe to take into calculations iterator pointing beyond collection?</p>\n", "Tags": "<c++>", "OwnerUserId": "727238", "AnswerCount": "3"}, "16567828": {"ParentId": "16567587", "CommentCount": "1", "Body": "<p>Incrementing and <code>end()</code> <code>iterator</code> is <strong>UB</strong> that means <code>p+=x;</code> is also UB if it goes beyond the <code>end()</code>.</p>\n<p>why not do something like this</p>\n<pre><code>size_t dis = std::distance(std::begin(mydeque),p);\nstd::advance(p, (dis + X) % mydeque.size());\n</code></pre>\n", "OwnerUserId": "6271971", "PostTypeId": "2", "Id": "16567828", "Score": "0", "CreationDate": "2013-05-15T14:28:58.337", "LastActivityDate": "2013-05-15T14:28:58.337"}, "bq_ids": {"n4140": {"so_16567587_16567705_0": {"section_id": 6142, "quality": 1.0, "length": 21}}, "n3337": {"so_16567587_16567705_0": {"section_id": 5906, "quality": 1.0, "length": 21}}, "n4659": {"so_16567587_16567705_0": {"section_id": 7638, "quality": 0.5238095238095238, "length": 11}}}});