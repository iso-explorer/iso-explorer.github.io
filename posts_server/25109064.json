post_cb({"25109064": {"ViewCount": "301", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;array&gt;\n\nusing namespace std;\n\ntypedef double (C_array)[10];\n\nint main()\n{ \n    std::vector&lt;C_array&gt; arr(10);\n\n    // let's initialize it\n    for (int i = 0; i &lt; 10; i++)\n        for (int j = 0; j &lt; 10; j++)\n            arr[i][j] = -1;\n\n    // now make sure we did the right thing\n    for (int i = 0; i &lt; 10; i++)\n    {\n        for (int j = 0; j &lt; 10; j++)\n        {\n            cout &lt;&lt; arr[i][j] &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n}\n</code></pre>\n<p>I just found out from @juanchopanza <a href=\"https://stackoverflow.com/a/25108679/3093378\">https://stackoverflow.com/a/25108679/3093378</a> that this code should not be legal, since a plain old <code>C</code>-style array is not assignable/copyable/movable. However <code>g++</code> flies through the code, even with <code>-Wall -Wextra -pedantic</code>. <code>clang++</code> doesn't compile it. Of course if I try to do something like <code>auto arr1 = arr;</code>, it fails under <code>g++</code>, as it doesn't know how to copy <code>arr</code> into <code>arr1</code>.</p>\n<p>I used <code>g++4.9</code> from <code>macports</code> under OS X Mavericks. \nLive code here: <a href=\"http://goo.gl/97koLa\" rel=\"nofollow noreferrer\">http://goo.gl/97koLa</a></p>\n<p>My questions are:</p>\n<ol>\n<li>Is this code illegal according to the standard?</li>\n<li>Is <code>g++</code> so buggy? I keep finding lots of simple examples in which <code>g++</code> blindly compiles illegal code, last was yesterday  <a href=\"https://stackoverflow.com/q/25100855/3093378\">user-defined conversion operators precedence, compiles in g++ but not clang++</a> , and without too much effort, just experimenting with <code>C++</code> for fun.</li>\n</ol>\n", "AcceptedAnswerId": "25410342", "Title": "g++4.9 bug in allowing std::vector<C_type_array>", "CreationDate": "2014-08-03T21:01:35.550", "Id": "25109064", "CommentCount": "13", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:10:04.477", "LastEditorUserId": "-1", "LastActivityDate": "2014-09-12T12:39:28.073", "Score": "7", "OwnerUserId": "3093378", "Tags": "<c++><c++11><stl><gcc4.9>", "AnswerCount": "1"}, "25410342": {"PostTypeId": "2", "Body": "<p>Your code is not valid C++03. First, the header <code>&lt;array&gt;</code> is not part of the C++03 standard library but it is also not needed here. Second, the construction of the vector object tries to call the constructor</p>\n<pre><code>explicit vector(size_type n, const value_type&amp; val = value_type(), const allocator_type&amp; alloc = allocator_type());\n</code></pre>\n<p>However, the initialization of val fails for the same reason why you cannot write</p>\n<pre><code>C_array foo = C_array();\n</code></pre>\n<p>To the best of my understanding paragraph 2 in section 5.2.3 of the C++03 standard allows this notation only for non-array types:</p>\n<blockquote>\n<p id=\"so_25109064_25410342_0\">The expression T(), where T is a simple-type-specifier (7.1.5.2) for a non-array complete object type or the (possibly cv-qualified) void type, creates an rvalue of the specified type, which is value-initialized (8.5; no initialization is done for the void() case).</p>\n</blockquote>\n<p>Furthermore, g++-4.9.0 does also refuse to compile the code unless -std=c++11 is provided on the command line:</p>\n<pre><code>foo.cpp: In constructor \u2018std::vector&lt;_Tp, _Alloc&gt;::vector(std::vector&lt;_Tp, _Alloc&gt;::size_type, const value_type&amp;, const allocator_type&amp;) [with _Tp = double [10]; _Alloc = std::allocator&lt;double [10]&gt;; std::vector&lt;_Tp, _Alloc&gt;::size_type = long unsigned int; std::vector&lt;_Tp, _Alloc&gt;::value_type = double [10]; std::vector&lt;_Tp, _Alloc&gt;::allocator_type = std::allocator&lt;double [10]&gt;]\u2019:\nfoo.cpp:11:32: error: functional cast to array type \u2018std::vector&lt;double [10]&gt;::value_type {aka double [10]}\u2019\n std::vector&lt;C_array&gt; arr(10);\n...\n</code></pre>\n<p>As for C++11 the vector container offers an additional fill constructor:</p>\n<pre><code>explicit vector (size_type n);\n</code></pre>\n<p>This constructor requires that the template type be default-constructible (see section 23.3.6.2). To the best of my understanding this requirement is also not met in C++11 (see section 17.6.3.1) since in order to meet the requirement the expression C_array() must create a temporary object, which is also not valid in C++11 (again see section 5.2.3). I don't know whether the standard actually requires the compiler to reject the code or whether the compiler is allowed to compile it if one of the requirements is not met but the implementation of the standard library just does not need it. Maybe people who know more about C++11 can fill in the gaps here.</p>\n<p>Aside from all that it is in my opinion not a good idea to try to use an array as a container element type since other container requirements are not met. For example C_array is not copy-insertable and thus the vector cannot be copied.</p>\n<p>Concerning your second question: Feel free to browse the gcc bugzilla database at <a href=\"https://gcc.gnu.org/bugzilla/\" rel=\"nofollow\">https://gcc.gnu.org/bugzilla/</a>. However, accepting invalid code can also be on purpose e.g. in order to not break legacy code.</p>\n", "LastActivityDate": "2014-08-21T07:34:05.897", "LastEditorUserId": "1225999", "Id": "25410342", "CommentCount": "2", "CreationDate": "2014-08-20T16:53:37.493", "ParentId": "25109064", "Score": "2", "OwnerUserId": "1225999", "LastEditDate": "2014-08-21T07:34:05.897"}, "bq_ids": {"n4140": {"so_25109064_25410342_0": {"length": 18, "quality": 0.8181818181818182, "section_id": 6000}}, "n3337": {"so_25109064_25410342_0": {"length": 18, "quality": 0.8181818181818182, "section_id": 5768}}}});