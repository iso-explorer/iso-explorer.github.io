post_cb({"31614816": {"CommentCount": "3", "ViewCount": "378", "CreationDate": "2015-07-24T15:50:21.907", "LastActivityDate": "2015-07-26T10:45:00.097", "Title": "Preventing implicit conversion of some arguments in a templated member function", "AcceptedAnswerId": "31636049", "PostTypeId": "1", "Id": "31614816", "Score": "4", "Body": "<p>Currently I have a member function defined as such:</p>\n<pre><code>template&lt;typename T&gt; bool updateParameter(const std::string&amp; name, const T&amp; data);\n</code></pre>\n<p>With an overload for pointers.</p>\n<pre><code>template&lt;typename T&gt; bool updateParameter(const std::string&amp; name, T* data);\n</code></pre>\n<p>I would like to be able to use this function as such:</p>\n<pre><code>int test = 20;\nupdateParameter&lt;int&gt;(\"name\", 0);\nupdateParameter&lt;int&gt;(\"Referenced parameter\", &amp;test);\n</code></pre>\n<p>This way I can have a parameter object that either owns the data that it represents, or points to a user owned member.</p>\n<p>Now the problem that I have is with the current setup MSVC implicitly will convert the const 0 of \"name\" to a pointer, so it ends up calling the overload designed for pointers.  I can use the explicit keyword, but then I can't get the implicit conversion from const char[] to std::string for the name parameter.\nIs there a way of telling the compiler, MSVC and GCC that a certain field should not be implicitly converted, or at least for it to prefer the const T&amp; version over the T* version?</p>\n", "Tags": "<c++><templates><overloading><implicit><explicit>", "OwnerUserId": "4141975", "AnswerCount": "1"}, "31636049": {"ParentId": "31614816", "CommentCount": "0", "Body": "<p>This is a VC++ bug. The first argument's conversion is identical for both overloads (<code>char const[5]</code> =&gt; <code>std::string const&amp;</code>).<br>\nFor the second argument, there are two distinct standard conversion sequences though: For the <code>T const&amp;</code>-overload, the conversion is an identity conversion - \u00a713.3.3.1.4/1:</br></p>\n<blockquote>\n<p id=\"so_31614816_31636049_0\">When a parameter of reference type binds directly (8.5.3) to an\n  argument expression, the implicit conversion sequence is the identity\n  conversion, unless the argument expression has a type that is a\n  derived class of the parameter type [\u2026]</p>\n</blockquote>\n<p>However, converting <code>0</code> to a pointer type has Conversion rank. \u00a74.10 goes</p>\n<blockquote>\n<p id=\"so_31614816_31636049_1\">A <em>null pointer constant</em> is an integer literal (2.13.2) with value zero\n  or a prvalue of type <code>std::nullptr_t</code>. A null pointer constant can be\n  converted to a pointer type; the result is the <em>null pointer value</em> of\n  that type and is distinguishable from every other value of object\n  pointer or function pointer type. Such a conversion\n  is called a <em>null pointer conversion</em>.</p>\n</blockquote>\n<p>And \u00a713.3.3.1.1/3 categorizes that accordingly, while also listing our identity conversion and how both relate:</p>\n<p><a href=\"https://i.stack.imgur.com/XlCMC.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/XlCMC.png\"/></a></p>\n<hr>\n<p>The best workaround is to simply upgrade VC++, as recent versions select the correct overload (e.g. compare with <a href=\"http://rextester.com/YAYE93057\" rel=\"nofollow noreferrer\">rextester's VC++</a>).<br>\nAnother option is to take <code>data</code> by reference instead for your second overload. Ambiguities would be prevented by \u00a713.3.3.2/3.2.6. Or simply don't overload <code>updateParameter</code> at all and provide a second function template instead.</br></p>\n</hr>", "OwnerUserId": "3647361", "PostTypeId": "2", "Id": "31636049", "Score": "2", "CreationDate": "2015-07-26T10:45:00.097", "LastActivityDate": "2015-07-26T10:45:00.097"}, "bq_ids": {"n4140": {"so_31614816_31636049_1": {"section_id": 39, "quality": 0.9210526315789473, "length": 35}, "so_31614816_31636049_0": {"section_id": 625, "quality": 0.9523809523809523, "length": 20}}, "n3337": {"so_31614816_31636049_1": {"section_id": 36, "quality": 0.868421052631579, "length": 33}, "so_31614816_31636049_0": {"section_id": 615, "quality": 0.9523809523809523, "length": 20}}, "n4659": {"so_31614816_31636049_1": {"section_id": 39, "quality": 0.9210526315789473, "length": 35}, "so_31614816_31636049_0": {"section_id": 651, "quality": 0.9523809523809523, "length": 20}}}});