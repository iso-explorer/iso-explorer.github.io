post_cb({"bq_ids": {"n4140": {"so_32961922_32961922_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 4240}}, "n3337": {"so_32961922_32961922_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 4081}}, "n4659": {"so_32961922_32961922_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 6399}}}, "32961922": {"ViewCount": "92", "Body": "<p>Implementing custom allocator I found out, that for classes which overloads <code>void * operator new(std::size_t)</code> and <code>void operator delete(void *)</code> allocator <code>std::allocator</code> not uses overloaded versions of mentioned operators, but it uses global defined versions of them instead. <a href=\"http://en.cppreference.com/w/cpp/memory/allocator/allocate\" rel=\"nofollow\">Documentation of <code>std::allocator</code></a> said:</p>\n<blockquote>\n<p id=\"so_32961922_32961922_0\">Allocates <code>n * sizeof(T)</code> bytes of uninitialized storage by calling <code>::operator new(std::size_t)</code>, but it is unspecified when and how this function is called.</p>\n</blockquote>\n<p>I think it is possible to make an overload using SFINAE by <code>std::is_class&lt; value_type &gt;{} || std::is_union&lt; value_type &gt;{}</code> or something similar, to dispatch on whether <code>std::allocator_traits&lt; A &gt;::value_type</code> can (ever) provide overloaded versions of the operators and eventually using proper version of them. But it is not enough to use the predicate in such a form.</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;memory&gt;\n#include &lt;new&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\n#include &lt;cstdlib&gt;\n#include &lt;cstddef&gt;\n\n#define PP { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; }\n\n#define ENABLE  std::enable_if_t&lt;  (std::is_class&lt; type &gt;{} || std::is_union&lt; type &gt;{}) &gt; * = nullptr\n#define DISABLE std::enable_if_t&lt; !(std::is_class&lt; type &gt;{} || std::is_union&lt; type &gt;{}) &gt; * = nullptr\n\ntemplate&lt; typename type &gt;\nvoid *\noperator new(std::size_t n, ENABLE) noexcept(false)\n{\n    return type::operator new(n);\n}\n\ntemplate&lt; typename type &gt;\nvoid *\noperator new(std::size_t n, DISABLE) noexcept(false)\n{\n    PP;\n    return ::operator new(n);\n}\n\ntemplate&lt; typename type &gt;\nvoid\noperator delete(void * p, ENABLE) noexcept\n{\n    return type::operator delete(p);\n}\n\ntemplate&lt; typename type &gt;\nvoid\noperator delete(void * p, DISABLE) noexcept\n{\n    PP;\n    return ::operator delete(p);\n}\n\ntemplate&lt; typename type &gt;\nstruct allocator\n{\n\n    using value_type = type;\n\n    value_type *\n    allocate(std::size_t n) noexcept(false)\n    {\n        return static_cast&lt; value_type * &gt;(::operator new&lt; value_type &gt;(n));\n    }\n\n    void\n    deallocate(value_type * p, std::size_t /*n*/) noexcept\n    {\n        return ::operator delete&lt; value_type &gt;(p);\n    }\n\n    template&lt; typename rhs &gt;\n    constexpr\n    bool\n    operator == (allocator&lt; rhs &gt; const &amp; /*_rhs*/) noexcept\n    {\n        return true;\n    }\n\n    template&lt; typename rhs &gt;\n    constexpr\n    bool\n    operator != (allocator&lt; rhs &gt; const &amp; _rhs) noexcept\n    {\n        return !operator == (_rhs);\n    }\n\n};\n\nstruct A\n{\n\n    void *\n    operator new(std::size_t n) noexcept(false)\n    {\n        PP;\n        return ::operator new(n);\n    }\n\n    void\n    operator delete(void * p) noexcept\n    {\n        PP;\n        return ::operator delete(p);\n    }\n\n};\n\nstruct B {};\n\nint\nmain()\n{\n    {\n        std::vector&lt; A, allocator&lt; A &gt; &gt; a;\n        a.resize(1);\n    }\n    std::cout &lt;&lt; std::endl;\n    {\n        std::vector&lt; int, allocator&lt; int &gt; &gt; i;\n        i.resize(1);\n    }\n    std::cout &lt;&lt; std::endl;\n    {\n        //std::vector&lt; B, allocator&lt; B &gt; &gt; b;\n        //b.resize(1);\n    }\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>The output for <code>A</code> type and <code>int</code> type is:</p>\n<pre><code>static void *A::operator new(std::size_t)\nstatic void A::operator delete(void *)\n\nvoid *operator new(std::size_t, std::enable_if_t&lt;!(std::is_class&lt;type&gt;({}) || std::is_union&lt;type&gt;({}))&gt; *) [type = int]\nvoid operator delete(void *, std::enable_if_t&lt;!(std::is_class&lt;type&gt;({}) || std::is_union&lt;type&gt;({}))&gt; *) [type = int]\n</code></pre>\n<p>I.e. dispatching is right, but for <code>B</code> class an error occured:</p>\n<pre><code>main.cpp:34:22: error: no member named 'operator delete' in 'B'\n        return type::operator delete(p);\n               ~~~~~~^\nmain.cpp:60:22: note: in instantiation of function template specialization 'operator delete&lt;B&gt;' requested here\n            return ::operator delete&lt; value_type &gt;(p);\n                     ^\n/usr/local/bin/../lib/gcc/x86_64-unknown-linux-gnu/5.2.0/../../../../include/c++/5.2.0/bits/alloc_traits.h:386:13: note: in instantiation of member function 'allocator&lt;B&gt;::deallocate' requested here\n      { __a.deallocate(__p, __n); }\n            ^\n/usr/local/bin/../lib/gcc/x86_64-unknown-linux-gnu/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h:178:9: note: in instantiation of member function 'std::allocator_traits&lt;allocator&lt;B&gt; &gt;::deallocate' requested here\n          _Tr::deallocate(_M_impl, __p, __n);\n               ^\n/usr/local/bin/../lib/gcc/x86_64-unknown-linux-gnu/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h:160:9: note: in instantiation of member function 'std::_Vector_base&lt;B, allocator&lt;B&gt; &gt;::_M_deallocate' requested here\n      { _M_deallocate(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_end_of_storage\n        ^\n/usr/local/bin/../lib/gcc/x86_64-unknown-linux-gnu/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h:253:7: note: in instantiation of member function 'std::_Vector_base&lt;B, allocator&lt;B&gt; &gt;::~_Vector_base' requested here\n      vector()\n      ^\nmain.cpp:116:46: note: in instantiation of member function 'std::vector&lt;B, allocator&lt;B&gt; &gt;::vector' requested here\n            std::vector&lt; B, allocator&lt; B &gt; &gt; b;\n                                             ^\nmain.cpp:19:22: error: no member named 'operator new' in 'B'\n        return type::operator new(n);\n               ~~~~~~^\nmain.cpp:54:50: note: in instantiation of function template specialization 'operator new&lt;B&gt;' requested here\n            return static_cast&lt; value_type * &gt;(::operator new&lt; value_type &gt;(n));\n                                                 ^\n/usr/local/bin/../lib/gcc/x86_64-unknown-linux-gnu/5.2.0/../../../../include/c++/5.2.0/bits/alloc_traits.h:360:20: note: in instantiation of member function 'allocator&lt;B&gt;::allocate' requested here\n      { return __a.allocate(__n); }\n                   ^\n/usr/local/bin/../lib/gcc/x86_64-unknown-linux-gnu/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h:170:25: note: in instantiation of member function 'std::allocator_traits&lt;allocator&lt;B&gt; &gt;::allocate' requested here\n        return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();\n                               ^\n/usr/local/bin/../lib/gcc/x86_64-unknown-linux-gnu/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc:557:34: note: in instantiation of member function 'std::_Vector_base&lt;B, allocator&lt;B&gt; &gt;::_M_allocate' requested here\n              pointer __new_start(this-&gt;_M_allocate(__len));\n                                        ^\n/usr/local/bin/../lib/gcc/x86_64-unknown-linux-gnu/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h:676:4: note: in instantiation of member function 'std::vector&lt;B, allocator&lt;B&gt; &gt;::_M_default_append' requested here\n          _M_default_append(__new_size - size());\n          ^\nmain.cpp:117:15: note: in instantiation of member function 'std::vector&lt;B, allocator&lt;B&gt; &gt;::resize' requested here\n            b.resize(1);\n              ^\n2 errors generated.\n</code></pre>\n<p>How to detect the presence of overloaded versions of class-scope <code>operator new</code> and <code>operator delete</code>?</p>\n", "Title": "How to detect whether type has overloaded version of operator new and delete?", "CreationDate": "2015-10-06T04:47:26.897", "LastActivityDate": "2015-10-06T05:05:26.467", "CommentCount": "3", "LastEditDate": "2015-10-06T05:05:26.467", "PostTypeId": "1", "LastEditorUserId": "1430927", "Id": "32961922", "Score": "0", "OwnerUserId": "1430927", "Tags": "<c++><c++11><memory-management><operator-overloading><new-operator>", "AnswerCount": "0"}});