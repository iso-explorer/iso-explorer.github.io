post_cb({"28573215": {"ViewCount": "3053", "Body": "<p>An blog author has brought up the discussion about null pointer dereferecing:</p>\n<ul>\n<li><a href=\"http://www.viva64.com/en/b/0306/\" rel=\"nofollow noreferrer\">http://www.viva64.com/en/b/0306/</a></li>\n</ul>\n<p>I've put some counter arguments here:</p>\n<ul>\n<li><a href=\"http://bit.ly/1L98GL4\" rel=\"nofollow noreferrer\">http://bit.ly/1L98GL4</a></li>\n</ul>\n<p>His main line of reasoning quoting the standard is this:</p>\n<blockquote>\n<p id=\"so_28573215_28573215_0\">The '&amp;podhd-&gt;line6' expression is undefined behavior in the C language\n  when 'podhd' is a null pointer.</p>\n<p id=\"so_28573215_28573215_1\">The C99 standard says the following about the '&amp;' address-of operator\n  (6.5.3.2 \"Address and indirection operators\"):</p>\n<p id=\"so_28573215_28573215_2\">The operand of the unary &amp; operator shall be either a function\n  designator, the result of a [] or unary * operator, or an lvalue that\n  designates an object that is not a bit-field and is not declared with\n  the register storage-class specifier.</p>\n<p id=\"so_28573215_28573215_3\">The expression 'podhd-&gt;line6' is clearly not a function designator,\n  the result of a [] or * operator. It is an lvalue expression. However,\n  when the 'podhd' pointer is NULL, the expression does not designate an\n  object since 6.3.2.3 \"Pointers\" says:</p>\n<p id=\"so_28573215_28573215_4\">If a null pointer constant is converted to a pointer type, the\n  resulting pointer, called a null pointer, is guaranteed to compare\n  unequal to a pointer to any object or function.</p>\n<p id=\"so_28573215_28573215_5\">When \"an lvalue does not designate an object when it is evaluated, the\n  behavior is undefined\" (C99 6.3.2.1 \"Lvalues, arrays, and function\n  designators\"):</p>\n<p id=\"so_28573215_28573215_6\">An lvalue is an expression with an object type or an incomplete type\n  other than void; if an lvalue does not designate an object when it is\n  evaluated, the behavior is undefined.</p>\n<p id=\"so_28573215_28573215_7\">So, the same idea in brief:</p>\n<p id=\"so_28573215_28573215_8\">When -&gt; was executed on the pointer, it evaluated to an lvalue where\n  no object exists, and as a result the behavior is undefined.</p>\n</blockquote>\n<p>This question is purely language based, I'm not asking regarding whether a given system allows one to tamper with what lies at address 0 in any language.</p>\n<p>As far as I can see, there's no restriction in dereferencing a pointer variable whose value is equal to <code>nullptr</code>, even thought comparisons of a pointer against the <code>nullptr</code> (or <code>(void *) 0</code>) constant can vanish in optimizations in certain situations because of the stated paragraphs, but this looks like another issue, it doesn't prevent dereferencing a pointer whose value is equal to <code>nullptr</code>. Notice that I've checked other SO questions and answers, I particularly <a href=\"https://stackoverflow.com/a/26919197/1000282\">like this set of quotations</a>, as well as the standard quotes above, and I didn't stumbled upon something that clearly infers from standard that if a pointer <code>ptr</code> compares equal to <code>nullptr</code>, dereferencing it would be undefined behavior.</p>\n<p>At most what I get is that deferencing <em>the constant</em> (or its cast to any pointer type) is what is UB, but nothing saying about a variable that's bit equal to the value that comes up from <code>nullptr</code>.</p>\n<p>I'd like to clearly separate the <code>nullptr</code> constant from a pointer variable that holds a value equals to it. But an answer that address both cases is ideal.</p>\n<p>I do realise that optimizations can quick in when there're comparisons against <code>nullptr</code>, etc and may simply strip code based on that.</p>\n<p>If the conclusion is that, if <code>ptr</code> equals to the value of <code>nullptr</code> dereferencing it is definitely UB, another question follows:</p>\n<p><a href=\"https://stackoverflow.com/q/28574069/1000282\">Do C and C++ standards imply that a special value in the address space must exist solely to represent the value of null pointers?</a></p>\n", "AcceptedAnswerId": "28573259", "Title": "Is dereferencing a pointer that's equal to nullptr undefined behavior by the standard?", "CreationDate": "2015-02-17T23:28:05.867", "Id": "28573215", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:53:11.047", "LastEditorUserId": "-1", "LastActivityDate": "2015-02-18T07:33:30.820", "Score": "2", "OwnerUserId": "1000282", "Tags": "<c++><c><language-lawyer>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_28573215_28573215_4": {"length": 12, "quality": 0.7058823529411765, "section_id": 39}, "so_28573215_28573396_0": {"length": 63, "quality": 0.9, "section_id": 3222}, "so_28573215_28573215_6": {"length": 9, "quality": 0.5294117647058824, "section_id": 6064}, "so_28573215_28573215_8": {"length": 7, "quality": 0.5833333333333334, "section_id": 6142}}, "n3337": {"so_28573215_28573215_4": {"length": 12, "quality": 0.7058823529411765, "section_id": 36}, "so_28573215_28573396_0": {"length": 61, "quality": 0.8714285714285714, "section_id": 3096}, "so_28573215_28573215_6": {"length": 9, "quality": 0.5294117647058824, "section_id": 5832}, "so_28573215_28573215_8": {"length": 7, "quality": 0.5833333333333334, "section_id": 5906}}, "n4659": {"so_28573215_28573215_4": {"length": 12, "quality": 0.7058823529411765, "section_id": 39}, "so_28573215_28573396_0": {"length": 63, "quality": 0.9, "section_id": 3979}, "so_28573215_28573215_6": {"length": 11, "quality": 0.6470588235294118, "section_id": 7709}}}, "28573259": {"Id": "28573259", "PostTypeId": "2", "Body": "<p>As you quote C, dereferencing a null pointer is clearly undefined behavior from this Standard quote (emphasis mine):</p>\n<blockquote>\n<p id=\"so_28573215_28573259_0\">(C11, 6.5.3.2p4) \"If an invalid value has been assigned to the pointer, <strong>the\n          behavior of the unary * operator is undefined</strong>.102)\"</p>\n<p id=\"so_28573215_28573259_1\">102): \"Among the invalid values for dereferencing a pointer by the unary * operator are a <strong>null pointer</strong>, an address inappropriately aligned for the type of object pointed to, and the address of an object after the end of its lifetime.\" </p>\n</blockquote>\n<p>Exact same quote in C99 and similar in C89 / C90.</p>\n", "LastActivityDate": "2015-02-17T23:31:39.100", "CommentCount": "8", "CreationDate": "2015-02-17T23:31:39.100", "ParentId": "28573215", "Score": "9", "OwnerUserId": "1119701"}, "28573396": {"Id": "28573396", "PostTypeId": "2", "Body": "<p><strong>C++</strong></p>\n<p>dcl.ref/5.</p>\n<blockquote>\n<p id=\"so_28573215_28573396_0\">There shall be no references to references, no arrays of references, and no pointers to references. The\n  declaration of a reference shall contain an initializer (8.5.3) except when the declaration contains an explicit\n  extern specifier (7.1.1), is a class member (9.2) declaration within a class definition, or is the declaration\n  of a parameter or a return type (8.3.5); see 3.1. A reference shall be initialized to refer to a valid object or\n  function. [ Note: in particular, a null reference cannot exist in a well-defined program, because <strong>the only way\n  to create such a reference would be to bind it to the \u201cobject\u201d obtained by indirection through a null pointer,\n  which causes undefined behavior.</strong> As described in 9.6, a reference cannot be bound directly to a bit-field.\n  \u2014 end note ]</p>\n</blockquote>\n<p>The note is of interest, as it explicitly says dereferencing a null pointer is undefined.</p>\n<p>I'm sure it says it somewhere else in a more relevant context, but this is good enough.</p>\n", "LastActivityDate": "2015-02-17T23:45:00.350", "CommentCount": "17", "CreationDate": "2015-02-17T23:45:00.350", "ParentId": "28573215", "Score": "3", "OwnerUserId": "3547110"}});