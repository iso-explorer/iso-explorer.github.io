post_cb({"bq_ids": {"n4140": {"so_15770613_15770796_0": {"length": 12, "quality": 1.0, "section_id": 3913}}, "n3337": {"so_15770613_15770796_0": {"length": 12, "quality": 1.0, "section_id": 3773}}, "n4659": {"so_15770613_15770796_0": {"length": 9, "quality": 0.75, "section_id": 4799}}}, "15770796": {"Id": "15770796", "PostTypeId": "2", "Body": "<p><strong>PREMISE:</strong></p>\n<p>First of all, the code is illegal because it misses a <code>return</code> statement (which is likely what is causing the exception that gets raised in the third version):</p>\n<pre><code>ostream&amp; operator&lt;&lt;(ostream&amp; o, const vector&lt;string&gt;&amp; v) {\n    copy(v.begin(), v.end(), std::ostream_iterator&lt;string&gt;(o,\",\"));\n    return o; // &lt;== THIS ONE WAS MISSING\n}\n</code></pre>\n<p>This injects undefined behavior to your program. Per Paragraph 6.6.3/1 of the C++11 Standard, in fact:</p>\n<blockquote>\n<p id=\"so_15770613_15770796_0\">[...] Flowing off the end of a function is equivalent to a return with no value; <strong>this results in undefined\n  behavior in a value-returning function</strong>.</p>\n</blockquote>\n<p><strong>Concerning your first question:</strong></p>\n<p>Once that is fixed, your code is fine, and the implementation of the Standard Library that is shipped with VC9 probably has a bug.</p>\n<p>In fact, the compiler should look up for eligible overloads of <code>operator &lt;&lt;</code> in the namespace of the arguments (<code>std</code>) and in the namespace where the call is being made (the global namespace). As long as your operator is defined in the global namespace <em>and</em> the statement <code>cout &lt;&lt; s_v</code> is in the global namespace, overload resolution should succesfully pick your overload.</p>\n<p><strong>Concerning your second question:</strong></p>\n<blockquote>\n<p id=\"so_15770613_15770796_1\">Why? the template is unused. Should it matter?</p>\n</blockquote>\n<p>That's simple: the compiler has no way of deducing <code>T</code> from the function arguments, so unless you specify it explicitly, this will result in a compilation error. However, specifying the template argument explicitly would mean do something like the following, which is close to non-sense:</p>\n<pre><code>::operator &lt;&lt; &lt;void&gt;(std::cout, s_v);\n</code></pre>\n<p>In C++11 you could specify a default argument for <code>T</code>, which would make the function call legal, bug then again, for what purpose?</p>\n<p><strong>Concerning your third question:</strong></p>\n<p>When <code>T</code> is used in the type of at least one of the function parameters in a deduced context, the compiler will allow to deduce it from the function arguments (in this case, it will deduce <code>T = std::string</code>, and you don't have to specify it explicitly. </p>\n<p><strong>CONCLUSION:</strong></p>\n<p>So to sum it up: after adding the necessary <code>return</code> statement, the first and third versions of your program are legal and make sense, while the second is not and does not.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-04-02T17:54:43.957", "Score": "5", "CreationDate": "2013-04-02T17:49:18.663", "ParentId": "15770613", "CommentCount": "11", "OwnerUserId": "1932150", "LastEditDate": "2013-04-02T17:54:43.957"}, "15770613": {"ViewCount": "3287", "Body": "<p>I am trying to pretty print an STL container. What I am trying to is to print elemets of a container separated with a delimiter.\nHowever I have came across a couple of problems.</p>\n<p><strong>1. g++ vs VC++</strong></p>\n<pre><code>ostream&amp; operator&lt;&lt;(ostream&amp; o, const vector&lt;string&gt;&amp; v) {\n    copy(v.begin(), v.end(), std::ostream_iterator&lt;string&gt;(o,\",\"));\n}\n\nint main()\n{\n\n    vector&lt;string&gt; s_v;\n    s_v.push_back(\"one\");\n    s_v.push_back(\"two\");\n\n    cout &lt;&lt; s_v;\n\n}\n</code></pre>\n<p>g++ (gcc version 4.4.0 on mingw32) can compile it an works fine. VC++ (Visual Studio 9) can not compile this code. </p>\n<pre><code>error C2679: binary '&lt;&lt;' : no operator found which takes a right-hand operand of type 'const std::string' (or there is no acceptable conversion)\n1&gt;        c:\\program files (x86)\\microsoft visual studio 9.0\\vc\\include\\ostream(653): could be 'std::basic_ostream&lt;_Elem,_Traits&gt; &amp;std::operator &lt;&lt;&lt;char,std::char_traits&lt;char&gt;&gt;(std::basic_ostream&lt;_Elem,_Traits&gt; &amp;,const char *)'\n1&gt;        with\n1&gt;        [\n</code></pre>\n<p><strong>why is this? Is this code illegal? or it is just VC++ beign VC++?</strong></p>\n<hr>\n<p><strong>2. Unused template variable breaks compilation.</strong></p>\n<p>if now I add a template to the ostream like this (it is not used, just sitting there)</p>\n<pre><code>template &lt;typename T&gt;  // &lt;----- Here\nostream&amp; operator&lt;&lt;(ostream&amp; o, const vector&lt;string&gt;&amp; v) {\n    copy(v.begin(), v.end(), std::ostream_iterator&lt;string&gt;(o,\",\"));\n}\n\nint main()\n{\n\n    vector&lt;string&gt; s_v;\n    s_v.push_back(\"one\");\n    s_v.push_back(\"two\");\n\n    cout &lt;&lt; s_v;\n\n}\n</code></pre>\n<p><strong>gcc can not match the operator anymore.</strong> </p>\n<pre><code>    error: no match for 'operator&lt;&lt;' in 'std::cout &lt;&lt; s_v'\n\nand a lot more candidates...\n</code></pre>\n<p><strong>Why? the template is unused. Should it matter?</strong></p>\n<hr>\n<p><strong>EDIT: This is solved. I had to return o;</strong></p>\n<p><strong>3. Used template</strong></p>\n<pre><code>template &lt;typename T&gt;\nostream&amp; operator&lt;&lt;(ostream&amp; o, const vector&lt;T&gt;&amp; v) {\n    copy(v.begin(), v.end(), std::ostream_iterator&lt;T&gt;(o,\",\"));\n\n    return o; // Edited\n}\n\nint main()\n{\n\n    vector&lt;string&gt; s_v;\n    s_v.push_back(\"one\");\n    s_v.push_back(\"two\");\n\n    vector&lt;int&gt; i_v;\n    i_v.push_back(1);\n    i_v.push_back(2);\n\n    cout &lt;&lt; s_v;\n    cout &lt;&lt; i_v;\n}\n</code></pre>\n<p><strong>If I know use the template type. g++ can compile it but then terminates with an exception.</strong></p>\n<pre><code>terminate called after throwing an instance of 'std::bad_cast'\n  what():  std::bad_cast\n</code></pre>\n<p>VC++ is just sitting and watching gcc do all of this. Doesn't compile any of them.</p>\n<p>Can someone please clarify this things for me? Thank you.</p>\n</hr></hr>", "AcceptedAnswerId": "15770796", "Title": "Template overloading ostream operator", "CreationDate": "2013-04-02T17:39:24.627", "Id": "15770613", "CommentCount": "12", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-04-02T17:58:52.693", "LastEditorDisplayName": "user2237197", "OwnerDisplayName": "user2237197", "LastActivityDate": "2013-04-02T17:58:52.693", "Score": "5", "Tags": "<c++><templates><operator-overloading>", "AnswerCount": "2"}, "15770871": {"Id": "15770871", "PostTypeId": "2", "Body": "<ol>\n<li><p>As posted, your code shouldn't compile with any compiler.\nYou're missing includes, and a lot of <code>std::</code>.  What I <em>suspect</em>\nis happening is that you don't have all of the necessary\nincludes; in particular, that <code>#include &lt;string&gt;</code> is missing,\nand that g++ picks it up indirectly.  Which is curious.  The\nproblem is usually the inverse: that VC++ picks up a lot of\nextra includes.  At times, however, only partially (so you might\nend up knowing about <code>std::string</code>, but not about the non-member\nfunctions associated with it, like <code>operator&lt;&lt;</code>).  Without\nseeing your actual includes, however, it's difficult to say. </p></li>\n<li><p>The compiler can only perform overload resolution on\nfunctions, not on function templates.  Before starting overload\nresolution, it tries to instantiate an function templates with\nthe correct name.  Successful instantiation results in\na function, which it adds to the overload set.  But how is it\nsupposed to instantiate your function template.  It has no way\nof knowing what to use for <code>T</code>.  So it doesn't instantiate\n(template argument deduction fails), and no instance of it finds\nits way into the overload set.</p></li>\n<li><p>I don't see anything immediate here.  After adding the\nmissing return in the <code>operator&lt;&lt;</code>, it compiles and runs\ncorrectly on VC++.</p></li>\n</ol>\n", "LastActivityDate": "2013-04-02T17:52:56.310", "CommentCount": "1", "CreationDate": "2013-04-02T17:52:56.310", "ParentId": "15770613", "Score": "1", "OwnerUserId": "649665"}});