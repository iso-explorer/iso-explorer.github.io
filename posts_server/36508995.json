post_cb({"36508995": {"ViewCount": "293", "Body": "<p>Suppose we have a pointer <code>T* ptr;</code> and <code>ptr, ptr+1, \u2026 ptr+(n-1)</code> all refer to valid objects of type T.</p>\n<p>Is it possible to access them as if they were an STL <code>array</code>? Or does the following code:</p>\n<pre><code>std::array&lt;T,n&gt;* ay = (std::array&lt;T,n&gt;*) ptr\n</code></pre>\n<p>invoke undefined behaviour?</p>\n", "Title": "Can a std::array alias a fragment of a larger array?", "CreationDate": "2016-04-08T20:42:32.653", "LastActivityDate": "2016-04-09T12:02:47.407", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "Id": "36508995", "Score": "10", "OwnerUserId": "1005379", "Tags": "<c++><arrays><c++11><strict-aliasing><type-punning>", "AnswerCount": "4"}, "36509393": {"Id": "36509393", "PostTypeId": "2", "Body": "<p>This does invoke undefined behavior. You are using <code>reinterpret_cast</code> to cast between unrelated types, and the rules on that are pretty strict. For the closest thing that offers defined behavior, consider the following union:</p>\n<pre><code>union {\n    int carray[10];\n    std::array&lt;10, int&gt; sarray;\n}\n</code></pre>\n<p>If two members of a union have the same prefix (i.e., their first k members are the same type), you can write to the union through one member and read from the other, as long as you restrict yourself to members in the common prefix. If you know with certainty that <code>std::array</code> has a C array as its first member, then this is defined. This seems to be \"basically\" required (<a href=\"https://stackoverflow.com/questions/19103244/is-the-size-of-stdarray-defined-by-standard\">Is the size of std::array defined by standard</a>).</p>\n<p>So in this case, if you take the address of <code>carray</code>, you have an <code>int*</code>, which can be legally cast to a <code>std::array&lt;10, int&gt;</code> indirectly through the union.</p>\n<p>However, there isn't really much reason to do any of this. More likely what you are looking for is something like <code>array_view</code>. It's not in the standard, but the basic idea is that its a generic way to wrap a view (not ownership) of any array. A basic version is pretty simple to implement on your own, or you can check this one out: <a href=\"https://github.com/rhysd/array_view\" rel=\"nofollow noreferrer\">https://github.com/rhysd/array_view</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-04-08T21:09:06.160", "Score": "-1", "CreationDate": "2016-04-08T21:09:06.160", "ParentId": "36508995", "CommentCount": "20", "LastEditDate": "2017-05-23T12:03:09.047", "OwnerUserId": "1908347"}, "36509050": {"Id": "36509050", "PostTypeId": "2", "Body": "<p>Yes, this invokes undefined behaviour. Generally you can't cast pointers to unrelated types between each other.</p>\n<p>The code is no different from </p>\n<pre><code>std::string str;\nstd::array&lt;double,10&gt;* arr = (std::array&lt;double,10&gt;*)(&amp;str);\n</code></pre>\n<p>Explanation: Standard does not provide any guarantee for any compatibility between <code>std::array&lt;T,n&gt;</code> and <code>T*</code>. It is simply not there. It doesn't say that <code>std::array</code> is trivial type either. Absent such guarantees, any conversion between <code>T*</code> and <code>std::array&lt;T,n&gt;</code> is undefined behavior on the same scale as conversion between pointers to any unrelated types.</p>\n<p>I also fail to see what is the benefit of accessing already constructed dynamic array as an <code>std::array</code>.</p>\n<p>P.S. Usual disclaimer. Cast, on it's own, is always 100% fine. It is indirection of resulted pointer which triggers the fireworks - but this part is omited for simplicty.</p>\n", "LastEditorUserId": "1005379", "LastActivityDate": "2016-04-09T12:02:47.407", "Score": "2", "CreationDate": "2016-04-08T20:45:25.090", "ParentId": "36508995", "CommentCount": "8", "LastEditDate": "2016-04-09T12:02:47.407", "OwnerUserId": "5245033"}, "bq_ids": {"n4140": {"so_36508995_36509337_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 6125}}, "n3337": {"so_36508995_36509337_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 5889}}, "n4659": {"so_36508995_36509337_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 7622}}}, "36509758": {"Id": "36509758", "PostTypeId": "2", "Body": "<p>I'm answering the first question here, as the second one has already been treated in the other answers:</p>\n<p>Recap:  you ...</p>\n<blockquote>\n<p id=\"so_36508995_36509758_0\">have a pointer <code>T* ptr;</code> and <code>ptr, ptr+1, \u2026 ptr+(n-1)</code> all refer to valid objects of type T.</p>\n</blockquote>\n<p>And you ask whether it is ...</p>\n<blockquote>\n<p id=\"so_36508995_36509758_1\">possible to access them as if they were an STL <code>array</code>?</p>\n</blockquote>\n<p>Answer: This is no problem -- but it works differently as you estimated in your code example:</p>\n<pre><code>std::array&lt;T*, N&gt; arr;\nfor(int i = 0; i&lt;N; ++i)\n{\n    arr[i] = ptr + i;\n}\n</code></pre>\n<p>Now you can use the array-elements as if they were the original pointers. And there is no undefined behaviour anywhere.</p>\n", "LastEditorUserId": "2412846", "LastActivityDate": "2016-04-08T21:44:04.630", "Score": "0", "CreationDate": "2016-04-08T21:38:50.133", "ParentId": "36508995", "CommentCount": "0", "LastEditDate": "2016-04-08T21:44:04.630", "OwnerUserId": "2412846"}, "36509337": {"Id": "36509337", "PostTypeId": "2", "Body": "<p>Yes, its an Undefined Behavior, a classic one...</p>\n<p>First, understand that what you just did:</p>\n<pre><code>std::array&lt;T,n&gt;* ay = (std::array&lt;T,n&gt;*) ptr\n</code></pre>\n<p>can be translated as:</p>\n<pre><code>using Arr = std::array&lt;T,n&gt;;\nstd::array&lt;T,n&gt;* ay = reinterpret_cast&lt;Arr*&gt;( const_cast&lt;TypeOfPtr&gt;(ptr));\n</code></pre>\n<p>You've not just casted away all, <code>const</code> and <code>volatile</code> qualification but also casted the type. See this answer: <a href=\"https://stackoverflow.com/a/103868/1621391\">https://stackoverflow.com/a/103868/1621391</a> ...indiscriminately casting away <code>cv</code> qualifications can also lead to UB.</p>\n<p>Secondly, It is undefined behavior to access an object through a pointer that was casted from an unrelated type. See <a href=\"https://stackoverflow.com/q/98650/3425536\">the strict aliasing rule</a> (Thanks zenith). Therefore any read or write access through the pointer <code>ay</code> is undefined. If you are extremely lucky, the code should crash instantly. If it works, evil days are awaiting you....</p>\n<p>Note that <a href=\"http://en.cppreference.com/w/cpp/container/array\" rel=\"nofollow noreferrer\"><code>std::array</code></a> is not and will never be the same as anything that isn't <a href=\"http://en.cppreference.com/w/cpp/container/array\" rel=\"nofollow noreferrer\"><code>std::array</code></a>.</p>\n<p>Just to add... In the <a href=\"http://eel.is/c++draft\" rel=\"nofollow noreferrer\">working draft of the C++ standard</a>, it lists <a href=\"http://eel.is/c++draft/#expr\" rel=\"nofollow noreferrer\">out explicit conversion rules</a>. <em>(you can read them)</em> and has a clause stating that</p>\n<blockquote>\n<p id=\"so_36508995_36509337_0\">.....</p>\n<p id=\"so_36508995_36509337_1\"><a href=\"http://eel.is/c++draft/expr.cast#3\" rel=\"nofollow noreferrer\">5.4.3:</a> Any type conversion not mentioned below and not explicitly defined by\n  the user ([class.conv]) is ill-formed.</p>\n<p id=\"so_36508995_36509337_2\">.....</p>\n</blockquote>\n<hr>\n<p>I suggest you cook up your own <a href=\"https://isocpp.org/blog/2014/01/n3851\" rel=\"nofollow noreferrer\"><code>array_view</code></a> (hopefully coming in C++17). Its really easy. Or, if you want some ownership, you can cook up a simple one like this:</p>\n<pre><code>template&lt;typename T&gt;\nclass OwnedArray{\n    T* data_ = nullptr;\n    std::size_t sz = 0;\n    OwnedArray(T* ptr, std::size_t len) : data_(ptr), sz(len) {}\npublic:\n    static OwnedArray own_from(T* ptr, std::size_t len)\n    { return OwnedArray(ptr, len);  }\n\n    OwnedArray(){}\n\n    OwnedArray(OwnedArray&amp;&amp; o)\n    { data_ = o.data_; sz = o.sz; o.data_=nullptr; o.sz=0; }\n\n    OwnedArray&amp; operator = (OwnedArray&amp;&amp; o)\n    { delete[] data_; data_ = o.data_; sz = o.sz; o.data_=nullptr; o.sz=0; }\n\n    OwnedArray(const OwnedArray&amp; o) = delete;\n\n    OwnedArray&amp; operator = (const OwnedArray&amp; o) = delete;    \n\n    ~OwnedArray(){ delete[] data_; }\n\n    std::size_t size() const { return sz; }\n\n    T* data() return { data_; }\n\n    T&amp; operator[] (std::size_t idx) { return data_[idx]; }\n};\n</code></pre>\n<p>...and you can roll out more member functions/const qualifications as you like. But this has caveats... The pointer must have been allocated the through <code>new T[len]</code></p>\n<p>Thus you can use it in your example like this:</p>\n<pre><code>auto ay = OwnedArray&lt;decltype(*ptr)&gt;::own_from(ptr, ptr_len);\n</code></pre>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-04-08T22:48:24.167", "Score": "3", "CreationDate": "2016-04-08T21:05:00.860", "ParentId": "36508995", "CommentCount": "5", "LastEditDate": "2017-05-23T10:34:12.230", "OwnerUserId": "1621391"}});