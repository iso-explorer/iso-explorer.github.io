post_cb({"bq_ids": {"n4140": {"so_48490519_48495362_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 6007}, "so_48490519_48495362_4": {"length": 17, "quality": 0.9444444444444444, "section_id": 5895}, "so_48490519_48495362_1": {"length": 66, "quality": 1.0, "section_id": 6007}}, "n3337": {"so_48490519_48495362_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 5775}, "so_48490519_48495362_4": {"length": 17, "quality": 0.9444444444444444, "section_id": 5666}, "so_48490519_48495362_1": {"length": 65, "quality": 0.9848484848484849, "section_id": 5775}}, "n4659": {"so_48490519_48495362_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 7506}, "so_48490519_48495362_4": {"length": 17, "quality": 0.9444444444444444, "section_id": 7378}, "so_48490519_48495362_1": {"length": 66, "quality": 1.0, "section_id": 7506}}}, "48495362": {"Id": "48495362", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48490519_48495362_0\">We know that members of rvalues are rvalues themselves.</p>\n</blockquote>\n<p>Yes this is true, as states <a href=\"https://timsong-cpp.github.io/cppwp/n4659/expr.ref#4.2\" rel=\"nofollow noreferrer\">[expr.ref]/4.2</a> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_48490519_48495362_1\">If E2 is a non-static data member and the type of E1 is \u201ccq1 vq1 X\u201d, and the type of E2 is \u201ccq2 vq2 T\u201d, the expression designates the named member of the object designated by the first expression. <strong>If E1 is an lvalue, then E1.E2 is an lvalue; otherwise E1.E2 is an xvalue.</strong> Let the notation vq12 stand for the \u201cunion\u201d of vq1 and vq2; that is, if vq1 or vq2 is volatile, then vq12 is volatile. Similarly, let the notation cq12 stand for the \u201cunion\u201d of cq1 and cq2; that is, if cq1 or cq2 is const, then cq12 is const. If E2 is declared to be a mutable member, then the type of E1.E2 is \u201cvq12 T\u201d. If E2 is not declared to be a mutable member, then the type of E1.E2 is \u201ccq12 vq12 T\u201d.</p>\n</blockquote>\n<p>And also, from <a href=\"https://timsong-cpp.github.io/cppwp/n4659/expr.ref#4.5\" rel=\"nofollow noreferrer\">[expr.ref]/4.5</a>:</p>\n<blockquote>\n<p id=\"so_48490519_48495362_2\">If E2 is a member enumerator and the type of E2 is T, the expression E1.E2 is a prvalue. The type of E1.E2 is T. </p>\n</blockquote>\n<p>So far so good. You can only get an lvalue if <code>E1</code> is an lvalue itself, otherwise it's an xvalue or a prvalue.</p>\n<blockquote>\n<p id=\"so_48490519_48495362_3\">But, as a member of an rvalue, c, is already an rvalue.</p>\n</blockquote>\n<p>This is where your assumptions are wrong.</p>\n<p>From <a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.this#1\" rel=\"nofollow noreferrer\">[class.this]/1</a> (emphasis mine)</p>\n<blockquote>\n<p id=\"so_48490519_48495362_4\">In the body of a non-static (9.3) member function, the keyword this is a prvalue expression whose value\n  is the address of the object for which the function is called. <strong>The type of this in a member function of\n  a class X is X*</strong>.</p>\n</blockquote>\n<p><code>this</code> is a prvalue of type <code>X*</code>, and dereferencing a pointer of type <code>X</code> yield an lvalue of type <code>X</code>.</p>\n<p>Since accessing a member inside a member function is equivalent to <code>(*this).m</code>, then <code>m</code> is accessed through an lvalue of type <code>X</code>.</p>\n<p>So your code is equivalent to:</p>\n<pre><code>C1 get1() { return (*this).c; }\n//      lvalue ----^       ^--- must be an lvalue too then.\n</code></pre>\n<p>Since <code>this</code> is always the same type, then even when using a function ref-qualifier the expression <code>c</code> inside a member function will always be an lvalue:</p>\n<pre><code>C1 get1() &amp;&amp; { return (*this).c; }\n//                            ^---- lvalue again, accessing through a pointer\n</code></pre>\n", "LastActivityDate": "2018-01-29T06:14:47.140", "Score": "1", "CreationDate": "2018-01-29T06:14:47.140", "ParentId": "48490519", "CommentCount": "0", "OwnerUserId": "2104697"}, "48490519": {"ViewCount": "131", "Body": "<p>Lets take two structs/classes</p>\n<pre><code>struct C1{\n  C1(){};\n  C1(C1&amp;){std::cout&lt;&lt;\"copy\"&lt;&lt;std::endl;}\n  C1(C1&amp;&amp;){std::cout&lt;&lt;\"move\"&lt;&lt;std::endl;}};\n\nstruct C2{\n  C1 c;\n  C2(){};\n  C1 get1(){return c;}\n  C1 get2(){return std::move(c);}};\n</code></pre>\n<p>And than</p>\n<pre><code>C1 a1=C2().c;\nC1 a2=C2().get1();\nC1 a3=C2().get2();\n</code></pre>\n<p>the output is</p>\n<pre><code>move\ncopy\nmove\n</code></pre>\n<h3>Question</h3>\n<p>We know that members of rvalues are rvalues themselves. This is why with a1, the move constructor is called. Why than, is the copy constructor called in the case of a2. We are returning an rvalue from a function.</p>\n<p>To put it differently, std::move casts to an rvalue. But, as a member of an rvalue, c, is already an rvalue. Why than is there a difference between the behavior with a2 and a3?</p>\n", "Title": "Returning a member from an rvalue object", "CreationDate": "2018-01-28T19:38:12.937", "LastActivityDate": "2018-01-29T16:23:54.913", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-01-29T16:23:54.913", "LastEditorUserId": "2104697", "Id": "48490519", "Score": "8", "OwnerUserId": "5642720", "Tags": "<c++><move-semantics><rvalue>", "AnswerCount": "2"}, "48490562": {"Id": "48490562", "PostTypeId": "2", "Body": "<p>Good question. The dull answer is that there's just no no rule in the C++ spec that says that returning a member from a dying object like this automatically moves it.</p>\n<p>You may be interested in what's called <em>rvalue reference to this</em>. It let's you overload on <code>&amp;&amp;</code> and <code>&amp;</code> such that you can manually implement the behaviour you expected:</p>\n<pre><code>struct C2{\n  C1 c;\n  C2(){};\n  C1 get1() &amp; { std::cout &lt;&lt; \"&amp;\" &lt;&lt; std::endl; return c;}\n  C1 get1() &amp;&amp; { std::cout &lt;&lt; \"&amp;&amp;\" &lt;&lt; std::endl; return std::move(c);}\n  C1 get2(){return std::move(c);}\n};\n</code></pre>\n<p>Now</p>\n<pre><code>C1 a2=C2().get1();\n</code></pre>\n<p>prints</p>\n<pre><code>&amp;&amp;\nmove\n</code></pre>\n<p>Cool, but quite rare. </p>\n<p>Related:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/8610571/what-is-rvalue-reference-for-this\">What is \"rvalue reference for *this\"?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/2220230/is-a-member-of-an-rvalue-structure-an-rvalue-or-lvalue\">Is a member of an rvalue structure an rvalue or lvalue?</a></li>\n</ul>\n", "LastEditorUserId": "1149664", "LastActivityDate": "2018-01-28T19:53:26.657", "Score": "7", "CreationDate": "2018-01-28T19:41:50.983", "ParentId": "48490519", "CommentCount": "2", "OwnerUserId": "1149664", "LastEditDate": "2018-01-28T19:53:26.657"}});