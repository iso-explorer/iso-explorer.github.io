post_cb({"14582505": {"CommentCount": "0", "ViewCount": "3082", "PostTypeId": "1", "LastEditorUserId": "6782", "CreationDate": "2013-01-29T12:07:03.057", "LastActivityDate": "2013-01-29T12:40:39.160", "Title": "Boost condition variables - do calls to \"notify_one\" stack?", "AcceptedAnswerId": "14582643", "LastEditDate": "2013-01-29T12:21:39.577", "Id": "14582505", "Score": "3", "Body": "<p>In a single producer / single consumer application using Boost threads, what happens if the producer thread makes more than one call to <code>cond_var.notify_one()</code> before the consumer thread has called <code>cond_var.wait(lock)</code> ?</p>\n<p>Will the additional calls to <code>notify_one</code> be stacked, such that each call to <code>.wait()</code> will correspond 1:1 with a <code>.notify_one()</code> call?</p>\n<p><strong>EDIT</strong> A <a href=\"http://www.justsoftwaresolutions.co.uk/threading/implementing-a-thread-safe-queue-using-condition-variables.html\" rel=\"nofollow\">commonly quoted example</a> for implementing a concurrent queue has these methods:</p>\n<pre><code>void push(Data const&amp; data)\n{\n    boost::mutex::scoped_lock lock(the_mutex);\n    the_queue.push(data);\n    lock.unlock();\n    the_condition_variable.notify_one();\n}\n\nvoid wait_and_pop(Data&amp; popped_value)\n{\n    boost::mutex::scoped_lock lock(the_mutex);\n    while(the_queue.empty())\n    {\n        the_condition_variable.wait(lock);\n    }\n\n    popped_value=the_queue.front();\n    the_queue.pop();\n}\n</code></pre>\n<p>I've used some very similar code, and experienced some odd memory growth which appears to be explained by the consumer thread not waking up for every <code>.notify_one()</code> (because it's still busy doing other work), and wondered whether lack of \"stacking\" might be the cause.</p>\n<p>It would seem that without stacking this code would fail if (on occasion) the consumer thread cannot keep up with the producer thread.  If my theory is correct, I'd appreciate suggestions on how to remedy this code.</p>\n", "Tags": "<c++><boost><boost-thread>", "OwnerUserId": "6782", "AnswerCount": "2"}, "14582643": {"ParentId": "14582505", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The specification of <code>notify_one</code> is:</p>\n<blockquote>\n<p id=\"so_14582505_14582643_0\">C++11 30.5.1/7: Effects: If any threads are blocked waiting for <code>*this</code>, unblocks one of those theads.</p>\n</blockquote>\n<p>So the answer is no: calls to <code>notify_one</code> and <code>notify_all</code> will only wake thread(s) currently waiting, and are not remembered for later.</p>\n<p>UPDATE: Sorry, I misread the question as <code>std::condition_variable</code>. Not surprisingly, the <a href=\"http://www.boost.org/doc/libs/release/doc/html/thread/synchronization.html#thread.synchronization.condvar_ref.condition_variable.notify_one\" rel=\"noreferrer\">Boost</a> specification is more or less identical:</p>\n<blockquote>\n<p id=\"so_14582505_14582643_1\">If any threads are currently <em>blocked</em> waiting on <code>*this</code> in a call to <code>wait</code> or <code>timed_wait</code>, unblocks one of those threads.</p>\n</blockquote>\n<p>Regarding your edit: If there is no thread waiting when someone calls <code>push</code>, then the next thread to call <code>pop</code> won't wait at all, since <code>the_queue</code> will not be empty. So there's no need for the condition variable to remember that it shouldn't wait; that information is stored in the state being managed, not the condition variable. If the consumer can't keep up with the producer, then you need to either speed up consumption or slow down production; there's nothing you can do to the signalling mechanism to help with that.</p>\n", "OwnerUserId": "204847", "LastEditorUserId": "204847", "LastEditDate": "2013-01-29T12:40:39.160", "Id": "14582643", "Score": "7", "CreationDate": "2013-01-29T12:15:14.733", "LastActivityDate": "2013-01-29T12:40:39.160"}, "14582646": {"ParentId": "14582505", "CommentCount": "0", "Body": "<p>In short: no, it does not stack.</p>\n<p><code>notify_one()</code> has only effect if another thread is waiting on the <code>cond_var</code>. So if your consumer was waiting, the first <code>notify_one()</code> has unblocked the consumer. The second <code>notify_one()</code> has no effect, since no thread is waiting on the <code>condition_variable</code></p>\n", "OwnerUserId": "1838266", "PostTypeId": "2", "Id": "14582646", "Score": "3", "CreationDate": "2013-01-29T12:15:24.527", "LastActivityDate": "2013-01-29T12:15:24.527"}, "bq_ids": {"n4140": {"so_14582505_14582643_1": {"section_id": 2993, "quality": 0.6363636363636364, "length": 7}, "so_14582505_14582643_0": {"section_id": 2993, "quality": 0.6, "length": 6}}, "n3337": {"so_14582505_14582643_1": {"section_id": 2863, "quality": 0.6363636363636364, "length": 7}, "so_14582505_14582643_0": {"section_id": 2863, "quality": 0.6, "length": 6}}, "n4659": {"so_14582505_14582643_1": {"section_id": 3752, "quality": 0.6363636363636364, "length": 7}, "so_14582505_14582643_0": {"section_id": 3752, "quality": 0.6, "length": 6}}}});