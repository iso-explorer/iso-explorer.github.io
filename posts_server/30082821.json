post_cb({"30161637": {"ParentId": "30082821", "CommentCount": "0", "CreationDate": "2015-05-11T07:14:54.590", "OwnerUserId": "4871538", "PostTypeId": "2", "Id": "30161637", "Score": "0", "Body": "<p>Thanks all for posting various suggestions. I try a summarizing answer with an additional proposal for the solution.</p>\n<p>The prerequisite of my question was to reach a class hierarchy that is trivially copyable. See <a href=\"http://en.cppreference.com/w/cpp/concept/TriviallyCopyable\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/concept/TriviallyCopyable</a> and especially the requirement of a trivial destructor (<a href=\"http://en.cppreference.com/w/cpp/language/destructor#Trivial_destructor\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/destructor#Trivial_destructor</a>). The class cannot need a destructor implemented. This restricts the allowed data members, but is fine for me. The example shows only C-compatible types without dynamic memory allocation.</p>\n<p>Some pointed out that the problem of my code is undefined behaviour, not necessarily a memory leak. Marco quoted the standard regarding this. Thanks, really helpful. </p>\n<p>From my understanding of the answers, possible solutions are the following. Please correct me if I am wrong. The solution's point is that the implementation of the base class must avoid that its destructor can be called. </p>\n<p><strong>Solution 1:</strong> The proposed solutions use protected inheritance.</p>\n<pre><code>class CanData : protected Header\n{\n  ...\n};\n</code></pre>\n<p>It works but avoids that people can access the public interface of Header. This was the original intention to have a base class. CanData needs to forward these functions to Header. In the consequece, I would reconsider to use composition instead of inheritance here. But the solution should work.</p>\n<p><strong>Solution 2:</strong> Header's destructor must be protected, not the base class as a whole.</p>\n<pre><code>class Header\n{\npublic:\n  uint8_t Version() const;\n  const Timestamp&amp; StartTime();\n  // ... more simple setters and getters with error checking\n\nprotected:\n  ~Header() = default;\n\nprivate:\n  uint8_t m_Version;\n  Timestamp m_StartTime;\n};\n</code></pre>\n<p>Then no user can delete Header. This is fine for me, because Header has no purpose on its own. With public derivation, the public interface remains available to the user. </p>\n<p>My understanding is that CanData needs not implement a destructor to call the base class's desctructor. All can use the default destructor. I am not completely sure about this though.</p>\n<p>All in all, the answers to my questions in the end of the origial positing are:</p>\n<ol>\n<li><p><strong>Is it right that the class hierarchy without the virtual destructor is a problem even if all classes use the compiler's default destructor?</strong> </p>\n<p>It is only a problem if your destructor is public. You must avoid that people can access you desctrutor, except for derived classes. And you must ensure that derived classes call (implicitely) the base class's destructor.</p></li>\n<li><p><strong>Is it therefore right that I cannot have a safe class hierarchy that is trivially copyable?</strong></p>\n<p>You can make your base class safe with protected inheritance or a protected desctructor. Then you can have a hierarchy of trivially copyable classes.</p></li>\n</ol>\n", "LastActivityDate": "2015-05-11T07:14:54.590"}, "30083758": {"ParentId": "30082821", "CommentCount": "2", "CreationDate": "2015-05-06T17:33:25.883", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "30083758", "Score": "1", "Body": "<p>My first instinct is \"don't do that - find another way, a different framework, or fix the framework\". But just for fun let's assume that for certain your class copy doesn't depend in any way on the copy constructor of the class or any of its comprised parts being called.</p>\n<p>Then since you're clearly inheriting to implement rather than to substitute the solution is easy: Use <code>protected</code> inheritance and your problem is solved, because they can no longer polymorphically access or delete your object, preventing the undefined behavior.</p>\n", "LastActivityDate": "2015-05-06T17:33:25.883"}, "30083007": {"ParentId": "30082821", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-05-06T16:56:08.373", "Score": "0", "LastEditorUserId": "1023390", "LastEditDate": "2015-05-06T17:21:43.690", "Id": "30083007", "OwnerUserId": "1023390", "Body": "<p>It's almost safe. In particular, there is <strong>no memory leak</strong> in</p>\n<pre><code>Header* h = new CanData();\ndelete h;\n</code></pre>\n<p><code>delete h</code> calls the destructor of <code>Header</code> and then frees the memory pointed to by <code>h</code>. The amount of memory freed is the same as was initially allocated at that memory address, not the <code>sizeof(Header)</code>. Since <code>Header</code> and <code>CanData</code> are trivial, their destructors do nothing.</p>\n<p>However, you <strong>must provide a virtual destructor</strong> to base even if it does nothing (by requirement of the standard to avoid undefined behaviour). A common guideline is that a destructor for a base class must be either public and virtual or protected and nonvirtual</p>\n<p>Of course, you must beware slicing as usual.</p>\n", "LastActivityDate": "2015-05-06T17:21:43.690"}, "30082821": {"CommentCount": "5", "ViewCount": "203", "CreationDate": "2015-05-06T16:46:45.230", "LastActivityDate": "2015-05-11T07:14:54.590", "Title": "Can a class hierarchy be safe and trivially copyable?", "PostTypeId": "1", "Id": "30082821", "Score": "11", "Body": "<p>We use a framework that relies on memcpy in certain functions. To my understanding I can give everything that is trivially copyable into these functions.</p>\n<p>Now we want to use a simple class hierarchy. We are not sure whether we can have a class hierarchy that results in trivially copyable types because of the safe destruction. The example code looks like this.</p>\n<pre><code>class Timestamp; //...\n\nclass Header\n{\npublic:\n  uint8_t Version() const;\n  const Timestamp&amp; StartTime();\n  // ... more simple setters and getters with error checking\n\nprivate:\n  uint8_t m_Version;\n  Timestamp m_StartTime;\n};\n\nclass CanData : public Header\n{\npublic:\n  uint8_t Channel();\n  // ... more setters and getters with error checking\n\nprivate:\n  uint8_t m_Channel;\n};\n</code></pre>\n<p>The base class is used in several similar subclasses. Here I omitted all constructors and destructors. Thus the classes are trivially copyable. I suppose though that the user can write a code that results in a memory leak like this:</p>\n<pre><code>void f()\n{\n  Header* h = new CanData();\n  delete h;\n}\n</code></pre>\n<p>Is it right that the class hierarchy without the virtual destructor is a problem even if all classes use the compiler's default destructor? Is it therefore right that I cannot have a safe class hierarchy that is trivially copyable?</p>\n", "Tags": "<c++>", "OwnerUserId": "4871538", "AnswerCount": "5"}, "30083000": {"ParentId": "30082821", "CommentCount": "1", "CreationDate": "2015-05-06T16:55:40.597", "OwnerUserId": "369872", "PostTypeId": "2", "Id": "30083000", "Score": "1", "Body": "<p>If you delete a pointer to a derived type held as its base type and you don't have a virtual destructor, the derived types destructor won't be called, whether it's implicitly generated or not. And whether its implicitly generated or not, you want it to be called. If the derived type's destructor wouldn't actually do anything anyway though, it might not leak anything or cause a problem. If the derived type holds something like a <code>std::string</code>, <code>std::vector</code>, or anything with a dynamic allocation, you want the dtors to be called. As a matter of good practice, you always want a virtual destructor for base classes whether or not the derived classes destructors <em>need</em> to be called (since a base class shouldn't know about what derives from it, it shouldn't make an assumption like this).</p>\n<p>If you copy a type like so:</p>\n<pre><code>Base* b1 = new Derived;\nBase b2 = *b1;\n</code></pre>\n<p>You will only invoke <code>Base</code>s copy ctor. The parts of the object which are actually from <code>Derived</code> will not be involved. <code>b2</code> will not secretly be a <code>Derived</code>, it will just be a <code>Base</code>.</p>\n", "LastActivityDate": "2015-05-06T16:55:40.597"}, "30083102": {"ParentId": "30082821", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-05-06T17:00:44.090", "Score": "4", "LastEditorUserId": "1938163", "LastEditDate": "2015-05-06T17:58:51.880", "Id": "30083102", "OwnerUserId": "1938163", "Body": "<p>This code</p>\n<pre><code>Header* h = new CanData();\ndelete h;\n</code></pre>\n<p>will trigger <strong>undefined behavior</strong> since \u00a75.3.5/p3 states:</p>\n<blockquote>\n<p id=\"so_30082821_30083102_0\">In the first alternative (delete object), if the static type of the object to be deleted is different from its\n  dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the\n  static type shall have a virtual destructor or the behavior is undefined</p>\n</blockquote>\n<p>and regardless of not having dynamically allocated objects contained in your derived class (really bad if you have), you shouldn't do it. Having a class hierarchy without the base class virtual destructor is not a problem <em>per se</em>, it becomes a problem when you try to mix static and dynamic types with <code>delete</code>.</p>\n<p>Doing <code>memcpy</code> on a derived class object smells of bad design to me, I would rather address the need for a \"<em>virtual constructor</em>\" (i.e. a virtual <code>clone()</code> function in your base class) to duplicate your derived objects.</p>\n<p>You can have your class hierarchy that is trivially copyable if you make sure that your object, its subobjects and base classes are trivially copyable. If you want to prevent users referring to your derived objects via base classes you could, as Mark first suggested, <a href=\"http://coliru.stacked-crooked.com/a/35e2bf858fdd08a8\" rel=\"nofollow\">render the inheritance protected</a> </p>\n<pre><code>class Header\n{\npublic:\n};\n\nclass CanData : protected Header\n{               ^^^^^^^^^\npublic:\n};\n\nint main() {\n  Header *pt = new CanData(); // &lt;- not allowed\n  delete pt;\n}\n</code></pre>\n<p>Notice that you won't be able to use base pointers at all to refer to derived objects due to \u00a74.10/p3 - pointer conversions.</p>\n", "LastActivityDate": "2015-05-06T17:58:51.880"}, "bq_ids": {"n4140": {"so_30082821_30083102_0": {"section_id": 6107, "quality": 0.9629629629629629, "length": 26}}, "n3337": {"so_30082821_30083102_0": {"section_id": 5873, "quality": 0.9629629629629629, "length": 26}}, "n4659": {"so_30082821_30083102_0": {"section_id": 7604, "quality": 0.9629629629629629, "length": 26}}}});