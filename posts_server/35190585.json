post_cb({"bq_ids": {"n4140": {"so_35190585_35190714_1": {"length": 19, "quality": 0.76, "section_id": 5979}, "so_35190585_35190714_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 1117}}, "n3337": {"so_35190585_35190714_1": {"length": 19, "quality": 0.76, "section_id": 5747}, "so_35190585_35190714_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 1114}}, "n4659": {"so_35190585_35190714_1": {"length": 14, "quality": 0.56, "section_id": 7461}, "so_35190585_35190714_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 1208}}}, "35190666": {"Id": "35190666", "PostTypeId": "2", "Body": "<p><code>std::priority_queue</code>'s constructor makes a copy of the comparator provided, so it's not a problem if it goes out of scope.</p>\n<p>You can use a lambda as comparator either by using <code>std::function&lt;bool(const T&amp;, const T&amp;)&gt;</code> as comparator type, or directly:</p>\n<pre><code>auto comp = [](int x, int y) { return x &gt; y; };\nstd::priority_queue&lt;int, std::vector&lt;int&gt;, decltype(comp)&gt; q(comp);\n</code></pre>\n<p>You can facilitate this with a helper function:</p>\n<pre><code>template&lt;typename T, typename Compare&gt;\nauto make_priority_queue(Compare&amp;&amp; comp) {\n    return std::priority_queue&lt;T, std::vector&lt;T&gt;, Compare&gt;(std::forward&lt;Compare&gt;(comp));\n}\n\nint main() {\n    auto q = make_priority_queue&lt;int&gt;([](int x, int y) { return x &gt; y; });\n}\n</code></pre>\n", "LastEditorUserId": "3959454", "LastActivityDate": "2016-02-04T01:19:01.230", "Score": "4", "CreationDate": "2016-02-04T00:57:05.923", "ParentId": "35190585", "CommentCount": "4", "OwnerUserId": "3959454", "LastEditDate": "2016-02-04T01:19:01.230"}, "35190679": {"Id": "35190679", "PostTypeId": "2", "Body": "<p>It doesn't go out of scope -- it is copy constructed into the container.  The description on <a href=\"http://en.cppreference.com/w/cpp/container/priority_queue/priority_queue\">cppreference.com</a> states:</p>\n<pre><code>explicit priority_queue( const Compare&amp; compare = Compare(),\n                         const Container&amp; cont = Container() );\n</code></pre>\n<blockquote>\n<p id=\"so_35190585_35190679_0\">Copy-constructs the underlying container c with the contents of cont. Copy-constructs the comparison functor comp with the contents of compare. Calls std::make_heap(c.begin(), c.end(), comp). This is also the default constructor.</p>\n</blockquote>\n<p>There are various other forms of the constructor, but in all cases the internal comparator is either copy- or move-constructed from the one supplied.</p>\n", "LastActivityDate": "2016-02-04T00:58:25.843", "CommentCount": "7", "CreationDate": "2016-02-04T00:58:25.843", "ParentId": "35190585", "Score": "5", "OwnerUserId": "1553090"}, "35190585": {"ViewCount": "428", "Body": "<p>Is there a reason that the <code>std::priority_queue</code>'s constructor accepts a comparator by constant reference? What if the comparator goes out of scope?</p>\n<p>I was thinking about this in the context of possibly moving the comparator as @LightnessRacesInOrbit pointed out!</p>\n<p>I am sorry if there has already been a post about this.  I have not been able to find it!</p>\n", "AcceptedAnswerId": "35190714", "Title": "Comparators in std::priority_queue", "CreationDate": "2016-02-04T00:48:16.373", "Id": "35190585", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-02-04T01:26:33.697", "LastEditorUserId": "5501675", "LastActivityDate": "2016-02-04T01:26:33.697", "Score": "12", "OwnerUserId": "5501675", "Tags": "<c++><c++11><stl><heap><priority-queue>", "AnswerCount": "3"}, "35190714": {"Id": "35190714", "PostTypeId": "2", "Body": "<p>I have never actually thought about this before, and the const-ref indeed is a bit misleading. However, the function signature was thought up before move semantics came along and it became vogue to accept everything by value. Indeed, the comparator is copied!</p>\n<blockquote>\n<p id=\"so_35190585_35190714_0\"><code>[C++14: 23.6.4.1/4]:</code> <em>Effects:</em> Initializes <code>comp</code> with <code>x</code> and <code>c</code> with <code>y</code> (copy constructing or move constructing as appropriate); calls <code>c.insert(c.end(), first, last);</code> and finally calls <code>make_heap(c.begin(), c.end(), comp).</code></p>\n</blockquote>\n<p>Lambdas are not copy-assignable, but they <em>are</em> copy-constructible, so there is no problem here.</p>\n<blockquote>\n<p id=\"so_35190585_35190714_1\"><code>[C++14: 5.1.2/20]:</code> The closure type associated with a <em>lambda-expression</em> has a deleted (8.4.3) default constructor and a deleted copy assignment operator. It has an implicitly-declared copy constructor (12.8) and may have an implicitly-declared move constructor (12.8). <em>[..]</em></p>\n</blockquote>\n<p>Does this prevent move-construction of the comparator itself? Yes, it does. I'm going to assume that this convention, of taking the comparator by const-ref then copying it, stems from the STL days, way before move semantics. I imagine it wasn't seriously considered to add overloads to take the comparator by value because that adds complexity and you shouldn't have a complex, move-enhancible comparator in the first place (give them state, sure, but not <em>too much</em>). Still, this <em>may</em> be worth raising with the committee if you can come up with a solid use case for moving a comparator.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2016-02-04T01:21:47.580", "Score": "8", "CreationDate": "2016-02-04T01:02:41.970", "ParentId": "35190585", "CommentCount": "7", "OwnerUserId": "560648", "LastEditDate": "2016-02-04T01:21:47.580"}});