post_cb({"11028929": {"CommentCount": "1", "CreationDate": "2012-06-14T07:56:05.293", "PostTypeId": "1", "AcceptedAnswerId": "11029028", "LastEditorUserId": "134841", "LastActivityDate": "2012-06-14T12:26:07.630", "LastEditDate": "2012-06-14T12:26:07.630", "ViewCount": "1695", "FavoriteCount": "3", "Title": "Move operator with templates", "Id": "11028929", "Score": "3", "Body": "<p>I have a templated class that I want to avoid copying (because of the potential cost to do so). I can implement a move constructor, but I would also like to allow moving \"accross template parameter\". Here is what I'm trying to compile:</p>\n<pre><code>template &lt;class T&gt;\nclass Foo\n{\npublic:\n    Foo() {}\n    template &lt;class U&gt; Foo(Foo&lt;U&gt;&amp;&amp;) {}\n\nprivate:\n    Foo(const Foo&amp;);\n};\n\nFoo&lt;int&gt; f() { Foo&lt;float&gt; y; return move(y); }\nFoo&lt;int&gt; g() { Foo&lt;int&gt; x; return x; }\nFoo&lt;int&gt; h() { Foo&lt;float&gt; z; return z; }\n</code></pre>\n<p>I understand why technically f compiles: the type of move(y) is Foo(float)&amp;&amp; and there happens to be a handy constructor that takes a Foo(U)&amp;&amp;, so the compiler manages to find that U=float works.</p>\n<p>h doesn't compile. z is of type Foo(float) and I guess that's too far from Foo(U)&amp;&amp; to figure out that the move constructor can be invoked if U=float is chosen...</p>\n<p>I'm not sure why g compiles, but it does. The type of x is Foo(int). How does the compiler manage to use the move operator (it can't just implicit cast from Foo(int) to Foo(int)&amp;&amp;, can it?)</p>\n<p>So my questions are: what are the rules? why does h compiles but g doesnt? is there something I can change in Foo to make h compile?</p>\n<p>Thank you</p>\n", "Tags": "<c++><templates><c++11><move-semantics>", "OwnerUserId": "1455590", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_11028929_11029028_3": {"section_id": 481, "quality": 0.6896551724137931, "length": 20}, "so_11028929_11029028_1": {"section_id": 452, "quality": 0.9310344827586207, "length": 27}, "so_11028929_11029028_2": {"section_id": 480, "quality": 1.0, "length": 23}, "so_11028929_11029028_0": {"section_id": 451, "quality": 0.9, "length": 27}}, "n3337": {"so_11028929_11029028_3": {"section_id": 472, "quality": 1.0, "length": 29}, "so_11028929_11029028_1": {"section_id": 443, "quality": 0.9310344827586207, "length": 27}, "so_11028929_11029028_2": {"section_id": 471, "quality": 1.0, "length": 23}, "so_11028929_11029028_0": {"section_id": 442, "quality": 0.9, "length": 27}}, "n4659": {"so_11028929_11029028_3": {"section_id": 504, "quality": 0.5517241379310345, "length": 16}, "so_11028929_11029028_1": {"section_id": 475, "quality": 0.9310344827586207, "length": 27}, "so_11028929_11029028_2": {"section_id": 502, "quality": 0.9130434782608695, "length": 21}, "so_11028929_11029028_0": {"section_id": 474, "quality": 0.9, "length": 27}}}, "11029028": {"ParentId": "11028929", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>A copy or move constructor mustn't be a template. From 12.8(2, 3):</p>\n<blockquote>\n<p id=\"so_11028929_11029028_0\">A <strong>non-template</strong> constructor for class <code>X</code> is a copy constructor if its first parameter is of type <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code> or <code>const volatile X&amp;</code>, and either there are no other parameters or else all other parameters have default arguments (8.3.6). [Example: <code>X::X(const X&amp;)</code> and <code>X::X(X&amp;,int=1)</code> are copy constructors.]</p>\n<p id=\"so_11028929_11029028_1\">A <strong>non-template</strong> constructor for class <code>X</code> is a move constructor if its first parameter is of type <code>X&amp;&amp;</code>, <code>const X&amp;&amp;</code>, <code>volatile X&amp;&amp;</code>, or <code>const volatile X&amp;&amp;</code>, and either there are no other parameters or else all other parameters have default arguments (8.3.6). [Example: <code>Y::Y(Y&amp;&amp;)</code> is a move constructor.]</p>\n</blockquote>\n<p>So your example <code>f</code> and <code>g</code> work because you're invoking an ordinary constructor (not a <em>move</em>-constructor).</p>\n<p><code>f</code> works for obvious reasons, because the result of <code>move(y)</code> can bind to <code>Foo&lt;float&gt;&amp;&amp;</code>. <code>g</code> works for a different reason: Since the type of <code>x</code> is the same as the return type of the function, the value of the expression <code>x</code> in the return statement matches <code>Foo&lt;int&gt;&amp;&amp;</code>. This is because of 12.8(31, 32): </p>\n<blockquote>\n<p id=\"so_11028929_11029028_2\">in a <code>return</code> statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function or catch-clause parameter) <strong>with the same cv-unqualified type as the function return type</strong>, [...]</p>\n<p id=\"so_11028929_11029028_3\">When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue.</p>\n</blockquote>\n<p>Finally we see why <code>h</code> doesn't work: The value of the expression <code>z</code> in the <code>return</code> statement cannot bind to <code>Foo&lt;float&gt;&amp;&amp;</code>, because it is not explicitly cast (via <code>std::move</code>), nor given the special dispensation of clause 12.8(32), since its type is not the same as the function's return type.  (It can only bind to <code>Foo&lt;float&gt;&amp;</code> (which would almost surely be wrong) or to <code>Foo&lt;float&gt; const &amp;</code>.)</p>\n<p><br/></p>\n<p>By the way, there's no point moving objects that don't manage external resources (e.g. primitives). The actual object data has to be copied anyway.</p>\n", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2012-06-14T12:15:56.793", "Id": "11029028", "Score": "6", "CreationDate": "2012-06-14T08:04:28.593", "LastActivityDate": "2012-06-14T12:15:56.793"}});