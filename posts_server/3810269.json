post_cb({"3817419": {"ParentId": "3810269", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2010-09-28T22:15:50.690", "Score": "4", "LastEditorUserId": "34509", "LastEditDate": "2010-09-28T22:31:35.250", "Id": "3817419", "OwnerUserId": "34509", "Body": "<p>I find this quite mind-screwing, and the committee has <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#287\" rel=\"nofollow\">more such fun</a>. So I think it's likely I have some errors in the below. So please read it with care :)</p>\n<p><strong>Third paragraph</strong></p>\n<blockquote>\n<p id=\"so_3810269_3817419_0\">For a class template specialization, a class member template specialization, or a specialization for a class member of a class template, if the specialization is implicitly instantiated because it is referenced from within another template specialization, if the context from which the specialization is referenced depends on a template parameter, and if the specialization is not instantiated previous to the instantiation of the enclosing template, the point of instantiation is immediately before the point of instantiation of the enclosing template. </p>\n</blockquote>\n<p>In other words, if a class template or a nested class of a class template is instantiated, and the context that causes that instantiation depends on a template parameter, the template/nested class is instantiated immediately before the point of instantiation of the template that refers to it. </p>\n<p>The context in the other specialization can either depend on template parameters, which is the case for primary templates, partial specializations and members of a class template, or it does <em>not</em> depend on template parameters, which is the case for references from within explicit specializations. </p>\n<blockquote>\n<p id=\"so_3810269_3817419_1\">Otherwise [i.e. the context is nondependent], the point of\n  instantiation for such a specialization immediately precedes the namespace scope declaration or definition that refers to the specialization.</p>\n</blockquote>\n<p>This distinction is important. Consider what would happen if the point of instantiation for specializations from dependent contexts would preceede immediately to the namespace scope declaration or definition that refers to it</p>\n<pre><code>template&lt;typename T, int N&gt; \nstruct A {\n  typedef typename A&lt;T, N-1&gt;::type *type;\n};\n\ntemplate&lt;typename T&gt;\nstruct A&lt;T, 0&gt; {\n  typedef T type;\n};\n\ntypedef A&lt;int, 2&gt;::type ptr;\n</code></pre>\n<p>This template is supposed to add <code>N</code> pointer declarators. So <code>A&lt;int, 2&gt;</code> is <code>int**</code> for example.</p>\n<ul>\n<li>The context around <code>typedef A&lt;int, 2&gt;::type</code> is non-dependent, so <code>A&lt;int, 2&gt;</code> is instantiated before the typedef declaration. </li>\n<li><p><em>Within</em> <code>A&lt;int, 2&gt;</code>, we have <code>A&lt;int, N-1&gt;::type</code>, which appears in a dependent context and which references <code>A&lt;int, 1&gt;::type</code>. So the Standard requires us to instantiate <code>A&lt;int, 1&gt;</code> at the same point we instantiated <code>A&lt;int, 2&gt;</code>. </p>\n<p>If we <em>would</em> instantiate this immediately before the namespace scope declaration that referred to it (before the primary template definition), we would not notice the partial specialization <code>A&lt;T, 0&gt;</code> when processing <code>`A&lt;int, N-1&gt;::type</code> within <code>A&lt;int, 1&gt;</code> because we would instantiate <code>A&lt;int, 1&gt;</code> <em>before</em> that specialization. </p></li>\n</ul>\n<p><strong>Second paragraph</strong></p>\n<p>This is just so that names looked up in default arguments are consistent with names looked up in the rest of the function that they are used for (i.e their POI is the same as the POI of their function template / member function of class template). </p>\n<p><strong>First paragraph</strong></p>\n<p>This is basically the same as the third paragraph. However, function templates are instantiated after the entity that refer to them so that recursive uses are possible, like in the following example. In contrast, class templates are instantiated <em>before</em> the entity that refer to them because the entity required that class type to be complete. If the class type's POI would be after that entity, the class type would still be non-existent.</p>\n<pre><code>template&lt;typename T&gt;\nvoid f(T);\n\ntemplate&lt;typename T&gt;\nstruct A {\n  void g() {\n    f(0);\n  }\n\n  void h() { /* do a dance */ }\n};\n\ntemplate&lt;typename T&gt;\nvoid f(T t) {\n  A&lt;T&gt; a;\n  a.h();\n}\n\nvoid g() {\n  A&lt;int&gt; a; \n  a.g();\n}\n</code></pre>\n<p>If <code>f</code> would be instantiated <em>before</em> <code>A&lt;int&gt;</code>, then it could not access <code>a.h()</code> because at that point it did not exist yet. Therefor, function templates are instantiated after the entity that refer to them, and class templates are instantiated before the entity that refer to them. </p>\n", "LastActivityDate": "2010-09-28T22:31:35.250"}, "3810269": {"CommentCount": "3", "CreationDate": "2010-09-28T06:38:42.903", "PostTypeId": "1", "AcceptedAnswerId": "3817419", "LastEditorUserId": "112", "LastActivityDate": "2010-09-29T03:02:11.007", "AnswerCount": "2", "LastEditDate": "2010-09-28T07:25:39.190", "ViewCount": "634", "FavoriteCount": "2", "Title": "Templates :Name resolution:Point of instantiation: -->can any one tell some more examples for this statement?", "Id": "3810269", "Score": "3", "Body": "<p>This is the statement from ISO C++ Standard 14.6.4.1 Point of instantiation</p>\n<blockquote>\n<ol>\n<li><p id=\"so_3810269_3810269_0\">For a function template specialization, a member function template \n    specialization, or a specialization for a member function or static \n    data member of a class template, if the specialization is implicitly \n    instantiated because it is referenced from within another template \n    specialization and the context from which it is referenced depends on a \n    template parameter, the point of instantiation of the specialization is \n    the point of instantiation of the enclosing specialization. Otherwise, \n    the point of instantiation for such a specialization immediately follows \n    the namespace scope declaration or definition that refers to the\n    specialization.</p></li>\n<li><p id=\"so_3810269_3810269_1\">If a function template or member function of a class template is called in\n    a way which uses the definition of a default argument of that function \n    template or member function, the point of instantiation of the default\n    argument is the point of instantiation of the function template or member \n   function specialization.</p></li>\n<li><p id=\"so_3810269_3810269_2\">For a class template specialization, a class member template specialization, \n   or a specialization for a class member of a class template, if the \n   specialization is implicitly instantiated because it is referenced from\n   within another template specialization, if the context from which the\n   specialization is referenced depends on a template parameter, and if the<br>\n   specialization is not instantiated previous to the instantiation of the\n   enclosing template, the point of instantiation is immediately before the\n   point of instantiation of the enclosing template. Otherwise, the point of<br>\n   instantiation for such a specialization immediately precedes the\n   namespace scope declaration or definition that refers to the specialization.</br></br></p></li>\n</ol>\n</blockquote>\n<p>I am unable to write a programs for this whole section. I am trying to write a programs for this section from yesterday.</p>\n<p>Can any one provide me a code for this sections to understand.</p>\n<p>Please, normally ..I tried to ask a 1 or more points. In any section. But here iam unable to understand a single point in this section.</p>\n<p>So, kindly can any one provide me a code(programs) for this sections to understand.</p>\n", "Tags": "<c++><templates>", "OwnerDisplayName": "BE Student"}, "bq_ids": {"n4140": {"so_3810269_3810269_1": {"section_id": 217, "quality": 1.0, "length": 27}, "so_3810269_3810269_0": {"section_id": 216, "quality": 0.98, "length": 49}, "so_3810269_3810269_2": {"section_id": 219, "quality": 0.9818181818181818, "length": 54}, "so_3810269_3817419_1": {"section_id": 219, "quality": 0.8666666666666667, "length": 13}, "so_3810269_3817419_0": {"section_id": 219, "quality": 0.9761904761904762, "length": 41}}, "n3337": {"so_3810269_3810269_1": {"section_id": 211, "quality": 1.0, "length": 27}, "so_3810269_3810269_0": {"section_id": 210, "quality": 0.98, "length": 49}, "so_3810269_3810269_2": {"section_id": 212, "quality": 0.9818181818181818, "length": 54}, "so_3810269_3817419_1": {"section_id": 212, "quality": 0.8666666666666667, "length": 13}, "so_3810269_3817419_0": {"section_id": 212, "quality": 0.9761904761904762, "length": 41}}, "n4659": {"so_3810269_3810269_1": {"section_id": 225, "quality": 1.0, "length": 27}, "so_3810269_3810269_0": {"section_id": 224, "quality": 0.98, "length": 49}, "so_3810269_3810269_2": {"section_id": 227, "quality": 0.9818181818181818, "length": 54}, "so_3810269_3817419_1": {"section_id": 227, "quality": 0.8666666666666667, "length": 13}, "so_3810269_3817419_0": {"section_id": 227, "quality": 0.9761904761904762, "length": 41}}}, "3811399": {"ParentId": "3810269", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2010-09-28T09:30:59.520", "Score": "0", "LastEditorUserId": "418110", "LastEditDate": "2010-09-29T03:02:11.007", "Id": "3811399", "OwnerUserId": "418110", "Body": "<p>Request some one to correct my understanding...</p>\n<p><strike>I think the code below illustrates what 1 and 2 mean (from what I have understood):</strike></p>\n<pre><code>template&lt;class T&gt; void f1(T t){cout &lt;&lt; 0;} \n\ntemplate&lt;class T&gt; void f2(T t, void (*p)(int) = f1){\n   (*p)(0);\n} \n\nvoid f(double d){cout &lt;&lt; 1;} \n\ntemplate&lt;class T&gt; void g(T t){ \n    f1(t);            // this is the interesting call. \n} \n\nvoid f1(int t){cout &lt;&lt; 2;} \n\nint main(){ \n    g(2); \n    f2(2);\n}     // POI for f1(t), Also POI for f2(2)\n</code></pre>\n<p>Consider the call g(2). At the POI, there are basically three overloads (viable) that are visible:</p>\n<ol>\n<li>function template</li>\n<li>f(int)</li>\n<li>f(double).</li>\n</ol>\n<p>The call however routs to 'f(int)' as this is the best match.</p>\n<p>In the same way, the POI for 'f2(2)' is the closing brace of main. The default argument 'f1' is once again looked up from this POI and resolves to 'f1(int)' which is the best match of all the three overloads available. </p>\n<p>Thanks @litb. Revised after @litb corrected my understanding:</p>\n<pre><code>double f1(double d){cout &lt;&lt; 1; return 0.0;} \n\ntemplate&lt;class T&gt; void f2(T t1, T t2 = f1(T())){} \n\ntemplate&lt;class T&gt; void g(T t){ \n        f1(t);            // this is the interesting call. \n} \n\nstruct A{\n        friend A f1(A const &amp;){cout &lt;&lt; 2; return A();} \n};\n\nint main(){ \n        g(A());   // 'f1(t)' resolves to friend function declaration\n        f2(A());  // The call to 'f1' in default argument also resolves to friend \n                  // function declaration\n                  // This is because for non dependent names, only ADL is performed\n                  // at POI which is at closing brace of main.\n}     // POI for f1(t), Also POI for f2(2) in that order\n</code></pre>\n<p>Remember that in both the above calls, there are two overloads that are candidates. The namspace function 'f1(double)' and the friend function 'f1' declaration (found due to ADL). Since this is the only viable function, the calls resolve to the friend declaration 'f1'.</p>\n<p>I think Point 3 means this:</p>\n<pre><code>template&lt;class A&gt; struct T{\n        T(int x = 0){}\n};\n\ntemplate&lt;class A&gt; struct U{\n        U():t(f(A())){}\n\n        T&lt;A&gt; t;\n}; // POI of 'gt' instantiation\n\nT&lt;int&gt; gt(f(2));         // At this point 'f' is not found, hence error\n\nint f(int x){return x;}\n\nint main(){\n        U&lt;int&gt; u;\n} // There are 2 POIs here 'U&lt;int&gt;::T&lt;int&gt;' and 'U&lt;int&gt;' and in that order\n  // Therefore 'f' is visible from here.\n</code></pre>\n", "LastActivityDate": "2010-09-29T03:02:11.007"}});