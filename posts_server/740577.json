post_cb({"bq_ids": {"n4140": {"so_740577_740686_0": {"length": 57, "quality": 0.8769230769230769, "section_id": 5913}}, "n3337": {"so_740577_740686_0": {"length": 57, "quality": 0.8769230769230769, "section_id": 5685}}, "n4659": {"so_740577_740686_0": {"length": 39, "quality": 0.6, "section_id": 7404}}}, "740608": {"Id": "740608", "PostTypeId": "2", "Body": "<p>You should really look at a union as a container for the largest datatype inside it combined with a shortcut for a cast. When you use one of the smaller members, the unused space is still there, but it simply stays unused. </p>\n<p>You often see this used in combination with ioctl() calls under in Unix, all ioctl() calls will pass the same struct, which contains a union of all possible responses. E.g. \nthis example comes from /usr/include/linux/if.h and this struct is used in ioctl()'s for configuring/querying the state of an ethernet interface, the request parameters defines which part of the union is actually in use:</p>\n<pre><code>struct ifreq \n{\n#define IFHWADDRLEN 6\n    union\n    {\n        char    ifrn_name[IFNAMSIZ];        /* if name, e.g. \"en0\" */\n    } ifr_ifrn;\n\n    union {\n        struct  sockaddr ifru_addr;\n        struct  sockaddr ifru_dstaddr;\n        struct  sockaddr ifru_broadaddr;\n        struct  sockaddr ifru_netmask;\n        struct  sockaddr ifru_hwaddr;\n        short   ifru_flags;\n        int ifru_ivalue;\n        int ifru_mtu;\n        struct  ifmap ifru_map;\n        char    ifru_slave[IFNAMSIZ];   /* Just fits the size */\n        char    ifru_newname[IFNAMSIZ];\n        void *  ifru_data;\n        struct  if_settings ifru_settings;\n    } ifr_ifru;\n};\n</code></pre>\n", "LastActivityDate": "2009-04-11T18:49:58.987", "CommentCount": "0", "CreationDate": "2009-04-11T18:49:58.987", "ParentId": "740577", "Score": "2", "OwnerUserId": "15791"}, "740588": {"Id": "740588", "PostTypeId": "2", "Body": "<p>There is no notion of active datatype for a union. You are free to read and write any 'member' of the union: this is up to you to interpret what you get.</p>\n<p>Therefore, the sizeof a union is always the sizeof its largest datatype.</p>\n", "LastActivityDate": "2009-04-11T18:33:30.120", "CommentCount": "4", "CreationDate": "2009-04-11T18:33:30.120", "ParentId": "740577", "Score": "9", "OwnerUserId": "45249"}, "740579": {"Id": "740579", "PostTypeId": "2", "Body": "<p>A <code>union</code> always takes up as much space as the largest member. It doesn't matter what is currently in use.</p>\n<pre><code>union {\n  short x;\n  int y;\n  long long z;\n}\n</code></pre>\n<p>An instance of the above <code>union</code> will always take at least a <code>long long</code> for storage.</p>\n<p><em>Side note</em>: As noted by <a href=\"https://stackoverflow.com/questions/740577/sizeof-a-union-in-c-c/740653#740653\">Stefano</a>, the actual space any type (<code>union</code>, <code>struct</code>, <code>class</code>) will take does depend on other issues such as alignment by the compiler. I didn't go through this for simplicity as I just wanted to tell that a union takes the biggest item into account. <strong>It's important to know that the actual size <em>does</em> depend on alignment</strong>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2009-04-15T23:11:30.027", "Score": "47", "CreationDate": "2009-04-11T18:28:21.583", "ParentId": "740577", "CommentCount": "3", "OwnerUserId": "33708", "LastEditDate": "2017-05-23T12:02:34.407"}, "740589": {"Id": "740589", "PostTypeId": "2", "Body": "<p>The size will be at least that of the largest composing type. There is no concept of an \"active\" type.</p>\n", "LastEditorDisplayName": "anon", "OwnerDisplayName": "anon", "LastActivityDate": "2009-04-11T19:31:00.853", "Score": "3", "CreationDate": "2009-04-11T18:33:40.430", "ParentId": "740577", "CommentCount": "1", "LastEditDate": "2009-04-11T19:31:00.853"}, "740653": {"Id": "740653", "PostTypeId": "2", "Body": "<p>It depends on the compiler, and on the options.</p>\n<pre><code>int main() {\n  union {\n    char all[13];\n    int foo;\n  } record;\n\nprintf(\"%d\\n\",sizeof(record.all));\nprintf(\"%d\\n\",sizeof(record.foo));\nprintf(\"%d\\n\",sizeof(record));\n\n}\n</code></pre>\n<p>This outputs:</p>\n<p>13\n4\n16</p>\n<p>If I remember correctly, it depends on the alignment that the compiler puts into the allocated space. So, unless you use some special option, the compiler will put padding into your union space.</p>\n<p>edit: with gcc you need to use a pragma directive</p>\n<pre><code>int main() {\n#pragma pack(push, 1)\n      union {\n           char all[13];\n           int foo;\n      } record;\n#pragma pack(pop)\n\n      printf(\"%d\\n\",sizeof(record.all));\n      printf(\"%d\\n\",sizeof(record.foo));\n      printf(\"%d\\n\",sizeof(record));\n\n}\n</code></pre>\n<p>this outputs</p>\n<p>13\n4\n13</p>\n<p>You can also see it from the disassemble (removed some printf, for clarity)</p>\n<pre><code>  0x00001fd2 &lt;main+0&gt;:    push   %ebp             |  0x00001fd2 &lt;main+0&gt;:    push   %ebp\n  0x00001fd3 &lt;main+1&gt;:    mov    %esp,%ebp        |  0x00001fd3 &lt;main+1&gt;:    mov    %esp,%ebp\n  0x00001fd5 &lt;main+3&gt;:    push   %ebx             |  0x00001fd5 &lt;main+3&gt;:    push   %ebx\n  0x00001fd6 &lt;main+4&gt;:    sub    $0x24,%esp       |  0x00001fd6 &lt;main+4&gt;:    sub    $0x24,%esp\n  0x00001fd9 &lt;main+7&gt;:    call   0x1fde &lt;main+12&gt; |  0x00001fd9 &lt;main+7&gt;:    call   0x1fde &lt;main+12&gt;\n  0x00001fde &lt;main+12&gt;:   pop    %ebx             |  0x00001fde &lt;main+12&gt;:   pop    %ebx\n  0x00001fdf &lt;main+13&gt;:   movl   $0xd,0x4(%esp)   |  0x00001fdf &lt;main+13&gt;:   movl   $0x10,0x4(%esp)                                         \n  0x00001fe7 &lt;main+21&gt;:   lea    0x1d(%ebx),%eax  |  0x00001fe7 &lt;main+21&gt;:   lea    0x1d(%ebx),%eax\n  0x00001fed &lt;main+27&gt;:   mov    %eax,(%esp)      |  0x00001fed &lt;main+27&gt;:   mov    %eax,(%esp)\n  0x00001ff0 &lt;main+30&gt;:   call  0x3005 &lt;printf&gt;   |  0x00001ff0 &lt;main+30&gt;:   call   0x3005 &lt;printf&gt;\n  0x00001ff5 &lt;main+35&gt;:   add    $0x24,%esp       |  0x00001ff5 &lt;main+35&gt;:   add    $0x24,%esp\n  0x00001ff8 &lt;main+38&gt;:   pop    %ebx             |  0x00001ff8 &lt;main+38&gt;:   pop    %ebx\n  0x00001ff9 &lt;main+39&gt;:   leave                   |  0x00001ff9 &lt;main+39&gt;:   leave\n  0x00001ffa &lt;main+40&gt;:   ret                     |  0x00001ffa &lt;main+40&gt;:   ret    \n</code></pre>\n<p>Where the only difference is in main+13, where the compiler allocates on the stack 0xd instead of 0x10</p>\n", "LastEditorUserId": "78374", "LastActivityDate": "2009-04-11T19:47:38.257", "Score": "15", "CreationDate": "2009-04-11T19:20:01.130", "ParentId": "740577", "CommentCount": "3", "OwnerUserId": "78374", "LastEditDate": "2009-04-11T19:47:38.257"}, "740577": {"ViewCount": "42730", "Body": "<p>What is the sizeof the union in C/C++? Is it the sizeof the largest datatype inside it? If so, how does the compiler calculate how to move the stack pointer if one of the smaller datatype of the union is active?</p>\n", "AcceptedAnswerId": "740686", "Title": "sizeof a union in C/C++", "CreationDate": "2009-04-11T18:27:19.087", "Id": "740577", "CommentCount": "0", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2012-08-14T17:52:20.777", "LastEditorUserId": "718379", "LastActivityDate": "2016-09-12T12:23:08.293", "Score": "33", "OwnerUserId": "39742", "Tags": "<c++><c><sizeof><unions>", "AnswerCount": "8"}, "39450241": {"Id": "39450241", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_740577_39450241_0\">What is the sizeof the union in C/C++? Is it the sizeof the largest\n  datatype inside it?</p>\n</blockquote>\n<p><strong>Yes</strong>, The size of the union is the size of its biggest member.</p>\n<p>For Example : </p>\n<pre><code>#include&lt;stdio.h&gt;\n\nunion un\n{\n    char c;\n    int i;\n    float f;\n    double d;\n};\n\nint main()\n{\n    union un u1;\n    printf(\"sizeof union u1 : %ld\\n\",sizeof(u1));\n    return 0;\n}\n</code></pre>\n<p><strong>Output :</strong></p>\n<pre><code>sizeof union u1 : 8\nsizeof double d : 8\n</code></pre>\n<p>Here biggest member is <code>double</code>. Both have size <code>8</code>. So, as <code>sizeof</code> correctly told you, the size of the union is indeed <code>8</code>.</p>\n<blockquote>\n<p id=\"so_740577_39450241_1\">how does the compiler calculate how to move the stack pointer if one\n  of the smaller datatype of the union is active?</p>\n</blockquote>\n<p>It internally handles by the compiler. Suppose we are accessing one of the data member of union then we cannot access other data member since we can access single data member of union because each data member shares same memory. By Using Union we can Save Lot of Valuable Space.</p>\n", "LastActivityDate": "2016-09-12T12:23:08.293", "CommentCount": "0", "CreationDate": "2016-09-12T12:23:08.293", "ParentId": "740577", "Score": "0", "OwnerUserId": "5612562"}, "740647": {"Id": "740647", "PostTypeId": "2", "Body": "<ol>\n<li><p>The size of the largest member.</p></li>\n<li><p>This is why unions usually make sense inside a struct that has a flag that indicates which is the \"active\" member.</p></li>\n</ol>\n<p>Example:</p>\n<pre><code>struct ONE_OF_MANY {\n    enum FLAG { FLAG_SHORT, FLAG_INT, FLAG_LONG_LONG } flag;\n    union { short x; int y; long long z; };\n};\n</code></pre>\n", "LastEditorUserId": "33708", "LastActivityDate": "2009-04-16T00:02:29.967", "Score": "0", "CreationDate": "2009-04-11T19:16:00.377", "ParentId": "740577", "CommentCount": "3", "OwnerUserId": "46571", "LastEditDate": "2009-04-16T00:02:29.967"}, "740686": {"Id": "740686", "PostTypeId": "2", "Body": "<p>The Standard answers all questions in section 9.5 of the C++ standard, or section 6.5.2.3 paragraph 5 of the C99 standard (or paragraph 6 of the C11 standard):</p>\n<blockquote>\n<p id=\"so_740577_740686_0\">In a union, at most one of the data members can be active at any time, that is, the value of at most one of the data members can be stored in a union at any time. [Note: one special guarantee is made in order to simplify the use of unions: If a POD-union contains several POD-structs that share a common initial sequence (9.2), and if an object of this POD-union type contains one of the POD-structs, it is permitted to inspect the common initial sequence of any of POD-struct members; see 9.2. ] The size of a union is sufficient to contain the largest of its data members. Each data member is allocated as if it were the sole member of a struct. </p>\n</blockquote>\n<p>That means each member share the same memory region. There <em>is</em> at most one member active, but you can't find out which one. You will have to store that information about the currently active member yourself somewhere else. Storing such a flag in addition to the union (for example having a struct with an integer as the type-flag and an union as the data-store) will give you a so called \"discriminated union\": An union which knows what type in it is currently the \"active one\".</p>\n<p>One common use is in lexers, where you can have different tokens, but depending on the token, you have different informations to store (putting <code>line</code> into each struct to show what a common initial sequence is):</p>\n<pre><code>struct tokeni {\n    int token; /* type tag */\n    union {\n        struct { int line; } noVal;\n        struct { int line; int val; } intVal;\n        struct { int line; struct string val; } stringVal;\n    } data;\n};\n</code></pre>\n<p>The Standard allows you to access <code>line</code> of each member, because that's the common initial sequence of each one. </p>\n<p>There exist compiler extensions that allow accessing all members disregarding which one currently has its value stored. That allows efficient reinterpretation of stored bits with different types among each of the members. For example, the following may be used to dissect a float variable into 2 unsigned shorts:</p>\n<pre><code>union float_cast { unsigned short s[2]; float f; };\n</code></pre>\n<p>That can come quite handy when writing low-level code. If the compiler does not support that extension, but you do it anyway, you write code whose results are not defined. So be certain your compiler has support for it if you use that trick.</p>\n", "LastEditorUserId": "1235165", "LastActivityDate": "2016-08-20T13:55:47.963", "Score": "24", "CreationDate": "2009-04-11T19:44:12.663", "ParentId": "740577", "CommentCount": "5", "OwnerUserId": "34509", "LastEditDate": "2016-08-20T13:55:47.963"}});