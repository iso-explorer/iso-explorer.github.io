post_cb({"bq_ids": {"n4140": {"so_32866810_32867482_0": {"length": 34, "quality": 1.0, "section_id": 3333}, "so_32866810_32867695_0": {"length": 4, "quality": 1.0, "section_id": 3262}}, "n3337": {"so_32866810_32867482_0": {"length": 34, "quality": 1.0, "section_id": 3203}, "so_32866810_32867695_0": {"length": 4, "quality": 1.0, "section_id": 3134}}, "n4659": {"so_32866810_32867482_0": {"length": 34, "quality": 1.0, "section_id": 4099}, "so_32866810_32867695_0": {"length": 4, "quality": 1.0, "section_id": 4020}}}, "32867695": {"Id": "32867695", "PostTypeId": "2", "Body": "<p>Your construction is a <em>function-try-block</em> and is defined in drafs n4296 for C++ 11 specification at 8.4 Function definitions [dcl.fct.def.general] with:</p>\n<blockquote>\n<p id=\"so_32866810_32867695_0\">Function definitions have the form</p>\n<ul>\n<li>function-definition:\n  \n  <ul>\n<li>attribute-specifier-seq<sub>opt</sub> decl-specifier-seq<sub>opt</sub> declarator virt-specifier-seq<sub>opt</sub> function-body</li>\n</ul></li>\n<li>function-body:\n  \n  <ul>\n<li>ctor-initializer<sub>opt</sub> compound-statement</li>\n<li>function-try-block</li>\n<li>= default ;</li>\n<li>= delete ;</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>and later in 15 Exception handling [except] with:</p>\n<blockquote>\n<p id=\"so_32866810_32867695_1\">function-try-block:</p>\n<ul>\n<li>try ctor-initializer<sub>opt</sub> compound-statement handler-seq</li>\n</ul>\n</blockquote>\n<p>Examples suggest that the normal usage for a function-try-block should be a ctor, but it is valid for a normal function (and main is syntactically a mere function)</p>\n<p>It is valid and works normally, meaning that catch block is only evaluated if an exception occurs in the ctor-initializer<sub>opt</sub> on in the compound-statement. You can confirm it in your code by adding prints in your blocks or by testing return value.</p>\n<p>In a Unix like system</p>\n<pre><code>foo\necho $?\n</code></pre>\n<p>should echo <code>0</code></p>\n<p>In a Windows system under a CMD.exe windows</p>\n<pre><code>foo.exe\nif errorlevel 1 echo \"Catch block\"\n</code></pre>\n<p>should not output <code>Catch block</code></p>\n<p>If your debugger lets you <strong>execute</strong> instructions in the catch block... it is not C++ 11 conformant!</p>\n<p>But it is known that when exiting a block, MSVC debugger puts cursor on last line of block, I assume that is is what is happening here because the last line of the function-try-block <strong>is</strong> last line of catch.</p>\n", "LastEditorUserId": "3545273", "LastActivityDate": "2015-09-30T14:46:17.073", "Score": "9", "CreationDate": "2015-09-30T13:42:49.860", "ParentId": "32866810", "CommentCount": "5", "OwnerUserId": "3545273", "LastEditDate": "2015-09-30T14:46:17.073"}, "32866810": {"ViewCount": "628", "Body": "<p>Visual Studio 2015; C++ language.</p>\n<p>I remember that I read somewhere about the entry point (i.e. <code>main</code> method) what it is possible to write this:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\ntry{\n  return 0; // I am here...\n}\ncatch (...){\n  cout &lt;&lt; \"I am 'catch'...\" &lt;&lt; endl; // This row wasn't called!\n  return 1; // Oops... But the next `F10` key pressing jumps from the \"try\" \n  // block into this row!\n}\n</code></pre>\n<p>I.e. at this case the <code>try\\catch</code> block is located not in the brackets:</p>\n<pre><code>int main() { // start bracket\n  try{\n    return 0;\n  }\n  catch (...){\n    return 1;\n  }\n} // end bracket\n</code></pre>\n<p>Both cases are compiled successfully and work too, but... In the first variant, when I am step by step pressing the <code>F10</code> key after the <code>try</code> block I get into the <code>catch</code> block also. For the second variant of code I haven't such behaviour.</p>\n<p>Why does it happen?</p>\n", "AcceptedAnswerId": "32867695", "Title": "try\\catch block in the main() function without brackets", "CreationDate": "2015-09-30T13:01:27.677", "Id": "32866810", "CommentCount": "11", "LastEditDate": "2015-09-30T13:52:45.657", "PostTypeId": "1", "LastEditorUserId": "1306132", "LastActivityDate": "2015-09-30T14:46:17.073", "Score": "11", "OwnerUserId": "1306132", "Tags": "<c++><try-catch>", "AnswerCount": "2"}, "32867482": {"Id": "32867482", "PostTypeId": "2", "Body": "<p>The C++ Spec states this:</p>\n<blockquote>\n<p id=\"so_32866810_32867482_0\">A function-try-block associates a handler-seq with the\n  ctor-initializer, if present, and the compound-statement.\n  An exception thrown during the execution of the compound-statement or, for\n  constructors and destructors, during the initialization or\n  destruction, respectively, of the class\u2019s subobjects, transfers\n  control to a handler in a function-try-block in the same way as an\n  exception thrown during the execution of a try-block transfers control\n  to other handlers. </p>\n</blockquote>\n<p>There is no special use case for the usage/behaviour of a function try block in constructor or any other function.</p>\n", "LastEditorUserId": "1163462", "LastActivityDate": "2015-09-30T13:58:01.967", "Score": "-2", "CreationDate": "2015-09-30T13:32:13.533", "ParentId": "32866810", "CommentCount": "3", "OwnerUserId": "1163462", "LastEditDate": "2015-09-30T13:58:01.967"}});