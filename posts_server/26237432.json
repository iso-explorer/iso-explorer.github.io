post_cb({"bq_ids": {"n4140": {"so_26237432_26237876_0": {"length": 12, "quality": 1.0, "section_id": 3913}, "so_26237432_26237876_1": {"length": 20, "quality": 0.8695652173913043, "section_id": 5769}}, "n3337": {"so_26237432_26237876_0": {"length": 12, "quality": 1.0, "section_id": 3773}, "so_26237432_26237876_1": {"length": 20, "quality": 0.8695652173913043, "section_id": 5542}}, "n4659": {"so_26237432_26237876_0": {"length": 9, "quality": 0.75, "section_id": 4799}, "so_26237432_26237876_1": {"length": 20, "quality": 0.8695652173913043, "section_id": 7226}}}, "26237743": {"Id": "26237743", "PostTypeId": "2", "Body": "<p>You may want to check out this answer <a href=\"https://stackoverflow.com/questions/1610030/why-can-you-return-from-a-non-void-function-without-returning-a-value-without-pr\">here</a></p>\n<p>The just of it is that the compiler allows you to not have a return statement since there are potentially many different execution paths, ensuring each will exit with a return can be tricky at compile time, so the compiler will take care of it for you.</p>\n<p>Things to remember:</p>\n<p>if main ends without a return it will always return 0.</p>\n<p>if another function ends without a return it will always return the last value in the eax register, usually the last statement</p>\n<p>optimization changes the code on the assembly level. This is why you are getting the weird behavior, the compiler is \"fixing\" your code for you changing when things are executed giving a different last value, and thus return value.</p>\n<p>Hope this helped!</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-07T13:55:38.917", "Score": "-1", "CreationDate": "2014-10-07T13:55:38.917", "ParentId": "26237432", "CommentCount": "3", "OwnerUserId": "4059250", "LastEditDate": "2017-05-23T12:30:59.127"}, "26237432": {"ViewCount": "153", "Body": "<p>Suppose you wrote a function in c++, but absentmindedly forgot to type the word <code>return</code>. What would happen in that case? I was hoping that the compiler would complain, or at least a segmentation fault would be raised once the program got to that point. However, what actually happens is far worse: the program spews out rubbish. Not only that, but the actual output depends on the level of optimization! Here's some code that demonstrate this problem:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ndouble max_1(double n1,\n         double n2)\n{\n  if(n1&gt;n2)\n    n1;\n  else\n    n2;\n}\n\nint max_2(const int n1,\n      const int n2)\n{\n  if(n1&gt;n2)\n    n1;\n  else\n    n2;\n}\n\nsize_t max_length(const vector&lt;int&gt;&amp; v1,\n          const vector&lt;int&gt;&amp; v2)\n{\n  if(v1.size()&gt;v2.size())\n    v1.size();\n  else\n    v2.size();\n}\n\nint main(void)\n{\n  cout &lt;&lt; max_1(3,4) &lt;&lt; endl;\n  cout &lt;&lt; max_1(4,3) &lt;&lt; endl;\n\n  cout &lt;&lt; max_2(3,4) &lt;&lt; endl;\n  cout &lt;&lt; max_2(4,3) &lt;&lt; endl;\n\n  cout &lt;&lt; max_length(vector&lt;int&gt;(3,1),vector&lt;int&gt;(4,1)) &lt;&lt; endl;\n  cout &lt;&lt; max_length(vector&lt;int&gt;(4,1),vector&lt;int&gt;(3,1)) &lt;&lt; endl;\n\n  return 0;\n}\n</code></pre>\n<p>And here's what I get when I compile it at different optimization levels:</p>\n<pre><code>$ rm ./a.out; g++ -O0 ./test.cpp &amp;&amp; ./a.out\nnan\nnan\n134525024\n134525024\n4\n4\n$ rm ./a.out; g++ -O1 ./test.cpp &amp;&amp; ./a.out\n0\n0\n0\n0\n0\n0\n$ rm ./a.out; g++ -O2 ./test.cpp &amp;&amp; ./a.out\n0\n0\n0\n0\n0\n0\n$ rm ./a.out; g++ -O3 ./test.cpp &amp;&amp; ./a.out\n0\n0\n0\n0\n0\n0\n</code></pre>\n<p>Now imagine that you're trying to debug the function max_length. In production mode you get the wrong answer, so you recompile in debug mode, and now when you run it everything works fine.</p>\n<p>I know there are ways to avoid such cases altogether by adding the appropriate warning flags (<code>-Wreturn-type</code>), but I'm still have two questions</p>\n<ol>\n<li><p>Why does the compiler even agree to compile a function without a return statement? Is this feature required for legacy code?</p></li>\n<li><p>Why does the output depend on the optimization level?</p></li>\n</ol>\n", "AcceptedAnswerId": "26237743", "Title": "Erratic behaviour with missing return in c++ and optimizations", "CreationDate": "2014-10-07T13:41:07.177", "Id": "26237432", "CommentCount": "9", "LastEditDate": "2014-10-07T15:25:56.450", "PostTypeId": "1", "LastEditorUserId": "1708801", "LastActivityDate": "2014-10-09T17:21:56.840", "Score": "2", "OwnerUserId": "2535797", "Tags": "<c++><vector><return><undefined-behavior>", "AnswerCount": "2"}, "26237876": {"Id": "26237876", "PostTypeId": "2", "Body": "<p>This is <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow noreferrer\">undefined behavior</a> to drop off the end of the value returning function, this is covered in the <a href=\"https://github.com/cplusplus/draft/blob/b7b8ed08ba4c111ad03e13e8524a1b746cb74ec6/papers/N3936.pdf\" rel=\"nofollow noreferrer\">draft C++ standard</a> section `6.6.31 <em>The return statement</em> which says:</p>\n<blockquote>\n<p id=\"so_26237432_26237876_0\">Flowing off the end of a function is equivalent to a return with no\n  value; this results in undefined behavior in a value-returning\n  function.</p>\n</blockquote>\n<p>The compiler is not required to issue a diagnostic, we can see this from section <code>1.4</code> <em>Implementation compliance</em> which says:</p>\n<blockquote>\n<p id=\"so_26237432_26237876_1\">The set of diagnosable rules consists of all syntactic and semantic\n  rules in this International Standard except for those rules containing\n  an explicit notation that \u201cno diagnostic is required\u201d or which are\n  described as resulting in \u201cundefined behavior.\u201d</p>\n</blockquote>\n<p>although compiler in general do try and catch a wide range of undefined behaviors and produce warnings, although usually you need to use the right set of flags. For <code>gcc</code> and <code>clang</code> I find the following set of flags to be useful:</p>\n<blockquote>\n<p id=\"so_26237432_26237876_2\">-Wall -Wextra -Wconversion -pedantic </p>\n</blockquote>\n<p>and in general I would encourage you to turn warnings into errors using <code>-Werror</code>.</p>\n<p>Compiler are notorious for taking advantage of undefined behavior during the optimization stages, see <a href=\"http://blog.regehr.org/archives/970\" rel=\"nofollow noreferrer\">Finding Undefined Behavior Bugs by Finding Dead Code</a> for some good examples including the infamous Linux kernel null pointer check removal where in processing this code:</p>\n<pre><code>struct foo *s = ...;\nint x = s-&gt;f;\nif (!s) return ERROR;\n</code></pre>\n<p><code>gcc</code> inferred that since <code>s</code> was deferenced in  <code>s-&gt;f;</code> and since dereferencing a null pointer is undefined behavior then <code>s</code> must not be null and therefore optimizes away the <code>if (!s)</code> check on the next line (<em>copied from my <a href=\"https://stackoverflow.com/a/24297811/1708801\">answer here</a></em>).</p>\n<p>Since undefined behavior is unpredictable, then at more aggressive settings the compiler in many cases will do more aggressive optimizations many of them may not make much intuitive sense but, hey it is undefined behavior so you should have no expectations anyway.</p>\n<p>Note, that although there are many cases the compiler can determine a function is not properly returning in the general case this is the <a href=\"http://en.wikipedia.org/wiki/Halting_problem\" rel=\"nofollow noreferrer\">halting problem</a>. Doing this at run-time automatically would carry a cost which violates the don't pay for what you don't use philosophy. Although both <code>gcc</code> and <code>clang</code> implement <a href=\"http://clang.llvm.org/docs/UsersManual.html#controlling-code-generation\" rel=\"nofollow noreferrer\">sanitizers</a> to check for things like undefined behavior, for example using the <code>-fsanitize=undefined</code> flag would check for undefined behavior at run-time. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-09T17:21:56.840", "Score": "9", "CreationDate": "2014-10-07T14:02:26.333", "ParentId": "26237432", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T12:23:33.027"}});