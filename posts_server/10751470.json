post_cb({"10751564": {"ParentId": "10751470", "CommentCount": "1", "Body": "<p>The expression <code>y * x * 0.25</code> associates as <code>(y * x) * 0.25</code> in both C and C++.</p>\n<p>When multiplying an <code>unsigned int</code> and a <code>signed int</code>, both operands are converted to <code>unsigned int</code> and the results is also an <code>unsigned int</code> due to the integer conversion rules for arithmetic expressions in both C and C++ so the result of <code>y * x</code> will be <code>UINT_MAX - 1</code> in both C and C++.</p>\n<p>Your example doesn't exhibit a compiler bug whether you are compiling your example as C or C++.</p>\n", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "10751564", "Score": "7", "CreationDate": "2012-05-25T09:09:12.233", "LastActivityDate": "2012-05-25T09:09:12.233"}, "10751470": {"CommentCount": "6", "CreationDate": "2012-05-25T09:01:04.453", "PostTypeId": "1", "AcceptedAnswerId": "10751564", "LastEditorUserId": "505088", "LastActivityDate": "2012-05-25T09:20:00.030", "LastEditDate": "2012-05-25T09:20:00.030", "ViewCount": "387", "FavoriteCount": "0", "Title": "Microsoft C++ compiler have a bug?", "Id": "10751470", "Score": "1", "Body": "<pre><code>usigned int x=1;\nsigned int y = -1;\ndouble z = y * x * 0.25;\n</code></pre>\n<p>I'm using Microsoft Visual Studio 10 C++ compiler.\nWhy z don't have -0.25 value?\nAs I saw from disassembly, it makes an signed int multiply (imul), places the result from edx on the stack, and extends it with 0!, as it would be an unsigned int. After that it multiplies it using FP instructions.</p>\n<pre><code>.............\nimul        edx,dword ptr [ecx]  \nmov         dword ptr [ebp-98h],edx  \nmov         dword ptr [ebp-94h],0\nfild        dword ptr [ebp-98h]  \nfmul        qword ptr [__real@3fd0000000000000 (1402FB8h)]  \nfstp        qword ptr [z]\n</code></pre>\n<p>Why the result of multiply of signed * unsigned is interpreted as unsigned?</p>\n", "Tags": "<c++><visual-studio-2010><visual-c++>", "OwnerUserId": "691343", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_10751470_10751574_3": {"section_id": 5943, "quality": 1.0, "length": 23}, "so_10751470_10751574_2": {"section_id": 5943, "quality": 1.0, "length": 8}, "so_10751470_10751574_1": {"section_id": 5943, "quality": 1.0, "length": 12}, "so_10751470_10751539_2": {"section_id": 5943, "quality": 1.0, "length": 12}, "so_10751470_10751539_0": {"section_id": 5943, "quality": 0.9032258064516129, "length": 28}, "so_10751470_10751574_4": {"section_id": 5943, "quality": 1.0, "length": 23}}, "n3337": {"so_10751470_10751574_3": {"section_id": 5714, "quality": 1.0, "length": 23}, "so_10751470_10751574_2": {"section_id": 5714, "quality": 1.0, "length": 8}, "so_10751470_10751574_1": {"section_id": 5714, "quality": 1.0, "length": 12}, "so_10751470_10751539_2": {"section_id": 5714, "quality": 1.0, "length": 12}, "so_10751470_10751539_0": {"section_id": 5714, "quality": 0.9032258064516129, "length": 28}, "so_10751470_10751574_4": {"section_id": 5714, "quality": 1.0, "length": 23}}, "n4659": {"so_10751470_10751574_3": {"section_id": 7428, "quality": 1.0, "length": 23}, "so_10751470_10751574_2": {"section_id": 7428, "quality": 1.0, "length": 8}, "so_10751470_10751574_1": {"section_id": 7428, "quality": 1.0, "length": 12}, "so_10751470_10751539_2": {"section_id": 7428, "quality": 1.0, "length": 12}, "so_10751470_10751539_0": {"section_id": 7428, "quality": 0.9032258064516129, "length": 28}, "so_10751470_10751574_4": {"section_id": 7428, "quality": 1.0, "length": 23}}}, "10751574": {"ParentId": "10751470", "CommentCount": "0", "Body": "<p>This is described in the [expr] section of the standard:</p>\n<blockquote>\n<p id=\"so_10751470_10751574_0\">....</p>\n<p id=\"so_10751470_10751574_1\">Otherwise, the integral promotions (4.5) shall be performed on both\n  operands. Then the following rules shall be applied to the promoted\n  operands: </p>\n<p id=\"so_10751470_10751574_2\">\u2014 If both operands have the same type, no further conversion\n  is needed. </p>\n<p id=\"so_10751470_10751574_3\">\u2014 Otherwise, if both operands have signed integer types or\n  both have unsigned integer types, the operand with the type of lesser\n  integer conversion rank shall be converted to the type of the operand\n  with greater rank. </p>\n<p id=\"so_10751470_10751574_4\">\u2014 Otherwise, if the operand that has unsigned\n  integer type has rank greater than or equal to the rank of the type of\n  the other operand, the operand with signed integer type shall be\n  converted to the type of the operand with unsigned integer type.</p>\n</blockquote>\n<p>The expression is evaluated left to right and so <code>y * x</code> is calculated first. This has two integral types of the same rank, one operand signed and the other unsigned. Hence the signed value is converted to an unsigned value, as described in the final paragraph of the standards extract.</p>\n", "OwnerUserId": "505088", "PostTypeId": "2", "Id": "10751574", "Score": "3", "CreationDate": "2012-05-25T09:09:39.293", "LastActivityDate": "2012-05-25T09:09:39.293"}, "10751539": {"ParentId": "10751470", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>This is actually according to the spec. C++11, 5.9:</p>\n<blockquote>\n<p id=\"so_10751470_10751539_0\">Many binary operators that expect operands of arithmetic or\n  enumeration type cause conversions and yield result types in a similar\n  way. The purpose is to yield a common type, which is also the type of\n  the result. This pattern is called the usual arithmetic conversions,\n  which are defined as follows:</p>\n<p id=\"so_10751470_10751539_1\">[...]</p>\n<p id=\"so_10751470_10751539_2\">Otherwise, the integral promotions (4.5) shall be performed on both\n  operands. Then the following rules shall be applied to the promoted\n  operands:</p>\n<p id=\"so_10751470_10751539_3\">[...]</p>\n<ul>\n<li>Otherwise, if the operand that has unsigned integer type has rank\n  greater than or equal to the rank of the type of the other operand,\n  the operand with signed integer type shall be converted to the type of\n  the operand with unsigned integer type.</li>\n</ul>\n</blockquote>\n<p>Here the two operands in <code>y * x</code> are signed and unsigned int, which have an equal <a href=\"https://www.securecoding.cert.org/confluence/display/seccode/INT02-C.+Understand+integer+conversion+rules\" rel=\"nofollow\">integer conversion rank</a>; so <code>y</code> ends up being converted to unsigned.</p>\n", "OwnerUserId": "50079", "LastEditorUserId": "50079", "LastEditDate": "2012-05-25T09:13:16.397", "Id": "10751539", "Score": "5", "CreationDate": "2012-05-25T09:07:37.007", "LastActivityDate": "2012-05-25T09:13:16.397"}});