post_cb({"bq_ids": {"n4140": {"so_45610376_45610924_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 3326}}, "n3337": {"so_45610376_45610924_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 3196}}, "n4659": {"so_45610376_45610924_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 4092}}}, "45610376": {"ViewCount": "97", "Body": "<p>Given a macro <code>FOO</code> used like this:</p>\n<pre><code>std::string f1();\nstd::string f2();\nFOO(f1().c_str(), f2().c_str());\n</code></pre>\n<p>Note: The type, <code>std::string</code> is only an example. <code>FOO</code> is generic and may not assume anything about types.</p>\n<p>that is supposed to guarantee the order of evaluation of <code>f1()</code> and <code>f2()</code> by doing something like:</p>\n<pre><code>#define FOO(e1, e2) \\\ndo {                \\\n    auto v1 = e1;   \\\n    auto v2 = e2;   \\\n    foo(e1, e2);    \\\n} while(0)\n</code></pre>\n<p>Edit: unfortunately <code>foo</code> can also be a template.</p>\n<p>Unfortunately, that way the temporary returned by <code>f1</code> is deleted and the <code>c_str</code> becomes invalid for the call to <code>foo</code>.</p>\n<p>Is there a way to guarantee the order of expression evaluation for macro parameters while retaining all temporary lifetimes?</p>\n<p>Surely there are overall better ways to approach that, but I'm specifically curious if there is a way to do this without reasoning about each of the usages of that macro in a large code base. Further I want to avoid handling specific types (i.e. not preserving <code>const char*</code> with <code>strdup</code>).</p>\n", "AcceptedAnswerId": "45611196", "Title": "Enforce parameter evaluation order while retaining lifetime of of expressions", "CreationDate": "2017-08-10T09:54:41.770", "Id": "45610376", "CommentCount": "2", "LastEditDate": "2017-08-10T12:36:01.267", "PostTypeId": "1", "LastEditorUserId": "620382", "LastActivityDate": "2017-08-16T09:14:57.257", "Score": "3", "OwnerUserId": "620382", "Tags": "<c++><c++14><lifetime><temporary-objects>", "AnswerCount": "2"}, "45611196": {"Id": "45611196", "PostTypeId": "2", "Body": "<p>This is trivial in C++17, using <a href=\"http://en.cppreference.com/w/cpp/utility/apply\" rel=\"nofollow noreferrer\"><code>std::apply</code></a>:</p>\n<pre><code>#define FOO(...) std::apply(foo, decltype(std::forward_as_tuple(__VA_ARGS__)){__VA_ARGS__})\n</code></pre>\n<p><a href=\"https://godbolt.org/g/n3sCJz\" rel=\"nofollow noreferrer\">Example</a>.</p>\n<p>If you're using a pre-C++17 standard library, you can use the recipe for implementing <code>std::apply</code> at the above link.</p>\n<p>If <code>foo</code> is a function template or an overload set, it can't be passed directly to <code>std::apply</code> so it has to be <a href=\"https://stackoverflow.com/questions/45187335/convert-template-function-to-generic-lambda\">wrapped in a polymorphic lambda</a>:</p>\n<pre><code>#define FOO(...) std::apply( \\\n    [](auto&amp;&amp;... args) -&gt; decltype(auto) { return foo(std::forward&lt;decltype(args)&gt;(args)...); }, \\\n    decltype(std::forward_as_tuple(__VA_ARGS__)){__VA_ARGS__})\n</code></pre>\n<p>This works because the order of evaluation within <code>{}</code> braces is strict left-to-right. We use <code>std::forward_as_tuple</code> to determine the <em>type</em> of the tuple we want to pass to <code>apply</code>, but we construct it using list-initialization syntax.</p>\n<p>If you're using a C++17 compiler with class template argument deduction, and don't need to worry about lvalue references, you could simplify this even further:</p>\n<pre><code>#define FOO(...) std::apply(foo, std::tuple{__VA_ARGS__})\n</code></pre>\n<p>Unfortunately, because the solution (without class template argument deduction) uses <code>decltype</code>, it won't work if the arguments involve lambda expressions. The only way I can see to make it work in this case is to use the sequencing between function arguments and function body, expanding <code>FOO(e1, e2)</code> to:</p>\n<pre><code>[&amp;](auto&amp;&amp; p1) {\n    return [&amp;](auto&amp;&amp; p2) {\n        return foo(std::forward&lt;decltype(p1)&gt;(p1), std::forward&lt;decltype(p2)&gt;(p2));\n    }(e2);\n}(e1)\n</code></pre>\n<p>This is actually possible using the incredible <a href=\"http://www.boost.org/doc/libs/1_64_0/libs/preprocessor/doc/index.html\" rel=\"nofollow noreferrer\">Boost.Preprocessor</a> library:</p>\n<pre><code>#define FOO_IMPL_START(z,n,_) [&amp;](auto&amp;&amp; p ## n) { return\n#define FOO_IMPL_PARAM(z,n,_) std::forward&lt;decltype(p ## n)&gt;(p ## n)\n#define FOO_IMPL_END(z,n,t) ; }(BOOST_PP_TUPLE_ELEM(n,t))\n#define FOO_IMPL(n,t) \\\n    BOOST_PP_REPEAT(n, FOO_IMPL_START, _) \\\n    foo(BOOST_PP_ENUM(n, FOO_IMPL_PARAM, _)) \\\n    BOOST_PP_REPEAT(n, FOO_IMPL_END, BOOST_PP_TUPLE_REVERSE(t))\n#define FOO(...) (FOO_IMPL(BOOST_PP_VARIADIC_SIZE(__VA_ARGS__), BOOST_PP_VARIADIC_TO_TUPLE(__VA_ARGS__)))\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/319d25ca87a459ed\" rel=\"nofollow noreferrer\">Example</a>.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2017-08-10T21:42:16.080", "Score": "4", "CreationDate": "2017-08-10T10:29:07.367", "ParentId": "45610376", "CommentCount": "10", "OwnerUserId": "567292", "LastEditDate": "2017-08-10T21:42:16.080"}, "45610924": {"Id": "45610924", "PostTypeId": "2", "Body": "<p>Generalized solution:</p>\n<pre><code>struct Execute\n{\n    template &lt;typename Func, typename ... Args&gt;\n    Execute(Func&amp;&amp; function, Args&amp;&amp; ... args)\n    {\n        std::forward&lt;Func&gt;(function)(std::forward&lt;Args&gt;(args) ...);\n    }\n};\n\n#define FOO(...)                            \\\n    do {                                    \\\n            Execute{foo, __VA_ARGS__};      \\\n    } while(0)\n\n FOO(f1().c_str(), f2().c_str()); // this will be evaluated in order from left to right\n</code></pre>\n<p>The reason why it has to work: evaluation order of braced-init-list is guaranteed.</p>\n<p>C++11 Standard, 8.5.4/4:</p>\n<blockquote>\n<p id=\"so_45610376_45610924_0\">Within the initializer-list of a braced-init-list, the\n  initializer-clauses, including any that result from pack expansions\n  (14.5.3), are evaluated in the order in which they appear...</p>\n</blockquote>\n<p>Unlike the accepted solution it works with <strong>C++11</strong> without any shenanigans and do not need Boost.</p>\n", "LastEditorUserId": "6639082", "LastActivityDate": "2017-08-16T09:14:57.257", "Score": "0", "CreationDate": "2017-08-10T10:17:19.523", "ParentId": "45610376", "CommentCount": "8", "OwnerUserId": "6639082", "LastEditDate": "2017-08-16T09:14:57.257"}});