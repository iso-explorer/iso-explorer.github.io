post_cb({"7973776": {"ParentId": "7973737", "Score": "14", "CreationDate": "2011-11-01T22:33:33.723", "Id": "7973776", "OwnerUserId": "902497", "LastActivityDate": "2011-11-01T22:33:33.723", "Body": "<p><code>FLT_MAX</code> is defined in section 5.2.4.2.2(9) as</p>\n<blockquote>\n<p id=\"so_7973737_7973776_0\">maximum representable finite floating-point number</p>\n</blockquote>\n<p>Positive infinity is not finite.</p>\n<p><code>FLT_MIN</code> is defined in section 5.2.4.2.2(10) as</p>\n<blockquote>\n<p id=\"so_7973737_7973776_1\">minimum normalized positive floating-point number</p>\n</blockquote>\n<p>Negative infinity is neither normalized nor positive.</p>\n", "PostTypeId": "2", "CommentCount": "8"}, "7973737": {"Tags": "<c++><c>", "ViewCount": "23178", "LastEditDate": "2011-11-01T22:46:33.453", "CreationDate": "2011-11-01T22:29:11.443", "LastEditorUserId": "768469", "Title": "Why are FLT_MAX and FLT_MIN not positive and negative infinity, and what is their use?", "CommentCount": "13", "AcceptedAnswerId": "7973772", "Score": "12", "OwnerUserId": "402169", "Id": "7973737", "LastActivityDate": "2011-11-07T00:13:35.220", "Body": "<p>Logically speaking, given the nature of floating point values, the maximum and minimum representable values of a <code>float</code> are positive and negative infinity, respectively.</p>\n<p>Why, then, are <code>FLT_MAX</code> and <code>FLT_MIN</code> not set to them? I understand that this is \"just how the standard called for\". But then, <strong>what <em>use</em> could <code>FLT_MAX</code> or <code>FLT_MIN</code> have as they currently lie in the middle of the representable numeric range of <code>float</code></strong>? Other numeric limits have some utility because they make guarantees about comparisons (e.g. \"No INT can test greater than INT_MAX\"). Without that kind of guarantee, what use are these float limits at all?</p>\n<p>A motivating example for C++:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;limits&gt;\n\ntemplate&lt;typename T&gt;\nT find_min(const std::vector&lt;T&gt; &amp;vec)\n{\n    T result = std::numeric_limits&lt;T&gt;::max();\n    for (std::vector&lt;T&gt;::const_iterator p = vec.start() ; p != vec.end() ; ++p)\n        if (*p &lt; result) result = *p;\n    return result;\n}\n</code></pre>\n<p>This code works fine if T is an integral type, but not if it is a floating point type.  This is annoying.  (Yes yes, the standard library provides <code>min_element</code>, but that is not the point.  The point is the <em>pattern</em>.)</p>\n", "PostTypeId": "1", "FavoriteCount": "4", "AnswerCount": "4"}, "7973772": {"ParentId": "7973737", "Score": "15", "CreationDate": "2011-11-01T22:33:21.087", "LastActivityDate": "2011-11-07T00:13:35.220", "LastEditDate": "2011-11-07T00:13:35.220", "OwnerUserId": "734069", "LastEditorUserId": "734069", "Body": "<p>The purpose of <code>FLT_MIN</code>/<code>MAX</code> is to tell you what the smallest and largest representable floating-point <strong>numbers</strong> are. Infinity isn't a number; it's a limit.</p>\n<blockquote>\n<p id=\"so_7973737_7973772_0\">what use could FLT_MAX or FLT_MIN have as they currently lie in the middle of the representable numeric range of float? </p>\n</blockquote>\n<p>They do not lie in the <em>middle</em> or the representable range. There is no positive float value <code>x</code> which you can add to <code>FLT_MAX</code> and get a representable number. You will get +INF.</p>\n<blockquote>\n<p id=\"so_7973737_7973772_1\">This code works fine if T is an integral type, but not if it is a floating point type. This is annoying. (Yes yes, the standard library provides min_element, but that is not the point. The point is the pattern.)</p>\n</blockquote>\n<p>And how doesn't it \"work fine?\" It gives you the smallest value. The only situation where it doesn't \"work fine\" is if the table contains <em>only</em> +INF. And even in that case, it returns an actual <em>number</em>, not an error-code. Which is probably the better option anyway.</p>\n", "Id": "7973772", "PostTypeId": "2", "CommentCount": "3"}, "bq_ids": {"n4659": {"so_7973737_7973776_0": {"length": 4, "section_id": 8243, "quality": 0.8}}}, "7974042": {"ParentId": "7973737", "Score": "6", "CreationDate": "2011-11-01T23:10:30.547", "Id": "7974042", "OwnerUserId": "827263", "LastActivityDate": "2011-11-01T23:10:30.547", "Body": "<p>Unlike integer types, floating-point types are (almost?) universally symmetric about zero, and I think the C floating-point model requires this.</p>\n<p>On two's-complement systems (i.e., almost all modern systems), <code>INT_MIN</code> is <code>-INT_MAX-1</code>; on other systems, it may be <code>-INT_MAX</code>.  (Quibble: a two's-complement system can have <code>INT_MIN</code> equal to <code>-INT_MAX</code> if the lowest representable value is treated as a trap representation.)  So <code>INT_MIN</code> conveys information that <code>INT_MAX</code> by itself doesn't.</p>\n<p>And a macro for the smallest positive value would not be particularly useful; that's just 1.</p>\n<p>In floating-point, on the other hand, the negative value with the greatest magnitude is just <code>-FLT_MAX</code> (or <code>-DBL_MAX</code>, or <code>-LDBL_MAX</code>).</p>\n<p>As for why they're not Infinity, there's already a way to represent infinite values (at least in C99): the macro <code>INFINITY</code>.  That might cause problems for some C++ applications, but these were defined for C, which doesn't have things like <code>std::numeric_limits&lt;T&gt;::max()</code>.</p>\n<p>Furthermore, not all floating-point systems have representations for infinity (or NaN).</p>\n<p>If <code>FLT_MAX</code> were <code>INFINITY</code> (on systems that support it), then there would probably need to be another macro for the largest representable real value.</p>\n", "PostTypeId": "2", "CommentCount": "2"}, "7976840": {"ParentId": "7973737", "Score": "8", "CreationDate": "2011-11-02T07:09:23.243", "Id": "7976840", "OwnerUserId": "379897", "LastActivityDate": "2011-11-02T07:09:23.243", "Body": "<p>I would say the broken pattern you're seeing is only an artifact of <em>poor naming</em> in C, whereas in C++ with <code>numeric_limits</code> and templates, it's an actual semantic flaw that breaks template code that wants to handle both integer and floating point values. Of course you can write a little bit of extra code to test if you have an integer or floating point type (e.g. <code>if ((T)1/2) /* floating point */ else /* integer */</code>) and the problem goes away.</p>\n<p>As for why somebody would care about the values <code>FLT_MIN</code> and <code>FLT_MAX</code> give you, they're useful for avoiding underflow and overflow. For example, suppose I need to compute <code>sqrt(x\u00b2-1)</code>. This is well-defined for any floating point <code>x</code> greater than or equal to 1, but performing the squaring, subtraction, and square root could easily overflow and render the result meaningless when <code>x</code> is large. One might want to test whether <code>x &gt; FLT_MAX/x</code> and handle this case some other way (such as simply returning <code>x</code> :-).</p>\n", "PostTypeId": "2", "CommentCount": "2"}});