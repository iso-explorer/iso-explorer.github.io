post_cb({"18551174": {"ViewCount": "340", "Body": "<p>I created a class but its size is zero. Now, how can I be sure that all objects have different addresses? (As we know, empty classes have a non-zero size.)</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nclass Test\n{\n    int arr[0];//Why is the sizezero?\n};\n\nint main()\n{\n    Test a,b;  \n      cout &lt;&lt;\"size of class\"&lt;&lt;sizeof(a)&lt;&lt;endl;\n       if (&amp;a == &amp;b)// now how we ensure about address of objects ?\n          cout &lt;&lt; \"impossible \" &lt;&lt; endl;\n       else\n          cout &lt;&lt; \"Fine \" &lt;&lt; endl;//Why isn't the address the same? \n\n        return 0;\n}        \n</code></pre>\n", "AcceptedAnswerId": "18551259", "Title": "Why is the size of my class zero? How can I ensure that different objects have different address?", "CreationDate": "2013-08-31T17:56:06.640", "Id": "18551174", "CommentCount": "8", "LastEditDate": "2013-08-31T18:22:55.453", "PostTypeId": "1", "LastEditorUserId": "2522427", "LastActivityDate": "2013-08-31T20:46:25.010", "Score": "3", "OwnerUserId": "2276404", "Tags": "<c++><class>", "AnswerCount": "4"}, "18552104": {"Id": "18552104", "PostTypeId": "2", "Body": "<p>This is largely a repetition of what the other answers have already said, but with a few more references to the ISO C++ standard and some musings about the odd behavior of g++.</p>\n<p>The ISO C++11 standard, in section 8.3.4 [dcl.array], paragraph 1, says:</p>\n<blockquote>\n<p id=\"so_18551174_18552104_0\">If the <em>constant-expression</em> (5.19) is present, it shall be an\n  integral constant expression and its value shall be greater than zero.</p>\n</blockquote>\n<p>Your class definition:</p>\n<pre><code>class Test\n{\n    int arr[0];\n};\n</code></pre>\n<p>violates this rule. Section 1.4 [intro.compliance] applies here:</p>\n<blockquote>\n<p id=\"so_18551174_18552104_1\">If a program contains a violation of any diagnosable rule [...], a\n  conforming implementation shall issue at least one diagnostic message.</p>\n</blockquote>\n<p>As I understand it, if a compiler issues this diagnostic and then accepts the program, the program's behavior is undefined. So that's all the standard has to say about your program.</p>\n<p>Now it becomes a question about your compiler rather than about the language.</p>\n<p>I'm using g++ version 4.7.2, which does permit zero-sized arrays as an extension, but prints the required diagnostic (a warning) if you invoke it with, for example, <code>-std=c++11 -pedantic</code>:</p>\n<pre><code>warning: ISO C++ forbids zero-size array \u2018arr\u2019 [-pedantic]\n</code></pre>\n<p>(Apparently you're also using g++.)</p>\n<p>Experiment shows that g++'s treatment of zero-sized arrays is a bit odd. Here's an example, based on the one in your program:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Empty {\n    /* This is valid C++ */\n};\n\nclass Almost_Empty {\n    int arr[0];\n};\n\nint main() {\n    Almost_Empty arr[2];\n    Almost_Empty x, y;\n\n    std::cout &lt;&lt; \"sizeof (Empty)        = \" &lt;&lt; sizeof (Empty) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"sizeof (Almost_Empty) = \" &lt;&lt; sizeof (Almost_Empty) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"sizeof arr[0]         = \" &lt;&lt; sizeof arr[0] &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"sizeof arr            = \" &lt;&lt; sizeof arr &lt;&lt; '\\n';\n\n    if (&amp;x == &amp;y) {\n        std::cout &lt;&lt; \"&amp;x == &amp;y\\n\";\n    }\n    else {\n        std::cout &lt;&lt; \"&amp;x != &amp;y\\n\";\n    }\n\n    if (&amp;arr[0] == &amp;arr[1]) {\n        std::cout &lt;&lt; \"&amp;arr[0] == &amp;arr[1]\\n\";\n    }\n    else {\n        std::cout &lt;&lt; \"&amp;arr[0] != &amp;arr[1]\\n\";\n    }\n}\n</code></pre>\n<p>I get the required warning on <code>int arr[0];</code>, and then the following run-time output:</p>\n<pre><code>sizeof (Empty)        = 1\nsizeof (Almost_Empty) = 0\nsizeof arr[0]         = 0\nsizeof arr            = 0\n&amp;x != &amp;y\n&amp;arr[0] == &amp;arr[1]\n</code></pre>\n<p>C++ requires a class, even one with no members, to have a size of at least 1 byte. g++ follows this requirement for class <code>Empty</code>, which has no members. But adding a zero-sized array to a class actually causes the class itself to have a size of 0.</p>\n<p>If you declare two objects of type <code>Almost_Empty</code>, they have distinct addresses, which is sensible; the compiler can allocate distinct objects any way it likes.</p>\n<p>But for elements in an array, a compiler has less flexibility: an array of N elements <em>must</em> have a size of N times the number of elements.</p>\n<p>In this case, since class <code>Almost_Empty</code> has a size of 0, it follows that an array of <code>Almost_Empty</code> elements has a size of 0 *and that all elements of such an array have the same address.</p>\n<p>This does not indicate that g++ fails to conform to the C++ standard. It's done its job by printing a diagnostic (even though it's a non-fatal warning); after that, as far as the standard is concerned, it's free to do whatever it likes.</p>\n<p>But I would probably argue that it's a bug in g++. Just in terms of common sense, adding an empty array to a class should not make the class smaller.</p>\n<p>But there is a rationale for it. As DyP points out in a comment, the gcc manual (which covers g++) <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html\" rel=\"nofollow\">mentions this feature</a> as a C extension which is <a href=\"http://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html\" rel=\"nofollow\">also available for C++</a>. They are intended primarily to be used as the last member of a structure that's really a header for a variable-length object. This is known as the <a href=\"http://c-faq.com/struct/structhack.html\" rel=\"nofollow\">struct hack</a>. It's replaced in C99 by flexible array members, and in C++ by container classes.</p>\n<p>My advice: Avoid all this confusion by not defining zero-length arrays. If you really need sequences of elements that can be empty, use one of the C++ standard container classes such as <code>std::vector</code> or <code>std::array</code>.</p>\n", "LastEditorUserId": "827263", "LastActivityDate": "2013-08-31T20:33:26.230", "Score": "3", "CreationDate": "2013-08-31T19:41:59.600", "ParentId": "18551174", "CommentCount": "3", "OwnerUserId": "827263", "LastEditDate": "2013-08-31T20:33:26.230"}, "18552666": {"Id": "18552666", "PostTypeId": "2", "Body": "<ul>\n<li>There is a difference between variable declaration and variable initialization. In your case, you just declare variables; A and B. Once you have declared a variable, you need to initialize it using either NEW or MALLOC.</li>\n<li>The initialization will now allocate memory to the variables that you just declared. You can initialize the variable to an arbitrary size or block of memory. </li>\n<li>A and B are both variables meaning you have created two variables A and B. The compiler will identify this variable as unique variables, it will then allocate A to a memory address say 2000 and then allocate B to another memory address say 150. </li>\n<li>If you want A to point to B or B to point to A, you can make a reference to A or B such as;\nA = &amp;B. Now A as a memory reference or address to B or rather A points to B. This is called passing variables, in C++ you can either pass variables by reference or pass variables by value. </li>\n</ul>\n", "LastActivityDate": "2013-08-31T20:46:25.010", "CommentCount": "2", "CreationDate": "2013-08-31T20:46:25.010", "ParentId": "18551174", "Score": "1", "OwnerUserId": "2585483"}, "18551271": {"Id": "18551271", "PostTypeId": "2", "Body": "<p>The standard says that having an array of zero size causes undefined behavior. When you trigger undefined behavior, other guarantees that the standard provides, such as requiring that objects be located at a different address, may not hold.</p>\n<p>Don't create arrays of zero size, and you shouldn't have this problem.</p>\n", "LastActivityDate": "2013-08-31T18:06:10.527", "CommentCount": "1", "CreationDate": "2013-08-31T18:06:10.527", "ParentId": "18551174", "Score": "6", "OwnerUserId": "82320"}, "bq_ids": {"n4140": {"so_18551174_18551259_0": {"length": 9, "quality": 1.0, "section_id": 5848}, "so_18551174_18552104_1": {"length": 11, "quality": 1.0, "section_id": 5770}, "so_18551174_18552104_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 3228}}, "n3337": {"so_18551174_18551259_0": {"length": 9, "quality": 1.0, "section_id": 5618}, "so_18551174_18552104_1": {"length": 11, "quality": 1.0, "section_id": 5543}, "so_18551174_18552104_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 3101}}, "n4659": {"so_18551174_18551259_0": {"length": 9, "quality": 1.0, "section_id": 7327}, "so_18551174_18552104_1": {"length": 11, "quality": 1.0, "section_id": 7227}, "so_18551174_18552104_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 3985}}}, "18551259": {"Id": "18551259", "PostTypeId": "2", "Body": "<p>Your class definition is illegal. C++ does not allow array declarations with size <code>0</code> in any context. But even if you make your class definition completely empty, the <code>sizeof</code> is still required to evaluate to a non-zero value.</p>\n<blockquote>\n<p id=\"so_18551174_18551259_0\">9/4 Complete objects and member subobjects of class type shall have\n  nonzero size.</p>\n</blockquote>\n<p>In other words, if your compiler accepts the class definition and evaluates the above <code>sizeof</code> to zero, that compiler is going outside of scope of standard C++ language. It must be a compiler extension that has no relation to standard C++.</p>\n<p>So, the only answer to the \"why\" question in this case is: because that's the way it is implemented in your compiler. </p>\n<p>I don't see what it all has to do with ensuring that different objects have different addresses. The compiler can easily enforce this regardless of whether object size is zero or not.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2013-08-31T18:20:01.573", "Score": "7", "CreationDate": "2013-08-31T18:05:07.867", "ParentId": "18551174", "CommentCount": "8", "OwnerUserId": "187690", "LastEditDate": "2013-08-31T18:20:01.573"}});