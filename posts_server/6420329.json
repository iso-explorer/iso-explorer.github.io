post_cb({"6420338": {"ParentId": "6420329", "CommentCount": "0", "Body": "<p>No, not legal. You can only <code>delete</code> what you got back from <code>new</code>, and the exact same applies to <code>new[]</code> and <code>delete[]</code></p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "6420338", "Score": "20", "CreationDate": "2011-06-21T04:26:06.793", "LastActivityDate": "2011-06-21T04:26:06.793"}, "6420345": {"ParentId": "6420329", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No it is not. You must call delete[] on the very same address (or pointer) that you received from new[]. You might just get lucky that it does not crash, but it definitely does not clear the memory appropriately.</p>\n<p>References :</p>\n<p>From <a href=\"http://www.cplusplus.com/doc/tutorial/dynamic/\" rel=\"nofollow\">http://www.cplusplus.com/doc/tutorial/dynamic/</a></p>\n<pre><code>The value passed as argument to delete must be either a pointer to a memory block\npreviously allocated with new, or a null pointer (in the case of a null pointer,\ndelete produces no effect).\n</code></pre>\n<p>From <a href=\"http://msdn.microsoft.com/en-us/library/h6227113.aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/h6227113.aspx</a></p>\n<pre><code>Using delete on a pointer to an object not allocated with new gives\nunpredictable results. You can, however, use delete on a pointer with the\nvalue 0. This provision means that, when new returns 0 on failure, deleting\nthe result of a failed new operation is harmless.\n</code></pre>\n", "OwnerUserId": "153863", "LastEditorUserId": "153863", "LastEditDate": "2011-06-21T04:38:23.987", "Id": "6420345", "Score": "7", "CreationDate": "2011-06-21T04:26:47.790", "LastActivityDate": "2011-06-21T04:38:23.987"}, "6420369": {"ParentId": "6420329", "CommentCount": "0", "Body": "<p>It is not legal  The fact that it does not crash does not mean it will not in other circumstances. It will surely crash if you enable verifier.  And in any case it will not free your array.   This is just the CRT / Windows letting your program not crash when it should</p>\n", "OwnerUserId": "251132", "PostTypeId": "2", "Id": "6420369", "Score": "0", "CreationDate": "2011-06-21T04:30:36.513", "LastActivityDate": "2011-06-21T04:30:36.513"}, "6420445": {"ParentId": "6420329", "CommentCount": "0", "Body": "<p>From standard docs,. <em>5.3.5.2 <code>Delete</code></em>,</p>\n<blockquote>\n<p id=\"so_6420329_6420445_0\">... In the second\n  alternative (delete array), the value of the operand of delete shall be the pointer value which resulted from a previous\n  array new-expression.72) If not, the behavior is undefined. ....</p>\n</blockquote>\n<p>Also the sub-note <em>72)</em> states that,</p>\n<blockquote>\n<p id=\"so_6420329_6420445_1\">72)For non-zero-length arrays, this is the same as a pointer to the first element of the array created by that new-expression. Zero-length arrays do not\n  have a first element.</p>\n</blockquote>\n<p>And so yes, it is undefined.</p>\n", "OwnerUserId": "249490", "PostTypeId": "2", "Id": "6420445", "Score": "6", "CreationDate": "2011-06-21T04:45:25.373", "LastActivityDate": "2011-06-21T04:45:25.373"}, "6420441": {"ParentId": "6420329", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No, it is undefined to pass any address to <code>delete</code> which was not returned by <code>new</code>.<br>\nHere is the quote from the Standard.</br></p>\n<p><strong>\u00a7 3.7.4.2-3</strong></p>\n<p><em>If a deallocation function terminates by throwing an exception, the behavior is undefined. The value of the first argument supplied to a deallocation function may be a null pointer value; if so, and if the deallocation function is one supplied in the standard library, the call has no effect. Otherwise, the value supplied\nto operator <code>delete(void*)</code> in the standard library shall be one of the values returned by a previous invocation of either operator <code>new(std::size_t)</code> or <code>operator new(std::size_t, const std::nothrow_-t&amp;)</code> in the standard library, and the value supplied to operator <code>delete[](void*)</code> in the standard library shall be one of the values returned by a previous invocation of either <code>operator new[](std::size_t)</code> or\n<code>operator new[](std::size_t, const std::nothrow_t&amp;)</code> in the standard library.</em></p>\n", "OwnerUserId": "452307", "LastEditorDisplayName": "user79758", "LastEditDate": "2011-06-21T08:16:07.323", "Id": "6420441", "Score": "21", "CreationDate": "2011-06-21T04:43:52.423", "LastActivityDate": "2011-06-21T08:16:07.323"}, "6428335": {"ParentId": "6420329", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The standard states that you can only delete what you allocated with new, but that doesn't explain why it crashes, or in this case, doesn't crash.</p>\n<p>When you delete a pointer, you are putting it back in the heap to be used again in future allocations.\nThe typical implementation gives you a pointer, with an int just before your pointer tracking the memory in the block (that's the typical malloc implementation).  Like this, for a typical 32 bit system.</p>\n<pre><code>     p-4  size here\np--&gt;     +--------+\n         |  your  |\n         |  block |\n</code></pre>\n<p>So if you point into the middle of the block, it's going to interpret the bytes just before it as a size, with potentially disasterous results.  You were saved from seeing the crash by your tiny code example.  Probably, you never tried to allocate after that point.  If you try to allocate something after that, it will probably crash, because it will try to recycle some of the memory you just gave back.</p>\n<p>The exact reason obviously depends on the implementation.  This is just to explain one common way improper deletes can fail, not specifically verified for Visual Studio 2005.</p>\n", "OwnerUserId": "233928", "LastEditorUserId": "233928", "LastEditDate": "2011-06-21T16:02:07.887", "Id": "6428335", "Score": "1", "CreationDate": "2011-06-21T15:56:46.043", "LastActivityDate": "2011-06-21T16:02:07.887"}, "6420329": {"CommentCount": "4", "AcceptedAnswerId": "6420441", "PostTypeId": "1", "LastEditorUserId": "3002139", "CreationDate": "2011-06-21T04:24:34.420", "LastActivityDate": "2017-08-02T20:30:28.463", "LastEditDate": "2017-08-02T20:30:28.463", "ViewCount": "1414", "FavoriteCount": "2", "Title": "Can I delete[] a pointer that points into an allocated array, but not to the start of it?", "Id": "6420329", "Score": "17", "Body": "<p>I'm wondering specifically about the following situation (which I discovered in some code I have to work with):</p>\n<pre><code>SomeClass *ar = new SomeClass[2];\nar++;\ndelete[] ar;\n</code></pre>\n<p>This code seems to be working fine - i.e. not crashing (win32, built with VS2005).</p>\n<p>Is this \"legal\"? It certainly doesn't feel right.</p>\n", "Tags": "<c++>", "OwnerUserId": "338803", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_6420329_6420445_1": {"section_id": 6106, "quality": 0.9333333333333333, "length": 14}, "so_6420329_6420445_0": {"section_id": 6106, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_6420329_6420445_1": {"section_id": 5872, "quality": 0.9333333333333333, "length": 14}, "so_6420329_6420445_0": {"section_id": 5872, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_6420329_6420445_1": {"section_id": 7603, "quality": 0.9333333333333333, "length": 14}, "so_6420329_6420445_0": {"section_id": 7603, "quality": 0.8666666666666667, "length": 13}}}});