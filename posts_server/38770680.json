post_cb({"38772162": {"Id": "38772162", "PostTypeId": "2", "Body": "<p><code>wchar_t</code> is just an integral literal.  It has a min value, a max value, etc.</p>\n<p>Its size is not fixed by the standard.</p>\n<p>If it is large enough, you can store UCS-2 or UCS-4 data in a buffer of <code>wchar_t</code>.  This is true regardless of the system you are on, as UCS-2 and UCS-4 and UTF-16 and UTF-32 are just descriptions of integer values arranged in a sequence.</p>\n<p>In C++11, there are <code>std</code> APIs that read or write data presuming it has those encodings.  In C++03, there are APIs that read or write data using the current locale.</p>\n<blockquote>\n<p id=\"so_38770680_38772162_0\">22.5 Standard code conversion facets [locale.stdcvt]</p>\n<p id=\"so_38770680_38772162_1\">3 For each of the three code conversion facets codecvt_utf8, codecvt_utf16, and codecvt_utf8_utf16:</p>\n<p id=\"so_38770680_38772162_2\">(3.1) \u2014 Elem is the wide-character type, such as wchar_t, char16_t, or char32_t.</p>\n<p id=\"so_38770680_38772162_3\">4 For the facet codecvt_utf8:</p>\n<p id=\"so_38770680_38772162_4\">(4.1) \u2014 The facet shall convert between UTF-8 multibyte sequences and UCS2 or UCS4 (depending on the size of Elem) within the program.</p>\n</blockquote>\n<p>So here it <code>codecvt_utf8_utf16</code> deals with <code>utf8</code> on one side, and UCS2 or UCS4 (depending on how big Elem is) on the other.  It does conversion.</p>\n<p>The Elem (the wide character) is presumed to be encoded in UCS2 or UCS4 depending on how big it is.</p>\n<p>This does not mean that <code>wchar_t</code> is encoded as such, it just means <em>this operation interprets the <code>wchar_t</code> as being encoded as such</em>.</p>\n<p>How the UCS2 or UCS4 got into the Elem is not something this part of the standard cares about.  Maybe you set it in there with hex constants.  Maybe you read it from io.  Maybe you calculated it on the fly.  Maybe you used a high-quality random-number generator.  Maybe you added together the bit-values of an <code>ascii</code> string.  Maybe you calculated a fixed-point approximation of the <code>log*</code> of the number of seconds it takes the moon to change the Earth's day by 1 second.  <strong>Not these paragraphs problems.</strong>  These pragraphs simply mandate how bits are modified and interpreted.</p>\n<p>Similar claims hold in other cases.  This does not mandate what format <code>wchar_t</code> have.  It simply states how these facets interpret <code>wchar_t</code> or <code>char16_t</code> or <code>char32_t</code> or <code>char8_t</code> (reading or writing).</p>\n<p>Other ways of interacting with <code>wchar_t</code> use different methods to mandate how the value of the <code>wchar_t</code> is interpreted.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/string/wide/iswalpha\" rel=\"nofollow\"><code>iswalpha</code></a> uses the (global) locale to interpret the <code>wchar_t</code>, for example.  In some locals, the <code>wchar_t</code> may be UCS2.  In others, it might be some insane cthulian encoding whose details enable you to see a new color from out of space.</p>\n<p>To be explicit: encodings are not the property of data, or bits.  Encodings are properties of <em>interpretation of data</em>.  Quite often there is only one <em>proper</em> or <em>reasonable</em> interpretation of data that makes any sense, but the data itself is bits.</p>\n<p>The C++ standard does not mandate what is stored in a <code>wchar_t</code>.  It does mandate what certain operations interpret the contents of a <code>wchar_t</code> to be.  That section describes how some facets interpret the data in a <code>wchar_t</code>.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2016-08-04T16:08:58.030", "Score": "6", "CreationDate": "2016-08-04T15:57:16.833", "ParentId": "38770680", "CommentCount": "0", "OwnerUserId": "1774667", "LastEditDate": "2016-08-04T16:08:58.030"}, "38776036": {"Id": "38776036", "PostTypeId": "2", "Body": "<p>The first interpretation is conditionally true.</p>\n<p>If <code>__STDC_ISO_10646__</code> macro (imported from C) is defined, then <code>wchar_t</code> is a superset of some version of Unicode. </p>\n<blockquote>\n<p id=\"so_38770680_38776036_0\"><code>__STDC_ISO_10646__</code><br>\n  An integer literal of the form <code>yyyymmL</code> (for example, <code>199712L</code>). If this symbol is defined, then every\n  character in the Unicode required set, when stored in an object of type <code>wchar_t</code>, has the same value\n  as the short identifier of that character. The Unicode required set consists of all the characters that\n  are defined by ISO/IEC 10646, along with all amendments and technical corrigenda as of the specified\n  year and month.</br></p>\n</blockquote>\n<p>It appears that if the macro is defined, some kind of UCS4 can be assumed. (Not UCS2 as ISO 10646 never had a 16-bit version; the first release of ISO 10646 corresponds to Unicode 2.0).</p>\n<p>So if the macro is defined, then </p>\n<ul>\n<li>there is a \"native\" wchar_t encoding</li>\n<li>it is a superset of some version of UCS4</li>\n<li>the conversion provided by <code>codecvt_utf8&lt;wchar_t&gt;</code> is compatible with this native encoding</li>\n</ul>\n<p>None of these things are required to hold if the macro is not defined.</p>\n<p>There are also <code>__STDC_UTF_16__</code> and <code>__STDC_UTF_32__</code> but the C++ standard doesn't say what they mean. The C standard says that they signify UTF-16 and UTF-32 encodings for <code>char16_t</code> and <code>char32_t</code> respectively, but in C++ these encodings are always used.</p>\n<p>Incidentally, the functions <code>mbrtoc32</code> and <code>c32rtomb</code> convert back and forth between <code>char</code> sequences and <code>char32_t</code> sequences. In C they only use UTF-32 if <code>__STDC_UTF_32__</code> is defined, but in C++ UTF-32 is always used for <code>char32_t</code>. So it would appear than even if <code>__STDC_ISO_10646__</code> is <em>not</em> defined, it should be possible to convert between UTF-8 and <code>wchar_t</code> by going from UTF-8 to UTF-32-encoded <code>char32_t</code> to natively encoded <code>char</code> to natively encoded <code>wchar_t</code>, but I'm afraid of this complex stuff.</p>\n", "LastEditorUserId": "775806", "LastActivityDate": "2016-08-04T19:50:32.323", "Score": "0", "CreationDate": "2016-08-04T19:40:25.557", "ParentId": "38770680", "CommentCount": "0", "OwnerUserId": "775806", "LastEditDate": "2016-08-04T19:50:32.323"}, "38771153": {"Id": "38771153", "PostTypeId": "2", "Body": "<p>Let us differentiate between <code>wchar_t</code> and string literals built using the <code>L</code> prefix.</p>\n<p><code>wchar_t</code> is just an integer type, which may be larger than <code>char</code>.</p>\n<p>String literals using the <code>L</code> prefix will generate strings using <code>wchar_t</code> characters. Exactly what that means is implementation-dependent. There is no requirement that such literals use <em>any particular encoding</em>. They might use UTF-16, UTF-32, or something else that has nothing to do with Unicode at all.</p>\n<p>So if you want a string literal which is <em>guaranteed</em> to be encoded in a Unicode format, across all platforms, use <code>u8</code>, <code>u</code>, or <code>U</code> prefixes for the string literal.</p>\n<blockquote>\n<p id=\"so_38770680_38771153_0\">One interpretation of these two paragraphs is that wchar_t must be encoded as either UCS2 or UCS4.</p>\n</blockquote>\n<p>No, that is not a valid interpretation. <code>wchar_t</code> <em>has no encoding</em>; it's just a type. It is <em>data</em> which is encoded. A string literal prefixed by <code>L</code> may or may not be encoded in UCS2 or UCS4.</p>\n<p>If you provide <code>codecvt_utf8</code> a string of <code>wchar_t</code>s which are encoded in UCS2 or UCS4 (as appropriate to <code>sizeof(wchar_t)</code>), then it will work. But not because of <code>wchar_t</code>; it only works because the <em>data</em> you provide it is correctly encoded.</p>\n<blockquote>\n<p id=\"so_38770680_38771153_1\">If 4.1 said \"The facet shall convert between UTF-8 multibyte sequences and UCS2 or UCS4 or whatever encoding is imposed on wchar_t by the current global locale\" there would be no problem.</p>\n</blockquote>\n<p>The whole point of those <code>codecvt_*</code> facets is to perform <em>locale-independent</em> conversions. If you want locale-dependent conversions, you shouldn't use them. You should instead use the global <code>codecvt</code> facet.</p>\n", "LastEditorUserId": "734069", "LastActivityDate": "2016-08-04T16:06:41.817", "Score": "3", "CreationDate": "2016-08-04T15:10:15.540", "ParentId": "38770680", "CommentCount": "13", "OwnerUserId": "734069", "LastEditDate": "2016-08-04T16:06:41.817"}, "38771875": {"Id": "38771875", "PostTypeId": "2", "Body": "<p>As <code>Elem</code> can be <code>wchar_t</code>, <code>char16_t</code>, or <code>char32_t</code>,  the clause 4.1 says nothing about a required <code>wchar_t</code> encoding.  It  states something about the conversion performed. </p>\n<p>From the wording, it is clear that the conversion is between UTF-8 and either UCS-2 or UCS-4, depending on the size of <code>Elem</code>. So if <code>wchar_t</code> is 16 bits, the conversion will be with UCS-2, and if it is 32 bits, UCS-4.  </p>\n<p>Why does the standard mention UCS-2 and UCS-4 and not UTF-16 and UTF-32 ?  Because  <code>codecvt_utf8</code> will convert a multi-byte UTF8 to a single wide character:  </p>\n<ul>\n<li>UCS-2 is a subset of unicode, but there is <a href=\"https://en.wikipedia.org/wiki/UTF-16#U.2B10000_to_U.2B10FFFF\" rel=\"nofollow\">no surogate pair encoding</a> contrary to UTF-16 </li>\n<li>UCS-4 is the same as UTF-32, now (but looking at the growing number of emojis, maybe one day there couldn't be enough of 32 bits, and you would have a UTF-64, and UTF32 surrogate pairs that would not be supported by <code>codecvt_utf8</code>)</li>\n</ul>\n<p><em>Although, it is not clear to me what will happen, if an UTF-8 text would contain a sequence corresponds to a unicode character that is not available in UCS-2 used for a receiving <code>char16_t</code>.</em> </p>\n", "LastActivityDate": "2016-08-04T15:43:01.773", "CommentCount": "1", "CreationDate": "2016-08-04T15:43:01.773", "ParentId": "38770680", "Score": "1", "OwnerUserId": "3723423"}, "38772192": {"Id": "38772192", "PostTypeId": "2", "Body": "<p>Both your interpretations are incorrect.  The standard doesn't require that there be a single <code>wchar_t</code> encoding, just like it doesn't require a single <code>char</code> encoding.  The <code>codecvt_utf8</code> facet must convert between UTF-8 and UCS-2 or UCS-4.\nThis true even UTF-8, UCS-2, and UCS-4 are not supported as character sets in any locale.</p>\n<p>If <code>Elem</code> is of type <code>wchar_t</code> and isn't big enough to store a UCS-2 value than then the conversion operations of the <code>codecvt_utf8</code> facet are undefined because the standard doesn't say what happens in that case. If it is big enough (or if you want to argue that the standard requires that it must be big enough) then it's merely implementation defined whether the UCS-2 or UCS-4 <code>wchar_t</code> values the facet generates or consumes are in an encoding compatible with any locale defined <code>wchar_t</code> encoding.</p>\n", "LastActivityDate": "2016-08-04T15:58:48.007", "CommentCount": "12", "CreationDate": "2016-08-04T15:58:48.007", "ParentId": "38770680", "Score": "1", "OwnerUserId": "3826372"}, "bq_ids": {"n4140": {"so_38770680_38772162_4": {"length": 12, "quality": 0.9230769230769231, "section_id": 6658}, "so_38770680_38771118_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 7214}, "so_38770680_38772162_2": {"length": 7, "quality": 1.0, "section_id": 6657}, "so_38770680_38770680_2": {"length": 14, "quality": 0.875, "section_id": 6658}, "so_38770680_38772162_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 6657}, "so_38770680_38770680_1": {"length": 15, "quality": 0.9375, "section_id": 6657}, "so_38770680_38776036_0": {"length": 40, "quality": 0.9302325581395349, "section_id": 551}}, "n3337": {"so_38770680_38772162_4": {"length": 12, "quality": 0.9230769230769231, "section_id": 6413}, "so_38770680_38771118_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 6958}, "so_38770680_38770680_2": {"length": 14, "quality": 0.875, "section_id": 6413}, "so_38770680_38772162_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 6412}, "so_38770680_38770680_1": {"length": 15, "quality": 0.9375, "section_id": 6412}, "so_38770680_38776036_0": {"length": 40, "quality": 0.9302325581395349, "section_id": 542}, "so_38770680_38772162_2": {"length": 7, "quality": 1.0, "section_id": 6412}}, "n4659": {"so_38770680_38772162_4": {"length": 12, "quality": 0.9230769230769231, "section_id": 6436}, "so_38770680_38771118_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 8723}, "so_38770680_38770680_2": {"length": 14, "quality": 0.875, "section_id": 6436}, "so_38770680_38772162_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 6435}, "so_38770680_38770680_1": {"length": 15, "quality": 0.9375, "section_id": 6435}, "so_38770680_38776036_0": {"length": 40, "quality": 0.9302325581395349, "section_id": 572}, "so_38770680_38772162_2": {"length": 7, "quality": 1.0, "section_id": 6435}}}, "38771683": {"Id": "38771683", "PostTypeId": "2", "Body": "<p>It appears your first conclusion is shared by <a href=\"https://msdn.microsoft.com/en-us/library/ee336489.aspx\" rel=\"nofollow\">Microsoft</a> who enumerate the possible options, and note that UTF-16, although \"widely used as such[sic]\" is not a valid encoding.</p>\n<p>The same wording is also used by <a href=\"http://www.qnx.com/developers/docs/660/index.jsp?topic=%2Fcom.qnx.doc.dinkum%2Ftopic%2Fcpp11%2Fcodecvt.html\" rel=\"nofollow\">QNX</a>, which points at the source of the wording: Both QNX and Microsoft derive their Standard Library implementation from Dinkumware.</p>\n<p>Now, as it happens, Dinkumware is also the author of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2401.htm\" rel=\"nofollow\">N2401</a> which introduced these classes. So I'm going to side with them.</p>\n", "LastActivityDate": "2016-08-04T15:33:52.123", "CommentCount": "4", "CreationDate": "2016-08-04T15:33:52.123", "ParentId": "38770680", "Score": "1", "OwnerUserId": "15416"}, "38770680": {"ViewCount": "300", "Body": "<p>Here are some excerpts from my copy of the 2014 draft standard N4140</p>\n<blockquote>\n<p id=\"so_38770680_38770680_0\"><strong>22.5 Standard code conversion facets [locale.stdcvt]</strong></p>\n<p id=\"so_38770680_38770680_1\">3 For each of the three code conversion facets <code>codecvt_utf8</code>, <code>codecvt_utf16</code>, and <code>codecvt_utf8_utf16</code>:<br>\n  (3.1) \u2014 <code>Elem</code> is the wide-character type, such as <code>wchar_t</code>, <code>char16_t</code>, or <code>char32_t</code>.</br></p>\n<p id=\"so_38770680_38770680_2\">4 For the facet <code>codecvt_utf8</code>:<br>\n  (4.1) \u2014 The facet shall convert between UTF-8 multibyte sequences and UCS2 or UCS4 (depending on the size of <code>Elem</code>) within the program.</br></p>\n</blockquote>\n<p>One interpretation of these two paragraphs is that <code>wchar_t</code> must be encoded as either UCS2 or UCS4. I don't like it much because if it's true, we have an important property of the language buried deep in a library description. I have tried to find a more direct statement of this property, but to no avail.</p>\n<p>Another interpretation that <code>wchar_t</code> encoding is not required to be either UCS2 or UCS4, and on implementations where it isn't, <code>codecvt_utf8</code> won't work for <code>wchar_t</code>. I don't like this interpretation much either, because if it's true, and neither <code>char</code> nor <code>wchar_t</code> native encodings are Unicode, there doesn't seem to be a way to portably convert between those native encodings and Unicode.</p>\n<p>Which of the two interpretations is true? Is there another one which I overlooked?</p>\n<p><strong>Clarification</strong> I'm not asking about general opinions about suitability of <code>wchar_t</code> for software development, or properties of <code>wchar_t</code> one can derive from elsewhere. I am interested <strong>in these two specific paragraphs</strong> of the standard. I'm trying to understand what <strong>these specific paragraphs</strong> entail or do not entail.</p>\n<p><strong>Clarification 2</strong>. If 4.1 said \"The facet shall convert between UTF-8 multibyte sequences and UCS2 or UCS4 <em>or whatever encoding is imposed on wchar_t by the current global locale</em>\" there would be no problem. It doesn't. It says what it says. It appears that if one uses <code>std::codecvt_utf8&lt;wchar_t&gt;</code>, one ends up with a bunch of <code>wchar_t</code> encoded as UCS2 or UCS4, regardless of the current global locale. (There is no way to specify a locale or any character conversion facet for <code>codecvt_utf8</code>). So the question can be rephrased like this: is the conversion result directly usable with the current global locale (and/or with any possible locale) for output, <code>wctype</code> queries and so on? If not, what it is usable <em>for</em>? (If the second interpretation above is correct, the answer would seem to be \"nothing\").</p>\n", "AcceptedAnswerId": "38772162", "Title": "Does the C++ standard mandate an encoding for wchar_t?", "CreationDate": "2016-08-04T14:49:31.903", "Id": "38770680", "CommentCount": "30", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-08-04T16:00:02.420", "LastEditorUserId": "775806", "LastActivityDate": "2016-08-04T19:50:32.323", "Score": "3", "OwnerUserId": "775806", "Tags": "<c++><c++11><unicode><wchar-t>", "AnswerCount": "7"}, "38771118": {"Id": "38771118", "PostTypeId": "2", "Body": "<p>No.</p>\n<p><code>wchar</code> is only required to hold the biggest locale supported by the compiler. Which could theoretically fit in a char. </p>\n<blockquote>\n<p id=\"so_38770680_38771118_0\">Type wchar_t is a distinct type whose values can represent distinct codes for all members of the largest extended character set specified among the supported locales (22.3.1).</p>\n<p id=\"so_38770680_38771118_1\">\u2014 C++ [basic.fundamental] 3.9.1/5</p>\n</blockquote>\n<p>as such it's not even required to support Unicode</p>\n<blockquote>\n<p id=\"so_38770680_38771118_2\">The width of wchar_t is compiler-specific and can be as small as 8 bits. Consequently, programs that need to be portable across any C or C++ compiler should not use wchar_t for storing Unicode text. The wchar_t type is intended for storing compiler-defined wide characters, which may be Unicode characters in some compilers.</p>\n<p id=\"so_38770680_38771118_3\">ISO/IEC 10646:2003 Unicode standard 4.0</p>\n</blockquote>\n", "LastActivityDate": "2016-08-04T15:08:56.510", "CommentCount": "0", "CreationDate": "2016-08-04T15:08:56.510", "ParentId": "38770680", "Score": "5", "OwnerUserId": "5160450"}});