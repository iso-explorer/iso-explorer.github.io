post_cb({"11491812": {"CommentCount": "2", "ViewCount": "3983", "PostTypeId": "1", "LastEditorUserId": "1332475", "CreationDate": "2012-07-15T12:17:20.247", "LastActivityDate": "2014-04-19T19:39:10.667", "Title": "boost::shared_ptr is it safe to use it in multiple threads?", "AcceptedAnswerId": "11492094", "LastEditDate": "2012-07-15T12:44:10.173", "Id": "11491812", "Score": "7", "Body": "<p>I was trying to find the answer for some time but I failed.</p>\n<p>Lets assume that we have a <code>shared_ptr</code> created from one thread. Then we pass this <code>shared_ptr</code> to another 2 threads (using some queue for example). So from this moment there are 2 copies of the original <code>shared_ptr</code>, pointing to the same raw pointer.\nBoth owner threads will take their copies of this <code>shared_ptr</code> from the queue. Then they will pass it to another thread or will destroy it.</p>\n<p>Question is - is it safe? Will the raw pointer destroyed correctly (there will be no race to reference counter?)\n<img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/0vPVM.jpg\"/></p>\n", "Tags": "<c++><multithreading><boost><shared-ptr>", "OwnerUserId": "1332475", "AnswerCount": "3"}, "11492094": {"ParentId": "11491812", "CommentCount": "2", "Body": "<p>The <a href=\"http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm#ThreadSafety\">boost docs</a> state:</p>\n<blockquote>\n<p id=\"so_11491812_11492094_0\">Different shared_ptr instances can be \"written to\" (accessed using mutable operations such as operator= or reset) simultaneosly by multiple threads (<strong>even when these instances are copies, and share the same reference count underneath.</strong>)</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>So the crux here is whether you <em>copy</em> the <code>boost::shared_ptr</code>s between threads or not.  If you create copies (the \"safe\" way to use <code>shared_ptr</code>s) you don't have any worries about thread-safety.  If however you pass the <code>shared_ptr</code> by reference or pointer, and hence are using the actual same <code>shared_ptr</code> in different threads, you would have to worry about thread-safety, as described in the docs.</p>\n", "OwnerUserId": "2556117", "PostTypeId": "2", "Id": "11492094", "Score": "5", "CreationDate": "2012-07-15T12:57:05.733", "LastActivityDate": "2012-07-15T12:57:05.733"}, "11491905": {"ParentId": "11491812", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>The C++ standard has almost no guarantees regarding thread safety. The reference count of <code>std::shared_ptr</code> is the only exception: it\u2019s guaranteed to behave as an atomically accessed variable. I believe this is codified in this phrase in \u00a720.7.2.2/4:</p>\n<blockquote>\n<p id=\"so_11491812_11491905_0\">Changes in <code>use_count()</code> do not reflect modifications that can introduce data races.</p>\n</blockquote>\n<p><code>boost::shared_ptr</code> <a href=\"http://www.boost.org/doc/libs/1_50_0/libs/smart_ptr/shared_ptr.htm#ThreadSafety\">offers the same guarantees</a>:</p>\n<blockquote>\n<p id=\"so_11491812_11491905_1\">shared_ptr objects offer the same level of thread safety as built-in types. A shared_ptr instance can be \"read\" \u2026 simultaneously by multiple threads. Different shared_ptr instances can be \"written to\"\u2026 simultaneosly by multiple threads (even when these instances are copies, and share the same reference count underneath.)</p>\n</blockquote>\n", "OwnerUserId": "1968", "LastEditorUserId": "1968", "LastEditDate": "2012-07-15T13:21:13.087", "Id": "11491905", "Score": "9", "CreationDate": "2012-07-15T12:29:53.650", "LastActivityDate": "2012-07-15T13:21:13.087"}, "23174605": {"ParentId": "11491812", "CommentCount": "0", "Body": "<p>I would like to post my comment for the reference counting  in the boost shared pointer in the multiple threads use cases. The comment is to answer the question that \u201cis there any race condition in the boost shared pointer reference counting?\u201d</p>\n<p>My simple answer is \u201cNo\u201d at least after boost 1.35 for most mainstream compiler. The boost implementation called \u201cadd_ref_copy\u201d defined in the boost/detail/shared_count.hpp. This function will invoke the corresponding atomic function defined for individual compiler. For example, the windows version will call \u201cBOOST_INTERLOCKED_INCREMENT\u201d to increment the count in the atomic way (see details in detail\\sp_counted_base_w32.hpp). And the Linux gcc for X86 will call atomic_increment(\u2026 ) (see details in detail\\sp_counted_base_gcc_x86.hpp). Each individual compiler implemented the thread-safe mechanism to make sure the reference counting update in an efficient way. Some piece of code are even written in assembly.</p>\n<p>Now there is a caveats in my simple answer. You really need to make sure your compiler is included in the boost\u2019s blessed list for multiple thread-safe reference counting. If you are not sure you can define \u201cBOOST_SP_USE_PTHREADS\u201d which drives boost to use the pthread library to make reference count update atomically (by including boost/detail/sp_counted_base_pt.hpp for pthread solution).</p>\n", "OwnerUserId": "3552511", "PostTypeId": "2", "Id": "23174605", "Score": "0", "CreationDate": "2014-04-19T19:39:10.667", "LastActivityDate": "2014-04-19T19:39:10.667"}, "bq_ids": {"n4140": {"so_11491812_11491905_0": {"section_id": 4377, "quality": 1.0, "length": 8}}, "n3337": {"so_11491812_11491905_0": {"section_id": 4214, "quality": 1.0, "length": 8}}, "n4659": {"so_11491812_11491905_0": {"section_id": 5640, "quality": 1.0, "length": 8}}}});