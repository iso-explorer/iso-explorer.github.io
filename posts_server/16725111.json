post_cb({"16725111": {"CommentCount": "0", "ViewCount": "403", "CreationDate": "2013-05-23T22:44:23.320", "LastActivityDate": "2013-05-23T22:52:45.083", "Title": "Pointer to member for std::array", "AcceptedAnswerId": "16725135", "PostTypeId": "1", "Id": "16725111", "Score": "1", "Body": "<p>Suppose I have a structure containing an array of objects of another structure type, like this:</p>\n<pre><code>struct foo { int x, y; };\nstruct bar { std::array&lt;foo, 4&gt; foos; };\n</code></pre>\n<p>Is it possible to portably write an expression which will evaluate to a pointer-to-member for a given attribute of a given array element? Something like <code>&amp;bar::foos[2]::x</code>?</p>\n<p>The application is <a href=\"https://github.com/imvu/emscripten/wiki/embind\" rel=\"nofollow\">embind</a>: I'd like to map a nested C++ type like this to a linear JavaScript tuple if possible. If this does not work out using pointer-to-member, then I could probably try using getter and setter methods instead, but I would still like to know whether there is a way to obtain such a pointer-to-member.</p>\n", "Tags": "<c++><c++11><emscripten><stdarray>", "OwnerUserId": "1468366", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_16725111_16725135_0": {"section_id": 6067, "quality": 1.0, "length": 10}}, "n3337": {"so_16725111_16725135_0": {"section_id": 5835, "quality": 1.0, "length": 10}}, "n4659": {"so_16725111_16725135_0": {"section_id": 7563, "quality": 1.0, "length": 10}}}, "16725135": {"ParentId": "16725111", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>I don't think you can do anything like that. <code>foos[2]</code> is not a member of <code>bar</code>, only <code>foos</code> is. You cannot get a pointer-to-member from something which is not a member. Paragraph 5.3.1/4 of the C++11 Standard specifies:</p>\n<blockquote>\n<p id=\"so_16725111_16725135_0\">A pointer to member is only formed when an explicit <code>&amp;</code> is used and its operand is a <em>qualified-id</em> not enclosed in parentheses.</p>\n</blockquote>\n<p>This means the grammar itself prevents you from writing anything that does not look like:</p>\n<pre><code>&amp;class_name::member_name\n</code></pre>\n<p>where <code>class_name</code> could itself be a qualified name. No subscript operator or other fancy notation is allowed.</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-05-23T22:52:45.083", "Id": "16725135", "Score": "1", "CreationDate": "2013-05-23T22:46:38.787", "LastActivityDate": "2013-05-23T22:52:45.083"}});