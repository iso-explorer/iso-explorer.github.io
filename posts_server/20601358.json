post_cb({"bq_ids": {"n4140": {"so_20601358_20601358_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 7153}, "so_20601358_20601358_1": {"length": 31, "quality": 0.8857142857142857, "section_id": 7153}}, "n3337": {"so_20601358_20601358_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 6897}, "so_20601358_20601358_1": {"length": 31, "quality": 0.8857142857142857, "section_id": 6897}}, "n4659": {"so_20601358_20601358_2": {"length": 10, "quality": 0.7692307692307693, "section_id": 8657}, "so_20601358_20601358_1": {"length": 22, "quality": 0.6285714285714286, "section_id": 8657}}}, "20716297": {"Id": "20716297", "PostTypeId": "2", "Body": "<p>As you've already found out the C++ standard doesn't guarantee that \"the dynamic initialization of a non-local variable with static storage duration is done before the \ufb01rst statement of main\". However, GCC does peform such initialization before executing main as described in <a href=\"http://gcc.gnu.org/onlinedocs/gccint/Initialization.html\" rel=\"nofollow\">How Initialization Functions Are Handled</a>.</p>\n<p>The only problem is initialization of static objects from shared libraries loaded with <code>dlopen</code>. These will only be initialized at the time the library is loaded, but there's nothing you can do about it.</p>\n", "LastActivityDate": "2013-12-21T06:36:18.647", "CommentCount": "0", "CreationDate": "2013-12-21T06:36:18.647", "ParentId": "20601358", "Score": "1", "OwnerUserId": "471164"}, "20601358": {"ViewCount": "700", "Body": "<p>Does gcc have any guarantees about static member initialization timing, especially regarding template classes?</p>\n<p>I want to know if I can get a hard guarantee that static members (<code>PWrap_T&lt;T&gt;::p_s</code>) will be initialized before <code>main()</code>, when classes are instantiated across multiple compilation units. It isn't practical to try to manually touch a symbol from each compilation unit at the start of main, but it isn't clear to me that anything else would work.</p>\n<p>I've tested with methods like <code>bar()</code> in different units and <em>always</em> gotten the desired result, but I need to know when/if ever gcc will yank the rug out and whether it's preventable.</p>\n<p>Furthermore, will all static members from a DSO be initialized before a library finishes loading?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;deque&gt;\n\nstruct P;\ninline std::deque&lt;P *&gt; &amp;ps() { static std::deque&lt;P *&gt; d; return d; }\nvoid dump();\n\nstruct P {\n  P(int id, char const *i) : id_(id), inf_(i) { ps().push_back(this); }\n  void doStuff() { std::cout &lt;&lt; id_ &lt;&lt; \" (\" &lt;&lt; inf_ &lt;&lt; \")\" &lt;&lt; std::endl; }\n  int  const        id_;\n  char const *const inf_;\n};\n\ntemplate &lt;class T&gt;\nstruct PWrap_T { static P p_s; };\n\n// *** Can I guarantee this is done before main()? ***\ntemplate &lt;class T&gt;\nP PWrap_T&lt;T&gt;::p_s(T::id(), T::desc());\n\n#define PP(ID, DESC, NAME) /* semicolon must follow! */  \\\nstruct ppdef_##NAME  {                                   \\\n  constexpr static int         id()   { return ID; }     \\\n  constexpr static char const *desc() { return DESC; }   \\\n};                                                       \\\nPWrap_T&lt;ppdef_##NAME&gt; const NAME\n\n// In a compilation unit apart from the template/macro header.\nvoid dump() {\n  std::cout &lt;&lt; \"[\";\n  for (P *pp : ps()) { std::cout &lt;&lt; \" \" &lt;&lt; pp-&gt;id_ &lt;&lt; \":\" &lt;&lt; pp-&gt;inf_; }\n  std::cout &lt;&lt; \" ]\" &lt;&lt; std::endl;\n}\n\n// In some compilation unit.\nvoid bar(int cnt) {\n  for (int i = 0; i &lt; cnt; ++i) {\n    PP(2, \"description\", pp);\n    pp.p_s.doStuff();\n  }\n}\n\nint main() {\n  dump();\n  PP(3, \"another\", pp2);\n  bar(5);\n  pp2.p_s.doStuff();\n}\n</code></pre>\n<blockquote>\n<p id=\"so_20601358_20601358_0\"><strong>(C++11 \u00a73.6.2/4 - [basic.start.init]:)</strong></p>\n<p id=\"so_20601358_20601358_1\">It is implementation-defined whether the dynamic initialization of a non-local variable with static storage duration is done before the \ufb01rst statement of main. <strong>If the initialization is deferred to some point in time after the \ufb01rst statement of main, it shall occur before the \ufb01rst odr-use (3.2) of any function or variable defined in the same translation unit as the variable to be initialized.</strong></p>\n<p id=\"so_20601358_20601358_2\">... A non-local variable with static storage duration having initialization with side-effects must be initialized even if it is not odr-used (3.2, 3.7.1).</p>\n</blockquote>\n<p>Also, trying <code>__attribute__ ((init_priority(int)))</code> or <code>__attribute__ ((constructor))</code> for the template member's initialization yielded <code>warning: attributes after parenthesized initializer ignored</code>, and I know no other tricks regarding static initialization.</p>\n<p>Thanks in advance to anyone who can give me an answer about this!</p>\n", "AcceptedAnswerId": "20716423", "Title": "non-deferred static member initialization for templates in gcc?", "CreationDate": "2013-12-15T23:40:40.003", "Id": "20601358", "CommentCount": "2", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2013-12-18T17:50:29.230", "LastEditorUserId": "334932", "LastActivityDate": "2013-12-21T14:14:18.737", "Score": "10", "OwnerUserId": "334932", "Tags": "<c++><gcc><instantiation><static-initialization>", "AnswerCount": "2"}, "20716423": {"Id": "20716423", "PostTypeId": "2", "Body": "<p>The standard guarantees that static storage duration objects are initialized before any functions/variables in the same translation unit as your object are used from an external source.</p>\n<p>The wording here is designed to work with shared libraries. Because shared libraries can be dynamically loaded after main() has started the language specification has to be flexible enough to cope with it. But as long as you access your object from outside the translation unit then you are guaranteed that it will have been constructed before you are given accesses (unless you are doing something pathological).</p>\n<p><strong>BUT</strong> this does not stop it being used before initialization if it is used in the constructor of another static storage duration object in the same compilation unit.</p>\n<p>But you can easily manually provide guarantees that a static object is correctly initialized before used by using the technique below.</p>\n<p>Just change the static variable to a static function. Then inside the function declare a static member that is returned. So you can use it exactly the same way as before (just add <code>()</code>).</p>\n<pre><code>template &lt;class T&gt;\nstruct PWrap_T\n{\n    static P&amp; p_s();  // change static variable to static member function.\n                      // Rather than the type being P make it a reference to P\n                      // because the object will be held internally to the function\n};\n\ntemplate &lt;class T&gt;\nP&amp; PWrap_T&lt;T&gt;::p_s()\n{\n    // Notice the member is static.\n    // This means it will live longer than the function.\n    // Also it will be initialized on first use.\n    // and destructed when other static storage duration objects are destroyed.\n    static P p_s_item(T::id(), T::desc());\n\n    return p_s_item;\n\n    // Note its not guaranteed to be created before main().\n    // But it is guaranteed to be created before first use.\n}\n</code></pre>\n<p>So here you get the benefits of a global (whatever they are). You get guaranteed construction/destruction and you know the object will be correctly constructed before it can be used.</p>\n<p>The only change you need to make is:</p>\n<pre><code>void bar(int cnt) {\n  for (int i = 0; i &lt; cnt; ++i) {\n    PP(2, \"description\", pp);\n    pp.p_s().doStuff();\n     //   ^^  Add the braces here.\n  }\n}\n</code></pre>\n", "LastEditorUserId": "14065", "LastActivityDate": "2013-12-21T14:14:18.737", "Score": "2", "CreationDate": "2013-12-21T06:53:09.610", "ParentId": "20601358", "CommentCount": "5", "OwnerUserId": "14065", "LastEditDate": "2013-12-21T14:14:18.737"}});