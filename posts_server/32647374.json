post_cb({"32647529": {"ParentId": "32647374", "CommentCount": "0", "Body": "<p>Your compiler used an arithmetic right shift instruction, rather than a logical right shift, as the standard allows.  To get the behavior you want, cast to the unsigned type the same width, then shift.</p>\n", "OwnerUserId": "4474419", "PostTypeId": "2", "Id": "32647529", "Score": "1", "CreationDate": "2015-09-18T08:38:45.103", "LastActivityDate": "2015-09-18T08:38:45.103"}, "32647374": {"CommentCount": "7", "AcceptedAnswerId": "32647491", "ClosedDate": "2015-09-18T08:36:33.197", "CreationDate": "2015-09-18T08:31:26.873", "LastActivityDate": "2015-09-18T08:41:52.190", "PostTypeId": "1", "ViewCount": "139", "Title": "Why -1 >> 1 evaluates to -1?", "Id": "32647374", "Score": "0", "Body": "<p>Simply as title says.</p>\n<p>I had a line like this <code>foo | (~(-1 &gt;&gt; 1));</code> which intension it was to keep foo as it is if it is negative and setting the first bit in case it isn't set.</p>\n<p>(by to keep it as it is, I mean the bits)</p>\n<p>But it just didn't change anything for foo.</p>\n<p>after dbeugging I figgured out that <code>-1 &gt;&gt; 1</code> evaluates to -1. I'm pretty sure right shifting does fill up from the left with <code>0</code>'s But this seems to filled a <code>1</code> while that would explain why <code>FF &gt;&gt; 1</code> would evaluate to <code>FF</code> but this seems unreasonable to me aswell.</p>\n<p>So what am I doing wrong / where is my error in my thinking about this?</p>\n", "Tags": "<c++>", "OwnerUserId": "2003898", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_32647374_32647491_0": {"section_id": 6148, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_32647374_32647491_0": {"section_id": 5911, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_32647374_32647491_0": {"section_id": 7644, "quality": 0.8333333333333334, "length": 10}}}, "32647466": {"ParentId": "32647374", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The C++ standard, [expr.shift] (Section 5.8.3) specifies for <code>E1 &gt;&gt; E2</code>:  \"If <code>E1</code> has a signed type and a negative value, the resulting value is implementation-defined.\"  In particular, the implementation could compile this to use use a sign-preserving shift operation.</p>\n", "OwnerUserId": "1948143", "LastEditorUserId": "1948143", "LastEditDate": "2015-09-18T08:41:52.190", "Id": "32647466", "Score": "1", "CreationDate": "2015-09-18T08:35:56.347", "LastActivityDate": "2015-09-18T08:41:52.190"}, "32647491": {"ParentId": "32647374", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Per standard, right shift is implementation-defined (5.8.3):</p>\n<blockquote>\n<p id=\"so_32647374_32647491_0\">The value of E1 &gt;&gt; E2 is E1 right-shifted E2 bit positions. &lt;...&gt; If E1 has a signed type and a negative value, the resulting value\n  is implementation-defined.</p>\n</blockquote>\n<p>For example, this <a href=\"https://msdn.microsoft.com/en-us/library/336xbhcz.aspx\" rel=\"nofollow\">MSDN article</a> mentions that for Microsoft\u2019s compiler</p>\n<blockquote>\n<p id=\"so_32647374_32647491_1\">The right-shift operator causes the bit pattern in shift-expression to\n  be shifted to the right by the number of positions specified by\n  additive-expression. For unsigned numbers, the bit positions that have\n  been vacated by the shift operation are zero-filled. <strong>For signed\n  numbers, the sign bit is used to fill the vacated bit positions.</strong> In\n  other words, if the number is positive, 0 is used, and if the number\n  is negative, 1 is used.</p>\n</blockquote>\n<p>which seems to match your case.</p>\n", "OwnerUserId": "1490355", "LastEditorUserId": "1490355", "LastEditDate": "2015-09-18T08:40:40.113", "Id": "32647491", "Score": "4", "CreationDate": "2015-09-18T08:36:49.260", "LastActivityDate": "2015-09-18T08:40:40.113"}});