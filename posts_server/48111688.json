post_cb({"bq_ids": {"n4140": {"so_48111688_48111688_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 6142}}, "n3337": {"so_48111688_48111688_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 5906}}, "n4659": {"so_48111688_48111688_0": {"length": 26, "quality": 1.0, "section_id": 7638}}}, "48127144": {"Id": "48127144", "PostTypeId": "2", "Body": "<p>getElts returns an address to the beginning of what is an array of something, created in the C library.</p>\n<p>getNElts returns the number of elements in that array.</p>\n<p>Presumably, you know the exact size of Elt.</p>\n<p>Thus, you have all of the information necessary to access your data in C++, using pointer arithmetic if you so choose.  It may be technically \"undefined\", but practically it is not undefined, and it works.  This has to be commonly done, especially when dealing with interfaces to hardware.</p>\n<p>If you are uncomfortable with going out of bounds on the array that you say is not a C++ array, create an array in C++ and place it at the location returned by getElts.  You could even create a std::vector in C++, and memcpy the data pointed to by getElts on to the vector.</p>\n<p>something like this:</p>\n<pre><code>struct Elt{\n    int j;\n    // etc.\n}\n\nstd::vector&lt;Elt&gt; elts;  // create a vector of Elt\n\nsize_t n_elts = getNElts();    // call library to get number of Elts\n\nelts.resize(n_elts);    // resize the vector according to number of elements\n\nElt* addr = getElts();   // get the address of the elements array from the library\n\nstd::memcpy(&amp;elts[0], addr, n_elts * sizeof(Elt));  // copy the array over the vector data, which starts at &amp;elts[0].\n// there may be better ways to do this copy but this works very well.\n\n// now you can access the elements from the vector.\n// using .at for bounds check.\nElt my_elt = elts.at(1);\n\n// not bound checked...\nElt my_elt_2 = elts[2];\n</code></pre>\n<p>You are now working on a copy of the elements contained in a C++ std::vector.  If the elements are dynamic from the library, you can 'place' the vector contents at the address returned by the library, and not do the copy.  Then you are 'looking' at the memory allocated in the C side.</p>\n<p>I'm not sure that all of this is 'defined' behavior, but it will work (I'm not an expert on the standard).  You may have other issues with assuring that the Elt structure really lays out the same in your C and C++ implementations, but that can all be worked out.</p>\n<p>The bottom line is, there are many ways to do what it appears you are wanting to do.  I think you are getting hung up on semantics of pointer arithmetic.  Pointer arithmetic is always dangerous, and can lead to undefined behavior, because it is easy to go out of bounds on an array.  This is why bare arrays are not recommended practice in C++.  There are usually safer ways to do things than using bare arrays.</p>\n", "LastActivityDate": "2018-01-06T12:01:20.333", "Score": "1", "CreationDate": "2018-01-06T12:01:20.333", "ParentId": "48111688", "CommentCount": "1", "OwnerUserId": "8270416"}, "48112158": {"Id": "48112158", "PostTypeId": "2", "Body": "<p>The <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a> standard provides nearly zero interoperability guarantees woth <a class=\"post-tag\" href=\"/questions/tagged/c\" rel=\"tag\" title=\"show questions tagged 'c'\">c</a>.</p>\n<p>As far as C++ is concerned, what happens within C code is outside the scope of C++.</p>\n<p>So \"does this pointer poimt to an array\" is a question the C++ standard cannot answer, as the pointer comes from a C function.  Rather it is a question left to your particular compiler.</p>\n<p>In practice, this works.  In theory, there are no guarantees provided by C++ that your program is well formed when you interact in any way with C.</p>\n<hr>\n<p>This is good news, because the C++ standard is broken around creating dynamic arrays of type T.  It is so bad that there is no standard-compliant way to implement <code>std::vector</code> without compiler magic, or by the compiler defining the undefined behavior that results from attempting to do it.</p>\n<p>However, C++ compilers are free to completely ignore this problem.  They are free to define inter-element pointer arithmetic when objects are contiguously allocated to behave just like an array.  I am unaware of a compiler that states or guarantees this formally.</p>\n<p>Similarly, they are free to produce any guarantees whatesoever with how they treat pointers from C code.  And in practice, they do provide quite reasonable behavior when you interact with C code.</p>\n<p>I am unaware of any formal guaratees by any compiler.</p>\n</hr>", "LastEditorUserId": "1774667", "LastActivityDate": "2018-01-05T14:05:27.457", "Score": "2", "CreationDate": "2018-01-05T10:57:17.543", "ParentId": "48111688", "CommentCount": "3", "OwnerUserId": "1774667", "LastEditDate": "2018-01-05T14:05:27.457"}, "48111688": {"ViewCount": "101", "Body": "<p>Context:</p>\n<p>As an old C programmer (even K&amp;R C...) I had always believed that an array was nothing more than <em>contiguously allocated nonempty set of objects with a\nparticular member object type, called the element type</em> (from n1570 draft for C11 standard, 6.2.5 Types). For that reason I did not worry too much about pointer arithmetics.</p>\n<p>I now know that an array is an object type and that it can be only created <em>by a definition (6.1), by a new-expression (8.3.4), when implicitly changing the active member of a\nunion (12.3), or when a temporary object is created (7.4, 15.2)</em> (from n4659 draft for C++17).</p>\n<p>Problem:</p>\n<p>I have to use a C library in which some functions return pointers to arrays of C structs. So far so good, a C struct is a POD type, and proper padding and alignment is achieved by using the standard flags of the compiler. But as the size of the array is only known at runtime, even with the correct <code>extern \"C\"</code> declarations, my function is declared to return a pointer to the first element of the array - the actual size is returned by a different function of the API.</p>\n<p>Simplified example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nextern \"C\" {\n    struct Elt {\n        int ival;\n        //...\n    };\n\n    void *libinit();                 // initialize the library and get a handle\n    size_t getNElts(void *id);       // get the number of elements\n    struct Elt* getElts(void *id);   // get an access the the array of elements\n    void libend(void *id);           // releases library internal data\n}\n\nint main() {\n    void *libid = libinit();\n    Elt* elts = getElts(libid);\n    size_t nelts = getNElts(libid);\n    for(int i=0; i&lt;nelts; i++) {\n        std::cout &lt;&lt; elts[i].ival &lt;&lt; \" \";    // is elts[i] legal?\n    }\n    std::cout &lt;&lt; std::endl;\n    libend(libid);\n    return 0;\n}\n</code></pre>\n<p>Question:</p>\n<p>I know that the bloc of memory has probably been allocated through <code>malloc</code>, which could allow to use pointers on it and I assume that <code>getElts(libid)[0]</code> does not involve Undefined Behaviour. But is it legal to use pointer arithmetics over the C array, when it has never been declared as a C++ array: the API only guarantees that I have a <em>contiguously allocated set of objects of type Elt</em> and that <code>getElts</code> returns a pointer to the first element of that set.</p>\n<p>Because [expr.add] explicitely restrict pointer arithmetics inside an array:</p>\n<blockquote>\n<p id=\"so_48111688_48111688_0\">4 When an expression that has integral type is added to or subtracted from a pointer, the result has the type\n  of the pointer operand. <strong>If the expression P points to element x[i] of an array object x</strong> with n elements,\n  the expressions P + J and J + P (where J has the value j) point to the (possibly-hypothetical) element\n  x[i + j] <strong>if 0 &lt;= i + j &lt;=n</strong>; <strong>otherwise, the behavior is undefined</strong>... </p>\n</blockquote>\n<p>That used to be a common pratice...</p>\n<h3>EDIT</h3>\n<p>In order to make more clear my question, I know that <em>this</em> would be UB if done in C++</p>\n<p>libstub.c++</p>\n<pre><code>/* C++ simulation of a C implementation */\nextern \"C\" {\n    struct Elt {\n        int ival;\n        //...\n    };\n\n    void *libinit();                 // initialize the library and get a handle\n    size_t getNElts(void *id);       // get the number of elements\n    struct Elt* getElts(void *id);   // get an access the the array of elements\n    void libend(void *id);           // releases library internal data\n}\n\nsize_t getCurrentSize() {\n    return 1024;    // let us assume that the returned value is not a constexpr\n}\n\nvoid *libinit() {\n    size_t N = getCurrentSize();\n    unsigned char * storage = new unsigned char[(N + 1) * sizeof(Elt)];\n    // storage can provide storage for a size_t correct alignment\n    size_t *n = new(storage) size_t;  \n    *n = N;\n    for (size_t i=1; i&lt;=N; i++) {\n        // storage can provide storage for a size_t, correct alignment\n        Elt *elt = new(storage + (i+1) * sizeof(Elt)) Elt();\n        elt-&gt;ival = i;           // put values into elt...\n    }\n    return static_cast&lt;void *&gt;(storage);\n}\n\nvoid libend(void * id) {\n    unsigned char *storage = static_cast&lt;unsigned char *&gt;(id);  // ok, back cast is valid\n    delete[] storage;   // ok, was allocated by new[]\n}\n\nsize_t getNElts(void *id) {\n    size_t *n = reinterpret_cast&lt;size_t *&gt;(id);    // ok a size_t was created there\n    return *n;\n}\n\nElt *getElts(void *id) {\n    unsigned char *storage = static_cast&lt;unsigned char *&gt;(id); // ok, back cast\n    Elt* elt = reinterpret_cast&lt;Elt *&gt;(storage + sizeof(Elt)); // ok an Elt was created there\n    return elt;\n}\n</code></pre>\n<p>This is valid C++ code, and it fullfills the C API requirement. The problem is that <code>getElts</code> returns a pointer to a single element object which is not member of any array. So according to [expr.add] pointer arithmetics based on the return value of <code>getElts</code> invokes UB</p>\n", "AcceptedAnswerId": "48112158", "Title": "Can we safely call C API functions from C++ when arrays are involved?", "CreationDate": "2018-01-05T10:30:37.277", "LastActivityDate": "2018-01-06T12:01:20.333", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-01-05T13:50:00.147", "LastEditorUserId": "3545273", "Id": "48111688", "Score": "1", "OwnerUserId": "3545273", "Tags": "<c++><c><arrays><pointers><language-lawyer>", "AnswerCount": "3"}, "48112502": {"Id": "48112502", "PostTypeId": "2", "Body": "<p>Pointer arithmetic using the builtin <code>[]</code> operator on pointers is strictly equivalent to doing the pointer arithmetic by hand in the sense that the following is guaranteed:</p>\n<pre><code>int arr[2] = { 0, 1 };\nassert(arr[1] == *(arr + 1));\n</code></pre>\n<p>The two variants are guaranteed to have the same semantics. As far as your example is concerned, if you know for sure that your API returns a pointer to some contiguous memory, then your code is perfectly valid. This is assumption seems perfectly fine given the way the API seems to work. As a side note, I have never seen an allocator that did not allocate contiguous memory on a modern system, it just seems like a very silly thing to do to me and it does not seem to me like something that is doable given the way C and C++ work (at least not with language support w.r.t to field accesses), anyone correct me if I am wrong though.</p>\n", "LastActivityDate": "2018-01-05T11:17:16.807", "Score": "2", "CreationDate": "2018-01-05T11:17:16.807", "ParentId": "48111688", "CommentCount": "2", "OwnerUserId": "4959478"}});