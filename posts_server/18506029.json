post_cb({"18506994": {"Id": "18506994", "PostTypeId": "2", "Body": "<p>From the <em>C++11 Standard</em> (actually from Draft N3337), in section 1.3 Terms and definitions [intro.defs] (<strong>emphasis</strong> mine):</p>\n<blockquote>\n<p id=\"so_18506029_18506994_0\"><strong>undefined behavior</strong><br>\n  behavior for which this International Standard imposes <strong>no requirements</strong><br>\n  [ <em>Note:</em> Undefined behavior may be expected when this International Standard omits any explicit definition of\n  behavior or when a program uses an erroneous construct or erroneous data. Permissible undefined behavior\n  ranges from ignoring the situation completely with <strong>unpredictable results</strong>, to behaving during translation or\n  program execution in a documented manner characteristic of the environment (with or without the issuance of\n  a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).\n  Many erroneous program constructs do not engender undefined behavior; they are required to be diagnosed.\n  \u2014 <em>end note</em> ]</br></br></p>\n</blockquote>\n<p>From \"no requirements\" + \"unpredictable results\" we can conclude that (in theory) <em>anything could happen</em>.</p>\n<p>Now, no \"reasonable\" compiler would <em>purposely</em> emit code to erase the hard drive for, e.g., a division by 0, <em>but</em> it could happen if you mess with the file system or indeed, as you said, if you corrupt memory (<em>edit:</em> see <a href=\"https://stackoverflow.com/questions/18506029/can-undefined-behavior-erase-the-hard-drive/18506994#comment27210833_18506556\">MSalters' comment on their own answer</a>).</p>\n<p>The point here is: <em>always be careful to <strong>never ever ever</strong> invoke undefined behavior</em>. \"Here Be Dragons.\"</p>\n<p>(In practice it can be hard to be sure that your program is well-defined. There's some advice. Know you language well, and keep away from the dusty corners. If a piece of code seems suspect or too complex, try to rewrite it to make it simpler and clearer. Always compile with the highest level of warnings, and don't ignore them. There are also compiler flags like <code>-fcatch-undefined-behavior</code> and tools like <code>lint</code> that can help. And testing of course, but that's a bit late.)</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-08-29T09:24:19.410", "Score": "7", "CreationDate": "2013-08-29T09:24:19.410", "ParentId": "18506029", "CommentCount": "2", "OwnerUserId": "688659", "LastEditDate": "2017-05-23T12:34:21.327"}, "18506087": {"Id": "18506087", "PostTypeId": "2", "Body": "<p>A simple example would be that you happen to corrupt the block number you're writing to, or the file name you're about to delete.</p>\n", "LastActivityDate": "2013-08-29T08:41:39.103", "CommentCount": "0", "CreationDate": "2013-08-29T08:41:39.103", "ParentId": "18506029", "Score": "2", "OwnerUserId": "162532"}, "18506768": {"Id": "18506768", "PostTypeId": "2", "Body": "<p>In <code>Linux</code>, any operation is valid when you are a root user. Even destroying your root filesystem.\n<code>rm -rf /</code></p>\n<p>Every code segment(with bugs) are happily executed when you are the <code>root</code>. All <strong>UB</strong> are assumed to be intended with <code>sudo</code> permissions.</p>\n", "LastActivityDate": "2013-08-29T09:14:58.530", "CommentCount": "1", "CreationDate": "2013-08-29T09:14:58.530", "ParentId": "18506029", "Score": "1", "OwnerUserId": "1544153"}, "18506029": {"ViewCount": "2013", "Body": "<p>From \"Effective C++ 3rd edition by Scott Meyers\":</p>\n<blockquote>\n<p id=\"so_18506029_18506029_0\">To emphasize that the results of undefined behavior are not predictable and may be very unpleasant, experienced C++ programmers often say that programs with undefined behavior can erase your hard drive.</p>\n</blockquote>\n<p>Under what circumstances can this happen? </p>\n<p>For example, can accessing and writing to locations out of array range corrupt memory that doesn't belong to this C++ program or thread?</p>\n", "AcceptedAnswerId": "18506556", "Title": "Can undefined behavior erase the hard drive?", "CreationDate": "2013-08-29T08:38:40.187", "Id": "18506029", "CommentCount": "11", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2017-09-06T01:19:56.523", "Score": "21", "OwnerUserId": "1367392", "Tags": "<c++><memory><undefined-behavior>", "AnswerCount": "8"}, "18516302": {"Id": "18516302", "PostTypeId": "2", "Body": "<p>Yes.</p>\n<p>Consider an application that processes external input (for example a component of a web application) and that has a buffer overflow, which is a fairly common type of undefined behavior.</p>\n<p>An attacker notices this and deliberately crafts input that erases all the data. (Most attackers actually don't do that: what they want to do is to retrieve your data, or to plant content on your site. But occasionally some do want to erase your files.)</p>\n<p>The maximal extent of the damage depends on what security layers the attacker is able to bypass. If the server hasn't been configured securely, or if there are other vulnerabilities that the attacker is able to exploit, then the attacker may be able to gain administrator privileges on the machine or use it as a relay to attack other machines. All this from a single buffer overflow.</p>\n<p>The lesson to keep from this is that undefined behavior is not just about things that are likely to happen. Not only can things happen that you wouldn't expect (some compilers are very good at picking up weird optimizations that are only correct when a variable isn't modified twice between sequence points and do something very surprising otherwise), but things can happen that are mathematically extremely unlikely because someone deliberately went out of their way to make them happen.</p>\n", "LastActivityDate": "2013-08-29T16:28:28.080", "CommentCount": "0", "CreationDate": "2013-08-29T16:28:28.080", "ParentId": "18506029", "Score": "2", "OwnerUserId": "387076"}, "bq_ids": {"n4140": {"so_18506029_18506994_0": {"length": 56, "quality": 0.9032258064516129, "section_id": 5768}}, "n3337": {"so_18506029_18506994_0": {"length": 56, "quality": 0.9032258064516129, "section_id": 5541}}, "n4659": {"so_18506029_18506994_0": {"length": 56, "quality": 0.9032258064516129, "section_id": 7225}}}, "46065394": {"Id": "46065394", "PostTypeId": "2", "Body": "<p>[This answer comes four years late. Who will read it? We shall see.]</p>\n<p>Er, no offense, but several of the other answers are wrong or at any rate misleading, in my experience.</p>\n<p>The C++ standard does not constrain undefined behavior.  The operating system does however normally constrain it.  Reason: the behavior is undefined <em>with respect to C++.</em></p>\n<blockquote>\n<p id=\"so_18506029_46065394_0\">... always be careful to never ever ever invoke undefined behavior.</p>\n</blockquote>\n<p>Nonsense. Experience belies this suggestion. C++ programmers often inadvertently invoke undefined behavior during testing. Sometimes I do it on purpose, just to see what happens.</p>\n<p>Now, I realize that someone thinks that I am flaunting foolhardiness here, but really, your laptop is hardly more likely to catch on fire with undefined than defined behavior. Undefined behavior in C++ emits assembly code with <em>defined</em> behavior. Think about that. The assembly behavior remains defined. It's just that the C++ standard no longer understands the mechanics.</p>\n<p>There are times you want to provoke undefined behavior just to see what's going on on the stack.</p>\n<p>If you are in an environment in which it is possible to write a <em>defined</em> C++ program that catches your laptop on fire, then you will have to be careful in any case; but the main problem in that case is a lack of hardware- and/or kernel-based protection.</p>\n<p>In sum, don't let the C++ standard confuse you. It's just informing you what its own limits of competence are.</p>\n", "LastActivityDate": "2017-09-06T01:19:56.523", "CommentCount": "1", "CreationDate": "2017-09-06T01:19:56.523", "ParentId": "18506029", "Score": "0", "OwnerUserId": "1275653"}, "18506557": {"Id": "18506557", "PostTypeId": "2", "Body": "<p>A memory violation can theoretically result in your program executing the wrong code. If you're <em>very</em> unlucky it could be code which deletes stuff on your hard drive. I suspect it's unlikely to go that far though, unless you're handling low-level disk operations yourself.</p>\n<p>I think the point of the statement is that you need to take undefined behaviour extremely seriously, and do everything practical to guard against it (i.e. defensive programming). I've seen too many bad programmers naively relying on some undefined behaviour, assuming it will work the same all the time. In practice, it's not predictable, and sometimes the result can be catastrophic.</p>\n", "LastActivityDate": "2013-08-29T09:04:28.453", "CommentCount": "0", "CreationDate": "2013-08-29T09:04:28.453", "ParentId": "18506029", "Score": "6", "OwnerUserId": "2500951"}, "18506556": {"Id": "18506556", "PostTypeId": "2", "Body": "<p>Can it? Sure. Happened to me, in fact.</p>\n<p>I wrote code to delete a temporary directory. That involved creating a <code>recursive delete &lt;temp directory&gt;\\*.*</code> command. Due to a bug, the <code>&lt;temp directory&gt;</code> field wasn't always filled in. Our file system code happily executed the <code>recursive delete \\*.*</code> command.</p>\n<p>My colleagues noticed when the icons on their desktop suddenly disappeared. Took out two machines.</p>\n", "LastActivityDate": "2013-08-29T09:04:25.857", "CommentCount": "9", "CreationDate": "2013-08-29T09:04:25.857", "ParentId": "18506029", "Score": "24", "OwnerUserId": "15416"}, "18507632": {"Id": "18507632", "PostTypeId": "2", "Body": "<p>If you take into account that UB is available not only to user-mode code, but also the system programmer. In other words, if you are writing driver-code with UB (or other bugs!) in it, you could end up writing to to a piece of memory that is later written back as the \"root of the whole disk-data structure\". </p>\n<p>I have indeed had a bug in a driver which I worked on, that caused disk corruption, because the driver was using stale pointers (pointer use after free). If you were UNLUCKY, the unused memory happened to be a block owned by the filesystem, so it would write back to the disk some random garbage. Fortunately, it wasn't too difficult to determine what the problem was, and I only needed reformat the disk once on my test-system (when working on drivers, you typically use two computers, one to build the code, and one to test the code on - the test machine typically has a minimal install set, and often gets reformatted and reconfigured relatively often anyway). </p>\n<p>I don't think Scott's mention necessarily means this type of situation, but it's entirely possible that if you have wild-enough code, it can cause almost anything to happen. Including finding holes in the security system (cf. all the stack-smashing exploits that have been successful). You probably have to be VERY unlucky to achieve that, but people also win those mega-lotteries from time to time, so if you can achieve something that has one chance in several million once a week or once a month, then a computer that can perform operations many millions of times a second can achieve much less likely things... </p>\n", "LastActivityDate": "2013-08-29T09:51:18.403", "CommentCount": "0", "CreationDate": "2013-08-29T09:51:18.403", "ParentId": "18506029", "Score": "11", "OwnerUserId": "1919155"}});