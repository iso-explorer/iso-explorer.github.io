post_cb({"117820": {"CommentCount": "0", "CreationDate": "2008-09-22T21:40:23.940", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "LastEditorUserId": "63550", "LastActivityDate": "2014-01-22T21:33:40.233", "ParentId": "30373", "PostTypeId": "2", "OwnerDisplayName": "ilitirit", "LastEditDate": "2014-01-22T21:33:40.233", "Id": "117820", "Score": "1", "Body": "<p>Read the book <em><a href=\"http://rads.stackoverflow.com/amzn/click/0321125185\" rel=\"nofollow noreferrer\">C++ Gotchas: Avoiding Common Problems in Coding and Design</a></em>.</p>\n", "OwnerUserId": "9825"}, "293047": {"CommentCount": "6", "CreationDate": "2008-11-15T21:02:15.377", "CommunityOwnedDate": "2008-11-15T22:01:10.187", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-06T01:12:27.180", "ParentId": "30373", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastEditDate": "2017-05-23T11:54:56.497", "Id": "293047", "Score": "49", "Body": "<h2>Pitfalls in decreasing order of their importance</h2>\n<p>First of all, you should visit the award winning <a href=\"https://isocpp.org/faq\" rel=\"nofollow noreferrer\">C++ FAQ</a>. It has many good answers to pitfalls. If you have further questions, visit <code>##c++</code> on <code>irc.freenode.org</code> in <a href=\"http://en.wikipedia.org/wiki/Internet_Relay_Chat\" rel=\"nofollow noreferrer\">IRC</a>. We are glad to help you, if we can. Note all the following pitfalls are originally written. They are not just copied from random sources.</p>\n<hr>\n<blockquote>\n<p id=\"so_30373_293047_0\">delete<code>[]</code> on new, <code>delete</code> on <code>new[]</code></p>\n</blockquote>\n<p><strong>Solution</strong>: Doing the above yields to undefined behavior: Everything could happen. Understand your code and what it does, and always <code>delete[]</code> what you <code>new[]</code>, and <code>delete</code> what you <code>new</code>, then that won't happen.</p>\n<p><strong>Exception</strong>:</p>\n<pre><code>typedef T type[N]; T * pT = new type; delete[] pT;\n</code></pre>\n<p>You need to <code>delete[]</code> even though you <code>new</code>, since you new'ed an array. So if you are working with <code>typedef</code>, take special care.</p>\n<hr>\n<blockquote>\n<p id=\"so_30373_293047_1\">Calling a virtual function in a constructor or destructor</p>\n</blockquote>\n<p><strong>Solution</strong>: Calling a virtual function won't call the overriding functions in the derived classes. Calling a <em>pure virtual function</em> in a constructor or desctructor is undefined behavior.</p>\n<hr>\n<blockquote>\n<p id=\"so_30373_293047_2\">Calling <code>delete</code> or <code>delete[]</code> on an already deleted pointer</p>\n</blockquote>\n<p><strong>Solution</strong>: Assign 0 to every pointer you delete. Calling <code>delete</code> or <code>delete[]</code> on a null-pointer does nothing.</p>\n<hr>\n<blockquote>\n<p id=\"so_30373_293047_3\">Taking the sizeof of a pointer, when the number of elements of an 'array' is to be calculated.</p>\n</blockquote>\n<p><strong>Solution</strong>: Pass the number of elements alongside the pointer when you need to pass an array as a pointer into a function. Use the function proposed <a href=\"https://stackoverflow.com/questions/275994/whats-the-best-way-to-do-a-backwards-loop-in-ccc#276053\">here</a> if you take the sizeof of an array that is supposed to be really an array.</p>\n<hr>\n<blockquote>\n<p id=\"so_30373_293047_4\">Using an array as if it were a pointer. Thus, using <code>T **</code> for a two dimentional array.</p>\n</blockquote>\n<p><strong>Solution</strong>: See <a href=\"https://stackoverflow.com/questions/274865/pointer-question-in-c#274943\">here</a> for why they are different and how you handle them.</p>\n<hr>\n<blockquote>\n<p id=\"so_30373_293047_5\">Writing to a string literal: <code>char * c = \"hello\"; *c = 'B';</code></p>\n</blockquote>\n<p><strong>Solution</strong>: Allocate an array that is initialized from the data of the string literal, then you can write to it:</p>\n<pre><code>char c[] = \"hello\"; *c = 'B';\n</code></pre>\n<p>Writing to a string literal is undefined behavior. Anyway, the above conversion from a string literal to <code>char *</code> is deprecated. So compilers will probably warn if you increase the warning level.</p>\n<hr>\n<blockquote>\n<p id=\"so_30373_293047_6\">Creating resources, then forgetting to free them when something throws.</p>\n</blockquote>\n<p><strong>Solution</strong>: Use smart pointers like <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr\" rel=\"nofollow noreferrer\"><code>std::unique_ptr</code></a> or <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\" rel=\"nofollow noreferrer\"><code>std::shared_ptr</code></a> as pointed out by other answers.</p>\n<hr>\n<blockquote>\n<p id=\"so_30373_293047_7\">Modifying an object twice like in this example: <code>i = ++i;</code></p>\n</blockquote>\n<p><strong>Solution</strong>: The above was supposed to assign to <code>i</code> the value of <code>i+1</code>. But what it does is not defined. Instead of incrementing <code>i</code> and assigning the result, it changes <code>i</code> on the right side as well. Changing an object between two sequence points is undefined behavior. Sequence points include <code>||</code>, <code>&amp;&amp;</code>, <code>comma-operator</code>, <code>semicolon</code> and <code>entering a function</code> (non exhaustive list!). Change the code to the following to make it behave correctly: <code>i = i + 1;</code></p>\n<hr>\n<h2>Misc Issues</h2>\n<blockquote>\n<p id=\"so_30373_293047_8\">Forgetting to flush streams before calling a blocking function like <code>sleep</code>.</p>\n</blockquote>\n<p><strong>Solution</strong>: Flush the stream by streaming either <code>std::endl</code> instead of <code>\\n</code> or by calling <code>stream.flush();</code>.</p>\n<hr>\n<blockquote>\n<p id=\"so_30373_293047_9\">Declaring a function instead of a variable.</p>\n</blockquote>\n<p><strong>Solution</strong>: The issue arises because the compiler interprets for example</p>\n<pre><code>Type t(other_type(value));\n</code></pre>\n<p>as a function declaration of a function <code>t</code> returning <code>Type</code> and having a parameter of type <code>other_type</code> which is called <code>value</code>. You solve it by putting parentheses around the first argument. Now you get a variable <code>t</code> of type <code>Type</code>:</p>\n<pre><code>Type t((other_type(value)));\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_30373_293047_10\">Calling the function of a free object that is only declared in the current translation unit (<code>.cpp</code> file).</p>\n</blockquote>\n<p><strong>Solution</strong>: The standard doesn't define the order of creation of free objects (at namespace scope) defined across different translation units. Calling a member function on an object not yet constructed is undefined behavior. You can define the following function in the object's translation unit instead and call it from other ones:</p>\n<pre><code>House &amp; getTheHouse() { static House h; return h; }\n</code></pre>\n<p>That would create the object on demand and leave you with a fully constructed object at the time you call functions on it.</p>\n<hr>\n<blockquote>\n<p id=\"so_30373_293047_11\">Defining a template in a <code>.cpp</code> file, while it's used in a different <code>.cpp</code> file.</p>\n</blockquote>\n<p><strong>Solution</strong>: Almost always you will get errors like <code>undefined reference to ...</code>. Put all the template definitions in a header, so that when the compiler is using them, it can already produce the code needed.</p>\n<hr>\n<blockquote>\n<p id=\"so_30373_293047_12\"><code>static_cast&lt;Derived*&gt;(base);</code> if base is a pointer to a virtual base class of <code>Derived</code>.</p>\n</blockquote>\n<p><strong>Solution</strong>: A virtual base class is a base which occurs only once, even if it is inherited more than once by different classes indirectly in an inheritance tree. Doing the above is not allowed by the Standard. Use dynamic_cast to do that, and make sure your base class is polymorphic.</p>\n<hr>\n<blockquote>\n<p id=\"so_30373_293047_13\"><code>dynamic_cast&lt;Derived*&gt;(ptr_to_base);</code> if base is non-polymorphic</p>\n</blockquote>\n<p><strong>Solution</strong>: The standard doesn't allow a downcast of a pointer or reference when the object passed is not polymorphic. It or one of its base classes has to have a virtual function.</p>\n<hr>\n<blockquote>\n<p id=\"so_30373_293047_14\">Making your function accept <code>T const **</code></p>\n</blockquote>\n<p><strong>Solution</strong>: You might think that's safer than using <code>T **</code>, but actually it will cause headache to people that want to pass <code>T**</code>: The standard doesn't allow it. It gives a neat example of why it is disallowed:</p>\n<pre><code>int main() {\n    char const c = \u2019c\u2019;\n    char* pc;\n    char const** pcc = &amp;pc; //1: not allowed\n    *pcc = &amp;c;\n    *pc = \u2019C\u2019; //2: modifies a const object\n}\n</code></pre>\n<p>Always accept <code>T const* const*;</code> instead.</p>\n<h2></h2>\n<p>Another (closed) pitfalls thread about C++, so people looking for them will find them, is Stack Overflow question <em><a href=\"https://stackoverflow.com/questions/280531\">C++ pitfalls</a></em>.</p>\n</hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr>", "OwnerUserId": "34509", "OwnerDisplayName": "litb"}, "30384": {"CommentCount": "0", "CreationDate": "2008-08-27T15:07:51.783", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "LastEditorUserId": "63550", "LastActivityDate": "2014-01-22T21:26:28.150", "ParentId": "30373", "PostTypeId": "2", "OwnerDisplayName": "Matt", "LastEditDate": "2014-01-22T21:26:28.150", "Id": "30384", "Score": "4", "Body": "<p>The book <em><a href=\"http://www.semantics.org/cpp_gotchas/\" rel=\"nofollow noreferrer\">C++ Gotchas</a></em> may prove useful.</p>\n", "OwnerUserId": "2590"}, "117801": {"CommentCount": "0", "CreationDate": "2008-09-22T21:37:03.213", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "LastEditorUserId": "63550", "LastActivityDate": "2014-01-22T21:33:07.260", "ParentId": "30373", "PostTypeId": "2", "OwnerDisplayName": "Eric P. Mangold", "LastEditDate": "2014-01-22T21:33:07.260", "Id": "117801", "Score": "3", "Body": "<ol>\n<li>Not reading the <a href=\"http://www.parashift.com/c++-faq-lite/\" rel=\"nofollow noreferrer\">C++ FAQ Lite</a>. It explains many bad (and good!) practices.</li>\n<li>Not using <a href=\"http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29\" rel=\"nofollow noreferrer\">Boost</a>. You'll save yourself a lot of frustration by taking advantage of Boost where possible.</li>\n</ol>\n", "OwnerUserId": "14739"}, "37369": {"CommentCount": "0", "CreationDate": "2008-09-01T02:03:56.793", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "LastEditorUserId": "63550", "LastActivityDate": "2014-01-22T21:30:22.830", "ParentId": "30373", "PostTypeId": "2", "OwnerDisplayName": "cdv", "LastEditDate": "2014-01-22T21:30:22.830", "Id": "37369", "Score": "3", "Body": "<p>PRQA have <a href=\"http://www.codingstandard.com/\" rel=\"nofollow noreferrer\">an excellent and free C++ coding standard</a> based on books from Scott Meyers, Bjarne Stroustrop and Herb Sutter. It brings all this information together in one document.</p>\n", "OwnerUserId": "3836"}, "281487": {"ParentId": "30373", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2008-11-11T17:00:34.810", "OwnerUserId": "5987", "Id": "281487", "CommunityOwnedDate": "2008-11-11T17:00:34.810", "OwnerDisplayName": "Mark Ransom", "Score": "0", "Body": "<p>Always check a pointer before you dereference it.  In C, you could usually count on a crash at the point where you dereference a bad pointer; in C++, you can create an invalid reference which will crash at a spot far removed from the source of the problem.</p>\n<pre><code>class SomeClass\n{\n    ...\n    void DoSomething()\n    {\n        ++counter;    // crash here!\n    }\n    int counter;\n};\n\nvoid Foo(SomeClass &amp; ref)\n{\n    ...\n    ref.DoSomething();    // if DoSomething is virtual, you might crash here\n    ...\n}\n\nvoid Bar(SomeClass * ptr)\n{\n    Foo(*ptr);    // if ptr is NULL, you have created an invalid reference\n                  // which probably WILL NOT crash here\n}\n</code></pre>\n", "LastActivityDate": "2008-11-11T17:00:34.810"}, "282056": {"CommentCount": "0", "CreationDate": "2008-11-11T20:33:14.677", "CommunityOwnedDate": "2008-11-11T20:33:14.677", "LastEditorUserId": "63550", "LastActivityDate": "2014-01-22T21:37:59.650", "ParentId": "30373", "PostTypeId": "2", "OwnerDisplayName": "zach", "LastEditDate": "2014-01-22T21:37:59.650", "Id": "282056", "Score": "1", "Body": "<ul>\n<li><p>Blizpasta. That's a huge one I see a lot...</p></li>\n<li><p>Uninitialized variables are a huge mistake that students of mine make. A lot of Java folks forget that just saying \"int counter\" doesn't set counter to 0. Since you have to define variables in the h file (and initialize them in the constructor/setup of an object), it's easy to forget.</p></li>\n<li><p>Off-by-one errors on <code>for</code> loops / array access.</p></li>\n<li><p>Not properly cleaning object code when voodoo starts.</p></li>\n</ul>\n"}, "281451": {"CommentCount": "1", "CreationDate": "2008-11-11T16:46:27.647", "CommunityOwnedDate": "2008-11-11T16:46:27.647", "LastEditorUserId": "63550", "LastActivityDate": "2014-01-22T21:35:20.210", "ParentId": "30373", "PostTypeId": "2", "OwnerDisplayName": "Martin York", "LastEditDate": "2014-01-22T21:35:20.210", "Id": "281451", "Score": "6", "Body": "<p>Using C++ like C. Having a create-and-release cycle in the code.</p>\n<p>In C++, this is not exception safe and thus the release may not be executed. In C++, we use <a href=\"https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\" rel=\"nofollow noreferrer\">RAII</a> to solve this problem.</p>\n<p>All resources that have a manual create and release should be wrapped in an object so these actions are done in the constructor/destructor.</p>\n<pre><code>// C Code\nvoid myFunc()\n{\n    Plop*   plop = createMyPlopResource();\n\n    // Use the plop\n\n    releaseMyPlopResource(plop);\n}\n</code></pre>\n<p>In C++, this should be wrapped in an object:</p>\n<pre><code>// C++\nclass PlopResource\n{\n    public:\n        PlopResource()\n        {\n            mPlop=createMyPlopResource();\n            // handle exceptions and errors.\n        }\n        ~PlopResource()\n        {\n             releaseMyPlopResource(mPlop);\n        }\n    private:\n        Plop*  mPlop;\n };\n\nvoid myFunc()\n{\n    PlopResource  plop;\n\n    // Use the plop\n    // Exception safe release on exit.\n}\n</code></pre>\n", "OwnerUserId": "14065"}, "30470": {"CommentCount": "0", "CreationDate": "2008-08-27T15:37:14.037", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "LastEditorUserId": "63550", "LastActivityDate": "2014-01-22T21:29:13.713", "ParentId": "30373", "PostTypeId": "2", "LastEditorDisplayName": "spider57", "LastEditDate": "2014-01-22T21:29:13.713", "Id": "30470", "Score": "6", "Body": "<p>I've already mentioned it a few times, but Scott Meyers' books <a href=\"http://rads.stackoverflow.com/amzn/click/0321334876\" rel=\"nofollow noreferrer\">Effective C++</a> and <a href=\"http://rads.stackoverflow.com/amzn/click/0201749629\" rel=\"nofollow noreferrer\">Effective STL</a> are really worth their weight in gold for helping with C++.</p>\n<p>Come to think of it, Steven Dewhurst's <a href=\"http://rads.stackoverflow.com/amzn/click/0321125185\" rel=\"nofollow noreferrer\">C++ Gotchas</a> is also an excellent \"from the trenches\" resource. His item on rolling your own exceptions and how they should be constructed really helped me in one project.</p>\n", "OwnerUserId": "2974", "OwnerDisplayName": "robwells57"}, "3986213": {"ParentId": "30373", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2010-10-21T09:52:38.663", "OwnerUserId": "49246", "CommunityOwnedDate": "2010-10-21T09:52:38.663", "Id": "3986213", "Score": "0", "Body": "<p>Forgetting an <code>&amp;</code> and thereby creating a copy instead of a reference.</p>\n<p>This happened to me twice in different ways:</p>\n<ul>\n<li><p>One instance was in an argument list, which caused a large object to be put on the stack with the result of a stack overflow and crash of the embedded system.</p></li>\n<li><p>I forgot the <code>&amp;</code> on an instance variable, with the effect that the object was copied. After registering as a listener to the copy I wondered why I never got the callbacks from the original object.</p></li>\n</ul>\n<p>Both where rather hard to spot, because the difference is small and hard to see, and otherwise objects and references are used syntactically in the same way.</p>\n", "LastActivityDate": "2010-10-21T09:52:38.663"}, "71386": {"ParentId": "30373", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2008-09-16T11:29:51.593", "OwnerUserId": "11521", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "Id": "71386", "Score": "12", "Body": "<p>Brian has a great list: I'd add \"Always mark single argument constructors explicit (except in those rare cases you want automatic casting).\"</p>\n", "LastActivityDate": "2008-09-16T11:29:51.593"}, "117788": {"CommentCount": "1", "CreationDate": "2008-09-22T21:34:24.890", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "LastEditorUserId": "63550", "LastActivityDate": "2014-01-22T21:32:29.257", "ParentId": "30373", "PostTypeId": "2", "OwnerDisplayName": "epatel", "LastEditDate": "2014-01-22T21:32:29.257", "Id": "117788", "Score": "2", "Body": "<p>Avoid <a href=\"http://www.idinews.com/quasiClass.pdf\" rel=\"nofollow noreferrer\">pseudo classes and quasi classes</a>... Overdesign basically.</p>\n", "OwnerUserId": "842"}, "34064": {"ParentId": "30373", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2008-08-29T06:39:53.970", "OwnerUserId": "3561", "Id": "34064", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "OwnerDisplayName": "Tyler", "Score": "6", "Body": "<p>Two gotchas that I wish I hadn't learned the hard way:</p>\n<p>(1) A lot of output (such as printf) is buffered by default.  If you're debugging crashing code, and you're using buffered debug statements, the last output you see may <em>not</em> really be the last print statement encountered in the code.  The solution is to flush the buffer after each debug print (or turn off the buffering altogether).</p>\n<p>(2) Be careful with initializations - (a) avoid class instances as globals / statics; and (b) try to initialize all your member variables to some safe value in a ctor, even if it's a trivial value such as NULL for pointers.</p>\n<p>Reasoning: the ordering of global object initialization is not guaranteed (globals includes static variables), so you may end up with code that seems to fail nondeterministically since it depends on object X being initialized before object Y.  If you don't explicitly initialize a primitive-type variable, such as a member bool or enum of a class, you'll end up with different values in surprising situations -- again, the behavior can seem very nondeterministic.</p>\n", "LastActivityDate": "2008-08-29T06:39:53.970"}, "117741": {"ParentId": "30373", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2008-09-22T21:25:16.580", "OwnerUserId": "20487", "Id": "117741", "CommunityOwnedDate": "2008-09-22T21:25:16.580", "OwnerDisplayName": "Avdi", "Score": "8", "Body": "<p>Not really a specific tip, but a general guideline: check your sources.  C++ is an old language, and it has changed a lot over the years.  Best practices have changed with it, but unfortunately there's still a lot of old information out there.  There have been some very good book recommendations on here - I can second buying every one of Scott Meyers C++ books.  Become familiar with Boost and with the coding styles used in Boost - the people involved with that project are on the cutting edge of C++ design.</p>\n<p>Do not reinvent the wheel.  Become familiar with the STL and Boost, and use their facilities whenever possible rolling your own.  In particular, use STL strings and collections unless you have a very, very good reason not to.  Get to know auto_ptr and the Boost smart pointers library very well, understand under which circumstances each type of smart pointer is intended to be used, and then use smart pointers everywhere you might otherwise have used raw pointers.  Your code will be just as efficient and a lot less prone to memory leaks.</p>\n<p>Use static_cast, dynamic_cast, const_cast, and reinterpret_cast instead of C-style casts.  Unlike C-style casts they will let you know if you are really asking for a different type of cast than you think you are asking for.  And they stand out viisually, alerting the reader that a cast is taking place.</p>\n", "LastActivityDate": "2008-09-22T21:25:16.580"}, "30426": {"ParentId": "30373", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2008-08-27T15:21:23.903", "OwnerUserId": "1968", "Id": "30426", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "OwnerDisplayName": "Konrad Rudolph", "Score": "3", "Body": "<p>The most important pitfalls for beginning developers is to avoid confusion between C and C++. C++ should never be treated as a mere better C or C with classes because this prunes its power and can make it even dangerous (especially when using memory as in C).</p>\n", "LastActivityDate": "2008-08-27T15:21:23.903"}, "281562": {"CommentCount": "3", "CreationDate": "2008-11-11T17:25:50.703", "CommunityOwnedDate": "2008-11-11T17:25:50.703", "LastEditorUserId": "63550", "LastActivityDate": "2014-01-22T21:36:05.467", "ParentId": "30373", "PostTypeId": "2", "OwnerDisplayName": "blizpasta", "LastEditDate": "2014-01-22T21:36:05.467", "Id": "281562", "Score": "0", "Body": "<p>Intention is <code>(x == 10)</code>:</p>\n<pre><code>if (x = 10) {\n    //Do something\n}\n</code></pre>\n<p>I thought I would never make this mistake myself, but I actually did it recently.</p>\n", "OwnerUserId": "20646"}, "30420": {"CommentCount": "5", "CreationDate": "2008-08-27T15:17:15.537", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "LastEditorUserId": "63550", "LastActivityDate": "2014-01-22T21:25:48.570", "ParentId": "30373", "PostTypeId": "2", "OwnerDisplayName": "Brian", "LastEditDate": "2014-01-22T21:25:48.570", "Id": "30420", "Score": "74", "Body": "<p>A short list might be:</p>\n<ul>\n<li>Avoid memory leaks through use shared pointers to manage memory allocation and cleanup</li>\n<li>Use the <a href=\"https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\" rel=\"nofollow noreferrer\">Resource Acquisition Is Initialization</a> (RAII) idiom to manage resource cleanup - especially in the presence of exceptions</li>\n<li>Avoid calling virtual functions in constructors</li>\n<li>Employ minimalist coding techniques where possible - for example, declaring variables only when needed, scoping variables, and early-out design where possible. </li>\n<li>Truly understand the exception handling in your code - both with regard to exceptions you throw, as well as ones thrown by classes you may be using indirectly. This is especially important in the presence of templates.</li>\n</ul>\n<p>RAII, shared pointers and minimalist coding are of course not specific to C++, but they help avoid problems that do frequently crop up when developing in the language. </p>\n<p>Some excellent books on this subject are:</p>\n<ul>\n<li>Effective C++ - Scott Meyers</li>\n<li>More Effective C++ - Scott Meyers</li>\n<li>C++ Coding Standards - Sutter &amp; Alexandrescu</li>\n<li>C++ FAQs - Cline</li>\n</ul>\n<p>Reading these books has helped me more than anything else to avoid the kind of pitfalls you are asking about.</p>\n", "OwnerUserId": "3114"}, "282070": {"CommentCount": "1", "CreationDate": "2008-11-11T20:40:00.170", "CommunityOwnedDate": "2008-11-11T20:40:00.170", "LastEditorUserId": "63550", "LastActivityDate": "2014-01-22T21:39:41.423", "ParentId": "30373", "PostTypeId": "2", "LastEditorDisplayName": "Konrad Rudolph", "LastEditDate": "2014-01-22T21:39:41.423", "Id": "282070", "Score": "1", "Body": "<blockquote id=\"so_30373_282070_0\">\n<ul>\n<li><code>static_cast</code> downcast on a virtual base class</li>\n</ul>\n</blockquote>\n<p>Not really... Now about my misconception: I thought that <code>A</code> in the following was a virtual base class when in fact it's not; it's, according to 10.3.1, a <em>polymorphic class</em>. Using <code>static_cast</code> here seems to be fine.</p>\n<pre><code>struct B { virtual ~B() {} };\n\nstruct D : B { };\n</code></pre>\n<p>In summary, yes, this is a dangerous pitfall.</p>\n", "OwnerUserId": "1968", "OwnerDisplayName": "Konrad Rudolph"}, "281593": {"ParentId": "30373", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2008-11-11T17:38:46.153", "OwnerUserId": "14148", "Id": "281593", "CommunityOwnedDate": "2008-11-11T17:38:46.153", "OwnerDisplayName": "David Thornley", "Score": "1", "Body": "<p>Keep the name spaces straight (including struct, class, namespace, and using).  That's my number-one frustration when the program just doesn't compile.</p>\n", "LastActivityDate": "2008-11-11T17:38:46.153"}, "282921": {"ParentId": "30373", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2008-11-12T03:22:42.340", "OwnerUserId": "36786", "Id": "282921", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "OwnerDisplayName": "gsarkis", "Score": "-1", "Body": "<pre><code>#include &lt;boost/shared_ptr.hpp&gt;\nclass A {\npublic:\n  void nuke() {\n     boost::shared_ptr&lt;A&gt; (this);\n  }\n};\n\nint main(int argc, char** argv) {\n  A a;\n  a.nuke();\n  return(0);\n}\n</code></pre>\n", "LastActivityDate": "2008-11-12T03:22:42.340"}, "bq_ids": {"n4140": {"so_30373_293047_12": {"section_id": 43, "quality": 0.5714285714285714, "length": 4}, "so_30373_293047_0": {"section_id": 6089, "quality": 1.0, "length": 4}, "so_30373_293047_1": {"section_id": 447, "quality": 0.8, "length": 4}}, "n3337": {"so_30373_293047_12": {"section_id": 40, "quality": 0.5714285714285714, "length": 4}, "so_30373_293047_0": {"section_id": 5857, "quality": 1.0, "length": 4}, "so_30373_293047_1": {"section_id": 438, "quality": 0.8, "length": 4}}, "n4659": {"so_30373_293047_12": {"section_id": 43, "quality": 0.5714285714285714, "length": 4}, "so_30373_293047_0": {"section_id": 7585, "quality": 1.0, "length": 4}, "so_30373_293047_1": {"section_id": 469, "quality": 0.8, "length": 4}}}, "285100": {"CommentCount": "0", "CreationDate": "2008-11-12T19:47:01.293", "CommunityOwnedDate": "2008-11-12T19:47:01.293", "LastEditorUserId": "63550", "LastActivityDate": "2014-01-22T21:40:20.833", "ParentId": "30373", "PostTypeId": "2", "OwnerDisplayName": "xtofl", "LastEditDate": "2014-01-22T21:40:20.833", "Id": "285100", "Score": "2", "Body": "<p>Forgetting to define a base class destructor virtual. This means that calling <code>delete</code> on a Base* won't end up destructing the derived part.</p>\n", "OwnerUserId": "6610"}, "48676": {"CommentCount": "2", "CreationDate": "2008-09-07T18:48:53.720", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "LastEditorUserId": "-1", "LastActivityDate": "2014-01-22T21:31:21.403", "ParentId": "30373", "PostTypeId": "2", "LastEditorDisplayName": "Motti", "LastEditDate": "2017-05-23T12:10:36.177", "Id": "48676", "Score": "4", "Body": "<p>Here are a few pits I had the misfortune to fall into. All these have good reasons which I only understood after being bitten by behaviour that surprised me. </p>\n<ul>\n<li><p><code>virtual</code> functions in constructors <a href=\"https://stackoverflow.com/questions/36832\" title=\"Virtual functions in constructors, why do languages differ?\">aren't</a>.</p></li>\n<li><p>Don't violate the <a href=\"http://en.wikipedia.org/wiki/One_Definition_Rule\" rel=\"nofollow noreferrer\">ODR (One Definition Rule)</a>, that's what anonymous namespaces are for (among other things).</p></li>\n<li><p>Order of initialization of members depends on the order in which they are declared.</p>\n<pre><code>class bar {\n    vector&lt;int&gt; vec_;\n    unsigned size_; // Note size_ declared *after* vec_\npublic:\n    bar(unsigned size)\n        : size_(size)\n        , vec_(size_) // size_ is uninitialized\n        {}\n};\n</code></pre></li>\n<li><p>Default values and <code>virtual</code> have different semantics.</p>\n<pre><code>class base {\npublic:\n    virtual foo(int i = 42) { cout &lt;&lt; \"base \" &lt;&lt; i; }\n};\n\nclass derived : public base {\npublic:\n    virtual foo(int i = 12) { cout &lt;&lt; \"derived \"&lt;&lt; i; }\n};\n\nderived d;\nbase&amp; b = d;\nb.foo(); // Outputs `derived 42`\n</code></pre></li>\n</ul>\n", "OwnerUserId": "3848", "OwnerDisplayName": "Motti"}, "281609": {"ParentId": "30373", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2008-11-11T17:43:24.240", "OwnerUserId": "14148", "Id": "281609", "CommunityOwnedDate": "2008-11-11T17:43:24.240", "OwnerDisplayName": "David Thornley", "Score": "1", "Body": "<p>To mess up, use straight pointers a lot.  Instead, use RAII for almost anything, making sure of course that you use the right smart pointers.  If you write \"delete\" anywhere outside a handle or pointer-type class, you're very likely doing it wrong.</p>\n", "LastActivityDate": "2008-11-11T17:43:24.240"}, "30373": {"CommentCount": "4", "AcceptedAnswerId": "30420", "PostTypeId": "1", "ClosedDate": "2011-03-29T03:44:56.750", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "LastEditorUserId": "63550", "LastActivityDate": "2015-07-06T01:12:27.180", "AnswerCount": "29", "Body": "<p>I remember first learning about vectors in the STL and after some time, I wanted to use a vector of bools for one of my projects. After seeing some strange behavior and doing some research, I learned that <a href=\"http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=98\" rel=\"noreferrer\">a vector of bools is not really a vector of bools</a>.</p>\n<p>Are there any other common pitfalls to avoid in C++?</p>\n", "LastEditDate": "2014-01-22T21:14:04.110", "ViewCount": "14200", "FavoriteCount": "87", "Title": "What C++ pitfalls should I avoid?", "Id": "30373", "Score": "69", "CreationDate": "2008-08-27T15:03:00.173", "Tags": "<c++><stl>", "OwnerUserId": "2328", "OwnerDisplayName": "Craig H"}, "754364": {"CommentCount": "0", "CreationDate": "2009-04-16T00:46:17.817", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "LastEditorUserId": "63550", "LastActivityDate": "2014-01-22T21:48:38.710", "ParentId": "30373", "PostTypeId": "2", "LastEditDate": "2014-01-22T21:48:38.710", "Id": "754364", "Score": "0", "Body": "<p>I spent many years doing C++ development. I wrote a <a href=\"http://btstout.blogspot.com/2005_09_01_archive.html\" rel=\"nofollow noreferrer\">quick summary</a> of problems I had with it years ago. Standards-compliant compilers are not really a problem anymore, but I suspect the other pitfalls outlined are still valid.</p>\n", "OwnerUserId": "59768"}, "30391": {"CommentCount": "0", "CreationDate": "2008-08-27T15:09:09.987", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "LastEditorUserId": "63550", "LastActivityDate": "2014-01-22T21:27:20.563", "ParentId": "30373", "PostTypeId": "2", "OwnerDisplayName": "sparkes", "LastEditDate": "2014-01-22T21:27:20.563", "Id": "30391", "Score": "7", "Body": "<p>The web page <em><a href=\"http://developer.kde.org/~wheeler/cpp-pitfalls.html\" rel=\"nofollow noreferrer\">C++ Pitfalls</a></em> by Scott Wheeler covers some of the main C++ pitfalls.</p>\n", "OwnerUserId": "269"}, "293080": {"CommentCount": "0", "CreationDate": "2008-11-15T21:34:30.427", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "LastEditorUserId": "63550", "LastActivityDate": "2014-01-22T21:48:15.757", "ParentId": "30373", "PostTypeId": "2", "OwnerDisplayName": "lurks", "LastEditDate": "2014-01-22T21:48:15.757", "Id": "293080", "Score": "0", "Body": "<p>The essay/article <em><a href=\"http://www.goingware.com/tips/parameters/\" rel=\"nofollow noreferrer\">Pointers, references and Values</a></em> is very useful. It talks avoid avoiding pitfalls and good practices. You can browse the whole site too, which contains programming tips, mainly for C++.</p>\n", "OwnerUserId": "1876"}, "30412": {"ParentId": "30373", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2008-08-27T15:15:18.460", "OwnerUserId": "2284", "Id": "30412", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "OwnerDisplayName": "17 of 26", "Score": "16", "Body": "<p>Some must have C++ books that will help you avoid common C++ pitfalls:</p>\n<p><a href=\"http://rads.stackoverflow.com/amzn/click/0321334876\" rel=\"nofollow noreferrer\">Effective C++</a><br>\n<a href=\"http://rads.stackoverflow.com/amzn/click/020163371X\" rel=\"nofollow noreferrer\">More Effective C++</a><br>\n<a href=\"http://rads.stackoverflow.com/amzn/click/0201749629\" rel=\"nofollow noreferrer\">Effective STL</a></br></br></p>\n<p>The Effective STL book explains the vector of bools issue :)</p>\n", "LastActivityDate": "2008-08-27T15:15:18.460"}, "30449": {"ParentId": "30373", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2008-08-27T15:29:04.540", "OwnerUserId": "3261", "Id": "30449", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "OwnerDisplayName": "Paul Whitehurst", "Score": "3", "Body": "<p>Check out <a href=\"http://boost.org\" rel=\"nofollow noreferrer\">boost.org</a>.  It provides a lot of additional functionality, especially their smart pointer implementations.</p>\n", "LastActivityDate": "2008-08-27T15:29:04.540"}, "48708": {"ParentId": "30373", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2008-09-07T19:34:10.227", "OwnerUserId": "5087", "Id": "48708", "CommunityOwnedDate": "2009-12-29T04:12:17.417", "OwnerDisplayName": " Registered User", "Score": "2", "Body": "<p>Be careful when using smart pointers and container classes.</p>\n", "LastActivityDate": "2008-09-07T19:34:10.227"}});