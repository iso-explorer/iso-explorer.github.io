post_cb({"24300071": {"ParentId": "24299963", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The error is because when <code>int b[A::a];</code> is being processed, <code>A</code> does not yet have a symbol <code>a</code>. At that point of compilation, <code>A</code> is still incomplete because we have not reached the closing <code>}</code> of the class definition yet. The compiler doesn't \"look ahead\" to see if future lines of source code contain a definition of <code>a</code>.</p>\n<p>You can see this by reversing the order of the lines:</p>\n<pre><code>class A\n{\n    static const int a = 5;\n    int b[A::a]; // OK\n};\n</code></pre>\n<p>The function definition does not have the same problem because inline function bodies are not compiled until after compilation of the class definition. (Sorry, I don't have standard references handy for this)</p>\n", "OwnerUserId": "1505939", "LastEditorUserId": "1782465", "LastEditDate": "2014-06-19T06:51:25.013", "Id": "24300071", "Score": "4", "CreationDate": "2014-06-19T06:27:34.517", "LastActivityDate": "2014-06-19T06:51:25.013"}, "24303296": {"ParentId": "24299963", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The member declaration <code>int b[A::a];</code> is not in the <em>potential scope</em> of <code>A::a</code> (3.3.7p1), while the body of <code>void A::foo()</code> is in the potential scope (3.3.7p1b1):</p>\n<blockquote>\n<p id=\"so_24299963_24303296_0\">1) The potential scope of a name declared in a class consists not only of the declarative region following the name's point of declaration, but also of all function bodies, <em>brace-or-equal-initializers</em> of non-static data members, and default arguments in that class (including such things in nested classes).</p>\n</blockquote>\n<p>3.4.3.1p1 references the potential scope rule in a note:</p>\n<blockquote>\n<p id=\"so_24299963_24303296_1\">[...] [ <em>Note:</em> A class member can be referred to using a qualified-id at any point in its potential scope (3.3.7). <em>\u2014 end note</em> ] [...]</p>\n</blockquote>\n<p>Of course, notes are non-normative, so the conclusion must be that the potential scope rule is implied by other material in the standard.  I believe this other material is specifically 3.3.2p5:</p>\n<blockquote>\n<p id=\"so_24299963_24303296_2\">After the point of declaration of a class member, the member name can be looked up in the scope of its class. [...]</p>\n</blockquote>\n<p>By implication, prior to the point of declaration of that class member, that member name <em>cannot</em> be looked up in the scope of that class.</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2014-06-19T10:31:48.520", "Id": "24303296", "Score": "3", "CreationDate": "2014-06-19T09:31:06.323", "LastActivityDate": "2014-06-19T10:31:48.520"}, "bq_ids": {"n4140": {"so_24299963_24303296_1": {"section_id": 5955, "quality": 0.7142857142857143, "length": 10}, "so_24299963_24299963_4": {"section_id": 6992, "quality": 1.0, "length": 15}, "so_24299963_24299963_1": {"section_id": 6990, "quality": 0.9090909090909091, "length": 10}, "so_24299963_24303296_2": {"section_id": 7054, "quality": 1.0, "length": 12}, "so_24299963_24299963_0": {"section_id": 7113, "quality": 0.9166666666666666, "length": 11}, "so_24299963_24303296_0": {"section_id": 7070, "quality": 0.9, "length": 27}}, "n3337": {"so_24299963_24303296_1": {"section_id": 5724, "quality": 0.7142857142857143, "length": 10}, "so_24299963_24299963_4": {"section_id": 6738, "quality": 1.0, "length": 15}, "so_24299963_24299963_1": {"section_id": 6736, "quality": 0.9090909090909091, "length": 10}, "so_24299963_24303296_2": {"section_id": 6798, "quality": 1.0, "length": 12}, "so_24299963_24299963_0": {"section_id": 6857, "quality": 0.9166666666666666, "length": 11}, "so_24299963_24303296_0": {"section_id": 6814, "quality": 0.9666666666666667, "length": 29}}, "n4659": {"so_24299963_24303296_1": {"section_id": 7443, "quality": 0.7142857142857143, "length": 10}, "so_24299963_24299963_1": {"section_id": 8488, "quality": 0.9090909090909091, "length": 10}, "so_24299963_24299963_4": {"section_id": 8490, "quality": 1.0, "length": 15}, "so_24299963_24303296_2": {"section_id": 8551, "quality": 1.0, "length": 12}, "so_24299963_24299963_0": {"section_id": 8614, "quality": 0.9166666666666666, "length": 11}, "so_24299963_24303296_0": {"section_id": 8567, "quality": 0.9, "length": 27}}}, "24299963": {"CommentCount": "1", "ViewCount": "201", "OwnerDisplayName": "user2953119", "CreationDate": "2014-06-19T06:20:24.557", "LastActivityDate": "2014-06-19T10:31:48.520", "Title": "Class member qualified name lookup", "PostTypeId": "1", "Id": "24299963", "Score": "4", "Body": "<p>Consider the following code snippet:</p>\n<pre><code>class A\n{\n    int b[A::a]; //1, error\n    void foo(){ int b = A::a; } //2, ok\n    static const int a = 5;\n}\n</code></pre>\n<p>Clause 3.4.3.1/1 (Qualified name lookup, class members) said:</p>\n<blockquote>\n<p id=\"so_24299963_24299963_0\">If the nested-name-specifier of a qualified-id nominates a class, the\n  name specified after the nested-name-specifier is looked up in the\n  scope of the class <strong>(10.2)</strong></p>\n</blockquote>\n<p>This implies that the name <code>a</code> after the nested-name-specifier both in <code>//1</code> and in <code>//2</code> will be looked up in the class scope.</p>\n<p>Clause 10.2 (Member name lookup) said:</p>\n<p><em>10.2/2</em></p>\n<blockquote>\n<p id=\"so_24299963_24299963_1\">The following steps define the result of name lookup for a member name\n  f in a class scope C.</p>\n</blockquote>\n<p><em>10.2/3</em></p>\n<blockquote>\n<p id=\"so_24299963_24299963_2\">The lookup set for f in C, called S(f, C)...</p>\n<p id=\"so_24299963_24299963_3\">S(f, C) is calculated as follows:</p>\n</blockquote>\n<p><em>10.2/4</em></p>\n<blockquote>\n<p id=\"so_24299963_24299963_4\">If C contains a declaration of the name f, the declaration set\n  contains every declaration of f declared in C that satisfies the\n  requirements of the language construct in which the lookup occurs.</p>\n</blockquote>\n<p><strong>The following is unclear for me:</strong></p>\n<p>From the quotes I cited implies that for both <code>//1</code> and <code>//2</code> the same member lookup rules shall be applied. <strong>But actually its a different.</strong> Why is my reasoning wrong?</p>\n<p><strong><em>Note</em></strong>: I know about unqualified name lookup rules into the class scope. And I understood that  behavior in the following code snippet:</p>\n<pre><code>class A\n{\n    int b[a]; //error\n    void foo(){ int b = a; } //ok\n    static const int a = 5;\n}\n</code></pre>\n<p>It is because that behavior described in the sections 3.4.1/7 and 3.4.1/8 (Unqualified name lookup).</p>\n", "Tags": "<c++><class><language-lawyer>", "AnswerCount": "2"}});