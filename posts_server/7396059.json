post_cb({"7396084": {"ParentId": "7396059", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_7396059_7396084_0\">i m calling destructor to deallocate memory</p>\n</blockquote>\n<p>Why? Destructor does not deallocate memory occupied by the object. Never did.</p>\n<p>A non-trivial destructor ends object's <em>lifetime</em>, but it doesn't end the object's <em>storage duration</em>. This means that memory remains allocated, it just becomes \"raw\" (uninitialized). \nSo, in that sense it is <em>destroying</em> your object. </p>\n<p>Meanwhile, a trivial destructor has no effect at all. Even if you call it explicitly, the object's lifetime does not end. </p>\n<p>In your case the destructor <code>B::~B</code> is non-trivial though, which formally means that by calling it you ended your object's lifetime. You destroyed it as much a local object can be destroyed. <a href=\"http://www.youtube.com/watch?v=u5rZmUPDHCk\" rel=\"noreferrer\">But the memory remains</a>. Attempting to access that memory as a <code>B</code> object simply leads to undefined behavior.</p>\n<p>In fact, there's no way to manually deallocate memory occupied by a local object. Local memory is always deallocated automatically.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2011-09-13T02:23:27.947", "Id": "7396084", "Score": "16", "CreationDate": "2011-09-13T02:09:43.393", "LastActivityDate": "2011-09-13T02:23:27.947"}, "7396098": {"ParentId": "7396059", "CommentCount": "0", "Body": "<p>It's <em>executed</em> because <em>you</em> wrote the code that said you wanted it to happen. The compiler is simply doing what you told it to do.</p>\n<p>What you're doing probably <em>doesn't</em> \"deallocate memory,\" as you suggested it would. Instead, it just calls the destructor. Destructors don't deallocate the memory occupied by the objects they're called on. They deallocate memory allocated by the object (such as by calling destructors of member variables, or calling <code>free</code> or <code>delete</code> on other things), but the memory of the object itself is deallocated elsewhere, either by the internal workings of the <code>delete</code> statement, or by the compiler when cleaning up automatic variables (which is what your <code>B b</code> declaration represents). Even the closing of the scope block probably doesn't deallocate any memory for <code>b</code>; compilers usually figure out how much stack space they'll need for an <em>entire</em> subroutine and allocate it all upon entry. The memory occupied by that <code>B</code> object is reserved for <code>b</code> upon entry to the inner scope, and upon exit, the destructor is called automatically.</p>\n", "OwnerUserId": "33732", "PostTypeId": "2", "Id": "7396098", "Score": "2", "CreationDate": "2011-09-13T02:12:06.780", "LastActivityDate": "2011-09-13T02:12:06.780"}, "7396065": {"ParentId": "7396059", "CommentCount": "0", "Body": "<p>What you're doing is actually invoking undefined behavior ... just because you've called the destructor, does not mean that the memory is zeroed out or necessarily \"reclaimed\" and inaccessable (especially in the case of an automatic variable that was allocated on the stack and not the heap).  It could be, but that is left up to the implementation, and typically that is not done due to performance reasons, which is typically the reason for using C++ in the first place. Therefore you can theoretically access the values at the memory address that the object was occupying after calling the destructor ... but again, it's undefined behavior, and you can run into pretty much anything from a segmentation fault, to a silent error that corrupts memory somewhere else, etc.</p>\n", "OwnerUserId": "649233", "PostTypeId": "2", "Id": "7396065", "Score": "3", "CreationDate": "2011-09-13T02:05:30.947", "LastActivityDate": "2011-09-13T02:05:30.947"}, "7396086": {"ParentId": "7396059", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You do <em>not</em> call a destructor like that (well, you <em>can</em> but it's generally not done).</p>\n<p>For automatic variables like your <code>b</code>, the destructor will be called at some point when the variable goes out of scope. You don't ever need to call the destructor explicitly.</p>\n<p>For objects allocated on the heap with <code>new</code>, the destructor will be called after you <code>delete</code> them. In this case, you also don't call the destructor explicitly.</p>\n<p>C++03 states in <code>12.4 Destructors</code>:</p>\n<blockquote>\n<p id=\"so_7396059_7396086_0\">Destructors are invoked implicitly:</p>\n<ul>\n<li>for a constructed object with static storage duration (3.7.1) at program termination;</li>\n<li>for a constructed object with automatic storage duration (3.7.2) when the block in which the object is created exits;</li>\n<li>for a constructed temporary object when the lifetime of the temporary object ends;</li>\n<li>for a constructed object allocated by a new-expression, through use of a delete-expression;</li>\n<li>in several situations due to the handling of exceptions.</li>\n</ul>\n<p id=\"so_7396059_7396086_1\">Destructors can also be invoked explicitly.</p>\n<p id=\"so_7396059_7396086_2\">Note: explicit calls of destructors are rarely needed. One use of such calls is for objects placed at specific addresses using a new-expression with the placement option. Such use of explicit placement and destruction of objects can be necessary to cope with dedicated hardware resources and for writing memory management facilities.</p>\n</blockquote>\n<p>You <em>especially</em> don't do what you're trying to do since the destructor will be called twice, once explicitly by you and once implicitly when <code>b</code> goes out of scope. From that same section of the standard:</p>\n<blockquote>\n<p id=\"so_7396059_7396086_3\">Once a destructor is invoked for an object, the object no longer exists; the behavior is undefined if the destructor is invoked for an object whose lifetime has ended. Example: if the destructor for an automatic object is explicitly invoked, and the block is subsequently left in a manner that would ordinarily invoke implicit destruction of the object, the behavior is undefined.</p>\n</blockquote>\n<p>This text remains unchanged in the latest draft of C++11 that I have (n3225, November 2010) and it's unlikely it would have changed in essence between that and approval in August 2011.</p>\n", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2011-09-13T02:31:20.210", "Id": "7396086", "Score": "5", "CreationDate": "2011-09-13T02:09:58.190", "LastActivityDate": "2011-09-13T02:31:20.210"}, "7396076": {"ParentId": "7396059", "CommentCount": "0", "Body": "<p>Why wouldn't? Your object has been destroyed but its memory space is still around until it goes out of scope, where it will be destroyed again by the way. It's undefined behavior to do what you do.</p>\n", "OwnerUserId": "927034", "PostTypeId": "2", "Id": "7396076", "Score": "0", "CreationDate": "2011-09-13T02:08:37.580", "LastActivityDate": "2011-09-13T02:08:37.580"}, "35479380": {"ParentId": "7396059", "CommentCount": "0", "Body": "<p>Destructors were not designed to call them explicitly. Basically it is just another (special) method of class.\nIf you want to Uninitialize your object and then still be able to use it you could make our own method:</p>\n<pre><code>class B: public A\n{\npublic:\n int b;\n B() {cout&lt;&lt;\"b\"&lt;&lt;endl;a=10;b=20;}\n ~B() {Release(); cout&lt;&lt;a&lt;&lt;b&lt;&lt;endl;}\n void Release() { cout&lt;&lt;\"Releasing B\"; b = 0; }\n};\n\nint main()\n{\n    {\n      B b;\n      b.Release();\n      b.b=100;  // why this step is executed?\n    }\n    int x;\n    cin&gt;&gt;x;\n    return 0;\n}\n</code></pre>\n<p>Otherwise B will be deleted when out of scope:</p>\n<pre><code>int main()\n{\n    {\n      B b;\n      b.b = 100;  //OK\n    }\n    b.b = 100; //compile time error\n    int x;\n    cin&gt;&gt;x;\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "5938816", "PostTypeId": "2", "Id": "35479380", "Score": "0", "CreationDate": "2016-02-18T10:51:27.887", "LastActivityDate": "2016-02-18T10:51:27.887"}, "7396059": {"CommentCount": "3", "ViewCount": "5335", "PostTypeId": "1", "LastEditorUserId": "4342498", "CreationDate": "2011-09-13T02:04:32.033", "LastActivityDate": "2016-05-27T13:11:51.483", "Title": "explicit call to destructor is not destroying my object why?", "FavoriteCount": "3", "LastEditDate": "2016-05-27T13:11:51.483", "Id": "7396059", "Score": "6", "Body": "<p>I'm calling the destructor to deallocate memory but it is not deleting my object. What is the reason behind it?</p>\n<p>my code is like this:</p>\n<pre><code>class A\n{\npublic: \n    int a;\n    A()\n    {\n        cout &lt;&lt; \"a\" &lt;&lt; endl;\n    }\n};\n\nclass B :public A\n{\npublic: \n    int b;\n    B()\n    {\n        cout &lt;&lt; \"b\" &lt;&lt; endl; a = 10; b = 20;\n    }\n    ~B()\n    {\n        cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;\n    }\n};\n</code></pre>\n<p>and I am using it like:</p>\n<pre><code>int main()\n{\n    {\n        B b;\n        b.~B();\n        b.b=100;  // why this step is executed?\n    }\n    int x;\n    cin&gt;&gt;x;\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><destructor>", "OwnerUserId": "1633728", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_7396059_7396086_3": {"section_id": 411, "quality": 0.9696969696969697, "length": 32}, "so_7396059_7396086_1": {"section_id": 407, "quality": 0.8, "length": 4}, "so_7396059_7396086_2": {"section_id": 410, "quality": 0.9705882352941176, "length": 33}}, "n3337": {"so_7396059_7396086_3": {"section_id": 402, "quality": 0.9696969696969697, "length": 32}, "so_7396059_7396086_1": {"section_id": 398, "quality": 1.0, "length": 5}, "so_7396059_7396086_2": {"section_id": 401, "quality": 0.9705882352941176, "length": 33}}, "n4659": {"so_7396059_7396086_3": {"section_id": 429, "quality": 0.9696969696969697, "length": 32}, "so_7396059_7396086_1": {"section_id": 425, "quality": 0.8, "length": 4}, "so_7396059_7396086_2": {"section_id": 428, "quality": 0.8823529411764706, "length": 30}}}});