post_cb({"31205418": {"Id": "31205418", "PostTypeId": "2", "Body": "<p>The <a href=\"http://en.cppreference.com/w/cpp/thread/mutex/lock\" rel=\"nofollow\">documentation</a> states:</p>\n<blockquote>\n<p id=\"so_31205040_31205418_0\">If lock is called by a thread that already owns the mutex, the behavior is undefined: the program may deadlock, or, if the implementation can detect the deadlock, a resource_deadlock_would_occur error condition may be thrown. </p>\n</blockquote>\n<hr>\n<p>Incidentally, because of stuff like this, I usually like to work with a wrapper subclassing <code>mutex</code>, that allows asserting stuff:</p>\n<pre><code>    /******************************************************************************\n*******************************************************************************\n******************************************************************************/\nnamespace detail\n{\n\n\nclass mutex :\n    public std::mutex\n{\npublic:\n#ifndef NDEBUG\n    void lock()\n    {\n        using ms_t = std::chrono::milliseconds;\n\n        assert(!locked_by_caller());\n        std::mutex::lock();\n        m_holder = std::this_thread::get_id(); \n    }\n#endif // #ifndef NDEBUG\n\n#ifndef NDEBUG\n    void unlock()\n    {\n        assert(locked_by_caller());\n        m_holder = std::thread::id();\n        std::mutex::unlock();\n    }\n#endif // #ifndef NDEBUG\n\n#ifndef NDEBUG\n    bool locked_by_caller() const\n    {\n        return m_holder == std::this_thread::get_id();\n    }\n#endif // #ifndef NDEBUG\n\nprivate:\n#ifndef NDEBUG\n    std::thread::id m_holder = std::thread::id();\n#endif // #ifndef NDEBUG\n};\n\n\n/******************************************************************************\n*******************************************************************************\n******************************************************************************/\n} // namespace detail\n</code></pre>\n<p>Note that here it would catch your error independently from the underlying <code>mutex</code> implementation.</p>\n</hr>", "LastActivityDate": "2015-07-03T11:11:23.787", "Score": "0", "CreationDate": "2015-07-03T11:11:23.787", "ParentId": "31205040", "CommentCount": "3", "OwnerUserId": "3510736"}, "bq_ids": {"n4140": {"so_31205040_31205382_0": {"length": 18, "quality": 0.8181818181818182, "section_id": 2777}, "so_31205040_31205382_1": {"length": 9, "quality": 0.9, "section_id": 2754}, "so_31205040_31205418_0": {"length": 10, "quality": 0.5263157894736842, "section_id": 2777}}, "n3337": {"so_31205040_31205382_0": {"length": 18, "quality": 0.8181818181818182, "section_id": 2738}, "so_31205040_31205382_1": {"length": 7, "quality": 0.7, "section_id": 2715}, "so_31205040_31205418_0": {"length": 10, "quality": 0.5263157894736842, "section_id": 2738}}, "n4659": {"so_31205040_31205382_0": {"length": 18, "quality": 0.8181818181818182, "section_id": 3515}, "so_31205040_31205382_1": {"length": 6, "quality": 0.6, "section_id": 3492}, "so_31205040_31205418_0": {"length": 10, "quality": 0.5263157894736842, "section_id": 3515}}}, "31205382": {"Id": "31205382", "PostTypeId": "2", "Body": "<p>Well, quick tests show the following:</p>\n<ol>\n<li>GCC - shows the output which is shown in the question</li>\n<li>Clang - process killed on the online compiler I've used. So deadlock.</li>\n<li>MSVC2013 - \"device or resource busy: device or resource busy\" - is thrown. It detected an attempt to lock the already locked mutex on the same thread.</li>\n</ol>\n<p>What standard has to say about it?</p>\n<blockquote>\n<p id=\"so_31205040_31205382_0\">30.4.1.2.1/4 [ Note: A program <strong>may</strong> deadlock if the thread that owns a mutex object calls lock() on that object. If the implementation\n  can detect the deadlock, a resource_deadlock_would_occur error condition <strong>may</strong> be observed. \u2014 end note ]</p>\n</blockquote>\n<p>But according to 30.4.1.2/13 it should throw one of these:</p>\n<pre><code>\u2014 resource_deadlock_would_occur \u2014 if the implementation detects that a deadlock would occur. \n\u2014 device_or_resource_busy \u2014 if the mutex is already locked and blocking is not possible.\n</code></pre>\n<p><strike>So the answer is yes, what you observe is an incorrect behavior. It should either block or throw but not proceed as nothing has happened.</strike></p>\n<p>The behavior observed is possible since you have UB in the code. According to 17.6.4.11, violation of a <em>Requires</em> clause is UB and in 30.4.1.2/7 we have the following requirement:</p>\n<blockquote>\n<p id=\"so_31205040_31205382_1\"><strong>Requires</strong>: If m is of type std::mutex, std::timed_mutex, or\n  std::shared_timed_mutex, the calling thread does not own the mutex.</p>\n</blockquote>\n<p>Thanks to @T.C. for pointing out about UB.</p>\n", "LastEditorUserId": "643393", "LastActivityDate": "2015-07-03T18:06:58.490", "Score": "3", "CreationDate": "2015-07-03T11:09:11.710", "ParentId": "31205040", "CommentCount": "3", "LastEditDate": "2015-07-03T18:06:58.490", "OwnerUserId": "643393"}, "31205154": {"Id": "31205154", "PostTypeId": "2", "Body": "<p>I'm not familiar with this <em>specific</em> mutex/resource implementation, but it's common for such synchronization primitives to contain a LOCK COUNT, and to allow the same thread to lock the same object multiples times. </p>\n<p>When the mutex has been unlocked the same number of times as it was locked, then another thread is free to lock it.</p>\n", "LastActivityDate": "2015-07-03T10:57:51.350", "Score": "0", "CreationDate": "2015-07-03T10:57:51.350", "ParentId": "31205040", "CommentCount": "2", "OwnerUserId": "1737"}, "31205040": {"ViewCount": "723", "Body": "<p>I have a class which contains a mutex and an object, each time I need to access the contained object, a method is called to lock the mutex and return te contained object, let's see the code:</p>\n<pre><code>template &lt;typename MUTEX, typename RESOURCE&gt;\nclass LockedResource\n{\n    using mutex_t    = MUTEX;\n    using resource_t = RESOURCE;\n\n    mutex_t    m_mutex;\n    resource_t m_resource;\n\npublic:\n        template &lt;typename ... ARGS&gt;\n        LockedResource(ARGS &amp;&amp;... args) :\n                m_resource(std::forward&lt;ARGS&gt;(args) ...)\n        {}\n\n    class Handler\n    {\n        std::unique_lock&lt;mutex_t&gt; m_lock;      // unique lock\n        resource_t                &amp;m_resource; // Ref to resource\n\n        friend class LockedResource;\n\n        Handler(mutex_t &amp;a_mutex, resource_t &amp;a_resource) :\n            m_lock(a_mutex),       // mutex automatically locked\n            m_resource(a_resource)\n        { std::cout &lt;&lt; \"Resource locked\\n\"; }\n\n    public:\n        Handler(Handler &amp;&amp;a_handler) :\n            m_lock(std::move(a_handler.m_lock)),\n            m_resource(a_handler.m_resource)\n        { std::cout &lt;&lt; \"Moved\\n\"; }\n\n        ~Handler() // mutex automatically unlocked\n        { std::cout &lt;&lt; \"Resource unlocked\\n\"; }\n\n        RESOURCE *operator-&gt;()\n        { return &amp;m_resource; }\n    };\n\n    Handler get()\n    { return {m_mutex, m_resource}; }\n};\n\ntemplate &lt;typename T&gt; using Resource = LockedResource&lt;std::mutex, T&gt;;\n</code></pre>\n<p>The idea behind this code is to <em>wrap</em> an object and protect it from multiple access from multiple threads; the wrapped object have private visibility and the only way to access it is through the internal class <code>Handler</code>, the expected usage is the following:</p>\n<pre><code>LockedResource&lt;std::mutex, Foo&gt; locked_foo;\nvoid f()\n{\n    auto handler = locked_foo.get(); // this will lock the locked_foo.m_mutex;\n    handler-&gt;some_foo_method();\n    // going out of the scope will call the handler dtor and\n    // unlock the locked_foo.m_mutex;\n}\n</code></pre>\n<p>So, if I'm not mistaken, calling the <code>LockedResource::get</code> method creates a <code>LockedResource::Handle</code> value which locks the <code>LockedResource::m_mutex</code> for the entire lifetime of the <code>Handle</code>... but I must be mistaken because the code below doesn't cause a deadlock:</p>\n<pre><code>LockedResource&lt;std::mutex, std::vector&lt;int&gt;&gt; locked_vector{10, 10};\n\nint main()\n{\n/*1*/  auto vec = locked_vector.get(); // vec = Resource&lt;vector&gt;::Handler\n/*2*/  std::cout &lt;&lt; locked_vector.get()-&gt;size() &lt;&lt; '\\n';\n/*3*/  std::cout &lt;&lt; vec-&gt;size() &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>\n<p>I was expecting the line <code>/*1*/</code> to lock the <code>locked_vector.m_mutex</code> and then the line <code>/*2*/</code> try to lock the same already locked mutex causing deadlock, but the output is the following:</p>\n<blockquote id=\"so_31205040_31205040_0\">\n<pre><code>Resource locked\nResource locked\n10\nResource unlocked\n10\nResource unlocked\n</code></pre>\n</blockquote>\n<ul>\n<li>Shouldn't the second <code>::get()</code> lead to a deadlock?</li>\n<li>I'm accessing the wrapped resource through the same lock or I am misunderstanding something?</li>\n</ul>\n<p>Here is the <kbd><a href=\"http://ideone.com/COJjBf\" rel=\"nofollow\">example code</a></kbd>.</p>\n", "AcceptedAnswerId": "31205382", "Title": "Shouldn't this code lead to a deadlock?", "CreationDate": "2015-07-03T10:52:05.397", "Id": "31205040", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-07-03T18:06:58.490", "Score": "3", "OwnerUserId": "499359", "Tags": "<c++><c++11><deadlock>", "AnswerCount": "3"}});