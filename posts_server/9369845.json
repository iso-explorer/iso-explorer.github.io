post_cb({"bq_ids": {"n4140": {"so_9369845_9370714_1": {"section_id": 5444, "quality": 0.9696969696969697, "length": 32}, "so_9369845_9370714_0": {"section_id": 103, "quality": 1.0, "length": 16}}, "n3337": {"so_9369845_9370714_1": {"section_id": 5239, "quality": 0.9696969696969697, "length": 32}, "so_9369845_9370714_0": {"section_id": 98, "quality": 1.0, "length": 16}}, "n4659": {"so_9369845_9370714_1": {"section_id": 6871, "quality": 0.9696969696969697, "length": 32}, "so_9369845_9370714_0": {"section_id": 107, "quality": 1.0, "length": 16}}}, "9370714": {"ParentId": "9369845", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>First off, here is the answer to 2. taken from 14.5.1 [temp.class] paragraph 4:</p>\n<blockquote>\n<p id=\"so_9369845_9370714_0\">In a redeclaration, partial specialization, explicit specialization or explicit instantiation of a class template, the class-key shall agree in kind with the original class template declaration.</p>\n</blockquote>\n<p>However, <code>struct</code> and <code>class</code> are referring to the same class-key according to 7.1.6.3 [dcl.type.elab] paragraph 3 last sentence:</p>\n<blockquote>\n<p id=\"so_9369845_9370714_1\">The class-key or enum keyword present in the elaborated-type-specifier shall agree in kind with the declaration to which the name in the elaborated-type-specifier refers. [...] Thus, in any elaborated-type-specifier, the enum keyword shall be used to refer to an enumeration, the union class-key shall be used to refer to a union, and either the class or struct class-key shall be used to refer to a class declared using the class or struct class-key.</p>\n</blockquote>\n<p>Trying g++, clang, and EDG all agree that it is possible to specialize a template declared as <code>struct</code> as a <code>class</code>. However, clang warns about having changed from <code>struct</code> to <code>class</code> or vice versa. Based on this, the standard library is free to choose whatever keyword it sees fit for the definition. Obviously, if the compiler rejects the code as a result something is seriously broken but I'd think it is the compiler rather than the library which is at error in this case.</p>\n", "OwnerUserId": "1120273", "LastEditorUserId": "743214", "LastEditDate": "2012-02-21T02:05:08.670", "Id": "9370714", "Score": "8", "CreationDate": "2012-02-21T01:01:32.707", "LastActivityDate": "2012-02-21T02:05:08.670"}, "9369845": {"CommentCount": "1", "AcceptedAnswerId": "9370714", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2012-02-20T23:11:54.937", "LastActivityDate": "2012-02-21T02:05:08.670", "LastEditDate": "2012-02-20T23:13:38.990", "ViewCount": "907", "FavoriteCount": "1", "Title": "Specializing a template class as a struct", "Id": "9369845", "Score": "17", "Body": "<p>I was just over specializing <code>std::hash</code> for a user-defined type using:</p>\n<pre><code>template&lt;&gt;\nstruct hash&lt;...&gt; {...};\n</code></pre>\n<p>When VC10 greeted me with the warning:</p>\n<blockquote>\n<p id=\"so_9369845_9369845_0\">warning C4099: 'std::hash&lt;_Kty&gt;': type name first seen using 'class'\n  now seen using 'struct'</p>\n</blockquote>\n<p>and I found out that its standard library declares <code>std::hash</code> as <code>class</code>, whereas the standard (or the latest free draft I have) declares it as <code>struct</code>.</p>\n<p>Well, of course  I know that a struct isn't any different from a class (except for the different default access and inheritance types). But my questions are:</p>\n<ol>\n<li>Does VC10 violate the standard here or is it free to exchange <code>struct</code>s for <code>class</code>s in any standard library components (as long as the required access types for members stay consistent, of course)?</li>\n<li>Is it legal to specialize a template class as a struct and vice versa or does this bring problems with name resolution and the like (at least VC10 thinks it's worth a warning).</li>\n</ol>\n", "Tags": "<c++><class><struct><template-specialization>", "OwnerUserId": "743214", "AnswerCount": "2"}, "9370519": {"ParentId": "9369845", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>For 1: I am not sure, but I believe it is a bug.</p>\n<p>For 2: Don't worry, it shouldn't result in any weird behavior. Just be careful with the scopes of functions that you define. As for the warning, <a href=\"http://msdn.microsoft.com/en-us/library/695x5bes.aspx\" rel=\"nofollow noreferrer\">it is actually pretty general</a> (i.e. not especially made for templates), so I wouldn't care about it much.</p>\n<p>Edit: See also the answer to <a href=\"https://stackoverflow.com/questions/4866425/mixing-class-and-struct\">this</a> question, which basically says that it doesn't make any difference in the standard, but some compilers may behave strangely.</p>\n", "OwnerUserId": "220918", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:34:20.603", "Id": "9370519", "Score": "0", "CreationDate": "2012-02-21T00:35:32.777", "LastActivityDate": "2012-02-21T00:35:32.777"}});