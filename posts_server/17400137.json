post_cb({"bq_ids": {"n4140": {"so_17400137_17403467_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 6009}, "so_17400137_17400137_5": {"length": 14, "quality": 1.0, "section_id": 5811}, "so_17400137_17400137_2": {"length": 14, "quality": 1.0, "section_id": 5811}, "so_17400137_17403467_0": {"length": 44, "quality": 0.9361702127659575, "section_id": 5808}, "so_17400137_17403467_3": {"length": 15, "quality": 1.0, "section_id": 6173}, "so_17400137_17403467_4": {"length": 4, "quality": 1.0, "section_id": 744}, "so_17400137_17403467_1": {"length": 43, "quality": 0.9772727272727273, "section_id": 5811}}, "n3337": {"so_17400137_17403467_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 5777}, "so_17400137_17400137_5": {"length": 14, "quality": 1.0, "section_id": 5584}, "so_17400137_17400137_2": {"length": 14, "quality": 1.0, "section_id": 5584}, "so_17400137_17403467_0": {"length": 44, "quality": 0.9361702127659575, "section_id": 5581}, "so_17400137_17403467_3": {"length": 15, "quality": 1.0, "section_id": 5934}, "so_17400137_17403467_4": {"length": 4, "quality": 1.0, "section_id": 750}, "so_17400137_17403467_1": {"length": 43, "quality": 0.9772727272727273, "section_id": 5584}}, "n4659": {"so_17400137_17403467_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 7508}, "so_17400137_17400137_5": {"length": 11, "quality": 0.7857142857142857, "section_id": 7272}, "so_17400137_17400137_2": {"length": 11, "quality": 0.7857142857142857, "section_id": 7272}, "so_17400137_17403467_0": {"length": 43, "quality": 0.9148936170212766, "section_id": 7269}, "so_17400137_17403467_3": {"length": 15, "quality": 1.0, "section_id": 7675}, "so_17400137_17403467_4": {"length": 4, "quality": 1.0, "section_id": 802}, "so_17400137_17403467_1": {"length": 37, "quality": 0.8409090909090909, "section_id": 7272}}}, "17400137": {"ViewCount": "742", "Body": "<p>Speaking in the context of the C++11 standard (which no longer has a concept of sequence points, as you know) I want to understand how two simplest examples are defined.</p>\n<pre><code>int i = 0;\n\ni = i++;   // #0\n\ni = ++i;   // #1\n</code></pre>\n<p>There are two topics on SO which explain those examples within the C++11 context. <a href=\"https://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points/4183735#4183735\">Here</a> it was said that <code>#0</code> invokes UB and <code>#1</code> is well-defined. <a href=\"https://stackoverflow.com/questions/3852768/unsequenced-value-computations-a-k-a-sequence-points/3852774#3852774\">Here</a> it was said that both examples are undefined. This ambiguity confuses me much. I've read this well-structured <a href=\"http://en.cppreference.com/w/cpp/language/eval_order\" rel=\"nofollow noreferrer\">reference</a> three times already but the topic seems to be way too complicated for me.</p>\n<p>.</p>\n<p>Let's analyze the example <code>#0</code>: <code>i = i++;</code>.</p>\n<p>Corresponding quotes are:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_17400137_17400137_0\">The value computation of the built-in postincrement and postdecrement\n  operators is sequenced before its side-effect.</p></li>\n<li><p id=\"so_17400137_17400137_1\">The side effect (modification of the left argument) of the built-in\n  assignment operator and of all built-in compound assignment operators\n  is sequenced after the value computation (but not the side effects) of\n  both left and right arguments, and is sequenced before the value\n  computation of the assignment expression (that is, before returning\n  the reference to the modified object)</p></li>\n<li><p id=\"so_17400137_17400137_2\">If a side effect on a scalar object is unsequenced relative to another\n  side effect on the same scalar object, the behavior is undefined.</p></li>\n</ul>\n</blockquote>\n<p>As I get it, the side effect of the assignment operator is not sequenced with side effects of it's left and right arguments. Thus the side effect of the assignment operator is not sequenced with the side effects of <code>i++</code>. So <code>#0</code> invokes an UB.</p>\n<p>.</p>\n<p>Let's analyze the example <code>#1</code>: <code>i = ++i;</code>.</p>\n<p>Corresponding quotes are:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_17400137_17400137_3\">The side effect of the built-in preincrement and predecrement\n  operators is sequenced before its value computation (implicit rule due\n  to definition as compound assignment)</p></li>\n<li><p id=\"so_17400137_17400137_4\">The side effect (modification of the left argument) of the built-in\n  assignment operator and of all built-in compound assignment operators\n  is sequenced after the value computation (but not the side effects) of\n  both left and right arguments, and is sequenced before the value\n  computation of the assignment expression (that is, before returning\n  the reference to the modified object)</p></li>\n<li><p id=\"so_17400137_17400137_5\">If a side effect on a scalar object is unsequenced relative to another\n  side effect on the same scalar object, the behavior is undefined.</p></li>\n</ul>\n</blockquote>\n<p>I can not see, how this example is different from the <code>#0</code>. This seems to be an UB for me for the very same reason as <code>#0</code>. The side effect of assignment is not sequenced with the side effect of <code>++i</code>. It seems to be an UB. The topic liked above says it is well-defined. Why?</p>\n<p>.</p>\n<p><strong><em>Question</em></strong>: how can I apply quoted rules to determine the UB of the examples. An as simple as possible explanation would be greatly appreciated. Thank you!</p>\n", "AcceptedAnswerId": "17403467", "Title": "Order of evaluation and undefined behaviour", "CreationDate": "2013-07-01T08:26:06.487", "Id": "17400137", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:09:20.883", "LastEditorUserId": "-1", "LastActivityDate": "2017-08-15T13:22:12.070", "Score": "18", "OwnerUserId": "1574294", "Tags": "<c++><c++11><sequence><increment><undefined-behavior>", "AnswerCount": "2"}, "17403467": {"Id": "17403467", "PostTypeId": "2", "Body": "<p>Since your quotes are not directly from the standard, I will try to give a detailed answer quoting the relevant parts of the standard. The definitions of \"side effects\" and \"evaluation\" is found in paragraph 1.9/12:</p>\n<blockquote>\n<p id=\"so_17400137_17403467_0\">Accessing an object designated by a volatile glvalue (3.10), modifying an object, calling a library I/O function, or calling a function that does any of those operations are all <em>side effects</em>, which are changes in the state of the execution environment. <em>Evaluation</em> of an expression (or a sub-expression) in general includes both value computations (including determining the identity of an object for glvalue evaluation and fetching a value previously assigned to an object for prvalue evaluation) and initiation of side effects.</p>\n</blockquote>\n<p>The next relevant part is paragraph 1.9/15:</p>\n<blockquote>\n<p id=\"so_17400137_17403467_1\">Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced. [...] The value computations of the operands of an operator are sequenced before the value computation of the result of the operator. If a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined.</p>\n</blockquote>\n<p>Now let's see, how to apply this to the two examples.</p>\n<pre><code>i = i++;\n</code></pre>\n<p>This is the postfix form of increment and you find its definition in paragraph 5.2.6. The most relevant sentence reads:</p>\n<blockquote>\n<p id=\"so_17400137_17403467_2\">The value computation of the ++ expression is sequenced before the modification\n  of the operand object.</p>\n</blockquote>\n<p>For the assignment expression see paragraph 5.17. The relevant part states:</p>\n<blockquote>\n<p id=\"so_17400137_17403467_3\">In all cases, the assignment is sequenced after the value computation of the right and left operands, and before the value computation of the assignment expression.</p>\n</blockquote>\n<p>Using all the information from above, the evaluation of the whole expression is (this order is not guaranteed by the standard!):</p>\n<ul>\n<li>value computation of <code>i++</code> (right hand side)</li>\n<li>value computation of <code>i</code> (left hand side)</li>\n<li>modification of <code>i</code> (side effect of <code>++</code>)</li>\n<li>modification of <code>i</code> (side effect of <code>=</code>)</li>\n</ul>\n<p>All the standard guarantees is that the value computations of the two operands is sequenced before the value computation of the assignment expression. But the value computation of the right hand side is only \"reading the value of <code>i</code>\" and <strong>not</strong> modifying <code>i</code>, the two modifications (side effects) are not sequenced with respect to each other and we get undefined behavior.</p>\n<p>What about the second example?</p>\n<pre><code>i = ++i;\n</code></pre>\n<p>The situation is quite different here. You find the definition of prefix increment in paragraph 5.3.2. The relevant part is:</p>\n<blockquote>\n<p id=\"so_17400137_17403467_4\">If x is not of type bool, the expression ++x is equivalent to x+=1.</p>\n</blockquote>\n<p>Substituting that, our expression is equivalent to</p>\n<pre><code>i = (i += 1)\n</code></pre>\n<p>Looking up the compound assignment operator <code>+=</code> in 5.17/7 we get that <code>i += 1</code> is equivalent to <code>i = i + 1</code> except that <code>i</code> is only evaluated once. Hence, the expression in question finally becomes</p>\n<blockquote>\n<p id=\"so_17400137_17403467_5\">i = ( i = (i + 1))</p>\n</blockquote>\n<p>But we already know from above that the value computation of the <code>=</code> is sequenced after the value computation of the operands and the side effects are sequenced before the value computations of <code>=</code>. So we get a well-defined order of evaluation:</p>\n<ol>\n<li>compute value of <code>i + 1</code> (and <code>i</code> - left hand side of inner expression)(#1)</li>\n<li>initiate side effect of inner <code>=</code>, i.e. modify \"inner\" <code>i</code></li>\n<li>compute value of <code>(i = i + 1)</code>, which is the \"new\" value of <code>i</code></li>\n<li>initiate side effect of outer <code>=</code>, i.e. modify \"outer\" <code>i</code></li>\n<li>compute value of full expression.</li>\n</ol>\n<hr>\n<p>(#1): Here, <code>i</code> is only evaluated once, since <code>i += 1</code> is equivalent to <code>i = i + 1</code> except that <code>i</code> is only evaluated once (5.17/7).</p>\n</hr>", "LastEditorUserId": "7586", "LastActivityDate": "2017-08-15T13:22:12.070", "Score": "9", "CreationDate": "2013-07-01T11:32:03.653", "ParentId": "17400137", "CommentCount": "3", "OwnerUserId": "1770418", "LastEditDate": "2017-08-15T13:22:12.070"}, "17400329": {"Id": "17400329", "PostTypeId": "2", "Body": "<p>The key difference is that <code>++i</code> is defined as <code>i += 1</code>, so</p>\n<pre><code>i = ++i;\n</code></pre>\n<p>is the same as:</p>\n<pre><code>i = (i += 1);\n</code></pre>\n<p>Since the side effects of the <code>+=</code> operator are sequenced before\nthe value computation of the operator, the actual modification\nof <code>i</code> in <code>++i</code> is sequenced before the outer assignment.  This\nfollows directly from the sections you quote: \"The side effect\n(modification of the left argument) of the built-in assignment\noperator and of all built-in compound assignment operators is\nsequenced after the value computation (but not the side effects) \nof both left and right arguments, and is sequenced before the\nvalue computation of the assignment expression (that is, before\nreturning the reference to the modified object)\"</p>\n<p>This is due to the nested assignment operator; the (outer)\nassignment operator only imposes sequenced before on the value\ncomputation of its operands, not on their side effects.  (But of\ncourse, it doesn't undo sequencing imposed otherwise.)</p>\n<p>And as you indirectly point out, this is new to C++11;\npreviously, both were undefined.  The older versions of C++\nused sequence points, rather than sequenced before, and there\nwas no sequence point in any of the assignment operators.  (I\nhave the impression that the intent was that operators which\nresult in an lvalue have a value which is sequenced after any\nside effects.  In earlier C++, the expression <code>*&amp;++i</code> was\nundefined behavior; in C++11, it is guaranteed to be the same as\n<code>++i</code>.)</p>\n", "LastEditorUserId": "649665", "LastActivityDate": "2013-07-01T09:17:39.563", "Score": "8", "CreationDate": "2013-07-01T08:37:48.820", "ParentId": "17400137", "CommentCount": "12", "OwnerUserId": "649665", "LastEditDate": "2013-07-01T09:17:39.563"}});