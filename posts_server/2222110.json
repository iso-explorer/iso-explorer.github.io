post_cb({"2223415": {"Id": "2223415", "PostTypeId": "2", "Body": "<p>An interesting link about common pitfalls related to this subject:</p>\n<p><a href=\"http://www.gotw.ca/gotw/002.htm\" rel=\"nofollow noreferrer\">http://www.gotw.ca/gotw/002.htm</a></p>\n", "LastActivityDate": "2010-02-08T17:13:24.543", "CommentCount": "0", "CreationDate": "2010-02-08T17:13:24.543", "ParentId": "2222110", "Score": "0", "OwnerUserId": "183071"}, "2222204": {"Id": "2222204", "PostTypeId": "2", "Body": "<p>I suppose \"unpredictable\" means \"something in accordance with the standard but different from what the programmer expects when writing code\", right?</p>\n<p>I guess you can see from the code where objects are being instantiated or copied, even if it's maybe not obvious. It might be hard to understand though.</p>\n<p>Some stuff is just implemented in certain ways by (all?) compiler vendors, but it could be done differently. E.g., late binding (aka. calling an overloaded, virtual method) is usually implemented using function pointers in the background. This is maybe the fastest way doing it, but I suppose it could be done differently and that would be unexpected. I don't know any compiler though that does it differently.</p>\n<p>Lots of stuff is unexpected in the sense that C++ is overly complex - hardly anybody understands the full language. So unexpected also depends on your knowledge.</p>\n", "LastActivityDate": "2010-02-08T14:28:44.940", "CommentCount": "1", "CreationDate": "2010-02-08T14:28:44.940", "ParentId": "2222110", "Score": "2", "OwnerUserId": "231967"}, "2222110": {"ViewCount": "737", "Body": "<p>Years ago I believed that C was absolutely pure compared to C++ because the compiler couldn't generate any code that you couldn't predict.  I now believe counter examples include the <code>volatile</code> keyword and memory barriers (in multiprocessor programming or device drivers for memory-mapped hardware devices, where plain assembly language would be even more pure than the optimizations of a C compiler).</p>\n<p>At the moment I'm trying to enumerate the unpredictable things a C++ compiler can do.  The main complaint that sticks in my mind about C++ is that the compiler will implicitly instantiate temporary objects, but I believe these cases can all be expected.  The cases I'm thinking of are:</p>\n<ul>\n<li>when a class defines a copy constructor for a type other than itself, without using the <code>explicit</code> keyword</li>\n<li>when a class defines an overloaded conversion operator:  <code>operator ()</code></li>\n<li>when a function accepts an object by value instead of by reference</li>\n<li>when a function returns an object by value instead of by reference</li>\n</ul>\n<p>Are there any others?</p>\n", "Title": "Ways to accidentally create temporary objects in C++?", "CreationDate": "2010-02-08T14:17:20.490", "LastActivityDate": "2012-07-09T21:03:26.573", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-07-09T21:03:26.573", "LastEditorUserId": "938089", "Id": "2222110", "Score": "7", "OwnerUserId": "268702", "Tags": "<c++><object><temporary>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_2222110_2222255_1": {"length": 15, "quality": 0.5769230769230769, "section_id": 378}, "so_2222110_2222255_2": {"length": 10, "quality": 1.0, "section_id": 381}}, "n3337": {"so_2222110_2222255_1": {"length": 17, "quality": 0.6538461538461539, "section_id": 369}, "so_2222110_2222255_2": {"length": 10, "quality": 1.0, "section_id": 372}}, "n4659": {"so_2222110_2222255_2": {"length": 9, "quality": 0.9, "section_id": 396}}}, "2222255": {"Id": "2222255", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_2222110_2222255_0\"><strong>12.2 Temporary objects</strong></p>\n<p id=\"so_2222110_2222255_1\">1 Temporaries of class type are\n  created in various contexts: binding\n  an rvalue to a reference (8.5.3),\n  returning an rvalue (6.6.3), a\n  conversion that creates an rvalue\n  (4.1, 5.2.9, 5.2.11, 5.4), throwing an\n  exception (15.1), entering a handler\n  (15.3), and in some initializations\n  (8.5).</p>\n<p id=\"so_2222110_2222255_2\">4 There are two contexts in which\n  temporaries are destroyed at a\n  different point than the end of the\n  fullexpression. </p>\n</blockquote>\n<p>In fact I suggest take a look at the entire 12.2</p>\n<blockquote>\n<p id=\"so_2222110_2222255_3\">At the moment I'm trying to enumerate\n  the unpredictable things a C++\n  compiler can do. The main complaint\n  that sticks in my mind about C++ is\n  that the compiler will implicitly\n  instantiate temporary objects, but I\n  believe these cases can all be\n  expected.</p>\n</blockquote>\n<p>The compiler does not create temporaries implicitly -- it obeys the standard. Unless, of course, when you invoke undefined behavior. Note, that there is something called copy-elision and return value optimization which may actually reduce the number of temporaries that would otherwise be created.</p>\n", "LastActivityDate": "2010-02-08T14:36:05.613", "CommentCount": "0", "CreationDate": "2010-02-08T14:36:05.613", "ParentId": "2222110", "Score": "2", "OwnerUserId": "66692"}});