post_cb({"bq_ids": {"n4140": {"so_41175957_41176278_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 312}, "so_41175957_41176278_1": {"length": 37, "quality": 0.9736842105263158, "section_id": 644}}, "n3337": {"so_41175957_41176278_1": {"length": 37, "quality": 0.9736842105263158, "section_id": 634}}, "n4659": {"so_41175957_41176278_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 320}, "so_41175957_41176278_1": {"length": 37, "quality": 0.9736842105263158, "section_id": 672}}}, "41175957": {"ViewCount": "124", "Body": "<p>With the 3 following overloads</p>\n<pre><code>template &lt;class T&gt; auto foo() { return 1; }\ntemplate &lt;class T&gt; int  foo() { return 2; }\ntemplate &lt;class T&gt; T    foo() { return 3; }\n</code></pre>\n<p>Is the following ill formed ?</p>\n<pre><code>static_cast&lt;int(*)()&gt;(&amp;foo&lt;int&gt;)();\n</code></pre>\n<p>Clang selects overload #2, whereas gcc fails to compile (<a href=\"http://coliru.stacked-crooked.com/a/f805467081c1c419\" rel=\"noreferrer\">Demo</a>)</p>\n<p>When removing overload #1, both agree to select overload #2 (<a href=\"http://coliru.stacked-crooked.com/a/82de6eb2336a5282\" rel=\"noreferrer\">Demo</a>).</p>\n<p>When removing overload #2, gcc selects overload #1 and clang fails to compile (<a href=\"http://coliru.stacked-crooked.com/a/28428c56e6e77756\" rel=\"noreferrer\">Demo</a>)</p>\n", "AcceptedAnswerId": "41176278", "Title": "overload resolution of template function with auto", "CreationDate": "2016-12-16T01:25:41.200", "Id": "41175957", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-12-16T02:12:00.583", "Score": "8", "OwnerUserId": "2684539", "Tags": "<c++><templates><c++14><language-lawyer><function-overloading>", "AnswerCount": "1"}, "41176278": {"Id": "41176278", "PostTypeId": "2", "Body": "<p>As per <a href=\"http://eel.is/c++draft/over.over#2\" rel=\"nofollow noreferrer\">[over.over]/2</a>, we perform template argument deduction. This will succeed for all three overloads: in the first one, keep <a href=\"http://eel.is/c++draft/temp.deduct.funcaddr#2\" rel=\"nofollow noreferrer\">[temp.deduct.funcaddr]/2</a> in mind:</p>\n<blockquote>\n<p id=\"so_41175957_41176278_0\">A placeholder type (7.1.7.4) in the return type of a function template is a non-deduced context. If template\n  argument deduction succeeds for such a function, the return type is determined from instantiation of the\n  function body.</p>\n</blockquote>\n<p>Since the deduction will succeed (given that all template parameters have explicitly supplied arguments), the return type is deduced as <code>int</code>. In the second case, deduction succeeds since the argument is provided, and in the third, <code>T</code> will be deduced. <sup>\u2020</sup></p>\n<p>Going on to <a href=\"http://eel.is/c++draft/over.over#4\" rel=\"nofollow noreferrer\">paragraph 4</a>, </p>\n<blockquote>\n<p id=\"so_41175957_41176278_1\">If more than one function is selected, [...] any given\n  function template specialization <code>F1</code> is eliminated if the set contains\n  a second function template specialization whose function template is\n  more specialized than the function template of <code>F1</code> according to the\n  partial ordering rules of 14.5.6.2. <strong>After such eliminations</strong>, if any, <strong>there shall remain exactly one selected function.</strong></p>\n</blockquote>\n<p>According to <a href=\"http://eel.is/c++draft/temp.deduct.partial#3\" rel=\"nofollow noreferrer\">[temp.deduct.partial]/3</a>, the function templates' function types are used for partial ordering. We can immediately see that #1 and #2's function types do not contain any template parameters that participate in deduction, hence via the addition to <a href=\"http://eel.is/c++draft/temp.deduct.partial#4\" rel=\"nofollow noreferrer\">[temp.deduct.partial]/4</a> introduced by core issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1391\" rel=\"nofollow noreferrer\">1391</a>'s resolution, their corresponding <code>P</code>s are not used to determine the ordering. @bogdan explained <a href=\"https://stackoverflow.com/a/31735126/3647361\">here</a> why that resolution is problematic; the bottom line is that ordering just yields an ambiguity for #1 and #2.</p>\n<p>That is, according to current (probably defective) wording, the conversion is ill-formed in all cases. If partial ordering is fixed for pairs of non-dependent/deducing parameters, </p>\n<ul>\n<li>case 1 and 3 are ambiguous, because for two non-dependent function types (the ones of #1 and #2), there is no ordering pair.</li>\n<li>the accepting behavior in case 2 is correct (as expected).</li>\n</ul>\n<hr>\n<p><sup>\u2020</sup> <a href=\"http://eel.is/c++draft/temp.deduct.type#8\" rel=\"nofollow noreferrer\">[temp.deduct.type]/8</a> element 9 (<code>T()</code>), in case you were curious.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-12-16T02:12:00.583", "Score": "8", "CreationDate": "2016-12-16T02:12:00.583", "ParentId": "41175957", "CommentCount": "1", "OwnerUserId": "3647361", "LastEditDate": "2017-05-23T12:30:52.970"}});