post_cb({"19187825": {"ParentId": "19187766", "PostTypeId": "2", "CommentCount": "12", "Body": "<p><code>std::pair</code> has its default <code>operator==</code> in namespace <code>std</code>, which is a template for arbitrary pairs, comparing both the <code>first</code> and the <code>second</code> fields. This operator gets picked in one of the four cases, namely <code>find</code> with <code>TYPE == type1</code>. The details are a bit complicated though:</p>\n<p>What actually happens for <code>TYPE == type1</code> is (correct me if I'm wrong)</p>\n<ul>\n<li>for <code>v1 == v2</code> ADL (<em>Argument Dependent Name Lookup</em>) is applied to find the <code>operator==</code> in <code>std</code>, meaning this operator is added to the normal overload set. However, the non-template version in the current translation unit is still preferred against the template <code>operator==</code> from <code>std</code>.</li>\n<li>The <code>std::find</code> call is instanced within <code>std</code>, thus lookup for <code>operator==</code> starts directly in <code>std</code>. It finds one match (without using ADL!) and therefore does not search the enclosing scope which would have contained the OP's own operator.</li>\n</ul>\n<p>And for <code>TYPE == type2</code></p>\n<ul>\n<li><code>v1 == v2</code> is easy -it directly finds the <code>operator==</code> in the enclosing namespace.</li>\n<li><code>std::find</code> is also instanced in <code>std</code>, but the custom operator from the main scope is added to the overload resolution set using ADL and then found to be more specific than the one in <code>std</code>.</li>\n</ul>\n", "OwnerUserId": "234053", "LastEditorUserId": "234053", "LastEditDate": "2013-10-04T18:48:37.033", "Id": "19187825", "Score": "8", "CreationDate": "2013-10-04T18:00:57.023", "LastActivityDate": "2013-10-04T18:48:37.033"}, "19191910": {"ParentId": "19187766", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The answer by @AlexanderGessler is incomplete in several details. So let's play compiler for both expressions and both types, shall we?</p>\n<h2>Expression 1</h2>\n<p><code>cout &lt;&lt; (v1 == v2) &lt;&lt; endl;</code></p>\n<p>First, for both <code>type1</code> and <code>type2</code>, <strong>unqualified name lookup</strong> starts at the <code>main()</code> function scope outwards, and finds your own <code>operator==</code> function at the global scope. </p>\n<p>Second, <strong>argument-dependent name lookup</strong> (ADL) finds the function template <code>operator==</code> for <code>std::pair</code> from <code>namespace std</code>. Actually, ADL finds many more <code>std::operator==</code> function templates (those from <code>std::vector</code> and <code>std::string</code>, since you included those headers as well). </p>\n<p><strong>Note</strong>: ADL also finds a match for <code>type2</code>, because its base class <code>type1</code> will add <code>namespace std</code> to the set of its associated namespaces.</p>\n<hr>\n<p><strong>3.4.2 Argument-dependent name lookup [basic.lookup.argdep]</strong></p>\n<blockquote>\n<p id=\"so_19187766_19191910_0\">\u2014 If T is a class type (including unions), its associated classes are:\n  the class itself; the class of which it is a member, if any; and its\n  direct and indirect base classes. Its associated namespaces are the\n  namespaces of which its associated classes are members.</p>\n</blockquote>\n<hr>\n<p>Third, <strong>template argument deduction</strong> takes place for all found function templates. For <code>type1</code>, only the function template for <code>std::pair</code> will survive argument deduction (and it deduces its template arguments to be <code>std::string</code>  and <code>int</code>, respectively). However, for <code>type2</code>, there is no set of template arguments that will fit because <code>type2</code> is not an instantiation of a <code>std::pair</code> template. </p>\n<p>Fourth, <strong>overload resolution</strong> comes into play. For <code>type1</code>, both your own function <code>operator==</code> and the <code>std::operator==</code> function template are of equal rank (Exact Match). Therefore the tie-break will select your non-template function. For <code>type2</code>, there is only one viable function so overload resolution does not come into play and your function will be selected.</p>\n<p><strong>Conclusion 1</strong>: <code>type1</code> and <code>type2</code> will give the same answer (your version is selected), albeit for different reasons.</p>\n<h2>Expression 2</h2>\n<p><code>cout &lt;&lt; (find(vec.begin(), vec.end(), v2) != vec.end()) &lt;&lt; endl;</code></p>\n<p>Here we need to first resolve the call to <code>find</code>. Because of your <code>using namespace std;</code>, unqualified name lookup already finds (no pun intended) <code>std::find</code>, but even without the using directive, ADL on the <code>std::vector</code> iterator would have found it. It will deduce the third template argument for <code>std::find</code> to either <code>type1</code> or <code>type2</code>.</p>\n<p>Within <code>std::find</code>, a call to <code>operator==</code> is found. Again, ordinary lookup will be performed first. However, this takes place from within <code>namespace std</code>. It will find several <code>operator==</code> function templates (for <code>std::vector</code>, <code>std::string</code> and <code>std::pair</code>). As soon as candidates in one scope are found during unqualified name lookup, this phase of name lookup stops. </p>\n<p>However, ADL is still being performed. Note though that the global namespace is not an associated namespace to <code>type1</code> <strong>because it is only a typedef</strong> to a class in <code>namespace std</code>. So for <code>type1</code>, ADL does not find anything new. In contrast, <code>type2</code> does have the global namespace as its associated namespace and so ADL will find your <code>operator==</code> function template in that case. </p>\n<p>For <code>type1</code>, template-argument-deduction finds <code>std::string</code> and <code>int</code> as template arguments for the <code>operator==</code> function template for <code>std::pair</code>. For <code>type2</code>, there is again no set of template arguments that will fit because <code>type2</code> is not an instantiation of a <code>std::pair</code> template. </p>\n<p>That leaves overload resolution. For <code>type1</code>, there is only one viable function (the instance of the <code>std::operator==</code> template), and overloads resolution does not come into play. For <code>type2</code>, there is also only one viable function (viable because it only requires a standard <code>derived-to-base</code> conversion). Hence overload resolution also does not come into play.</p>\n<p><strong>Conclusion 2</strong>: for <code>type1</code> (<code>std</code> version) and <code>type2</code> (your version) you get different results.</p>\n<h2>Summary</h2>\n<p>Just because these things can get very tricky with multiple overloads in different namespaces, here's a summary table with the holy trinity (name lookup, argument deduction and overload resolution). For each phase, and for each type, I have listed the surviving candidates after that phase. The bottom row shows the called function.</p>\n<p><strong>Expression 1</strong></p>\n<pre><code>+---------------------+-----------------+-----------------+\n| phase               | type1           | type2           |\n+---------------------+-----------------+-----------------+\n| unqualified lookup  |    ::operator== |    ::operator== |\n| ADL                 | std::operator== | std::operator== |\n+---------------------+-----------------+-----------------+\n| argument deduction  |    ::operator== |    ::operator== |\n|                     | std::operator== |                 |\n+---------------------+-----------------+-----------------+\n| overload resolution |    ::operator== |    ::operator== |\n+---------------------+-----------------+-----------------+\n</code></pre>\n<p><strong>Expression 2</strong></p>\n<pre><code>+---------------------+-----------------+-----------------+\n| phase               | type1           | type2           |\n+---------------------+-----------------+-----------------+\n| unqualified lookup  | std::operator== | std::operator== |\n| ADL                 |                 |    ::operator== |\n+---------------------+-----------------+-----------------+\n| argument deduction  | std::operator== |    ::operator== |\n+---------------------+-----------------+-----------------+\n| overload resolution | std::operator== |    ::operator== |\n+---------------------+-----------------+-----------------+\n</code></pre>\n<p>Note that unqualified lookup finds a different name depending on the scope it starts in (function scope inside global scope versus namespace scope), and that ADL similarly finds a different name depending on which namespace is considered associated (<code>namespace std</code> vs the global namespace).</p>\n</hr></hr>", "OwnerUserId": "819272", "LastEditorUserId": "819272", "LastEditDate": "2013-10-06T21:15:28.447", "Id": "19191910", "Score": "4", "CreationDate": "2013-10-04T22:45:13.467", "LastActivityDate": "2013-10-06T21:15:28.447"}, "19187766": {"CommentCount": "0", "ViewCount": "1475", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2013-10-04T17:57:27.047", "LastActivityDate": "2013-10-08T09:11:58.720", "Title": "find() using overloaded operator==", "AcceptedAnswerId": "19191910", "LastEditDate": "2013-10-06T21:27:32.127", "Id": "19187766", "Score": "8", "Body": "<p>I try to find an element in a vector using overloaded operator==(). However, if using <code>type1</code> in the following code, the output is 1 and 0 (not found). Using <code>type2</code> gives both 1 and 1. The environment is Xubuntu 12.04 and g++ version 4.6.3. </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef pair&lt;string, int&gt; type1;\nstruct type2: public type1 {};\n#define TYPE type1\n\nbool operator== (const TYPE&amp; lhs, const TYPE&amp; rhs) {\n    return lhs.first == rhs.first;\n}\n\nint main()\n{\n    vector&lt;TYPE&gt; vec;\n    TYPE v1, v2;\n\n    v1.first = \"abc\"; v1.second = 1; vec.push_back(v1);\n    v2.first = \"abc\"; v2.second = 2;\n\n    cout &lt;&lt; (v1 == v2) &lt;&lt; endl;\n    cout &lt;&lt; (find(vec.begin(), vec.end(), v2) != vec.end()) &lt;&lt; endl;\n}\n</code></pre>\n", "Tags": "<c++><operator-overloading><overload-resolution><argument-dependent-lookup><name-lookup>", "OwnerUserId": "2847598", "AnswerCount": "4"}, "19187971": {"ParentId": "19187766", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I think you're better off using <a href=\"http://en.cppreference.com/w/cpp/algorithm/find\" rel=\"nofollow\">find_if</a> instead of find. It takes a predicate, so you can just define your comparer as an ordinary function/functor and pass it.</p>\n", "OwnerUserId": "11684", "LastEditorDisplayName": "user283145", "LastEditDate": "2013-10-08T09:11:58.720", "Id": "19187971", "Score": "1", "CreationDate": "2013-10-04T18:09:20.193", "LastActivityDate": "2013-10-08T09:11:58.720"}, "19187838": {"ParentId": "19187766", "CommentCount": "1", "Body": "<p><code>std::pair</code> has its own <a href=\"http://en.cppreference.com/w/cpp/utility/pair/operator_cmp\" rel=\"nofollow\"><code>operator==</code></a> that takes precedence over your own.</p>\n", "OwnerUserId": "5987", "PostTypeId": "2", "Id": "19187838", "Score": "1", "CreationDate": "2013-10-04T18:01:32.197", "LastActivityDate": "2013-10-04T18:01:32.197"}, "bq_ids": {"n4140": {"so_19187766_19191910_0": {"section_id": 7104, "quality": 1.0, "length": 24}}, "n3337": {"so_19187766_19191910_0": {"section_id": 6848, "quality": 1.0, "length": 24}}, "n4659": {"so_19187766_19191910_0": {"section_id": 8605, "quality": 1.0, "length": 24}}}});