post_cb({"bq_ids": {"n4140": {"so_39599219_39599543_1": {"length": 25, "quality": 1.0, "section_id": 5879}}, "n4659": {"so_39599219_39599543_1": {"length": 25, "quality": 1.0, "section_id": 7363}, "so_39599219_39599543_0": {"length": 28, "quality": 0.9333333333333333, "section_id": 8733}}}, "39599543": {"Id": "39599543", "PostTypeId": "2", "Body": "<p>I think it's defined behavior, assuming <code>Pair</code> is standard-layout. Otherwise, it's undefined behavior. </p>\n<p>First, a standard layout class and its first member share an address. The new wording in [basic.compound] (which clarifies earlier rules) reads:</p>\n<blockquote>\n<p id=\"so_39599219_39599543_0\">Two objects <em>a</em> and <em>b</em> are <em>pointer-interconvertible</em> if:<br>\n  * [...]<br>\n  * one is a standard-layout class object and the other is the first non-static data member of that object,\n  or, [...]<br>\n  * [...]<br>\n  If two objects are <em>pointer-interconvertible</em>, then they have the same address, and it is possible to obtain a\n  pointer to one from a pointer to the other via a <code>reinterpret_cast</code> (5.2.10).</br></br></br></br></p>\n</blockquote>\n<p>Also from [class.mem]:</p>\n<blockquote>\n<p id=\"so_39599219_39599543_1\">If a standard-layout class object has any non-static data members, its address is the same as the address\n  of its first non-static data member. Otherwise, its address is the same as the address of its first base class\n  subobject (if any).</p>\n</blockquote>\n<p>So the <code>reinterpret_cast</code> from <code>A</code> to <code>Pair</code> is fine. If then <code>function</code> only ever access the <code>a</code> object, then that access well-defined, as the offset of <code>A</code> is 0, so the behavior is equivalent to having <code>function</code> take an <code>A&amp;</code> directly. Any access to the <code>b</code> would be undefined, obviously. </p>\n<hr/>\n<p><strong>However</strong>, while I believe the code is defined behavior, it's a bad idea. It's defined behavior <strong>NOW</strong>, but somebody someday might change <code>function</code> to refer to <code>pair.b</code> and then you're in a world of pain. It'd be a lot easier to simply write:</p>\n<pre><code>void function(A&amp; a) { ... }\nvoid function(Pair&amp; p) { function(p.a); }\n</code></pre>\n<p>and just call <code>function</code> directly with your <code>a</code>.</p>\n", "Score": "4", "LastActivityDate": "2016-09-20T16:39:54.993", "CreationDate": "2016-09-20T16:39:54.993", "ParentId": "39599219", "CommentCount": "3", "OwnerUserId": "2069064"}, "39599440": {"Id": "39599440", "PostTypeId": "2", "Body": "<p>Yes, it's undefined behaviour. </p>\n<p>In a struct pair, there can be padding between a and b. An assignment to a member of a struct can modify any padding in the struct. So an assignment to pair.a can modify memory where it thinks there is padding in the struct, where in reality there is just random memory following the memory occupied by your a. </p>\n", "Score": "-1", "LastActivityDate": "2016-09-20T16:33:39.647", "CreationDate": "2016-09-20T16:33:39.647", "ParentId": "39599219", "CommentCount": "1", "OwnerUserId": "3255455"}, "39599219": {"ViewCount": "128", "LastEditDate": "2016-09-20T16:28:29.680", "AcceptedAnswerId": "39599543", "Title": "Struct alignment and type reinterpretation", "CreationDate": "2016-09-20T16:21:16.407", "LastActivityDate": "2016-09-20T16:39:54.993", "CommentCount": "3", "Body": "<p>Lets say I have two types A and B.</p>\n<p>Then I make this type</p>\n<pre><code>struct Pair{\n    A a;\n    B b;\n};\n</code></pre>\n<p>Now I have a function such as this.</p>\n<pre><code>void function(Pair&amp; pair);\n</code></pre>\n<p>And lets assume that <code>function</code>  will only ever use the <code>a</code> part of the pair.</p>\n<p>Then is it undefined behavior to use and call the function in this way?</p>\n<pre><code>A a;\nfunction(reinterpret_cast&lt;Pair&amp;&gt;(a));\n</code></pre>\n<p>I know that a compiler may insert padding bytes after a member but can it also do it before the first member?</p>\n", "PostTypeId": "1", "LastEditorUserId": "2069064", "Id": "39599219", "Score": "4", "OwnerUserId": "6695690", "Tags": "<c++><struct><undefined-behavior>", "AnswerCount": "2"}});