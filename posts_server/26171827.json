post_cb({"30114008": {"ParentId": "26171827", "CommentCount": "1", "Body": "<p>In the same draft, you also find the following text, directly following the text you quoted:</p>\n<blockquote>\n<p id=\"so_26171827_30114008_0\">For any trivially copyable type <code>T</code>, if two pointers to <code>T</code> point to distinct <code>T</code> objects <code>obj1</code> and <code>obj2</code>, where\n  neither <code>obj1</code> nor <code>obj2</code> is a base-class subobject, if the underlying bytes (1.7) making up <code>obj1</code> are copied\n  into <code>obj2</code>, <code>obj2</code> shall subsequently hold the same value as <code>obj1</code>.</p>\n</blockquote>\n<p>Note that this speaks about a change of the value of <code>obj2</code>, not about destroying the object <code>obj2</code> and creating a new object in its place. Since not the object, but only its value is changed, any pointers or references to its members should therefore remain valid.</p>\n", "OwnerUserId": "1032073", "PostTypeId": "2", "Id": "30114008", "Score": "2", "CreationDate": "2015-05-08T00:45:58.140", "LastActivityDate": "2015-05-08T00:45:58.140"}, "bq_ids": {"n4140": {"so_26171827_26171827_2": {"section_id": 7200, "quality": 0.9090909090909091, "length": 40}, "so_26171827_26171827_0": {"section_id": 7189, "quality": 0.8461538461538461, "length": 33}, "so_26171827_30114310_1": {"section_id": 7202, "quality": 0.8235294117647058, "length": 42}, "so_26171827_30114008_0": {"section_id": 7201, "quality": 0.967741935483871, "length": 30}, "so_26171827_26171827_1": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_26171827_26171827_2": {"section_id": 6944, "quality": 0.9090909090909091, "length": 40}, "so_26171827_26171827_0": {"section_id": 6933, "quality": 0.8461538461538461, "length": 33}, "so_26171827_30114310_1": {"section_id": 6946, "quality": 0.8235294117647058, "length": 42}, "so_26171827_26171827_1": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_26171827_30114008_0": {"section_id": 6945, "quality": 0.967741935483871, "length": 30}}, "n4659": {"so_26171827_26171827_2": {"section_id": 8709, "quality": 0.8409090909090909, "length": 37}, "so_26171827_26171827_0": {"section_id": 8697, "quality": 0.7435897435897436, "length": 29}, "so_26171827_30114310_1": {"section_id": 8711, "quality": 0.8235294117647058, "length": 42}, "so_26171827_26171827_1": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_26171827_30114008_0": {"section_id": 8710, "quality": 0.967741935483871, "length": 30}}}, "26171827": {"CommentCount": "16", "AcceptedAnswerId": "30114310", "PostTypeId": "1", "LastEditorUserId": "2756719", "CreationDate": "2014-10-03T00:53:11.687", "LastActivityDate": "2016-07-16T00:18:12.580", "LastEditDate": "2014-10-03T01:00:45.343", "ViewCount": "995", "FavoriteCount": "5", "Title": "Is memcpy of a trivially-copyable type construction or assignment?", "Id": "26171827", "Score": "26", "Body": "\n<p>Let's say you have an object of type <code>T</code> and a suitably-aligned memory buffer <code>alignas(T) unsigned char[sizeof(T)]</code>.  If you use <code>std::memcpy</code> to copy from the object of type <code>T</code> to the <code>unsigned char</code> array, is that considered copy construction or copy-assignment?</p>\n<p>If a type is trivially-copyable but not standard-layout, it is conceivable that a class such as this:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>struct Meow\n{\n    int x;\nprotected: // different access-specifier means not standard-layout\n    int y;\n};\n</code></pre>\n<p>could be implemented like this, because the compiler isn't forced into using standard-layout:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>struct Meow_internal\n{\nprivate:\n    ptrdiff_t x_offset;\n    ptrdiff_t y_offset;\n    unsigned char buffer[sizeof(int) * 2 + ANY_CONSTANT];\n};\n</code></pre>\n<p>The compiler could store <code>x</code> and <code>y</code> of Meow within buffer at any portion of <code>buffer</code>, possibly even at a random offset within <code>buffer</code>, so long as they are aligned properly and do not overlap.  The offset of <code>x</code> and <code>y</code> could even vary randomly with each construction if the compiler wishes.  (<code>x</code> could go after <code>y</code> if the compiler wishes because the Standard only requires members of the same access-specifier to go in order, and <code>x</code> and <code>y</code> have different access-specifiers.)</p>\n<p>This would meet the requirements of being trivially-copyable; a <code>memcpy</code> would copy the hidden offset fields, so the new copy would work.  But some things would not work.  For example, holding a pointer to <code>x</code> across a <code>memcpy</code> would break:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>Meow a;\na.x = 2;\na.y = 4;\nint *px = &amp;a.x;\n\nMeow b;\nb.x = 3;\nb.y = 9;\nstd::memcpy(&amp;a, &amp;b, sizeof(a));\n\n++*px; // kaboom\n</code></pre>\n<p>However, is the compiler really allowed to implement a trivially-copyable class in this manner?  Dereferencing <code>px</code> should only be undefined behavior if <code>a.x</code>'s lifetime has ended.  Has it?  The relevant portions of the N3797 draft Standard aren't very clear on the subject.  This is section <strong>[basic.life]/1</strong>:</p>\n<blockquote>\n<p id=\"so_26171827_26171827_0\">The <em>lifetime</em> of an object is a runtime property of the object.  An\n  object is said to have non-trivial initialization if it is of a class\n  or aggregate type and it or one of its members is initialized by a\n  constructor other than a trivial default constructor.  [ <em>Note:</em>\n  initialization by a trivial copy/move constructor is non-trivial\n  initialization. \u2014 <em>end note</em> ] The lifetime of an object of type <code>T</code>\n  begins when:</p>\n<ul>\n<li>storage with the proper alignment and size for type <code>T</code> is obtained, and</li>\n<li>if the object has non-trivial initialization, its initialization is complete.</li>\n</ul>\n<p id=\"so_26171827_26171827_1\">The lifetime of an object of type <code>T</code> ends when:</p>\n<ul>\n<li>if <code>T</code> is a class type with a non-trivial destructor (<strong>[class.dtor]</strong>), the destructor call starts, or</li>\n<li>the storage which the object occupies is reused or released.</li>\n</ul>\n</blockquote>\n<p>And this is <strong>[basic.types]/3</strong>:</p>\n<blockquote>\n<p id=\"so_26171827_26171827_2\">For any object (other than a base-class subobject) of trivially\n  copyable type <code>T</code>, whether or not the object holds a valid value of\n  type <code>T</code>, the underlying bytes (<strong>[intro.memory]</strong>) making up the\n  object can be copied into an array of <code>char</code> or <code>unsigned char</code>.  If\n  the content of the array of <code>char</code> or <code>unsigned char</code> is copied back\n  into the object, the object shall subsequently hold its original\n  value.  <em>example omitted</em></p>\n</blockquote>\n<p>The question then becomes, is a <code>memcpy</code> overwrite of a trivially-copyable class instance \"copy construction\" or \"copy-assignment\"?  The answer to the question seems to decide whether <code>Meow_internal</code> is a valid way for a compiler to implement trivially-copyable class <code>Meow</code>.</p>\n<p>If <code>memcpy</code> is \"copy construction\", then the answer is that <code>Meow_internal</code> is valid, because copy construction is reusing the memory.  If <code>memcpy</code> is \"copy-assignment\", then the answer is that <code>Meow_internal</code> is not a valid implementation, because assignment does not invalidate pointers to the instantiated members of a class.  If <code>memcpy</code> is both, I have no idea what the answer is.</p>\n", "Tags": "<c++><c++11><copy-constructor><language-lawyer><memcpy>", "OwnerUserId": "2958774", "AnswerCount": "2"}, "30114310": {"ParentId": "26171827", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>It is clear to me that using <code>std::memcpy</code> results in neither construction nor assignment. It is not construction, since no constructor will be called. Nor is it assignment, as the assignment operator will not be called. Given that a trivially copyable object has trivial destructors, (copy/move) constructors, and (copy/move) assignment operators, the point is rather moot.</p>\n<p>You seem to have quoted \u00b62 from \u00a73.9 [basic.types]. On \u00b63, it states:</p>\n<blockquote>\n<p id=\"so_26171827_30114310_0\">For any trivially copyable type <code>T</code>, if two pointers to <code>T</code> point to distinct <code>T</code> objects <code>obj1</code> and <code>obj2</code>, where neither <code>obj1</code> nor <code>obj2</code> is a base-class subobject, if the underlying bytes (1.7) making up <code>obj1</code> are copied into <code>obj2</code>,<sup>41</sup> <code>obj2</code> shall subsequently hold the same value as <code>obj1</code>. <em>[ Example:</em><br>\n  \u00a0\u00a0<code>T* t1p;</code><br>\n  \u00a0\u00a0<code>T* t2p;</code><br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// <em>provided that</em> <code>t2p</code> <em>points to an initialized object ...</em><br>\n  \u00a0\u00a0<code>std::memcpy(t1p, t2p, sizeof(T));</code><br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// <em>at this point, every subobject of trivially copyable type in</em> <code>*t1p</code> <em>contains</em><br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// <em>the same value as the corresponding subobject in</em> <code>*t2p</code><br>\n<em>\u2014 end example ]</em><br>\n<sub>41) By using, for example, the library functions (17.6.1.2) <code>std::memcpy</code> or <code>std::memmove</code>.</sub></br></br></br></br></br></br></br></br></p>\n</blockquote>\n<p>Clearly, the standard intended to allow <code>*t1p</code> to be useable in every way <code>*t2p</code> would be.</p>\n<p>Continuing on to \u00b64:</p>\n<blockquote>\n<p id=\"so_26171827_30114310_1\">The <em>object representation</em> of an object of type <code>T</code> is the sequence of <em>N</em> unsigned char objects taken up by the object of type <code>T</code>, where <em>N</em> equals <code>sizeof(T)</code>. The <em>value representation</em> of an object is the set of bits that hold the value of type <code>T</code>. For trivially copyable types, the value representation is a set of bits in the object representation that determines a value, which is one discrete element of an implementation-defined set of values.<sup>42</sup><br>\n<sub>42) The intent is that the memory model of C++ is compatible with that of ISO/IEC 9899 Programming Language C.</sub></br></p>\n</blockquote>\n<p>The use of the word <strong><em>the</em></strong> in front of both defined terms implies that any given type only has <strong><em>one</em></strong> object representation and a given object has only <strong><em>one</em></strong> value representation. Your hypothetical morphing internal type should not exist. The footnote makes it clear that the intention is for trivially copyable types to have a memory layout compatible with C. The expectation is then that even an object with non-standard layout, copying it around will still allow it to be useable.</p>\n", "OwnerUserId": "315052", "LastEditorUserId": "315052", "LastEditDate": "2016-07-16T00:18:12.580", "Id": "30114310", "Score": "6", "CreationDate": "2015-05-08T01:23:59.963", "LastActivityDate": "2016-07-16T00:18:12.580"}});