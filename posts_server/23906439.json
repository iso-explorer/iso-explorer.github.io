post_cb({"bq_ids": {"n4140": {"so_23906439_23906439_0": {"length": 15, "quality": 1.0, "section_id": 7093}}, "n3337": {"so_23906439_23906439_0": {"length": 15, "quality": 1.0, "section_id": 6837}}, "n4659": {"so_23906439_23906439_0": {"length": 15, "quality": 1.0, "section_id": 8594}}}, "23906439": {"ViewCount": "41", "Body": "<p>There is a quote from 3.4.1/7:</p>\n<blockquote>\n<p id=\"so_23906439_23906439_0\">When looking for a prior declaration of a class or function introduced\n  by a friend declaration, scopes outside of the innermost enclosing\n  namespace scope are not considered;</p>\n</blockquote>\n<p>Can you get an example to demonstrate this rule?</p>\n", "AcceptedAnswerId": "23906684", "Title": "Looking for a prior declaration, introduced by friend declaration", "CreationDate": "2014-05-28T08:28:38.133", "Id": "23906439", "CommentCount": "1", "LastEditDate": "2014-05-28T09:32:34.893", "PostTypeId": "1", "LastEditorUserId": "1498329", "LastActivityDate": "2014-05-28T09:32:34.893", "Score": "1", "OwnerUserId": "2786156", "Tags": "<c++><namespaces><friend>", "AnswerCount": "2"}, "23906684": {"Id": "23906684", "PostTypeId": "2", "Body": "<p>Sure. This code works (both classes are in the same namespace):</p>\n<pre><code>namespace Foo {\n  class Bar\n  {\n  friend class FooBar;\n  public:\n    Bar() : i(0){}\n  private:\n    int i;\n  };\n\n  class FooBar\n  {\n    FooBar( Bar &amp; other )\n    {\n      other.i = 1;\n    }\n  };\n}//namespace Foo\n</code></pre>\n<p>And this code fails (the friend class is outside of the <code>Foo</code>'s enclosing namespace, thus the lookup fails and you see the the <code>int Foo::i is private within this context</code> error):</p>\n<pre><code>namespace Foo {\n  class Bar\n  {\n  friend class FooBar;\n  public:\n    Bar() : i(0){}\n  private:\n    int i;\n  };\n}//namespace Foo\n\nclass FooBar\n{\n    FooBar( Foo::Bar &amp; other )\n    {\n        other.i = 1;//Oops :'(\n    }\n};\n</code></pre>\n", "LastEditorUserId": "1490355", "LastActivityDate": "2014-05-28T08:46:24.243", "Score": "1", "CreationDate": "2014-05-28T08:40:57.050", "ParentId": "23906439", "CommentCount": "0", "OwnerUserId": "1490355", "LastEditDate": "2014-05-28T08:46:24.243"}, "23906610": {"Id": "23906610", "PostTypeId": "2", "Body": "<p>This rule regulates where the compiler is looking for functions or classes marked as <code>friend</code>. It regulates, that the compiler will only check functions or classes in the same namespace as the class which allows <code>friend</code> access. It will not check functions or classes in other or outer namespaces.</p>\n<hr>\n<p>This code will produce an error:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace a {\n  class Q { int x; friend void foo(Q q); };\n}\n\n// function foo is in outer namespace (not in a)\nvoid foo(a::Q q) { std::cout &lt;&lt; q.x &lt;&lt; std::endl; }\n//                              ^^^ ERROR q.x is private\n\nint main() {\n    a::Q q;\n    foo(q);\n}\n</code></pre>\n<p>The reason is that the function <code>foo</code> is not in the namespace <code>a</code>, but in an outer namespace (in this case the global namespace). Thus <code>foo</code> does not match the friend declaration in <code>Q</code>.</p>\n<hr>\n<p>This code will work:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace a {\n  class Q { int x; friend void foo(Q q); };\n}\n\n// function foo is in same namespace as Q\nnamespace a {\n  void foo(Q q) { std::cout &lt;&lt; q.x &lt;&lt; std::endl; }\n//                            ^^^ OK access allowed by friend\n}\n\nint main() {\n    a::Q q;\n    a::foo(q);\n}\n</code></pre>\n<p>This works because the function <code>foo</code> is now in the same namespace as <code>Q</code>. Thus <code>foo</code> matches the friend declaration in <code>Q</code>.</p>\n</hr></hr>", "LastEditorUserId": "316448", "LastActivityDate": "2014-05-28T08:50:29.117", "Score": "1", "CreationDate": "2014-05-28T08:37:42.150", "ParentId": "23906439", "CommentCount": "0", "OwnerUserId": "316448", "LastEditDate": "2014-05-28T08:50:29.117"}});