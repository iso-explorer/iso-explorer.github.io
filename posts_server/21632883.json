post_cb({"21633032": {"Id": "21633032", "PostTypeId": "2", "Body": "<p>Use <code>inline</code> only to satisfy the One Definition Rule.  Don't bother with <code>inline</code> for performance reasons.</p>\n<blockquote>\n<p id=\"so_21632883_21633032_0\">If inline function is just to \"provide a simple mechanism for the\n  compiler to apply more OPTIMIZATIONS.\"</p>\n</blockquote>\n<p>If we're talking about the <code>inline</code> keyword, then this is <strong>not</strong> what <code>inline</code> is about.  Like, at all.</p>\n<p>All <code>inline</code> <em>does</em> is ensure that a function doesn't violate the One Definition Rule.  It might also provide a hint to the compiler that the compiler should blow the code out inline, which may or may not improve speed, but the compiler is entitled to ignore that hint.  And in fact in modern compilers they will ignore this hint a great deal of the time.</p>\n<p>One of the cases where the compiler is very likely to not blow the code out inline is with big functions.  That doesn't mean the function shouldn't be declared <code>inline</code>, however -- it all depends on how the function is declared, defined and used.  But, again, it has <strong>nothing</strong> to do with performance.</p>\n<p>Don't try to outsmart the compiler when it comes to applying optimization techniques.  It's far better at making your program fast than you are.</p>\n<hr>\n<p>Let's see what the Standard has to say on all of this.</p>\n<h2>7.1.2 Function specifiers</h2>\n<blockquote>\n<p id=\"so_21632883_21633032_1\">2/A function declaration (8.3.5, 9.3, 11.3) with an <code>inline</code> specifier\n  declares an <em>inline function</em>. The <code>inline</code> specifier indicates to the\n  implementation that inline substitution of the function body at the\n  point of call is to be preferred to the usual function call mechanism.\n  An implementation is not required to perform this inline substitution\n  at the point of call; however, even if this inline substitution is\n  omitted, the other rules for inline functions defined by 7.1.2 shall\n  still be respected.</p>\n</blockquote>\n<p>This tells us that <code>inline</code> is a request to the compiler to blow the code out inline, and that compilers are not required to perform that substitution.  But this also tells us that regardless of the compiler performing this inline substitution, the \"other rules\" defined in 7.1.2 still apply.</p>\n<p>There was a time, long ago, when the optimization techniques employed by C++ compilers were primitive relative to the compilers of today.  Back in those days, it might have made sense to use <code>inline</code> as an optimization technique.  But these days, compilers are much better at optimizing your code.  The compiler applies techniques that, today, would make your code faster than inlining ever would, even if the function isn't actually inlined.  (One possible example, RVO.)</p>\n<p>So the end result of this is that while the original intent of 7.1.2/2 might have been to give the programmer a manual-optimization technique, modern compilers optimize so aggressively that this original intent is largely moot.</p>\n<p>So all that's left for <code>inline</code> are those \"other rules.\"  So what are those other rules? (C++11 verbiage)</p>\n<blockquote>\n<p id=\"so_21632883_21633032_2\">4/An inline function shall be defined in every translation unit in\n  which it is odr-used and shall have exactly the same definition in\n  every case (3.2). [ Note: A call to the inline function may be\n  encountered before its definition appears in the translation unit. \u2014\n  end note ] If the definition of a function appears in a translation\n  unit before its first declaration as inline, the program is\n  ill-formed. If a function with external linkage is declared inline in\n  one translation unit, it shall be declared inline in all translation\n  units in which it appears; no diagnostic is required. An inline\n  function with external linkage shall have the same address in all\n  translation units. A static local variable in an extern inline\n  function always refers to the same object. A string literal in the\n  body of an extern inline function is the same object in different\n  translation units. [ Note: A string literal appearing in a default\n  argument is not in the body of an inline function merely because the\n  expression is used in a function call from that inline function. \u2014 end\n  note ] A type defined within the body of an extern inline function is\n  the same type in every translation unit.</p>\n</blockquote>\n<p>Let's take a look at an example.  Suppose we have this class <code>template</code>:</p>\n<h2>File: foo.h</h2>\n<pre><code>#ifndef FOO_H     \n#define FOO_H     \n\n#include &lt;string&gt;     \n#include &lt;sstream&gt;     \n\nclass StringBuilder    \n{    \npublic:    \n    template &lt;typename T&gt; inline StringBuilder&amp; operator&lt;&lt;(const T&amp; t)    \n    {    \n        mStream &lt;&lt; t;    \n        return * this;    \n    }    \n    operator std::string () const;    \nprivate:    \n    std::stringstream mStream;    \n};    \n\nStringBuilder::operator std::string() const     \n{     \n    return mStream.str();    \n}     \n\n#endif     \n</code></pre>\n<p>If we <code>#include</code> this file in <code>main.cpp</code> and use the <code>StringBuilder</code>, everything's fine:</p>\n<h2>File: main.cpp</h2>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    double d = 3.14;\n    unsigned a = 42; \n\n    std::string s = StringBuilder() \n        &lt;&lt; \"d=\" &lt;&lt; d &lt;&lt; \", a=\" &lt;&lt; a;\n    std::cout &lt;&lt; s &lt;&lt; \"\\n\";\n}\n</code></pre>\n<h2>Output:</h2>\n<pre><code>jdibling@hurricane:~/dev/hacks$ ./hacks \nd=3.14, a=42\n</code></pre>\n<p>But if we want to use the <code>StringBuilder</code> in a second translation unit, we're going to have a problem:</p>\n<h2>File: other.cpp</h2>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n#include \"foo.h\"\n\nvoid DoSomethingElse()\n{\n    unsigned long l = -12345;\n    long l2 = 223344;\n\n    std::string s = StringBuilder()\n        &lt;&lt; \"l=\" &lt;&lt; l &lt;&lt; \", l2=\" &lt;&lt; l2; \n    std::cout &lt;&lt; s &lt;&lt; \"\\n\";\n}\n</code></pre>\n<h2>Compiler output:</h2>\n<pre><code>ninja: Entering directory `.'\n[1/3] Building CXX object CMakeFiles/hacks.dir/main.o\n[2/3] Building CXX object CMakeFiles/hacks.dir/other.o\n[3/3] Linking CXX executable hacks\nFAILED: : &amp;&amp; /usr/bin/g++   -Wall -std=c++11 -g   CMakeFiles/hacks.dir/main.o CMakeFiles/hacks.dir/other.o  -o hacks  -rdynamic -lboost_regex-mt &amp;&amp; :\nCMakeFiles/hacks.dir/other.o: In function `std::operator|(std::_Ios_Openmode, std::_Ios_Openmode)':\n/home/jdibling/dev/hacks/foo.h:21: multiple definition of `StringBuilder::operator std::string() const'\nCMakeFiles/hacks.dir/main.o:/home/jdibling/dev/hacks/foo.h:21: first defined here\ncollect2: error: ld returned 1 exit status\nninja: build stopped: subcommand failed.\n</code></pre>\n<p><code>StringBuilder::operator std::string()</code> is defined twice; once in <code>main.cpp</code> and again in <code>other.cpp</code> -- which violated the One Definition Rule.</p>\n<p>We can fix this by making the function <code>inline</code>:</p>\n<pre><code>class StringBuilder\n{\npublic:\n    // [...]\n    inline operator std::string () const;\n//  ^^^^^^\nprivate:\n    std::stringstream mStream;\n};\n</code></pre>\n<h2>Compiler output:</h2>\n<pre><code>ninja: Entering directory `.'\n[1/3] Building CXX object CMakeFiles/hacks.dir/main.o\n[2/3] Building CXX object CMakeFiles/hacks.dir/other.o\n[3/3] Linking CXX executable hacks\n</code></pre>\n<p>This works because now <code>operator std::string</code> is defined on both translation units with exactly the same definition.  It has the same effect as defining the function directly in the declaraton:</p>\n<pre><code>class StringBuilder\n{\npublic:\n    operator std::string () const\n    {\n        return mStream.str();\n    }\nprivate:\n    std::stringstream mStream;\n};\n</code></pre>\n</hr>", "LastEditorUserId": "241536", "LastActivityDate": "2014-02-07T19:06:30.067", "Score": "6", "CreationDate": "2014-02-07T16:33:29.497", "ParentId": "21632883", "CommentCount": "3", "LastEditDate": "2014-02-07T19:06:30.067", "OwnerUserId": "241536"}, "21635095": {"Id": "21635095", "PostTypeId": "2", "Body": "<p>Its ultimately complier decision to make function <code>inline</code> or not so if you declare function as <code>inline</code> its just gives a hint to <strong>compiler</strong> to make this function <code>inline</code> .</p>\n", "LastActivityDate": "2014-02-07T18:25:20.000", "Score": "0", "CreationDate": "2014-02-07T18:25:20.000", "ParentId": "21632883", "CommentCount": "2", "OwnerUserId": "2877945"}, "bq_ids": {"n4140": {"so_21632883_21633032_1": {"length": 41, "quality": 0.9111111111111111, "section_id": 5402}, "so_21632883_21633032_2": {"length": 109, "quality": 0.9396551724137931, "section_id": 5404}}, "n3337": {"so_21632883_21633032_1": {"length": 41, "quality": 0.9111111111111111, "section_id": 5197}, "so_21632883_21633032_2": {"length": 109, "quality": 0.9396551724137931, "section_id": 5199}}, "n4659": {"so_21632883_21633032_1": {"length": 40, "quality": 0.8888888888888888, "section_id": 6849}, "so_21632883_21633032_2": {"length": 81, "quality": 0.6982758620689655, "section_id": 6853}}}, "21633872": {"Id": "21633872", "PostTypeId": "2", "Body": "<p>If we assume that a compiler will paste the inline code at the point where the function is called, you would have large chunks of duplicated code.  </p>\n<p>Functionally, you may observe a negligible performance improvement, but a large increase in the size of your executable.  </p>\n<p>The primary reason to have the compiler paste the code rather than call the function is when the code in the function is smaller than or close to the overhead costs in calling the function and returning from it.  A rule of thumb is a function of a few statements should be marked as inline.  As others have stated, the <code>inline</code> keyword is a hint to the compiler, not a request.  </p>\n", "LastActivityDate": "2014-02-07T17:15:14.943", "Score": "0", "CreationDate": "2014-02-07T17:15:14.943", "ParentId": "21632883", "CommentCount": "1", "OwnerUserId": "225074"}, "21633002": {"Id": "21633002", "PostTypeId": "2", "Body": "<p>Just because you make a function inline it doesn't mean the compiler has to make it inline. An inline function is a hint to the compiler, not an order.</p>\n<p>A compiler will use a set of metrics, such as optimization level, build type (debug or release), code size etc to determine if a function should be inlined.</p>\n", "LastActivityDate": "2014-02-07T16:32:05.703", "Score": "1", "CreationDate": "2014-02-07T16:32:05.703", "ParentId": "21632883", "CommentCount": "1", "OwnerUserId": "26095"}, "21632883": {"ViewCount": "646", "Body": "<p>I search some related questions (such as <a href=\"https://stackoverflow.com/questions/145838/benefits-of-inline-functions-in-c\">Benefits of inline functions in C++?</a>), but I still have questions.</p>\n<p>If inline function is just to \"provide a simple mechanism for the compiler to apply more OPTIMIZATIONS.\" </p>\n<ol>\n<li>Then can I set every function as inline function?</li>\n<li>If I wrongfully set a function as inline function, what would happen concerning performance?</li>\n<li>Any threshold that tells me what size of function should not be inline function?</li>\n</ol>\n", "AcceptedAnswerId": "21633032", "Title": "What if I declare a big function as inline function?", "CreationDate": "2014-02-07T16:26:09.960", "Id": "21632883", "CommentCount": "4", "LastEditDate": "2017-07-05T20:33:51.437", "PostTypeId": "1", "LastEditorUserId": "1498329", "LastActivityDate": "2017-07-05T20:33:51.437", "Score": "1", "OwnerUserId": "650718", "Tags": "<c++><performance><inline>", "AnswerCount": "4"}});