post_cb({"bq_ids": {"n4140": {"so_43962934_43965247_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 370}}, "n3337": {"so_43962934_43965247_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 360}}, "n4659": {"so_43962934_43965247_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 384}}}, "43965247": {"Id": "43965247", "PostTypeId": "2", "Body": "<p>The rule is simple: if the generated definition satisfies the requirements of a <code>constexpr</code> function, then it <em>will be</em> a <code>constexpr</code> function. For example, from C++17, [class.ctor]/7:</p>\n<blockquote>\n<p id=\"so_43962934_43965247_0\">If that user-written default constructor would satisfy the requirements of a constexpr constructor (10.1.5), the implicitly-defined default constructor is <code>constexpr</code>.</p>\n</blockquote>\n<p>The wording around implicit default constructors is describes in terms of what a \"user-written default constructor\" would look like. So \"that user-written default constructor\" means \"what the compiler generates\".</p>\n<p>Similar wording exists for the copy/move constructors.</p>\n<p>The wording is slightly more complex for the assignment operators, but it boils down to the same thing. The type must be a literal type and the assignment operators selected to do the copy/move for each subobject (non-static data member and base class) must be <code>constexpr</code>.</p>\n", "LastActivityDate": "2017-05-14T14:48:24.897", "Score": "4", "CreationDate": "2017-05-14T14:48:24.897", "ParentId": "43962934", "CommentCount": "0", "OwnerUserId": "734069"}, "43962934": {"ViewCount": "59", "Body": "<p>For a class of type T, the following members can be generated by the compiler, depending on the class:</p>\n<ul>\n<li>default constructor: <code>T::T()</code></li>\n<li>copy constructor: <code>T::T(const T&amp;)</code></li>\n<li>move constructor: <code>T::T(T&amp;&amp;)</code></li>\n<li>copy assignment operator: <code>T&amp; T::operator=(const T&amp;)</code></li>\n<li>move assignment operator: <code>T&amp; T::operator=(T&amp;&amp;)</code></li>\n</ul>\n<p>In C++14, and in C++17, what are the rules that lead to the generation of <code>constexpr</code> versions of these functions by the compiler?</p>\n", "AcceptedAnswerId": "43965247", "Title": "Constexpr implicitly declared functions", "CreationDate": "2017-05-14T10:41:56.300", "Id": "43962934", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2017-05-14T14:48:24.897", "Score": "4", "OwnerUserId": "882932", "Tags": "<constructor><c++14><constexpr><assignment-operator><c++1z>", "AnswerCount": "1"}});