post_cb({"19563891": {"FavoriteCount": "1", "ViewCount": "349", "Id": "19563891", "AcceptedAnswerId": "19565257", "Score": "4", "Title": "g++ and clang different behavior with recursive variadic template bitset creation (possible gcc bug?)", "LastEditorUserId": "598696", "CommentCount": "3", "Body": "<p>The following code produces drastically different results when compiled with <strong>g++</strong> or with <strong>clang++</strong>. Sorry for the long example, but I haven't been able to make it any shorter.</p>\n<p>The program should assign a specific bit position to a specific type, then build an <code>std::bitset</code> containing multiple type bits.</p>\n<pre><code>#include &lt;bitset&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\nusing Bts = bitset&lt;32&gt;;\n\nint getNextId() { static int last{0}; return last++; }\n\ntemplate&lt;class T&gt; struct IdStore{ static const int bitIdx; };\ntemplate&lt;class T&gt; const int IdStore&lt;T&gt;::bitIdx{getNextId()};\n\ntemplate&lt;class T&gt; void buildBtsHelper(Bts&amp; mBts) { \n    mBts[IdStore&lt;T&gt;::bitIdx] = true; \n}\ntemplate&lt;class T1, class T2, class... A&gt; \nvoid buildBtsHelper(Bts&amp; mBts) { \n    buildBtsHelper&lt;T1&gt;(mBts); buildBtsHelper&lt;T2, A...&gt;(mBts); \n}\ntemplate&lt;class... A&gt; Bts getBuildBts() { \n    Bts result; buildBtsHelper&lt;A...&gt;(result); return result; \n}\n\ntemplate&lt;class... A&gt; struct BtsStore{ static const Bts bts; };\ntemplate&lt;class... A&gt; const Bts BtsStore&lt;A...&gt;::bts{getBuildBts&lt;A...&gt;()};\ntemplate&lt;&gt; const Bts BtsStore&lt;&gt;::bts{};\n\ntemplate&lt;class... A&gt; const Bts&amp; getBtsStore() { \n    return BtsStore&lt;A...&gt;::bts; \n}\n\nstruct Type1 { int k; };\nstruct Type2 { float f; };\nstruct Type3 { double z; };\nstruct Type4 { };\n\nint main()\n{\n    cout &lt;&lt; getBtsStore&lt;Type1, Type2, Type3, Type4&gt;() &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<ul>\n<li><strong>g++ 4.8.2</strong> prints-----:    <code>00000000000000000000000000000001</code></li>\n<li><strong>clang++ SVN</strong> prints:   <code>00000000000000000000000000001111</code> <em>(as expected)</em></li>\n</ul>\n<p>Only compilation flag is <code>-std=c++11</code>.</p>\n<p><strong>What is happening? Am I introducing undefined behavior? Is g++ wrong?</strong></p>\n", "Tags": "<c++><gcc><c++11><clang><bitset>", "CreationDate": "2013-10-24T10:52:33.720", "LastEditDate": "2013-10-24T11:15:26.080", "LastActivityDate": "2013-10-25T18:50:01.693", "PostTypeId": "1", "AnswerCount": "3", "OwnerUserId": "598696"}, "19565257": {"LastActivityDate": "2013-10-25T18:50:01.693", "CreationDate": "2013-10-24T11:56:14.000", "CommentCount": "5", "Body": "<p>Your code relies on initialization order of two declarations:</p>\n<pre><code>template&lt;class T&gt; const int IdStore&lt;T&gt;::bitIdx{getNextId()};\n\ntemplate&lt;class... A&gt; const Bts BtsStore&lt;A...&gt;::bts{getBuildBts&lt;A...&gt;()};\n// getBuildBts uses IdStore&lt;T&gt;::bitIdx as indexes to assign\n</code></pre>\n<p>If all of <code>IdStore&lt;T&gt;::bitIdx</code> initializations happen before <code>BtsStore&lt;A...&gt;::bts</code> then you get your expected behavior. If all of the happen after <code>BtsStore&lt;A...&gt;::bts</code> then you get g++ behavior. Both orderings are allowed by standard:</p>\n<blockquote>\n<p id=\"so_19563891_19565257_0\"><strong>3.6.2 Initialization of non-local variables</strong></p>\n<p id=\"so_19563891_19565257_1\">2 (...) Dynamic initialization of a non-local variable with static storage\n  duration is either ordered or unordered. Definitions of explicitly\n  specialized class template static data members have ordered\n  initialization. <strong>Other class template static data members (i.e.,\n  implicitly or explicitly instantiated specializations) have unordered\n  initialization</strong>.</p>\n</blockquote>\n", "Id": "19565257", "LastEditDate": "2013-10-25T18:50:01.693", "ParentId": "19563891", "OwnerUserId": "1126943", "PostTypeId": "2", "Score": "6", "LastEditorUserId": "365496"}, "19566110": {"CommentCount": "0", "Body": "<p>The solution is to make <code>IdStore::bitIdx</code> a static member function returning a static local variable.</p>\n", "CreationDate": "2013-10-24T12:34:46.947", "ParentId": "19563891", "Id": "19566110", "LastActivityDate": "2013-10-24T12:34:46.947", "PostTypeId": "2", "Score": "2", "OwnerUserId": "775806"}, "19565549": {"LastActivityDate": "2013-10-24T12:22:30.367", "CreationDate": "2013-10-24T12:09:33.037", "CommentCount": "4", "Body": "<p>Adding to zch's <a href=\"https://stackoverflow.com/a/19565257/1137388\">answer</a>.</p>\n<p>Forcing the instatiations of <code>IdStore</code> for <code>Type1</code>, <code>Type2</code>, <code>Type3</code> and <code>Type4</code> just after these types are defined, <em>seems</em> to fix the problem. For this, add these lines just after the definitions of <code>Type1</code>, <code>Type2</code>, <code>Type3</code> and <code>Type4</code>.</p>\n<pre><code>template struct IdStore&lt;Type1&gt;;\ntemplate struct IdStore&lt;Type2&gt;;\ntemplate struct IdStore&lt;Type3&gt;;\ntemplate struct IdStore&lt;Type4&gt;;\n</code></pre>\n<p><strong>Update</strong>: Like Vittorio, I no longer like the solution above. Here is another one. Turn <code>IdStore</code> into a template function:</p>\n<pre><code>template &lt;typename T&gt;\nint IdStore() {\n    return getNextId();\n}\n</code></pre>\n<p>and, in <code>buildBtsHelper</code> use it this way:</p>\n<pre><code>mBts[IdStore&lt;T&gt;()] = true;\n</code></pre>\n", "Id": "19565549", "LastEditDate": "2017-05-23T10:31:46.997", "ParentId": "19563891", "OwnerUserId": "1137388", "PostTypeId": "2", "Score": "1", "LastEditorUserId": "-1"}, "bq_ids": {"n4140": {"so_19563891_19565257_1": {"length": 34, "quality": 1.0, "section_id": 7151}}, "n3337": {"so_19563891_19565257_1": {"length": 34, "quality": 1.0, "section_id": 6895}}}});