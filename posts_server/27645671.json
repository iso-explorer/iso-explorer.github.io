post_cb({"27645671": {"ViewCount": "658", "Body": "<p>I have recently learned about the <code>explicit</code> specifier.</p>\n<p>Suppose we have:</p>\n<pre><code>f( W, W, W );\n</code></pre>\n<p>Now if we do</p>\n<pre><code>f( 42, 3.14, \"seven\" );\n</code></pre>\n<p>The compiler will attempt the following implicit conversions:</p>\n<pre><code>f( W(42), W(3.14), W(\"seven\") );\n</code></pre>\n<p>If we have defined matching constructors for W, namely:</p>\n<pre><code>W(int);\nW(double);\nW(std::string);\n</code></pre>\n<p>...it will succeed.</p>\n<p>However, if we make the first one explicit:</p>\n<pre><code>explicit W(int);\n</code></pre>\n<p>... this disables the implicit conversion.</p>\n<p>You would now have to write:</p>\n<pre><code>f( W(42), 3.14, \"seven\" );\n</code></pre>\n<p>i.e. it is forcing you to explicitly state the conversion</p>\n<p><strong>Now on to the question:</strong></p>\n<p>It is possible to write:</p>\n<pre><code>explicit W(int,int); // 2 arguments!\n</code></pre>\n<p>This compiles!</p>\n<p>But I can't see any corresponding scenario that might require this syntax.</p>\n<p>Can anyone provide a minimal example?</p>\n", "AcceptedAnswerId": "27645680", "Title": "When to use explicit specifier for multi-argument constructors?", "CreationDate": "2014-12-25T08:49:11.957", "Id": "27645671", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-01-10T15:32:48.457", "Score": "3", "OwnerUserId": "435129", "Tags": "<c++><c++11><constructor><explicit><multiple-arguments>", "AnswerCount": "1"}, "27645680": {"Id": "27645680", "PostTypeId": "2", "Body": "<p>If your constructor is explicit and the class doesn't supply a non-explicit constructor taking <code>initializer_list&lt;T&gt;</code>, then you cannot copy-list-initialize an instance.</p>\n<pre><code>W w = {1,2}; // compiles without explicit, but not with\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/d973bedc26ba3942\" rel=\"nofollow\">Simple live example</a></p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A\n{\npublic:\n   explicit A(int, int) {}\n};\n\nclass B\n{\npublic:\n    B(int, int) {}\n};\n\nint main()\n{\n   B b = {1,2};\n   A a = {1,2};\n}\n</code></pre>\n<p>Quotes from standard:</p>\n<p>8.5/16</p>\n<blockquote>\n<p id=\"so_27645671_27645680_0\">\u2014 If the initializer is a (non-parenthesized) braced-init-list, the\n  object or reference is list-initialized (8.5.4).</p>\n</blockquote>\n<p>8.5.4/3</p>\n<blockquote>\n<p id=\"so_27645671_27645680_1\">List-initialization of an object or reference of type T is defined as\n  follows: ...</p>\n<p id=\"so_27645671_27645680_2\">Otherwise, if T is a class type, constructors are considered. The\n  applicable constructors are enumerated and the best one is chosen\n  through overload resolution (13.3, 13.3.1.7). If a narrowing\n  conversion (see below) is required to convert any of the arguments,\n  the program is ill-formed.</p>\n</blockquote>\n", "LastEditorUserId": "435129", "LastActivityDate": "2015-01-10T15:32:48.457", "Score": "8", "CreationDate": "2014-12-25T08:51:14.330", "ParentId": "27645671", "CommentCount": "4", "LastEditDate": "2015-01-10T15:32:48.457", "OwnerUserId": "1498580"}, "bq_ids": {"n4140": {"so_27645671_27645680_2": {"length": 21, "quality": 0.875, "section_id": 3325}, "so_27645671_27645680_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 3296}, "so_27645671_27645680_1": {"length": 6, "quality": 1.0, "section_id": 3325}}, "n3337": {"so_27645671_27645680_2": {"length": 21, "quality": 0.875, "section_id": 3195}, "so_27645671_27645680_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 3166}, "so_27645671_27645680_1": {"length": 6, "quality": 1.0, "section_id": 3195}}, "n4659": {"so_27645671_27645680_2": {"length": 21, "quality": 0.875, "section_id": 4091}, "so_27645671_27645680_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 4058}, "so_27645671_27645680_1": {"length": 6, "quality": 1.0, "section_id": 4091}}}});