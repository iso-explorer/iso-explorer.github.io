post_cb({"4582039": {"Id": "4582039", "PostTypeId": "2", "Body": "<p>Of course, if you're writing a function in C with such a large number of arguments, you <em>probably</em> want to rethink the design of your program. </p>\n", "LastActivityDate": "2011-01-03T04:19:04.353", "CommentCount": "5", "CreationDate": "2011-01-03T04:19:04.353", "ParentId": "4582012", "Score": "4", "OwnerUserId": "477587"}, "4582250": {"Id": "4582250", "PostTypeId": "2", "Body": "<p>As previous answerers have adequately noted, the number of parameters depends on the C++ compiler.  The compiler limit may well be due to limitations imposed by hardware environments.</p>\n<p>For example the <a href=\"http://www.s-and-b.su/syshlp/vms_html/4515/4515pro_020.html#4515ch9_87\" rel=\"nofollow\">VAX CPU architecture</a> uses an 8-bit field which holds the number of arguments, so compliant VAX code cannot pass more than 255 parameters.</p>\n<p>Likewise many small processors like the <a href=\"http://en.wikipedia.org/wiki/8048\" rel=\"nofollow\">Intel 8048 family</a> are so constrained for memory that most C and C++ compilers give grief if more about four parameters are used.  While many mainstream developers may sneer at the 8048, its descendants remain one of the most widely deployed CPUs\u2014mostly in embedded devices.</p>\n<p>Many RISC architecture implementations specify a parameter passing method using registers, rather than the stack.  A basic ARM CPU, for example, has only 16 registers.  The maximum number of parameters could well depend on compiler command line options which affect how it generates code to pass parameters.  Maybe more than eight are pushed onto a stack.  Maybe not.</p>\n<p>If those examples seem overly restrictive, consider that the <a href=\"http://web.archive.org/web/20080608231658/http://www.handheld-basic.com/documentation/text/page_1495.html\" rel=\"nofollow\">Palm OS limited</a> a C function to a single parameter, and that had to be of type <code>int</code> or <code>void *</code>.</p>\n", "LastEditorUserId": "198536", "LastActivityDate": "2012-03-30T05:41:20.430", "Score": "5", "CreationDate": "2011-01-03T05:31:44.683", "ParentId": "4582012", "CommentCount": "0", "OwnerUserId": "198536", "LastEditDate": "2012-03-30T05:41:20.430"}, "bq_ids": {"n4140": {"so_4582012_4582026_2": {"length": 5, "quality": 0.625, "section_id": 6803}, "so_4582012_4582026_1": {"length": 210, "quality": 0.8433734939759037, "section_id": 47}, "so_4582012_4582026_0": {"length": 40, "quality": 0.975609756097561, "section_id": 46}}, "n3337": {"so_4582012_4582026_2": {"length": 5, "quality": 0.625, "section_id": 6558}}, "n4659": {"so_4582012_4582026_2": {"length": 5, "quality": 0.625, "section_id": 8294}, "so_4582012_4582026_1": {"length": 204, "quality": 0.8192771084337349, "section_id": 48}, "so_4582012_4582026_0": {"length": 40, "quality": 0.975609756097561, "section_id": 47}}}, "4582012": {"ViewCount": "24791", "Body": "<p>I know that minimum number of parameters in function definition is zero, but what is the maximum number of parameters in function definition? I am asking the question just for the sake of knowledge and out of curiosity, not that I am going to write a real function.</p>\n", "AcceptedAnswerId": "4582026", "Title": "Maximum number of parameters in function declaration", "CreationDate": "2011-01-03T04:11:30.113", "Id": "4582012", "CommentCount": "1", "FavoriteCount": "9", "PostTypeId": "1", "LastEditDate": "2011-02-19T21:52:11.197", "LastEditorUserId": "415784", "LastActivityDate": "2013-03-19T12:05:32.407", "Score": "22", "OwnerUserId": "415784", "Tags": "<c++><c><limits><function-declaration><function-parameter>", "AnswerCount": "4"}, "4582067": {"Id": "4582067", "PostTypeId": "2", "Body": "<h1>2. C Language</h1>\n<p><br/></p>\n<h1>5.2.4.1 Translation Limits</h1>\n<p><br/></p>\n<p>The implementation shall be able to <em>translate</em> and <em>execute</em> <strong>at least one program</strong> that\ncontains <strong>at least one instance of every one</strong> of the following limits:<br>\n\u2014 127 nesting levels of blocks<br>\n\u2014 63 nesting levels of conditional inclusion<br>\n\u2014 12 pointer, array, and function declarators (in any combinations) modifying an\narithmetic, structure, union, or incomplete type in a declaration<br>\n\u2014 63 nesting levels of parenthesized declarators within a full declarator<br>\n\u2014 63 nesting levels of parenthesized expressions within a full expression<br>\n\u2014 63 significant initial characters in an internal identifier or a macro name (each\nuniversal character name or extended source character is considered a single\ncharacter)<br>\n\u2014 31 significant initial characters in an external identifier (each universal character name<br>\nspecifying a short identifier of 0000FFFF or less is considered 6 characters, each\nuniversal character name specifying a short identifier of 00010000 or more is\nconsidered 10 characters, and each extended source character is considered the same\nnumber of characters as the corresponding universal character name, if any)<br>\n\u2014 4095 external identifiers in one translation unit<br>\n\u2014 511 identifiers with block scope declared in one block<br>\n\u2014 4095 macro identifiers simultaneously defined in one preprocessing translation unit<br>\n<strong>\u2014 127 parameters in one function definition<br>\n\u2014 127 arguments in one function call</br></strong><br>\n\u2014 127 parameters in one macro definition<br>\n\u2014 127 arguments in one macro invocation<br>\n\u2014 4095 characters in a logical source line<br>\n\u2014 4095 characters in a character string literal or wide string literal (after concatenation)<br>\n\u2014 65535 bytes in an object (in a hosted environment only)<br>\n\u2014 15 nesting levels for #included files<br>\n\u2014 1023 case labels for a switch statement (excluding those for any nested switch\nstatements)<br>\n\u2014 1023 members in a single structure or union<br>\n\u2014 1023 enumeration constants in a single enumeration<br>\n\u2014 63 lev els of nested structure or union definitions in a single struct-declaration-list   </br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></p>\n<p>However, it says in notes that,</p>\n<blockquote>\n<p id=\"so_4582012_4582067_0\"><strong>13) Implementations should avoid\n  imposing fixed translation limits\n  whenever possible.</strong></p>\n</blockquote>\n", "LastEditorUserId": "415784", "LastActivityDate": "2011-01-03T04:45:17.847", "Score": "19", "CreationDate": "2011-01-03T04:28:16.443", "ParentId": "4582012", "CommentCount": "3", "OwnerUserId": "415784", "LastEditDate": "2011-01-03T04:45:17.847"}, "4582026": {"Id": "4582026", "PostTypeId": "2", "Body": "<p>Yes, there are limits imposed by the implementation. Your answer is given in the bold text in the following excerpt from the C++ Standard. </p>\n<h1>1. C++ Language</h1>\n<p><br/></p>\n<h1>Annex B - Implementation quantities</h1>\n<blockquote>\n<ol>\n<li><p id=\"so_4582012_4582026_0\">Because computers are finite, C + + implementations are inevitably limited\n  in the size of the programs they can\n  successfully process. <strong>Every\n  implementation shall document those\n  limitations where known.</strong> This\n  documentation may cite fixed limits\n  where they exist, say how to compute\n  variable limits as a function of\n  available resources, or say that fixed\n  limits do not exist or are unknown.</p></li>\n<li><p id=\"so_4582012_4582026_1\">The limits may constrain quantities that include those described below or\n  others. <strong>The bracketed number following\n  each quantity is recommended as the\n  minimum for that quantity.</strong> However,\n  these quantities are only guidelines\n  and do not determine compliance. <br/> \u2014\n  Nesting levels of compound statements,\n  iteration control structures, and\n  selection control structures [256].<br/>  \u2014\n  Nesting levels of conditional\n  inclusion [256]. <br/> \u2014 Pointer, array, and\n  function declarators (in any\n  combination) modifying an arithmetic,\n  structure, union, or incomplete type\n  in a declaration [256]. <br/> \u2014 Nesting\n  levels of parenthesized expressions\n  within a full expression [256]. <br/> \u2014\n  Number of characters in an internal\n  identifier or macro name [1 024]. <br/> \u2014\n  Number of characters in an external\n  identifier [1 024]. <br/> \u2014 External\n  identifiers in one translation unit\n  [65 536]. <br/> \u2014 Identifiers with block\n  scope declared in one block [1 024]. <br/> \u2014\n  Macro identifiers simultaneously\n  defined in one translation unit [65\n  536]. <br/> <strong>\u2014 Parameters in one function\n  definition [256]. <br/> \u2014 Arguments in one\n  function call [256].</strong> <br/> \u2014 Parameters in\n  one macro definition [256]. <br/> \u2014\n  Arguments in one macro invocation\n  [256]. <br/> \u2014 Characters in one logical\n  source line [65 536]. <br/> \u2014 Characters in\n  a character string literal or wide\n  string literal (after concatenation)\n  [65 536]. <br/> \u2014 Size of an object [262\n  144]. <br/> \u2014 Nesting levels for #include\n  files [256]. <br/> \u2014 Case labels for a\n  switch statement (excluding those for\n  any nested switch statements) [16\n  384]. <br/> \u2014 Data members in a single\n  class, structure, or union [16 384].<br/> \u2014\n  Enumeration constants in a single\n  enumeration [4 096]. <br/> \u2014 Levels of\n  nested class, structure, or union\n  definitions in a single\n  struct-declaration-list [256]. <br/> \u2014\n  Functions registered by atexit()[32].\n  <br/> \u2014 Direct and indirect base classes [16\n  384]. <br/> \u2014 Direct base classes for a\n  single class [1024]. <br/> \u2014 Members\n  declared in a single class [4 096].<br/>  \u2014\n  Final overriding virtual functions in\n  a class, accessible or not [16 384]. <br/> \u2014\n  Direct and indirect virtual bases of a\n  class [1 024]. <br/> \u2014 Static members of a\n  class [1 024]. <br/> \u2014 Friend declarations\n  in a class [4 096]. <br/> \u2014 Access control\n  declarations in a class [4 096]. <br/> \u2014\n  Member initializers in a constructor\n  definition [6 144]. <br/> \u2014 Scope\n  qualifications of one identifier\n  [256]. <br/> \u2014 Nested external\n  specifications [1 024]. <br/> \u2014 Template\n  arguments in a template declaration [1\n  024]. <br/> \u2014 Recursively nested template\n  instantiations [17]. <br/> \u2014 Handlers per\n  try block [256]. <br/> \u2014 Throw\n  specifications on a single function\n  declaration [256].</p></li>\n</ol>\n</blockquote>\n<p>Besides, it also says in $18.3/6,</p>\n<blockquote>\n<p id=\"so_4582012_4582026_2\"><strong>Implementation Limits:</strong> The\n  implementation shall support the\n  registration of at least 32 functions.</p>\n</blockquote>\n", "LastEditorUserId": "415784", "LastActivityDate": "2011-01-03T04:29:18.643", "Score": "34", "CreationDate": "2011-01-03T04:14:35.587", "ParentId": "4582012", "CommentCount": "3", "OwnerUserId": "415784", "LastEditDate": "2011-01-03T04:29:18.643"}});