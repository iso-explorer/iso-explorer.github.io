post_cb({"28505277": {"ParentId": "28505090", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-02-13T17:28:25.323", "Score": "1", "LastEditorUserId": "2069064", "LastEditDate": "2015-02-13T18:25:02.030", "Id": "28505277", "OwnerUserId": "2069064", "Body": "<p>I don't really know what your <code>C</code> and <code>D</code> are, but basically you have these two overloads:</p>\n<pre><code>static std::true_type test(X*, long);\nstatic std::true_type test(Y*, int*);\n\ntest(nullptr, 0);\n</code></pre>\n<p><code>nullptr</code> matches both of the first arguments, and <code>0</code> matches both of the second. Both overloads are viable, and neither is a better candidate than the other. Hence:</p>\n<blockquote>\n<p id=\"so_28505090_28505277_0\">error: call of overloaded <code>\u2018test(std::nullptr_t, int)\u2019</code> is ambiguous</p>\n</blockquote>\n<p>The reason that <code>0</code> can pass for <code>int*</code> is because, from [conv.ptr]:</p>\n<blockquote>\n<p id=\"so_28505090_28505277_1\">A <em>null pointer constant</em> is an <strong>integer literal with value zero</strong> or a prvalue of type <code>std::nullptr_t</code>. A null pointer constant can be converted to a pointer type; the result is the <em>null pointer value</em> of that type\n  and is distinguishable from every other value of object pointer or function pointer type.</p>\n</blockquote>\n", "LastActivityDate": "2015-02-13T18:25:02.030"}, "28505090": {"CommentCount": "6", "ViewCount": "211", "PostTypeId": "1", "LastEditorUserId": "743382", "CreationDate": "2015-02-13T17:16:45.107", "LastActivityDate": "2015-02-13T19:02:31.243", "Title": "sfinae ambiguous call when passing 0 instead of 1", "AcceptedAnswerId": "28505277", "LastEditDate": "2015-02-13T19:02:31.243", "Id": "28505090", "Score": "1", "Body": "<p>Relevant code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\ntemplate&lt;template&lt;typename...&gt; class C, typename... T&gt;\nstruct is_valid_instantiation_impl\n{\n  // Default constructor\n  template&lt;template&lt;typename...&gt; class D&gt;\n  static std::true_type test(decltype(D&lt;T...&gt;{ })*, int);\n  // Copy constructor\n  template&lt;template&lt;typename...&gt; class D&gt;\n  static std::true_type test(decltype(D&lt;T...&gt;{ std::declval&lt;const D&lt;T...&gt;&amp;&gt;() })*, long);\n  // Move constructor\n  template&lt;template&lt;typename...&gt; class D&gt;\n  static std::true_type test(decltype(D&lt;T...&gt;{ std::declval&lt;D&lt;T...&gt;&amp;&amp;&gt;() })*, int*);\n\n  template&lt;template&lt;typename...&gt; class D&gt;\n  static std::false_type test(...);\n\n  using type =  decltype(test&lt;C&gt;(nullptr, 1));\n  //                                      ^ this one\n};\n\ntemplate&lt;template&lt;typename...&gt; class C, typename... T&gt;\nstruct is_valid_instantiation : is_valid_instantiation_impl&lt;C, T...&gt;::type { };\n\ntemplate&lt;typename&gt;\nstruct tester;\n\ntemplate&lt;&gt;\nstruct tester&lt;int&gt;\n{\n  tester(int);\n};\n\nint main(int argc, char** argv)\n{\n  std::cout &lt;&lt; \"instantiable&lt;int&gt;: \" &lt;&lt; is_valid_instantiation&lt;tester, int&gt;::value &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This code compiles fine, but when I replace that <code>1</code> by a <code>0</code> I get (Clang 3.4)</p>\n<pre><code>xxx: error: call to 'test' is ambiguous\n  using type =  decltype(test&lt;C&gt;(nullptr, 0));\n                         ^~~~~~~\nxxx: note: in instantiation of template class 'is_valid_instantiation_impl&lt;tester, int&gt;' requested here\n...\n\nxxx: note: candidate function [with D = tester]\n  static std::true_type test(decltype(D&lt;T...&gt;{ std::declval&lt;const D&lt;T...&gt;&amp;&gt;() })*, long);\n                        ^\nxxx: note: candidate function [with D = tester]\n  static std::true_type test(decltype(D&lt;T...&gt;{ std::declval&lt;D&lt;T...&gt;&amp;&amp;&gt;() })*, int*);\n                        ^\nxxx: note: candidate function [with D = tester]\n  static std::false_type test(...);\n                         ^\n</code></pre>\n<p>Why is it that suddenly this call is ambiguous? As far as I know <code>0</code> is still an int (<em>and GCC 4.8.2 seems to agree with me, but won't compile it either</em>):</p>\n<pre><code>xxx: error: call of overloaded \u2018test(std::nullptr_t, int)\u2019 is ambiguous\n</code></pre>\n<p><strong>EDIT:</strong></p>\n<p>Please note I'm not asking how to resolve this ambiguity, but why there is an ambiguity when I use <code>0</code> instead of <code>1</code>.\nSee <a href=\"http://ideone.com/K9uwrk\" rel=\"nofollow\">this live example</a> for the full code showing the error.</p>\n", "Tags": "<c++><c++11><sfinae>", "OwnerUserId": "840382", "AnswerCount": "2"}, "28506359": {"ParentId": "28505090", "CommentCount": "2", "Body": "<p>In some C++ compilers (most? I'm not sure), nullptr is defined as 0.  If you're using managed pointers, then nullptr and 0 are defined differently.  But for native pointers, they're the same thing.</p>\n<p>So your code is hitting this literal 0, and the compiler suddenly doesn't know whether that's supposed to be a pointer or an integer, because technically it could be either.  Whereas \"1\" is defined in C++ to be a literal int, so there's no confusion.</p>\n<p>Unfortunately, I don't see any way around it other than a cast to explicitly tell the compiler what 0 is supposed to mean.</p>\n", "OwnerUserId": "4561333", "PostTypeId": "2", "Id": "28506359", "Score": "0", "CreationDate": "2015-02-13T18:34:48.633", "LastActivityDate": "2015-02-13T18:34:48.633"}, "bq_ids": {"n4140": {"so_28505090_28505277_1": {"section_id": 39, "quality": 0.9354838709677419, "length": 29}}, "n3337": {"so_28505090_28505277_1": {"section_id": 36, "quality": 0.8709677419354839, "length": 27}}, "n4659": {"so_28505090_28505277_1": {"section_id": 39, "quality": 0.9354838709677419, "length": 29}}}});