post_cb({"8539956": {"Id": "8539956", "PostTypeId": "2", "Body": "<p>Lambdas that do not capture anything are essentially <em>free functions</em>, and thus they are convertible to ordinary function pointers.</p>\n<p>Lambdas that <em>do</em> capture are essentially full classes, and they cannot simply be converted to a free-function pointer. (A capturing lambda is really essentially the same predicate functor class that you would have written in C++ before we had lambdas.)</p>\n<p>Either version of lambda <strong>is</strong> convertible to <code>std::function&lt;void()&gt;</code>, which is what the mapped type of your map should be.</p>\n", "LastActivityDate": "2011-12-16T20:50:51.157", "CommentCount": "2", "CreationDate": "2011-12-16T20:50:51.157", "ParentId": "8539924", "Score": "5", "OwnerUserId": "596781"}, "8539962": {"Id": "8539962", "PostTypeId": "2", "Body": "<p>You're trying to call something that wants a function pointer. A captureless lambda can be converted to a function pointer automatically, but once you write <code>[this]</code> it ceases to be captureless - you're capturing <code>this</code>, so it's an error.</p>\n<p>The solution is to change the type to be a <code>std::function</code>, not a pointer to a function. <code>std::function</code> erases the type of the \"functor\" it \"wraps\" so you can still pass a function pointer as well as a lamba with a capture.</p>\n", "LastEditorUserId": "168175", "LastActivityDate": "2011-12-16T20:57:33.410", "Score": "7", "CreationDate": "2011-12-16T20:51:11.440", "ParentId": "8539924", "CommentCount": "0", "OwnerUserId": "168175", "LastEditDate": "2011-12-16T20:57:33.410"}, "8539924": {"ViewCount": "221", "Body": "<p>I have a class db_interface. And defined a lambda type:</p>\n<pre><code>typedef void (*db_interface_lambda)();\n</code></pre>\n<p>When I create lambda in class in such way: <code>[](){ /* do something */ }</code>, it has good type (db_interface_lambda), but when I use <code>[this](){ /* do something */ }</code>, the compiler starts to shout at me.</p>\n<pre><code>cannot convert \u2018db_interface::db_interface(std::ifstream&amp;)::&lt;lambda()&gt;\u2019 to \u2018std::map&lt;std::basic_string&lt;char&gt;, void (*)()&gt;::mapped_type {aka void (*)()}\u2019 in assignment\n</code></pre>\n<p>How to solve that problem? What is the correct type?</p>\n", "AcceptedAnswerId": "8539959", "Title": "Difference in type of lambda when using [] and [this]", "CreationDate": "2011-12-16T20:48:11.243", "Id": "8539924", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-02-25T02:46:43.423", "LastEditorUserId": "500104", "LastActivityDate": "2013-02-25T02:46:43.423", "Score": "3", "OwnerUserId": "1021680", "Tags": "<c++><c++11><lambda>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_8539924_8539959_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 5965}, "so_8539924_8539959_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 5962}}, "n3337": {"so_8539924_8539959_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 5734}, "so_8539924_8539959_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 5731}}, "n4659": {"so_8539924_8539959_0": {"length": 18, "quality": 0.75, "section_id": 7456}, "so_8539924_8539959_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 7451}}}, "8539959": {"Id": "8539959", "PostTypeId": "2", "Body": "<p>Because lambdas are only implicitly convertible to function pointers <em>if and only if</em> they do not capture anything.</p>\n<p><code>\u00a75.1.2 [expr.prim.lambda] p6</code></p>\n<blockquote>\n<p id=\"so_8539924_8539959_0\">The closure type for a <em>lambda-expression</em> with no <em>lambda-capture</em> (<code>[]</code> is empty) has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type\u2019s function call operator.</p>\n</blockquote>\n<p>Btw, what you <code>typedef</code>'d there is a function pointer, not a lambda type. Lambda expressions have a <em>unique, unnamed, nonunion class type</em>. You can not name them.</p>\n<p><code>\u00a75.1.2 [expr.prim.lambda] p3</code></p>\n<blockquote>\n<p id=\"so_8539924_8539959_1\">The type of the <em>lambda-expression</em> (which is also the type of the closure object) is a unique, unnamed nonunion class type</p>\n</blockquote>\n", "LastActivityDate": "2011-12-16T20:50:57.103", "CommentCount": "0", "CreationDate": "2011-12-16T20:50:57.103", "ParentId": "8539924", "Score": "8", "OwnerUserId": "500104"}});