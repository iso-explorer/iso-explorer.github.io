post_cb({"45578695": {"ParentId": "45469214", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong>Expanding on others' answers</strong></p>\n<hr>\n<p><strong>To clarify why the OP is confused, first</strong>: consider the <code>signed int</code> binary representation of <code>2147483647</code>, below.</p>\n<p><a href=\"https://i.stack.imgur.com/O7FDn.png\" rel=\"nofollow noreferrer\"><img alt=\"Largest signed int\" src=\"https://i.stack.imgur.com/O7FDn.png\"/></a></p>\n<p><br/> </p>\n<hr>\n<p><br/>\n<strong>Next, add one to this number</strong>: giving another <code>signed int</code> of <code>-2147483648</code> (which the OP wishes to use)\n<a href=\"https://i.stack.imgur.com/ddVHv.png\" rel=\"nofollow noreferrer\"><img alt=\"Smallest signed int\" src=\"https://i.stack.imgur.com/ddVHv.png\"/></a>\n<br/></p>\n<hr>\n<p><br/>\n<strong>Finally:</strong> we can see why the OP is confused when <code>-2147483648</code> compiles to a <code>long int</code> instead of a <code>signed int</code>, since it clearly fits in 32 bits.</p>\n<p>But, as the current answers mention, the unary operator (<code>-</code>) is applied <strong><em>after</em></strong> resolving <code>2147483648</code> which is a <code>long int</code> and does NOT fit in 32 bits.</p>\n</hr></hr></hr>", "OwnerUserId": "786356", "LastEditorUserId": "786356", "LastEditDate": "2017-08-21T15:59:39.177", "Id": "45578695", "Score": "3", "CreationDate": "2017-08-08T22:02:06.223", "LastActivityDate": "2017-08-21T15:59:39.177"}, "45469214": {"CommentCount": "13", "AcceptedAnswerId": "45469321", "PostTypeId": "1", "LastEditorUserId": "4850040", "CreationDate": "2017-08-02T19:14:43.437", "LastActivityDate": "2017-08-21T15:59:39.177", "LastEditDate": "2017-08-03T07:40:43.167", "ViewCount": "4058", "FavoriteCount": "9", "Title": "Why does the most negative int value cause an error about ambiguous function overloads?", "Id": "45469214", "Score": "83", "Body": "<p>I'm learning about function overloading in C++ and came across this:</p>\n<pre><code>void display(int a)\n{\n    cout &lt;&lt; \"int\" &lt;&lt; endl;\n}\n\nvoid display(unsigned a)\n{\n    cout &lt;&lt; \"unsigned\" &lt;&lt; endl;\n}\n\nint main()\n{\n    int i = -2147483648;\n    cout &lt;&lt; i &lt;&lt; endl; //will display -2147483648\n    display(-2147483648);\n}\n</code></pre>\n<p>From what I understood, any value given in the <code>int</code> range (in my case <code>int</code> is 4 byte) will call <code>display(int)</code> and any value outside this range will be ambiguous (since the compiler cannot decide which function to call). It is valid for the complete range of <code>int</code> values except its min value i.e. <code>-2147483648</code> where compilation fails with the error</p>\n<blockquote>\n<p id=\"so_45469214_45469214_0\">call of overloaded <code>display(long int)</code> is ambiguous</p>\n</blockquote>\n<p>But taking the same value to an <code>int</code> and printing the value gives <code>2147483648</code>. I'm literally confused with this behavior.</p>\n<p>Why is this behavior observed only when the most negative number is passed? (The behavior is the same if a <code>short</code> is used with <code>-32768</code> - in fact, in any case where the negative number and positive number have the same binary representation)</p>\n<p>Compiler used: g++ (GCC) 4.8.5</p>\n", "Tags": "<c++><integer><function-overloading><negative-number><ambiguous-call>", "OwnerUserId": "5558647", "AnswerCount": "3"}, "45469312": {"ParentId": "45469214", "CommentCount": "0", "Body": "<p>The expression <code>-2147483648</code> is actually applying the <code>-</code> operator to the constant <code>2147483648</code>. On your platform, <code>int</code> can't store <code>2147483648</code>, it must be represented by a larger type. Therefore, the expression <code>-2147483648</code> is not deduced to be <code>signed int</code> but a larger signed type, likely <code>signed long int</code>.</p>\n<p>Since you do not provide an overload for <code>long</code> the compiler is forced to choose between two overloads that are both equally (in)valid. Your compiler should issue a compiler error about ambiguous overloads.</p>\n", "OwnerUserId": "7359094", "PostTypeId": "2", "Id": "45469312", "Score": "32", "CreationDate": "2017-08-02T19:21:16.150", "LastActivityDate": "2017-08-02T19:21:16.150"}, "45469321": {"ParentId": "45469214", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>This is a very subtle error.  What you are seeing is a consequence of there being no negative integer literals in C++.  If we look at [lex.icon] we get that a <em>integer-literal</em>,</p>\n<blockquote>\n<p id=\"so_45469214_45469321_0\"><em>integer-literal</em><br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>decimal-literal integer-suffix<sub>opt</sub></em><br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[...]</br></br></p>\n</blockquote>\n<p>can be a <em>decimal-literal</em>,</p>\n<blockquote>\n<p id=\"so_45469214_45469321_1\"><em>decimal-literal:</em><br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>nonzero-digit</em><br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>decimal-literal \u2019 <sub>opt</sub> digit</em></br></br></p>\n</blockquote>\n<p>where <em>digit</em> is <code>[0-9]</code> and <em>nonzero-digit</em> is <code>[1-9]</code> and the suffix par can be one of <code>u</code>, <code>U</code>, <code>l</code>, <code>L</code>, <code>ll</code>, or <code>LL</code>.  Nowhere in here does it include <code>-</code> as being part of the decimal literal.</p>\n<p>In \u00a72.13.2, we also have:</p>\n<blockquote>\n<p id=\"so_45469214_45469321_2\">An <em>integer literal</em> is a sequence of digits that has no period or exponent part, with optional separating single quotes that are ignored when determining its value. An integer literal may have a prefix that specifies its base and a suffix that specifies its type. The lexically first digit of the sequence of digits is the most significant. <strong>A <em>decimal</em> integer literal (base ten) begins with a digit other than 0 and consists of a sequence of decimal digits.</strong></p>\n</blockquote>\n<p><sup>(emphasis mine)</sup></p>\n<p>Which means the <code>-</code> in <code>-2147483648</code> is the unary <code>operator -</code>.  That means <code>-2147483648</code> is actually treated as <code>-1 * (2147483648)</code>.  Since <code>2147483648</code> is one too many for your <code>int</code> it is promoted to a <code>long int</code> and the ambiguity comes from that not matching.</p>\n<p>If you want to get the minimum or maximum value for a type in a portable manner you can use:</p>\n<pre><code>std::numeric_limits&lt;type&gt;::min();  // or max()\n</code></pre>\n", "OwnerUserId": "4342498", "LastEditorUserId": "366904", "LastEditDate": "2017-08-04T11:56:43.250", "Id": "45469321", "Score": "128", "CreationDate": "2017-08-02T19:21:41.600", "LastActivityDate": "2017-08-04T11:56:43.250"}, "bq_ids": {"n4140": {"so_45469214_45469321_2": {"section_id": 5340, "quality": 0.9591836734693877, "length": 47}}, "n3337": {"so_45469214_45469321_2": {"section_id": 5137, "quality": 0.7755102040816326, "length": 38}}, "n4659": {"so_45469214_45469321_2": {"section_id": 6761, "quality": 0.9183673469387755, "length": 45}}}});