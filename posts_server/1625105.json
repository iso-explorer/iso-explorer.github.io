post_cb({"1625105": {"CommentCount": "9", "CreationDate": "2009-10-26T14:21:54.400", "PostTypeId": "1", "AcceptedAnswerId": "1956217", "LastEditorUserId": "-1", "LastActivityDate": "2016-05-12T16:54:53.497", "LastEditDate": "2017-05-23T11:45:36.470", "ViewCount": "2438", "FavoriteCount": "5", "Title": "How to write `is_complete` template?", "Id": "1625105", "Score": "16", "Body": "<p>After answering <a href=\"https://stackoverflow.com/questions/1611771/deleting-object-with-private-destructor\">this</a> question I was trying to find <code>is_complete</code> template in Boost library and I realized that there is no such template in Boost.TypeTraits. Why there is no such template in Boost library? How it should look like?</p>\n<pre><code>//! Check whether type complete\ntemplate&lt;typename T&gt;\nstruct is_complete\n{   \n  static const bool value = ( sizeof(T) &gt; 0 );\n};\n\n...\n\n// so I could use it in such a way\nBOOST_STATIC_ASSERT( boost::is_complete&lt;T&gt;::value );\n</code></pre>\n<p><strong>The code above is not correct, because it is illegal to apply <code>sizeof</code> to an incomplete type. What will be a good solution?</strong> Is it possible to apply SFINAE in this case somehow?</p>\n<hr>\n<p>Well, this problem couldn't be solved in general without violating the <a href=\"http://en.wikipedia.org/wiki/One_Definition_Rule\" rel=\"nofollow noreferrer\">ODR rule</a>, but there is there a platform specific <a href=\"https://stackoverflow.com/questions/1625105/how-to-write-is-complete-template/1956217#1956217\">solution</a> which works for me.</p>\n</hr>", "Tags": "<c++><templates><typetraits>", "OwnerUserId": "123111", "AnswerCount": "7"}, "37193089": {"ParentId": "1625105", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It might be a bit late, but so far, no C++ 11 solution worked for both complete and abstract types.</p>\n<p>So, here you are.</p>\n<p>With VS2015 (v140), g++ &gt;= 4.8.1, clang &gt;= 3.4, this is working:</p>\n<pre><code>template &lt;class T, class = void&gt;\nstruct IsComplete : std::false_type\n{};\n\ntemplate &lt;class T&gt;\nstruct IsComplete&lt; T, decltype(void(sizeof(T))) &gt; : std::true_type\n{};\n</code></pre>\n<p>Thanks to Bat-Ulzii Luvsanbat: <a href=\"https://blogs.msdn.microsoft.com/vcblog/2015/12/02/partial-support-for-expression-sfinae-in-vs-2015-update-1/\" rel=\"nofollow noreferrer\">https://blogs.msdn.microsoft.com/vcblog/2015/12/02/partial-support-for-expression-sfinae-in-vs-2015-update-1/</a></p>\n<p>With VS2013 (V120):</p>\n<pre><code>namespace Details\n{\n\n    template &lt;class T&gt;\n    struct IsComplete\n    {\n        typedef char no;\n        struct yes { char dummy[2]; };\n\n        template &lt;class U, class = decltype(sizeof(std::declval&lt; U &gt;())) &gt;\n        static yes check(U*);\n\n        template &lt;class U&gt;\n        static no check(...);\n\n        static const bool value = sizeof(check&lt; T &gt;(nullptr)) == sizeof(yes);\n    };\n\n} // namespace Details\n\n\ntemplate &lt;class T&gt;\nstruct IsComplete : std::integral_constant&lt; bool, Details::IsComplete&lt; T &gt;::value &gt;\n{};\n</code></pre>\n<p>This one is inspired from the internets and <a href=\"https://stackoverflow.com/questions/25796126/static-assert-that-template-typename-t-is-not-complete\">static assert that template typename T is NOT complete?</a></p>\n", "OwnerUserId": "685664", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:00:17.657", "Id": "37193089", "Score": "5", "CreationDate": "2016-05-12T16:54:53.497", "LastActivityDate": "2016-05-12T16:54:53.497"}, "1625360": {"ParentId": "1625105", "CommentCount": "4", "Body": "<pre><code>template&lt;class T&gt;\nstruct is_complete {\n    static T &amp; getT();\n    static char (&amp; pass(T))[2];\n    static char pass(...);\n\n    static const bool value = sizeof(pass(getT()))==2;\n};\n</code></pre>\n", "OwnerUserId": "124161", "PostTypeId": "2", "Id": "1625360", "Score": "7", "CreationDate": "2009-10-26T15:03:16.113", "LastActivityDate": "2009-10-26T15:03:16.113"}, "17672456": {"ParentId": "1625105", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Solving this requires performing the computation in the default argument of the trait template, as attempting to change the definition of a template violates the ODR rule (although a combination of <code>__COUNTER__</code> and <code>namespace {}</code> can work around ODR).</p>\n<p>This is written in C++11 but can be adjusted to work in C++03 mode of a moderately recent C++11-compatible compiler.</p>\n<pre><code>template&lt; typename t &gt;\ntypename std::enable_if&lt; sizeof (t), std::true_type &gt;::type\nis_complete_fn( t * );\n\nstd::false_type is_complete_fn( ... );\n\ntemplate&lt; typename t, bool value = decltype( is_complete_fn( (t *) nullptr ) )::value &gt;\nstruct is_complete : std::integral_constant&lt; bool, value &gt; {};\n</code></pre>\n<p><a href=\"http://ideone.com/oNlzkB\" rel=\"nofollow noreferrer\">Online demo.</a></p>\n<p>The default argument is evaluated where the template is named, so it can contextually switch between different definitions. There is no need for a different specialization and definition at each use; you only need one for <code>true</code> and one for <code>false</code>.</p>\n<p>The rule is given in \u00a78.3.6/9, which applies equally to function default arguments and default template-arguments:</p>\n<blockquote>\n<p id=\"so_1625105_17672456_0\">Default arguments are evaluated each time the function is called.</p>\n</blockquote>\n<p>But beware, using this inside a template is almost sure to violate the ODR. A template instantiated on an incomplete type must not do anything differently from if it were instantiated on a complete type. I personally only want this for a <code>static_assert</code>.</p>\n<p>Incidentally, this principle may also be helpful if you want to go the other way and <a href=\"https://stackoverflow.com/questions/6166337/does-c-support-compile-time-counters/6174263#6174263\">implement</a> the functionality of <code>__COUNTER__</code> using templates and overloading.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:16:55.457", "Id": "17672456", "Score": "2", "CreationDate": "2013-07-16T09:12:29.617", "LastActivityDate": "2013-07-17T10:48:16.840"}, "1953520": {"ParentId": "1625105", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I'm afraid you can't implement such an <code>is_complete</code> type traits. The implementation given by @Alexey fails to compile on G++ 4.4.2 and G++ 4.5.0:</p>\n<blockquote>\n<p id=\"so_1625105_1953520_0\">error:   initializing argument 1 of \u2018static char (&amp; is_complete::pass(T))[2] [with T = Foo]\u2019</p>\n</blockquote>\n<p>On my Mac, with G++ 4.0.1 evaluating <code>is_complete&lt;Foo&gt;::value</code> where <code>struct Foo;</code> is incomplete yields to <code>true</code> which is even worse than a compiler error.</p>\n<p><code>T</code> can be both complete and incomplete in the same program, depending on the translation unit but it's always the same type. As a consequence, as commented above, <code>is_complete&lt;T&gt;</code> is always the same type as well.</p>\n<p>So if you respect <a href=\"http://en.wikipedia.org/wiki/One_Definition_Rule\" rel=\"nofollow noreferrer\">ODR</a> it is not possible to have <code>is_complete&lt;T&gt;</code> evaluating to different values depending on where it is used; otherwise it would mean you have different definitions for <code>is_complete&lt;T&gt;</code> which ODR forbids.</p>\n<p>EDIT: As the accepted answer, I myself hacked around a solution that uses the <code>__COUNTER__</code> macro to instantiate a different <code>is_complete&lt;T, int&gt;</code> type everytime the <code>IS_COMPLETE</code> macro is used. However, with gcc, I couldn't get SFINAE to work in the first place.</p>\n", "OwnerUserId": "216063", "LastEditorUserId": "216063", "LastEditDate": "2009-12-25T10:42:16.207", "Id": "1953520", "Score": "2", "CreationDate": "2009-12-23T15:44:24.687", "LastActivityDate": "2009-12-25T10:42:16.207"}, "1956217": {"ParentId": "1625105", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The answer given by Alexey Malistov can be used on MSVC with a minor modification:</p>\n<pre><code>namespace \n{\n    template&lt;class T, int discriminator&gt;\n    struct is_complete {  \n      static T &amp; getT();   \n      static char (&amp; pass(T))[2]; \n      static char pass(...);   \n      static const bool value = sizeof(pass(getT()))==2;\n    };\n}\n#define IS_COMPLETE(X) is_complete&lt;X,__COUNTER__&gt;::value\n</code></pre>\n<p>Unfortunately, the <em><strong>COUNTER</strong></em> predefined macro is not part of the standard, so it would not work on every compiler.</p>\n", "OwnerUserId": "218774", "LastEditorUserId": "218774", "LastEditDate": "2013-07-16T20:59:57.577", "Id": "1956217", "Score": "11", "CreationDate": "2009-12-24T01:14:41.857", "LastActivityDate": "2013-07-16T20:59:57.577"}, "20846218": {"ParentId": "1625105", "CommentCount": "4", "Body": "<p>My 5 cents:</p>\n<pre><code>  template &lt;typename T, typename = void&gt;\n  struct is_incomplete : ::std::true_type\n  {\n  };\n\n  template &lt;typename T&gt;\n  struct is_incomplete&lt;T, decltype(sizeof(T))&gt; : ::std::false_type\n  {\n  };\n\n  template &lt;&gt;\n  struct is_incomplete&lt;void&gt; : ::std::false_type\n  {\n  };\n</code></pre>\n", "OwnerUserId": "1095108", "PostTypeId": "2", "Id": "20846218", "Score": "-1", "CreationDate": "2013-12-30T19:34:47.257", "LastActivityDate": "2013-12-30T19:34:47.257"}, "1625193": {"ParentId": "1625105", "CommentCount": "2", "Body": "<p>I can't find anything in the standard that guarantees that sizeof on an incomplete type will yield 0. It does require, however, that if T is incomplete at some point, but completed later in that translation unit, that all references to T refer to the same type -- so as I read it, even if T is incomplete where your template was invoked, it would be required to say it was complete if T is completed somewhere in that translation unit.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "1625193", "Score": "0", "CreationDate": "2009-10-26T14:35:30.457", "LastActivityDate": "2009-10-26T14:35:30.457"}, "bq_ids": {"n4140": {"so_1625105_17672456_0": {"section_id": 3260, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_1625105_17672456_0": {"section_id": 3132, "quality": 1.0, "length": 7}}, "n4659": {"so_1625105_17672456_0": {"section_id": 4018, "quality": 0.7142857142857143, "length": 5}}}});