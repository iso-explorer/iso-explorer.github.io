post_cb({"bq_ids": {"n4140": {"so_27743745_27743745_3": {"length": 23, "quality": 0.8214285714285714, "section_id": 3242}, "so_27743745_27743745_5": {"length": 26, "quality": 0.8125, "section_id": 3242}, "so_27743745_27743745_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 3242}}, "n3337": {"so_27743745_27743745_3": {"length": 23, "quality": 0.8214285714285714, "section_id": 3115}, "so_27743745_27743745_5": {"length": 26, "quality": 0.8125, "section_id": 3115}}, "n4659": {"so_27743745_27743745_3": {"length": 23, "quality": 0.8214285714285714, "section_id": 3999}, "so_27743745_27743745_5": {"length": 24, "quality": 0.75, "section_id": 4000}, "so_27743745_27743745_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 3998}}}, "27744606": {"Id": "27744606", "PostTypeId": "2", "Body": "<p>I see no way around this - define it once and reuse it whenever possible.<br>\nSuch a huge amount of specializations is avoidable when the qualifiers are <strong>top-level</strong> - we could use <code>std::remove_cv</code> or <code>std::remove_reference</code> in that case, removing all orthogonal qualifiers in each step. Unfortunately this is not applicable for functions as explained in the paragraph quoted by you: The e.g. cv-qualifier is part of the function type, and not top-level. <code>void() const</code> is a fundamentally different type than <code>void()</code>, and thus the both have to be matched by two different partial specializations.</br></p>\n<p>You can shorten all specializations using macros though:</p>\n<pre><code>#define REM_CTOR(...) __VA_ARGS__\n\n#define SPEC(var, cv, ref) \\\ntemplate &lt;typename R, typename... Args&gt; \\\nstruct strip_function_qualifiers&lt;R(Args... REM_CTOR var) cv ref &gt; \\\n{using type = R(Args... REM_CTOR var);};\n\n#define REF(var, cv) SPEC(var, cv,) SPEC(var, cv, &amp;) SPEC(var, cv, &amp;&amp;)\n\n#define CV(var) REF(var,) REF(var, const) \\\n                REF(var, volatile) REF(var, const volatile)\n\ntemplate &lt;typename&gt; struct strip_function_qualifiers;\n\nCV(()) CV((,...))\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/267eb53939b5b7f5\" rel=\"nofollow\"><strong>Demo</strong></a>.<br>\nBoost.PP is possible as well:</br></p>\n<pre><code>#include &lt;boost/preprocessor/tuple/enum.hpp&gt;\n#include &lt;boost/preprocessor/seq/elem.hpp&gt;\n#include &lt;boost/preprocessor/seq/for_each_product.hpp&gt;\n\n#define REF  (&amp;&amp;)(&amp;)()\n#define CV   (const volatile)(const)(volatile)()\n#define VAR  (())((,...)) // Had to add a comma here and use rem_ctor below,\n                          // otherwise Clang complains about ambiguous ellipses\n\n#define SPEC(r, product) \\\ntemplate &lt;typename R, typename... Args&gt; \\\nstruct strip_function_qualifiers&lt;R(Args... BOOST_PP_TUPLE_ENUM( \\\n    BOOST_PP_SEQ_ELEM(0, product))) \\\n    BOOST_PP_SEQ_ELEM(1, product)   \\\n    BOOST_PP_SEQ_ELEM(2, product)&gt;  \\\n{using type = R(Args... BOOST_PP_TUPLE_ENUM(BOOST_PP_SEQ_ELEM(0, product)));};\n\ntemplate &lt;typename&gt; struct strip_function_qualifiers;\n\nBOOST_PP_SEQ_FOR_EACH_PRODUCT(SPEC, (VAR)(CV)(REF))\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/32a381d0ed0f839e\" rel=\"nofollow\"><strong>Demo</strong></a>. Both methods won't get much longer when adding new qualifiers such as <code>transaction_safe</code> or <code>transaction_safe_noinherit</code>.</p>\n<hr>\n<p>Here is a modified <code>SPEC</code> that also defines certain trait members.</p>\n<pre><code>#include &lt;type_traits&gt;\n\n#include &lt;boost/preprocessor/tuple/size.hpp&gt;\n\n// [\u2026]\n\n#define SPEC(r, product)                                         \\\ntemplate &lt;typename R, typename... Args&gt;                          \\\nstruct strip_function_qualifiers&lt;R(Args... BOOST_PP_TUPLE_ENUM(  \\\n    BOOST_PP_SEQ_ELEM(0, product))) \\\n    BOOST_PP_SEQ_ELEM(1, product)   \\\n    BOOST_PP_SEQ_ELEM(2, product)&gt;  \\\n{                                     \\\n    using type = R(Args... BOOST_PP_TUPLE_ENUM(BOOST_PP_SEQ_ELEM(0, product))); \\\n                                                            \\\nprivate:                                                    \\\n    using cv_type = int BOOST_PP_SEQ_ELEM(1, product);      \\\n    using ref_type = int BOOST_PP_SEQ_ELEM(2, product);     \\\npublic:                                                     \\\n    using is_const    = std::is_const&lt;cv_type&gt;;             \\\n    using is_volatile = std::is_volatile&lt;cv_type&gt;;          \\\n    using is_ref_qualified = std::is_reference&lt;ref_type&gt;;               \\\n    using is_lvalue_ref_qualified = std::is_lvalue_reference&lt;ref_type&gt;; \\\n    using is_rvalue_ref_qualified = std::is_rvalue_reference&lt;ref_type&gt;; \\\n    using is_variadic = std::integral_constant&lt;bool,                          \\\n                       !!BOOST_PP_TUPLE_SIZE(BOOST_PP_SEQ_ELEM(0, product))&gt;; \\\n};\n</code></pre>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2015-01-05T10:46:50.410", "Score": "7", "CreationDate": "2015-01-02T15:41:12.023", "ParentId": "27743745", "CommentCount": "14", "OwnerUserId": "3647361", "LastEditDate": "2015-01-05T10:46:50.410"}, "27743745": {"ViewCount": "490", "Body": "<p>Given a possibly varargs function type with possibly a <em>cv-qualifier-seq</em> and possibly a <em>ref-qualifier</em>, is it possible to write a type trait that strips all the qualifiers without writing 4 * 3 * 2 = 24 partial specializations?</p>\n<pre><code>template&lt;class T&gt;\nstruct strip_function_qualifiers;\n\ntemplate&lt;class R, class... Args&gt;\nstruct strip_function_qualifiers&lt;R(Args...)&gt; { using type = R(Args...); };\n\ntemplate&lt;class R, class... Args&gt;\nstruct strip_function_qualifiers&lt;R(Args..., ...)&gt; { using type = R(Args..., ...); };\n\ntemplate&lt;class R, class... Args&gt;\nstruct strip_function_qualifiers&lt;R(Args...) const&gt; { using type = R(Args...); };\n\ntemplate&lt;class R, class... Args&gt;\nstruct strip_function_qualifiers&lt;R(Args..., ...) const &gt; { using type = R(Args..., ...); };\n\ntemplate&lt;class R, class... Args&gt;\nstruct strip_function_qualifiers&lt;R(Args...) const &amp;&gt; { using type = R(Args...); };\n\ntemplate&lt;class R, class... Args&gt;\nstruct strip_function_qualifiers&lt;R(Args..., ...) const &amp; &gt; { using type = R(Args..., ...); };\n\n// etc. etc. for each possible combination (24 in total)\n</code></pre>\n<p>And with <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4301.pdf\" rel=\"nofollow\">the new transactional memory TS</a> adding <code>transaction_safe</code> to the mix, does that mean we'll need to write 48 partial specializations for this?</p>\n<hr>\n<p><strong>Edit</strong>: Quoting the description of these weird function types ([dcl.fct]/p6, quoting N4140):</p>\n<blockquote>\n<p id=\"so_27743745_27743745_0\">A function type with a <em>cv-qualifier-seq</em> or a <em>ref-qualifier</em>\n  (including a type named by typedef-name (7.1.3, 14.1)) shall appear\n  only as:</p>\n<ul>\n<li>the function type for a non-static member function,</li>\n<li>the function type to which a pointer to member refers,</li>\n<li>the top-level function type of a function typedef declaration or <em>alias-declaration</em>, </li>\n<li>the <em>type-id</em> in the default argument of a type-parameter (14.1), or</li>\n<li>the <em>type-id</em> of a <em>template-argument</em> for a <em>type-parameter</em> (14.3.1).</li>\n</ul>\n<p id=\"so_27743745_27743745_1\">[ <em>Example</em>:</p>\n<pre><code>typedef int FIC(int) const;\nFIC f; // ill-formed: does not declare a member function\nstruct S {\n   FIC f; // OK\n};\nFIC S::*pm = &amp;S::f; // OK\n</code></pre>\n<p id=\"so_27743745_27743745_2\">\u2014 <em>end example</em> ] </p>\n<p id=\"so_27743745_27743745_3\">The effect of a <em>cv-qualifier-seq</em> in a function\n  declarator is not the same as adding cv-qualification on top of the\n  function type. In the latter case, the <em>cv-qualifiers</em> are ignored.\n  [<em>Note</em>: a function type that has a <em>cv-qualifier-seq</em> is not a\n  cv-qualified type; there are no cv-qualified function types. \u2014 <em>end\n  note</em> ] [ <em>Example</em>:</p>\n<pre><code> typedef void F();\n struct S {\n    const F f; // OK: equivalent to: void f();\n };\n</code></pre>\n<p id=\"so_27743745_27743745_4\">\u2014 <em>end example</em> ] </p>\n<p id=\"so_27743745_27743745_5\"><strong>The return type, the <em>parameter-type-list</em>, the\n  <em>ref-qualifier</em>, and the <em>cv-qualifier-seq</em>, but not the default arguments (8.3.6) or the exception specification (15.4), are part of\n  the function type.</strong> [<em>Note</em>: Function types are checked during the\n  assignments and initializations of pointers to functions, references\n  to functions, and pointers to member functions. \u2014 <em>end note</em> ]</p>\n</blockquote>\n</hr>", "AcceptedAnswerId": "27744606", "Title": "Stripping all qualifiers from a function type", "CreationDate": "2015-01-02T14:30:36.533", "Id": "27743745", "CommentCount": "7", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-01-04T22:09:04.787", "LastEditorUserId": "3647361", "LastActivityDate": "2015-01-05T10:46:50.410", "Score": "17", "OwnerUserId": "2756719", "Tags": "<c++><templates><c++11><c++14><c++1z>", "AnswerCount": "1"}});