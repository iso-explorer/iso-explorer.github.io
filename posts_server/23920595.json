post_cb({"23920678": {"ParentId": "23920595", "LastEditDate": "2014-05-28T20:23:09.840", "CommentCount": "5", "CreationDate": "2014-05-28T19:53:02.313", "OwnerUserId": "819272", "LastEditorUserId": "819272", "PostTypeId": "2", "Id": "23920678", "Score": "3", "Body": "<p>You are calling <code>std::vector</code>'s templated constructor with two iterators (and a hidden allocator parameter). This is what the relevant Standard quote says:</p>\n<p><strong>23.3.6.2 vector constructors, copy, and assignment [vector.cons]</strong></p>\n<pre><code>template &lt;class InputIterator&gt; \nvector(InputIterator first, InputIterator last, const Allocator&amp; = Allocator());\n</code></pre>\n<blockquote>\n<p id=\"so_23920595_23920678_0\">9 Effects:\n  Constructs a vector equal to the range [first,last), using the\n  speci\ufb01ed allocator. </p>\n<p id=\"so_23920595_23920678_1\">10 Complexity: Makes only N calls to the copy\n  constructor of T (where N is the distance between first and last) <strong>and\n  no reallocations if iterators \ufb01rst and last are of forward,\n  bidirectional, or random access categories</strong>. It makes order N calls to\n  the copy constructor of T and order log(N) reallocations if they are\n  just input iterators.</p>\n</blockquote>\n<p>Because you are initializing from a <code>std::list</code> (bidirectional iterators) there will be only one allocation. </p>\n<p>Reading from standard input, OTOH, is done using input iterators and then there could be multiple reallocations. Note though that the average number of times that an element is being moved around in memory is still <code>O(1)</code> (because of the exponential memory allocation strategy).</p>\n", "LastActivityDate": "2014-05-28T20:23:09.840"}, "23920663": {"ParentId": "23920595", "CommentCount": "0", "Body": "<p>According to the standard at \u00a723.3.6.2/10, there are no reallocations as long as the iterators are forward iterators, bidirectional iterators, or random access iterators. There are O(log N) reallocations if the iterators are input iterators.</p>\n<p>Note: <code>std::list</code> has bidirectional iterators.</p>\n<p>How is this implemented, you ask? Presumably, it makes one pass to calculate the distance between the two iterators (or calls <code>std::distance</code> or an internal version) and then makes another pass to actually initialize the vector.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "23920663", "Score": "2", "CreationDate": "2014-05-28T19:52:22.050", "LastActivityDate": "2014-05-28T19:52:22.050"}, "23920595": {"CommentCount": "1", "ViewCount": "367", "CreationDate": "2014-05-28T19:48:35.737", "LastActivityDate": "2014-05-28T20:23:09.840", "Title": "Performance of vector initialization in C++", "AcceptedAnswerId": "23920678", "PostTypeId": "1", "Id": "23920595", "Score": "1", "Body": "<p>Suppose you initialize a vector from another container:</p>\n<pre><code>main()\n{\n    list&lt;int&gt; L { 0, 1, 2 };\n    vector&lt;int&gt; V ( L.begin(), L.end() );\n    copy ( V.begin(), V.end(), ostream_iterator&lt;int&gt; ( cout, \" \" ) );\n    cout &lt;&lt; endl;\n}\n</code></pre>\n<p>Does the vector size get set once, or is it dynamically resized during initialization?  (Not an issue in this example as the source has few elements, but could be an issue if the source has very many elements.)</p>\n", "Tags": "<c++><performance><vector><initialization>", "OwnerUserId": "890753", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_23920595_23920678_0": {"section_id": 965, "quality": 0.6666666666666666, "length": 6}, "so_23920595_23920678_1": {"section_id": 966, "quality": 0.9032258064516129, "length": 28}}, "n3337": {"so_23920595_23920678_0": {"section_id": 953, "quality": 0.6666666666666666, "length": 6}, "so_23920595_23920678_1": {"section_id": 954, "quality": 0.9032258064516129, "length": 28}}, "n4659": {"so_23920595_23920678_0": {"section_id": 1027, "quality": 0.6666666666666666, "length": 6}, "so_23920595_23920678_1": {"section_id": 1028, "quality": 0.9032258064516129, "length": 28}}}});