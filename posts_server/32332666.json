post_cb({"32332892": {"Id": "32332892", "PostTypeId": "2", "Body": "<p>As the error message states : In <code>D</code> <code>func</code> is not a member function, thus you cannot provide a definition for it. It is a member with type <code>S&lt;X,6&gt;::func</code>.</p>\n", "LastActivityDate": "2015-09-01T13:26:11.173", "CommentCount": "1", "CreationDate": "2015-09-01T13:26:11.173", "ParentId": "32332666", "Score": "0", "OwnerUserId": "3984892"}, "32332666": {"ViewCount": "572", "Body": "<p>Consider the following code:</p>\n<pre><code>template&lt;int X, int Y&gt;\nstruct S\n{\n    typedef int func(int,float) const;\n};\n\ntemplate&lt;int X&gt;\nstruct D : public S&lt;X,6&gt;\n{\n    typename S&lt;X,6&gt;::func func;\n};\ntemplate&lt;int X&gt;\nint D&lt;X&gt;::func(int,float) const\n{\n    return 1;\n}\n//----------------\nstruct W : public S&lt;7,8&gt;\n{\n    S&lt;7,8&gt;::func func;\n};\nint W::func(int,float) const\n{\n    return 2;\n}\n\n#include &lt;iostream&gt;\nint main()\n{\n    W w;\n    std::cout &lt;&lt; w.func(1,4.3) &lt;&lt; \"\\n\";\n    D&lt;3&gt; d;\n    std::cout &lt;&lt; d.func(1,4.3) &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>If I comment out the code declaring class <code>D</code> and <code>D::func()</code> as well as the corresponding lines in <code>main()</code>, the code compiles normally, and I see <code>2</code> in output, as expected.</p>\n<p>But when I make the derived class template (adding <code>typename</code> before function declaration, as <code>S&lt;X.6&gt;</code> is a dependent scope), I get the following errors:</p>\n<pre><code>test.cpp:13:27: error: no \u2018int D&lt;X&gt;::func(int, float) const\u2019 member function declared in class \u2018D&lt;X&gt;\u2019\n int D&lt;X&gt;::func(int,float) const\n                           ^\ntest.cpp: In instantiation of \u2018struct D&lt;3&gt;\u2019:\ntest.cpp:32:10:   required from here\ntest.cpp:10:27: error: field \u2018D&lt;3&gt;::func\u2019 invalidly declared function type\n     typename S&lt;X,6&gt;::func func;\n                           ^\n</code></pre>\n<ul>\n<li>Why can't I declare <code>func</code> in a template derived class, while in non-template class it's OK?</li>\n<li>What exactly is \"invalidly declared function type\"? what is invalid here?</li>\n</ul>\n", "AcceptedAnswerId": "32333629", "Title": "Why is this declaration of a function in template class invalid?", "CreationDate": "2015-09-01T13:15:05.203", "Id": "32332666", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-09-01T14:45:41.180", "Score": "8", "OwnerUserId": "673852", "Tags": "<c++><templates><methods><types>", "AnswerCount": "2"}, "32333629": {"Id": "32333629", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_32332666_32333629_0\"><code>N3337 [dcl.fct]/10:</code> A <code>typedef</code> of function type may be used to declare a function but shall not be used to define a function.</p>\n</blockquote>\n<p>By this rule, both <code>D</code> and <code>W</code> are technically well-formed. I think the reason this doesn't compile with GCC or Clang is that declaring a function with a typedef is really rare. Declaring a function with a member typedef dependent on a template parameter is even rarer. Looks like you've just hit on a dark corner where compiler support is limited.</p>\n<p>Funnily enough, MSVC actually <a href=\"http://rextester.com/WFML36390\" rel=\"nofollow\">does the right thing</a> here.</p>\n<p>Your best option is probably to find a different way to express your classes. I can't really give any directed advice without knowing more about the problem you are trying to solve, but if you ask a new question with details we can give some suggestions.</p>\n<p>You might also think about filing a bug report for <a href=\"https://gcc.gnu.org/bugs/\" rel=\"nofollow\">GCC</a> and <a href=\"http://llvm.org/docs/HowToSubmitABug.html\" rel=\"nofollow\">Clang</a>.</p>\n<hr>\n<p>Edit:</p>\n<p>However, as Jarod42 pointed out, the dependent type could later be defined as something other than a function type, making the declaration invalid. The reason MSVC works where GCC and Clang does not is the same reason MSVC doesn't require <code>typename</code> in some places: it doesn't correctly implement two-phase lookup. Having this case fully specified would require something like <code>function_typename</code> to mark a dependent name as being a function type. I think declaring a function based on a dependent type is underspecified and inconsistent as a result of this being a very rare case.</p>\n</hr>", "LastEditorUserId": "496161", "LastActivityDate": "2015-09-01T14:45:41.180", "Score": "3", "CreationDate": "2015-09-01T13:58:58.973", "ParentId": "32332666", "CommentCount": "3", "OwnerUserId": "496161", "LastEditDate": "2015-09-01T14:45:41.180"}, "bq_ids": {"n4140": {"so_32332666_32333629_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 3246}}, "n3337": {"so_32332666_32333629_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 3119}}, "n4659": {"so_32332666_32333629_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 4004}}}});