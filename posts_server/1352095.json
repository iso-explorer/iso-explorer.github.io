post_cb({"1352135": {"Id": "1352135", "PostTypeId": "2", "Body": "<p><code>Color(3)</code> is a cast, with the same semantic as <code>(Color)3</code>, it isn't a constructor.  Note that you can also use <code>static_cast&lt;Color&gt;(3)</code> for the same conversion but you can't use <code>Color x(3)</code>.</p>\n", "LastEditorUserId": "39375", "LastActivityDate": "2009-08-29T19:00:54.693", "Score": "1", "CreationDate": "2009-08-29T18:59:58.643", "ParentId": "1352095", "CommentCount": "0", "OwnerUserId": "136208", "LastEditDate": "2009-08-29T19:00:54.693"}, "1352161": {"Id": "1352161", "PostTypeId": "2", "Body": "<p>Both the C and the C++ standards are kind of confusing on the subject of enums. Both insist that enums are \"distinct types\" but then both treat them as the underlying integral type. C++ even refers to an italic term \"underlying type\" which is only sort-of defined when introducing wchar_t.</p>\n<p>In summary, wchar_t and enum types are \"distinct\" but simply mapped to an underlying integral type chosen by the implementation, and this is no doubt due to the need to be compatible with historical enum which was definitely just an int.</p>\n<p>Modern compilers typically have options to add more type-like behavior to enums, turning on warnings and errors for various misuses. These can't be a default because they elect non-conforming behavior.</p>\n", "LastActivityDate": "2009-08-29T19:10:52.787", "CommentCount": "1", "CreationDate": "2009-08-29T19:10:52.787", "ParentId": "1352095", "Score": "0", "OwnerUserId": "140740"}, "1352095": {"ViewCount": "1213", "Body": "<p>I would expect the following code snippet to complain about trying to assign something other that 0,1,2 to a Color variable.\nBut the following does compile and I get the output </p>\n<p>Printing:3</p>\n<p>3</p>\n<p>Can anybody explain why? Is enum not meant to be a true user-defined type? Thanks.</p>\n<pre><code>enum Color { blue=0,green=1,yellow=2};\n\nvoid print_color(Color x);\n\nint main(){\n    Color x=Color(3);\n\n    print_color(x);\n    std::cout &lt;&lt; x &lt;&lt; std::endl;\n\n    return 0;\n}\n\nvoid print_color(Color x)\n{\n    std::cout &lt;&lt; \"Printing:\" &lt;&lt; x &lt;&lt; std::endl;\n}\n</code></pre>\n", "AcceptedAnswerId": "1352111", "Title": "typechecking provided on enum", "CreationDate": "2009-08-29T18:46:09.530", "Id": "1352095", "CommentCount": "0", "LastEditDate": "2009-08-29T18:48:57.917", "PostTypeId": "1", "LastEditorUserId": "21886", "LastActivityDate": "2009-08-29T19:33:46.030", "Score": "1", "OwnerUserId": "160831", "Tags": "<c++><enums>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_1352095_1352111_0": {"length": 19, "quality": 0.5277777777777778, "section_id": 5467}}, "n3337": {"so_1352095_1352111_0": {"length": 19, "quality": 0.5277777777777778, "section_id": 5253}}, "n4659": {"so_1352095_1352111_0": {"length": 19, "quality": 0.5277777777777778, "section_id": 6901}}}, "1352110": {"Id": "1352110", "PostTypeId": "2", "Body": "<p>Enum in C++ is more of a set of named integer constants than a true type, from compile-time checking point of view. However, the C++ standard has this to say [dcl.enum]:</p>\n<p>9 An expression of arithmetic or enumeration type can be converted to an\n  enumeration  type  explicitly.  The value is unchanged if it is in the\n  range of enumeration values of the  enumeration  type;  otherwise  the\n  resulting enumeration value is unspecified.</p>\n<p>\"Unspecified\" is slightly better than the usual \"undefined behavior\".</p>\n", "LastActivityDate": "2009-08-29T18:52:25.287", "CommentCount": "2", "CreationDate": "2009-08-29T18:52:25.287", "ParentId": "1352095", "Score": "0", "OwnerUserId": "3458"}, "1352111": {"Id": "1352111", "PostTypeId": "2", "Body": "<p>Since you manually cast the <code>3</code> to <code>Color</code>, the compiler will allow you to do that. If you tried to initialize the variable <code>x</code> with a plain <code>3</code> without a cast, you would get a diagnostic. </p>\n<p>Note that the range of values an enumeration can store is not limited by the enumerators it contains. It's the range of values of the smallest bitfield that can store all enumerator values of the enumeration. That is, the range of your enumeration type is <code>0..3</code>:</p>\n<pre><code>00\n01\n10\n11\n</code></pre>\n<p>The value <code>3</code> is thus still in range, and so the code is valid. Had you cast a <code>4</code>, then the resulting value would be left unspecified by the C++ Standard. </p>\n<p>In practice, the implementation has to chose an underlying integer type for the enumeration. The smallest type it can choose is <code>char</code>, but which is still able to at least store values ranging up to <code>127</code>. But as mentioned, the compiler is not required to convert a <code>4</code> to a value of <code>4</code>, because it's outside the range of your enumeration. </p>\n<hr>\n<p>I figure i should post some explanation on the difference of \"underlying type\" and \"range of enumeration values\". The range of values for any type is the smallest and largest value of that type. The underlying type of an enumeration must be able to store the value of any enumerator (of course) - and two enumerations that have the same underlying type are layout compatible (this allows some flexibility in case a type mismatch occurs). </p>\n<p>So while the underlying type is meant to fix the object representation (alignment and size), the values of the enumeration is defined as follows in <code>7.2/6</code></p>\n<blockquote>\n<p id=\"so_1352095_1352111_0\">For an enumeration where e<sub>min</sub> is the smallest enumerator and e<sub>max</sub> is the largest, the values of the enumeration are the values of the underlying type in the range b<sub>min</sub> to b<sub>max</sub>, where b<sub>min</sub> and b<sub>max</sub> are, respectively, the smallest and largest values of the smallest bit-field that can store e<sub>min</sub> and e<sub>max</sub> . It is possible to define an enumeration that has values not defined by any of its enumerators.</p>\n<p id=\"so_1352095_1352111_1\">[Footnote:  On a two\u2019s-complement machine, b<sub>max</sub> is the smallest value greater than or equal to <code>max (abs(</code>e<sub>min</sub><code>) \u2212 1 ,abs(</code>e<sub>max</sub><code>))</code> of the form\n  2<sup>M</sup>\u22121; b<sub>min</sub> is zero if e<sub>min</sub> is non-negative and <code>\u2212(</code>b<sub>min</sub><code>+1)</code> otherwise.]</p>\n</blockquote>\n</hr>", "LastEditorUserId": "34509", "LastActivityDate": "2009-08-29T19:33:46.030", "Score": "4", "CreationDate": "2009-08-29T18:53:40.527", "ParentId": "1352095", "CommentCount": "2", "OwnerUserId": "34509", "LastEditDate": "2009-08-29T19:33:46.030"}});