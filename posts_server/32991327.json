post_cb({"32991637": {"ParentId": "32991327", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-10-07T11:59:08.147", "Score": "6", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:15:47.903", "Id": "32991637", "OwnerUserId": "1708801", "Body": "<p>This language was added by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html\" rel=\"nofollow noreferrer\">N3664: Clarifying Memory Allocation</a> which allows the implementation to fuse allocations when the allocations are not part of the observable behavior. In other words the allocation can be <em>extended</em>. </p>\n<p>The function call itself is not extended but the function call and hence the allocation <em>may be omitted</em> and the <em>allocations may be lumped</em> together into a larger allocation later on.</p>\n<p>The proposal states the problem (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_32991327_32991637_0\">As strict reading of the current C and C++ standards may lead one to\n  conclude that the allocation strategy shall not consider any\n  information not derivable from the sequence of new and delete\n  expressions. In essence, the standards may exclude macro-optimization\n  of allocation.</p>\n<p id=\"so_32991327_32991637_1\">On the other hand, a <strong>strict reading of the standards may lead one to\n  conclude that the implementation must make an allocation function call\n  for each and every new expression</strong>. This reading may exclude\n  micro-optimization of allocation.</p>\n</blockquote>\n<p>and proposes:</p>\n<blockquote>\n<p id=\"so_32991327_32991637_2\">We propose to replace existing mechanistic wording with wording more\n  precisely focused on essential requirements. <strong>The intent is to enable\n  behavior that some existing compilers and memory allocators already\n  have</strong>. For example, see TCMalloc</p>\n</blockquote>\n<p>and further says:</p>\n<blockquote>\n<p id=\"so_32991327_32991637_3\">An essential requirement on implementations is that they deliver\n  usable memory, <strong>not that they have a particular sequence of allocation\n  calls</strong>. We propose to relax the allocation calls with respect to new\n  expressions.</p>\n<ol>\n<li><p id=\"so_32991327_32991637_4\">Within certain constraints, the number of allocation calls is not part of the observable behavior of the program. This <strong>enables\n  implementations to reduce the number of allocation calls by avoiding\n  them or fusing them</strong>.</p></li>\n<li><p id=\"so_32991327_32991637_5\">When avoiding or fusing allocations, the amount of space requested does not exceed that implied by the new expressions, with the\n  exception of additional padding to meet alignment constraints. This\n  means that the amount of space allocated does not increase peak\n  allocation.</p></li>\n</ol>\n<p id=\"so_32991327_32991637_6\">Because C++ class-specific memory allocators are often tuned to\n  specific class sizes, we do not apply this relaxation to those\n  allocators.</p>\n</blockquote>\n<p>This can lead to allocations being completely omitted which can be surprising in some cases. We can see for the following example taken from <a href=\"https://stackoverflow.com/q/31873616/1708801\">this question</a>:</p>\n<pre><code>#include &lt;new&gt;  \n\nint main()\n{\n    int* mem = new (std::nothrow) int[100];\n    return 0;\n}\n</code></pre>\n<p>clang optimizes this to (<em><a href=\"http://goo.gl/wvPt6B\" rel=\"nofollow noreferrer\">see it live via godbolt</a></em>):</p>\n<pre><code>main:                                   # @main\n    xorl    %eax, %eax\n    retq\n</code></pre>\n<p>This is allowable because no observable behavior is effected, so this falls under the umbrella of the <a href=\"http://en.cppreference.com/w/cpp/language/as_if\" rel=\"nofollow noreferrer\">as-if rule</a>.</p>\n", "LastActivityDate": "2015-12-17T14:02:08.500"}, "bq_ids": {"n4140": {"so_32991327_32991327_1": {"section_id": 6093, "quality": 1.0, "length": 36}, "so_32991327_32991327_0": {"section_id": 6092, "quality": 0.9292929292929293, "length": 92}}, "n3337": {"so_32991327_32991327_0": {"section_id": 5859, "quality": 0.8484848484848485, "length": 84}}, "n4659": {"so_32991327_32991327_1": {"section_id": 7589, "quality": 1.0, "length": 36}, "so_32991327_32991327_0": {"section_id": 7588, "quality": 0.9393939393939394, "length": 93}}}, "32991327": {"CommentCount": "1", "ViewCount": "236", "CreationDate": "2015-10-07T11:44:44.730", "LastActivityDate": "2015-12-17T14:02:08.500", "Title": "I think I can understand \u00a75.3.4/11 in N4140, but the notion of an allocation function which has been extended is incomprehensible to me", "PostTypeId": "1", "Id": "32991327", "Score": "6", "Body": "<p>The two paragraphs below were copied from N4140 (emphasis are mine).</p>\n<p>\u00a75.3.4/11:</p>\n<blockquote>\n<p id=\"so_32991327_32991327_0\">When a <em>new-expression</em> calls an allocation function and that\n  allocation has <strong>not</strong> <strong>been extended</strong>, the <em>new-expression</em> passes the\n  amount of space requested to the allocation function as the first\n  argument of type <code>std::size_t</code>. That argument shall be no less than\n  the size of the object being created; it may be greater than the size\n  of the object being created only if the object is an array. For\n  arrays of <code>char</code> and <code>unsigned char</code>, the difference between the\n  result of the <em>new-expression</em> and the address returned by the\n  allocation function shall be an integral multiple of the strictest\n  fundamental alignment requirement (3.11) of any object type whose size\n  is no greater than the size of the array being created. [ Note:\n  Because allocation functions are assumed to return pointers to storage\n  that is appropriately aligned for objects of any type with fundamental\n  alignment, this constraint on array allocation overhead permits the\n  common idiom of allocating character arrays into which objects of\n  other types will later be placed. \u2014end note ]</p>\n</blockquote>\n<p>\u00a75.4.3/12</p>\n<blockquote>\n<p id=\"so_32991327_32991327_1\">When a <em>new-expression</em> calls an allocation function and that\n  allocation <strong>has</strong> <strong>been extended</strong>, the size argument to the\n  allocation call shall be no greater than the sum of the sizes for\n  the omitted calls as specified above, plus the size for the extended\n  call had it not been extended, plus any padding necessary to align the\n  allocated objects within the allocated memory.</p>\n</blockquote>\n<p>I can understand \u00a75.3.4/11, but the notion of an allocation function which has been extended is incomprehensible to me, as stated above in \u00a75.4.3/12.</p>\n", "Tags": "<c++><language-lawyer><new-operator><c++14>", "OwnerUserId": "1042389", "AnswerCount": "1"}});