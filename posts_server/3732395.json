post_cb({"bq_ids": {"n4140": {"so_3732395_3732395_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 1188}}, "n3337": {"so_3732395_3732395_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 1186}}, "n4659": {"so_3732395_3732395_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 1269}}}, "3732406": {"Id": "3732406", "PostTypeId": "2", "Body": "<p>Do what you want. It doesn't matter.</p>\n<p>When ISO state that you \"shall not do something\", doing it is undefined behaviour. If a user does that, they have violated the contract with the implementation, and the implementation is within its rights to do as it pleases.</p>\n<p>What you decide to do is entirely up to you. I would opt for whatever makes your implementation \"better\" (in your eyes, be that faster, more readable, subject to the principle of least astonishment, and so forth).</p>\n<p>Myself, I'd go for readability (since I would have to maintain the thing) with speed taking a close second.</p>\n", "LastEditorUserId": "14860", "LastActivityDate": "2016-02-06T13:13:58.273", "Score": "9", "CreationDate": "2010-09-17T03:01:19.053", "ParentId": "3732395", "CommentCount": "0", "OwnerUserId": "14860", "LastEditDate": "2016-02-06T13:13:58.273"}, "3732634": {"Id": "3732634", "PostTypeId": "2", "Body": "<p>I'd rather get vaguey sane behaviour that something crazy.</p>\n<p>Well, as a potential consumer of your library, here's what I'd like: if there's no performance cost to the documented usage, then see if one of the memory_order values provides a functional superset of the others, particularly something corresponding to what a caller might naively expect the unsupported modes to do (if any sensible expectation can be formed).  The caller may get the slowest, safest mode, but that's better than something functionally wrong.  You minimise the client code's dependency on getting everything perfect for your code.  The problem with this - compared to an assert/exception - is that it can go unnoticed in a test environment, so consider also writing an explanation to std::cerr, using a static variable to limit the messages to one per process run.  That's a very useful diagnostic.</p>\n<p>An exception, fatal assertion etc. might bring down a client application at a very inconvenient moment....  Seems a bit draconian, and not something I'd appreciate particularly.  Another option is to have an environment variable control this behaviour.</p>\n<p>(There's presumably a similar issue for values that aren't even in your current enumeration.)</p>\n", "LastActivityDate": "2010-09-17T04:21:32.267", "CommentCount": "10", "CreationDate": "2010-09-17T04:21:32.267", "ParentId": "3732395", "Score": "0", "OwnerUserId": "410767"}, "3732395": {"ViewCount": "551", "Body": "<p>I'm attempting to implement the atomic library from the C++0x draft.  Specifically, I'm implementing \u00a729.6/8, the <em>store</em> method:</p>\n<pre><code>template &lt;typename T&gt;\nvoid atomic&lt;T&gt;::store(T pDesired, memory_order pOrder = memory_order_seq_cst);\n</code></pre>\n<p>The requirement states:</p>\n<blockquote>\n<p id=\"so_3732395_3732395_0\">The order argument shall not be memory_order_consume, memory_order_acquire, nor memory_order_acq_rel.</p>\n</blockquote>\n<p>I'm not sure what to do if it is one of these. Should I do nothing, throw an exception, get undefined behavior, or do something else?</p>\n<p><sub>P.S.: \"C++0X\" looks kinda like a dead fish :3</sub></p>\n", "AcceptedAnswerId": "3732406", "Title": "Implementing atomic<T>::store", "CreationDate": "2010-09-17T02:57:15.737", "Id": "3732395", "CommentCount": "1", "LastEditDate": "2010-09-18T18:45:14.230", "PostTypeId": "1", "LastEditorDisplayName": "Roger Pate", "LastActivityDate": "2016-02-06T13:13:58.273", "Score": "7", "OwnerUserId": "450188", "Tags": "<c++><c++11><atomic><std>", "AnswerCount": "3"}, "3763350": {"Id": "3763350", "PostTypeId": "2", "Body": "<p>I prefer a compile time error. If not that, then an assert() failure.</p>\n<p>Assert is good because it compiles out of the release version and will not impact performance.</p>\n<p>Compile time errors are even better because they provide more immediate feedback without waiting for the software to trip over the bug. Compile time error checks are a thing I love about C++ code over Python, Ruby, Perl code.</p>\n", "LastActivityDate": "2010-09-21T18:35:42.650", "CommentCount": "0", "CreationDate": "2010-09-21T18:35:42.650", "ParentId": "3732395", "Score": "0", "OwnerUserId": "13422"}});