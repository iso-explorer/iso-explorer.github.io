post_cb({"bq_ids": {"n4140": {"so_17457579_19258426_0": {"length": 17, "quality": 0.7391304347826086, "section_id": 3298}}, "n3337": {"so_17457579_19258426_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 3168}}, "n4659": {"so_17457579_19258426_0": {"length": 12, "quality": 0.5217391304347826, "section_id": 4063}}}, "17457579": {"ViewCount": "318", "Body": "<p>If all of your class/struct data members lack initializers, you can use uniform initialization syntax to construct the object.</p>\n<pre><code>struct foo\n{\n    int i;\n    float f;\n};\n...\nfoo bar{ 5, 3.141f };\n</code></pre>\n<p>But if one or more members have initializers, uniform initialization syntax becomes invalid.</p>\n<pre><code>struct foo\n{\n    int i;\n    float f = 0;\n};\n...\nfoo bar{ 5, 3.141f };  // Compiler error.\n</code></pre>\n<p>I surmise that the addition of a data member initializer automatically implements one or more default constructors and suppresses the default implementation of the <code>initialization_list</code> constructor. Is that the intended standard? Why does it work this way?</p>\n", "AcceptedAnswerId": "19258426", "Title": "Why do non-static data member initializers defeat uniform initialization syntax?", "CreationDate": "2013-07-03T20:31:08.887", "Id": "17457579", "CommentCount": "3", "LastEditDate": "2013-07-04T18:44:03.893", "PostTypeId": "1", "LastEditorUserId": "1774667", "LastActivityDate": "2013-10-08T22:10:37.560", "Score": "5", "OwnerUserId": "358475", "Tags": "<c++><c++11><constructor><initialization-list>", "AnswerCount": "1"}, "19258426": {"Id": "19258426", "PostTypeId": "2", "Body": "<p>Yes, this is intended by the standard.  What you are attempting here is <em>aggregate initialization</em>.  Unfortunately, your second <code>foo</code> is no longer considered an aggregate due to the equal initializer of <code>f</code>.  See <em>8.5.1 [dcl.init.aggr]</em> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_17457579_19258426_0\">An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), <strong>no brace-or-equalinitializers for non-static data members (9.2)</strong>, no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>Because you have an equal initializer for the member <code>f</code>, you will need to provide a custom constructor to support the syntax you are after:</p>\n<pre><code>struct foo\n{\n  int i;\n  float f = 0;\n  constexpr foo(int i, float f) : i(i), f(f) { }\n};\n...\nfoo bar{ 5, 3.141f }; // now okay\n</code></pre>\n<p>As to <em>why</em> this was specified in the standard, I have no idea.</p>\n", "LastEditorUserId": "1651000", "LastActivityDate": "2013-10-08T22:10:37.560", "Score": "1", "CreationDate": "2013-10-08T21:06:59.393", "ParentId": "17457579", "CommentCount": "1", "OwnerUserId": "1651000", "LastEditDate": "2013-10-08T22:10:37.560"}});