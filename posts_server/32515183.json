post_cb({"32515264": {"ParentId": "32515183", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>GCC bug. [dcl.spec.auto]/p7 (quoting N4527):</p>\n<blockquote>\n<p id=\"so_32515183_32515264_0\">When a variable declared using a placeholder type is initialized,\n  [...] the deduced return type or variable type is determined from the\n  type of its initializer. [...] Otherwise, let <code>T</code> be the declared type\n  of the variable [...]. If the placeholder is the <code>auto</code>\n<em>type-specifier</em>, the deduced type is determined using the rules for template argument deduction. If the initialization is\n  <em>direct-list-initialization</em> [...]. [...] Otherwise, obtain <code>P</code> from <code>T</code> by replacing the occurrences of <code>auto</code> with either a new invented\n  type template parameter <code>U</code> or, if the initialization is\n  <em>copy-list-initialization</em>, with <code>std::initializer_list&lt;U&gt;</code>. Deduce a value for <code>U</code> using the rules of template argument deduction from a\n  function call (14.8.2.1), where <code>P</code> is a function template parameter\n  type and the corresponding argument is the initializer [...]. If the\n  deduction fails, the declaration is ill-formed. Otherwise, the type\n  deduced for the variable or return type is obtained by substituting\n  the deduced <code>U</code> into <code>P</code>.</p>\n</blockquote>\n<p>Thus, in <code>const auto l2 = { 1, 2, 3 };</code>, deduction is performed as if for the function template</p>\n<pre><code>template&lt;class U&gt; void meow(const std::initializer_list&lt;U&gt;);\n</code></pre>\n<p>given the call <code>meow({1, 2, 3})</code>.</p>\n<p>Now consider the const-less case <code>auto l3 = { 1, 2, 3 };</code> (which GCC correctly deduces as <code>std::initializer_list&lt;int&gt;</code>). Deduction in this case is performed as if for the function template</p>\n<pre><code>template&lt;class U&gt; void purr(std::initializer_list&lt;U&gt;);\n</code></pre>\n<p>given the call <code>purr({1, 2, 3})</code>.</p>\n<p>Since top-level cv-qualification of function parameters are ignored, it should be obvious that the two deduction should yield the same type.</p>\n<hr>\n<p>[temp.deduct.call]/p1:</p>\n<blockquote>\n<p id=\"so_32515183_32515264_1\">Template argument deduction is done by comparing each function\n  template parameter type (call it <code>P</code>) with the type of the\n  corresponding argument of the call (call it <code>A</code>) as described below.\n  If <code>P</code> is a dependent type, removing references and cv-qualifiers from\n  <code>P</code> gives <code>std::initializer_list&lt;P'&gt;</code> [...] for some <code>P'</code> [...] and\n  the argument is a non-empty initializer list (8.5.4), then deduction\n  is performed instead for each element of the initializer list, taking\n  <code>P'</code> as a function template parameter type and the initializer element\n  as its argument.</p>\n</blockquote>\n<p>Deducing <code>P'</code> (which is <code>U</code>) against <code>1</code>, <code>2</code>, or <code>3</code>, all literals of type <code>int</code>, obviously yields <code>int</code>.</p>\n</hr>", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2015-09-11T04:13:25.470", "Id": "32515264", "Score": "6", "CreationDate": "2015-09-11T04:05:39.287", "LastActivityDate": "2015-09-11T04:13:25.470"}, "32515183": {"CommentCount": "2", "ViewCount": "449", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-09-11T03:54:37.013", "LastActivityDate": "2015-09-11T12:11:32.307", "Title": "const auto std::initializer_list difference between Clang and GCC", "AcceptedAnswerId": "32515264", "LastEditDate": "2015-09-11T12:11:32.307", "Id": "32515183", "Score": "10", "Body": "<p>I am trying to understand what the correct behavior of C++11 should be when combining initialization lists and <code>const auto</code>. I am getting different behavior between GCC and Clang for the following code and would like to know which is the correct one:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n#include &lt;vector&gt;\n\nint main()\n{\n    const std::initializer_list&lt;int&gt; l1 = { 1, 2, 3 };\n    const auto l2 = { 1, 2, 3 };\n\n    std::cout &lt;&lt; \"explicit: \" &lt;&lt; typeid(l1).name() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"auto:     \" &lt;&lt; typeid(l2).name() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Compiled with g++ the output is:</p>\n<pre><code>explicit: St16initializer_listIiE\nauto:     St16initializer_listIKiE\n</code></pre>\n<p>While the clang++ compiled version produces:</p>\n<pre><code>explicit: St16initializer_listIiE\nauto:     St16initializer_listIiE\n</code></pre>\n<p>It seems that GCC is turning the <code>auto</code> line into a <code>std::initializer_list&lt;const int&gt;</code> while Clang produces <code>std::initializer_list&lt;int&gt;</code>. The GCC version creates a problem when I use it to initialize a <code>std::vector</code>. So the following works under Clang but produces a compiler error for GCC. </p>\n<pre><code>// Compiles under clang but fails for GCC because l4\nstd::vector&lt;int&gt; v2 { l2 };\n</code></pre>\n<p>If GCC is producing the correct version then it seems to suggest that the various STL containers should be extended to include another list initializer overload for these cases. </p>\n<p>Note: this behavior seems to be consistent across multiple versions of GCC (4.8, 4.9, 5.2) and Clang (3.4 and 3.6).</p>\n", "Tags": "<c++><c++11><gcc><stl><clang>", "OwnerUserId": "2749393", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_32515183_32515251_2": {"section_id": 5451, "quality": 0.9487179487179487, "length": 74}, "so_32515183_32515251_4": {"section_id": 5451, "quality": 0.9090909090909091, "length": 10}, "so_32515183_32515264_1": {"section_id": 302, "quality": 0.9166666666666666, "length": 44}, "so_32515183_32515264_0": {"section_id": 5451, "quality": 0.875, "length": 70}}, "n3337": {"so_32515183_32515251_4": {"section_id": 5246, "quality": 0.9090909090909091, "length": 10}, "so_32515183_32515264_1": {"section_id": 293, "quality": 0.9166666666666666, "length": 44}}, "n4659": {"so_32515183_32515251_4": {"section_id": 6889, "quality": 0.9090909090909091, "length": 10}, "so_32515183_32515264_0": {"section_id": 6889, "quality": 0.6, "length": 48}, "so_32515183_32515264_1": {"section_id": 309, "quality": 0.9375, "length": 45}}}, "32515251": {"ParentId": "32515183", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>There is a gcc bug report <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63149\" rel=\"nofollow\">wrong auto deduction from braced-init-list</a> about this and similar cases and Richard Smith  indicates it is a gcc bug:</p>\n<blockquote>\n<p id=\"so_32515183_32515251_0\">Even simpler testcase:</p>\n<pre><code>#include &lt;initializer_list&gt;\nconst auto r = { 1, 2, 3 };\nusing X = decltype(r);\nusing X = const std::initializer_list&lt;int&gt;;\n</code></pre>\n<p id=\"so_32515183_32515251_1\">fails because <code>decltype(r)</code> is deduced as <code>const std::initializer_list&lt;const int&gt;</code> rather than <code>const std::initializer_list&lt;int&gt;</code>.</p>\n</blockquote>\n<p>The section of the draft C++ standard would be section <code>7.1.6.4</code> <em>[dcl.spec.auto]</em> which says:</p>\n<blockquote>\n<p id=\"so_32515183_32515251_2\">When a variable declared using a placeholder type is initialized, or a return statement occurs in a function\n  declared with a return type that contains a placeholder type, the deduced return type or variable type\n  is determined from the type of its initializer. [...] Let T be the declared type of the variable or return type of the function. If the\n  placeholder is the auto type-specifier, the deduced type is determined using the rules for template argument\n  deduction. [...] Otherwise, obtain P from T by replacing the occurrences of auto with either a\n  new invented type template parameter U or, if the initializer is a braced-init-list, with std::initializer_-\n  list. Deduce a value for U using the rules of template argument deduction from a function call (14.8.2.1),\n  where P is a function template parameter type and the initializer is the corresponding argument [...] [ Example:</p>\n<pre><code>auto x1 = { 1, 2 }; // decltype(x1) is std::initializer_list&lt;int&gt;\nauto x2 = { 1, 2.0 }; // error: cannot deduce element type\n</code></pre>\n<p id=\"so_32515183_32515251_3\">\u2014end example ] [ Example:</p>\n<pre><code>const auto &amp;i = expr;\n</code></pre>\n<p id=\"so_32515183_32515251_4\">The type of i is the deduced type of the parameter u in the call f(expr) of the following invented function template:</p>\n<pre><code>template &lt;class U&gt; void f(const U&amp; u);\n</code></pre>\n<p id=\"so_32515183_32515251_5\">\u2014end example ]</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-09-11T04:33:24.123", "Id": "32515251", "Score": "4", "CreationDate": "2015-09-11T04:04:29.543", "LastActivityDate": "2015-09-11T04:33:24.123"}});