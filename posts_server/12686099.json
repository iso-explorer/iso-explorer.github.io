post_cb({"bq_ids": {"n4140": {"so_12686099_12686210_0": {"length": 29, "quality": 0.6904761904761905, "section_id": 379}, "so_12686099_12686210_1": {"length": 18, "quality": 0.9, "section_id": 480}}, "n3337": {"so_12686099_12686210_0": {"length": 29, "quality": 0.6904761904761905, "section_id": 370}, "so_12686099_12686210_1": {"length": 18, "quality": 0.9, "section_id": 471}}, "n4659": {"so_12686099_12686210_1": {"length": 18, "quality": 0.9, "section_id": 502}}}, "12686210": {"Id": "12686210", "PostTypeId": "2", "Body": "<p>This is <strong>Copy Elision</strong><sup>Ref 1:</sup>.<br>\nCopy constructor calls while generating temporaries might be optimized by the compiler by creating objects inline and it is explicitly allowed by the C++ Standard.     </br></p>\n<p>This is nicely demonstrated in the standard with an example as well:      </p>\n<p><strong>C++03 Standard 12.2 Temporary objects [class.temporary]</strong><br>\n<strong>Para 2:</strong></br></p>\n<pre><code>[Example:\nclass X {\n    // ...\n    public:\n    // ...\n    X(int);\n    X(const X&amp;);\n    \u02dcX();\n};\nX f(X);\n\nvoid g()\n{\n    X a(1);\n    X b = f(X(2));\n    a = f(a);\n}\n</code></pre>\n<blockquote>\n<p id=\"so_12686099_12686210_0\">Here, an implementation might use a temporary in which to construct <code>X(2)</code> before passing it to <code>f()</code> using X\u2019s copy-constructor; alternatively, <code>X(2)</code> might be constructed in the space used to hold the argument. Also, a temporary might be used to hold the result of <code>f(X(2))</code> before copying it to <code>`b using</code>X<code>\u2019s copyconstructor; alternatively,</code>f()<code>\u2019s result might be constructed in b. On the other hand, the expression</code>a=f(a)<code>requires a temporary for either the argument a or the result of</code>f(a)<code>to avoid undesired aliasing of</code>a`. ]</p>\n</blockquote>\n<p><strong><sup>Ref 1:</sup></strong><br>\n<strong>C++03 12.8 Copying class objects [class.copy]</strong><br>\n<strong>Para 12:</strong> </br></br></p>\n<blockquote>\n<p id=\"so_12686099_12686210_1\"><strong>When certain criteria are met, an implementation is allowed to omit the copy construction of a class object</strong>, even if the copy constructor and/or destructor for the object have side effects.....</p>\n</blockquote>\n", "LastEditorUserId": "452307", "LastActivityDate": "2012-10-02T07:42:24.350", "Score": "5", "CreationDate": "2012-10-02T07:36:48.330", "ParentId": "12686099", "CommentCount": "0", "OwnerUserId": "452307", "LastEditDate": "2012-10-02T07:42:24.350"}, "12686099": {"ViewCount": "240", "Body": "<p>When I read about copy initializing vs direct initializing <a href=\"https://stackoverflow.com/questions/1051379/is-there-a-difference-in-c-between-copy-initialization-and-direct-initializati\">here</a>. copy constructor should call in copy initializing. why here copy constructor not calling? </p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass A{};\n\nclass B{\npublic:\nB(const A &amp;a){cout &lt;&lt; \"B construct from A\" &lt;&lt; endl;}\nB(const B &amp;b){cout &lt;&lt; \"B copy constructor\" &lt;&lt; endl;}\n};\n\nint main(){\nA a;\nB b = a;\nreturn 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "12686210", "Title": "Copy constructor not calling", "CreationDate": "2012-10-02T07:28:27.810", "Id": "12686099", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:18:49.447", "LastEditorUserId": "-1", "LastActivityDate": "2012-10-02T07:42:24.350", "Score": "4", "OwnerUserId": "1268258", "Tags": "<c++><constructor>", "AnswerCount": "2"}, "12686133": {"Id": "12686133", "PostTypeId": "2", "Body": "<p>Copy initialization is still subject to copy elision, and I'm guessing that's what's happening. Theoretically, a temporary <code>B</code> is constructed from <code>a</code> and the the copy constructor is used to create <code>b</code> from the temporary. In practice, the copy can be optimized out.</p>\n<p>To test this, you can make the copy constructor private:</p>\n<pre><code>class B{\npublic:\nB(const A &amp;a){cout &lt;&lt; \"B construct from A\" &lt;&lt; endl;}\nprivate:\nB(const B &amp;b){cout &lt;&lt; \"B copy constructor\" &lt;&lt; endl;}\n};\n</code></pre>\n<p>and get a compilation error. This means the compiler expects the copy constructor to be accessible, but is not required to call it.</p>\n<p>Copy elision is the only case where observed behavior can be altered.</p>\n", "LastActivityDate": "2012-10-02T07:30:57.890", "CommentCount": "9", "CreationDate": "2012-10-02T07:30:57.890", "ParentId": "12686099", "Score": "5", "OwnerUserId": "673730"}});