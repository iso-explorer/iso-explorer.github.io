post_cb({"8166008": {"Id": "8166008", "PostTypeId": "2", "Body": "<p>You really should use an unsigned short, to avoid language quirks on the high bit.</p>\n<pre><code>unsigned short myShort = (unsigned short)bits.to_ulong();\n</code></pre>\n", "LastActivityDate": "2011-11-17T11:01:53.037", "CommentCount": "0", "CreationDate": "2011-11-17T11:01:53.037", "ParentId": "8165980", "Score": "4", "OwnerUserId": "9990"}, "8166974": {"Id": "8166974", "PostTypeId": "2", "Body": "<p>As others have said, <code>to_ulong</code> will work. I was feeling some doubt whether the bit order was guaranteed until I looked at the Standard, C++03 \u00a723.3.5/3,</p>\n<blockquote>\n<p id=\"so_8165980_8166974_0\">When converting between an object of class bitset and a value of some integral type, bit position <code>pos</code> corresponds to the bit value <code>1 &lt;&lt; pos</code>. The integral value corresponding to two or more bits is the sum of their bit values.</p>\n</blockquote>\n<p>So, you can cast <code>to_ulong</code> to <code>unsigned short</code> (or better yet, <code>uint16_t</code>) with no worries about overflow or endianness.</p>\n", "LastActivityDate": "2011-11-17T12:19:45.507", "CommentCount": "1", "CreationDate": "2011-11-17T12:19:45.507", "ParentId": "8165980", "Score": "2", "OwnerUserId": "153285"}, "8165980": {"ViewCount": "1506", "Body": "<p>if i have a <code>bitset&lt;16&gt; bits(*iter)</code> and a my short\nhow i can assign this bist to my short?</p>\n<pre><code>short myShort = ??bits??\n</code></pre>\n<p>It's possible to convert a bitset&lt;16&gt; to short?</p>\n", "AcceptedAnswerId": "8166008", "Title": "How can i convert bitset into short in c++?", "CreationDate": "2011-11-17T10:58:59.630", "Id": "8165980", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-04-18T06:34:04.473", "Score": "5", "OwnerUserId": "534218", "Tags": "<c++><bit-manipulation><short><bitset>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_8165980_8166974_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 4111}}, "n3337": {"so_8165980_8166974_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 3954}}, "n4659": {"so_8165980_8166974_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 5376}}}, "8166035": {"Id": "8166035", "PostTypeId": "2", "Body": "<p>use <code>to_ulong</code> <a href=\"http://new.cplusplus.com/reference/stl/bitset/to_ulong/\" rel=\"nofollow\">http://new.cplusplus.com/reference/stl/bitset/to_ulong/</a></p>\n", "LastActivityDate": "2011-11-17T11:04:12.953", "CommentCount": "0", "CreationDate": "2011-11-17T11:04:12.953", "ParentId": "8165980", "Score": "0", "OwnerUserId": "1032731"}, "8166044": {"Id": "8166044", "PostTypeId": "2", "Body": "<pre><code>bitset&lt;16&gt; b;\n...   \nshort myShort = (short)b.to_ulong();\n</code></pre>\n", "LastActivityDate": "2011-11-17T11:04:39.247", "CommentCount": "0", "CreationDate": "2011-11-17T11:04:39.247", "ParentId": "8165980", "Score": "0", "OwnerUserId": "419761"}, "8166020": {"Id": "8166020", "PostTypeId": "2", "Body": "<p>I'd use the <code>to_ulong</code> method for this, and cast the result (since you know that only the lowest 16 bit will be used):</p>\n<pre><code>short myShort = static_cast&lt;short&gt;( bits.to_ulong() );\n</code></pre>\n", "LastActivityDate": "2011-11-17T11:02:37.613", "CommentCount": "0", "CreationDate": "2011-11-17T11:02:37.613", "ParentId": "8165980", "Score": "2", "OwnerUserId": "91757"}});