post_cb({"14388886": {"Id": "14388886", "PostTypeId": "2", "Body": "<p>There's no standard <code>BOOL</code> type, but <code>bool</code> is a standard fundamental type:</p>\n<blockquote>\n<p id=\"so_14388855_14388886_0\"><code>[C++11: 3.9.1/6]:</code> Values of type <code>bool</code> are either <code>true</code> or <code>false</code>. <em>[..]</em></p>\n</blockquote>\n<p>As for the result of your relational comparison:</p>\n<blockquote>\n<p id=\"so_14388855_14388886_1\"><code>[C++11: 5.9/1]:</code> The relational operators group left-to-right. <em>[..]</em> The operands shall have arithmetic, enumeration, or pointer type, or type <code>std::nullptr_t</code>. The operators <code>&lt;</code> (less than), <code>&gt;</code> (greater than), <code>&lt;=</code> (less than or equal to), and <code>&gt;=</code> (greater than or equal to) all yield <code>false</code> or <code>true</code>. <strong>The type of the result is <code>bool</code>.</strong></p>\n</blockquote>\n<p>Note that this is not the same in C, in which there is no built-in type <code>bool</code> and the result of relational comparisons is of type <code>int</code>:</p>\n<blockquote>\n<p id=\"so_14388855_14388886_2\"><code>[C99: 6.5/8]:</code> Each of the operators <code>&lt;</code> (less than), <code>&gt;</code> (greater than), <code>&lt;=</code> (less than or equal to), and <code>&gt;=</code> (greater than or equal to) shall yield <code>1</code> if the specified relation is true and <code>0</code> if it is false. <strong>The result has type <code>int</code>.</strong></p>\n</blockquote>\n", "LastActivityDate": "2013-01-17T21:58:58.460", "CommentCount": "1", "CreationDate": "2013-01-17T21:58:58.460", "ParentId": "14388855", "Score": "6", "OwnerUserId": "560648"}, "14388896": {"Id": "14388896", "PostTypeId": "2", "Body": "<p>The C++ standard, section 5.9 <strong>Relational operators</strong>, paragraph 1 says:</p>\n<blockquote>\n<p id=\"so_14388855_14388896_0\">The type of the result is <code>bool</code>.</p>\n</blockquote>\n", "LastActivityDate": "2013-01-17T21:59:37.520", "CommentCount": "0", "CreationDate": "2013-01-17T21:59:37.520", "ParentId": "14388855", "Score": "2", "OwnerUserId": "116908"}, "bq_ids": {"n4140": {"so_14388855_14388886_0": {"length": 6, "quality": 0.75, "section_id": 7215}, "so_14388855_14388887_1": {"length": 14, "quality": 1.0, "section_id": 26}, "so_14388855_14388886_2": {"length": 14, "quality": 0.6086956521739131, "section_id": 6149}, "so_14388855_14388887_0": {"length": 18, "quality": 0.9, "section_id": 6149}, "so_14388855_14388886_1": {"length": 28, "quality": 0.7777777777777778, "section_id": 6149}, "so_14388855_14388887_2": {"length": 27, "quality": 0.9642857142857143, "section_id": 7216}}, "n3337": {"so_14388855_14388886_0": {"length": 6, "quality": 0.75, "section_id": 6959}, "so_14388855_14388887_1": {"length": 14, "quality": 1.0, "section_id": 23}, "so_14388855_14388886_2": {"length": 14, "quality": 0.6086956521739131, "section_id": 5912}, "so_14388855_14388887_0": {"length": 18, "quality": 0.9, "section_id": 5912}, "so_14388855_14388886_1": {"length": 30, "quality": 0.8333333333333334, "section_id": 5912}, "so_14388855_14388887_2": {"length": 27, "quality": 0.9642857142857143, "section_id": 6960}}, "n4659": {"so_14388855_14388886_0": {"length": 6, "quality": 0.75, "section_id": 8724}, "so_14388855_14388887_1": {"length": 14, "quality": 1.0, "section_id": 26}, "so_14388855_14388886_2": {"length": 13, "quality": 0.5652173913043478, "section_id": 7646}, "so_14388855_14388887_0": {"length": 18, "quality": 0.9, "section_id": 7646}, "so_14388855_14388886_1": {"length": 28, "quality": 0.7777777777777778, "section_id": 7646}, "so_14388855_14388887_2": {"length": 27, "quality": 0.9642857142857143, "section_id": 8725}}}, "14388855": {"ViewCount": "120", "Body": "<p>Relizing there's no such thing as a <code>BOOL</code> datatype, take the following:</p>\n<p><code>std::cout &lt;&lt; (1&gt;2);  //&lt;&lt;-- prints 0</code></p>\n<p>Assuming this false comparison is a 0, what datatype deos the result of a comparison reduce to?  Doing a quick google search doesn't yield any results.  My best guess it that it's an <code>unsigned char</code> because it's the smallest most basic datatype where 0 truly represented as <code>0x00</code>.  I don't want to assume anything because I'm not sure what voodoo <code>std::cout</code> does to the value to make it a printable character.</p>\n", "AcceptedAnswerId": "14388887", "Title": "What datatype does the result of a binary comparison reduce to?", "CreationDate": "2013-01-17T21:57:22.080", "Id": "14388855", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-01-18T13:11:13.640", "LastEditorUserId": "348917", "LastActivityDate": "2013-01-18T20:47:48.263", "Score": "0", "OwnerUserId": "348917", "Tags": "<c++><types><comparison>", "AnswerCount": "4"}, "14389619": {"Id": "14389619", "PostTypeId": "2", "Body": "<p>This is not a direct answer to your question:</p>\n<p>as said here it is bool in c++ and int in c but you i think the part which you would think of is <strong>how much memory it takes to save a comparison result ?</strong></p>\n<ul>\n<li><p>as you know a data type defines how much memory to be allocated.  </p></li>\n<li><p>Note: sometimes it(data type to memory size definition) is <strong>different</strong> from compiler/processor architecture  to another for example in embedded systems environment people used to talk about and define data types in projects using number of bits e.g <code>typedef unsigned char uint8;</code> instead of using standard data types directly  so it would be easy to port to another compiler/target processor</p></li>\n<li><p>you should look at this: <a href=\"https://stackoverflow.com/questions/266870/why-is-a-char-and-a-bool-the-same-size-in-c\">Why is a char and a bool the same size in c++?</a></p></li>\n<li><p>you should look at this also <a href=\"http://www.cplusplus.com/doc/tutorial/variables\" rel=\"nofollow noreferrer\">http://www.cplusplus.com/doc/tutorial/variables</a> under \"Fundamental data types\" section a table of each data type and its size and range but he noted : </p></li>\n</ul>\n<blockquote>\n<p id=\"so_14388855_14389619_0\">The values of the columns Size and Range depend on the system the program is compiled for. The values shown above are those found on\n  most 32-bit systems. But for other systems, the general specification\n  is that int has the natural size suggested by the system architecture\n  (one \"word\") and the four integer types char, short, int and long must\n  each one be at least as large as the one preceding it, with char being\n  always one byte in size. The same applies to the floating point types\n  float, double and long double, where each one must provide at least as\n  much precision as the preceding one.</p>\n</blockquote>\n<ul>\n<li>as noted by sftrabbit about the standard in his answer that the standard is abstract enough and not detailed thus i think that the size of bool in memory is an implementation specific which may be different from c++ compiler to another , check Nawazs' answer here: <a href=\"https://stackoverflow.com/questions/7967924/how-a-bool-type-variable-is-stored-in-memory-c\">How a bool type variable is stored in memory? (C++)</a></li>\n</ul>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-01-18T20:47:48.263", "Score": "0", "CreationDate": "2013-01-17T22:51:55.417", "ParentId": "14388855", "CommentCount": "0", "OwnerUserId": "1009037", "LastEditDate": "2017-05-23T11:49:00.560"}, "14388887": {"Id": "14388887", "PostTypeId": "2", "Body": "<p>The type of the result of all relational operators (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) is <code>bool</code>:</p>\n<blockquote>\n<p id=\"so_14388855_14388887_0\">The operators <code>&lt;</code> (less than), <code>&gt;</code> (greater than), <code>&lt;=</code> (less than or equal to), and <code>&gt;=</code> (greater than or equal to) all yield <code>false</code> or <code>true</code>. The type of the result is <code>bool</code>.</p>\n</blockquote>\n<p>An object of type <code>bool</code> has the values <code>true</code> or <code>false</code>.Under integral promotion, a <code>bool</code> can be converted to an <code>int</code> where <code>false</code> becomes <code>0</code> and <code>true</code> becomes <code>1</code>:</p>\n<blockquote>\n<p id=\"so_14388855_14388887_1\">A prvalue of type <code>bool</code> can be converted to a prvalue of type <code>int</code>, with <code>false</code> becoming zero and <code>true</code> becoming one.</p>\n</blockquote>\n<p><code>bool</code> is an integral type, which the standard says are represented by use of a \"pure binary numeration system\". The footnote that describes this representation is fairly unclear as to how it maps to the values <code>true</code> and <code>false</code>, but you could assume that they are implying that the value representation for <code>0</code> would be all <code>0</code> bits:</p>\n<blockquote>\n<p id=\"so_14388855_14388887_2\">A positional representation for integers that uses the binary digits 0 and 1, in which the values represented by successive bits are additive, begin with 1, and are multiplied by successive integral power of 2, except perhaps for the bit with the highest position. (Adapted from the American National Dictionary for Information Processing Systems.)</p>\n</blockquote>\n", "LastEditorUserId": "150634", "LastActivityDate": "2013-01-18T12:02:06.783", "Score": "10", "CreationDate": "2013-01-17T21:59:08.147", "ParentId": "14388855", "CommentCount": "12", "OwnerUserId": "150634", "LastEditDate": "2013-01-18T12:02:06.783"}});