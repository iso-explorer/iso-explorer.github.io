post_cb({"14543676": {"ParentId": "14543554", "CommentCount": "3", "Body": "<pre><code>class Irritating\n{\n    public:  Irritating() {}\n    private: Irritating(const Irritating&amp; other) {}\n};\n\nenum DefaultConstruct { defaultConstruct };\n\nclass MaybeTooClever\n    : public Irritating\n{\npublic:\n    MaybeTooClever( DefaultConstruct = defaultConstruct ) {}\n#ifdef __GNUC__\npublic:\n    MaybeTooClever( MaybeTooClever const&amp; other );      // No such.\n#else\nprivate:\n    MaybeTooClever( MaybeTooClever const&amp; other );      // No such.\n#endif\n};    \n\nstatic MaybeTooClever const array[] = { defaultConstruct };\n\nint main()\n{}\n</code></pre>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "14543676", "Score": "1", "CreationDate": "2013-01-27T01:55:05.183", "LastActivityDate": "2013-01-27T01:55:05.183"}, "14543584": {"ParentId": "14543554", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Tried just creating the array with a size?  Default ctor should be called.</p>\n<p>As in this <a href=\"http://liveworkspace.org/code/1Gty7O%243\" rel=\"nofollow\">source</a></p>\n<pre><code>struct foo {\n   int x;\n   foo():x(1) {}\nprivate:\n   foo( foo const&amp; ) {}\n};\n\nfoo array[10];\n\n#include &lt;iostream&gt;\nint main() {\n   for (auto&amp;&amp; i:array) {\n      std::cout &lt;&lt; i.x &lt;&lt; \"\\n\";\n   }\n}\n</code></pre>\n<p>which demonstrates initialized <code>foo</code> in an array with no default copy constructor.</p>\n<p>If your problem is that you actually want to construct the <code>foo</code> with a non-default constructor, this can be done as well, but it is much harder, and that isn't what your question asked.  In any case, here is a very, very rough sketch of the kind of stuff needed to create an array-like structure that supports emplaced construction of its elements.  It is far from finished or compiling, but the basic technique should be sound:</p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;utility&gt;\n#include &lt;type_traits&gt;\n\n\ntemplate&lt;typename... Args&gt;\nstruct types {};\n\ntemplate&lt;typename types, typename=void&gt;\nstruct emplacer;\n\ntemplate&lt;typename T&gt;\nstruct remove_refref {\n  typedef T type;\n};\ntemplate&lt;typename T&gt;\nstruct remove_refref&lt;T&amp;&amp;&gt; {\n  typedef T type; \n};\n\ntemplate&lt;typename A1, typename... Args&gt;\nstruct emplacer&lt; types&lt;A1, Args...&gt;, void&gt;:\n  emplacer&lt; types&lt;Args...&gt; &gt;\n{\n  typename remove_refref&lt;A1&gt;::type val;\n  emplacer( A1 arg, Args... args ):\n    emplacer&lt; types&lt;Args...&gt;, index+1 &gt;( std::forward(args)... ),\n    val( std::forward(arg) )\n  {}\n};\n\ntemplate&lt; std::size_t n &gt;\nstruct extract {\n  template&lt; typename A1, typename... Args &gt;\n  A1&amp;&amp; from( emplacer&lt;types&lt;A1, Args...&gt;&amp;&amp; e ) {\n    return extract&lt;n-1&gt;::from( emplacer&lt;types&lt;Args...&gt;&gt;&amp;&amp;(e) );\n  }\n};\ntemplate&lt;&gt;\nstruct extract&lt;0&gt; {\n  template&lt; typename A1, typename... Args &gt;\n  A1&amp;&amp; from( emplacer&lt;types&lt;A1, Args...&gt;&amp;&amp; e ) {\n    return std::move( e.val );\n  }\n};\n\ntemplate&lt;std::size_t... v&gt;\nstruct seq {};\ntemplate&lt;std::size_t n, std::size_t... tail&gt;\nstruct make_seq: make_seq&lt;n-1, n-1, tail...&gt; {};\ntemplate&lt;std::size_t n, std::size_t... tail&gt;\nstruct make_seq&lt;0, tail...&gt; {\n  typedef seq&lt;tail...&gt; type;\n  type val() { return type(); }\n};\nstruct nothing {};\ntemplate&lt;typename T, typename... Args, std::size_t... indexes&gt;\nnothing construct( T* src, emplacer&lt;types&lt;Args...&gt;&gt;&amp;&amp; e, seq&lt;indexes...&gt; s = make_seq&lt; sizeof...(Args) &gt;::val() ) {\n  new(src)T( std::move( extract&lt;indexes&gt;( std::move(e) ))... );\n}\n\ntemplate&lt;typename... Args&gt;\nemplacer&lt; types&lt;Args...&gt; &gt; emplace( Args&amp;&amp;... a ) {\n  return emplacer&lt; types&lt;Args...&gt; &gt;( std::forward(a)... );\n}\n\ntemplate&lt;typename T, std::size_t n&gt;\nstruct my_array {\nprivate:\n  union T_mem {\n    T t;\n    char x;\n    T_mem():x(0) {}\n  };\n  T_mem buff[n];\n  template&lt;typename... nothings&gt;\n  void do_nothing( nothings...&amp;&amp; ) {}\n  template&lt;typename... emplacers, std::size_t... indexes&gt;\n  my_array( emplacers&amp;&amp;... em, seq&lt;indexes...&gt; s=make_seq&lt; sizeof...(emplacers) &gt;::val() ) {\n    do_nothing( construct( &amp;buff[indexes].t, em)... );\n  }\n  ~my_array() {\n    for( auto&amp;&amp; v:buff) {\n      v.t.~T();\n    }\n  }\n  T&amp; operator[](std::size_t n) { return buff[n].t; }\n  // etc\n};\n</code></pre>\n<p>The idea is that we create an array like construct that is actually an array of <code>union</code> to both <code>T</code> and a <code>char</code>.  We thus avoid actually constructing our <code>T</code>, while still having proper alignment and such for one.  Assuming <code>char</code> has no non-trivial alignment, the resulting buffer is binary-compatible with a <code>T[]</code>.</p>\n<p>We then take as a construction argument <code>emplacer</code> objects, which act as packages for arbitrary construction arguments.  For annoying reasons, these objects need to create a temporary copy of some of their parameters (I cannot figure out how to avoid the lifetime issues... maybe I'm missing something).</p>\n<p>The constructor of the <code>my_array</code> takes any number of <code>emplacers</code> and proceeds to construct the contents of <code>buff</code> based on their arguments.</p>\n<p>You'd create your array something like this:</p>\n<pre><code>my_array&lt; Foo, 10 &gt; arr = {\n  emplacer( a, b, c ),\n  emplacer( x, y, z ),\n  ...\n};\n</code></pre>\n<p>a bit more work would allow default construction of uninitialized objects in the array.</p>\n<p>But this is really, really tricky to write correctly.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2013-01-27T04:00:16.940", "Id": "14543584", "Score": "-4", "CreationDate": "2013-01-27T01:41:04.820", "LastActivityDate": "2013-01-27T04:00:16.940"}, "14543711": {"ParentId": "14543554", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Assuming the copy constructor of <code>Irritating</code> is disabled because it is expensive than perhaps it is best to manage them by reference:</p>\n<pre><code>vector&lt;unique_ptr&lt;Irritating&gt;&gt; V = { new Irritating(), ... };\n</code></pre>\n<p>You could use <code>shared_ptr</code> instead of <code>unique_ptr</code> depending on the usage pattern.</p>\n<p>(If you could modify Irritating you could give it a move constructor, take a look at move semantics)</p>\n<p>If you <em>really</em> want them constructed in place than you could use <code>aligned_storage</code> to make an array of storage for them and then placement new them in place.  This would produce almost identical compiled code to what you want to do with your original request, but it is a little messier:</p>\n<pre><code>aligned_storage &lt;sizeof(Irritating), alignment_of&lt;Irritating&gt;::value&gt;::type data[N];\nnew ((Irritating*) data+0) Irritating(...);\nnew ((Irritating*) data+1) Irritating(...);\nnew ((Irritating*) data+2) Irritating(...);\n...\nnew ((Irritating*) data+N-1) Irritating(...);\n</code></pre>\n<p>(Dont forget to placement delete them at program exit.)</p>\n", "OwnerUserId": "1131467", "LastEditorUserId": "1131467", "LastEditDate": "2013-01-27T02:09:41.160", "Id": "14543711", "Score": "1", "CreationDate": "2013-01-27T02:01:27.947", "LastActivityDate": "2013-01-27T02:09:41.160"}, "14543554": {"CommentCount": "4", "ViewCount": "1707", "PostTypeId": "1", "LastEditorUserId": "589985", "CreationDate": "2013-01-27T01:34:19.377", "LastActivityDate": "2013-01-27T04:00:16.940", "Title": "Why can't I initialize an array of objects if they have private copy constructors?", "AcceptedAnswerId": "14543600", "LastEditDate": "2013-01-27T01:46:39.107", "Id": "14543554", "Score": "1", "Body": "<p>I just ran across some unexpected and frustrating behaviour while working on a C++ project.  My actual code is a tad more complicated, but the following example captures it just as well:</p>\n<pre><code>class Irritating\n{\n    public:  Irritating() {}\n    private: Irritating(const Irritating&amp; other) {}\n};\n\nconst Irritating singleton;                // Works just fine.\nconst Irritating array[] = {Irritating()}; // Compilation error.\n\nint main()\n{\n    return 0;\n}\n</code></pre>\n<p>Trying to compile this produces the following error (GCC version thrown in just in case):</p>\n<pre><code>[holt@Michaela irritating]$ g++ --version\ng++ (GCC) 4.6.3 20120306 (Red Hat 4.6.3-2)\nCopyright (C) 2011 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n[holt@Michaela irritating]$ g++ test.cpp\ntest.cpp:4:11: error: \u2018Irritating::Irritating(const Irritating&amp;)\u2019 is private\ntest.cpp:8:41: error: within this context\n[holt@Michaela irritating]$ \n</code></pre>\n<p>The offending object, unfortunately, is from an external library and outside my control.  My current workaround is to use an array of pointers; it works, but it feels a bit hackish and adds a needless layer of indirection.  Is there a better way to do this?</p>\n<p>Also:  The array is constant and global (well, class-static in the actual code); why isn't it being initialized in place?  Is this expected C++ behaviour, or a bug/quirk of GCC?</p>\n<p><strong>Update:</strong> Installed Clang just to see if it would agree with GCC.  Sadly, it did:</p>\n<pre><code>[holt@Michaela irritating]$ clang test.cpp\ntest.cpp:8:29: warning: C++98 requires an accessible copy constructor for class 'Irritating' when binding a reference to a temporary; was private\n      [-Wbind-to-temporary-copy]\nconst Irritating array[] = {Irritating()};\n                            ^\ntest.cpp:4:11: note: declared private here\n        private: Irritating(const Irritating&amp; other) {}\n                 ^\ntest.cpp:8:29: error: calling a private constructor of class 'Irritating'\nconst Irritating array[] = {Irritating()};\n                            ^\ntest.cpp:4:11: note: declared private here\n        private: Irritating(const Irritating&amp; other) {}\n                 ^\n1 warning and 1 error generated.\n[holt@Michaela irritating]$\n</code></pre>\n", "Tags": "<c++><g++><initialization><copy-constructor>", "OwnerUserId": "589985", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_14543554_14543600_0": {"section_id": 3294, "quality": 0.5789473684210527, "length": 11}}, "n3337": {"so_14543554_14543600_0": {"section_id": 3164, "quality": 0.5789473684210527, "length": 11}}, "n4659": {"so_14543554_14543600_0": {"section_id": 4056, "quality": 0.5789473684210527, "length": 11}}}, "14543600": {"ParentId": "14543554", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Because individual array elements are initialized by <em>copy-initialization</em> from the initializers specified through = <code>{...}</code> syntax. See 8.5/12 (C++03)</p>\n<blockquote>\n<p id=\"so_14543554_14543600_0\">The initialization that occurs in argument passing, function return,\n  throwing an exception (15.1), handling an exception (15.3), and\n  brace-enclosed initializer lists (8.5.1) is called copy-initialization</p>\n</blockquote>\n<p>Copy-initialization requires copy constructor (even if it won't actually use it).</p>\n<p>In practice, if you make your code compile by making the copy constructor public, the compiler will probably end up initializing your array elements in place, without using the copy constructor. Nevertheless, the formal rules of abstract language call for copy-initialization in this context.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2013-01-27T01:49:09.657", "Id": "14543600", "Score": "4", "CreationDate": "2013-01-27T01:43:52.757", "LastActivityDate": "2013-01-27T01:49:09.657"}});