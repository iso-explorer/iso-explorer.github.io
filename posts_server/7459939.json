post_cb({"7469242": {"Id": "7469242", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_7459939_7469242_0\">An ordinary character literal that contains more than one c-char is a multicharacter literal. A multicharacter literal has type int and implementation-de\ufb01ned value.</p>\n</blockquote>\n<p>Implementation defined behavior is required to be documented by\nthe implementation. for example in gcc you can find it <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Characters-implementation.html\" rel=\"noreferrer\">here</a> </p>\n<p>The compiler values a multi-character character constant\na character at a time, shifting the previous value left\nby the number of bits per target character, and then\nor-ing in the bit-pattern of the new character truncated\nto the width of a target character. The final\nbit-pattern is given type int, and is therefore signed,\nregardless of whether single characters are signed or\nnot. </p>\n<p>Check the explanation in <a href=\"http://books.google.fr/books?id=3Qiwp2kD4QYC&amp;pg=PA108&amp;lpg=PA108&amp;dq=C%2b%2b%20multi%20character%20in%20single%20quote&amp;source=bl&amp;ots=iQA74CjfW9&amp;sig=aZcKEZvmHebVrwbsqPgiTY1KSqw&amp;hl=fr&amp;ei=3w13Ts-WHsPB0QXVxJycCA&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=6&amp;ved=0CFEQ6AEwBTgK#v=onepage&amp;q&amp;f=false\" rel=\"noreferrer\">this page</a> for more details </p>\n", "LastEditorUserId": "927034", "LastActivityDate": "2011-11-11T22:41:01.213", "Score": "17", "CreationDate": "2011-09-19T10:06:00.270", "ParentId": "7459939", "CommentCount": "0", "LastEditDate": "2011-11-11T22:41:01.213", "OwnerUserId": "271999"}, "bq_ids": {"n4140": {"so_7459939_7459943_1": {"length": 14, "quality": 0.875, "section_id": 5343}, "so_7459939_7469242_0": {"length": 14, "quality": 0.875, "section_id": 5343}}, "n3337": {"so_7459939_7469242_0": {"length": 14, "quality": 0.875, "section_id": 5140}, "so_7459939_7459943_1": {"length": 14, "quality": 0.875, "section_id": 5140}}, "n4659": {"so_7459939_7469242_0": {"length": 14, "quality": 0.875, "section_id": 6765}, "so_7459939_7459943_1": {"length": 14, "quality": 0.875, "section_id": 6765}}}, "20816715": {"Id": "20816715", "PostTypeId": "2", "Body": "<p>They're really just <code>int</code>s.  They're used extensively in the Core Audio API enum's for example, in the <code>CoreAudioTypes.h</code> header file,</p>\n<pre><code>enum\n{\n    kAudioFormatLinearPCM               = 'lpcm',\n    kAudioFormatAC3                     = 'ac-3',\n    kAudioFormat60958AC3                = 'cac3',\n    kAudioFormatAppleIMA4               = 'ima4',\n    kAudioFormatMPEG4AAC                = 'aac ',\n    kAudioFormatMPEG4CELP               = 'celp',\n} ;\n</code></pre>\n<p>There's a lot of chatter about this not being \"platform independent\", but when you're using an api that's <em>made for</em> a specific platform, who cares about portability.  Checking for equality on the same platform will never fail.  These <code>enum</code>'d values are easier to read and they actually contain <em>their identity in their value</em>, which is pretty nice.</p>\n<p>What I've tried to do below is wrap a multibyte character literal up so it can be printed (on Mac this works).  The strange thing is, if you don't use up all 4 characters, the result becomes wrong below..</p>\n<pre><code>#include &lt;stdio.h&gt;\n\n#define MASK(x,BYTEX) ((x&amp;(0xff&lt;&lt;8*BYTEX))&gt;&gt;(8*BYTEX))\n\nstruct Multibyte\n{\n  union{\n    int val ;\n    char vals[4];\n  };\n\n  Multibyte() : val(0) { }\n  Multibyte( int in )\n  {\n    vals[0] = MASK(in,3);\n    vals[1] = MASK(in,2);\n    vals[2] = MASK(in,1);\n    vals[3] = MASK(in,0);\n  }\n  char operator[]( int i ) {\n    return val &gt;&gt; (3-i)*8 ; // works on mac\n    //return val&gt;&gt;i*8 ; // might work on other systems\n  }\n\n  void println()\n  {\n    for( int i = 0 ; i &lt; 4 ; i++ )\n      putc( vals[i], stdout ) ;\n    puts( \"\" ) ;\n  }\n} ;\n\nint main(int argc, const char * argv[])\n{\n  Multibyte( 'abcd' ).println() ;  \n  Multibyte( 'x097' ).println() ;\n  Multibyte( '\\\"\\\\\\'\\'' ).println() ;\n  Multibyte( '/*|' ).println() ;\n  Multibyte( 'd' ).println() ;\n\n  return 0;\n}\n</code></pre>\n", "LastActivityDate": "2013-12-28T16:25:25.867", "Score": "10", "CreationDate": "2013-12-28T16:25:25.867", "ParentId": "7459939", "CommentCount": "3", "OwnerUserId": "111307"}, "7459953": {"Id": "7459953", "PostTypeId": "2", "Body": "<p>No, it's not an address. It's the so-called multibyte character.</p>\n<p>Typically, it's the ASCII values of the four characters combined.</p>\n<pre><code>'t' == 0x74; 'e' == 0x65; 's' == 0x73; 't' == 0x74; \n</code></pre>\n<p>So 0x74657374 is 1952805748.</p>\n<p>But it can also be 0x74736574 on some other compiler. The C and C++ standards both say the value of multibyte characters is <em>implementation defined</em>. So generally its use is <em>strongly</em> discouraged.</p>\n", "LastEditorUserId": "1938163", "LastActivityDate": "2015-06-13T19:40:14.520", "Score": "69", "CreationDate": "2011-09-18T06:48:51.093", "ParentId": "7459939", "CommentCount": "5", "LastEditDate": "2015-06-13T19:40:14.520", "OwnerUserId": "498284"}, "7459943": {"Id": "7459943", "PostTypeId": "2", "Body": "<p>It's a multi-character literal. <code>1952805748</code> is <code>0x74657374</code>, which decomposes as</p>\n<pre><code>0x74 -&gt; 't'\n0x65 -&gt; 'e'\n0x73 -&gt; 's'\n0x74 -&gt; 't'\n</code></pre>\n<p><strong>Edit:</strong></p>\n<blockquote>\n<p id=\"so_7459939_7459943_0\"><em><strong>C++ standard, \u00a72.14.3/1 - Character literals</strong></em></p>\n<p id=\"so_7459939_7459943_1\">(...) An ordinary character literal that contains more than\n  one c-char is a multicharacter literal . A multicharacter literal has type int and implementation-de\ufb01ned\n  value.</p>\n</blockquote>\n", "LastEditorUserId": "663580", "LastActivityDate": "2015-06-17T23:36:30.113", "Score": "274", "CreationDate": "2011-09-18T06:45:41.960", "ParentId": "7459939", "CommentCount": "2", "LastEditDate": "2015-06-17T23:36:30.113", "OwnerUserId": "927034"}, "7459939": {"ViewCount": "15379", "Body": "<p>I'm curious about this code:</p>\n<pre><code>cout &lt;&lt; 'test'; // Note the single quotes.\n</code></pre>\n<p>gives me an output of <code>1952805748</code>. </p>\n<p>My question: Is the output an address in memory or something?</p>\n", "Title": "What do single quotes do in C++ when used on multiple characters?", "CreationDate": "2011-09-18T06:44:11.907", "LastActivityDate": "2017-07-06T09:33:44.323", "CommentCount": "4", "FavoriteCount": "43", "PostTypeId": "1", "LastEditDate": "2011-09-18T09:06:22.077", "LastEditorUserId": "47064", "Id": "7459939", "Score": "258", "OwnerUserId": "950975", "Tags": "<c++><quotes>", "AnswerCount": "5"}, "44945096": {"Id": "44945096", "PostTypeId": "2", "Body": "<p>This kind of feature is really good when you are building parsers.\nConsider this:</p>\n<pre><code>byte* buffer = ...;\nif(*(int*)buffer == 'GET ')\n  invoke_get_method(buffer+4);\n</code></pre>\n<p>This code will likely only work on specific endianess and might break across different compilers</p>\n", "LastActivityDate": "2017-07-06T09:33:44.323", "Score": "0", "CreationDate": "2017-07-06T09:33:44.323", "ParentId": "7459939", "CommentCount": "0", "OwnerUserId": "6366"}});