post_cb({"14402513": {"ParentId": "14402328", "CommentCount": "0", "Body": "<p>A spinlock will be automatically pre-empted by the OS scheduler making this code unnecessary. The OS will automatically switch to another thread when one thread has taken its share of time. This is why yield is a hint. In the Completely Fair Schedular in Linux, for example, the  call to yield would often cause needless context switches due to the schedular trying to correct for a thread not getting it's fair share of time.</p>\n<p>Your attempt to get a spinlock will not block anything, only holding the spinlock will cause other things to block.</p>\n", "OwnerUserId": "316500", "PostTypeId": "2", "Id": "14402513", "Score": "1", "CreationDate": "2013-01-18T15:49:10.320", "LastActivityDate": "2013-01-18T15:49:10.320"}, "14402328": {"CommentCount": "3", "ViewCount": "806", "CreationDate": "2013-01-18T15:40:04.097", "LastActivityDate": "2013-01-18T17:38:10.347", "Title": "Can std::this_thread::yield being just a hint be problematic?", "PostTypeId": "1", "Id": "14402328", "Score": "1", "Body": "<p>colleague and me discussed a hypothetical problem when one would want to implement spinlock mutex with <code>std::atomic_flag</code> , but also implement that spinlock as not while(true) but as a</p>\n<pre><code>while(true)\n{\n     cnt=0;\n     while (cnt&lt;yieldAfterTries)\n     {\n        //try to get lock\n        cnt++;\n     }\n     std::this_thread::yield();\n\n     // if got lock do work and then break;\n}     \n</code></pre>\n<p>Basically idea is that the thread cant block others \"for a very long time\" even if it has a  real time priority because it will yield after a while... but when I saw \nspecification of std::yield I was surprised it is a suggestion, not a mandatory thing. </p>\n<blockquote>\n<p id=\"so_14402328_14402328_0\">Provides a hint to the implementation to reschedule the execution of\n  threads, allowing other threads to run.  </p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/thread/yield\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/thread/yield</a></p>\n<p>So can that be problematic?</p>\n", "Tags": "<c++><c++11><stdthread><stdatomic>", "OwnerUserId": "700825", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_14402328_14404498_0": {"section_id": 2738, "quality": 0.8, "length": 4}}, "n3337": {"so_14402328_14404498_0": {"section_id": 2699, "quality": 0.8, "length": 4}}, "n4659": {"so_14402328_14404498_0": {"section_id": 3476, "quality": 0.8, "length": 4}}}, "14404498": {"ParentId": "14402328", "CommentCount": "3", "Body": "<p>I've written code very similar to yours, and measured the impact of the call to <code>yield</code> under high contention conditions.  I've found the use of <code>yield</code> in this way beneficial to overall system throughput.</p>\n<p>The actual specification is not different in spirit from what you quote, but here is the exact spec from 30.3.2 [thread.thread.this], paragraphs 2 and 3:</p>\n<pre><code>void this_thread::yield() noexcept;\n</code></pre>\n<blockquote>\n<p id=\"so_14402328_14404498_0\"><em>Effects:</em> Offers the implementation the opportunity to reschedule.</p>\n<p id=\"so_14402328_14404498_1\"><em>Synchronization:</em> None.</p>\n</blockquote>\n<p>If the implementation implements <code>yield</code> as a no-op (for example), this will impact only the performance of your code and not the correctness.  A failing spin-lock will eventually get pre-empted even without the <code>yield</code>.  But it will also be more likely to needlessly hog cpu, degrading overall system performance.</p>\n", "OwnerUserId": "576911", "PostTypeId": "2", "Id": "14404498", "Score": "5", "CreationDate": "2013-01-18T17:38:10.347", "LastActivityDate": "2013-01-18T17:38:10.347"}});