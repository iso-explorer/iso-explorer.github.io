post_cb({"14026224": {"ParentId": "14026202", "PostTypeId": "2", "CommentCount": "19", "Body": "<p>The error is quite clear, you cannot take <em>non-const references</em> to <em>bitfields</em>. <em>[class.bit]/3</em>:</p>\n<blockquote>\n<p id=\"so_14026202_14026224_0\">The address-of operator &amp; shall not be applied to a bit-field, so there are no pointers to bit-fields. A non-const reference shall not be bound to a bit-field (8.5.3). [ Note: If the initializer for a reference of type const T&amp; is an lvalue that refers to a bit-field, the reference is bound to a temporary initialized to hold the value of the bit-field; the reference is not bound to the bit-field directly. See 8.5.3. \u2014end note ]</p>\n</blockquote>\n<p>The reason overload resolution behaves differently has to do with <em>Universal References</em>. Reference collapsing rules and templates make this:</p>\n<pre><code>template &lt;typename T&gt;\nvoid f(T&amp;&amp; x) {}\n</code></pre>\n<p>result in <code>T&amp;&amp;</code> to be deduced as <code>int&amp;</code> when applied to a <em>non-const lvalue</em> <code>int</code>, which is the case for <code>x.x</code>. In that particular case, you are left with:</p>\n<pre><code>void f(int&amp; x){}\nvoid f(int const&amp; x){}\n</code></pre>\n<p>and the first one, the one obtained from reference collapsing rules on <code>f(T&amp;&amp; x)</code>, it can be clearly seen to be a better match than the later one.</p>\n", "OwnerUserId": "927034", "LastEditorUserId": "927034", "LastEditDate": "2012-12-24T23:03:52.933", "Id": "14026224", "Score": "4", "CreationDate": "2012-12-24T22:42:25.430", "LastActivityDate": "2012-12-24T23:03:52.933"}, "14026202": {"CommentCount": "9", "AcceptedAnswerId": "14026224", "CreationDate": "2012-12-24T22:39:11.607", "LastActivityDate": "2012-12-27T19:59:24.450", "PostTypeId": "1", "ViewCount": "1192", "FavoriteCount": "0", "Title": "bit-field in overload resolution for template", "Id": "14026202", "Score": "3", "Body": "<p>Anyone knows why the first program compiles but second one doesn't?  The only difference is that the first one uses normal function but the second one uses template function.  Why the overload resolution behaves differently on bitfield for template and non-template function?</p>\n<p>Please refer to paragraphs in standard when answering.  Thanks.</p>\n<p>a.cpp</p>\n<pre><code>struct X {\n  int x : 20;\n  int y : 12;\n};\n\nvoid f(const int&amp; x) {}\n\nvoid f(int&amp;&amp; x) {}\n\nint main() {\n  X x;\n  f(x.x);\n}\n</code></pre>\n<p>b.cpp</p>\n<pre><code>struct X {\n  int x : 20;\n  int y : 12;\n};\n\ntemplate &lt;typename T&gt;\nvoid f(T&amp;&amp; x) {}\n\ntemplate &lt;typename T&gt;\nvoid f(const T&amp; x) {}\n\nint main() {\n  X x;\n  f(x.x);\n}\n</code></pre>\n<p>Compiler errors:</p>\n<pre><code>[hidden]$ g++ -v 2&gt;&amp;1 | tail -n 1\ngcc version 4.7.2 20120921 (Red Hat 4.7.2-2) (GCC)\n[hidden]$ clang++ -v 2&gt;&amp;1 | head -n 1\nclang version 3.3\n[hidden]$ g++ -std=c++11 a.cpp\n[hidden]$ g++ -std=c++11 b.cpp\nb.cpp: In function \u2018int main()\u2019:\nb.cpp:14:8: error: cannot bind bitfield \u2018x.X::x\u2019 to \u2018int&amp;\u2019\n[hidden]$ clang++ -std=c++11 a.cpp\n[hidden]$ clang++ -std=c++11 b.cpp\nb.cpp:14:5: error: non-const reference cannot bind to bit-field 'x'\n  f(x.x);\n    ^~~\nb.cpp:2:7: note: bit-field is declared here\n  int x : 20;\n      ^\n1 error generated.\n</code></pre>\n", "Tags": "<c++><gcc><c++11><clang>", "OwnerUserId": "875044", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_14026202_14026224_0": {"section_id": 5923, "quality": 0.8333333333333334, "length": 30}}, "n3337": {"so_14026202_14026224_0": {"section_id": 5695, "quality": 0.8333333333333334, "length": 30}}, "n4659": {"so_14026202_14026224_0": {"section_id": 7397, "quality": 0.8333333333333334, "length": 30}}}});