post_cb({"27258829": {"ParentId": "27258344", "LastEditDate": "2014-12-02T21:04:35.870", "CommentCount": "3", "CreationDate": "2014-12-02T20:58:37.180", "OwnerUserId": "3953764", "LastEditorUserId": "3953764", "PostTypeId": "2", "Id": "27258829", "Score": "2", "Body": "<p>Following \u00a79.4.2 [class.static.data]:</p>\n<blockquote>\n<p id=\"so_27258344_27258829_0\"><sup>3</sup> If a non-volatile const static data member is of integral or enumeration type, its declaration in the class definition can specify a brace-or-equal-initializer in which every initializer-clause that is an assignment expression is a constant expression (5.19). [...] <strong>The member shall still be defined in a namespace scope if it is odr-used (3.2) in the program and the namespace scope definition shall not contain an initializer.</strong></p>\n</blockquote>\n<p>In other words, giving a const static data member a value directly in a header does not mean you don't need to define that data member. You should have this in staticinitclass.cpp file:</p>\n<pre><code>#ifndef INITIALIZE_IN_HEADER\nconst int StaticInitClass::default_i = 2;\n#else\nconst int StaticInitClass::default_i; // this is what you don't have\n#endif\n</code></pre>\n<p>Binding to a reference (to a forwarding reference <code>&amp;&amp;</code> in your case deduced as const lvalue reference) counts as <em>odr-use</em> of this data member.</p>\n<p>In case you don't use a forwarding reference and you take the argument <em>by-value</em>, then it is not an odr-use of that static data member, therefore no linker error is raised.</p>\n", "LastActivityDate": "2014-12-02T21:04:35.870"}, "bq_ids": {"n4140": {"so_27258344_27258829_0": {"section_id": 5908, "quality": 0.9117647058823529, "length": 31}}, "n3337": {"so_27258344_27258829_0": {"section_id": 5680, "quality": 0.9117647058823529, "length": 31}}, "n4659": {"so_27258344_27258829_0": {"section_id": 7390, "quality": 0.8823529411764706, "length": 30}}}, "27258344": {"CommentCount": "1", "ViewCount": "144", "CreationDate": "2014-12-02T20:29:15.637", "LastActivityDate": "2014-12-02T21:04:35.870", "Title": "Compiler error or correct behavior for static const member variable, variadic templates, and &&?", "AcceptedAnswerId": "27258829", "PostTypeId": "1", "Id": "27258344", "Score": "1", "Body": "<p>I have noticed a strange behavior when trying to compile the code included below.  I have 4 files as follows</p>\n<p>createshared.h:\n</p>\n<pre><code>#ifndef CREATESHARED_H_\n#define CREATESHARED_H_\n\n#include &lt;memory&gt;\n#include &lt;utility&gt;\n\n#ifdef USE_REFREF\ntemplate&lt;typename T, typename... Args&gt;\nstd::shared_ptr&lt;T&gt; create_shared(Args&amp;&amp;... args)\n{\n    class HelperClass : public T\n    {\n    public:\n        HelperClass (Args&amp;&amp; ... nargs) : T(std::forward&lt;Args...&gt;(nargs)...) {}\n        virtual ~HelperClass() = default;\n    };\n\n    return std::make_shared&lt;HelperClass&gt;(std::forward&lt;Args...&gt;(args)...);\n}\n#else\ntemplate&lt;typename T, typename... Args&gt;\nstd::shared_ptr&lt;T&gt; create_shared(Args... args)\n{\n    class HelperClass : public T\n    {\n    public:\n        HelperClass (Args ... nargs) : T(nargs...) {}\n        virtual ~HelperClass() = default;\n    };\n\n    return std::make_shared&lt;HelperClass&gt;(args...);\n}\n#endif\n\n#endif\n</code></pre>\n<p>staticinitclass.h\n</p>\n<pre><code>#ifndef STATICINITCLASS_H_\n#define STATICINITCLASS_H_\n\nclass StaticInitClass\n{\npublic:\n#ifdef INITIALIZE_IN_HEADER\n    static const int default_i = 1;\n#else\n    static const int default_i;\n#endif\n    virtual ~StaticInitClass() = default;\n    StaticInitClass() = delete;\nprotected:\n    StaticInitClass(int i);\n};\n\n#endif\n</code></pre>\n<p>staticinitclass.cpp:\n</p>\n<pre><code>#include \"staticinitclass.h\"\n\n#include &lt;iostream&gt;\n\n#ifndef INITIALIZE_IN_HEADER\nconst int StaticInitClass::default_i = 2;\n#endif\n\nStaticInitClass::StaticInitClass(int i)\n{\n    std::cout &lt;&lt; \"Created with \" &lt;&lt; i &lt;&lt; std::endl;\n}\n</code></pre>\n<p>main.cpp:\n</p>\n<pre><code>#include \"staticinitclass.h\"\n#include \"createshared.h\"\n#include &lt;memory&gt;\n\nint main(int argc, const char* argv[])\n{\n    auto shared = create_shared&lt;StaticInitClass&gt;(StaticInitClass::default_i);\n}\n</code></pre>\n<p>With no flags, the program compiles and runs fine.\n</p>\n<pre><code>$ g++ -std=c++11 main.cpp staticinitclass.cpp \n$ ./a.out \nCreated with 2\n</code></pre>\n<p>Fine, because default_i is an integral type, we can initialize it in the header.  Let's do that\n</p>\n<pre><code>$ g++ -std=c++11 main.cpp staticinitclass.cpp -DINITIALIZE_IN_HEADER\n$ ./a.out \nCreated with 1\n</code></pre>\n<p>Good, still compiles and works fine.  Now, let's add our &amp;&amp; and std::forward\n</p>\n<pre><code>$ g++ -std=c++11 main.cpp staticinitclass.cpp -DINITIALIZE_IN_HEADER -DUSE_REFREF\n/tmp/cc3G4tjc.o: In function `main':\nmain.cpp:(.text+0xaf): undefined reference to `StaticInitClass::default_i'\ncollect2: error: ld returned 1 exit status\n</code></pre>\n<p>Linker error.  Well, let's now try initializing our default_i member in the .cpp\n</p>\n<pre><code>$ g++ -std=c++11 main.cpp staticinitclass.cpp -DUSE_REFREF\n$ ./a.out \nCreated with 2\n</code></pre>\n<p>And it works again.  Using clang yields the same result, which would lead me to believe that this isn't just an isolated compiler error, but perhaps something in the language itself that prevents the static initialization.  I just can't seem to connect why adding &amp;&amp; would cause the break.</p>\n<p>Currently I am using g++ 4.8.2 and clang++ 3.5 on Ubuntu 14.04</p>\n<p>Any ideas what is broken here when using -DINITIALIZE_IN_HEADER and -DUSE_REFREF?</p>\n", "Tags": "<c++><c++11><rvalue-reference><compiler-bug>", "OwnerUserId": "1012251", "AnswerCount": "1"}});