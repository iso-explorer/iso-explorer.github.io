post_cb({"31016833": {"ParentId": "31016784", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Unfortunately, this is a function declaration:</p>\n<pre><code>vector&lt;int&gt; vec(istream_iterator&lt;int&gt;(cin), istream_iterator&lt;int&gt;());\n</code></pre>\n<p>It's a function named <code>vec</code>, that returns a <code>vector&lt;int&gt;</code> by value and takes two parameters: an <code>istream_iterator&lt;int&gt;</code> with a formal parameter name of <code>cin</code>, and a function with no formal parameter name that returns an <code>istream_iterator&lt;int&gt;</code>, and takes no parameters.</p>\n<p><strong>Why?</strong> </p>\n<p>Basically, in C++(and C), if a piece of code can be interpreted as a declaration, it will be.</p>\n<p>According to N3936::6.8.1 [stmt.ambig]:</p>\n<blockquote>\n<p id=\"so_31016784_31016833_0\">There is an ambiguity in the grammar involving expression-statements\n  and declarations: An expressionstatement with a function-style\n  explicit type conversion (5.2.3) as its leftmost subexpression can be\n  indistinguishable from a declaration where the first declarator starts\n  with a (. In those cases the statement is a declaration. [ Note: To\n  disambiguate, the whole statement might have to be examined to\n  determine if it is an expression-statement or a declaration. This\n  disambiguates many examples. [ Example: assuming T is a\n  simple-type-specifier (7.1.6),  </p>\n<p id=\"so_31016784_31016833_1\">T(a)-&gt;m = 7;      // expression-statement<br>\n  T(a)++;           // expression-statement<br>\n  T(a,5) &lt;&lt; c;      // expression-statement   </br></br></p>\n<p id=\"so_31016784_31016833_2\">T(*d)(int);       // declaration<br>\n  T(e)[5];          // declaration<br>\n  T(f) = { 1, 2 };  //declaration<br>\n  T(*g)(double(3)); // declaration   </br></br></br></p>\n<p id=\"so_31016784_31016833_3\">In the last example\n  above, g, which is a pointer to T, is initialized to double(3). This\n  is of course ill-formed for semantic reasons, but that does not affect\n  the syntactic analysis. \u2014end example ]</p>\n</blockquote>\n<p><strong>How to fix it</strong></p>\n<p>All we need is something that makes it impossible for the compiler to treat the code as a function declaration.</p>\n<ol>\n<li><p>Adding the extra parentheses around the parameters makes it clear to the\ncompiler that what we intend to be constructor parameter names can't be parameter declarations.</p>\n<p><code>vector&lt;int&gt; vec((istream_iterator&lt;int&gt;(cin)), istream_iterator&lt;int&gt;());</code></p></li>\n<li><p>As your solution showed, using named variables as constructor parameters.</p></li>\n</ol>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2015-06-24T03:01:40.170", "Id": "31016833", "Score": "2", "CreationDate": "2015-06-24T02:53:57.467", "LastActivityDate": "2015-06-24T03:01:40.170"}, "bq_ids": {"n4140": {"so_31016784_31016833_2": {"section_id": 48, "quality": 0.5714285714285714, "length": 4}, "so_31016784_31016833_3": {"section_id": 3922, "quality": 0.8333333333333334, "length": 15}, "so_31016784_31016833_0": {"section_id": 3921, "quality": 0.5681818181818182, "length": 25}}, "n3337": {"so_31016784_31016833_2": {"section_id": 43, "quality": 0.5714285714285714, "length": 4}, "so_31016784_31016833_3": {"section_id": 3781, "quality": 0.8333333333333334, "length": 15}, "so_31016784_31016833_0": {"section_id": 3781, "quality": 0.7272727272727273, "length": 32}}, "n4659": {"so_31016784_31016833_2": {"section_id": 49, "quality": 0.5714285714285714, "length": 4}, "so_31016784_31016833_3": {"section_id": 4808, "quality": 0.8333333333333334, "length": 15}, "so_31016784_31016833_0": {"section_id": 4807, "quality": 0.5681818181818182, "length": 25}}}, "31016784": {"CommentCount": "0", "AcceptedAnswerId": "31016833", "ClosedDate": "2015-06-24T02:56:21.360", "CreationDate": "2015-06-24T02:48:39.197", "LastActivityDate": "2015-06-24T03:01:40.170", "PostTypeId": "1", "ViewCount": "71", "Title": "Why can't i construct a vector by passing temporary input iterator?", "Id": "31016784", "Score": "1", "Body": "<p>I often used istream_iterator copy standard input to a vector like this:</p>\n<pre><code>copy(istream_iterator&lt;int&gt;(cin), istream_iterator&lt;int&gt;(), back_inserter(vec));\n</code></pre>\n<p>it works.</p>\n<p>Today when i construct a vector by this:</p>\n<pre><code>vector&lt;int&gt; vec(istream_iterator&lt;int&gt;(cin), istream_iterator&lt;int&gt;());\ncopy(vec.begin(), vec.end(), ostream_iterator&lt;int&gt;(cout, \" \"));\n</code></pre>\n<p>it just can not compile!</p>\n<p>But if i construct it like this:</p>\n<pre><code>istream_iterator&lt;int&gt; beg(cin), end;\nvector&lt;int&gt; vec(beg, end); \ncopy(vec.begin(), vec.end(), ostream_iterator&lt;int&gt;(cout, \" \"));\n</code></pre>\n<p>it works.</p>\n<p>Why? Can not i use temporary variables to construct a vector? If it does, but why could i do it when i use std::copy? </p>\n<p>ps: I compiled it under vs2005 and i used the following head files:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;iterator&gt;\n#include &lt;algorithm&gt;\n</code></pre>\n", "Tags": "<c++><vector><istream-iterator>", "OwnerUserId": "3691082", "AnswerCount": "1"}});