post_cb({"bq_ids": {"n4140": {"so_10031397_10031741_1": {"length": 11, "quality": 0.8461538461538461, "section_id": 91}, "so_10031397_10031741_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 91}, "so_10031397_10031741_2": {"length": 8, "quality": 0.8, "section_id": 91}}, "n3337": {"so_10031397_10031741_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 86}, "so_10031397_10031741_2": {"length": 8, "quality": 0.8, "section_id": 86}, "so_10031397_10031741_1": {"length": 11, "quality": 0.8461538461538461, "section_id": 86}}}, "10031741": {"PostTypeId": "2", "Body": "<p>The argument you're supplying isn't a type, it's a value, so the rules are a bit different -- you need to apply the rules for non-type arguments. For non-type arguments, implicit conversions are allowed. \u00a714.3.2/5:</p>\n<blockquote>\n<p id=\"so_10031397_10031741_0\">The following conversions are performed on each expression used as a non-type template-argument. If a non-type template-argument cannot be converted to the type of the corresponding template-parameter then the program is ill-formed.</p>\n<p id=\"so_10031397_10031741_1\">\u2014 For a non-type template-parameter of integral or enumeration type, conversions permitted in a converted constant expression (5.19) are applied.</p>\n</blockquote>\n<p>In C++03, the wording is marginally different, but the effect essentially identical (also \u00a714.3.2/5):</p>\n<blockquote>\n<p id=\"so_10031397_10031741_2\">\u2014 for a non-type template-parameter of integral or enumeration type, integral promotions (4.5) and integral conversions (4.7) are applied.</p>\n</blockquote>\n<p>Either way, since <code>1</code> is both an <code>int</code> and implicitly convertible to a <code>bool</code>, your call is ambiguous.</p>\n", "LastActivityDate": "2012-04-05T15:44:32.743", "Id": "10031741", "CommentCount": "3", "CreationDate": "2012-04-05T15:44:32.743", "ParentId": "10031397", "Score": "8", "OwnerUserId": "179910"}, "10031863": {"Id": "10031863", "PostTypeId": "2", "Body": "<p>Since this isn't a compiler bug but a language feature (see <a href=\"https://stackoverflow.com/a/10031741/1176973\">this answer</a>), you have to find a work around.</p>\n<p>Either you have to rename your functions or you can use this hack:</p>\n<pre><code>template &lt;typename T&gt; struct F;\n\ntemplate&lt;&gt; struct F&lt;bool&gt; {\n  template &lt;bool veracity&gt;\n  static int f(){return 1;}\n};\n\ntemplate&lt;&gt; struct F&lt;int&gt; {\n  template &lt;int amount&gt;\n  static int f(){return 2;}\n};\n\ntemplate &lt;typename T, T value&gt;\nint f() { return F&lt;T&gt;::template f&lt;value&gt;(); }\n\n// inside main():\nstd::cout &lt;&lt; f&lt;int,  2&gt;() &lt;&lt; '\\n'; // prints 2\nstd::cout &lt;&lt; f&lt;bool, 2&gt;() &lt;&lt; '\\n'; // prints 1\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-04-05T15:52:21.283", "CommentCount": "0", "CreationDate": "2012-04-05T15:52:21.283", "ParentId": "10031397", "Score": "5", "OwnerUserId": "1176973", "LastEditDate": "2017-05-23T12:11:26.043"}, "10031397": {"ViewCount": "1218", "Body": "<p>If you overload a function and then call it with an argument that perfectly matches one of the overloads</p>\n<pre><code>int f(int){return 3;}\nint f(bool){return 4;}\n...        //inside main()\nf(1);      //Calls f(int)\n</code></pre>\n<p>the compiler simply chooses this (perfect) match before attempting any implicit conversions. However I've been trying to overload a function temp\u013aate as in</p>\n<pre><code>template &lt;bool veracity&gt;\nint f(){return 1;}\n\ntemplate &lt;int amount&gt;\nint f(){return 2;}\n\n...        //inside main()\nf&lt;1&gt;();\n</code></pre>\n<p>but the compiler keeps complainning about ambiguous call to the overloaded f(), stating it could be either <code>f&lt;true&gt;()</code> or <code>f&lt;1&gt;()</code>. Shouldn't the compiler just choose the perfect match, instead of trying to convert <em>1</em> to <em>true</em> ? </p>\n<p>I was under the impression that implicit conversion for template arguments was actually more restrictive than implicit conversion of function arguments. Is there a way to get around this problem?</p>\n", "AcceptedAnswerId": "10031741", "Title": "Rules for implicit conversion of template arguments", "CreationDate": "2012-04-05T15:21:03.377", "Id": "10031397", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2012-04-05T15:52:21.283", "Score": "12", "OwnerUserId": "491532", "Tags": "<c++><templates><overloading>", "AnswerCount": "2"}});