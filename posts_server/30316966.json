post_cb({"30316966": {"CommentCount": "0", "ViewCount": "269", "PostTypeId": "1", "LastEditorUserId": "419994", "CreationDate": "2015-05-19T04:48:17.197", "LastActivityDate": "2015-05-19T05:15:25.420", "Title": "Calculate number of elements in an array based on pointers to the first and last elements", "LastEditDate": "2015-05-19T04:57:47.873", "Id": "30316966", "Score": "2", "Body": "<p>Suppose there exists an array, A, such that its elements are of struct Element and I am told that the struct Element is packed with no padding.  </p>\n<p>If I am given pointers to the first and last element in A, can I determine the number of elements in A based on the address of the pointers and amount of memory an Element takes up?  Or does the structure of an array in memory not work like that.</p>\n<p>My thought is if the pointers I'm given are Element* start and Element* finish...</p>\n<pre><code>number of elements = (finish - start) / sizeof(Element)\n</code></pre>\n<p>Is this logical thinking?</p>\n", "Tags": "<c++><arrays>", "OwnerUserId": "4857357", "AnswerCount": "2"}, "30317258": {"ParentId": "30316966", "CommentCount": "1", "Body": "<p>When you use pointer arithmetic, you can say that the \"unit\" is the size of one element of the type pointed to.</p>\n<p>I.e. if you have <code>Element* start</code> pointing to the 0-th element of an array, <code>start + 1</code> will point to the 1-st element of that array.</p>\n<p>So, when you use <code>finish - start</code>, you already get the number of elements between them, and there is no need to divide by <code>sizeof(Element)</code>.</p>\n", "OwnerUserId": "3079266", "PostTypeId": "2", "Id": "30317258", "Score": "0", "CreationDate": "2015-05-19T05:15:25.420", "LastActivityDate": "2015-05-19T05:15:25.420"}, "30317069": {"ParentId": "30316966", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>If you have:</p>\n<pre><code>Element* start; // first element\nElement* finish; // last element\n</code></pre>\n<p>Then:</p>\n<pre><code>numElements = finish - start + 1;\n</code></pre>\n<ol>\n<li>If <code>finish</code> is like an <code>end</code> in STL, you do not have the <code>+1</code>.</li>\n<li>Because of pointer arithmetic, you do not have to divide by <code>sizeof(Element)</code></li>\n</ol>\n<p>With regard to considering whether there might be padding at the structure end, as Billy indicated, <code>sizeof</code> already contains that, as will pointer arithmetic. from the C++14 final draft:</p>\n<blockquote>\n<p id=\"so_30316966_30317069_0\">N3797/5.3.3/2 [ sizeof ]</p>\n<p id=\"so_30316966_30317069_1\">When applied to a class, the result is the number of bytes in an\n  object of that class including any padding required for placing objects of that type in an array.</p>\n</blockquote>\n", "OwnerUserId": "540026", "LastEditorUserId": "540026", "LastEditDate": "2015-05-19T05:11:39.790", "Id": "30317069", "Score": "7", "CreationDate": "2015-05-19T04:57:45.770", "LastActivityDate": "2015-05-19T05:11:39.790"}, "bq_ids": {"n4140": {"so_30316966_30317069_1": {"section_id": 6077, "quality": 1.0, "length": 15}}, "n3337": {"so_30316966_30317069_1": {"section_id": 5845, "quality": 1.0, "length": 15}}, "n4659": {"so_30316966_30317069_1": {"section_id": 7573, "quality": 1.0, "length": 15}}}});