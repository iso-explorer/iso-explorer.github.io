post_cb({"bq_ids": {"n4140": {"so_7170394_7170548_1": {"length": 9, "quality": 0.6923076923076923, "section_id": 5988}, "so_7170394_7170548_0": {"length": 27, "quality": 0.7105263157894737, "section_id": 6045}, "so_7170394_7170548_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 5991}}, "n3337": {"so_7170394_7170548_0": {"length": 32, "quality": 0.8421052631578947, "section_id": 5814}, "so_7170394_7170548_1": {"length": 9, "quality": 0.6923076923076923, "section_id": 5756}, "so_7170394_7170548_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 5759}}, "n4659": {"so_7170394_7170548_0": {"length": 27, "quality": 0.7105263157894737, "section_id": 7544}, "so_7170394_7170548_1": {"length": 10, "quality": 0.7692307692307693, "section_id": 7488}, "so_7170394_7170548_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 7491}}}, "7170478": {"Id": "7170478", "PostTypeId": "2", "Body": "<p>I believe that if you cast A* to B* and then cast it back to A* again, then the standard says you are OK. Those would be reinterpret_casts though not static_casts.</p>\n<p>But what exactly is wrong with the normal solution?</p>\n<pre><code>class B\n{\nprivate:\n  A* ptr;\npublic:\n  B(A* p) : ptr(p) {}\n  void do_something(int arg) { do_something_with_A(ptr,arg); }\n};\n</code></pre>\n<p>Seems to be as efficient as your solution and less mucking about.</p>\n", "LastActivityDate": "2011-08-24T04:34:45.247", "CommentCount": "4", "CreationDate": "2011-08-24T04:34:45.247", "ParentId": "7170394", "Score": "2", "OwnerUserId": "882003"}, "7170394": {"ViewCount": "154", "Body": "<p>There is a forward C struct declared in an unmodifiable header. I would like to \"virtually\" add convenience member functions to it.  Obviously my first choice would be to extend the struct and add the methods to the derived class.  No-can-do, as the struct itself is declared as \"forward\" in the header, so I get the error \"error: invalid use of incomplete type ...\".  I get a similar error if I try to define a new struct with a single element of the old struct.  This sucks.</p>\n<p>However, I was thinking that I could do some hackery with reinterpret_cast to get it to work anyway.  The way it would go is this:</p>\n<pre><code>//defined in header\nstruct A forward;\nvoid do_something_with_A(A* a, int arg);\n\n//defined in my wrapper\nstruct B {\n  B* wrap(A* a) {return reinterpret_cast&lt;B*&gt;(a); }\n  void do_something(int arg) {do_something_with_A(reinterpret_cast&lt;A*&gt;(this),arg); }\n}\n</code></pre>\n<p>If I added implicit conversions from type B to type A, I was thinking that this could work out <em>almost</em> as if B was a zero-data inheritor of A.  However, this obviously brings up the question:  is this undefined in C++?  Normally I would think that accessing an element of an illegally casted struct would be undefined; that makes sense.  However, I would think that reinterpret_casting from one type to another, passing that pointer around, and then casting back again, without doing anything illegal in between would be fine.  I would also think that the way a compiler implements non-virtual struct members would be creating a function</p>\n<pre><code>B::do_something(B* b, int arg)\n</code></pre>\n<p>and calling that with the appropriate argument for B.  This then reduces to the previous case, which by my dubious logic is okay.    So I would think calling .do_something on a struct which is actually a reinterpret_cast A would be okay.</p>\n<p>However, this says nothing for what the C++ standard actually says on the matter.   Any help with that?  Also, if someone has information on how well this will work practically, (i.e. \"Every compiler ever made accepts this\", or \"this only works with a few compilers\") that would also be helpful, but slightly less so.</p>\n", "AcceptedAnswerId": "7170548", "Title": "Calling member function of zero data struct which was cast from incompatible type - Undefined?", "CreationDate": "2011-08-24T04:20:10.290", "Id": "7170394", "CommentCount": "5", "LastEditDate": "2011-08-24T17:58:04.773", "PostTypeId": "1", "LastEditorUserId": "501557", "LastActivityDate": "2011-08-24T17:58:04.773", "Score": "0", "OwnerUserId": "94102", "Tags": "<c++><struct><reinterpret-cast>", "AnswerCount": "2"}, "7170548": {"Id": "7170548", "PostTypeId": "2", "Body": "<p>I don't believe this works if you're using <code>static_cast</code> because you cannot <code>static_cast</code> between two completely unrelated class types.  To be specific, if you have a pointer of type <code>A*</code> and try to convert it to a pointer of type <code>B*</code>, the <code>static_cast</code> only succeeds if this declaration is valid:</p>\n<pre><code>B* ptr(myAPtr);\n</code></pre>\n<p>or if <code>B</code> is non-virtually derived from <code>A</code> (which it isn't).  See the ISO spec \u00a75.2.9 for details on the specifics of this.  If we consider the above declaration, the only possible conversions that could be applied here in all of \u00a74 are those in \u00a74.10, and of those the only one that might be applicable is conversion from base to derived classes (\u00a74.10/3), but this doesn't apply here because <code>A</code> and <code>B</code> aren't related types.</p>\n<p>The only cast you might be able to use here is a <code>reinterpret_cast</code>, and it doesn't look like this will work either.  In particular, the behavior of casting across class hierarchies is (\u00a75.2.10/7)</p>\n<blockquote>\n<p id=\"so_7170394_7170548_0\">A pointer to an object can be explicitly converted to a pointer to an object of different type.65) Except that converting an rvalue of type \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d <strong>(where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than those of T1)</strong> and back to its original type yields the original pointer value, the result of such a pointer conversion is unspecified.</p>\n</blockquote>\n<p>So immediately there's no guarantee that anything is going to work if the two objects have different alignment restrictions, and you cannot ensure that this is true.  But suppose that you could.  In that case, though, I believe that this will actually work correctly!  Here's the reasoning.  When you call the member function of the <code>B</code> object, then rule &amp;5.2.2/1) kicks in and says that, since the function is nonvirtual:</p>\n<blockquote>\n<p id=\"so_7170394_7170548_1\">[...] The function called in a member function call is normally selected according to the static type of the object expression. [...] </p>\n</blockquote>\n<p>Okay, so we're at least calling the right function.  Now, what about the <code>this</code> pointer?  Well, according to &amp;5.2.2/4:</p>\n<blockquote>\n<p id=\"so_7170394_7170548_2\">[...] If the function is a nonstatic member function, the \u201cthis\u201d parameter of the function (9.3.2) shall be initialized with a pointer to the object of the call, converted as if by an explicit type conversion (5.4). [...]</p>\n</blockquote>\n<p>The type conversion done in the last part is the identity conversion from a <code>B*</code> to a <code>B*</code>, since that's the selected type.  So you've called the right function with the <code>this</code> pointer set appropriately.  Nice!  Finally, when you do a <code>reinterpret_cast</code> back to the original type, by the earlier rule, you'll get back the <code>A*</code> object and everything will go as expected.</p>\n<p>Of course, <strong>this only works if the objects have the same alignment requirements</strong>, and this cannot be guaranteed.  Consequently, you shouldn't do it!</p>\n<p>Hope this helps!</p>\n", "LastActivityDate": "2011-08-24T04:45:34.203", "CommentCount": "4", "CreationDate": "2011-08-24T04:45:34.203", "ParentId": "7170394", "Score": "1", "OwnerUserId": "501557"}});