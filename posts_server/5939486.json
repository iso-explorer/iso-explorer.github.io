post_cb({"5939486": {"ViewCount": "889", "Body": "<p>Sorry for the funny title.</p>\n<p>Prior to C++0x, there are <a href=\"https://stackoverflow.com/q/4659157/1968\">restrictions</a> in the use of function-local structs (\u201clocal types\u201d) as template arguments. My question is essentially if similar restrictions apply to anonymous structs. Specifically, in the context of a trait class:</p>\n<pre><code>template &lt;typename T&gt;\nstruct trait;\n\ntemplate &lt;&gt;\nstruct trait&lt;int&gt; {\n    typedef int type;\n};\n\ntemplate &lt;typename T&gt;\nstruct trait&lt;std::basic_string&lt;T&gt; &gt; {\n    typedef struct {\n        T value;\n    } type;\n};\n\ntrait&lt;std::string&gt;::type foo; // Is this valid?\n\ntemplate &lt;typename T&gt;\nvoid f() { }\n\nf&lt;trait&lt;std::string&gt;::type&gt; &gt;(); // Is this?\n\ntemplate &lt;typename T&gt;\nvoid g() { f&lt;typename trait&lt;T&gt;::type&gt;(); }\n\ng&lt;std::string&gt;(); // And this?\n</code></pre>\n<p>Is this valid and reliable? It compiles in recent versions of GCC and LLVM but I\u2019m still insecure whether this is strictly valid, and whether it\u2019s understood by VC++ and ICC.</p>\n", "AcceptedAnswerId": "5942427", "Title": "Anonymous struct in typedef of trait class", "CreationDate": "2011-05-09T16:02:04.640", "Id": "5939486", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:34:32.437", "LastEditorUserId": "-1", "LastActivityDate": "2011-05-09T20:58:05.993", "Score": "14", "OwnerUserId": "1968", "Tags": "<c++><templates><c++11><anonymous-class>", "AnswerCount": "4"}, "5939961": {"Id": "5939961", "PostTypeId": "2", "Body": "<p>For reference, the quote from the linked question in 14.3.1/2:</p>\n<blockquote>\n<p id=\"so_5939486_5939961_0\">A local type, a type with no linkage,\n  an unnamed type or a type compounded\n  from any of these types shall not be\n  used as a template argument for a\n  template type parameter.</p>\n</blockquote>\n<p>My interpretation is that the <code>typedef struct</code> is creating an alias to an unnamed type and that it thus can't be used as a template type parameter. Further note that additionally in C <code>typedef struct {} Foo;</code> is treated rather differently from <code>struct Foo {};</code> giving precedent that the two forms are not equivalent (although admittedly that difference doesn't appear in C++).</p>\n<p>Thus it would appear your first example works (since it's not using the unnamed type as a template type parameter), while the second and third examples would be technically invalid (since they do use it as a template type parameter).</p>\n<p>Finally in closing I have to ask, is there a reason you can't name the struct instead of <code>typedef</code>ing it?</p>\n<p>EDIT: From 7.1.3/1:</p>\n<blockquote>\n<p id=\"so_5939486_5939961_1\">...A typedef-name is thus a synonym for\n  another type. A typedef-name does not\n  introduce a new type the way a class\n  declaration (9.1) or enum declaration\n  does...</p>\n</blockquote>\n<p>This strongly implies that using <code>typedef</code> in such a way does not introduce a type suitable for use as a template type-parameter.</p>\n", "LastEditorUserId": "251738", "LastActivityDate": "2011-05-09T17:03:07.470", "Score": "6", "CreationDate": "2011-05-09T16:48:13.290", "ParentId": "5939486", "CommentCount": "4", "OwnerUserId": "251738", "LastEditDate": "2011-05-09T17:03:07.470"}, "bq_ids": {"n4140": {"so_5939486_5942427_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 5415}, "so_5939486_5939961_1": {"length": 16, "quality": 1.0, "section_id": 5407}, "so_5939486_5941022_0": {"length": 4, "quality": 1.0, "section_id": 84}, "so_5939486_5939961_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 3487}}, "n3337": {"so_5939486_5942427_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 5210}, "so_5939486_5939961_1": {"length": 16, "quality": 1.0, "section_id": 5202}, "so_5939486_5941022_0": {"length": 4, "quality": 1.0, "section_id": 79}, "so_5939486_5939961_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 3352}}, "n4659": {"so_5939486_5942427_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 6837}, "so_5939486_5939961_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 4250}, "so_5939486_5941022_0": {"length": 4, "quality": 1.0, "section_id": 87}, "so_5939486_5939961_1": {"length": 16, "quality": 1.0, "section_id": 6829}}}, "5939596": {"Id": "5939596", "PostTypeId": "2", "Body": "<p>Well, that is equivalent to </p>\n<pre><code>template &lt;typename T&gt;\nstruct trait&lt;std::basic_string&lt;T&gt; &gt; {\n    struct type {\n        T value;\n    };\n};\n</code></pre>\n<p>which is completely legitimate.</p>\n", "LastActivityDate": "2011-05-09T16:11:54.350", "CommentCount": "3", "CreationDate": "2011-05-09T16:11:54.350", "ParentId": "5939486", "Score": "0", "OwnerUserId": "298661"}, "5942427": {"Id": "5942427", "PostTypeId": "2", "Body": "<p>A <code>typedef</code> declaration that defines an anonymous class and a typedef-name for that class, the typedef-name is the name of the class for linkage purposes. It is therefore legal to use that class as a template parameter if it meets the other criteria.</p>\n<p>See 7.1.3p5 of the C++03 standard</p>\n<blockquote>\n<p id=\"so_5939486_5942427_0\">If the typedef declaration defines an\n  unnamed class (or enum), the first\n  typedef-name declared by the decla-ration to be that class type (or enum\n  type) is used to denote the class type\n  (or enum type) for linkage purposes\n  only (3.5). [Example:</p>\n</blockquote>\n<pre><code>typedef struct { } *ps, S; // S is the class name for linkage purposes\n</code></pre>\n<p>This is 7.1.3p9 in the C++0x FDIS.</p>\n<p>FWIW, this code compiles OK with MSVC2010 (modulo typos).</p>\n", "LastActivityDate": "2011-05-09T20:58:05.993", "CommentCount": "2", "CreationDate": "2011-05-09T20:58:05.993", "ParentId": "5939486", "Score": "3", "OwnerUserId": "5597"}, "5941022": {"Id": "5941022", "PostTypeId": "2", "Body": "<p>In the upcoming standard that restriction is removed from the language. The standard says in </p>\n<p>14.3.1 [temp.arg.type] /1</p>\n<blockquote>\n<p id=\"so_5939486_5941022_0\">A template-argument for a template-parameter which is a type shall be a type-id.</p>\n</blockquote>\n<p>And a typedef is a valid <em>type-id</em>. As a matter of fact the next paragraph contains such an example:</p>\n<p>14.3.1 [temp.arg.type] /2</p>\n<pre><code>template &lt;class T&gt; class X { };\ntemplate &lt;class T&gt; void f(T t) { }\nvoid f() { \n   typedef struct { } B;\n   B b;\n   X&lt;B&gt; x3;\n   f(b);\n}\n</code></pre>\n<p>(Where I have trimmed most of the other examples) The example shows that an unnamed type can be used as a class template argument both in class templates and function templates.</p>\n", "LastActivityDate": "2011-05-09T18:40:03.043", "CommentCount": "3", "CreationDate": "2011-05-09T18:40:03.043", "ParentId": "5939486", "Score": "4", "OwnerUserId": "36565"}});