post_cb({"36392775": {"ParentId": "36392600", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The builtin <code>operator&amp;&amp;</code> is a context in which expressions are <em>contextually converted</em> to <code>bool</code>. Other such contexts include for example the condition of <code>if</code>, <code>for</code>, <code>while</code> and the conditional operator <code>?</code>.</p>\n<p>Quoting <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">N4296, \u00a74/4</a> (the latest publicly available draft before C++14):</p>\n<blockquote>\n<p id=\"so_36392600_36392775_0\">Certain language constructs require that an expression be converted to a Boolean value. An expression <code>e</code>\n  appearing in such a context is said to be contextually converted to <code>bool</code> and is well-formed if and only if the\n  declaration <code>bool t(e);</code> is well-formed, for some invented temporary variable <code>t</code> (8.5).</p>\n</blockquote>\n<p>Basically, this means that there is an \"impicit explicit conversion to <code>bool</code>\" in these contexts. Or, to illustrate this further, you can think of the following two lines being one and the same:</p>\n<pre><code>a &amp;&amp; b\nstatic_cast&lt;bool&gt;(a) &amp;&amp; static_cast&lt;bool&gt;(b)\n</code></pre>\n<p>Therefore, the compiler must consider the <code>explicit operator bool()</code> when doing overload resolution for <code>operator&amp;&amp;</code>, but has to ignore it when doing overload resolution for <code>operator==</code> (since that operator does not force a \"<code>bool</code> context\" .. you can also compare numbers, strings, ...).</p>\n<hr>\n<p>The solution in your case is IMO to get rid of the <code>operator&amp;&amp;(const my_bool&amp;, const my_bool&amp;)</code> all together. After all, it does not produce a more meaningful behavior than what would be possible by relying on the builtin <code>operator&amp;&amp;(bool, bool)</code>. <s>Establishing a second \"boolean context\" just isn't something the language was designed for</s> (see below).</p>\n<p>If you want to keep this operator, say for some side effects, then I see these choices:</p>\n<ul>\n<li><p>Be explicit at the call site. That is:</p>\n<pre><code>if (static_cast&lt;my_bool&gt;(a) &amp;&amp; static_cast&lt;my_bool&gt;(b)) { /* ... */ }\n</code></pre></li>\n<li><p>Be explicit at the definition site: Provide additional definitions for <code>operator&amp;&amp;(my_bool const &amp;, bool)</code>, <code>operator&amp;&amp;(bool, my_bool const &amp;)</code>. These then should rule out both <code>operator&amp;&amp;(my_bool const &amp;, my_bool const &amp;)</code> as well as <code>operator&amp;&amp;(bool, bool)</code> because the later are less specific. Adding these definitions to your class <a href=\"http://ideone.com/wEzUT6\" rel=\"nofollow\">should mitigate the issue</a>:</p>\n<pre><code>friend my_bool operator&amp;&amp;(const my_bool &amp; lhs, bool rhs) {\n    // Delegate to operator&amp;&amp;(const my_bool &amp;, const my_bool &amp;)\n    return lhs &amp;&amp; my_bool(rhs);\n}\nfriend my_bool operator&amp;&amp;(bool lhs, const my_bool &amp; rhs) {\n    // Delegate to operator&amp;&amp;(const my_bool &amp;, const my_bool &amp;)\n    return my_bool(lhs) &amp;&amp; rhs;\n}\n</code></pre></li>\n</ul>\n<hr>\n<p>Turns out one can \"establish a boolean context\", using CRTP:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nstruct bool_context {\n    friend T operator&amp;&amp;(T const &amp; lhs, bool rhs) {\n        return lhs &amp;&amp; T(rhs);\n    }\n    friend T operator&amp;&amp;(bool lhs, T const &amp; rhs) {\n        return T(lhs) &amp;&amp; rhs;\n    }\n    friend T operator||(T const &amp; lhs, bool rhs) {\n        return lhs || T(rhs);\n    }\n    friend T operator||(bool lhs, T const &amp; rhs) {\n        return T(lhs) || rhs;\n    }\n};\n\nstruct my_bool : bool_context&lt;my_bool&gt; {\n    bool value;\n    my_bool(bool v) : value(v) {}\n    explicit operator bool() { return value; };\n    friend my_bool operator&amp;&amp;(my_bool const &amp; lhs, my_bool const &amp; rhs) {\n        cout &lt;&lt; \"my_bool::operator&amp;&amp;\" &lt;&lt; endl;\n        return lhs.value &amp;&amp; rhs.value;\n    }\n    friend my_bool operator||(my_bool const &amp; lhs, my_bool const &amp; rhs) {\n        cout &lt;&lt; \"my_bool::operator||\" &lt;&lt; endl;\n        return lhs.value || rhs.value;\n    }\n};\n\n\nint main(int, char**) {\n    my_bool a = true;\n    bool b = false;\n    cout &lt;&lt; \"a &amp;&amp; b =&gt; \"; a &amp;&amp; b; // my_bool::operator&amp;&amp;\n    cout &lt;&lt; \"b &amp;&amp; a =&gt; \"; b &amp;&amp; a; // my_bool::operator&amp;&amp;\n    cout &lt;&lt; \"a &amp;&amp; a =&gt; \"; a &amp;&amp; a; // my_bool::operator&amp;&amp;\n    cout &lt;&lt; \"b &amp;&amp; b =&gt; \"; b &amp;&amp; b; cout &lt;&lt; endl;\n    cout &lt;&lt; \"a || b =&gt; \"; a || b; // my_bool::operator||\n    cout &lt;&lt; \"b || a =&gt; \"; b || a; // my_bool::operator||\n    cout &lt;&lt; \"a || a =&gt; \"; a || a; // my_bool::operator||\n    cout &lt;&lt; \"b || b =&gt; \"; b || b; cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>(<a href=\"http://ideone.com/V2dVza\" rel=\"nofollow\">Ideone</a>)</p>\n</hr></hr>", "OwnerUserId": "1116364", "LastEditorUserId": "1116364", "LastEditDate": "2016-04-04T00:49:33.237", "Id": "36392775", "Score": "5", "CreationDate": "2016-04-04T00:01:28.693", "LastActivityDate": "2016-04-04T00:49:33.237"}, "36393088": {"ParentId": "36392600", "CommentCount": "1", "Body": "<p>The code bellow works in the same manner for both == and &amp;&amp;. \nThe class equality is triggered only when are of the same type.</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nclass my_bool {\nprivate:\n  bool v{false};\n  public:\n    my_bool() : v(v) {};\n    operator bool (){return v;}\n\n    friend bool operator==(const my_bool a, my_bool b){\n            printf(\"operator==\\n\");return a.v==b;\n        }\n        friend bool operator&amp;&amp;(const my_bool a, my_bool b){\n            printf(\"operator&amp;&amp;\\n\");return a.v&amp;&amp;b;\n        }\n};\n\nint main(int argc, char **argv)\n{ printf(\"Starting\\n\");\n  bool a=true,b=true;\n  my_bool A{},B{},R{};\n\n  a==b;a&amp;&amp;b;\n  a==A;a&amp;&amp;A;\n  A==b;A&amp;&amp;b;\n  A==B;A&amp;&amp;B;\n}\n</code></pre>\n", "OwnerUserId": "3127336", "PostTypeId": "2", "Id": "36393088", "Score": "0", "CreationDate": "2016-04-04T00:50:49.573", "LastActivityDate": "2016-04-04T00:50:49.573"}, "36392600": {"CommentCount": "3", "ViewCount": "76", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-04-03T23:36:56.550", "LastActivityDate": "2016-04-04T00:50:49.573", "Title": "binary operator overloading, implicit type conversion", "AcceptedAnswerId": "36392775", "LastEditDate": "2017-05-23T11:50:41.217", "Id": "36392600", "Score": "3", "Body": "<pre><code>class my_bool {\n  private:\n    bool value;\n  public:\n    my_bool(bool value) : value(value) {}\n    explicit operator bool() { return value };\n\n    friend my_bool operator==(const my_bool &amp; instance_1, const my_bool &amp; instance_2);\n    friend my_bool operator&amp;&amp;(const my_bool &amp; instance_1, const my_bool &amp; instance_2);\n\n};\n\nvoid main(){\n  my_bool a = true;\n  bool b = false;\n\n  if(a == b){\n    // do something\n  }\n\n  if(a &amp;&amp; b){\n    // do something \n  }\n}\n</code></pre>\n<p>I have just created a similar topic regarding my problem over here <a href=\"https://stackoverflow.com/questions/36391795/binary-operator-overloading-implicit-type-conversion\">binary operator overloading; implicit type conversion</a> . It can be deleted I guess because it is not explicit enough about the problem I am encountering.</p>\n<p>Why is that <code>operator==</code> works fine and <code>operator&amp;&amp;</code> causes ambiguities? How do I solve this problem? I can surely write down two more overloads of <code>operator&amp;&amp;</code> (<code>bool</code>, <code>my_bool</code>), (<code>my_bool</code>, <code>bool</code>). That is a messy solution though</p>\n", "Tags": "<c++>", "OwnerUserId": "3600124", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_36392600_36392775_0": {"section_id": 3, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_36392600_36392775_0": {"section_id": 2, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_36392600_36392775_0": {"section_id": 3, "quality": 0.9583333333333334, "length": 23}}}, "36392734": {"ParentId": "36392600", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>My first thought on this is that the arguments to the compiler's built-in <code>operator&amp;&amp;</code> are <code>(bool, bool)</code>, so my_bool's explicit bool operator can be invoked - since you are in effect, requesting an explicit conversion.</p>\n<p>However, I can't find any reference in the standard as to whether a variable appearing on the right hand side of &amp;&amp; should invoke an explicit conversion to bool.</p>\n<p>Here's the complete error output from apple clang (once the source code above is fixed):</p>\n<pre><code>./nod.cpp:45:10: error: use of overloaded operator '&amp;&amp;' is ambiguous (with operand types 'my_bool' and 'bool')\n    if(a &amp;&amp; b){\n       ~ ^  ~\n./nod.cpp:33:20: note: candidate function\n    friend my_bool operator&amp;&amp;(const my_bool &amp; instance_1, const my_bool &amp; instance_2);\n                   ^\n./nod.cpp:45:10: note: built-in candidate operator&amp;&amp;(_Bool, _Bool)\n    if(a &amp;&amp; b){\n         ^\n1 error generated.\n</code></pre>\n<blockquote>\n<p id=\"so_36392600_36392734_0\">So how do I fix it?</p>\n</blockquote>\n<p>Remove the user-defined &amp;&amp; operator.</p>\n<pre><code>class my_bool {\nprivate:\n    bool value;\npublic:\n    my_bool(bool value) : value(value) {}\n    explicit operator bool() { return value; }\n\n    friend my_bool operator==(const my_bool &amp; instance_1, const my_bool &amp; instance_2);\n//    friend my_bool operator&amp;&amp;(const my_bool &amp; instance_1, const my_bool &amp; instance_2);\n\n};\n\nint main(){\n    my_bool a = true;\n    bool b = false;\n\n    if(a == b){\n        // do something\n    }\n\n    if(a &amp;&amp; b){\n        // do something\n    }\n}\n</code></pre>\n", "OwnerUserId": "2015579", "LastEditorUserId": "2015579", "LastEditDate": "2016-04-04T00:25:08.343", "Id": "36392734", "Score": "1", "CreationDate": "2016-04-03T23:55:00.073", "LastActivityDate": "2016-04-04T00:25:08.343"}});