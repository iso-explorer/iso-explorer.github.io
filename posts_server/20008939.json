post_cb({"20009069": {"ParentId": "20008939", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Only static variables have values pre-initialized.  Variables that are created on the stack (i.e. local variables) have garbage values, and thus should not be used before initializing. </p>\n", "OwnerUserId": "2993960", "LastEditorUserId": "2993960", "LastEditDate": "2013-12-26T14:10:25.310", "Id": "20009069", "Score": "1", "CreationDate": "2013-11-15T19:29:03.213", "LastActivityDate": "2013-12-26T14:10:25.310"}, "20009013": {"ParentId": "20008939", "CommentCount": "0", "Body": "<p>C and C++ provides no guarantee regarding values of local variables. They have a garbage values, depending on what is at that memory adress in the moment of allocation. In order to use them, you must initialize them with a value.</p>\n<p>This is not true for global variables. They are initialized with 0 by default. </p>\n", "OwnerUserId": "2896626", "PostTypeId": "2", "Id": "20009013", "Score": "1", "CreationDate": "2013-11-15T19:26:20.003", "LastActivityDate": "2013-11-15T19:26:20.003"}, "20030753": {"ParentId": "20008939", "CommentCount": "0", "Body": "<p>one way is to define a construct function to initialize the params </p>\n<pre><code>typedef struct tagCtxt\n{\n    tagCtxt()\n    {\n     memset( iadl1, '\\0', sizeof(char)*51);\n     memset( iadl2, '\\0', sizeof(char)*51);\n     memset( iprurb, '\\0', sizeof(char)*29);\n     memset( iadl3, '\\0', sizeof(char)*51);\n    }\n    char     iadl1[50+1];\n    char     iadl2[50+1];\n    char     iprurb[28+1];\n    char     iadl3[50+1];\n} PARM;\n</code></pre>\n", "OwnerUserId": "2914665", "PostTypeId": "2", "Id": "20030753", "Score": "0", "CreationDate": "2013-11-17T12:39:24.630", "LastActivityDate": "2013-11-17T12:39:24.630"}, "20008939": {"CommentCount": "2", "CreationDate": "2013-11-15T19:22:10.423", "PostTypeId": "1", "AcceptedAnswerId": "20008969", "LastEditorUserId": "1708801", "LastActivityDate": "2013-12-26T14:10:25.310", "LastEditDate": "2013-11-17T03:49:36.380", "ViewCount": "147", "FavoriteCount": "0", "Title": "Why is this struct initialized with data already in a field?", "Id": "20008939", "Score": "1", "Body": "<p>I'm using a library written in <em>C</em>, with my own program that's in <em>C++</em>. They <em>typedef</em> a struct like this:</p>\n<pre><code>typedef struct tagCtxt\n{\n    char     iadl1[50+1];\n    char     iadl2[50+1];\n    char     iprurb[28+1];\n    char     iadl3[50+1];\n} PARM;\n</code></pre>\n<p>In one of my methods, I construct it and immediately print the value of one of the fields:</p>\n<pre><code>PARM parm1;\ncout &lt;&lt; \"'\" &lt;&lt; parm1.iadl3 &lt;&lt; \"'\" &lt;&lt; endl;\n</code></pre>\n<p>As expected, it's blank/empty:</p>\n<pre><code>''\n</code></pre>\n<p>Now I do this, creating <code>parm2</code>:</p>\n<pre><code>PARM parm1, parm2;\ncout &lt;&lt; \"'\" &lt;&lt; parm1.iadl3 &lt;&lt; \"'\\t'\" &lt;&lt; parm2.iadl3 &lt;&lt; \"'\" endl;\n</code></pre>\n<p>Then I get this:</p>\n<pre><code>''    'x\ufffd\ufffd'\n</code></pre>\n<p>The output of the second one varies. Sometimes it looks like <code>X\u0170</code> or <code>8\u01b0</code> or <code>\ufffd\u01f0</code> or <code>\u01f0</code>, etc.</p>\n<p>This line appears to fix the symptoms:</p>\n<pre><code>memset(&amp;parm2.iadl3, 0, sizeof(parm2.iadl3));\n</code></pre>\n<p>But what is the problem? Why is the char array non-empty for the second one, but not for the first?</p>\n<p>Remember, my program is compiled as <em>C++</em> but the header file I'm using that defines the type is in <em>C</em>. Does that make a difference? I'm including the header file like so:</p>\n<pre><code>extern \"C\"\n{\n    #include \"parm.h\"\n}\n</code></pre>\n", "Tags": "<c++><c><struct><undefined-behavior><arrays>", "OwnerUserId": "1048862", "AnswerCount": "7"}, "20009062": {"ParentId": "20008939", "CommentCount": "0", "Body": "<pre><code>char     iadl1[50+1];\n</code></pre>\n<p>Will reserve you a block of memory that are large enough to store 51 characters</p>\n<p>However, it doesn't guarantee you that that block of memory is all empty, it just happens to be empty in your case. In general, use memset to initialize your arrays before accessing it would be the best way to do.</p>\n<pre><code>memset( iadl1, '\\0', sizeof(char)*51);\n</code></pre>\n", "OwnerUserId": "2903325", "PostTypeId": "2", "Id": "20009062", "Score": "1", "CreationDate": "2013-11-15T19:28:34.880", "LastActivityDate": "2013-11-15T19:28:34.880"}, "20009022": {"ParentId": "20008939", "CommentCount": "0", "Body": "<p><em>\"As expected, it's blank/empty:</em>\" No, thats not expected. C++ dones not initialize the value of a  variable (Except its data type provides a constructor which does the job, or is a thing with static storage duration).  </p>\n<p>As Shafik said, reading the uninitialized data has undefined behaviour.</p>\n", "OwnerUserId": "1609356", "PostTypeId": "2", "Id": "20009022", "Score": "2", "CreationDate": "2013-11-15T19:26:32.230", "LastActivityDate": "2013-11-15T19:26:32.230"}, "20008987": {"ParentId": "20008939", "CommentCount": "0", "Body": "<p>Doesn't matter with the C/C++ thing.</p>\n<p>In general, memory which you havn't set explicitly (like that <code>memset</code> operation u did) contains undefined values.</p>\n<p>It's not 'expected' to be 0's.</p>\n", "OwnerUserId": "1778249", "PostTypeId": "2", "Id": "20008987", "Score": "1", "CreationDate": "2013-11-15T19:25:08.537", "LastActivityDate": "2013-11-15T19:25:08.537"}, "bq_ids": {"n4140": {"so_20008939_20008969_2": {"section_id": 3291, "quality": 0.76, "length": 19}}, "n3337": {"so_20008939_20008969_2": {"section_id": 3161, "quality": 0.84, "length": 21}}, "n4659": {"so_20008939_20008969_2": {"section_id": 4053, "quality": 0.76, "length": 19}}}, "20008969": {"ParentId": "20008939", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>This is <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow\">undefined behavior</a>, the initial value of an <em>automatic variable</em> is indeterminate, you need to initialize variables before you use them.</p>\n<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"nofollow\">C99 draft standard</a> in section <code>6.2.4</code> <em>Storage durations of objects</em> says after covering <em>static variables</em> says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_20008939_20008969_0\">For such an object that does not have a variable length array type, its lifetime extends\n  from entry into the block with which it is associated until execution of that block ends in\n  any way. [...] <strong>The initial value of the object is indeterminate</strong>. [...]</p>\n</blockquote>\n<p>and the definition of <em>indeterminate value</em> is as follows:</p>\n<blockquote>\n<p id=\"so_20008939_20008969_1\">either an unspecified value or a trap representation</p>\n</blockquote>\n<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">C++ draft standard</a> section <code>8.5</code> <em>Initializers</em> paragraph <em>12</em> says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_20008939_20008969_2\">If no initializer is specified for an object, the object is default-initialized; if no initialization is performed, <strong>an object with automatic or dynamic storage duration has indeterminate value</strong>. [ Note: Objects with static or thread storage duration are zero-initialized, see 3.6.2. \u2014end note ]</p>\n</blockquote>\n<p>A good place to get started in understanding some forms of <em>undefined behavior</em> is the <a href=\"http://www.slideshare.net/olvemaudal/deep-c\" rel=\"nofollow\">Deep C</a> slides.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2013-11-15T19:50:12.007", "Id": "20008969", "Score": "4", "CreationDate": "2013-11-15T19:23:31.327", "LastActivityDate": "2013-11-15T19:50:12.007"}});