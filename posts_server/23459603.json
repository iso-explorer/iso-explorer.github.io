post_cb({"23459603": {"CommentCount": "1", "AcceptedAnswerId": "23460825", "PostTypeId": "1", "LastEditorUserId": "661519", "CreationDate": "2014-05-04T17:53:21.927", "LastActivityDate": "2014-05-04T19:47:28.897", "LastEditDate": "2014-05-04T18:10:16.707", "ViewCount": "287", "FavoriteCount": "1", "Title": "rvalue reference argument turning into an lvalue", "Id": "23459603", "Score": "3", "Body": "<p>Please consider the following code:</p>\n<pre><code>class a {\npublic:\n    int a;\n};\n\nvoid func1( a &amp;&amp;var1 );\n\nvoid func2( a &amp;&amp;var2 )\n{\n    func1(var2);\n}\n</code></pre>\n<p>When trying to compile it, gcc returns the following:</p>\n<pre><code>question.cpp: In function \u2018void func2(a&amp;&amp;)\u2019:\nquestion.cpp:10:14: error: cannot bind \u2018a\u2019 lvalue to \u2018a&amp;&amp;\u2019\n     func1(var);\n              ^\nquestion.cpp:6:6: error:   initializing argument 1 of \u2018void func1(a&amp;&amp;)\u2019\n void func1( a &amp;&amp;var );\n      ^\n</code></pre>\n<p>It seems that var2 is an lvalue, despite it being quite explicitly defined as an rvalue reference. Does the double ampersands lose their meaning once assigned? What is the mechanism that's at work here?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1510211", "AnswerCount": "3"}, "23460825": {"ParentId": "23459603", "CommentCount": "0", "Body": "<p>There is no mechanism at work, just the definitions. <code>var2</code> is an identifier that denotes a variable. When used as an expression, it becomes <em>id-expression</em>, whose value category is defined as follows, in <code>5.1.1[expr.prim.general]/8</code></p>\n<blockquote>\n<p id=\"so_23459603_23460825_0\">The result is the entity denoted by the identifier. The result is an lvalue if the entity is a function, variable, or data member and a prvalue otherwise.</p>\n</blockquote>\n<p><code>var2</code>, the variable, has type rvalue reference to <code>a</code></p>\n<p><code>var2</code>, the expression, has type <code>a</code> and value category lvalue</p>\n<p>(you're not the first person to confuse rvalues and rvalue references)</p>\n", "OwnerUserId": "273767", "PostTypeId": "2", "Id": "23460825", "Score": "4", "CreationDate": "2014-05-04T19:47:28.897", "LastActivityDate": "2014-05-04T19:47:28.897"}, "23459644": {"ParentId": "23459603", "CommentCount": "2", "Body": "<p>In <code>func2</code> you could, theoretically, write <code>a = &lt;something&gt;</code>. Therefore <code>a</code> is an l-value. So the compiler is correct.</p>\n", "OwnerUserId": "532057", "PostTypeId": "2", "Id": "23459644", "Score": "2", "CreationDate": "2014-05-04T17:56:40.283", "LastActivityDate": "2014-05-04T17:56:40.283"}, "bq_ids": {"n4140": {"so_23459603_23460825_0": {"section_id": 5954, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_23459603_23460825_0": {"section_id": 5724, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_23459603_23460825_0": {"section_id": 7441, "quality": 0.8, "length": 12}}}, "23459655": {"ParentId": "23459603", "CommentCount": "0", "Body": "<p>Inside the function implementation, the <em>once</em>-rvalue becomes a regular variable (l-value), to which you can make assignments. If you want to turn it into an rvalue again, you must use <code>std::move</code>, as in:</p>\n<pre><code>void func2( a &amp;&amp;var2 ) {\n    func1(std::move(var2));\n}\n</code></pre>\n", "OwnerUserId": "1655939", "PostTypeId": "2", "Id": "23459655", "Score": "5", "CreationDate": "2014-05-04T17:58:31.403", "LastActivityDate": "2014-05-04T17:58:31.403"}});