post_cb({"bq_ids": {"n4140": {"so_20669394_20803084_0": {"length": 70, "quality": 0.9333333333333333, "section_id": 243}}, "n3337": {"so_20669394_20803084_0": {"length": 68, "quality": 0.9066666666666666, "section_id": 235}}, "n4659": {"so_20669394_20803084_0": {"length": 68, "quality": 0.9066666666666666, "section_id": 250}}}, "20669606": {"Id": "20669606", "PostTypeId": "2", "Body": "<p>When MSVC instantiates a class, it also populates its vtable and for that purpose instantiates all of its virtual functions, even those never called.</p>\n<p>In your case, the function <code>useX</code> cannot be instantiated without compiler seeing the full definition of A. </p>\n<p>If you declare useX as non-virtual, MSVC works fine.</p>\n<p>It seems this behavior is compiler-dependent; for example, AIX is even more aggressive than MSVC in instantiating (unused) functions.</p>\n", "LastActivityDate": "2013-12-18T22:17:04.113", "CommentCount": "3", "CreationDate": "2013-12-18T22:17:04.113", "ParentId": "20669394", "Score": "8", "OwnerUserId": "2876861"}, "20834300": {"Id": "20834300", "PostTypeId": "2", "Body": "<p>First, as many have stated, the standard fully allows for compilers to instantiate (or chose not to instantiate) to their hearts content in this situation; by a strict interpretation of the standard, this is a code issue, not an MSVC bug. The behavior you are depending on is platform specific and therefore non-standard; while this is not a \"bug\" per se, it's distinctly non-portable.</p>\n<p>However, it's interesting to understand why GCC and Clang differ from MSVC, which has to do with how vtables are set up in each compiler.</p>\n<p>A quick overview of how objects look in memory:</p>\n<ol>\n<li>no inheritance, all calls are static, no vtable or adjustments</li>\n<li>single inheritance, all calls are static, clever organization</li>\n<li>multiple inheritance, all calls are static, pointer adjustments</li>\n<li>virtual inheritance, calls can be dynamic, vtable and pointer adjustments</li>\n</ol>\n<p>In the first case, all the information can be static; member functions are just normal functions with a hidden this. In the second case, the derived class (or classes, for a long inheritance list) can be cleverly put after the base class in memory, so that Derived* == Base*. This optimization doesn't work with multiple inheritance, obviously, which means each call needs to adjust the this pointer. Virtual inheritance then adds an array, the vtable, which dynamically selects the correct function at run time.</p>\n<p><strong>What does any of this have to do with instantiation of unused members?</strong></p>\n<p>In general, no matter what your implementation, you need three things:</p>\n<ol>\n<li>A delta, detailing where in your this the subobject you care about is</li>\n<li>a virtual index (vindex) detailing which virtual method to call</li>\n<li>an array of methods to call (vtable)</li>\n</ol>\n<p>G++ has a standardized and well copied way to do these adjustments, used in many compilers (including Clang, as Clang is meant to be a drop in replacement for GCC):</p>\n<ol>\n<li>store the delta explicitly</li>\n<li>store vindex and offset calculations in the vtable as well, with method addresses on evens and vindex's on odds</li>\n</ol>\n<p>This is a sort of strange cache optimization which has some benefits; it's been widely copied, despite not being the most elegant solution. It uses one structure for all cases, and does the same calculations each time, depending on compiler optimizations to replace virtual table hops with direct calls when applicable (a task that the GCC optimizer are marvelous at). </p>\n<p>MSVC, on the other hand, is not merely a little inelegant. It's a horrible hack: it uses a different structure for each case. This allows it to avoid the overhead of unnecessary calculations, and to save space in many cases. However, this means that casting member function pointers causes them to change size, in the common case (derived to base) causing them to <em>lose information</em>. </p>\n<p>Because of this, unlike the more elegant GCC implementation, MSVC absolutely must instantiate virtual member functions; if it doesn't, it could easily lose information between translation units or during linking, and have the same object <em>represented by different sized structures</em>! </p>\n<p>This was such a problem they actually added keywords just to deal with it: <a href=\"http://msdn.microsoft.com/en-us/library/ck561bfk.aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/ck561bfk.aspx</a></p>\n<p>So, while you don't think the compiler needs the type, <strong><em>MSVC certainly does, or it will almost certainly be unsafe.</em></strong></p>\n<p>Edit: confused myself with simple single inheritance, base class goes FIRST:</p>\n<pre><code>class A : public B\n</code></pre>\n<p>becomes</p>\n<p>[[ B ] A ]</p>\n<p>So the pointers *B == *A</p>\n", "LastEditorUserId": "3137484", "LastActivityDate": "2013-12-30T07:16:03.247", "Score": "4", "CreationDate": "2013-12-30T06:12:55.510", "ParentId": "20669394", "CommentCount": "0", "OwnerUserId": "3137484", "LastEditDate": "2013-12-30T07:16:03.247"}, "20803084": {"Id": "20803084", "PostTypeId": "2", "Body": "<p>From the draft C++1y standard: (via @DyP)</p>\n<blockquote>\n<p id=\"so_20669394_20803084_0\">An implementation shall not implicitly instantiate a function template, a variable template, a member tem-\n  plate, a non-virtual member function, a member class, or a static data member of a class template that\n  does not require instantiation. <em>It is unspecified whether or not an implementation implicitly instantiates\n  a virtual member function of a class template if the virtual member function would not otherwise be in-\n  stantiated.</em> The use of a template specialization in a default argument shall not cause the template to be\n  implicitly instantiated except that a class template may be instantiated where its complete type is needed to\n  determine the correctness of the default argument. The use of a default argument in a function call causes\n  specializations in the default argument to be implicitly instantiated.</p>\n</blockquote>\n<p>emphasis mine.  Any <code>virtual</code> function in a <code>template</code> can be instantiated by any C++ compiler for any or no reason at any point without violating the C++ standard.  So MSVC is standards conforming in this matter.</p>\n<p>This is 14.7.1.11 in <a href=\"http://isocpp.org/files/papers/N3797.pdf\" rel=\"nofollow\">the current draft N3797</a>.</p>\n", "LastActivityDate": "2013-12-27T15:20:15.880", "CommentCount": "0", "CreationDate": "2013-12-27T15:20:15.880", "ParentId": "20669394", "Score": "3", "OwnerUserId": "1774667"}, "20669394": {"ViewCount": "357", "Body": "<p>I'm trying to find out why this fails. I'm using code that condenses down to basically what I have below. I have a simple class A that I'm specializing a template with. The template doesn't need this type to compile its constructor, and the constructor I'm actually calling (of a derived type) isn't exposed, so the compiler cannot generate the code for the constructor at this point.</p>\n<p>GCC and Clang don't. MSVC however (2008 + 2010) do try to compile the virtual member and thereby do not compile.</p>\n<p>Is this wrong from GCC and Clang, or from MSVC? Or am I bounding into UB territory?</p>\n<pre><code>class A;\n\ntemplate &lt;typename X&gt;\nclass S {\npublic:\n    S() {}\n\n    virtual int useX() { return X::value; }\n};\n\nclass T : public S&lt;A&gt; {\npublic:\n    T();\n};\n\nint main()\n{\n    new T();\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "20834300", "Title": "Use a forward-declared class in a virtual function in a template baseclass where the constructor only needs the forward declare?", "CreationDate": "2013-12-18T22:04:39.713", "Id": "20669394", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-12-30T07:16:03.247", "Score": "3", "OwnerUserId": "272708", "Tags": "<c++><templates><visual-c++><gcc>", "AnswerCount": "3"}});