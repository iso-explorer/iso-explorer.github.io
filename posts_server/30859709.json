post_cb({"30859772": {"ParentId": "30859709", "CommentCount": "0", "Body": "<p>The way the compiler implements reference behaviours - including where and how they're stored - is not specified in the C++ Standard.  Consequently, some compiler could \"print e.g. 1 instead of 16\" as you ask.</p>\n<p>Separately, you don't need to <code>break</code> after <code>return</code>ing.</p>\n", "OwnerUserId": "410767", "PostTypeId": "2", "Id": "30859772", "Score": "2", "CreationDate": "2015-06-16T05:54:34.693", "LastActivityDate": "2015-06-16T05:54:34.693"}, "30859758": {"ParentId": "30859709", "CommentCount": "0", "Body": "<p>The Standard says under [dcl.ref]:</p>\n<blockquote>\n<p id=\"so_30859709_30859758_0\">It is unspecified whether or not a reference requires storage</p>\n</blockquote>\n<p>Also it is up to the compiler to decide what the size of an object is, so you could get any non-zero number here.</p>\n<p>There is also the as-if rule (aka. permission to optimize). So it would be legal for the compiler to use storage for these references if and only if the way the references were used required it.</p>\n<p>Having said all that; in the interests of having a stable ABI I would still expect that a compiler assigns storage to these references.</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "30859758", "Score": "5", "CreationDate": "2015-06-16T05:54:01.543", "LastActivityDate": "2015-06-16T05:54:01.543"}, "30859709": {"CommentCount": "3", "AcceptedAnswerId": "30859758", "CreationDate": "2015-06-16T05:49:54.250", "LastActivityDate": "2015-06-16T06:16:07.550", "PostTypeId": "1", "ViewCount": "147", "FavoriteCount": "1", "Title": "Can storage for references inside a C++ class be optimized away?", "Id": "30859709", "Score": "6", "Body": "<p>Does the C++ language allow the following code to print e.g. 1 instead of 16? According to other answers I would guess yes but this case specifically doesn't seem to have been covered.</p>\n<pre><code>#include \"iostream\"\n#include \"cstdlib\"\nusing namespace std;\n\nstruct as_array {\n    double &amp;a, &amp;b;\n\n    as_array(double&amp; A, double&amp; B)\n        : a(A), b(B) {}\n\n    double&amp; operator[](const int i) {\n        switch (i) {\n        case 0:\n            return this-&gt;a;\n            break;\n        case 1:\n            return this-&gt;b;\n            break;\n        default:\n            abort();\n        }\n    }\n};\n\nint main() {\n    cout &lt;&lt; sizeof(as_array) &lt;&lt; endl;\n}\n</code></pre>\n", "Tags": "<c++><compiler-optimization>", "OwnerUserId": "3493721", "AnswerCount": "3"}, "30860061": {"ParentId": "30859709", "CommentCount": "2", "Body": "<p>I believe that </p>\n<pre><code>cout &lt;&lt; sizeof(as_array) &lt;&lt; endl;\n</code></pre>\n<p>always returns the required storage for two pointers to double on the given machine, maybe extended with gaps to fulfill packing rules. Optimizing did mot mean to reduce the size of the storage of given data structures. Instead the compiler can optimize your code completely away in a real world scenario. So if you have the code:</p>\n<pre><code>double a=100;\ndouble b=200;\nas_array arr(&amp;a, &amp;b);\nstd::cout &lt;&lt; arr[0] &lt;&lt; std::endl;\n</code></pre>\n<p>can result in optimizing the storage for the struct completely away, because the compiler knows how the values are handled through your code. But the print out of sizeof(arr) still give you the theoretical size of the struct.</p>\n<p>Anyway: If you want to get better optimizing results, you should write better code! Make methods <code>const</code> if they are <code>const</code>! If you use c++11 use constexpr if possible.</p>\n", "OwnerUserId": "878532", "PostTypeId": "2", "Id": "30860061", "Score": "2", "CreationDate": "2015-06-16T06:16:07.550", "LastActivityDate": "2015-06-16T06:16:07.550"}, "bq_ids": {"n4140": {"so_30859709_30859758_0": {"section_id": 3221, "quality": 1.0, "length": 5}}, "n3337": {"so_30859709_30859758_0": {"section_id": 3095, "quality": 1.0, "length": 5}}, "n4659": {"so_30859709_30859758_0": {"section_id": 3978, "quality": 1.0, "length": 5}}}});