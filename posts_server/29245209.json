post_cb({"29245264": {"ParentId": "29245209", "CommentCount": "7", "Body": "<p>It's ambiguous because it could be both</p>\n<ul>\n<li><code>int*</code> and <code>int</code> (because 1 is an <code>int</code>)</li>\n<li><code>unsigned long*</code> and <code>unsigned long</code> (because your pointer is <code>unsigned long*</code>)</li>\n</ul>\n", "OwnerUserId": "3307279", "PostTypeId": "2", "Id": "29245264", "Score": "0", "CreationDate": "2015-03-25T00:10:02.983", "LastActivityDate": "2015-03-25T00:10:02.983"}, "29245293": {"ParentId": "29245209", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_29245209_29245293_0\">Why can't T be deduced using the type of the pointer, which should be\n  unambiguous?</p>\n</blockquote>\n<p>Because you haven't told the compiler to do so. Inconsistent deductions of a template argument lead to a deduction failure.</p>\n<blockquote>\n<p id=\"so_29245209_29245293_1\">And is there a way to rewrite the template so that the original call\n  to Set would compile successfully?</p>\n</blockquote>\n<p>Yes, using non-deduced contexts.</p>\n<pre><code>template &lt;typename T&gt;\nstruct identity {using type=T;};\ntemplate &lt;typename T&gt;\nusing identity_t = typename identity&lt;T&gt;::type;\n\ntemplate &lt;typename T&gt;\nvoid Set(T* a, identity_t&lt;T&gt; b) {\n    *a = b;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/aabc5cbe0b81187f\"><strong>Demo</strong></a>.<br>\nOr use a second template parameter.</br></p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-03-25T00:16:23.093", "Id": "29245293", "Score": "6", "CreationDate": "2015-03-25T00:12:21.507", "LastActivityDate": "2015-03-25T00:16:23.093"}, "29245209": {"CommentCount": "0", "ViewCount": "102", "CreationDate": "2015-03-25T00:05:24.747", "LastActivityDate": "2015-03-25T00:28:09.317", "Title": "Template type not deduced using pointer type", "AcceptedAnswerId": "29245344", "PostTypeId": "1", "Id": "29245209", "Score": "2", "Body": "<p>I was surprised to find that <code>T</code> could not be deduced successfully in the following code:</p>\n<pre><code>template &lt;typename T&gt;\nvoid Set(T* a,T b)\n{\n    *a = b;\n}\n\nvoid Test()\n{\n    unsigned long a;\n    Set(&amp;a, 1);\n}\n</code></pre>\n<p>VC++ complains about an ambiguity:</p>\n<pre><code>1&gt;test.cpp(10): error C2782: 'void Set(T *,T)' : template parameter 'T' is ambiguous\n1&gt;          test.cpp(32) : see declaration of 'Set'\n1&gt;          could be 'int'\n1&gt;          or       'unsigned long'\n</code></pre>\n<p>Obviously this can be fixed by changing the call to <code>Set(&amp;a, 1ul);</code> but my question is why is this necessary?</p>\n<p>Why can't <code>T</code> be deduced using the type of the pointer, which should be unambiguous?</p>\n<p>And is there a way to rewrite the template so that the original call to <code>Set</code> would compile successfully?</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "506413", "AnswerCount": "4"}, "29245344": {"ParentId": "29245209", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The parameters <code>T* a</code> and <code>T b</code> are both deduced contexts, so first the compiler will try to deduce <code>T</code> from both of them in order to make <code>T*</code> <em>identical to</em> the type of the first argument and <code>T</code> <em>identical to</em> to the type of the second argument (following the usual decay adjustments). This yields <code>unsigned long</code> from the first argument and <code>int</code> from the second, so this attempt at deduction fails.</p>\n<p>Then the compiler will attempt to find <code>T</code> such that the first argument is <em>convertible to</em> <code>T*</code> and the second argument is <em>convertible to</em> <code>T</code> (rather than identical in type). However, in this case only certain conversions are considered. See [temp.deduct.call] in N3936,</p>\n<blockquote>\n<p id=\"so_29245209_29245344_0\">(4) In general, the deduction process attempts to find template argument values that will make the deduced <code>A</code>\n  identical to <code>A</code> (after the type <code>A</code> is transformed as described above). However, there are three cases that allow\n  a difference:</p>\n<p id=\"so_29245209_29245344_1\">(4.1) \u2014 If the original <code>P</code> is a reference type, the deduced <code>A</code> (i.e., the type referred to by the reference) can be\n  more cv-qualified than the transformed <code>A</code>.</p>\n<p id=\"so_29245209_29245344_2\">(4.2) \u2014 The transformed <code>A</code> can be another pointer or pointer to member type that can be converted to the\n  deduced <code>A</code> via a qualification conversion (4.4).</p>\n<p id=\"so_29245209_29245344_3\">(4.3) \u2014 If <code>P</code> is a class and <code>P</code> has the form <em>simple-template-id,</em> then the transformed <code>A</code> can be a derived class of\n  the deduced <code>A</code>. Likewise, if <code>P</code> is a pointer to a class of the form <em>simple-template-id,</em> the transformed <code>A</code>\n  can be a pointer to a derived class pointed to by the deduced <code>A</code>.</p>\n<p id=\"so_29245209_29245344_4\">(5) These alternatives are considered only if type deduction would otherwise fail. If they yield more than one\n  possible deduced <code>A</code>, the type deduction fails. [ <em>Note:</em> If a template-parameter is not used in any of the\n  function parameters of a function template, or is used only in a non-deduced context, its corresponding\n  <em>template-argument</em> cannot be deduced from a function call and the <em>template-argument</em> must be explicitly\n  specified. <em>\u2014 end note</em> ]</p>\n</blockquote>\n<p>Integer conversions, such as <code>int</code> to <code>unsigned long</code>, are not considered for parameter types that are in a deduced context. So <code>T</code> could not be <code>unsigned long</code> in this case, either. Thus, deduction of <code>T</code> fails altogether.</p>\n<p>My suggestion to fix:</p>\n<pre><code>template &lt;typename T, typename U&gt;\nvoid Set(T* a, U&amp;&amp; b)\n{\n    *a = std::forward&lt;U&gt;(b);\n}\n</code></pre>\n", "OwnerUserId": "481267", "LastEditorUserId": "481267", "LastEditDate": "2015-03-25T00:28:09.317", "Id": "29245344", "Score": "3", "CreationDate": "2015-03-25T00:17:32.117", "LastActivityDate": "2015-03-25T00:28:09.317"}, "bq_ids": {"n4140": {"so_29245209_29245344_2": {"section_id": 305, "quality": 0.9285714285714286, "length": 13}, "so_29245209_29245344_1": {"section_id": 305, "quality": 1.0, "length": 12}, "so_29245209_29245344_3": {"section_id": 305, "quality": 1.0, "length": 21}, "so_29245209_29245344_4": {"section_id": 306, "quality": 0.8947368421052632, "length": 34}, "so_29245209_29245344_0": {"section_id": 305, "quality": 1.0, "length": 23}}, "n3337": {"so_29245209_29245344_2": {"section_id": 296, "quality": 0.9285714285714286, "length": 13}, "so_29245209_29245344_1": {"section_id": 296, "quality": 1.0, "length": 12}, "so_29245209_29245344_3": {"section_id": 296, "quality": 1.0, "length": 21}, "so_29245209_29245344_4": {"section_id": 297, "quality": 0.8947368421052632, "length": 34}, "so_29245209_29245344_0": {"section_id": 296, "quality": 1.0, "length": 23}}, "n4659": {"so_29245209_29245344_2": {"section_id": 312, "quality": 0.9285714285714286, "length": 13}, "so_29245209_29245344_1": {"section_id": 312, "quality": 1.0, "length": 12}, "so_29245209_29245344_3": {"section_id": 312, "quality": 1.0, "length": 21}, "so_29245209_29245344_4": {"section_id": 313, "quality": 0.8947368421052632, "length": 34}, "so_29245209_29245344_0": {"section_id": 312, "quality": 1.0, "length": 23}}}, "29245288": {"ParentId": "29245209", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The value 1 is deduced to the type <code>int</code>, which doesn't match the template argument deduced by <code>&amp;a</code>.</p>\n<blockquote>\n<p id=\"so_29245209_29245288_0\">And is there a way to rewrite the template so that the original call\n  to Set would compile successfully</p>\n</blockquote>\n<p>Two parameter way : ( just for <em>completeness</em> )</p>\n<pre><code>#include &lt;type_traits&gt;\n// SFINAE : in case S is not convertible to T\ntemplate &lt;typename T, typename S,\n         typename std::enable_if&lt;\n         std::is_convertible&lt;S, T&gt;::value&gt;::type* = nullptr &gt;\nvoid Set(T *a, S b) \n{ \n   *a = b; \n}\n</code></pre>\n", "OwnerUserId": "1870232", "LastEditorUserId": "1870232", "LastEditDate": "2015-03-25T00:25:02.313", "Id": "29245288", "Score": "0", "CreationDate": "2015-03-25T00:12:06.533", "LastActivityDate": "2015-03-25T00:25:02.313"}});