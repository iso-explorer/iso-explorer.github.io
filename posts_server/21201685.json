post_cb({"21201894": {"ParentId": "21201685", "CommentCount": "0", "Body": "<p>Using local types as template arguments is not allowed in C++03. </p>\n<p>From ISO/IEC 14882,  <strong>14.3.1 Template type arguments [temp.arg.type]</strong>:</p>\n<blockquote>\n<p id=\"so_21201685_21201894_0\">A local type, a type with no linkage, an unnamed type or a type\n  compounded from any of these types shall not be used as a\n  template-argument for a template type-parameter.</p>\n</blockquote>\n<p>The example given is along these lines:</p>\n<pre><code>template &lt;typename T&gt; struct Foo {};\n\nvoid foo()\n{\n  struct Bar {};\n  Foo&lt;Bar&gt; b1;   // error: local type used as template-argument\n  Foo&lt;Bar*&gt; x4;  // error: pointer to local type used as template-argument\n}\n</code></pre>\n<p>This restriction has been lifted in C++11.</p>\n", "OwnerUserId": "661519", "PostTypeId": "2", "Id": "21201894", "Score": "5", "CreationDate": "2014-01-18T08:34:55.790", "LastActivityDate": "2014-01-18T08:34:55.790"}, "21201685": {"CommentCount": "5", "ViewCount": "1047", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-01-18T08:09:24.267", "LastActivityDate": "2014-01-18T09:26:17.853", "Title": "std::sort with local type Compare", "AcceptedAnswerId": "21201894", "LastEditDate": "2017-05-23T11:49:42.293", "Id": "21201685", "Score": "3", "Body": "<p>The following example</p>\n<pre><code>// file mysort.cc\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;string.h&gt;\n\nvoid mysort (const char**tab, unsigned size) {\n  std::vector&lt;int&gt; vecix;\n  vecix.resize(size);\n  struct CompareIndex {\n    const char**t;\n    CompareIndex(const char**p) : t(p) {};\n    bool operator() (int l, int r)  {\n      return strcmp(t[l], t[r])&lt;0;\n    }\n  };\n  CompareIndex compix(tab);\n  for (unsigned ix=0; ix&lt;size; ix++) vecix[ix] = ix;\n  std::stable_sort(vecix.begin(), vecix.end(), compix);\n  std::vector&lt;const char*&gt; vecstr;\n  vecstr.resize(size);\n  for (unsigned ix=0; ix&lt;size; ix++) vecstr[ix] = tab[vecix[ix]];\n  for (unsigned ix=0; ix&lt;size; ix++) tab[ix] = vecstr[ix];\n}    \n</code></pre>\n<p>fails to compile (using GCC 4.8.2 on Debian/Sid/x86-64 in C++03 standard)</p>\n<pre><code>mysort.cc: In function 'void mysort(const char**, unsigned int)':\nmysort.cc:19:58: error: no matching function for call to \n      'stable_sort(std::vector&lt;int&gt;::iterator, \n                   std::vector&lt;int&gt;::iterator, \n                   mysort(const char**, unsigned int)::CompareIndex&amp;)'\n   std::stable_sort(vecix.begin(), vecix.end(), compix);\n                                                      ^\n\n\nIn file included from /usr/include/c++/4.8/algorithm:62:0,\n                 from mysort.cc:4:\n/usr/include/c++/4.8/bits/stl_algo.h:5682:5: note: \n       template&lt;class _RAIter, class _Compare&gt;\n                void std::stable_sort(_RAIter, _RAIter, _Compare)\n     stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,\n     ^\n/usr/include/c++/4.8/bits/stl_algo.h:5682:5: note:   \n    template argument deduction/substitution failed:\nmysort.cc: In substitution of 'template&lt;class _RAIter, class _Compare&gt;\n     void std::stable_sort(_RAIter, _RAIter, _Compare)\n     [with _RAIter = __gnu_cxx::__normal_iterator&lt;int*, std::vector&lt;int&gt; &gt;;\n           _Compare = mysort(const char**, unsigned int)::CompareIndex]':\nmysort.cc:19:58:   required from here\nmysort.cc:19:58: error: template argument for\n    'template&lt;class _RAIter, class _Compare&gt; \n         void std::stable_sort(_RAIter, _RAIter, _Compare)'\n     uses local type 'mysort(const char**, unsigned int)::CompareIndex'\n       std::stable_sort(vecix.begin(), vecix.end(), compix);\n                                                          ^\nmysort.cc:19:58: error:   trying to instantiate\n            'template&lt;class _RAIter, class _Compare&gt;\n                     void std::stable_sort(_RAIter, _RAIter, _Compare)'\n</code></pre>\n<p>The above was compiled with <a href=\"http://gcc.gnu.org/gcc-4.8/\" rel=\"nofollow noreferrer\">GCC 4.8</a> using</p>\n<pre><code>  g++ -Wall -c mysort.cc\n</code></pre>\n<p>I am getting the same error with</p>\n<pre><code>  g++ -std=c++03 -Wall -c mysort.cc\n</code></pre>\n<p>or with</p>\n<pre><code>  g++ -std=c++98 -Wall -c mysort.cc\n</code></pre>\n<p>but no errors with </p>\n<pre><code>  g++ -std=c++11 -c mysort.cc\n</code></pre>\n<p>given that my <code>g++ -v</code> is a <code>gcc version 4.8.2 (Debian 4.8.2-12)</code></p>\n<p>but with <a href=\"http://llvm.org/releases/3.4/docs/ReleaseNotes.html\" rel=\"nofollow noreferrer\">Clang/LLVM 3.4</a> compiling with</p>\n<pre><code>  clang++ -Wall -c mysort.cc\n</code></pre>\n<p>I'm getting only a warning:</p>\n<pre><code>  mysort.cc:19:7: warning: template argument uses local \n                  type 'CompareIndex'\n                [-Wlocal-type-template-args]\n  std::stable_sort(vecix.begin(), vecix.end(), compix);\n  ^~~\n  1 warning generated.\n</code></pre>\n<p>(and I still get only a warning not an error when passing <code>-std=c++03</code> or <code>-std=c++98</code> to <code>clang++</code> but no warnings with <code>clang++ -std=c++11</code>)</p>\n<p>so my question is: why the error by GCC and the warning by Clang? Is my code legal and without undefined behavior (w.r.t. the C++03 standard)? Should I make my <code>CompareIndex</code> a global <code>struct</code> in my compilation unit?</p>\n<h3>motivations</h3>\n<p>Of course, this is a silly way to sort an array of C strings. \nThe real code is a bit different. In fact, I am trying to use <code>std::stable_sort</code> in my <a href=\"http://gcc-melt.org/\" rel=\"nofollow noreferrer\">MELT</a> plugin (a domain specific language to extend and customize GCC). MELT is generating C++ code and has a <em>copying</em> <a href=\"http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29\" rel=\"nofollow noreferrer\">garbage collector</a> (so pointers are moved by the GC). Hence, I need to sort using an array of indexes: the compare function in fact calls a MELT closure (which could trigger the copying GC at arbitrary moment), so I need to sort by indexes (and not by raw pointers). I want to keep the C++ code generated by MELT conforming to the C++ standard (03 or 98) required to compile GCC.</p>\n<h3>work-around</h3>\n<p>Thanks to <a href=\"https://stackoverflow.com/a/21201894/841108\">juanchopanza's answer</a> I've solved the issue by moving the declaration of <code>CompareIndex</code> at global scope before <code>mysort</code>.</p>\n<p><sup>I just committed the svn revision 206748 of the MELT branch of GCC; its file <code>gcc/melt/warmelt-base.melt</code> contains now a <code>multiple_sort_new</code> MELT function (to replace <code>multiple_sort</code> when it is working well) using <code>std::stable_sort</code>, and a global <code>Melt_Sort_Compare_Index</code> class in the generated C++ code.</sup></p>\n", "Tags": "<c++><gcc>", "OwnerUserId": "841108", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_21201685_21201894_0": {"section_id": 7141, "quality": 0.6666666666666666, "length": 8}}, "n3337": {"so_21201685_21201894_0": {"section_id": 6885, "quality": 0.6666666666666666, "length": 8}}, "n4659": {"so_21201685_21201894_0": {"section_id": 8642, "quality": 0.6666666666666666, "length": 8}}}});