post_cb({"bq_ids": {"n4140": {"so_44522331_44522662_0": {"length": 32, "quality": 0.9696969696969697, "section_id": 484}}, "n3337": {"so_44522331_44522662_0": {"length": 32, "quality": 0.9696969696969697, "section_id": 475}}}, "44522504": {"CreationDate": "2017-06-13T13:09:29.597", "CommentCount": "0", "Body": "<p>If you declare any constructors the default constructor is not <a href=\"http://en.cppreference.com/w/cpp/language/default_constructor\" rel=\"nofollow noreferrer\">implicitly generated</a>, you can generate it by adding a <code>= default</code> for it as well:</p>\n<pre><code>class B : public A {\n\npublic:\n\n    B() = default;\n    B(const B&amp;) =   default;\n    B(      B&amp;&amp;) =  default;\n};\n</code></pre>\n<blockquote>\n<p id=\"so_44522331_44522504_0\">This has changed with <a href=\"http://en.cppreference.com/w/cpp/language/using_declaration#Inheriting_constructors\" rel=\"nofollow noreferrer\">C++17</a> (as pointed out by <a href=\"https://stackoverflow.com/a/44522990/377927\">other</a> answer).</p>\n</blockquote>\n", "Id": "44522504", "OwnerUserId": "377927", "LastEditDate": "2017-06-14T12:15:59.360", "ParentId": "44522331", "LastActivityDate": "2017-06-14T12:15:59.360", "PostTypeId": "2", "Score": "5", "LastEditorUserId": "377927"}, "44522331": {"CreationDate": "2017-06-13T13:02:41.977", "ViewCount": "405", "Id": "44522331", "AcceptedAnswerId": "44522990", "Score": "9", "Title": "C++ Default constructor not inherited with \"using\" when move and copy constructors present", "LastEditorUserId": "3309790", "CommentCount": "11", "Body": "<pre><code>class A{\n\npublic:\n    A(){};\n\n};\n\nclass B : public A{\n\npublic:\n    using A::A;\n\n    B(const B&amp;) =   default;\n    B(      B&amp;&amp;) =  default;\n\n};\n\nB b;\n</code></pre>\n<p>The compiler (g++ (5.4.0-6ubuntu1) / c++11) says \"no matching function for call to B::B()\" and lists the copy and move constructors as candidates. If I comment those defaulted ones out then it compiles. What causes this? And what difference does it make that they are explicitly defaulted? If those 2 lines weren't there they would be defaulted anyway.</p>\n", "Tags": "<c++><c++11><constructor><language-lawyer><c++1z>", "LastEditDate": "2017-06-13T14:59:04.690", "LastActivityDate": "2017-06-14T12:24:02.753", "PostTypeId": "1", "AnswerCount": "3", "OwnerUserId": "8038490"}, "44522662": {"CreationDate": "2017-06-13T13:16:05.880", "CommentCount": "3", "Body": "<p>The default constructor cannot be inherited, the standard explicitly says so. Quoting C++11 12.9 [class.inhctor]/3 (emphasis mine) <sup>(*)</sup>:</p>\n<blockquote>\n<p id=\"so_44522331_44522662_0\">For each non-template constructor in the candidate set of inherited constructors <strong>other than a constructor\n  having no parameters</strong> or a copy/move constructor having a single parameter, a constructor is implicitly\n  declared with the same constructor characteristics unless there is a user-declared constructor with the same\n  signature in the class where the using-declaration appears. ...</p>\n</blockquote>\n<p>This means that for the default constructor, normal rules apply as if the <code>using A::A;</code> declaration wasn't there. So the presence of any other constructor declaration (such as the copy &amp; move constructor) causes the default constructor not to be implicitly declared. Note that you can easily add it back by explicitly defaulting it:</p>\n<pre><code>class B : public A{\n\npublic:\n    using A::A;\n\n    B() = default;\n\n    B(const B&amp;) =   default;\n    B(      B&amp;&amp;) =  default;\n\n};\n</code></pre>\n<hr>\n<p><sup>(*)</sup> The same wording is present in C++14 (n4140), at the same location. I can't seem to find equivalent wording in C++1z (looking through n4582)</p>\n</hr>", "Id": "44522662", "OwnerUserId": "1782465", "LastEditDate": "2017-06-13T13:25:49.813", "ParentId": "44522331", "LastActivityDate": "2017-06-13T13:25:49.813", "PostTypeId": "2", "Score": "3", "LastEditorUserId": "1782465"}, "44522990": {"CreationDate": "2017-06-13T13:29:03.503", "CommentCount": "2", "Body": "<p>Before C++17, the default constructor of the base class won't be <a href=\"http://en.cppreference.com/w/cpp/language/using_declaration#Inheriting_constructors\" rel=\"nofollow noreferrer\">inherited</a> via <code>using</code>:</p>\n<blockquote>\n<p id=\"so_44522331_44522990_0\">All candidate inherited constructors that aren't the default constructor or the copy/move constructor and whose signatures do not match user-defined constructors in the derived class, are implicitly declared in the derived class. (until C++17)</p>\n</blockquote>\n<p>After C++17 the code works fine. </p>\n<p>Before that, the default constructor won't be inherited from the base class, and won't be <a href=\"http://en.cppreference.com/w/cpp/language/default_constructor#Implicitly-declared_default_constructor\" rel=\"nofollow noreferrer\">generated</a> for class <code>B</code> because copy/move constructor are provided. </p>\n<blockquote>\n<p id=\"so_44522331_44522990_1\">If no user-declared constructors of any kind are provided for a class type (struct, class, or union), the compiler will always declare a default constructor as an inline public member of its class.</p>\n</blockquote>\n<p>That's why if you comment copy/move constructor out it compiles. You can add the definition explicitly as a pre-C++17 workaround. e.g.</p>\n<pre><code>class B : public A {\npublic:\n    B(const B&amp;) =   default;\n    B(      B&amp;&amp;) =  default;\n\n    B() = default;\n};\n</code></pre>\n<hr>\n<p><sup>The code compiles with <a href=\"https://wandbox.org/permlink/9hpmp1KOSMs7DzCn\" rel=\"nofollow noreferrer\">gcc8</a>.</sup></p>\n</hr>", "Id": "44522990", "OwnerUserId": "3309790", "LastEditDate": "2017-06-14T12:24:02.753", "ParentId": "44522331", "LastActivityDate": "2017-06-14T12:24:02.753", "PostTypeId": "2", "Score": "8", "LastEditorUserId": "3309790"}});