post_cb({"15898163": {"ParentId": "15898121", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2013-04-09T09:22:44.950", "Score": "26", "LastEditorUserId": "464581", "LastEditDate": "2013-04-09T09:27:47.660", "Id": "15898163", "OwnerUserId": "464581", "Body": "<p>make sure the base class has at least one virtual method, include <code>&lt;typeinfo&gt;</code> and use your current code just with an additional dereferencing, <code>typeid(*b).name()</code>.\n<hr>\nin passing, note that a <code>typeid</code> call is the one place in C++ where you can dereference a nullpointer with well-defined behavior, which implies that it can throw an exception:</hr></p>\n<blockquote>\n<p id=\"so_15898121_15898163_0\"><strong>C++11 \u00a75.2.8/2</strong>:<br>\n  \u201cIf the glvalue expression is obtained by applying the unary <code>*</code> operator to a\n  pointer and the pointer is a null pointer value (4.10), the <code>typeid</code> expression throws the <code>std::bad_typeid</code> exception (18.7.3).\u201d</br></p>\n</blockquote>\n", "LastActivityDate": "2013-04-09T09:27:47.660"}, "bq_ids": {"n4140": {"so_15898121_15898163_0": {"section_id": 6021, "quality": 0.8, "length": 16}}, "n3337": {"so_15898121_15898163_0": {"section_id": 5789, "quality": 0.8, "length": 16}}, "n4659": {"so_15898121_15898163_0": {"section_id": 7520, "quality": 0.8, "length": 16}}}, "15898370": {"ParentId": "15898121", "CommentCount": "1", "Body": "<p>If all you want to do is find if <code>b</code> actually points to <code>Derived</code>, just use <code>dynamic_cast()</code>:</p>\n<pre><code>if (dynamic_cast&lt;Derived*&gt;(b)) { ... }\n</code></pre>\n<p><code>dynamic_cast</code> returns a null pointer if the actual runtime type of the object pointed to by <code>b</code> is not <code>Derived</code> (or a class derived from <code>Derived</code>). Unlike the <code>name()</code> member of <code>std::type_info</code>, this is compiler-invariant.</p>\n<p>Note that this only works if <code>Base</code> has at least one virtual member functions. Which it should anyway, since you're manipulating types derived from it through a base pointer, so it should have a virtual destructor.</p>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "15898370", "Score": "8", "CreationDate": "2013-04-09T09:32:24.570", "LastActivityDate": "2013-04-09T09:32:24.570"}, "15898121": {"CommentCount": "3", "CreationDate": "2013-04-09T09:20:55.270", "PostTypeId": "1", "AcceptedAnswerId": "15898163", "LastEditorUserId": "2038383", "LastActivityDate": "2014-02-17T04:03:28.970", "LastEditDate": "2014-02-17T04:03:28.970", "ViewCount": "17118", "FavoriteCount": "5", "Title": "How to determine actual object type at runtime in C++;", "Id": "15898121", "Score": "14", "Body": "<p>Lets say we have a class hierarchy. At the bottom we have Base and at the top Derived.\nHow to determine object class even if it is converted to base class pointer.</p>\n<pre><code>Base* b = new Derived():\n\ntypeid(b).name(); // i want this to tell me that this is actually derived not base object\n</code></pre>\n<p>is there any way other than manual implementation of string field or such and virtual get function? </p>\n<p>PS: I talking about compiler-independent solution</p>\n", "Tags": "<c++><typeid><typeinfo>", "OwnerUserId": "1079475", "AnswerCount": "2"}});