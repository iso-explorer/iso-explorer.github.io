post_cb({"6936997": {"Id": "6936997", "PostTypeId": "2", "Body": "<p>In your first run, the objects are destroyed in the order they were pushed on the stack -&gt; that is push A, push B, pop B, pop A.</p>\n<p>In the second run, A's lifetime ends with the construction of b. Therefore, it creates A, it creates B from A, A's lifetime finishes so it is destroyed, and then B is destroyed. Makes sense...</p>\n", "LastActivityDate": "2011-08-04T06:20:40.033", "CommentCount": "2", "CreationDate": "2011-08-04T06:20:40.033", "ParentId": "6936720", "Score": "2", "OwnerUserId": "673730"}, "6938295": {"Id": "6938295", "PostTypeId": "2", "Body": "<p>\u00a712.2/5 says <em>\u201cThe second context [when the lifetime of a temporary\nis extended] is when a reference is bound to a temporary.\u201d</em>  Taken\nliterally, this clearly says that the lifetime should be extended in\nyour case; your <code>B::a</code> is certainly bound to a temporary.  (A reference\nbinds to an object, and I don't see any other object it could possibly\nbe bound to.)  This is very poor wording, however; I'm sure that what is\nmeant is <em>\u201cThe second context is when a temporary is used to\ninitialize a reference,\u201d</em> and the extended lifetime corresponds to\nthat of the reference initiailized with the rvalue expression creating\nthe temporary, and not to that of any other references which may later\nbe bound to the object.  As it stands, the wording requires something\nthat simply isn't implementable: consider:</p>\n<pre><code>void f(A const&amp; a)\n{\n    static A const&amp; localA = a;\n}\n</code></pre>\n<p>called with:</p>\n<pre><code>f(A());\n</code></pre>\n<p>Where should the compiler put <code>A()</code> (given that it generally cannot see\nthe code of <code>f()</code>, and doesn't know about the local static when\ngenerating the call)?</p>\n<p>I think, actually, that this is worth a DR.</p>\n<p>I might add that there is text which strongly suggests that my\ninterpretation of the intent is correct.  Imagine that you had a second\nconstructor for <code>B</code>:</p>\n<pre><code>B::B() : a(A()) {}\n</code></pre>\n<p>In this case, <code>B::a</code> would be directly initialized with a temporary; the\nlifetime of this temporary should be extended even by my interpretation.\nHowever, the standard makes a specific exception for this case; such a\ntemporary only persists until the constructor exits (which again would\nleave you with a dangling reference).  This exception provides a very\nstrong indication that the authors of the standard didn't intend for\nmember references in a class to extend the lifetime of any temporaries\nthey are bound to; again, the motivation is implementability.  Imagine\nthat instead of</p>\n<pre><code>B b((A()));\n</code></pre>\n<p>you'd written:</p>\n<pre><code>B* b = new B(A());\n</code></pre>\n<p>Where should the compiler put the temporary <code>A()</code> so that it's lifetime\nwould be that of the dynamically allocated <code>B</code>?</p>\n", "LastEditorUserId": "102441", "LastActivityDate": "2017-01-01T22:02:00.640", "Score": "4", "CreationDate": "2011-08-04T08:25:54.517", "ParentId": "6936720", "CommentCount": "5", "OwnerUserId": "649665", "LastEditDate": "2017-01-01T22:02:00.640"}, "6936720": {"ViewCount": "2530", "Body": "<p>I know that a temporary <em>cannot</em> be bound to a non-const reference, but it <em>can be</em> bound to const reference. That is,</p>\n<pre><code> A &amp; x = A(); //error\n const A &amp; y = A(); //ok\n</code></pre>\n<p>I also know that in the second case (above), the lifetime of the temporary created out of <code>A()</code> extends till the lifetime of const reference (i.e <code>y</code>).</p>\n<p>But my question is:</p>\n<p><strong>Can the const reference which is bound to a temporary, be <em>further</em> bound to yet another const reference, extending the lifetime of the temporary till the lifetime of second object?</strong> </p>\n<p>I tried this and it didn't work. I don't exactly understand this. I wrote this code:</p>\n<pre><code>struct A\n{\n   A()  { std::cout &lt;&lt; \" A()\" &lt;&lt; std::endl; }\n   ~A() { std::cout &lt;&lt; \"~A()\" &lt;&lt; std::endl; }\n};\n\nstruct B\n{\n   const A &amp; a;\n   B(const A &amp; a) : a(a) { std::cout &lt;&lt; \" B()\" &lt;&lt; std::endl; }\n   ~B() { std::cout &lt;&lt; \"~B()\" &lt;&lt; std::endl; }\n};\n\nint main() \n{\n        {\n            A a;\n            B b(a);\n        }\n        std::cout &lt;&lt; \"-----\" &lt;&lt; std::endl;\n        {\n            B b((A())); //extra braces are needed!\n        }\n}\n</code></pre>\n<p>Output (<a href=\"http://www.ideone.com/hgADU\" rel=\"noreferrer\">ideone</a>):</p>\n<pre><code> A()\n B()\n~B()\n~A()\n-----\n A()\n B()\n~A()\n~B()\n</code></pre>\n<p>Difference in output? Why the temporary object <code>A()</code> is destructed before the object <code>b</code> in the second case? Does the Standard (C++03) talks about this behavior?</p>\n", "AcceptedAnswerId": "6937829", "Title": "Why lifetime of temporary doesn't extend till lifetime of enclosing object?", "CreationDate": "2011-08-04T05:45:49.867", "Id": "6936720", "CommentCount": "4", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2011-08-04T06:30:13.983", "LastEditorUserId": "415784", "LastActivityDate": "2017-01-01T22:02:00.640", "Score": "27", "OwnerUserId": "415784", "Tags": "<c++><temporary>", "AnswerCount": "7"}, "17354675": {"Id": "17354675", "PostTypeId": "2", "Body": "<p><strong>Your example doesn't perform nested lifetime extension</strong></p>\n<p><em>In the constructor</em></p>\n<pre><code>B(const A &amp; a_) : a(a_) { std::cout &lt;&lt; \" B()\" &lt;&lt; std::endl; }\n</code></pre>\n<p>The <code>a_</code> here (renamed for exposition) is not a temporary. Whether an expression is a temporary is a syntactic property of the expression, and an <em>id-expression</em> is never a temporary. So no lifetime extension occurs here.</p>\n<p>Here's a case where lifetime-extension would occur:</p>\n<pre><code>B() : a(A()) { std::cout &lt;&lt; \" B()\" &lt;&lt; std::endl; }\n</code></pre>\n<p>However, because the reference is initialized in a ctor-initializer, the lifetime is only extended until the end of the function. Per <strong>[class.temporary]p5</strong>:</p>\n<blockquote>\n<p id=\"so_6936720_17354675_0\">A temporary bound to a reference member in a constructor's <em>ctor-initializer</em> (12.6.2) persists until the constructor exits.</p>\n</blockquote>\n<p><em>In the call to the constructor</em></p>\n<pre><code>B b((A())); //extra braces are needed!\n</code></pre>\n<p>Here, we <em>are</em> binding a reference to a temporary. <strong>[class.temporary]p5</strong> says:</p>\n<blockquote>\n<p id=\"so_6936720_17354675_1\">A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full-expression containing the call.</p>\n</blockquote>\n<p>Therefore the <code>A</code> temporary is destroyed at the end of the statement. This happens before the <code>B</code> variable is destroyed at the end of the block, explaining your logging output.</p>\n<p><strong>Other cases do perform nested lifetime extension</strong></p>\n<p><em>Aggregate variable initialization</em></p>\n<p>Aggregate initialization of a struct with a reference member can lifetime-extend:</p>\n<pre><code>struct X {\n  const A &amp;a;\n};\nX x = { A() };\n</code></pre>\n<p>In this case, the <code>A</code> temporary is bound directly to a reference, and so the temporary is lifetime-extended to the lifetime of <code>x.a</code>, which is the same as the lifetime of <code>x</code>. (Warning: until recently, very few compilers got this right).</p>\n<p><em>Aggregate temporary initialization</em></p>\n<p>In C++11, you can use aggregate initialization to initialize a temporary, and thus get recursive lifetime extension:</p>\n<pre><code>struct A {\n   A()  { std::cout &lt;&lt; \" A()\" &lt;&lt; std::endl; }\n   ~A() { std::cout &lt;&lt; \"~A()\" &lt;&lt; std::endl; }\n};\n\nstruct B {\n   const A &amp;a;\n   ~B() { std::cout &lt;&lt; \"~B()\" &lt;&lt; std::endl; }\n};\n\nint main() {\n  const B &amp;b = B { A() };\n  std::cout &lt;&lt; \"-----\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>With trunk Clang or g++, this produces the following output:</p>\n<pre><code> A()\n-----\n~B()\n~A()\n</code></pre>\n<p>Note that both the <code>A</code> temporary and the <code>B</code> temporary are lifetime-extended. Because the construction of the <code>A</code> temporary completes first, it is destroyed last.</p>\n<p><em>In <code>std::initializer_list&lt;T&gt;</code> initialization</em></p>\n<p>C++11's <code>std::initializer_list&lt;T&gt;</code> performs lifetime-extension as if by binding a reference to the underlying array. Therefore we can perform nested lifetime extension using <code>std::initializer_list</code>. However, compiler bugs are common in this area:</p>\n<pre><code>struct C {\n  std::initializer_list&lt;B&gt; b;\n  ~C() { std::cout &lt;&lt; \"~C()\" &lt;&lt; std::endl; }\n};\nint main() {\n  const C &amp;c = C{ { { A() }, { A() } } };\n  std::cout &lt;&lt; \"-----\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Produces with Clang trunk:</p>\n<pre><code> A()\n A()\n-----\n~C()\n~B()\n~B()\n~A()\n~A()\n</code></pre>\n<p>and with g++ trunk:</p>\n<pre><code> A()\n A()\n~A()\n~A()\n-----\n~C()\n~B()\n~B() \n</code></pre>\n<p>These are both wrong; the correct output is:</p>\n<pre><code> A()\n A()\n-----\n~C()\n~B()\n~A()\n~B()\n~A()\n</code></pre>\n", "LastActivityDate": "2013-06-27T23:04:37.450", "CommentCount": "0", "CreationDate": "2013-06-27T23:04:37.450", "ParentId": "6936720", "Score": "4", "OwnerUserId": "1041090"}, "6937829": {"Id": "6937829", "PostTypeId": "2", "Body": "<p>The standard considers two circumstances under which the lifetime of a temporary is extended: </p>\n<blockquote>\n<p id=\"so_6936720_6937829_0\">\u00a712.2/4 There are two contexts in which temporaries are destroyed at a different point than the end of the fullexpression. The first context is when an expression appears as an initializer for a declarator defining an object. In that context, the temporary that holds the result of the expression shall persist until the object\u2019s initialization is complete. [...]</p>\n<p id=\"so_6936720_6937829_1\">\u00a712.2/5 The second context is when a reference is bound to a temporary. [...]</p>\n</blockquote>\n<p>None of those two allow you to extend the lifetime of the temporary by a later binding of the reference to another const reference. But ignore the standarese and think of what is going on:</p>\n<p>Temporaries are created in the stack. Well, technically, the calling convention might mean that a returned value (temporary) that fits in the registers might not even be created in the stack, but bear with me. When you bind a constant reference to a temporary the compiler <em>semantically</em> creates a hidden named variable (that is why the copy constructor needs to be accessible, even if it is not called) and binds the reference to that variable. Whether the copy is actually made or elided is a detail: what we have is an <em>unnamed</em> local variable and a reference to it.</p>\n<p>If the standard allowed your use case, then it would mean that the lifetime of the temporary would have to be extended all the way until the last reference to that variable. Now consider this simple extension of your example:</p>\n<pre><code>B* f() {\n   B * bp = new B(A());\n   return b;\n}\nvoid test() {\n   B* p = f();\n   delete p;\n}\n</code></pre>\n<p>Now the problem is that the temporary (lets call it <code>_T</code>) is bound in <code>f()</code>, it behaves like a local variable there. The reference is bound inside <code>*bp</code>. Now that object's lifetime extends beyond the function that created the temporary, but because <code>_T</code> was not dynamically allocated that is impossible.</p>\n<p>You can try and reason the effort that would be required to extend the lifetime of the temporary in this example, and the answer is that it cannot be done without some form of GC.</p>\n", "LastActivityDate": "2011-08-04T07:41:22.863", "CommentCount": "2", "CreationDate": "2011-08-04T07:41:22.863", "ParentId": "6936720", "Score": "14", "OwnerUserId": "36565"}, "bq_ids": {"n4140": {"so_6936720_17354675_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 382}, "so_6936720_17354675_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 382}, "so_6936720_6937829_1": {"length": 6, "quality": 0.75, "section_id": 382}, "so_6936720_6976563_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 382}, "so_6936720_6937056_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 382}}, "n3337": {"so_6936720_6976563_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 373}, "so_6936720_6937056_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 373}, "so_6936720_6937829_1": {"length": 6, "quality": 0.75, "section_id": 373}, "so_6936720_17354675_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 373}, "so_6936720_17354675_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 373}}, "n4659": {"so_6936720_6976563_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 397}, "so_6936720_6937829_1": {"length": 5, "quality": 0.625, "section_id": 397}, "so_6936720_17354675_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 397}}}, "6976563": {"Id": "6976563", "PostTypeId": "2", "Body": "<p>\u00a712.2/5 says </p>\n<blockquote>\n<p id=\"so_6936720_6976563_0\">A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full expression containing the call.</p>\n</blockquote>\n<p>Pretty cut and dried, really.</p>\n", "LastActivityDate": "2011-08-07T23:39:25.103", "CommentCount": "0", "CreationDate": "2011-08-07T23:39:25.103", "ParentId": "6936720", "Score": "0", "OwnerUserId": "103167"}, "6937121": {"Id": "6937121", "PostTypeId": "2", "Body": "<p>I don't know about standards, but can discuss some facts which I saw in few previous questions. </p>\n<p>The 1st output is as is for obvious reasons that <code>a</code> and <code>b</code> are in the same scope. Also  <code>a</code> is destroyed after <code>b</code> because it's constructed before <code>b</code>.</p>\n<p>I assume that you should be more interested in 2nd output. Before I start, we should note that following kind of object creations (stand alone temporaries):</p>\n<pre><code>{\n  A();\n}\n</code></pre>\n<p>last only till the next <code>;</code> and <strong>not for the block surrounding</strong> it. <a href=\"http://www.ideone.com/1LzXH\" rel=\"nofollow\">Demo</a>. In your 2nd case, when you do,</p>\n<pre><code>B b((A()));\n</code></pre>\n<p>thus <code>A()</code> is destroyed as soon as the <code>B()</code> object creation finishes. Since, const reference can be bind to temporary, this will not give compilation error. However it will surely result in logical error if you try to access <code>B::a</code>, which is now bound to already out of scope variable.</p>\n", "LastActivityDate": "2011-08-04T06:34:37.390", "CommentCount": "0", "CreationDate": "2011-08-04T06:34:37.390", "ParentId": "6936720", "Score": "1", "OwnerUserId": "514235"}, "6937056": {"Id": "6937056", "PostTypeId": "2", "Body": "<p>No, the extended lifetime is not further extended by passing the reference on.</p>\n<p>In the second case, the temporary is bound to the <em>parameter</em> a, and destroyed at the end of the parameter's lifetime - the end of the constructor.</p>\n<p>The standard explicitly says:</p>\n<blockquote>\n<p id=\"so_6936720_6937056_0\">A temporary bound to a reference member in a constructor's ctor-initializer (12.6.2) persists until the constructor exits.</p>\n</blockquote>\n", "LastEditorUserId": "597607", "LastActivityDate": "2011-08-04T06:35:09.413", "Score": "7", "CreationDate": "2011-08-04T06:27:48.613", "ParentId": "6936720", "CommentCount": "4", "OwnerUserId": "597607", "LastEditDate": "2011-08-04T06:35:09.413"}});