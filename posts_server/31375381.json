post_cb({"31375497": {"ParentId": "31375381", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-07-13T04:39:08.153", "Score": "2", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:06:13.537", "Id": "31375497", "OwnerUserId": "2639513", "Body": "<p>The constexpr key word by my experiments <a href=\"https://stackoverflow.com/questions/31373689/constexpr-variable-evaluation/31373971#31373971\" title=\"here\">in this answer</a> more or less instructs the compiler that it must be able to statically resolve all codepaths given in that call. That is, at least right now (it would appear), everything must be declared constexpr along that codepath otherwise it will fail. For example, in your code, the initial constexpr assignment to b will fail if you don't declare the operator or constructor constexpr. It appears that the constexpr only takes effect when you're assigning to a variable that is declared constexpr, otherwise it seems to only serve as an adviser to the compiler that the codepath can be optimized via static evaluation, but it's not guaranteed to do it if you don't explicitly instruct it with a constexpr variable assignment.</p>\n<p>That being said, it would appear that declaring a constructor constexpr has no affect under normal circumstances. The machine code below was produced with the following command line:</p>\n<pre><code>g++ -std=c++11 -Wall -g  -c main.cpp -o obj/Debug/main.o\ng++  -o bin/Debug/TestProject obj/Debug/main.o  \n</code></pre>\n<p>And so your b assignment produces this code:</p>\n<pre><code>0x4005bd    push   rbp\n0x4005be    mov    rbp,rsp\n0x4005c1    mov    DWORD PTR [rbp-0x4],0x1\n0x4005c8    mov    eax,0x0\n0x4005cd    pop    rbp\n0x4005ce    ret\n</code></pre>\n<p>However, if you remove the constexpr declaration on the b variable:</p>\n<pre><code>0x4005bd    push   rbp\n0x4005be    mov    rbp,rsp\n0x4005c1    sub    rsp,0x10\n0x4005c5    lea    rax,[rbp-0x5]\n0x4005c9    mov    rdi,rax\n0x4005cc    call   0x4005ee &lt;test::test()&gt;\n0x4005d1    lea    rdx,[rbp-0x5]\n0x4005d5    lea    rax,[rbp-0x6]\n0x4005d9    mov    rsi,rdx\n0x4005dc    mov    rdi,rax\n0x4005df    call   0x4005f8 &lt;test::operator+(test const&amp;) const&gt;\n0x4005e4    mov    DWORD PTR [rbp-0x4],eax\n0x4005e7    mov    eax,0x0\n0x4005ec    leave\n0x4005ed    ret\n</code></pre>\n<p>It appears to be handled as if the operator and constructor weren't declared constexpr, but this is a situation where you should consult the specifics about your compiler, really.</p>\n", "LastActivityDate": "2015-07-13T04:47:11.550"}, "31375381": {"CommentCount": "2", "AcceptedAnswerId": "31384320", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-07-13T04:21:45.760", "LastActivityDate": "2015-07-22T19:14:19.337", "LastEditDate": "2015-07-13T13:10:25.193", "ViewCount": "4352", "FavoriteCount": "6", "Title": "Does specifying constexpr on constructor automatically makes all objects created from it to be constexpr?", "Id": "31375381", "Score": "21", "Body": "<p>Here is my code:</p>\n<pre><code>class test{\n    public:\n    constexpr test(){\n\n    }\n\n    constexpr int operator+(const test&amp; rhs){\n        return 1;\n    }\n};\n\n\n\nint main(){\n\n    test t;                         //constexpr word isn't necessary\n    constexpr int b = t+test();     // works at compile time!\n\n\n    int w = 10;                     // ERROR constexpr required\n    constexpr int c = w + 2;        // Requires w to be constexpr\n    return 0;\n}\n</code></pre>\n<p>I notice that it worked even though I didn't specify test to be <code>constexpr</code>. I tried replicating the result by doing the same with <code>int</code> but i get errors. Specifically, it wants my <code>int w</code> inside the <code>constexpr int c = w + 2;</code> to be <code>constexpr</code>. From my first attempt which is using <code>test</code>, Did it work because of the reason that i used <code>constexpr</code> on the constructor already? If that is the case then would it good to assume that all classes that have <code>constexpr</code> on their constructors will result to all objects instantiated or created with it to be <code>constexpr</code>?</p>\n<p>Bonus question:</p>\n<p>If I have a <code>constexpr</code> constructor, is it bad to do something like ? <code>test * t = new test();</code> ?  </p>\n", "Tags": "<c++><c++11><constexpr>", "OwnerUserId": "2910144", "AnswerCount": "3"}, "31377416": {"ParentId": "31375381", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2015-07-13T07:15:36.713", "Score": "5", "LastEditorUserId": "2567683", "LastEditDate": "2015-07-13T09:27:31.260", "Id": "31377416", "OwnerUserId": "2567683", "Body": "<p>The effect that a <code>constexpr</code> constructor has on the class type can be read in the C++ Standard</p>\n<blockquote>\n<h2>3.9 Types</h2>\n<p id=\"so_31375381_31377416_0\">(...)</p>\n<ol start=\"10\">\n<li><p id=\"so_31375381_31377416_1\">A type is a literal type if it is:</p>\n<ul>\n<li>it is an aggregate type (8.5.1) <strong>or has at least one constexpr constructor</strong> or constructor template that is not a copy or move constructor </li>\n</ul></li>\n</ol>\n<p id=\"so_31375381_31377416_2\">(...)</p>\n</blockquote>\n<p>So <code>constexpr</code> constructors means that <strong>static initialization</strong> can be performed and uses like <a href=\"http://coliru.stacked-crooked.com/a/379920a76ad26902\" rel=\"nofollow\"><strong>this one</strong></a> are possible :</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct test {\n    int val; \n    constexpr test(int val) : val(val) { }\n};\n\ntemplate&lt;int N&gt;\nstruct CC {\n    double m[N]; \n};\n\nint main()\n{\n    CC&lt;test(6).val&gt; k; // usage where compile time constant is required\n    std::cout &lt;&lt; std::end(k.m) - std::begin(k.m) &lt;&lt; std::endl; \n    return 0;\n}\n</code></pre>\n<p>The mere fact that <code>test</code> is a <em>literal class</em> <strong>does not mean all its instances will be constant expressions</strong>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct test {\n    int val;\n    constexpr test(int val) : val(val) { }\n};\n\nint main()\n{\n    test a(1); \n    ++a.val; \n    std::cout &lt;&lt; a.val &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p><kbd><a href=\"http://coliru.stacked-crooked.com/a/f657d50e3e9d409a\" rel=\"nofollow\">Demo</a></kbd></p>\n<p>In the example above the instance <code>a</code> was not declared as a constant so even though <code>a</code> could be a <code>constexpr</code> constant, it's not one (hence it can be modified).</p>\n", "LastActivityDate": "2015-07-13T09:27:31.260"}, "bq_ids": {"n4140": {"so_31375381_31384320_0": {"section_id": 6185, "quality": 0.6, "length": 6}, "so_31375381_31384320_3": {"section_id": 6185, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_31375381_31384320_0": {"section_id": 5946, "quality": 0.9, "length": 9}, "so_31375381_31384320_2": {"section_id": 5946, "quality": 0.9444444444444444, "length": 17}, "so_31375381_31384320_3": {"section_id": 5946, "quality": 1.0, "length": 12}}, "n4659": {"so_31375381_31384320_3": {"section_id": 7687, "quality": 0.9166666666666666, "length": 11}}}, "31384320": {"ParentId": "31375381", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-07-13T13:09:51.937", "Score": "10", "LastEditorUserId": "1708801", "LastEditDate": "2015-07-22T19:14:19.337", "Id": "31384320", "OwnerUserId": "1708801", "Body": "<p>Having a constexpr constructor does not make declarations of that variable automatically constexpr, so <code>t</code> is not a constexpr. What is going on in this case is that you are calling a constexpr function, this line:</p>\n<pre><code>constexpr int b = t+test(); \n</code></pre>\n<p>can be viewed as follows:</p>\n<pre><code>constexpr int b = t.operator+( test() ); \n</code></pre>\n<p>So then the question is whether <code>test()</code> is a constant expression, which it is since the constructor is constexpr and does not fall under any of the exceptions under the draft C++11 standard section <code>5.19</code> <em>[expr.const]</em> paragraph <code>2</code> which says:</p>\n<blockquote>\n<p id=\"so_31375381_31384320_0\">A conditional-expression is a core constant expression unless it\n  involves one of the following as a potentially evaluated subexpression\n  [...]</p>\n</blockquote>\n<p>and includes the following bullet:</p>\n<blockquote>\n<ul>\n<li>an invocation of a function other than a constexpr constructor for a literal class or a constexpr function [ Note: Overload resolution\n  (13.3) is applied as usual \u2014end note ];</li>\n</ul>\n<p id=\"so_31375381_31384320_1\">[...]</p>\n<ul>\n<li><p id=\"so_31375381_31384320_2\">an invocation of a constexpr constructor with arguments that, when substituted by function invocation\n  substitution (7.1.5), do not produce all constant expressions for the constructor calls and\n  full-expressions in the mem-initializers</p></li>\n<li><p id=\"so_31375381_31384320_3\">an invocation of a constexpr function or a constexpr constructor that would exceed the implementationdefined\n  recursion limits (see Annex B);</p></li>\n</ul>\n</blockquote>\n<p>We can see this more readily by making some small changes to <code>test</code> by introducing a member variable <code>x</code>:</p>\n<pre><code>class test{\n    public:\n    constexpr test(){\n\n    }\n\n    constexpr int operator+(const test&amp; rhs) const {\n        return x + 1  ;\n    }\n\n    int x = 10 ;\n};\n</code></pre>\n<p>Attempting to access it in <code>operator +</code> and we can see that the following line now fails:</p>\n<pre><code>constexpr int b = t+test();\n</code></pre>\n<p>with the following error from clang (<em><a href=\"http://melpon.org/wandbox/permlink/1iyAk1mOJlwYUtLJ\" rel=\"nofollow\">see it live</a></em>):</p>\n<pre><code>error: constexpr variable 'b' must be initialized by a constant expression\nconstexpr int b = t+test();     // works at compile time!\n              ^   ~~~~~~~~\n\nnote: read of non-constexpr variable 't' is not allowed in a constant expression\n    return x + 1  ;\n           ^\n</code></pre>\n<p>It fails because <code>t</code> is not a constexpr variable and therefore its subobjects are also not constexpr variables.</p>\n<p>Your second example:</p>\n<pre><code> constexpr int c = w + 2;  \n</code></pre>\n<p>does not work because it falls under one of the exceptions in the draft C++11 standard section <code>5.19</code> <em>[expr.const]</em> :</p>\n<blockquote>\n<ul>\n<li><p id=\"so_31375381_31384320_4\">an lvalue-to-rvalue conversion (4.1) unless it is applied to</p>\n<p id=\"so_31375381_31384320_5\">[...]</p>\n<ul>\n<li>a glvalue of integral or enumeration type that refers to a non-volatile const object with a preceding initialization, initialized\n  with a constant expression, or</li>\n</ul></li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2015-07-22T19:14:19.337"}});