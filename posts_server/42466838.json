post_cb({"bq_ids": {"n4140": {"so_42466838_42488624_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 5455}, "so_42466838_42488624_0": {"length": 10, "quality": 1.0, "section_id": 5455}}, "n3337": {"so_42466838_42488624_0": {"length": 6, "quality": 0.6, "section_id": 3191}}, "n4659": {"so_42466838_42488624_0": {"length": 10, "quality": 1.0, "section_id": 6881}, "so_42466838_42488624_1": {"length": 19, "quality": 1.0, "section_id": 6881}}}, "42488624": {"Id": "42488624", "PostTypeId": "2", "Body": "<p>The rule in [dcl.spec.auto] is:</p>\n<blockquote>\n<p id=\"so_42466838_42488624_0\">If the type of an entity with an undeduced placeholder type is needed to determine the type of an expression,\n  the program is ill-formed.</p>\n</blockquote>\n<p>This is to just cut short the arbitrary complexity that could be infinite recursive deduction. Fear not though, there are ways around this problem:</p>\n<ol>\n<li><p>Just use <code>T</code> instead of <code>auto</code>:</p>\n<pre><code>template &lt;class T&gt;\nconstexpr T fib_ce(T n) {\n    return (n&gt;1) ? fib_ce(n-1)+fib_ce(n-2) : 1;\n}\n</code></pre></li>\n<li><p>We also have the rule:</p>\n<blockquote>\n<p id=\"so_42466838_42488624_1\">Once a non-discarded return statement has been seen in a function, however, the return type deduced from that statement can be used in the rest of the function, including in other return\n  statements.</p>\n</blockquote>\n<p>So we can use an <code>if</code> statement instead of the conditional operator. We just have to invert the logic so that the <code>return</code> statement with known type goes first:</p>\n<pre><code>template &lt;typename T&gt;\nconstexpr auto fib_ce(T n) {\n   if (n &lt;= 1) {\n       return static_cast&lt;T&gt;(1);       // ok, deduced as T\n   }\n   else {\n       return fib_ce(n-1)+fib_ce(n-2); // we already deduced T, so sticking with it\n   }\n}\n</code></pre></li>\n</ol>\n", "LastActivityDate": "2017-02-27T14:45:54.980", "CommentCount": "0", "CreationDate": "2017-02-27T14:45:54.980", "ParentId": "42466838", "Score": "3", "OwnerUserId": "2069064"}, "42466838": {"ViewCount": "119", "Body": "<p>I am trying to pass a more \"generic\" const input parameter to a constexpr implementation for fibonacci. When I replace the template parameter with an int, things are hunky-dory again.</p>\n<pre><code>#include&lt;iostream&gt;\ntemplate &lt;typename T&gt;\nconstexpr auto fib_ce(T n) {\n   return (n&gt;1) ? fib_ce(n-1)+fib_ce(n-2) : 1;\n}\n\nint main() {\n   std::cout&lt;&lt;fib_ce(4)&lt;&lt;\"\\n\";\n}\n</code></pre>\n<p>This is the error I get:</p>\n<pre><code>g++ -std=c++14 -o constexpr_fib constexpr_fib.cpp \nconstexpr_fib.cpp:4:19: fatal error: recursive template instantiation exceeded maximum depth of 256\n   return (n&gt;1) ? fib_ce(n-1)+fib_ce(n-2) : 1;\n\n              ^\n</code></pre>\n<p>How do I provide a template argument to a constexpr, that can take inputs like long, int, unsigned long, etc etc for this constexpr</p>\n", "AcceptedAnswerId": "42488624", "Title": "Template parameters to constexpr", "CreationDate": "2017-02-26T09:32:01.710", "Id": "42466838", "CommentCount": "2", "LastEditDate": "2017-02-26T09:33:18.740", "PostTypeId": "1", "LastEditorUserId": "5293254", "LastActivityDate": "2017-02-27T14:45:54.980", "Score": "1", "OwnerUserId": "5293254", "Tags": "<c++><c++11><templates><c++14><constexpr>", "AnswerCount": "2"}, "42466871": {"Id": "42466871", "PostTypeId": "2", "Body": "<p>Ok, I think I found the answer, need to refrain from auto and letting the compiler work the return type out here. The following works fine:</p>\n<pre><code>#include&lt;iostream&gt;\ntemplate &lt;typename T&gt;\nconstexpr T fib_ce(T n) {\n   return (n&gt;1) ? fib_ce(n-1)+fib_ce(n-2) : 1;\n}\n\nint main() {\n   std::cout&lt;&lt;fib_ce(4)&lt;&lt;\"\\n\";\n}\n</code></pre>\n", "LastActivityDate": "2017-02-26T09:36:12.297", "CommentCount": "0", "CreationDate": "2017-02-26T09:36:12.297", "ParentId": "42466838", "Score": "3", "OwnerUserId": "5293254"}});