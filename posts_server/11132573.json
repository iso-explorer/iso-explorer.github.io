post_cb({"11133008": {"ParentId": "11132573", "CommentCount": "0", "CreationDate": "2012-06-21T06:54:46.980", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "11133008", "Score": "1", "Body": "<p>Ah, but they are <em>not</em> the same because they do not use the same parameters. Using clang and your original example:</p>\n<pre><code>#include &lt;cstdio&gt;\n\ntemplate &lt;class x1, class x2&gt;\nstruct CoreTemplate { };\n\ntemplate &lt;class x1, class x2&gt;\nstruct CoreTemplate&lt;x1*, x2*&gt; { int spec; CoreTemplate() { spec = 1; } };\n// note: partial specialization matches [with x1 = int, x2 = int]\n\ntemplate &lt;class x1, class x2&gt;\nstruct CoreTemplate&lt;x2*, x1*&gt; { int spec; CoreTemplate() { spec = 2; } };\n// note: partial specialization matches [with x1 = int, x2 = int]\n\nint main()\n{\n    CoreTemplate&lt;int*, int*&gt; qq;\n    // error: ambiguous partial specializations of 'CoreTemplate&lt;int *, int *&gt;'\n    std::printf(\"var=%d.\\r\\n\", qq.spec);\n}\n</code></pre>\n<p>However if we tweak the partial specializations so that they exactly match:</p>\n<pre><code>template &lt;class x1, class x2&gt;\nstruct Core { };\n\ntemplate &lt;class x1&gt;\nstruct Core&lt;x1*, x1*&gt; { int spec; Core() { spec = 1; } };\n// note: previous definition is here\n\ntemplate &lt;class x1&gt;\nstruct Core&lt;x1*, x1*&gt; { int spec; Core() { spec = 2; } };\n// error: redefinition of 'Core&lt;type-parameter-0-0 *, type-parameter-0-0 *&gt;'\n</code></pre>\n<p>Therefore, it just seems to be a quality of implementation issue. A compiler could emit a warning for the first case, but it might be resource consuming in the general case or it may just be that nobody expressed the need so far.</p>\n", "LastActivityDate": "2012-06-21T06:54:46.980"}, "11132910": {"ParentId": "11132573", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2012-06-21T06:47:14.333", "Score": "5", "LastEditorUserId": "179910", "LastEditDate": "2012-06-21T06:52:22.303", "Id": "11132910", "OwnerUserId": "179910", "Body": "<p>The standard is specific in stating that this only happens when you attempt to instantiate the template (\u00a714.5.4.1/1):</p>\n<blockquote>\n<p id=\"so_11132573_11132910_0\"><strong>When a class template is used in a context that requires an instantiation of the class</strong>, it is necessary to determine whether the instantiation is to be generated using the primary template or one of the partial specializations. [emphasis added]</p>\n</blockquote>\n<p>Unfortunately, the rest of your question can't be answered without discussing how to decide which specialization to use during instantiation. Here's the text from the standard (continuing from the excerpt above):</p>\n<blockquote>\n<p id=\"so_11132573_11132910_1\">This is done by matching the template arguments of the class template specialization with the template argument lists of the partial specializations.</p>\n<ul>\n<li>If exactly one matching specialization is found, the instantiation is generated from that specialization.</li>\n<li>If more than one matching specialization is found, the partial order rules (14.5.4.2) are used to determine whether one of the specializations is more specialized than the others. If none of the specializations is more specialized than all of the other matching specializations, then the use of the class template is ambiguous and the program is ill-formed.</li>\n</ul>\n</blockquote>\n<p>So, it never even attempts to compare the templates directly to each other at all. Rather, it attempts to find a specialization that will match the arguments given. If more than one matches, it attempts to pick the most specialized one based on the partial ordering rules. If neither is more specialized than the other, then the instantiation is ambiguous, and compilation fails.</p>\n<p>Now, it's certainly true that neither of these specializations could ever be used, since there would always be ambiguity -- if either matches, the other obviously matches equally well. There's simply no requirement for the compiler to detect or diagnose that though. In this exact case (essentially identical specializations) that would probably be easy, but there are almost certainly other cases where it would be much more difficult, so (apparently) the committee decided the compiler didn't even have to try.</p>\n", "LastActivityDate": "2012-06-21T06:52:22.303"}, "11132573": {"CommentCount": "2", "AcceptedAnswerId": "11132910", "PostTypeId": "1", "LastEditorUserId": "514235", "CreationDate": "2012-06-21T06:19:38.620", "LastActivityDate": "2012-06-27T05:54:40.257", "LastEditDate": "2012-06-27T05:54:40.257", "ViewCount": "284", "FavoriteCount": "1", "Title": "Why compiler doesn't give error while defining similar template specializations?", "Id": "11132573", "Score": "10", "Body": "<p>What is the procedure of comparing the class <code>template</code> specializations? The standard is not detailed on this point (or I am missing the right place).<br>\nMy question has NOTHING TO DO  with deciding what specialization to use during the instantiation. Please, do not comment on that. The question is about comparing the specializations with each other to decide if particular specialization is already defined or not yet.</br></p>\n<p>Consider this sample code:</p>\n<pre><code>template &lt;class x1, class x2&gt;\nstruct CoreTemplate { };\n\ntemplate &lt;class x1, class x2&gt;\nstruct CoreTemplate&lt;x1*, x2*&gt; { int spec; CoreTemplate() { spec = 1; } };\n\ntemplate &lt;class x1, class x2&gt;\nstruct CoreTemplate&lt;x2*, x1*&gt; { int spec; CoreTemplate() { spec = 2; } };\n\nint main(int argc, char* argv[])\n{\n    CoreTemplate&lt;int*, int*&gt; qq;\n    printf(\"var=%d.\\r\\n\", qq.spec);\n}\n</code></pre>\n<p>When I try to compile this code with MSVC, I get an error for the instantiation attempt inside the <code>main</code> function:</p>\n<blockquote>\n<p id=\"so_11132573_11132573_0\">cpptest1.cxx(15) : error C2752: '<code>CoreTemplate&lt;x1,x2&gt;</code>' : more than one partial specialization matches the template argument list</p>\n</blockquote>\n<p>For me it would be more logical to issue an error for an attempt to declare identical template specializations. I do not see any difference between the specializations above.</p>\n<p>So, does anybody know rules of comparing template specializations? Articles, links, books, etc will also help.</p>\n", "Tags": "<c++><templates><compiler-errors><template-specialization>", "OwnerUserId": "1459996", "AnswerCount": "3"}, "11132656": {"ParentId": "11132573", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2012-06-21T06:26:16.793", "Score": "0", "LastEditorUserId": "514235", "LastEditDate": "2012-06-21T06:39:56.943", "Id": "11132656", "OwnerUserId": "514235", "Body": "<blockquote>\n<p id=\"so_11132573_11132656_0\">For me it would be more logical to issue an error for an attempt to\n  declare identical template specializations.</p>\n</blockquote>\n<p><strike>That would not happen, because <code>CoreTemplate&lt;int*, double*&gt;</code> and <code>CoreTemplate&lt;double*, int*&gt;</code> will generate different types.</strike></p>\n<p>Below is my guess:<br>\nCompiler may not do the extra <em>sanity/common-sense</em> checks for <code>template</code> bodies.<br>\nOnce you instantiate a <code>template</code>, at that time compiler looks up for the matching type and picks up the best one. If it doesn't match <strong>only one</strong>, then it gives compiler error either for <em>no-match</em> or <em>multiple-match</em>.</br></br></p>\n<p>For example:</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo ()\n{\n  T::x();\n}\n\nint main ()\n{\n}\n</code></pre>\n<p>Would compile fine, even though we know that in whole C++ program there is not a single function name <code>x()</code>. Compiler will give error only when you try instantiating the <code>foo&lt;T&gt;</code>.</p>\n<p>Also if you twist your example a bit by putting <code>main()</code> between two specializations, it will <a href=\"http://ideone.com/w73PX\" rel=\"nofollow\">compile perfectly fine</a>.</p>\n", "LastActivityDate": "2012-06-21T06:39:56.943"}, "bq_ids": {"n4140": {"so_11132573_11132910_1": {"section_id": 143, "quality": 0.9230769230769231, "length": 12}, "so_11132573_11132910_0": {"section_id": 143, "quality": 0.9, "length": 18}}, "n3337": {"so_11132573_11132910_1": {"section_id": 137, "quality": 0.9230769230769231, "length": 12}, "so_11132573_11132910_0": {"section_id": 137, "quality": 0.9, "length": 18}}, "n4659": {"so_11132573_11132910_0": {"section_id": 147, "quality": 0.9, "length": 18}, "so_11132573_11132910_1": {"section_id": 147, "quality": 0.9230769230769231, "length": 12}}}});