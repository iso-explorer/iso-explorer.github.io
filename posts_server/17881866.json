post_cb({"17881866": {"ViewCount": "196", "Body": "<p>Here's a piece of code I had written to see the behaviour during downcasting.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass base {\npublic :\n    void function()\n    {\n        cout &lt;&lt; \"\\nInside class Base\";\n    }\n};\n\nclass derived : public base {\npublic :\n    void function()\n    {\n        cout &lt;&lt; \"\\nInside class Derived.\";\n    }\n};\n\nint main()\n{\n    base * b1 = new base();\n    base * b2 = new derived();\n    derived * b3 = (derived*)b1 ;\n    b1 -&gt; function();\n    b2 -&gt; function();\n    b3 -&gt; function(); // print statement 3\n    static_cast&lt;derived*&gt;(b2) -&gt; function();\n    static_cast&lt;derived*&gt;(b1) -&gt; function(); // print statement 5\n    return 0;\n}\n</code></pre>\n<p>The output is as follows .</p>\n<pre><code>Inside class Base\nInside class Base\nInside class Derived.\nInside class Derived.\nInside class Derived.\n</code></pre>\n<p>I feel print statement 3 and print statement 5 should have displayed \"Inside  class base\" .</p>\n<p>Can someone please explain what I might be missing here?</p>\n", "Title": "incorrect behaviour while downcasting c++", "CreationDate": "2013-07-26T12:55:13.177", "LastActivityDate": "2013-07-27T10:19:34.483", "CommentCount": "1", "PostTypeId": "1", "Id": "17881866", "Score": "0", "OwnerUserId": "2171119", "Tags": "<c++><inheritance><downcasting>", "AnswerCount": "4"}, "17881940": {"Id": "17881940", "PostTypeId": "2", "Body": "<p>You need to define base method <code>void function()</code> as <code>virtual</code>:</p>\n<pre><code>virtual void function()\n{\n    cout &lt;&lt; \"\\nInside class Base\";\n}\n</code></pre>\n<p>and resulting output is:</p>\n<pre><code>Inside class Base\nInside class Derived.\nInside class Base\nInside class Derived.\nInside class Base\n</code></pre>\n<p>In OP, 5th case may not be an undefined behaviour as stated in the reference<a href=\"https://stackoverflow.com/questions/648647/in-c-where-in-memory-are-class-functions-put\">1</a> and inline member function memory is not stored like data members as stated <a href=\"https://stackoverflow.com/questions/648647/in-c-where-in-memory-are-class-functions-put\">here</a> insuring that after static cast to derived type, derived member function is called:</p>\n<blockquote>\n<p id=\"so_17881866_17881940_0\">The inverse of any standard conversion sequence (Clause 4) not\n  containing an lvalue-to-rvalue (4.1), array-to- pointer (4.2),\n  function-to-pointer (4.3), null pointer (4.10), null member pointer\n  (4.11), or boolean (4.12) conversion, can be performed explicitly\n  using static_cast.</p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/questions/648647/in-c-where-in-memory-are-class-functions-put\">1</a> Working Draft, Standard for Programming Language C++, 5.2.9 Static Cast - 7</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-07-27T10:19:34.483", "Score": "1", "CreationDate": "2013-07-26T12:59:05.867", "ParentId": "17881866", "CommentCount": "2", "OwnerUserId": "2183287", "LastEditDate": "2017-05-23T12:13:00.383"}, "bq_ids": {"n4140": {"so_17881866_17881940_0": {"length": 19, "quality": 0.76, "section_id": 6033}}, "n3337": {"so_17881866_17881940_0": {"length": 19, "quality": 0.76, "section_id": 5801}}, "n4659": {"so_17881866_17881940_0": {"length": 19, "quality": 0.76, "section_id": 7532}}}, "17882016": {"Id": "17882016", "PostTypeId": "2", "Body": "<p>The functions are dispatched at compilation time, based solely on the static type, as they are not virtual.</p>\n<p>Static type of b3 in print statement is Derived *, hence 'Inside class Derived'. Print statement 5 casts Base * to Derived *, hence the same printout.</p>\n<p>Add virtual to function() definition in Base and check again to see what happens.</p>\n", "LastActivityDate": "2013-07-26T13:01:52.597", "CommentCount": "1", "CreationDate": "2013-07-26T13:01:52.597", "ParentId": "17881866", "Score": "0", "OwnerUserId": "25406"}, "17882027": {"Id": "17882027", "PostTypeId": "2", "Body": "<p>Both are cases of undefined behavior.  Casting <code>b1</code> to <code>derived*</code> is not valid. </p>\n<p>However, if you said <code>base* b1 = new derived()</code>, you would have the same behavior. Since neither function is marked <code>virtual</code>, then it only checks objects type at compile time.  </p>\n<p>So the first case would print \"Inside class Base\", even though its actually a derived pointer.</p>\n", "LastEditorUserId": "862231", "LastActivityDate": "2013-07-26T13:12:04.670", "Score": "5", "CreationDate": "2013-07-26T13:02:22.913", "ParentId": "17881866", "CommentCount": "7", "OwnerUserId": "862231", "LastEditDate": "2013-07-26T13:12:04.670"}, "17881947": {"Id": "17881947", "PostTypeId": "2", "Body": "<p>That's the expected behavior.<br>\nNon virtual methods are called by the object's type at <strong>compile time</strong>.<br>\nYou used a static cast, so the compiler treats it as \"Derived\" class.  </br></br></p>\n<p>If you'd declare the method as <code>virtual</code> then it will create a virtual look up table for the function, and call the method according to the actual <strong>run-time</strong> type.</p>\n", "LastActivityDate": "2013-07-26T12:59:19.177", "CommentCount": "3", "CreationDate": "2013-07-26T12:59:19.177", "ParentId": "17881866", "Score": "-1", "OwnerUserId": "536086"}});