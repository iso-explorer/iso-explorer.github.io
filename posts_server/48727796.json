post_cb({"bq_ids": {"n4140": {"so_48727796_48727897_1": {"length": 35, "quality": 1.0, "section_id": 481}}, "n3337": {"so_48727796_48727897_1": {"length": 32, "quality": 0.9142857142857143, "section_id": 472}}, "n4659": {"so_48727796_48727897_0": {"length": 9, "quality": 1.0, "section_id": 504}, "so_48727796_48727897_1": {"length": 35, "quality": 1.0, "section_id": 504}}}, "48727796": {"ViewCount": "303", "Body": "<p>My understanding is that in C++17, the following snippet is intended to Do The Right Thing:</p>\n<pre><code>struct Instrument;  // instrumented (non-trivial) move and copy operations\n\nstruct Base {\n    Instrument i;\n};\n\nstruct Derived : public Base {};\n\nstruct Unrelated {\n    Instrument i;\n    Unrelated(const Derived&amp; d): i(d.i) {}\n    Unrelated(Derived&amp;&amp; d): i(std::move(d.i)) {}\n};\n\nUnrelated test1() {\n    Derived d1;\n    return d1;\n}\n\nBase test2() {\n    Derived d2;\n    return d2;  // yes, this is slicing!\n}\n</code></pre>\n<p>That is, in C++17, the compiler is supposed to treat both <code>d1</code> and <code>d2</code> as rvalues for the purposes of overload resolution in those two return statements. However, in C++14 and earlier, this was not the case; the lvalue-to-rvalue transformation in <code>return</code> operands was supposed to apply only when the operand was <em>exactly</em> the correct return type.</p>\n<p>Furthermore, GCC and Clang both appear to have confusing and possibly buggy behavior in this area. <a href=\"https://wandbox.org/permlink/FzDxshhjl9Hp73F4\" rel=\"nofollow noreferrer\">Trying the above code on Wandbox,</a> I see these outputs:</p>\n<pre><code>GCC 4.9.3 and earlier: copy/copy (regardless of -std=)\nClang 3.8.1 and earlier: copy/copy (regardless of -std=)\nClang 3.9.1 and later: move/copy (regardless of -std=)\nGCC 5.1.0 through 7.1.0: move/copy (regardless of -std=)\nGCC 8.0.1 (HEAD): move/move (regardless of -std=)\n</code></pre>\n<p>So this started out as a tooling question and ended up with a side order of \"what the heck is the <em>correct</em> behavior for a C++ compiler?\"</p>\n<p>My tooling question is: In our codebase, we have several places that say <code>return x;</code> but that accidentally produces a copy instead of a move because our toolchain is GCC 4.9.x and/or Clang. We'd like to detect this situation automatically and insert <code>std::move()</code> as needed. Is there any easy way to detect this issue? Maybe a clang-tidy check or a <code>-Wfoo</code> flag we could enable?</p>\n<p>But of course now I'd also like to know what is the <em>correct</em> behavior of a C++ compiler on this code. Are these outputs indicative of GCC/Clang bugs? Are they being worked on? And is the language version (<code>-std=</code>) supposed to matter? (I'd think that it is supposed to matter, unless the correct behavior has been updated via Defect Reports going all the way back to C++11.)</p>\n<p><a href=\"https://wandbox.org/permlink/Ijlnl9vdFKynWEL6\" rel=\"nofollow noreferrer\">Here is a more complete test</a> inspired by Barry's answer. We test six different cases where lvalue-to-rvalue conversion would be desirable.</p>\n<pre><code>GCC 4.9.3 and earlier:   elided/copy/copy/copy/copy/copy\nClang 3.8.1 and earlier: elided/copy/copy/copy/copy/copy\nClang 3.9.1 and later:   elided/copy/move/copy/copy/copy\nGCC 5.1.0 through 7.1.0: elided/copy/move/move/move/move\nGCC 8.0.1 (HEAD):        elided/move/move/move/move/move\n\nICC 17:                  elided/copy/copy/copy/copy/copy  \nICC 18:                  elided/move/move/move/copy/copy\nMSVC 2017 (wow):         elided/copy/move/copy/copymove/copymove\n</code></pre>\n<p>After Barry's answer, it seems to me that Clang 3.9+ does the technically correct thing in all cases; GCC 8+ does the <em>desirable</em> thing in all cases; and in general I ought to stop teaching that people \"just <code>return x</code> and let the compiler DTRT\" (or at least teach it with a huge flashing caveat) because in practice the compiler will <em>not</em> DTRT unless you are using a bleeding-edge (and technically non-conforming) GCC.</p>\n", "Title": "Automatically detect C++14 \"return should use std::move\" situation", "CreationDate": "2018-02-11T02:47:16.590", "LastActivityDate": "2018-02-20T02:09:07.023", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-02-20T02:09:07.023", "LastEditorUserId": "1424877", "Id": "48727796", "Score": "8", "OwnerUserId": "1424877", "Tags": "<c++><language-lawyer><move-semantics><c++17><compiler-specific>", "AnswerCount": "1"}, "48727897": {"Id": "48727897", "PostTypeId": "2", "Body": "<p>The correct behavior is move/copy. You probably want to just write a clang-tidy check.</p>\n<hr/>\n<p>The wording in C++17 is <a href=\"http://eel.is/c++draft/class.copy.elision#3\" rel=\"nofollow noreferrer\">[class.copy.elision]/3</a> and in C++14 is <a href=\"https://timsong-cpp.github.io/cppwp/n4140/class.copy#32\" rel=\"nofollow noreferrer\">[class.copy]/32</a>. The specific words and formatting is different but the rule is the same. </p>\n<p>In C++11, the rule wording was <a href=\"https://timsong-cpp.github.io/cppwp/n3337/class.copy#32\" rel=\"nofollow noreferrer\">[class.copy]/32</a> and was tied to the copy elision rules, the exception for automatic storage local variables was added in <a href=\"https://wg21.link/CWG1579\" rel=\"nofollow noreferrer\">CWG 1579</a> as a defect report. Compilers predating this defect report would behave as copy/copy. But as the defect report is against C++11, compilers implementing the wording change would implement it across all standard versions. </p>\n<p>Using the C++17 wording:</p>\n<blockquote>\n<p id=\"so_48727796_48727897_0\">In the following copy-initialization contexts, a move operation might be used instead of a copy operation:  </p>\n<ul>\n<li>If the expression in a return statement is a (possibly parenthesized) id-expression that names an object with automatic storage duration declared in the body or parameter-declaration-clause of the innermost enclosing function or lambda-expression, or</li>\n<li>[ ... ]</li>\n</ul>\n<p id=\"so_48727796_48727897_1\">overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue. If the first overload resolution fails or was not performed, <strong>or if the type of the first parameter of the selected constructor is not an rvalue reference to the object's type (possibly cv-qualified)</strong>, overload resolution is performed again, considering the object as an lvalue.</p>\n</blockquote>\n<p>In:</p>\n<pre><code>Unrelated test1() {\n    Derived d1;\n    return d1;\n}\n</code></pre>\n<p>We meet the first bullet, so we try to copy-initialize an <code>Unrelated</code> with an rvalue of type <code>Derived</code>, which gives us <code>Unrelated(Derived&amp;&amp; )</code>. That meets the highlighted criteria so we use it, and the result is a move.</p>\n<p>In:</p>\n<pre><code>Base test2() {\n    Derived d2;\n    return d2;  // yes, this is slicing!\n}\n</code></pre>\n<p>We again meet the first bullet, but overload resolution will find <code>Base(Base&amp;&amp; )</code>. The first parameter of the selected constructor is <strong>not</strong> an rvalue reference to <code>Derived</code> (possibly cv-qualified), so we perform overload resolution again - and end up copying.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2018-02-12T18:19:37.293", "Score": "10", "CreationDate": "2018-02-11T03:07:38.093", "ParentId": "48727796", "CommentCount": "9", "OwnerUserId": "2069064", "LastEditDate": "2018-02-12T18:19:37.293"}});