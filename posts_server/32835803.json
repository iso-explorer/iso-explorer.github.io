post_cb({"32835803": {"CommentCount": "9", "ViewCount": "162", "OwnerDisplayName": "user2953119", "CreationDate": "2015-09-29T04:39:55.420", "LastActivityDate": "2015-09-29T05:34:06.410", "Title": "Understanding object initialization", "PostTypeId": "1", "Id": "32835803", "Score": "6", "Body": "<p>I accidenatlly forget to write braces while initializing array:</p>\n<pre><code>struct A\n{\n    A() { std::cout &lt;&lt; \"A()\" &lt;&lt; std::endl; }\n    A(int a) { std::cout &lt;&lt; \"A(\" &lt;&lt; a &lt;&lt; \")\" &lt;&lt; std::endl; }\n};\n\nint main()\n{\n    A a[3] =  A(2), A(3);\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/a900da63cce76ac1\"><strong>DEMO</strong></a></p>\n<p>Output:</p>\n<pre><code>A(2)\nA(2)\nA(2)\nA(3)\n</code></pre>\n<p>And this's correct, as far as I got. <code>N4257::12.6.1/2</code>:</p>\n<blockquote>\n<p id=\"so_32835803_32835803_0\"><strong><em>Braces can be elided in the initializer-list for any aggregate</em></strong>, even\n  if the aggregate has members of a class type with user-defined type\n  conversions</p>\n</blockquote>\n<p>But braced initiliazation has the different side-effect:</p>\n<pre><code>struct A\n{\n    A() { std::cout &lt;&lt; \"A()\" &lt;&lt; std::endl; }\n    A(int a) { std::cout &lt;&lt; \"A(\" &lt;&lt; a &lt;&lt; \")\" &lt;&lt; std::endl; }\n};\n\nint main()\n{\n    A a[3] = { A(2), A(3) };\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/66a22f2425547d7f\"><strong>DEMO</strong></a></p>\n<p>Output:</p>\n<pre><code>A(2)\nA(3)\nA()\n</code></pre>\n<p>Couldn't you explain that difference?</p>\n", "Tags": "<c++><initialization>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_32835803_32835960_5": {"section_id": 3296, "quality": 0.8333333333333334, "length": 5}, "so_32835803_32835960_0": {"section_id": 3296, "quality": 0.8, "length": 20}, "so_32835803_32835960_3": {"section_id": 3296, "quality": 0.875, "length": 14}, "so_32835803_32835960_2": {"section_id": 3296, "quality": 0.7142857142857143, "length": 5}, "so_32835803_32835803_0": {"section_id": 425, "quality": 1.0, "length": 13}, "so_32835803_32835960_1": {"section_id": 3296, "quality": 0.75, "length": 6}}, "n3337": {"so_32835803_32835960_5": {"section_id": 3166, "quality": 0.8333333333333334, "length": 5}, "so_32835803_32835960_2": {"section_id": 3166, "quality": 0.7142857142857143, "length": 5}, "so_32835803_32835960_3": {"section_id": 3166, "quality": 0.875, "length": 14}, "so_32835803_32835960_0": {"section_id": 3166, "quality": 0.8, "length": 20}, "so_32835803_32835803_0": {"section_id": 417, "quality": 1.0, "length": 13}, "so_32835803_32835960_1": {"section_id": 3166, "quality": 0.75, "length": 6}}, "n4659": {"so_32835803_32835960_5": {"section_id": 4058, "quality": 0.8333333333333334, "length": 5}, "so_32835803_32835960_0": {"section_id": 4058, "quality": 0.8, "length": 20}, "so_32835803_32835960_3": {"section_id": 4058, "quality": 0.875, "length": 14}, "so_32835803_32835960_2": {"section_id": 4058, "quality": 0.7142857142857143, "length": 5}, "so_32835803_32835803_0": {"section_id": 443, "quality": 1.0, "length": 13}, "so_32835803_32835960_1": {"section_id": 4058, "quality": 0.75, "length": 6}}}, "32835960": {"ParentId": "32835803", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>N4527 \u00a7 8.5 [dcl.init]</p>\n<blockquote>\n<p id=\"so_32835803_32835960_0\">17 The semantics of initializers are as follows. The <em>destination type</em> is the type of the object or reference being\n  initialized and the <em>source type</em> is the type of the initializer expression. If the initializer is not a single (possibly\n  parenthesized) expression, the source type is not de\ufb01ned.</p>\n<p id=\"so_32835803_32835960_1\">\u2014 (17.1) If the initializer is a (non-parenthesized) braced-init-list, the object or reference is list-initialized (8.5.4).</p>\n<p id=\"so_32835803_32835960_2\">\u2014 (17.2) If the destination type is a reference type, see 8.5.3.</p>\n<p id=\"so_32835803_32835960_3\">\u2014 (17.3) If the destination type is an array of characters, an array of char16_t, an array of char32_t, or an\n  array of wchar_t, and the initializer is a string literal, see 8.5.2.</p>\n<p id=\"so_32835803_32835960_4\">\u2014 (17.4) If the initializer is (), the object is value-initialized.</p>\n<p id=\"so_32835803_32835960_5\">\u2014 (17.5) Otherwise, if the destination type is an array, the program is ill-formed.</p>\n<p id=\"so_32835803_32835960_6\">[Other irrelevant bullets omitted]</p>\n</blockquote>\n<p><code>A a[3] =  A(2)</code> falls into (17.5), so your program is ill-formed. Apparently <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60009\">g++ has a bug in this case</a>. <a href=\"http://coliru.stacked-crooked.com/a/59e12517b015cb8b\">clang correctly rejects your code</a>.</p>\n", "OwnerUserId": "4672588", "LastEditorUserId": "4672588", "LastEditDate": "2015-09-29T05:34:06.410", "Id": "32835960", "Score": "4", "CreationDate": "2015-09-29T04:57:52.377", "LastActivityDate": "2015-09-29T05:34:06.410"}});