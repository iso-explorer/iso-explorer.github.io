post_cb({"bq_ids": {"n4140": {"so_32809304_32809350_1": {"length": 10, "quality": 0.5882352941176471, "section_id": 6049}}, "n3337": {"so_32809304_32809350_1": {"length": 10, "quality": 0.5882352941176471, "section_id": 5817}}, "n4659": {"so_32809304_32809350_1": {"length": 10, "quality": 0.5882352941176471, "section_id": 7548}}}, "32810796": {"Id": "32810796", "PostTypeId": "2", "Body": "<p>I suspect what you are trying to do is a more complex version of something like this:</p>\n<pre><code>typedef MainLoop *MainLoop(); // not legal\n\nextern MainLoop* main_loop_1();\nextern MainLoop* main_loop_2();\n\nMainLoop* main_loop_1()\n{\n    // do some work here\n    return main_loop_2;\n}\n\nMainLoop* main_loop_2()\n{\n    // do some work here\n    return main_loop_1;\n}\n\nint main()\n{\n    MainLoop f = main_loop_1;\n\n    for (;;) {\n      f = f();\n    }\n}\n</code></pre>\n<p>A workaround is to wrap the function pointer in a struct:</p>\n<pre><code>struct MainLoop {\n    MainLoop (*function_ptr)(); // legal\n};\n\nextern MainLoop main_loop_1();\nextern MainLoop main_loop_2();\n\nMainLoop main_loop_1()\n{\n    // do some work here\n    return {main_loop_2};\n}\n\nMainLoop main_loop_2()\n{\n    // do some work here\n    return {main_loop_1};\n}  \n\nint main()\n{\n    MainLoop f{main_loop_1};\n\n    for (;;) {\n       f = f.function_ptr();\n    }\n}\n</code></pre>\n", "LastEditorUserId": "951890", "LastActivityDate": "2015-09-27T17:56:54.120", "Score": "1", "CreationDate": "2015-09-27T17:34:04.783", "ParentId": "32809304", "CommentCount": "1", "OwnerUserId": "951890", "LastEditDate": "2015-09-27T17:56:54.120"}, "32809350": {"Id": "32809350", "PostTypeId": "2", "Body": "<p>Don't use <code>void*</code>, because no guarantee that a <code>void *</code> can hold a function pointer. You can use <code>void(*)()</code> as a workaround:</p>\n<pre><code>typedef void(*void_func)();\ntypedef void_func (*func_type) (int);\nvoid_func arbitraryFunction(int a) {\n    // could be this function, or another with the same signature, \n    cout &lt;&lt; \"arbitraryFunction\\n\";\n    return nullptr;  \n}\nvoid_func function(int a) {\n    // could be this function, or another with the same signature, \n    return (void_func) arbitraryFunction;  \n}\nint main() {\n    // your code goes here\n    func_type f = (func_type) function(0);\n    f(0);\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/hEmPyq\" rel=\"nofollow\">LIVE</a></p>\n<p>C99 [6.2.5/27]:</p>\n<blockquote>\n<p id=\"so_32809304_32809350_0\">A pointer to void shall have the same representation and alignment requirements as a pointer to a character type. Similarly, pointers to\n  quali\ufb01ed or unquali\ufb01ed versions of compatible types shall have the\n  same representation and alignment requirements. All pointers to\n  structure types shall have the same representation and alignment\n  requirements as each other. All pointers to union types shall have the\n  same representation and alignment requirements as each other. Pointers\n  to other types need not have the same representation or alignment\n  requirements.</p>\n</blockquote>\n<p>C99 [6.3.2.3/8]:</p>\n<blockquote>\n<p id=\"so_32809304_32809350_1\">A pointer to a function of one type may be converted to a pointer to a function of another type and back again; the result shall compare\n  equal to the original pointer.</p>\n</blockquote>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2015-09-28T02:16:36.153", "Score": "6", "CreationDate": "2015-09-27T15:09:37.827", "ParentId": "32809304", "CommentCount": "6", "OwnerUserId": "3309790", "LastEditDate": "2015-09-28T02:16:36.153"}, "32810028": {"Id": "32810028", "PostTypeId": "2", "Body": "<p>The trick in C is to take advantage of the fact that any kind of function pointer can be cast to any other kind of function pointer:</p>\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\ntypedef void(*emptyfunc)(void);\ntypedef emptyfunc (*funcptr2)(int);\n\nfuncptr2 strategy(int m)\n{\n  printf(\"Strategy %d.\\n\", m);\n  return (funcptr2)&amp;strategy;\n}\n\nint main (void)\n{\n  const funcptr2 strategy2 = (funcptr2)strategy(1);\n  const funcptr2 strategy3 = (funcptr2)strategy2(2);\n  strategy3(3);\n\n  return EXIT_SUCCESS;\n}\n</code></pre>\n<p>Each pointer to a strategy is always in a type that can be called once, and the return value is put back into a form that can be called once again.</p>\n<p>In C++, you would declare a function object:</p>\n<pre><code>class strategy {\n  public:\n  virtual const strategy&amp; operator()(int) const = 0;\n}\n</code></pre>\n<p>An instance of this class can be called like a function.</p>\n", "LastEditorUserId": "4474419", "LastActivityDate": "2015-09-27T20:58:27.687", "Score": "5", "CreationDate": "2015-09-27T16:14:13.830", "ParentId": "32809304", "CommentCount": "4", "OwnerUserId": "4474419", "LastEditDate": "2015-09-27T20:58:27.687"}, "32809304": {"ViewCount": "533", "Body": "<p>I want to assign a function's address to a function pointer, but the function to be addressed returns a function pointer with the same signature as itself, causing it to recurse in a way that I can't write the return type at all, for the function pointer or even the function declaration itself...</p>\n<p>I guess a way of simplifying the problem so it's not confusing:</p>\n<p>How could I write a function declaration such, that it can return a pointer to itself (or any other function with the same signature)?</p>\n<pre><code>????? function(int a){\n    // could be this function, or another with the same signature, \n    return arbitraryFunction;  \n}\n\n?????(*func)(int) = function;  // same problem as above\n</code></pre>\n<p><strong>edit:</strong></p>\n<p>For now I have a solution, though I won't post it as an answer because it's aggressively ugly.  It gets rid of the recursion by simply returning a raw <code>void*</code> pointer as the return type, and ends up taking the following form:</p>\n<pre><code>void* function(int parameter){\n    return arbitraryFunction; // of the same signature\n}\n\nvoid*(*func)(int) = function; \nfunc = reinterpret_cast&lt;void*(*)(int)&gt;(func(42));  // sin\n</code></pre>\n<p><strong>edit2:</strong></p>\n<p>It seems casting between function pointers and regular pointers is UB, so I can't use <code>void*</code> in this case...</p>\n<p>To answer one of the comments, this is for passing control between multiple \"main\" loops in my program, with each loop getting it's own function.  There's a lot of ways to do this, but returning function pointers (or NULL to terminate the program) mid-loop <em>seemed</em> like the simplest method, but I didn't anticipate that pointers to data and pointers to function addresses would be incompatable with each other.  I think returning polymorphic function objects will end up being the more sane option in this case.</p>\n", "Title": "How to write a function pointer to a function returning a function pointer to a function?", "CreationDate": "2015-09-27T15:04:48.497", "LastActivityDate": "2015-09-28T02:16:36.153", "CommentCount": "12", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-09-27T16:35:44.663", "LastEditorUserId": "620863", "Id": "32809304", "Score": "10", "OwnerUserId": "620863", "Tags": "<c++><function><pointers>", "AnswerCount": "3"}});