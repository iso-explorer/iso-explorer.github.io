post_cb({"bq_ids": {"n4140": {"so_16922023_16922023_1": {"length": 12, "quality": 0.8, "section_id": 105}, "so_16922023_16922023_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 114}}, "n3337": {"so_16922023_16922023_1": {"length": 12, "quality": 0.8, "section_id": 100}, "so_16922023_16922023_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 109}}, "n4659": {"so_16922023_16922023_1": {"length": 12, "quality": 0.8, "section_id": 109}, "so_16922023_16922023_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 118}}}, "36920964": {"Id": "36920964", "PostTypeId": "2", "Body": "<p>You can use intermediary template class to make explicit parameter to ctor - and it will deduce your desired type </p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;typename T&gt; struct tag { using type = T;};\n\nclass My {\npublic:\n    template &lt;typename T&gt; My(tag&lt;T&gt;) {\n        cout &lt;&lt; \"ctor of \" &lt;&lt; typeid(T).name();\n    }\n};\n\nint main(int argc, const char * argv[]) {\n\n    auto a = My(tag&lt;int&gt;());\n}\n</code></pre>\n", "LastActivityDate": "2016-04-28T16:55:37.313", "CommentCount": "0", "CreationDate": "2016-04-28T16:55:37.313", "ParentId": "16922023", "Score": "0", "OwnerUserId": "5302690"}, "16922369": {"Id": "16922369", "PostTypeId": "2", "Body": "<p>You can never provide an explicit template argument list to constructor templates. Constructor templates must always have their arguments deduced:</p>\n<pre><code>struct A {\n    template&lt;typename U&gt; A() {}\n};\ntemplate &lt;typename T&gt;\nstruct B {\n    B() {}\n};\nstruct C {\n    template&lt;typename U&gt; C(U t) {}\n};\ntemplate &lt;typename T&gt;\nstruct D {\n    template&lt;typename U&gt; D(U t) {}\n};\n\nint main()\n{\n    //auto a1 = A&lt;int&gt;{}; //illegal -- A is not a template\n    //A can never be instantiated...\n\n    auto b = B&lt;int&gt;{}; //default-constructs a B&lt;int&gt;\n\n    //auto c = C&lt;double&gt;{1.}; //illegal - C not a template\n\n    //Constructs a C, deduces `U = double` constructor:\n    auto c = C{1.};\n    //Constructs a D&lt;int&gt;, deduces `U = double` constructor:\n    auto d = D&lt;int&gt;{1.};\n}\n</code></pre>\n", "LastActivityDate": "2013-06-04T15:57:55.840", "CommentCount": "3", "CreationDate": "2013-06-04T15:57:55.840", "ParentId": "16922023", "Score": "3", "OwnerUserId": "485561"}, "16922023": {"ViewCount": "1010", "Body": "<p>I'm confused about the sentence below,I understand the example they used for conversion member function but not understand the constructor member function templates occasions<a href=\"https://stackoverflow.com/questions/16922023/is-there-any-way-to-provide-an-explicit-template-argument-list-for-constructor-f/16922369?noredirect=1#16922369\">,helpful example given by Mankarse</a>.</p>\n<blockquote>\n<p id=\"so_16922023_16922023_0\">Because the explicit template argument list follows the function template name,\n  and because conversion member function templates and constructor member function templates are called\n  without using a function name, <strong>there is no way to provide an explicit template argument list for these\n  function templates.</strong>  --14.5.2.5 N3242</p>\n</blockquote>\n<pre><code>struct A {\n    template &lt;class T&gt; operator T*();\n};\ntemplate &lt;class T&gt; A::operator T*(){ return 0; }\ntemplate &lt;&gt; A::operator char*(){ return 0; } // specialization\ntemplate A::operator void*(); // explicit instantiation\n\nint main() \n{\n   A a;\n   int *ip;\n   ip = a.operator int*(); // explicit call to template operator\n   // A::operator int*()\n}\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_16922023_16922023_1\">The template-arguments for a member function of a class template are determined by the template-arguments\n  of the type of the object for which the member function is called.  --14.5.1.1.2 N3242</p>\n</blockquote>\n<p><strong>So I need to deduct the template-argument by myself or use a wrapper.</strong><br>\nexample given by libstdc++ when reading standard library:</br></p>\n<pre><code>template&lt;typename _Container&gt;\nclass back_insert_iterator\n: public iterator&lt;output_iterator_tag, void, void, void, void&gt;\n{\n   protected:\n      _Container* container;\n   public:\n       explicit\n       back_insert_iterator(_Container&amp; __x) : container(&amp;__x) { }\n}\n/*\n *it use a wrapper :\n */\ntemplate&lt;typename _Container&gt;\ninline back_insert_iterator&lt;_Container&gt;\nback_inserter(_Container&amp; __x)\n{ return back_insert_iterator&lt;_Container&gt;(__x); }\n</code></pre>\n</hr>", "AcceptedAnswerId": "16922369", "Title": "how and when to use constructor function templates?", "CreationDate": "2013-06-04T15:41:34.740", "Id": "16922023", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:22:30.657", "LastEditorUserId": "-1", "LastActivityDate": "2016-04-28T16:55:37.313", "Score": "0", "OwnerUserId": "1501948", "Tags": "<c++>", "AnswerCount": "2"}});