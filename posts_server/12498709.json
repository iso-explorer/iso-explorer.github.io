post_cb({"12499353": {"ParentId": "12498709", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, and this could be useful in some cases.</p>\n<p>Suppose you have a program that wishes to access more storage than will fit in virtual memory.  By creating an allocator that references memory mapped storage and mapping it as required when indirecting <code>pointer</code> objects, you can access arbitrarily large amounts of memory.</p>\n<p>This remains conformant to 18.2:6 because <code>size_t</code> is defined as large enough to contain the size of any object, but 17.6.3.5:2 table 28 defines <code>size_type</code> as containing the size of <em>the largest object in the allocation model</em>, which need not be an actual object in the C++ memory model.</p>\n<p>Note that the requirements in 17.6.3.5:2 table 28 do not constitute a requirement that the allocation of multiple objects should result in an array; for <code>allocate(n)</code> the requirement is:</p>\n<blockquote>\n<p id=\"so_12498709_12499353_0\">Memory is allocated for <code>n</code> objects of type <code>T</code></p>\n</blockquote>\n<p>and for <code>deallocate</code> the assertion is:</p>\n<blockquote>\n<p id=\"so_12498709_12499353_1\">All <code>n</code> <code>T</code> objects in the area\n  pointed to by <code>p</code> shall be\n  destroyed prior to this call.</p>\n</blockquote>\n<p>Note <em>area</em>, not <em>array</em>.  Another point is 17.6.3.5:4:</p>\n<blockquote>\n<p id=\"so_12498709_12499353_2\">The <code>X::pointer</code>, <code>X::const_pointer</code>, <code>X::void_pointer</code>, and <code>X::const_void_pointer</code> types shall satisfy\n  the requirements of NullablePointer (17.6.3.3). No constructor, comparison operator, copy operation,\n  move operation, or swap operation on these types shall exit via an exception. <code>X::pointer</code> and <code>X::const_pointer</code> shall also satisfy the requirements for a random access iterator (24.2).</p>\n</blockquote>\n<p>There is no requirement here that <code>(&amp;*p) + n</code> should be the same as <code>p + n</code>.</p>\n<p>It's perfectly legitimate for a model expressible within another model to contain objects not representable in the outer model; for example, non-standard models in mathematical logic.</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2012-09-19T17:27:25.683", "Id": "12499353", "Score": "25", "CreationDate": "2012-09-19T16:54:06.703", "LastActivityDate": "2012-09-19T17:27:25.683"}, "bq_ids": {"n4140": {"so_12498709_12499353_2": {"section_id": 6292, "quality": 0.90625, "length": 29}, "so_12498709_12499353_0": {"section_id": 6290, "quality": 1.0, "length": 4}, "so_12498709_12499353_1": {"section_id": 6290, "quality": 1.0, "length": 7}, "so_12498709_12499124_0": {"section_id": 25, "quality": 0.6, "length": 6}, "so_12498709_12499245_0": {"section_id": 6708, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_12498709_12499353_2": {"section_id": 6052, "quality": 0.90625, "length": 29}, "so_12498709_12499353_0": {"section_id": 6050, "quality": 1.0, "length": 4}, "so_12498709_12499353_1": {"section_id": 6050, "quality": 1.0, "length": 7}, "so_12498709_12499124_0": {"section_id": 22, "quality": 0.6, "length": 6}, "so_12498709_12499245_0": {"section_id": 6463, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_12498709_12499353_2": {"section_id": 7800, "quality": 0.875, "length": 28}, "so_12498709_12499353_0": {"section_id": 7797, "quality": 1.0, "length": 4}, "so_12498709_12499124_0": {"section_id": 25, "quality": 0.6, "length": 6}, "so_12498709_12499245_0": {"section_id": 8183, "quality": 0.8461538461538461, "length": 11}}}, "12499154": {"ParentId": "12498709", "PostTypeId": "2", "CommentCount": "7", "Body": "<p><code>size_t</code> is the type of the unsigned integer you get by applying <code>sizeof</code>.</p>\n<p><code>sizeof</code> should return the size of the type (or of the type of the expression) that is his argument. In case of arrays it should return the size of the whole array.</p>\n<p>This implies that:</p>\n<ul>\n<li><p>there cannot be ANY structure or union that is larger than what <code>size_t</code> can represent.</p></li>\n<li><p>there cannot be any array that is larger than what <code>size_t</code> can represent.</p></li>\n</ul>\n<p>In other words, if something fits in the largest block of consecutive memory that you can access, then its size must fit in size_t (in non-portable, but easy to grasp intuitively terms this means that on most systems <code>size_t</code> is as large as <code>void*</code> and can 'measure' the whole of your virtual address space).</p>\n<p>Edit: this next sentence is probably wrong. See below</p>\n<p>Therefore the answer to <em>is it possible to have an allocator that allocates objects whose size cannot be represented by a <code>size_t</code>?</em> is no. </p>\n<p>Edit (addendum):</p>\n<p>I've been thinking about it and the above my be in fact wrong. I've checked the standard and it seems to be possible to design a completely custom allocator with completely custom pointer types, including using different types for pointer, const pointer, void pointer and const void pointer. Therefore an allocator can in fact have a size_type that is larger than size_t.</p>\n<p>But to do so you need to actually define completely custom pointer types and the corresponding allocator and allocator traits instances.</p>\n<p>The reason I say <strong>may</strong> is that I'm still a bit unclear if the <code>size_type</code> needs to span the size of the single object or also the size of multiple objects (that is an array) in the allocator model. I will need to investigate this detail (but not now, it's dinner time here :) )</p>\n<p>Edit2 (new addendum):</p>\n<p>@larsmans I think you may want to decide what to accept anyway. The problem seems to be a little more complicated than one may intuitively realize. I'm editing the answer again as my thoughts are definitively more than a comment (both in content and in size).</p>\n<p>ReEdit (as pointed out in the comments the next two paragraphs are not correct):</p>\n<p>First of all <code>size_type</code> is just a name. You can of course define a container and add a <code>size_type</code> to it with whatever meaning you wish. Your <code>size_type</code> could be a float, a string whatever.</p>\n<p>That said in standard library containers <code>size_type</code> is defined in the container only to make it easy to access. It's in fact supposed to be identical to the <code>size_type</code> of the allocator for that container (and the <code>size_type</code> of the allocator should be the <code>size_type</code> of the allotator_traits of that allocator).</p>\n<p>Therefore we shall henceforth assume that the <code>size_type</code> of the container, even one you define, follows the same logic 'by convention'. @BenVoight begins his answer with \"As @AnalogFile explains, no allocated memory can be larger than size_t. So a container which inherits its size_type from an allocator cannot have size_type larger than size_t.\". In fact we are now stipulating that if a container has a <code>size_type</code> then that comes from the allocator (he says inherit, but that of course is not in the common sense of class inheritance).</p>\n<p>However he may or may not be 100% right that a <code>size_type</code> (even if it comes from an allocator) is necessarily constrained to <code>size_t</code>. The question really is: can an allocator (and the corresponding traits) define a <code>size_type</code> that is larger than <code>size_t</code>? </p>\n<p>Both @BenVoight and @ecatmur suggest a usecase where the backing store is a file. However if the backing store is a file only for the content and you have something in memory that refers to that content (let's call that an 'handle'), then you are in fact doing a container that contains handles. A handle will be an instance of some class that stores the actual data on a file and only keeps in memory whatever it needs to retrieve that data, but this is irrelevant to the container: the container will store the handles and those are in memory and we still are in the 'normal' address space, so my initial response is still valid.</p>\n<p>There is another case, however. You are not allocating handles, you are actually storing stuff in the file (or database) and your allocator (and relative traits) define pointer, const pointer, void pointer, const void pointer etc. types that directly manage that backing store. In this case, of course, they also need to define the <code>size_type</code> (replacing <code>size_t</code>) and <code>difference_type</code> (replacing ptrdiff_t) to match.</p>\n<p>The direct difficulties in defining <code>size_type</code> (and <code>difference_type</code>) as larger than <code>size_t</code> when <code>size_t</code> is already as large as the largest implementation provided primitive integral type (if not, then there are no difficulties) are related to the fact that they need to be <code>integer types</code>. </p>\n<p>Depending on how you interpret the standard this may be impossible (because according to the standard <code>integer types</code> are the types defined in the standard plus the <code>extended integer types</code> provided by the implementation) or possible (if you interpret it such that you can provide an <code>extended integer type</code> yourself) as long as you can write a class that behaves <strong>exactly</strong> like an primitive type. This was impossible in the old times (overloading rules did make primitive types always distinguishable from user defined types), but I'm not 100% up-to-date with C++11 and this may (or may not be changed).</p>\n<p>However there are also indirect difficulties. You not only need to provide a suitable integer type for <code>size_type</code>. You also need to provide the rest of the allocator interface.</p>\n<p>I've been thinking about it a little and one problem I see is in implementing <code>*p</code> according to 17.6.3.5. In that <code>*p</code> syntax <code>p</code> is a <code>pointer</code> as typed by the allocator traits. Of course we can write a class and define an <code>operator*</code> (the nullary method version, doing pointer dereferece). And one may think that this can be easily done by 'paging in' the relative part of the file (as @ecatmur suggests). However there's a problem: <code>*p</code> must be a <code>T&amp;</code> for that object. Therefore the object itself must fit in memory and, more importantly, since you may do <code>T &amp;ref = *p</code> and hold that reference indefinitely, once you have paged in the data you will never be allowed to page it out any more. This means that effectively there may be no way to properly implement such an allocator unless the whole backing store can also be loaded into memory.</p>\n<p>Those are my early observations and seem to actually confirm my first impression that the <strong>real</strong> answer is no: there is no practical way to do it.</p>\n<p>However, as you see, things are much more complicated than mere intuition seems to suggest. It may take quite a time to find a definitive answer (and I may or may not go ahead and research the topic further).</p>\n<p>For the moment I'll just say: <strong>it seems not to be possible</strong>. Statements to the contrary shall only be acceptable if they are not based solely on intuition: post code and let people debate if your code fully conforms to 17.6.3.5 and if your <code>size_type</code> (which shall be larger than <code>size_t</code> even if <code>size_t</code> is as large as the largest primitive integer type) can be considered an integer type.</p>\n", "OwnerUserId": "574590", "LastEditorUserId": "574590", "LastEditDate": "2012-09-20T22:06:10.260", "Id": "12499154", "Score": "19", "CreationDate": "2012-09-19T16:41:51.927", "LastActivityDate": "2012-09-20T22:06:10.260"}, "12499245": {"ParentId": "12498709", "CommentCount": "3", "Body": "<p>From \u00a718.2/6</p>\n<blockquote>\n<p id=\"so_12498709_12499245_0\">The type <code>size_t</code> is an implementation-defined unsigned integer type that is large enough to contain the size in bytes of any object.</p>\n</blockquote>\n<p>So, if it were possible for you to allocate an object whose size cannot be represented by a <code>size_t</code> it would make the implementation non-conforming.</p>\n", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "12499245", "Score": "3", "CreationDate": "2012-09-19T16:48:07.533", "LastActivityDate": "2012-09-19T16:48:07.533"}, "12499305": {"ParentId": "12498709", "CommentCount": "2", "Body": "<p>To add to the \"standard\" answers, also note the <a href=\"http://stxxl.sourceforge.net/\" rel=\"nofollow\">stxxl</a> project which is supposed to be able to handle terabytes of data using disk storage (perhaps by extension, network storage). See the <a href=\"http://algo2.iti.kit.edu/stxxl/tags/1.3.1/vector_8h_source.html\" rel=\"nofollow\">header of vector</a> for example, for the definition of <code>size_type</code> (<a href=\"http://algo2.iti.kit.edu/stxxl/tags/1.3.1/vector_8h_source.html#l00731\" rel=\"nofollow\">line 731</a>, and <a href=\"http://algo2.iti.kit.edu/stxxl/trunk/vector_8h_source.html#l00742\" rel=\"nofollow\">line 742</a>) as uint64.</p>\n<p>This is a concrete example of using containers with larger sizes than memory can afford, or that even the system's integer can handle.</p>\n", "OwnerUserId": "586784", "PostTypeId": "2", "Id": "12499305", "Score": "1", "CreationDate": "2012-09-19T16:50:37.920", "LastActivityDate": "2012-09-19T16:50:37.920"}, "12499242": {"ParentId": "12498709", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Yes and no.</p>\n<p>As @AnalogFile explains, no allocated memory can be larger than <code>size_t</code>.  So a container which inherits its <code>size_type</code> from an allocator cannot have <code>size_type</code> larger than <code>size_t</code>.</p>\n<p>However, you can design a container type which represents a collection not entirely stored in addressable memory.  For example, the members could be on disk or in a database.  They could even be computed dynamically, e.g. a Fibonacci sequence, and never stored anywhere at all.  In such cases, <code>size_type</code> could easily be larger than <code>size_t</code>.</p>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2012-09-19T18:28:53.393", "Id": "12499242", "Score": "15", "CreationDate": "2012-09-19T16:48:03.667", "LastActivityDate": "2012-09-19T18:28:53.393"}, "12498709": {"CommentCount": "0", "AcceptedAnswerId": "12499353", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-09-19T16:11:59.563", "LastActivityDate": "2012-09-20T22:06:10.260", "LastEditDate": "2017-05-23T12:16:36.210", "ViewCount": "1996", "FavoriteCount": "8", "Title": "Can a size_type ever be larger than std::size_t?", "Id": "12498709", "Score": "35", "Body": "<p>Standard containers with an <code>std::allocator</code> have their <a href=\"https://stackoverflow.com/q/918567/166749\"><code>size_type</code> defined as <code>std::size_t</code></a>. However, is it possible to have an allocator that allocates objects whose size cannot be represented by a <code>size_t</code>? In other words, can a <code>size_type</code> ever be larger than <code>size_t</code>?</p>\n", "Tags": "<c++><stl><allocator><size-t>", "OwnerUserId": "166749", "AnswerCount": "7"}, "12507954": {"ParentId": "12498709", "CommentCount": "0", "Body": "<p>Not necessarily.</p>\n<p>I assume by size_type you mean the typedef inside most STL containers?</p>\n<p>If so, then just because size_type was added to all the containers instead\nof just using size_t means that the STL is reserving the right to make\nsize_type any type they like. (By default, in all implementations I'm aware\nof size_type is a typedef of size_t).</p>\n", "OwnerUserId": "1653769", "PostTypeId": "2", "Id": "12507954", "Score": "0", "CreationDate": "2012-09-20T07:34:13.070", "LastActivityDate": "2012-09-20T07:34:13.070"}, "12499124": {"ParentId": "12498709", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I'm sure its buried in the standard somewhere, but the best description i've seen for <a href=\"http://www.sgi.com/tech/stl/Container.html\" rel=\"nofollow\">size_type</a> is from the SGI-STL documentation. As I said, i'm sure it is in the standard, and if someone can point it out, by all means do.</p>\n<p>According to SGI, a container's size_type is:</p>\n<blockquote>\n<p id=\"so_12498709_12499124_0\">An unsigned integral type that can represent any nonnegative value of\n  the container's distance type</p>\n</blockquote>\n<p>It makes no claims that is must be anything besides that. In theory you could define a container that uses uint64_t, unsigned char, and anything else in between. That it is referencing the container's distance_type is the part I find interesting, since...</p>\n<blockquote>\n<p id=\"so_12498709_12499124_1\">distance_type: A signed integral type used to represent the distance\n  between two of the container's iterators. This type must be the same\n  as the iterator's distance type.</p>\n</blockquote>\n<p>This doesn't really answer the question, though, but it is interesting to see how size_type and size_t differ (or can). Regarding your question, see (and up vote) @AnalogFile s answer, as I believe it to be correct.</p>\n", "OwnerUserId": "1322972", "LastEditorUserId": "1322972", "LastEditDate": "2012-09-19T17:09:18.330", "Id": "12499124", "Score": "5", "CreationDate": "2012-09-19T16:39:26.007", "LastActivityDate": "2012-09-19T17:09:18.330"}});