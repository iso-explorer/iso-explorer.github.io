post_cb({"bq_ids": {"n4140": {"so_47691216_47705939_1": {"length": 10, "quality": 1.0, "section_id": 6173}}, "n3337": {"so_47691216_47705939_1": {"length": 10, "quality": 1.0, "section_id": 5934}}, "n4659": {"so_47691216_47705939_1": {"length": 10, "quality": 1.0, "section_id": 7675}}}, "47705939": {"Id": "47705939", "PostTypeId": "2", "Body": "<p>The code is well-defined in all versions of C and C++. You are seeing a bug in MSVC.</p>\n<p>The definition of the <code>+=</code> operator is that <code>x += y</code> means <code>x = x + y</code>, except that <code>x</code> is only evaluated once.  (Note that \"evaluate\" is different to \"lvalue conversion\").</p>\n<p>So we are looking at <code>i = i + a[i]++</code>. </p>\n<p>Informally: the new value to store in <code>i</code> cannot be computed until both operands of <code>+</code> have been evaluated, and had lvalue conversion performed. Because we need the result of that lvalue conversion in order to know the value to store.  </p>\n<p>The term \"evaluate\" for an lvalue means to determine the memory location which the lvalue refers to. Evaluating <code>a[i]++</code> when <code>i</code> is <code>0</code> beforehand means to determine that we are referring to <code>a[0]</code>. Then lvalue conversion retrieves the stored value of <code>a[0]</code>, and the unsequenced side-effect is that the stored value of <code>a[0]</code> will be updated sooner or later. </p>\n<p>Writing to <code>a[0]</code> has nothing to do with <code>i</code>, so there is no reason to believe there might be undefined behaviour.</p>\n<hr>\n<p>More formally: prior to 2011, the C and C++ standards used a somewhat confusing sentence that expressed the logic in my \"Informally:\" paragraph. If the expression reads and writes <code>i</code> then it is well-defined only if the reads of <code>i</code> are all necessary to determine the new value to store in <code>i</code>, because that will guarantee that the reads have all happened before it is possible to store the new value.</p>\n<p>In C11 and C++11 the language changed but not the implication. C11 6.5.16/3 (Assignment operators) says:</p>\n<blockquote>\n<p id=\"so_47691216_47705939_0\">The side effect of updating the stored value of the left operand is\n  sequenced after the value computations of the left and right operands.</p>\n</blockquote>\n<p>which leaves no doubt that the write to <code>i</code> is sequenced after all reads of <code>i</code> on the right-hand side.</p>\n<p>C++11 has similar language:</p>\n<blockquote>\n<p id=\"so_47691216_47705939_1\">In all cases, the assignment is sequenced after the value computation of the right and left operands,</p>\n</blockquote>\n</hr>", "LastActivityDate": "2017-12-08T00:22:13.890", "Score": "4", "CreationDate": "2017-12-08T00:22:13.890", "ParentId": "47691216", "CommentCount": "0", "OwnerUserId": "1505939"}, "47691216": {"ViewCount": "153", "Body": "<p><strong>Problem</strong></p>\n<ul>\n<li><p>This example is a minimal reproduction of this issue encountered a code golf attempt. I am not advocating anyone use this style.</p></li>\n<li><p>I am aware I may have hit undefined behaviour, my question is: why specifically, and does this go for C as well as C++?</p></li>\n</ul>\n<p>I have this file:</p>\n<pre><code>#include &lt;stdio.h&gt;\nint main() {\n    int a[]={1, 0}, i=0;\n    i += a[i]++;\n    printf(\"i=%d a=[%d, %d]\\n\", i, a[0], a[1]);\n    return 0;\n}\n</code></pre>\n<p>With GCC on Ubuntu on WSL I get the expected <code>i=1 a=[2, 0]</code> but with Visual C++ it is <code>i=1 a=[1, 1]</code></p>\n<p>The problem is fixed if I do this:</p>\n<pre><code>delta = a[i]++;\ni += delta;\n</code></pre>\n<p>Whilst order of evaluation of assignment is unspecified, I am surprised that it appears that <code>a[i]</code> is evaluated again for the increment, <em>after</em> the assignment of <code>i</code>. The disassembly below seems to confirm this.</p>\n<p>Do either the C or C++ standards allow this?</p>\n<hr>\n<p><strong>Background</strong></p>\n<p>Build command line and output on Windows:</p>\n<pre><code>&gt;cl test.c\nMicrosoft (R) C/C++ Optimizing Compiler Version 19.12.25830.2 for x64\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\ntest.c\nMicrosoft (R) Incremental Linker Version 14.12.25830.2\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\n/out:test.exe\ntest.obj\n</code></pre>\n<p>Dissasembly of the statement (built with <code>/Zi</code>):</p>\n<pre><code>     4:     i += a[i]++;\n00007FF6CBBA626C  movsxd      rax,dword ptr [i]  \n00007FF6CBBA6271  mov         eax,dword ptr a[rax*4]  \n00007FF6CBBA6275  mov         ecx,dword ptr [i]  \n00007FF6CBBA6279  add         ecx,eax  \n00007FF6CBBA627B  mov         eax,ecx  \n00007FF6CBBA627D  mov         dword ptr [i],eax  \n00007FF6CBBA6281  movsxd      rax,dword ptr [i]  \n00007FF6CBBA6286  mov         eax,dword ptr a[rax*4]  \n00007FF6CBBA628A  inc         eax  \n00007FF6CBBA628C  movsxd      rcx,dword ptr [i]  \n00007FF6CBBA6291  mov         dword ptr a[rcx*4],eax  \n</code></pre>\n</hr>", "AcceptedAnswerId": "47705939", "Title": "Why does i += a[i]++ assign i before incrementing a[i] with Visual C++?", "CreationDate": "2017-12-07T09:01:50.357", "LastActivityDate": "2017-12-08T17:11:07.460", "CommentCount": "38", "LastEditDate": "2017-12-08T17:11:07.460", "PostTypeId": "1", "LastEditorUserId": "59527", "Id": "47691216", "Score": "1", "OwnerUserId": "59527", "Tags": "<c++><c><visual-c++>", "AnswerCount": "1"}});