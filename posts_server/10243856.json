post_cb({"10243856": {"CommentCount": "5", "ViewCount": "938", "PostTypeId": "1", "LastEditorUserId": "875044", "CreationDate": "2012-04-20T09:49:01.787", "LastActivityDate": "2012-04-20T13:15:50.487", "Title": "gcc 4.7 STL library deficit on pair implementation?", "AcceptedAnswerId": "10244048", "LastEditDate": "2012-04-20T09:56:07.420", "Id": "10243856", "Score": "1", "Body": "<p>The following code compiles on gcc 4.6 but not 4.7.  Is it 4.7's problem or 4.6's problem?  Compiled with -std=gnu++0x.</p>\n<pre><code>#include &lt;utility&gt;\n\nusing namespace std;\n\nstruct Z {\n};\n\nstruct X {\n    operator Z*() const { return nullptr; }\n};\n\nstruct Y {\n    Y(Z*) {}\n};\n\nint main() {\n    pair&lt;int, Y&gt; p(make_pair(0, X()));\n}\n</code></pre>\n<p>Error messages:</p>\n<pre><code>[hidden]$ g++-mp-4.6 -std=gnu++0x e.cpp \n[hidden]$ g++-mp-4.7 -std=gnu++0x e.cpp \ne.cpp: In function 'int main()':\ne.cpp:17:37: error: no matching function for call to 'std::pair&lt;int, Y&gt;::pair(std::pair&lt;int, X&gt;)'\ne.cpp:17:37: note: candidates are:\nIn file included from /opt/local/include/gcc47/c++/utility:72:0,\n                 from e.cpp:1:\n/opt/local/include/gcc47/c++/bits/stl_pair.h:204:9: note: template&lt;class ... _Args1, long unsigned int ..._Indexes1, class ... _Args2, long unsigned int ..._Indexes2&gt; std::pair::pair(std::tuple&lt;_Args1 ...&gt;&amp;, std::tuple&lt;_Args2 ...&gt;&amp;, std::_Index_tuple&lt;_Indexes1 ...&gt;, std::_Index_tuple&lt;_Indexes2 ...&gt;)\n/opt/local/include/gcc47/c++/bits/stl_pair.h:204:9: note:   template argument deduction/substitution failed:\ne.cpp:17:37: note:   'std::pair&lt;int, X&gt;' is not derived from 'std::tuple&lt;_Args1 ...&gt;'\nIn file included from /opt/local/include/gcc47/c++/utility:72:0,\n                 from e.cpp:1:\n/opt/local/include/gcc47/c++/bits/stl_pair.h:153:9: note: template&lt;class ... _Args1, class ... _Args2&gt; std::pair::pair(std::piecewise_construct_t, std::tuple&lt;_Args1 ...&gt;, std::tuple&lt;_Args2 ...&gt;)\n/opt/local/include/gcc47/c++/bits/stl_pair.h:153:9: note:   template argument deduction/substitution failed:\ne.cpp:17:37: note:   cannot convert 'std::make_pair(_T1&amp;&amp;, _T2&amp;&amp;) [with _T1 = int; _T2 = X; typename std::__decay_and_strip&lt;_T2&gt;::__type = X; typename std::__decay_and_strip&lt;_T1&gt;::__type = int]((* &amp; X()))' (type 'std::pair&lt;int, X&gt;') to type 'std::piecewise_construct_t'\nIn file included from /opt/local/include/gcc47/c++/utility:72:0,\n                 from e.cpp:1:\n/opt/local/include/gcc47/c++/bits/stl_pair.h:148:12: note: template&lt;class _U1, class _U2, class&gt; constexpr std::pair::pair(std::pair&lt;_U1, _U2&gt;&amp;&amp;)\n/opt/local/include/gcc47/c++/bits/stl_pair.h:148:12: note:   template argument deduction/substitution failed:\n/opt/local/include/gcc47/c++/bits/stl_pair.h:145:38: error: no type named 'type' in 'struct std::enable_if&lt;false, void&gt;'\n/opt/local/include/gcc47/c++/bits/stl_pair.h:142:12: note: template&lt;class _U1, class _U2, class&gt; constexpr std::pair::pair(_U1&amp;&amp;, _U2&amp;&amp;)\n/opt/local/include/gcc47/c++/bits/stl_pair.h:142:12: note:   template argument deduction/substitution failed:\ne.cpp:17:37: note:   candidate expects 2 arguments, 1 provided\nIn file included from /opt/local/include/gcc47/c++/utility:72:0,\n                 from e.cpp:1:\n/opt/local/include/gcc47/c++/bits/stl_pair.h:136:12: note: template&lt;class _U2, class&gt; constexpr std::pair::pair(const _T1&amp;, _U2&amp;&amp;)\n/opt/local/include/gcc47/c++/bits/stl_pair.h:136:12: note:   template argument deduction/substitution failed:\ne.cpp:17:37: note:   cannot convert 'std::make_pair(_T1&amp;&amp;, _T2&amp;&amp;) [with _T1 = int; _T2 = X; typename std::__decay_and_strip&lt;_T2&gt;::__type = X; typename std::__decay_and_strip&lt;_T1&gt;::__type = int]((* &amp; X()))' (type 'std::pair&lt;int, X&gt;') to type 'const int&amp;'\nIn file included from /opt/local/include/gcc47/c++/utility:72:0,\n                 from e.cpp:1:\n/opt/local/include/gcc47/c++/bits/stl_pair.h:131:12: note: template&lt;class _U1, class&gt; constexpr std::pair::pair(_U1&amp;&amp;, const _T2&amp;)\n/opt/local/include/gcc47/c++/bits/stl_pair.h:131:12: note:   template argument deduction/substitution failed:\ne.cpp:17:37: note:   candidate expects 2 arguments, 1 provided\nIn file included from /opt/local/include/gcc47/c++/utility:72:0,\n                 from e.cpp:1:\n/opt/local/include/gcc47/c++/bits/stl_pair.h:122:7: note: std::pair&lt;_T1, _T2&gt;::pair(std::pair&lt;_T1, _T2&gt;&amp;&amp;) [with _T1 = int; _T2 = Y; std::pair&lt;_T1, _T2&gt; = std::pair&lt;int, Y&gt;]\n/opt/local/include/gcc47/c++/bits/stl_pair.h:122:7: note:   no known conversion for argument 1 from 'std::pair&lt;int, X&gt;' to 'std::pair&lt;int, Y&gt;&amp;&amp;'\n/opt/local/include/gcc47/c++/bits/stl_pair.h:119:17: note: constexpr std::pair&lt;_T1, _T2&gt;::pair(const std::pair&lt;_T1, _T2&gt;&amp;) [with _T1 = int; _T2 = Y; std::pair&lt;_T1, _T2&gt; = std::pair&lt;int, Y&gt;]\n/opt/local/include/gcc47/c++/bits/stl_pair.h:119:17: note:   no known conversion for argument 1 from 'std::pair&lt;int, X&gt;' to 'const std::pair&lt;int, Y&gt;&amp;'\n/opt/local/include/gcc47/c++/bits/stl_pair.h:116:12: note: template&lt;class _U1, class _U2, class&gt; constexpr std::pair::pair(const std::pair&lt;_U1, _U2&gt;&amp;)\n/opt/local/include/gcc47/c++/bits/stl_pair.h:116:12: note:   template argument deduction/substitution failed:\n/opt/local/include/gcc47/c++/bits/stl_pair.h:113:38: error: no type named 'type' in 'struct std::enable_if&lt;false, void&gt;'\n/opt/local/include/gcc47/c++/bits/stl_pair.h:104:26: note: constexpr std::pair&lt;_T1, _T2&gt;::pair(const _T1&amp;, const _T2&amp;) [with _T1 = int; _T2 = Y]\n/opt/local/include/gcc47/c++/bits/stl_pair.h:104:26: note:   candidate expects 2 arguments, 1 provided\n/opt/local/include/gcc47/c++/bits/stl_pair.h:100:26: note: constexpr std::pair&lt;_T1, _T2&gt;::pair() [with _T1 = int; _T2 = Y]\n/opt/local/include/gcc47/c++/bits/stl_pair.h:100:26: note:   candidate expects 0 arguments, 1 provided\n</code></pre>\n", "Tags": "<c++><gcc><g++>", "OwnerUserId": "875044", "AnswerCount": "1"}, "10244048": {"ParentId": "10243856", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>That shouldn't compile.</p>\n<p>The initialisation of <code>p.second</code> requires an implicit conversion from <code>X</code> to <code>Y</code>. An implicit conversion can only involve at most one user-defined conversion The required conversion would require two; <code>X</code> to <code>Z*</code> via the conversion operator, and <code>Z*</code> to <code>Y</code> via the conversion constructor.</p>\n<p>Initialisation of pair elements from another pair is only allowed via implicit conversions. C++11 says:</p>\n<blockquote>\n<p id=\"so_10243856_10244048_0\">20.3.2/12 This constructor shall not participate in overload resolution unless <code>const U&amp;</code> is implicitly convertible to <code>first_type</code> and <code>const V&amp;</code> is <strong>implicitly convertible</strong> to <code>second_type</code>.</p>\n</blockquote>\n<p>and C++98 said:</p>\n<blockquote>\n<p id=\"so_10243856_10244048_1\">20.2.2/4 Initializes members from the corresponding members of the argument, <strong>performing implicit conversions</strong> as needed.</p>\n</blockquote>\n<p>Presumably, the older version had a bug which allowed this conversion to be considered, and that bug has been fixed in the more recent version.</p>\n", "OwnerUserId": "204847", "LastEditorUserId": "365496", "LastEditDate": "2012-04-20T13:15:50.487", "Id": "10244048", "Score": "5", "CreationDate": "2012-04-20T10:00:24.213", "LastActivityDate": "2012-04-20T13:15:50.487"}, "bq_ids": {"n4140": {"so_10243856_10244048_0": {"section_id": 3967, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_10243856_10244048_0": {"section_id": 3824, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_10243856_10244048_0": {"section_id": 5572, "quality": 0.5714285714285714, "length": 8}}}});