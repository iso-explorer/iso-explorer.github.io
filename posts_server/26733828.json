post_cb({"26741609": {"ParentId": "26733828", "PostTypeId": "2", "CommentCount": "0", "Body": "<pre><code>B* b = (B*)((A*)new C()); // this is done manually, i believe it is safe\n</code></pre>\n<p>This is <strong>not</strong> safe.<br>\nCasts of the form <code>(T)</code> <em>expr</em> are, roughly speaking, converted into either <code>static_cast</code> or <code>reinterpret_cast</code>. [expr.cast]/4:</br></p>\n<blockquote>\n<p id=\"so_26733828_26741609_0\">The conversions performed by</p>\n<ul>\n<li>a <code>const_cast</code> (5.2.11),</li>\n<li>a <code>static_cast</code> (5.2.9),</li>\n<li>a <code>static_cast</code> followed by a <code>const_cast</code>,</li>\n<li>a <code>reinterpret_cast</code> (5.2.10), or</li>\n<li>a <code>reinterpret_cast</code> followed by a <code>const_cast</code>,</li>\n</ul>\n<p id=\"so_26733828_26741609_1\">can be performed using the cast notation of explicit type conversion.\n  <strong>The same semantic restrictions and behaviors apply</strong> [\u2026]<br> If a\n  conversion can be interpreted in more than one of the ways listed\n  above, the interpretation that appears first in the list is used, even\n  if a cast resulting from that interpretation is ill-formed.</br></p>\n</blockquote>\n<p>You can ignore <code>const_cast</code> here as no qualification conversions are done in your code.\n<code>static_cast</code> suffices in both casts, the first one, <code>(A*)</code>, and the second one, <code>(B*)</code>.\nThe first one is just fine. Upcasting is never an issue.<br>\nThe second one induces undefined behavior. [expr.static.cast]/11:</br></p>\n<blockquote>\n<p id=\"so_26733828_26741609_2\">A prvalue of type \u201cpointer to <em>cv1</em> <code>B</code>,\u201d where <code>B</code> is a class type,\n  can be converted to a prvalue of type \u201cpointer to <em>cv2</em> <code>D</code>\u201d, where\n  <code>D</code> is a class derived (Clause 10) from <code>B</code>, if a valid standard\n  conversion from \u201cpointer to <code>D</code>\u201d to \u201cpointer to <code>B</code>\u201d exists (4.10),\n  <em>cv2</em> is the same cv-qualification as, or greater cv-qualification than, <em>cv1</em>, and <code>B</code> is neither a virtual base class of <code>D</code> nor a base\n  class of a virtual base class of <code>D</code>. [\u2026] <strong>If the prvalue of type\n  \u201cpointer to cv1 B\u201d points to a <code>B</code> that is actually a subobject of an\n  object of type <code>D</code>, the resulting pointer points to the enclosing\n  object of type <code>D</code>. Otherwise, the result of the cast is undefined.</strong></p>\n</blockquote>\n<p>Note also that just because the <code>static_cast</code> triggers UB that doesn't mean it isn't selected (and replaced by <code>reinterpret_cast</code>).</p>\n<p>The second and third casts base on the first one (which causes undefined behavior), thus talking about their validity is pointless.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2016-07-25T12:32:41.590", "Id": "26741609", "Score": "2", "CreationDate": "2014-11-04T17:45:23.820", "LastActivityDate": "2016-07-25T12:32:41.590"}, "26739968": {"ParentId": "26733828", "CommentCount": "0", "Body": "<p>Your casts are both legal and correct but very dangerous. You should use reinterpret_cast&lt;&gt; to tag them in your code.\nYou can always cast any address of any type <code>A</code> to any other address of any type <code>B</code> and get your first address back. This is essentially what you've done:</p>\n<pre><code>A *pa = &amp;some_a;\nB *pb = reinterpret_cast&lt;B *&gt;(pa);\npa = reinterpret_cast&lt;A *&gt;(pb);\n</code></pre>\n<p>and then dereference <code>pa</code>. This example works but it is so easy to make a mistake...</p>\n", "OwnerUserId": "719263", "PostTypeId": "2", "Id": "26739968", "Score": "0", "CreationDate": "2014-11-04T16:19:23.383", "LastActivityDate": "2014-11-04T16:19:23.383"}, "26734053": {"ParentId": "26733828", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Unless you really really know what your doing, don't do that.</p>\n<p>The casts are legal, but using them on anything but the correct class results in undefined behaviour, any use of <code>b</code> without further casts results in UB, which might work, do nothing or start WWIII.</p>\n<p>The casts simply tells the compiler that is should consider the variable to be of another type (unless it is multiple inheritance), but as soon as the cast variable is used it must actual be legal to use it in the way the code does, using B's function table is no good if the object is a C or vice versa. As this is undefined behaviour the compiler might emit whatever code it feels is right.</p>\n<p>Example</p>\n<pre><code>class AA { };\nclass BB { };\nclass CC : public AA, public BB { };\nint main () {\n    CC cc; // address is 0x22aa6f\n    BB* bb = &amp;cc; // bb now is 0x22aa6f\n    cout &lt;&lt; &amp;cc &lt;&lt; \",\" &lt;&lt; bb &lt;&lt; \"\\n\";\n\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>Gives </p>\n<blockquote>\n<p id=\"so_26733828_26734053_0\">0x22aa6f,0x22aa6f</p>\n</blockquote>\n<p>Example with multiple inheritance</p>\n<pre><code>class AX{ int a = 1; };\nclass BX{ int b = 2; };\nclass CX:AX,BX {\npublic:\n int c = 3;\n int SomeFunc(){cout &lt;&lt; \"SomeFunc \" &lt;&lt; c &lt;&lt; \" \"; return c;}\n};\n\nint cast() {\n  CX* c;\n  BX* b = (BX*)((AX*)(c = new CX())); // this is done manually, i believe it is safe\n  cout &lt;&lt; \"c=\" &lt;&lt; c &lt;&lt; \", b=\" &lt;&lt; b &lt;&lt; \", cx=\" &lt;&lt; ((CX*)b) &lt;&lt; \", ca=\" &lt;&lt; ((CX*)((AX*)b)) &lt;&lt; endl;\n  ((CX*)b)-&gt;SomeFunc(); // is this safe? this is the cast in question\n\n  return ((CX*)((AX*)b))-&gt;SomeFunc(); // this is done manually, i believe it is safe\n}\n\nint main () {\n    return cast();\n}\n</code></pre>\n<p>output</p>\n<blockquote>\n<p id=\"so_26733828_26734053_1\">c=0x60003ac70, b=0x60003ac70, cx=0x60003ac6c, ca=0x60003ac70<br>\n  SomeFunc 2 SomeFunc 3</br></p>\n</blockquote>\n<ul>\n<li>c is the real address of the <code>new</code></li>\n<li>b is the cast to AX first which is c then to BX (which doesn't make any sense for AX) but b is just set to the same address as c</li>\n<li>cx is b reinterpreted as CX, multi-inheritance kicks in and really change the address as if b was the 2nd class in the inheritance.</li>\n<li>ca is the correct reinterpretation of b through AX and then CX.</li>\n</ul>\n<p>The 2 calls to SomeFunc works despite the wrong address</p>\n<ul>\n<li>the function call is found through the current type which is CX due to the last cast.</li>\n<li>the wrong addresses are passed as <code>this</code> pointer</li>\n<li>because <code>this</code> is not used it works, so I had to add some use.</li>\n<li>now we have entered undefined behaviour due to the cast (BX*)((AX*)c which makes the cast (CX*)b do the wrong thing.</li>\n</ul>\n<p>To check if it is safe you need to use dynamic_cast.</p>\n<pre><code>int main() {\n  A* AP = new C();\n  C* CP = dynamic_cast&lt;C*&gt;(A);\n  if (CP != nullptr)\n    CP-&gt;SomeFunc();\n\n  return EXIT_SUCCESS;   \n}\n</code></pre>\n", "OwnerUserId": "4013258", "LastEditorUserId": "4013258", "LastEditDate": "2014-11-04T14:35:44.677", "Id": "26734053", "Score": "2", "CreationDate": "2014-11-04T11:30:53.697", "LastActivityDate": "2014-11-04T14:35:44.677"}, "26733828": {"CommentCount": "14", "AcceptedAnswerId": "26741609", "PostTypeId": "1", "LastEditorUserId": "1316208", "CreationDate": "2014-11-04T11:18:39.150", "LastActivityDate": "2016-07-25T12:32:41.590", "LastEditDate": "2014-11-04T11:54:47.780", "ViewCount": "860", "FavoriteCount": "1", "Title": "casting between two derived classes", "Id": "26733828", "Score": "3", "Body": "<p>is it legal to cast between pointers on classes that have common ancestor? Does the compiler notice such hierarchy and makes sure its safe (call 1) ? \nOr does the user have to go through the hierarchy manually for it to be always safe (call 2) ?</p>\n<p>say we have</p>\n<pre><code>class A{};\nclass B:A{};\nclass C:A\n{ \npublic:\n int SomeFunc(){return 3;}\n};\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    B* b = (B*)((A*)new C()); // this is done manually, i believe it is safe\n\n  ((C*)b)-&gt;SomeFunc(); // is this safe? this is the cast in question\n\n  return ((C*)((A*)b))-&gt;SomeFunc(); // this is done manually, i believe it is safe\n}\n</code></pre>\n<p>edit: Made this code compilable and runnable</p>\n<p>edit2: Added more comments</p>\n", "Tags": "<c++><class><casting>", "OwnerUserId": "1316208", "AnswerCount": "4"}, "26734024": {"ParentId": "26733828", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>To check whether a cast is meaningful or not just use dynamic_cast. dynamic_cast will cast properly if cast is safe OR returns NULL (in case of pointers, for references it throws bad_cast exception ) if its not able to cast to target type.</p>\n<p>For your question just think about whether this cast is meaningful. You are casting B class to C where these classes have no knowledge of each other. <strong>So, surely this cast would fail.</strong></p>\n<p>You are doing:-</p>\n<pre><code>B* b = (B*)(new C());\n</code></pre>\n<p>This would fail(means won't even compile ) if given to dynamic_cast since classes involved are not polymorphic. Even if you make class B polymorphic cast would fail. Leave further casting.</p>\n<p>One more thing you can cross cast using dynamic_cast safely assuming classes are polymorphic and cast is safe. For e.g:-</p>\n<pre><code>class A;\nClass B;\nClass C : public A, public B\n\nA *a = new C;\n</code></pre>\n<p>You can cast this to sibling:-</p>\n<pre><code>B *b = dynamic_cast&lt;B*&gt; (a);\n</code></pre>\n", "OwnerUserId": "4047092", "LastEditorUserId": "4047092", "LastEditDate": "2014-11-04T11:44:14.653", "Id": "26734024", "Score": "1", "CreationDate": "2014-11-04T11:29:09.520", "LastActivityDate": "2014-11-04T11:44:14.653"}, "bq_ids": {"n4140": {"so_26733828_26741609_2": {"section_id": 6037, "quality": 0.864406779661017, "length": 51}, "so_26733828_26741609_1": {"section_id": 6126, "quality": 0.96875, "length": 31}}, "n3337": {"so_26733828_26741609_2": {"section_id": 5805, "quality": 0.8983050847457628, "length": 53}, "so_26733828_26741609_1": {"section_id": 5890, "quality": 0.96875, "length": 31}}, "n4659": {"so_26733828_26741609_2": {"section_id": 7536, "quality": 0.7457627118644068, "length": 44}, "so_26733828_26741609_1": {"section_id": 7623, "quality": 0.96875, "length": 31}}}});