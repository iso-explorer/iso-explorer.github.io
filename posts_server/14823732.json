post_cb({"14830871": {"ParentId": "14823732", "CommentCount": "1", "Body": "<p>In the discussion of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475\" rel=\"noreferrer\">LWG475</a>, <code>std::for_each</code> is compared with <code>std::transform</code>. It's noted that \"<code>transform</code> does not guarantee the order in which its function object is called\". So, yes, the committee is aware of the lack of sequential guarantees in the standard. </p>\n<p>There is no opposite requirement for non-sequential behavior either, so Microsoft and Apache are free to use sequential evaluation.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "14830871", "Score": "7", "CreationDate": "2013-02-12T10:55:19.847", "LastActivityDate": "2013-02-12T10:55:19.847"}, "14823732": {"CommentCount": "10", "AcceptedAnswerId": "14830871", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-02-12T00:51:40.200", "LastActivityDate": "2013-02-14T00:58:41.153", "LastEditDate": "2017-05-23T12:14:27.393", "ViewCount": "437", "FavoriteCount": "3", "Title": "C++ standard wording: Does \"through all iterators in the range\" imply sequentiality?", "Id": "14823732", "Score": "26", "Body": "<p><a href=\"https://stackoverflow.com/questions/14823291\">This SO question</a> sparked a discussion about <code>std::generate</code> and the guarantees made by the standard. In particular, can you use function objects with internal state and rely on <code>generate(it1, it2, gen)</code> to call <code>gen()</code>, store the result in <code>*it</code>, call <code>gen()</code> again, store in <code>*(it + 1)</code> etc., or can it start at the back, for example?</p>\n<p>The standard (n3337, \u00a725.3.7/1) says this:</p>\n<blockquote>\n<p id=\"so_14823732_14823732_0\">Effects: The first algorithm invokes the function object <code>gen</code> and assigns the return value of gen through all the iterators in the range <code>[first,last)</code>. The second algorithm invokes the function object gen and assigns the return value of gen through all the iterators in the range <code>[first,first + n)</code> if <code>n</code> is positive, otherwise it does nothing.</p>\n</blockquote>\n<p>It seems like no ordering is guaranteed, especially since other paragraphs have stronger wording, for example <code>std::for_each</code> (<em>Effects: Applies <code>f</code> to the result of dereferencing every iterator in the range <code>[first,last)</code>, starting from first and proceeding to <code>last - 1</code>.</em> If we're taking this literally, it only guarantees to start at <code>first</code> and end at <code>last</code> though - no guarantees on the ordering in between). </p>\n<p><strong>But:</strong> Both <a href=\"http://msdn.microsoft.com/en-us/library/k0ctd768%28v=vs.110%29.aspx\" rel=\"nofollow noreferrer\">Microsoft's</a> and <a href=\"http://stdcxx.apache.org/doc/stdlibref/generate.html\" rel=\"nofollow noreferrer\">Apache's C++ standard library</a> both give examples on their documentation pages that require the evaluation to be sequential. And both libc++ (in <code>algorithm</code>) and libstdc++ (in <code>bits/stl_algo.h</code>) implement it that way. Moreover, you lose a lot of potential applications for <code>generate</code> without this guarantee.</p>\n<p>Does the current wording imply sequentiality? If not, was this an oversight by the members of the committee or intentional?</p>\n<p>(I am well aware that there aren't many people who can provide insightful answers to this question without merely speculating or discussing, but in my humble opinion, this does not make this question 'not constructive' as per SO guidelines.)</p>\n<hr>\n<p>Thanks to @juanchopanza for pointing out this issue and referring me to the paragraph about <code>for_each</code>.</p>\n</hr>", "Tags": "<c++><c++11><standards><std>", "OwnerUserId": "1865077", "AnswerCount": "2"}, "14831584": {"ParentId": "14823732", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Anywhere the standard doesn't specify an ordering on an algorithm, you should assume that an implementation can exploit that for parallelism.  The paper <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3408.pdf\" rel=\"nofollow\">n3408</a> discusses options for parallelisation, and points to the <a href=\"http://thrust.github.com/\" rel=\"nofollow\">Thrust</a> library, which is both a usable parallel-enabled reimplementation of the standard algorithms and a proof-of-concept for future standardisation of parallelism in the algorithms.</p>\n<p>Looking at Thrust's implementation of <code>generate</code>, it calls <code>gen</code> in a parallel loop whenever the iterator category is random access.  As you've observed, this is consistent with the standard, so you should not assume that <code>generate</code> will always be sequential.  (For example, a thread-safe <code>std::rand</code> can be efficiently used with <code>generate</code> and does not require sequential invocation.)</p>\n<p>The only algorithms that guarantee sequential invocation are those in <code>numeric</code>; if your code depends on sequential invocation, you should use <code>iota</code> in place of <code>generate</code>.  Adapting an existing generator:</p>\n<pre><code>template&lt;typename F&gt; struct iota_adapter {\n   F f;\n   operator typename std::result_of&lt;F()&gt;::type() { return f(); }\n   void operator++() {}\n};\ntemplate&lt;typename F&gt; iota_adapter&lt;F&gt; iota_adapt(F &amp;&amp;f) { return {f}; }\n</code></pre>\n<p>Use as:</p>\n<pre><code>#include &lt;numeric&gt;\n#include &lt;iostream&gt;\n\nint main() {\n   int v[5], i = 0;\n   std::iota(std::begin(v), std::end(v), iota_adapt([&amp;i]() { return ++i; }));\n   for (auto i: v) std::cout &lt;&lt; i &lt;&lt; '\\n';\n}\n</code></pre>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2013-02-12T14:55:43.670", "Id": "14831584", "Score": "5", "CreationDate": "2013-02-12T11:34:31.083", "LastActivityDate": "2013-02-12T14:55:43.670"}, "bq_ids": {"n4140": {"so_14823732_14823732_0": {"section_id": 1332, "quality": 0.8648648648648649, "length": 32}}, "n3337": {"so_14823732_14823732_0": {"section_id": 1326, "quality": 0.8648648648648649, "length": 32}}, "n4659": {"so_14823732_14823732_0": {"section_id": 1463, "quality": 0.6216216216216216, "length": 23}}}});