post_cb({"4757871": {"CommentCount": "1", "ViewCount": "7420", "PostTypeId": "1", "LastEditorUserId": "581051", "CreationDate": "2011-01-21T10:47:01.077", "LastActivityDate": "2017-01-05T20:17:37.300", "Title": "gcc failes to compile operator definition with prefixed namespace", "AcceptedAnswerId": "4757918", "LastEditDate": "2011-01-21T13:13:59.390", "Id": "4757871", "Score": "7", "Body": "<p>I have operators declared for class <code>my_type</code> in namespace <code>my_namespace</code>.</p>\n<pre><code>namespace my_namespace {\n class my_type\n {\n  friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; out, my_type t);\n }\n}\n</code></pre>\n<p>I'm trying to define these operators in implementation file, but when I write something like that</p>\n<pre><code>std::ostream&amp; my_namespace::operator &lt;&lt; (std::ostream&amp; out, my_type t)\n{\n out &lt;&lt; t;\n return out;\n}\n</code></pre>\n<p>I get error message</p>\n<p><code>error: ... operator should have been declared inside 'my_namespace'</code></p>\n<p>When I change it to</p>\n<pre><code>namespace my_namespace {\n    std::ostream&amp; operator &lt;&lt; (std::ostream&amp; out, my_type t)\n    {\n     out &lt;&lt; t;\n     return out;\n    }\n}\n</code></pre>\n<p>then it's compiles, but I don't understand the problem. Why does this failed to compile? Is there everything right with that?\nI would appreciate link to standard as I really don't know what to search.</p>\n<p><strong>added</strong></p>\n<p><code>file.h</code></p>\n<pre><code>#ifndef A_H\n#define A_H\n\n#include &lt;iosfwd&gt;\n\nnamespace N\n{\n class A\n {\n  friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; out, A&amp; obj);\n };\n}\n\n#endif\n</code></pre>\n<p><code>file.cpp</code></p>\n<pre><code>#include \"file.h\"\n#include &lt;iostream&gt;\n\nstd::ostream&amp; N::operator &lt;&lt; (std::ostream&amp; out, N::A&amp; obj)\n{\n return out;\n}\n\nint main() {}\n</code></pre>\n<p>here is complete example. This works fine on VS2010, but gives above mentioned error on gcc 4.4.5.</p>\n<p><strong>added</strong></p>\n<p>hmm...yes, this one works</p>\n<pre><code>namespace N\n{\n    class A\n    {\n        friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; out, A&amp; obj);\n    };\n    std::ostream&amp; operator &lt;&lt; (std::ostream&amp; out, A&amp; obj);\n}\n</code></pre>\n<p>I was always thinking that in terms of visibility declaring friend operator in class is same thing as declaring outside of the class..looks like it's not. Thanks.</p>\n<p>Thanks much in advance.</p>\n", "Tags": "<c++><gcc><namespaces><operator-overloading>", "OwnerUserId": "581051", "AnswerCount": "2"}, "4757918": {"ParentId": "4757871", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2011-01-21T10:52:00.417", "Score": "9", "LastEditorUserId": "954", "LastEditDate": "2017-01-05T20:17:37.300", "Id": "4757918", "OwnerUserId": "454406", "Body": "<blockquote>\n<p id=\"so_4757871_4757918_0\">The error message says it all, actually. You can keep your function definition in the implementation file, but you need to declare it in the namespace first:</p>\n</blockquote>\n<pre><code>namespace my_namespace {\n    std::ostream&amp; operator &lt;&lt; (std::ostream&amp; out, my_type t);\n}\n</code></pre>\n<p>The C++ standard is quite clear about this: </p>\n<blockquote>\n<p id=\"so_4757871_4757918_1\">7.3.1.2/3:</p>\n<p id=\"so_4757871_4757918_2\">Every name first declared in a namespace is a member of that   namespace. If a friend declaration in a non-local class first   declares a class or function the friend class or function is a   member of the innermost enclosing namespace. The name of the friend   is not found by simple name lookup until a matching declaration is provided in that namespace scope (either before or after the   class declaration granting friendship). If a friend function is   called, its name may be found by the name lookup that considers   functions from namespaces and classes associated with the types of   the function arguments (3.4.2). When looking for a prior declaration   of a class or a function declared as a friend, and when the name of   the friend class or function is neither a qualified name nor a   template-id, scopes outside the innermost enclosing namespace   scope are not considered. .</p>\n</blockquote>\n<p>The following link puts it more simply, and adds a few examples: <a href=\"http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=/com.ibm.xlcpp8a.doc/language/ref/cplr043.htm\" rel=\"nofollow noreferrer\">http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=/com.ibm.xlcpp8a.doc/language/ref/cplr043.htm</a></p>\n<p><strike>So I'd say that gcc is wrong here.</strike>. The relevant sentence seems to be \"<strong>The name of the friend is not found by simple name lookup until a matching declaration is provided in that namespace scope (either before or after the class declaration granting friendship)</strong>.</p>\n", "LastActivityDate": "2017-01-05T20:17:37.300"}, "4758831": {"ParentId": "4757871", "CommentCount": "0", "CreationDate": "2011-01-21T12:33:36.337", "OwnerUserId": "613064", "PostTypeId": "2", "Id": "4758831", "Score": "1", "Body": "<p>Declarations refer to a set of other names, and introduce a single new name; this new name must not be qualified with a namespace identifier, but rather the declaration needs to be inside the namespace block in which the new name should be declared.</p>\n<p>The same rules apply to definitions, as they imply a declaration. The friend declaration is special, because it lives inside another definition and doesn't really declare anything.</p>\n", "LastActivityDate": "2011-01-21T12:33:36.337"}, "bq_ids": {"n4140": {"so_4757871_4757918_2": {"section_id": 5485, "quality": 0.75, "length": 63}}, "n3337": {"so_4757871_4757918_2": {"section_id": 5271, "quality": 0.7857142857142857, "length": 66}}, "n4659": {"so_4757871_4757918_2": {"section_id": 6920, "quality": 0.6666666666666666, "length": 56}}}});