post_cb({"39739781": {"ParentId": "39737956", "CommentCount": "0", "Body": "<p>If you insist on using a macro: Skip the anotherParentFunction() function and use the macro directly instead. When called with constant strings, i.e. </p>\n<pre><code>FUNCTION_RECOGNIZER( \"1a\");\n</code></pre>\n<p>it should work.</p>\n<p>A more C++ like solution would be to e.g use an enum, then implement anotherParentFunction() with the enum as parameter and a switch that calls the corresponding function. Of course you need to change the enum and the switch statement then every time you add a new function, but you would be more flexible in choosing the names of the functions.</p>\n<p>There are many more solutions to achieve something similar, the question really is: What is your use case? What do want to achieve?</p>\n", "OwnerUserId": "2767436", "PostTypeId": "2", "Id": "39739781", "Score": "0", "CreationDate": "2016-09-28T06:40:03.723", "LastActivityDate": "2016-09-28T06:40:03.723"}, "39740834": {"ParentId": "39737956", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In 16.1.5 the standard says:</p>\n<blockquote>\n<p id=\"so_39737956_39740834_0\">The implementation can process and skip sections of source files conditionally, include other source files, and replace macros. <em>These capabilities are called preprocessing, because conceptually they occur before translation of the resulting translation unit.</em></p>\n</blockquote>\n<p>[emphasis mine]</p>\n<p>Originally pre-processing was done by a separate app, it is essentially an independent language.</p>\n<p>Today, the pre-processor is often part of the compiler, but - for example - you can't see macros etc in the Clang AST tree.</p>\n<p>The significance of this is that the pre-processor knows nothing about types or functions or arguments.</p>\n<p>Your function definition</p>\n<pre><code>void anotherParentFunction(const char* type)\n</code></pre>\n<p>means nothing to the pre-processor and is completely ignored by it.</p>\n<pre><code>FUNCTION_RECOGNIZER(type);\n</code></pre>\n<p>this is recognized as a defined macro, but <code>type</code> is not a recognized <em>pre-processor</em> symbol so it is treated as a literal, the pre-processor does not consult the C++ parser or interact with it's AST tree.</p>\n<p>It consults the macro definition:</p>\n<pre><code>#define FUNCTION_RECOGNIZER(TOKEN) function##TOKEN()\n</code></pre>\n<p>The argument, literal <code>type</code>, is tokenized as <code>TOKEN</code>. The word <code>function</code> is taken as a literal and copied to the result string, the <code>##</code> tells the processor to copy the value of the token <code>TOKEN</code> literally, production <code>functiontype</code> in the result string. Because <code>TOKEN</code> isn't recognized as a macro, the <code>()</code>s end the token and the <code>()</code> is appended as a literal to the result string.</p>\n<p>Thus, the pre-processor substitutes</p>\n<pre><code>FUNCTION_RECOGNIZER(type);\n</code></pre>\n<p>with</p>\n<pre><code>functiontype();\n</code></pre>\n<p>So the bad news is, no there is no way to do what you were trying to do, but this may be an <a href=\"https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem\">XY Problem</a> and perhaps there's a solution to what you were trying to achieve instead.</p>\n<p>For instance, it is possible to overload functions based on argument type, or to specialize template functions based on parameters, or you can create a lookup table based on parameter values.</p>\n", "OwnerUserId": "257645", "LastEditorUserId": "-1", "LastEditDate": "2017-03-20T10:29:30.887", "Id": "39740834", "Score": "0", "CreationDate": "2016-09-28T07:31:37.163", "LastActivityDate": "2016-09-28T07:31:37.163"}, "39737956": {"CommentCount": "7", "ViewCount": "49", "PostTypeId": "1", "LastEditorUserId": "4911868", "CreationDate": "2016-09-28T04:16:38.977", "LastActivityDate": "2016-09-28T07:31:37.163", "Title": "C++ Macro's Token-Paster as argument of a function", "LastEditDate": "2016-09-28T04:58:45.057", "Id": "39737956", "Score": "-2", "Body": "<p>I was searching for a while on the net and unfortunately i didn't find an answer or a solution for my problem, in fact, let's say i have 2 functions named like this :</p>\n<p>1) <code>function1a(some_args)</code></p>\n<p>2) <code>function2b(some_args)</code></p>\n<p>what i want to do is to write a macro that can recognize those functions when feeded with the correct parameter, just that the thing is, this parameter should be also a parameter of a C/C++ function, here is what i did so far.</p>\n<pre><code> #define FUNCTION_RECOGNIZER(TOKEN) function##TOKEN()\n\nvoid function1a() \n{\n\n}\nvoid function2a() \n{\n}\n\nvoid anotherParentFunction(const char* type)\n{\n    FUNCTION_RECOGNIZER(type);\n}\n</code></pre>\n<p>clearly, the macro is recognizing \"functiontype\" and ignoring the argument of anotherParentFunction, i'm asking if there is/exist a trick or anything to perform this way of pasting.</p>\n<p>thank you in advance :)</p>\n", "Tags": "<c++><macros>", "OwnerUserId": "4637178", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_39737956_39740834_0": {"section_id": 495, "quality": 0.8928571428571429, "length": 25}}, "n3337": {"so_39737956_39740834_0": {"section_id": 486, "quality": 0.8928571428571429, "length": 25}}, "n4659": {"so_39737956_39740834_0": {"section_id": 510, "quality": 0.8928571428571429, "length": 25}}}});