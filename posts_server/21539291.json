post_cb({"bq_ids": {"n4140": {"so_21539291_21539291_2": {"length": 13, "quality": 1.0, "section_id": 6341}, "so_21539291_21539291_4": {"length": 21, "quality": 1.0, "section_id": 6342}, "so_21539291_21539291_3": {"length": 7, "quality": 1.0, "section_id": 6341}, "so_21539291_21561407_0": {"length": 21, "quality": 1.0, "section_id": 6342}, "so_21539291_21539291_0": {"length": 10, "quality": 1.0, "section_id": 6341}, "so_21539291_21539291_1": {"length": 17, "quality": 0.85, "section_id": 6341}, "so_21539291_21561407_1": {"length": 9, "quality": 1.0, "section_id": 6356}}, "n3337": {"so_21539291_21539291_2": {"length": 13, "quality": 1.0, "section_id": 6098}, "so_21539291_21539291_4": {"length": 21, "quality": 1.0, "section_id": 6099}, "so_21539291_21539291_3": {"length": 7, "quality": 1.0, "section_id": 6098}, "so_21539291_21561407_0": {"length": 21, "quality": 1.0, "section_id": 6099}, "so_21539291_21561407_1": {"length": 9, "quality": 1.0, "section_id": 6113}, "so_21539291_21539291_1": {"length": 17, "quality": 0.85, "section_id": 6098}, "so_21539291_21539291_0": {"length": 10, "quality": 1.0, "section_id": 6098}}, "n4659": {"so_21539291_21539291_2": {"length": 9, "quality": 0.6923076923076923, "section_id": 7851}, "so_21539291_21539291_4": {"length": 16, "quality": 0.7619047619047619, "section_id": 7847}, "so_21539291_21539291_3": {"length": 5, "quality": 0.7142857142857143, "section_id": 115}, "so_21539291_21561407_0": {"length": 16, "quality": 0.7619047619047619, "section_id": 7847}, "so_21539291_21561407_1": {"length": 9, "quality": 1.0, "section_id": 7865}, "so_21539291_21539291_0": {"length": 6, "quality": 0.6, "section_id": 49}}}, "21539291": {"ViewCount": "476", "Body": "<p>Are C++ standard library implementations allowed to add public (and protected) members to standard types' interfaces? N3797 17.6.5.5 [member.functions]/2 says:</p>\n<blockquote>\n<p id=\"so_21539291_21539291_0\">An implementation may declare additional non-virtual member function signatures within a class:</p>\n<p id=\"so_21539291_21539291_1\">\u2014 by adding arguments with default values to a member function signature; [ <em>Note</em>: An implementation may not add arguments with default values to virtual, global, or non-member functions. \u2014 <em>end note</em> ]</p>\n<p id=\"so_21539291_21539291_2\">\u2014 by replacing a member function signature with default values by two or more member function signatures with equivalent behavior; and</p>\n<p id=\"so_21539291_21539291_3\">\u2014 by adding a member function signature for a member function name.</p>\n</blockquote>\n<p>Does this mean that a standard library cannot add any additional public members with names not mentioned in the standard under any circumstances (that include, for example, reserved identifiers)?</p>\n<p>A tiny bit of explanation: this is the text about adding signatures (which I assume talks about new signatures just for functions that are already defined to be there, so no new <em>names</em>) I managed to find in the standard. There is also the footnote 189, which says:</p>\n<blockquote>\n<p id=\"so_21539291_21539291_4\">A valid C++ program always calls the expected library member function, or one with equivalent behavior. An implementation may also define additional member functions that would otherwise not be called by a valid C++ program.</p>\n</blockquote>\n<p>All this text originates from [member.functions], so it is clearly about member functions only. My question is more generic and asks for any references I could've missed: is a standard library implementation allowed to add new <em>names</em> to public (and/or protected) interfaces of a standard type, be it data or function members?</p>\n", "AcceptedAnswerId": "21561407", "Title": "Are implementations allowed to add public members to standard types?", "CreationDate": "2014-02-03T22:37:03.717", "Id": "21539291", "CommentCount": "7", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-02-03T22:55:48.913", "LastEditorUserId": "809387", "LastActivityDate": "2014-02-05T04:04:12.557", "Score": "14", "OwnerUserId": "809387", "Tags": "<c++><c++11><language-lawyer><c++14>", "AnswerCount": "2"}, "21561154": {"Id": "21561154", "PostTypeId": "2", "Body": "<p>I think that the key to reading footnote 189 is the phrase <code>would otherwise not be called by a valid C++ program</code>.  </p>\n<p>Remember that identifiers beginning with an underscore followed by a capital letter (or containing two consecutive underscores anywhere) are reserved for the implementation. (section 17.6.4.3.2)</p>\n<p>So implementations are free to add public/protected member functions that are named in that manner.</p>\n<p>For example, in libc++, <code>std::vector</code> has a protected member function named <code>__throw_length_error</code></p>\n", "LastActivityDate": "2014-02-04T19:04:30.467", "CommentCount": "0", "CreationDate": "2014-02-04T19:04:30.467", "ParentId": "21539291", "Score": "2", "OwnerUserId": "992490"}, "21561407": {"Id": "21561407", "PostTypeId": "2", "Body": "<p>I believe you have what you need with a combination of foot note <code>189</code> which says:</p>\n<blockquote>\n<p id=\"so_21539291_21561407_0\">A valid C++ program always calls the expected library member function, or one with equivalent behavior. An implementation may also define additional member functions that would otherwise not be called by a valid C++ program.</p>\n</blockquote>\n<p>and section <code>17.6.5.11</code> <em>Derived classes</em> which says:</p>\n<blockquote>\n<p id=\"so_21539291_21561407_1\">An implementation may derive any class in the C++ standard library from a class with a name reserved to the implementation.</p>\n</blockquote>\n<p>but does not add any restrictions, i.e. it does not let's say restrict the access qualifiers etc...</p>\n<p>and we can see <a href=\"http://gcc.gnu.org/libstdc++/\" rel=\"nofollow\">libstdc++</a> uses derived classes pretty effectively, for example in <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.6.2/libstdc++/api/a01069_source.html\" rel=\"nofollow\">stl_vector.h</a>. Although as far as I can see <code>libstdc++</code> does seem to eschew adding public data members but that is probably more for clean design.</p>\n<p>At minimum, this looks under-specified but if you stick to something similar to <code>libstdc++</code> implementation style you should be good. </p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-02-05T04:04:12.557", "Score": "5", "CreationDate": "2014-02-04T19:18:17.440", "ParentId": "21539291", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2014-02-05T04:04:12.557"}});