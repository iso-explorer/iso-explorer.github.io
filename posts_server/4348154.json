post_cb({"4348186": {"Id": "4348186", "PostTypeId": "2", "Body": "<p>Strings are null terminated in C. If you want to populate a non-null-terminated char array you can use an array initializer.</p>\n", "Score": "0", "LastActivityDate": "2010-12-03T17:32:48.413", "CreationDate": "2010-12-03T17:32:48.413", "ParentId": "4348154", "CommentCount": "0", "OwnerUserId": "90848"}, "4348176": {"Id": "4348176", "PostTypeId": "2", "Body": "<p>No.  NUL-terminated strings are intrinsic to the language.  You can have a character array though, and set each character one by one:</p>\n<pre><code>char hex [] = {'0', '1', '2', ... 'F'};\n</code></pre>\n", "Score": "7", "LastActivityDate": "2010-12-03T17:31:51.830", "CreationDate": "2010-12-03T17:31:51.830", "ParentId": "4348154", "CommentCount": "4", "OwnerUserId": "198536"}, "4348188": {"Id": "4348188", "PostTypeId": "2", "LastEditDate": "2010-12-03T18:01:35.337", "CommentCount": "5", "LastEditorUserId": "207248", "LastActivityDate": "2010-12-03T18:01:35.337", "CreationDate": "2010-12-03T17:32:52.163", "ParentId": "4348154", "Score": "11", "Body": "<p>No need for a compiler option, it's <em>already</em> non-NUL terminated.  The standard says a NUL should only be added if it can fit, otherwise it would be an overflow. It may just be that the next byte in memory past your array is <code>\\0</code></p>\n<blockquote>\n<p id=\"so_4348154_4348188_0\"><strong>\u00a7 6.7.8p14</strong><br><br>\n  An array of character\n  type may be initialized by a character\n  string literal, optionally\n       enclosed in braces. Successive characters of the character string\n  literal (<strong><em>including the\n       terminating null character if there is room</em></strong> or if the array is of\n  unknown size) initialize the\n       elements of the array.</br></br></p>\n</blockquote>\n", "OwnerUserId": "207248"}, "bq_ids": {"n4140": {"so_4348154_4348188_0": {"length": 15, "quality": 0.5172413793103449, "section_id": 3314}}, "n4659": {"so_4348154_4348188_0": {"length": 15, "quality": 0.5172413793103449, "section_id": 4080}}}, "4348154": {"ViewCount": "2210", "LastEditDate": "2015-12-02T02:07:44.057", "AcceptedAnswerId": "4348188", "Title": "Non null-terminated string compiler option for gcc", "CreationDate": "2010-12-03T17:29:28.930", "LastActivityDate": "2015-12-02T02:07:44.057", "CommentCount": "3", "Body": "<h2>Update</h2>\n<p>turns out this is just another case of \"c++ is not c blues\"</p>\n<hr>\n<p>What I want</p>\n<pre><code>const char hex[16] = \"0123456789ABCDEF\";\n</code></pre>\n<p>the only thing that works</p>\n<pre><code>char hex[16] = \"0123456789ABCDE\"; hex[15] = \"F\";\n</code></pre>\n<p>are there any compiler options or something I can do to make strings not null terminated in the gcc compiler. so that I can make a(n) constant array</p>\n</hr>", "PostTypeId": "1", "LastEditorUserId": "3425536", "Id": "4348154", "AnswerCount": "5", "Score": "7", "OwnerUserId": "144020", "Tags": "<c++><c><string><gcc><null-terminated>", "FavoriteCount": "1"}, "4348282": {"Id": "4348282", "PostTypeId": "2", "Body": "<p>You answered your own question. If you explicitly give the array a length, as in:</p>\n<pre><code>const char hex[16] = \"0123456789ABCDEF\";\n</code></pre>\n<p>then of course it won't be null-terminated because there is no storage reserved for null termination. (<code>hex[16]</code> is outside the bounds of the object and thus reading or writing it is undefined behavior. If it happens to read as 0, that's UB for ya...)</p>\n<p>It's only if you leave the length implicit, as in:</p>\n<pre><code>const char hex[] = \"0123456789ABCDEF\";\n</code></pre>\n<p>or if you use the string literal as an object rather than as an initializer, that it will have null termination.</p>\n<p>By the way, why do you care if the null termination is there or not, if you're not planning to use it. Are you trying to shave bytes off your binary? :-)</p>\n", "Score": "5", "LastActivityDate": "2010-12-03T17:43:25.557", "CreationDate": "2010-12-03T17:43:25.557", "ParentId": "4348154", "CommentCount": "2", "OwnerUserId": "379897"}, "26955988": {"Id": "26955988", "PostTypeId": "2", "Body": "<p>I believe the question is a bit unclear: In C, the qoted initialization:</p>\n<pre><code>static const char hex[16] = \"0123456789ABCDEF\";\n</code></pre>\n<p>is legal. In C++, it is not. So it is one of the pieces of code, that fail (fortunately at compile time), when you move from C to C++.</p>\n<p>It would be nice to have a way to force string literals without termination \\0 byte. Something like:</p>\n<pre><code>static const char hex[16] = \"0123456789ABCDEF\\!0\";\n</code></pre>\n<p>where the <code>\\!0</code> at the end tells the compiler to not zero-terminate the string! <code>\\!</code> or even <code>\\!0</code> anywhere else in the string would behave unmodified, so just put out a literal <code>!</code> or <code>!0</code> .</p>\n", "Score": "0", "LastActivityDate": "2014-11-16T10:34:16.863", "CreationDate": "2014-11-16T10:34:16.863", "ParentId": "4348154", "CommentCount": "1", "OwnerUserId": "2528436"}});