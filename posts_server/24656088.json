post_cb({"bq_ids": {"n4140": {"so_24656088_25845039_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 7153}}, "n3337": {"so_24656088_25845039_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 6897}}, "n4659": {"so_24656088_25845039_0": {"length": 23, "quality": 0.6571428571428571, "section_id": 8657}}}, "25845039": {"Id": "25845039", "PostTypeId": "2", "Body": "<p>In short, there's no guarantee that static variables that cannot be initialized at compile time will be initialized before an externally visible function or variable in the same translation unit is referred to. This is true even for static linking. As for trying to get static variables in dynamically loaded libraries to initialize upon loading, my experience is that often you'll get lucky, especially for small programs, but fundamentally this is undefined behavior and should not be relied on. The resulting bugs are unpredictable, difficult to reproduce, and highly system specific.</p>\n<p>First, some standardese and an explanation of why this is undefined behavior and then some workarounds.</p>\n<p>The word static is unfortunately overloaded in the Standard so bare with me. The Standard makes reference to both <em>static storage duration</em> and <em>static initialization</em>. The types of storage duration defined by the Standard are static, thread, automatic, and dynamic. They are as they sound. Static <em>storage duration</em> means that the lifetime of such a variable is the entire duration of the program.</p>\n<p>Static <em>initialization</em> is a distinct concept. Although a variable may be stored only once per program execution, the value it will be initialized with may be not be known when the program starts. At the start of the program, all variables with static storage duration will be zero initialized and those that can be will then be constant initialized. The fine points are in \u00a73.6.2 but roughly, a static variable will be constant initialized if its initialization relies only on constant expressions. Together, zero initialization and constant initialization are termed <em>static initialization</em>. The counterpart is <em>dynamic initialization</em>. These are the interesting ones but unfortunately there's no portable way to force dynamic initialization to take place before <code>main()</code> first executes, in the case of dynamic linking, or before <code>dlopen()</code> returns, in the case of dynamic loading. C++ simply does not demand such.</p>\n<p>The key part of the C++11 Standard is in \u00a73.6.2:</p>\n<blockquote>\n<p id=\"so_24656088_25845039_0\">It is implementation-defined whether the dynamic initialization of a\n  non-local variable with static storage duration is done before the\n  first statement of main. If the initialization is deferred to some\n  point in time after the first statement of main, it shall occur before\n  the first odr-use (3.2) of any function or variable defined in the\n  same translation unit as the variable to be initialized.</p>\n</blockquote>\n<p>Nonetheless, if you've experimented, you've noticed that sometimes this does work. Sometimes you can get arbitrary code to run upon library loading by stuffing it in the constructors of static variables. Whether this happens is simply up to the compiler (not the linker). The manpage for <a href=\"http://linux.die.net/man/3/dlopen\" rel=\"nofollow noreferrer\">dlopen</a> explains.</p>\n<blockquote>\n<p id=\"so_24656088_25845039_1\">If a dynamic library exports a routine named _init(), then that code is executed after the loading, before dlopen() returns</p>\n</blockquote>\n<p>Inspecting the asm output of a small shared object written in standard C++, I can see that clang 3.4 and g++ 4.8 both add an _init section, however they are not required to do so.</p>\n<p>As for workarounds, a gcc extension that has become commonplace does allow control of this behavior. By adding a constructor attribute to functions, we can insist that they be run upon library initialization. The linked manpage for dlopen suggests using this method.</p>\n<p>See the <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html\" rel=\"nofollow noreferrer\">GCC documentation</a> on function attributes and <a href=\"https://stackoverflow.com/questions/2053029/how-exactly-does-attribute-constructor-work\">this SO question</a> which has an example usage. This extension is supported by gcc, clang, IBM XL, and my guess is that icc supports it too. MSVC does not support this but I understand there's something similar.</p>\n<p>A truly portable solution is elusive. As the Standard says, if you can somehow cause an odr usage in the same translation unit as the static variable, then the static variable must be initialized. Calling a function, even a dummy function just for this purpose, would work.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-09-15T09:41:26.017", "Score": "2", "CreationDate": "2014-09-15T09:41:26.017", "ParentId": "24656088", "CommentCount": "0", "OwnerUserId": "1128289", "LastEditDate": "2017-05-23T10:33:01.713"}, "24656088": {"ViewCount": "1204", "Body": "<p>If I were to load up some symbols using something like <code>dlopen</code> in C++ while other classes in that translation unit had <code>static</code> member variables what exactly is the behavior of those static member variables. Do they get initialized or no because the library isn't really loaded just the symbols that you looked up (which I'm thinking the latter is not true because if the symbol you looked up needs those they need to be loaded too)?</p>\n", "Title": "Static member variable for class that is dynamically loaded", "CreationDate": "2014-07-09T14:13:31.477", "LastActivityDate": "2014-09-15T09:41:26.017", "CommentCount": "3", "LastEditDate": "2014-07-09T14:48:06.170", "PostTypeId": "1", "LastEditorUserId": "802302", "Id": "24656088", "Score": "1", "OwnerUserId": "802302", "Tags": "<c++><linux><shared-libraries><dynamic-loading>", "AnswerCount": "1"}});