post_cb({"bq_ids": {"n4140": {"so_26920134_26920239_1": {"length": 17, "quality": 0.7391304347826086, "section_id": 3298}}, "n3337": {"so_26920134_26920239_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 3168}}, "n4659": {"so_26920134_26920239_1": {"length": 12, "quality": 0.5217391304347826, "section_id": 4063}}}, "26920301": {"Id": "26920301", "PostTypeId": "2", "Body": "<p>The answer given by R Sahu is already correct, but I'd like to add that there is no loss of efficiency to add a constructor that does what your memberwise-initialization does:</p>\n<pre><code>struct B {\n  A a_;\n  B(const A&amp; a) : a_(a) {}\n}\n</code></pre>\n<p>Now calling <code>B b {A()};</code> is exactly as efficient as it was when you were using aggregate-initialization.</p>\n<p>UPDATE:\nAfter reading the comments I've tested my assertion:</p>\n<pre><code>struct Foo\n{\n        Foo() { std::cout &lt;&lt; \"Foo default\" &lt;&lt; std::endl; }\n        Foo(const Foo&amp; other) { std::cout &lt;&lt; \"Foo copy\" &lt;&lt; std::endl; }\n};\n\nstruct Bar\n{\n        Foo f;\n        // #1 Bar(const Foo&amp; f) : f(f) {}\n};\n\nint main()\n{\n        Bar b { Foo() };\n}\n</code></pre>\n<p>As shown above this application outputs just </p>\n<pre>\nFoo default\n</pre>\n<p>If I uncomment #1 I then get </p>\n<pre>\nFoo default\nFoo copy\n</pre>\n<p>as the original poster suggested (GCC 4.9 with -O3).  I have to play more with non-printing constructors to see if this is always true or just when there are side effects, but I wanted to update this post to clarify that it is not as cut and dry as I suggested.</p>\n", "LastEditorUserId": "1738399", "LastActivityDate": "2014-11-14T13:17:37.703", "Score": "1", "CreationDate": "2014-11-13T23:19:55.183", "ParentId": "26920134", "CommentCount": "2", "OwnerUserId": "1738399", "LastEditDate": "2014-11-14T13:17:37.703"}, "26920134": {"ViewCount": "376", "Body": "<p>Without defining a constructor I am able to use memberwise initialization:</p>\n<pre><code>struct B {\n  A a_;\n};\n</code></pre>\n<p>and later on it okay to say</p>\n<pre><code>B b {A()};\n</code></pre>\n<p>This is efficient as no copy or move of A is involved. However as soon as I define a move constructor for B the above code no longer compiles. How can I have both memberwise initialization and some constructors coexist?</p>\n", "AcceptedAnswerId": "26920239", "Title": "C++ memberwise initialization and constructors", "CreationDate": "2014-11-13T23:05:24.300", "Id": "26920134", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-11-14T13:17:37.703", "Score": "1", "OwnerUserId": "1640831", "Tags": "<c++>", "AnswerCount": "2"}, "26920239": {"Id": "26920239", "PostTypeId": "2", "Body": "<p>The way it is defined, <code>B</code> is an aggregate type if <code>A</code> is an aggregate type. </p>\n<pre><code>B b {A()};\n</code></pre>\n<p>is aggregate initialization.</p>\n<p>When you add a move constructor to <code>B</code>, <code>B</code> stops being an aggregate type. Hence, you can't use aggregate initialization to initialize an instance of <code>B</code>.</p>\n<p>From the standard (emphasis mine):</p>\n<blockquote>\n<p id=\"so_26920134_26920239_0\"><strong>8.5.1 Aggregates</strong> [dcl.init.aggr]</p>\n<p id=\"so_26920134_26920239_1\">1 An <em>aggregate</em> is an array or a <strong>class (Clause 9) with no user-provided constructors</strong> (12.1), no <em>brace-or-equalinitializers</em> for non-static data members (9.2), no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3)</p>\n</blockquote>\n", "LastActivityDate": "2014-11-13T23:13:51.397", "CommentCount": "6", "CreationDate": "2014-11-13T23:13:51.397", "ParentId": "26920134", "Score": "2", "OwnerUserId": "434551"}});