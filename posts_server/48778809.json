post_cb({"48778809": {"ViewCount": "80", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/concept/ContiguousIterator\" rel=\"nofollow noreferrer\">C++ concepts: ContiguousIterator</a></p>\n<p>refers to the type of an iterator to <code>std::vector</code> as contiguous. But \nthere is no definition provided for the type contiguous iterator <a href=\"http://en.cppreference.com/w/cpp/iterator/iterator_tags\" rel=\"nofollow noreferrer\">here</a></p>\n<p><a href=\"http://www.cplusplus.com/reference/vector/vector/begin/\" rel=\"nofollow noreferrer\">std::vector::begin</a></p>\n<p>refers to the iterator type as random access iterator.</p>\n<p>Does this imply that contiguous iterator is of type random access? </p>\n", "AcceptedAnswerId": "48790440", "Title": "std::vector iterator type and permissible operations", "CreationDate": "2018-02-14T02:36:15.693", "LastActivityDate": "2018-02-14T15:28:19.520", "CommentCount": "0", "LastEditDate": "2018-02-14T02:54:55.483", "PostTypeId": "1", "LastEditorUserId": "6022656", "Id": "48778809", "Score": "1", "OwnerUserId": "9196120", "Tags": "<c++><c++11><iterator><c++17><contiguous>", "AnswerCount": "3"}, "48778918": {"Id": "48778918", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48778809_48778918_0\">[a] contiguous iterator is of type random access? </p>\n</blockquote>\n<p>Yes.</p>\n<p>A \"contiguous iterator\" is defined (see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3884.pdf\" rel=\"nofollow noreferrer\">N3884</a>) as</p>\n<blockquote>\n<p id=\"so_48778809_48778918_1\">a random access iterator that also meets the following requirements: </p>\n<p id=\"so_48778809_48778918_2\"><code>std::pointer_from(i) == std::addressof(*i)</code> (when <code>i</code> is dereferenceable)</p>\n<p id=\"so_48778809_48778918_3\"><code>std::pointer_from(i + n) == std::pointer_from(i) + n</code> (when <code>i + n</code> is a valid iterator)</p>\n</blockquote>\n<p>So</p>\n<ul>\n<li><p>\"contiguous iterator\" imply \"random access iterator\"</p></li>\n<li><p>\"random access iterator\" doesn't imply \"contiguous iterator\" (see <code>std::deque</code> for a counterexample)</p></li>\n</ul>\n", "LastEditorUserId": "6022656", "LastActivityDate": "2018-02-14T03:25:39.747", "Score": "4", "CreationDate": "2018-02-14T02:50:01.417", "ParentId": "48778809", "CommentCount": "0", "OwnerUserId": "6022656", "LastEditDate": "2018-02-14T03:25:39.747"}, "48778901": {"Id": "48778901", "PostTypeId": "2", "Body": "<p>Yup. <a href=\"http://en.cppreference.com/w/cpp/iterator\" rel=\"nofollow noreferrer\">cppreference has a nice chart</a>, that makes it clear that <code>ContiguousIterator</code> encompasses a superset of the features of <code>RandomAccessIterator</code> (which is itself a superset of <code>BidirectionalIterator</code>, which is a superset of <code>ForwardIterator</code>, etc.).</p>\n", "LastActivityDate": "2018-02-14T02:48:10.297", "Score": "2", "CreationDate": "2018-02-14T02:48:10.297", "ParentId": "48778809", "CommentCount": "0", "OwnerUserId": "364696"}, "bq_ids": {"n4140": {"so_48778809_48778918_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 3844}, "so_48778809_48790440_1": {"length": 9, "quality": 0.6428571428571429, "section_id": 763}, "so_48778809_48778918_0": {"length": 4, "quality": 0.8, "section_id": 711}}, "n3337": {"so_48778809_48778918_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 3706}, "so_48778809_48790440_1": {"length": 9, "quality": 0.6428571428571429, "section_id": 750}, "so_48778809_48778918_0": {"length": 4, "quality": 0.8, "section_id": 700}}, "n4659": {"so_48778809_48790440_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7005}, "so_48778809_48778918_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 4612}, "so_48778809_48790440_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 743}, "so_48778809_48778918_0": {"length": 5, "quality": 1.0, "section_id": 4612}}}, "48790440": {"Id": "48790440", "PostTypeId": "2", "Body": "<p>CPPReference is leading you astray by portraying an iterator category and concept <code>ContiguousIterator</code> that do not appear in the C++ Standard. C++17 defines contiguity as a property of iterators, much like mutability. <a href=\"http://eel.is/c++draft/iterator.requirements.general#6\" rel=\"nofollow noreferrer\">[iterator.requirements.general]/6</a>:</p>\n<blockquote>\n<p id=\"so_48778809_48790440_0\">Iterators that further satisfy the requirement that, for integral values <code>n</code> and dereferenceable iterator values <code>a</code> and <code>(a + n)</code>, <code>*(a + n)</code> is equivalent to <code>*(addressof(*a) + n)</code>, are called <em>contiguous iterators</em>.</p>\n</blockquote>\n<p>Notably this property is independent of iterator category. In theory, you could define an iterator that satisfies the <em>contiguous iterator</em> requirements and the requirements of any of the iterator categories. </p>\n<p>In practice, I don't think this flexibility provides any expressiveness over a design in which contiguous iterators are a refinement of random access iterators. In fact the standard library container requirements define <em>contiguous container</em> as (<a href=\"http://eel.is/c++draft/container.requirements#general-13\" rel=\"nofollow noreferrer\">[container.requirements]/13</a>):</p>\n<blockquote>\n<p id=\"so_48778809_48790440_1\">A <em>contiguous container</em> is a container that supports random access iterators and whose member types <code>iterator</code> and <code>const_\u00aditerator</code> are contiguous iterators.</p>\n</blockquote>\n<p>which does not precisely contradict [iterator.requirements.general]/6's notion that contiguity is independent of iterator category, but it does introduce an inconsistency that helps to cause confusion.</p>\n", "LastEditorUserId": "923854", "LastActivityDate": "2018-02-14T15:28:19.520", "Score": "1", "CreationDate": "2018-02-14T15:14:04.157", "ParentId": "48778809", "CommentCount": "2", "OwnerUserId": "923854", "LastEditDate": "2018-02-14T15:28:19.520"}});