post_cb({"2271046": {"CommentCount": "1", "AcceptedAnswerId": "2271055", "CreationDate": "2010-02-16T06:27:49.187", "LastActivityDate": "2010-02-16T09:16:24.187", "PostTypeId": "1", "ViewCount": "1151", "FavoriteCount": "1", "Title": "If changing a const object is undefined behavior then how do constructors and destructors operate with write access?", "Id": "2271046", "Score": "8", "Body": "<p>C++ standard says that modifying an object originally declared <code>const</code> is undefined behavior. But then how do constructors and destructors operate?</p>\n<pre><code>class Class {\npublic:\n    Class() { Change(); }\n    ~Class() { Change(); }\n    void Change() { data = 0; }\nprivate:\n    int data;\n};\n\n//later:\nconst Class object;\n//object.Change(); - won't compile\nconst_cast&lt;Class&amp;&gt;( object ).Change();// compiles, but it's undefined behavior\n</code></pre>\n<p>I mean here the constructor and destructor do exactly the same thing as the calling code, but they are allowed to change the object and the caller is not allowed - he runs into undefined behavior.</p>\n<p>How is it supposed to work under an implementation and according to the standard?</p>\n", "Tags": "<c++><constructor><const><destructor><undefined-behavior>", "OwnerUserId": "57428", "AnswerCount": "5"}, "2271687": {"ParentId": "2271046", "CommentCount": "0", "Body": "<p>To elaborate on what Jerry Coffin said: the standard makes accessing a const object undefined, only if that access occurs during the object's lifetime.</p>\n<p>7.1.5.1/4:</p>\n<blockquote>\n<p id=\"so_2271046_2271687_0\">Except that any class member declared mutable (7.1.1) can be modified, any attempt to modify a const object during its lifetime (3.8) results in undefined behavior.</p>\n</blockquote>\n<p>The object's lifetime begins only after the constructor has finished.</p>\n<p>3.8/1:</p>\n<blockquote>\n<p id=\"so_2271046_2271687_1\">The lifetime of an object of type T begins when:</p>\n<ul>\n<li>storage with the proper alignment and size for type T is obtained, and</li>\n<li>if T is a class type with a non-trivial constructor (12.1), the constructor call has completed.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "89847", "PostTypeId": "2", "Id": "2271687", "Score": "2", "CreationDate": "2010-02-16T09:16:24.187", "LastActivityDate": "2010-02-16T09:16:24.187"}, "2271399": {"ParentId": "2271046", "CommentCount": "2", "Body": "<p>Here's a way that ignoring the standard could lead to incorrect behavior.  Consider a situation like this:</p>\n<pre><code>class Value\n{\n    int value;\n\npublic: \n    value(int initial_value = 0)\n        : value(initial_value)\n    {\n    }\n\n    void set(int new_value)\n    {\n        value = new_value;\n    }\n\n    int get() const\n    {\n        return value;\n    }\n}\n\nvoid cheat(const Value &amp;v);\n\nint doit()\n{\n    const Value v(5);\n\n    cheat(v);\n\n    return v.get();\n}\n</code></pre>\n<p>If optimized, the compiler knows that v is const so could replace the call to <code>v.get()</code> with <code>5</code>.</p>\n<p>But let's say in a different translation unit, you've defined <code>cheat()</code> like this:</p>\n<pre><code>void cheat(const Value &amp;cv)\n{\n     Value &amp;v = const_cast&lt;Value &amp;&gt;(cv);\n     v.set(v.get() + 2);\n}\n</code></pre>\n<p>So while on most platforms this will run, the behavior could change depending on what the optimizer does.</p>\n", "OwnerUserId": "29809", "PostTypeId": "2", "Id": "2271399", "Score": "1", "CreationDate": "2010-02-16T08:10:47.390", "LastActivityDate": "2010-02-16T08:10:47.390"}, "2271063": {"ParentId": "2271046", "CommentCount": "0", "Body": "<p>The standard doesn't really say a lot about how the implementation makes it work, but the basic idea is pretty simple: the <code>const</code> applies to the <em>object</em>, not (necessarily) to the memory in which the object is stored. Since the ctor is part of what creates the object, it's not really an object until (sometime shortly after) the ctor returns. Likewise, since the dtor takes part in destroying the object, it's no longer really operating on a complete object either.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "2271063", "Score": "1", "CreationDate": "2010-02-16T06:35:54.743", "LastActivityDate": "2010-02-16T06:35:54.743"}, "2271061": {"ParentId": "2271046", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Constness for a user-defined type is different than constness for a built-in type.  Constness when used with user-defined types is said to be \"logical constness.\"  The compiler enforces that only member functions declared \"const\" can be called on a const object (or pointer, or reference).  The compiler cannot allocate the object in some read-only memory area, because <em>non-const</em> member functions must be able to modify the object's state (and even <em>const</em> member functions must be able to when a member variable is declared <code>mutable</code>).</p>\n<p>For built-in types, I believe the compiler is allowed to allocate the object in read-only memory (if the platform supports such a thing).  Thus casting away the const and modifying the variable could result in a run-time memory protection fault.</p>\n", "Id": "2271061", "LastEditDate": "2010-02-16T06:47:50.487", "OwnerDisplayName": "user123456", "Score": "0", "CreationDate": "2010-02-16T06:34:52.960", "LastActivityDate": "2010-02-16T06:47:50.487", "LastEditorDisplayName": "user123456"}, "bq_ids": {"n4140": {"so_2271046_2271055_1": {"section_id": 398, "quality": 0.8214285714285714, "length": 23}, "so_2271046_2271687_0": {"section_id": 5433, "quality": 0.9444444444444444, "length": 17}, "so_2271046_2271055_0": {"section_id": 368, "quality": 0.8518518518518519, "length": 23}, "so_2271046_2271687_1": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_2271046_2271055_1": {"section_id": 389, "quality": 0.8214285714285714, "length": 23}, "so_2271046_2271687_0": {"section_id": 5228, "quality": 0.9444444444444444, "length": 17}, "so_2271046_2271055_0": {"section_id": 358, "quality": 0.8518518518518519, "length": 23}, "so_2271046_2271687_1": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_2271046_2271687_0": {"section_id": 6861, "quality": 0.9444444444444444, "length": 17}, "so_2271046_2271055_1": {"section_id": 415, "quality": 0.8214285714285714, "length": 23}, "so_2271046_2271687_1": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_2271046_2271055_0": {"section_id": 380, "quality": 0.8518518518518519, "length": 23}}}, "2271055": {"ParentId": "2271046", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>The standard explicitly allows constructors and destructors to deal with <code>const</code> objects.  from 12.1/4 \"Constructors\":</p>\n<blockquote>\n<p id=\"so_2271046_2271055_0\">A constructor can be invoked for a <code>const</code>, <code>volatile</code> or <code>const volatile</code> object. ... <code>const</code> and <code>volatile</code> semantics (7.1.5.1) are not applied on an object under construction.  Such semantics only come into effect once the constructor for the most derived object (1.8) ends.</p>\n</blockquote>\n<p>And 12.4/2 \"Destructors\":</p>\n<blockquote>\n<p id=\"so_2271046_2271055_1\">A  destructor  can  be  invoked  for  a <code>const</code>, <code>volatile</code> or <code>const volatile</code> object. ...  <code>const</code> and <code>volatile</code> semantics (7.1.5.1) are not applied on an object under destruction.  Such semantics stop being into effect once the destructor for the most derived object (1.8) starts.</p>\n</blockquote>\n<p>As background, Stroustrup says in \"Design and Evolution of C++\" (13.3.2 Refinement of the Defintion of <code>const</code>):</p>\n<blockquote>\n<p id=\"so_2271046_2271055_2\">To ensure that some, but not all, <code>const</code> objects could be placed read-only memory (ROM), I adopted the rule that any object that has a constructor (that is, required runtime initialization) can't be place in ROM, but other <code>const</code> objects can.</p>\n<p id=\"so_2271046_2271055_3\">...</p>\n<p id=\"so_2271046_2271055_4\">An object declared <code>const</code> is considered immutable from the completion of the constructor until the start of its destructor.  The result of a write to the object between those points is deemed undefined.</p>\n<p id=\"so_2271046_2271055_5\">When originally designing <code>const</code>, I remember arguing that the ideal <code>const</code> would be an object that is writable until the constructor had run, then becomes read-only by some hardware magic, and finally upon the entry into the destructor becomes writable again. One could imagine a tagged architecture that actually worked this way. Such an implementation would cause a run-time error if someone could write to an object defined <code>const</code>. On the other hand, someone could write to an object not defined <code>const</code> that had been passed as a <code>const</code> reference or pointer. In both cases, the user would have to cast away <code>const</code> first. The implication of this view is that casting away <code>const</code> for an object that was originally defined <code>const</code> and then writing to it is at best undefined, whereas doing the same to an object that wasn't originally defined <code>const</code> is legal and well defined.</p>\n<p id=\"so_2271046_2271055_6\">Note that with this refinement of the rules, the meaning of <code>const</code> doesn't depend on whether a type has a constructor or not; in principle, they all do. Any object declared <code>const</code> now may be placed in ROM, be placed in code segments, be protected by access control, etc., to ensure that it doesn't mutate after receiving its initial value. Such protection is not required, however, because current systems cannot in general protect every <code>const</code> from every form of corruption.</p>\n</blockquote>\n", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2010-02-16T07:24:46.817", "Id": "2271055", "Score": "15", "CreationDate": "2010-02-16T06:33:14.277", "LastActivityDate": "2010-02-16T07:24:46.817"}});