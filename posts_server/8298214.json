post_cb({"8301494": {"ParentId": "8298214", "PostTypeId": "2", "CommentCount": "0", "Body": "<pre><code>template&lt;typename T&gt; constexpr int size(T const&amp;) { \n  return 1; \n}\n\ntemplate&lt;typename T, int N&gt; constexpr int size(T const (&amp;a)[N]) { \n  return N * size(a[0]); \n} \n</code></pre>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2011-11-29T22:04:56.393", "Id": "8301494", "Score": "3", "CreationDate": "2011-11-28T19:53:12.987", "LastActivityDate": "2011-11-29T22:04:56.393"}, "8300518": {"ParentId": "8298214", "CommentCount": "0", "Body": "<pre><code>#include &lt;type_traits&gt;\n#include &lt;cstdlib&gt;\n\ntemplate &lt;typename T&gt;\nconstexpr size_t size(const T&amp;) noexcept\n{\n    return sizeof(T)/sizeof(typename std::remove_all_extents&lt;T&gt;::type);\n}\n</code></pre>\n<p>Example:</p>\n<pre><code>#include &lt;cstdio&gt;\nint main()\n{\n    int a[3][4][7][12];\n    char f[6];\n\n    printf(\"%lu == %ld ?\\n\", size(a), 3*4*7*12);\n    printf(\"%lu == %ld ?\\n\", size(f), 6);\n\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "224671", "PostTypeId": "2", "Id": "8300518", "Score": "5", "CreationDate": "2011-11-28T18:30:33.387", "LastActivityDate": "2011-11-28T18:30:33.387"}, "8298487": {"ParentId": "8298214", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You're looking for <code>std::extent</code>. C++11 \u00a720.9.5:</p>\n<pre><code>template &lt;class T, unsigned I = 0&gt; struct extent;\n</code></pre>\n<blockquote>\n<p id=\"so_8298214_8298487_0\">If T is not an array type, or if it has rank less than or equal to I, or if I is 0 and T has type \u201carray of unknown bound of U\u201d, then 0; otherwise, the bound (8.3.4) of the I\u2019th dimension of T, where indexing of I is zero-based.</p>\n</blockquote>\n<p>Usage, also from the Standard, prefix <code>extent</code> with <code>std::</code> as needed:</p>\n<pre><code>assert((extent&lt;int[2][4], 1&gt;::value) == 4);\n</code></pre>\n<p>You should also probably use this to replace your custom <code>size</code> function.</p>\n<p>Edit: Oops, now I read to the end of the question :vP . You also need <code>std::remove_extent</code>.</p>\n<pre><code>template&lt; typename multi_array, bool = std::is_array&lt; multi_array &gt;::value &gt;\nstruct total_extent;\n\ntemplate&lt; typename multi_array &gt;\nstruct total_extent&lt; multi_array, false &gt; {\n    enum { value = 1 };\n};\n\ntemplate&lt; typename multi_array &gt;\nstruct total_extent&lt; multi_array, true &gt; {\n    enum {\n        value = std::extent&lt; multi_array &gt;::value\n              * total_extent&lt; typename std::remove_extent&lt; multi_array &gt;\n                              ::type &gt;::value\n    };\n};\n</code></pre>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2011-11-28T16:09:21.303", "Id": "8298487", "Score": "2", "CreationDate": "2011-11-28T15:54:35.690", "LastActivityDate": "2011-11-28T16:09:21.303"}, "bq_ids": {"n4140": {"so_8298214_8298487_0": {"section_id": 4711, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_8298214_8298487_0": {"section_id": 4519, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_8298214_8298487_0": {"section_id": 6109, "quality": 0.9473684210526315, "length": 18}}}, "8298214": {"CommentCount": "1", "CreationDate": "2011-11-28T15:34:47.937", "PostTypeId": "1", "AcceptedAnswerId": "8300518", "LastEditorUserId": "636019", "LastActivityDate": "2011-11-29T22:04:56.393", "LastEditDate": "2011-11-28T19:37:38.760", "ViewCount": "653", "FavoriteCount": "2", "Title": "Size of built-in multidimensional array using variadic template function", "Id": "8298214", "Score": "3", "Body": "<p>In C++11 it is possible to create a function which returns the size (number of elements) of a built-in one dimensional array at compile time using constexpr. Example below:</p>\n<pre><code>template &lt;typename T, std::size_t N&gt;\nconstexpr std::size_t size(T (&amp;array)[N])\n{\n     return N;\n}\n</code></pre>\n<p>This is a superior alternative to ARRAY_SIZE and similar macros imo.</p>\n<p>However, this will only return the size of the most significant dimension of a built-in multidimensional array.</p>\n<p>I use the following function for determining the size of a built-in two dimensional array:</p>\n<pre><code>template &lt;typename T, std::size_t N, std::size_t N2&gt;\nconstexpr std::size_t size(T (&amp;array)[N][N2])\n{\n     return N * N2;\n}\n</code></pre>\n<p>Ideally, it would be very useful to have a function that returns the size of a built-in array with an arbitrary number of dimensions. I thought variadic templates may help but I couldn't see a way of unpacking the template paramters as only one argument is passed. Is such a function possible?</p>\n<p>Thanks in advance.</p>\n", "Tags": "<c++><multidimensional-array><c++11><variadic-templates><built-in>", "OwnerUserId": "762809", "AnswerCount": "3"}});