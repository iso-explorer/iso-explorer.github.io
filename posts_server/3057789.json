post_cb({"26020732": {"ParentId": "3057789", "CommentCount": "0", "CreationDate": "2014-09-24T15:23:34.347", "OwnerUserId": "1635675", "PostTypeId": "2", "Id": "26020732", "Score": "1", "Body": "<p>Actually, this seems logical. Inheritance gives you access to Derived::foo and not to Base::foo. Let me illustrate with a code example:</p>\n<pre><code>struct Derived : public Base\n{\n    void callPrivateMethod(Base &amp;b)\n    {\n        // this should obviously fail\n        b.foo(5);\n\n        // pointer-to-member call should also fail\n        void (Base::*pBaseFoo) (int) = &amp;Base::foo; // the same error as yours here\n        (b.*pBaseFoo)(5);\n    }\n};\n</code></pre>\n", "LastActivityDate": "2014-09-24T15:23:34.347"}, "3057789": {"CommentCount": "5", "ViewCount": "1554", "CreationDate": "2010-06-16T23:02:06.247", "LastActivityDate": "2014-09-24T15:23:34.347", "Title": "boost::bind with protected members & context", "FavoriteCount": "2", "PostTypeId": "1", "Id": "3057789", "Score": "5", "Body": "<p>In the below code, there are two \"equivalent\" calls to <code>std::for_each</code> using <code>boost:bind</code> expressions. The indicated line compiles, the indicated failing line fails. The best explanation I can find in the standard amounts to \"because we said so\". I'm looking for \"why the standard indicates this behavior\". My suppositions are below.</p>\n<p>My question is simply: Why does the indicated line compile and the equivalent following line fail to compile (and I don't want because \"the standard says so\", I already know that - I will not accept any answers that give this as an explanation; I'd like an explanation as to <em>why</em> the standard says so).</p>\n<p>Notes: Although I use boost, boost is irrelevant to this question, and the error in various formats has been reproduced using g++ 4.1.* and VC7.1.</p>\n<pre><code>#include &lt;boost/bind.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;algorithm&gt;\n\nclass Base\n{\nprotected:\n        void foo(int i)\n        { std::cout &lt;&lt; \"Base: \" &lt;&lt; i &lt;&lt; std::endl; }\n};\n\nstruct Derived : public Base\n{\n        Derived()\n        {\n                data[0] = 5;\n                data[1] = 6;\n                data[2] = 7;\n        }\n\n        void test()\n        {\n                // Compiles\n                std::for_each(data.begin(), data.end(),\n                        boost::bind(&amp;Derived::foo, this,\n                                boost::bind(&amp;std::map&lt;int, int&gt;::value_type::second, _1)));\n\n                // Fails to compile - why?\n                std::for_each(data.begin(), data.end(),\n                        boost::bind(&amp;Base::foo, this,\n                                boost::bind(&amp;std::map&lt;int, int&gt;::value_type::second, _1)));\n        }\n\n        std::map&lt;int, int&gt; data;\n};\n\nint main(int, const char**)\n{\n        Derived().test();\n\n        return 0;\n}\n</code></pre>\n<p>The indicated line fails with this error:\nmain.C: In member function 'void Derived::test()':\nmain.C:9: error: 'void Base::foo(int)' is protected\nmain.C:31: error: within this context</p>\n<p>As noted, the supposedly equivalent statement above compiles cleanly (and if the offending statement is commented out, runs with the expected result of printing \u201c5\u201d, \u201c6\u201d, \u201c7\u201d on separate lines).</p>\n<p>While searching for an explanation, I came across 11.5.1 in the standard (specifically, I\u2019m looking at the 2006-11-06 draft):</p>\n<blockquote>\n<p id=\"so_3057789_3057789_0\">An additional access check beyond\n  those described earlier in clause 11\n  is applied when a non-static data\n  member or nonstatic member function is\n  a protected member of its naming class\n  (11.2)105) As described earlier,\n  access to a protected member is\n  granted because the reference occurs\n  in a friend or member of some class C.\n  If the access is to form a pointer to\n  member (5.3.1), the\n  nested-name-specifier shall name C or\n  a class derived from C. All other\n  accesses involve a (possibly implicit)\n  object expression (5.2.5). In this\n  case, the class of the object\n  expression shall be C or a class\n  derived from C.</p>\n</blockquote>\n<p>After reading this, it became evidently why the second statement failed while the first succeeded, but then the question came up: What is the rationale for this?</p>\n<p>My initial thought was that the compiler was expanding the boost::bind templates, discovering that Base::foo was protected and kicking it out because boost::bind&lt;\u2026&gt; was not a friend. But, the more I thought about this explanation, the less it made sense, because if I recall correctly, as soon as you take the pointer to a member (assuming you initially are within access control of the member), all access control information is lost (i.e. I could define a function that returns an arbitrary pointer to a member that alternately returns a public, protected or private member depending on some input and the returner would be none the wiser).</p>\n<p>More I thought about it, and the only plausible explanation I could come up with why it should make a difference was in the case of multiple inheritance.  Specifically, that depending on the class layout, the member pointer when calculated from Base would be different than that calculated from Derived.</p>\n", "Tags": "<c++>", "OwnerUserId": "311314", "AnswerCount": "2"}, "3061991": {"ParentId": "3057789", "CommentCount": "0", "CreationDate": "2010-06-17T13:25:51.940", "OwnerUserId": "318688", "PostTypeId": "2", "Id": "3061991", "Score": "5", "Body": "<p>It's all about \"context\". In the first call the context of the call is <code>Derived</code> which has access to the protected members of <code>Base</code> and hence is allowed to take addresses of them. In the second the context is \"outside of\" <code>Derived</code> and hence outside of <code>Base</code> so the protected member access is not allowed.</p>\n", "LastActivityDate": "2010-06-17T13:25:51.940"}, "bq_ids": {"n4140": {"so_3057789_3057789_0": {"section_id": 6695, "quality": 0.9152542372881356, "length": 54}}, "n3337": {"so_3057789_3057789_0": {"section_id": 6450, "quality": 0.9152542372881356, "length": 54}}, "n4659": {"so_3057789_3057789_0": {"section_id": 8170, "quality": 0.9152542372881356, "length": 54}}}});