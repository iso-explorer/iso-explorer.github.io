post_cb({"45934517": {"Id": "45934517", "PostTypeId": "2", "Body": "<p>Reading <a href=\"http://eel.is/c++draft/basic.string#string.erase\" rel=\"nofollow noreferrer\">documentation</a>, I think it depends on the signature of the function. In the case <code>basic_string&amp; erase(size_type pos = 0, size_type n = npos);</code> it's described as a <strong>copy</strong> of the previous string. In the case <code>iterator erase(const_iterator first, const_iterator last);</code> the elements are <strong>removed</strong>.</p>\n<p>Actually I'm quite surprised by the difference. I think you can't be sure that there is no allocation.</p>\n<p><strong>EDIT</strong> Note that in this small example, I keep the same address at each check:</p>\n<pre><code>#include &lt;iostream&gt;\nint main()\n{\n    std::string a;\n    for(std::size_t i = 0; i &lt; 10000; ++i)\n        a += \"Hello World ! My name is Bond... James Bond.\";\n    std::cout &lt;&lt; (long)&amp;a[0] &lt;&lt; std::endl;\n    a.erase(400000);\n    std::cout &lt;&lt; (long)&amp;(a[0]) &lt;&lt; std::endl;\n    a.erase(10);\n    std::cout &lt;&lt; (long)&amp;(a[0]) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "3378179", "LastActivityDate": "2017-08-29T08:58:54.583", "Score": "1", "CreationDate": "2017-08-29T08:45:39.823", "ParentId": "45934295", "CommentCount": "0", "OwnerUserId": "3378179", "LastEditDate": "2017-08-29T08:58:54.583"}, "45934606": {"Id": "45934606", "PostTypeId": "2", "Body": "<p>No, sensible implementations might not reallocate but the standard does not guarantee that these method calls do not reallocate, the standard says on the requirements:</p>\n<blockquote>\n<p id=\"so_45934295_45934606_0\">References, pointers, and iterators referring to the elements of a\n  <code>basic_\u00adstring</code> sequence may be invalidated by the following uses of\n  that basic_\u00adstring object:</p>\n<p id=\"so_45934295_45934606_1\">(4.1)\n  as an argument to any standard library function taking a reference to non-const basic_\u00adstring as an argument.227</p>\n<p id=\"so_45934295_45934606_2\">(4.2)\n  <strong>Calling non-const member functions, except operator[], at, data, front, back, begin, rbegin, end, and rend</strong>.</p>\n</blockquote>\n<p>Both proposed methods fall under category 2 and thus both might change <code>capacity()</code> which would implicitly mean a reallocation.</p>\n<p><code>pop_back</code> is required to have the same effect as <code>erase</code> as <code>erase</code> is specified as :</p>\n<blockquote>\n<p id=\"so_45934295_45934606_3\">Effects: Determines the effective length xlen of the string to be\n  removed as the smaller of <code>n</code> and <code>size() - pos</code>. 3</p>\n<p id=\"so_45934295_45934606_4\">The function then replaces the string controlled by <code>*this</code> with a string of length <code>size() - xlen</code> whose first <code>pos</code> elements are a copy of\n  the initial elements of the original string controlled by <code>*this</code>, and\n  whose remaining elements are a copy of the elements of the original\n  string controlled by <code>*this</code> beginning at position <code>pos + xlen</code>.</p>\n</blockquote>\n<p>There's no guarantee on how that copy is made, extra allocations or reallocations are thus possible.</p>\n<hr>\n<p>As for</p>\n<blockquote>\n<p id=\"so_45934295_45934606_5\">Can I take that as a guarantee that these methods DO NOT do any\n  reallocation? Since the reallocation might throw <code>bad_alloc</code>.</p>\n</blockquote>\n<p>The standard does not seem to explicitly mention the possibility of a <code>bad_alloc</code> caused by any of the methods. Even with a binding <code>reserve</code> call there is no mention of it:</p>\n<blockquote>\n<p id=\"so_45934295_45934606_6\"><code>void reserve(size_type res_arg=0);</code></p>\n<p id=\"so_45934295_45934606_7\"><strong>Throws: <code>length_\u00aderror</code> if <code>res_\u00adarg &gt; max_\u00adsize()</code></strong></p>\n</blockquote>\n<p>Thus I don't think that assumption can be made.</p>\n</hr>", "LastEditorUserId": "1870760", "LastActivityDate": "2017-08-29T08:57:07.530", "Score": "3", "CreationDate": "2017-08-29T08:50:04.737", "ParentId": "45934295", "CommentCount": "3", "OwnerUserId": "1870760", "LastEditDate": "2017-08-29T08:57:07.530"}, "45938929": {"Id": "45938929", "PostTypeId": "2", "Body": "<p>Yes, you may assume that the <em>Throws:</em> on these functions prohibits reallocation (which could throw <code>bad_alloc</code>).</p>\n<p><strong>20.5.5.12 Restrictions on exception handling [res.on.exception.handling]</strong></p>\n<blockquote>\n<p id=\"so_45934295_45938929_0\">Any of the functions defined in the C++ standard library can report a\n  failure by throwing an exception of a type described in its <em>Throws:</em>\n  paragraph, or of a type derived from a type named in the <em>Throws:</em>\n  paragraph that would be caught by an exception handler for the base\n  type.</p>\n</blockquote>\n<p>...</p>\n<blockquote>\n<p id=\"so_45934295_45938929_1\">Functions defined in the C++ standard library that do not have a\n  <em>Throws:</em> paragraph but do have a potentially- throwing exception specification may throw implementation-defined\n  exceptions.<sup>186</sup> Implementations should report errors by\n  throwing exceptions of or derived from the standard exception classes\n  (21.6.3.1, 21.8, 22.2).</p>\n</blockquote>\n<p>Note that the spec does not explicitly say that something marked with a \"<em>Throws:</em> Nothing.\" can't throw anything.  But at some point common sense has to take over.  The standard also doesn't explicitly state that these functions can't reformat your disk.  In general the standard specifies what the functions <em>can</em> do, and they are not allowed to do <em>anything</em> else.</p>\n<p>The only way a function throws an exception not listed in the <em>Throws:</em> spec (or a derived type) is if the client uses it in a way that invokes undefined behavior.</p>\n", "LastActivityDate": "2017-08-29T12:15:47.803", "CommentCount": "0", "CreationDate": "2017-08-29T12:15:47.803", "ParentId": "45934295", "Score": "2", "OwnerUserId": "576911"}, "45934613": {"Id": "45934613", "PostTypeId": "2", "Body": "<p>I think it's guaranteed, even the standard doesn't say that explicitly. Here's a description about the effect of <a href=\"http://eel.is/c++draft/basic.string#string.capacity-15\" rel=\"nofollow noreferrer\">reallocation</a> on <code>shrink_to_fit</code>:</p>\n<blockquote>\n<p id=\"so_45934295_45934613_0\">Remarks: Reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence as well as the past-the-end iterator. If no reallocation happens, they remain valid.</p>\n</blockquote>\n<p>If reallocation happends, all the iterators, pointers, references will be invalidated. But <code>erase</code> and <code>pop_back</code> don't mention that; that means they won't cause all of them to be invalidated, then reallocation won't happen.</p>\n", "LastActivityDate": "2017-08-29T08:50:22.073", "CommentCount": "0", "CreationDate": "2017-08-29T08:50:22.073", "ParentId": "45934295", "Score": "1", "OwnerUserId": "3309790"}, "bq_ids": {"n4140": {"so_45934295_45934606_1": {"length": 7, "quality": 0.875, "section_id": 1567}, "so_45934295_45934606_3": {"length": 9, "quality": 0.9, "section_id": 1706}, "so_45934295_45934606_0": {"length": 13, "quality": 1.0, "section_id": 1567}, "so_45934295_45934606_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 1567}, "so_45934295_45934606_4": {"length": 31, "quality": 0.96875, "section_id": 1707}, "so_45934295_45934613_0": {"length": 10, "quality": 0.5555555555555556, "section_id": 972}}, "n3337": {"so_45934295_45934606_1": {"length": 7, "quality": 0.875, "section_id": 1562}, "so_45934295_45934606_3": {"length": 9, "quality": 0.9, "section_id": 1703}, "so_45934295_45934606_0": {"length": 13, "quality": 1.0, "section_id": 1562}, "so_45934295_45934606_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 1562}, "so_45934295_45934606_4": {"length": 31, "quality": 0.96875, "section_id": 1704}, "so_45934295_45934613_0": {"length": 10, "quality": 0.5555555555555556, "section_id": 961}}, "n4659": {"so_45934295_45934606_1": {"length": 7, "quality": 0.875, "section_id": 1716}, "so_45934295_45938929_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 7869}, "so_45934295_45934606_3": {"length": 9, "quality": 0.9, "section_id": 1868}, "so_45934295_45938929_1": {"length": 19, "quality": 0.7037037037037037, "section_id": 7872}, "so_45934295_45934606_0": {"length": 13, "quality": 1.0, "section_id": 1716}, "so_45934295_45934606_2": {"length": 13, "quality": 1.0, "section_id": 1716}, "so_45934295_45934606_4": {"length": 31, "quality": 0.96875, "section_id": 1869}, "so_45934295_45934613_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 1038}}}, "45934295": {"ViewCount": "172", "Body": "<p>Does the standard guarantee that <code>string::erase</code> and <code>string::pop_back</code> DO <strong>NOT</strong> reallocate memory? After erasing some elements, is it possible that the <code>string</code> might be shrink automatically?</p>\n<p>I checked the standard, it says that <code>string::erase</code> and <code>string::pop_back</code> either throw <code>std::out_of_range</code> or throw nothing. Can I take that as a guarantee that these methods DO <strong>NOT</strong> do any reallocation? Since the reallocation might throw <code>bad_alloc</code>.</p>\n", "Title": "Does the standard guarantee that string::erase and string::pop_back DO NOT reallocate memory?", "CreationDate": "2017-08-29T08:32:45.963", "LastActivityDate": "2017-08-29T12:15:47.803", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "Id": "45934295", "Score": "7", "OwnerUserId": "5384363", "Tags": "<c++><string>", "AnswerCount": "4"}});