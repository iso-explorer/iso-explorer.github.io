post_cb({"14403946": {"CreationDate": "2013-01-18T17:05:50.930", "ViewCount": "195", "Id": "14403946", "AcceptedAnswerId": "14404900", "Score": "3", "Title": "adding parenthesis to a constructor call causes duplicate parameter error in xlc C++ compiler", "LastEditorUserId": "726361", "CommentCount": "10", "Body": "<p>We are creating a domain specific language that generates C++ code that must compile under gcc and also IBM xlc (version 10.1 for AIX) compilers.</p>\n<p>One specific code snippet generated C++ code that works perfectly well under gcc, but no so much under xlc. I have modified the code to the minimum case that still triggers the compile error:</p>\n<pre><code>//bug183.h\nclass emptyList\n{};\n\nextern emptyList weco;\n\nclass otherClass\n{\n        public:\n                otherClass();\n                otherClass(const int &amp; p);\n                otherClass(const emptyList &amp; e);\n                int geta() {return a;}\n        private:\n                int a;\n};\n\nclass someClass\n{\n        public:\n                someClass();\n                someClass(const someClass &amp; other);\n                someClass(const otherClass &amp; p1, const otherClass &amp; p2);\n                void exportState();\n\n        private:\n                otherClass oc1;\n                otherClass oc2;\n\n};\n\n//bug183.cpp\n#include \"bug183.h\"\n#include &lt;iostream&gt;\n\nemptyList weco = emptyList();\n\notherClass::otherClass() {a = 0;}\notherClass::otherClass(const int &amp; p) {a = p;}\notherClass::otherClass(const emptyList &amp; e) {a = 1000;}\n\nsomeClass::someClass() {oc1 = otherClass(); oc2 = otherClass();}\nsomeClass::someClass(const someClass &amp; other) {oc1 = other.oc1; oc2 = other.oc2;}\nsomeClass::someClass(const otherClass &amp; p1, const otherClass &amp; p2) {oc1 = p1; oc2 = p2;}\nvoid someClass::exportState() {std::cout &lt;&lt; oc1.geta() &lt;&lt; \" \" &lt;&lt; oc2.geta() &lt;&lt; std::endl;}\n\nint main()\n{\n        someClass dudi;\n        dudi.exportState();\n\n        //this line triggers the error in xlc\n        someClass nuni = (someClass(otherClass(weco), otherClass(weco)));\n        nuni.exportState();\n\n        return 0;\n}\n</code></pre>\n<p>Compiling this causes the following error to be raised:\n\"bug183.cpp\", line 21.66: 1540-0114 (S) A parameter name must not be the same as another parameter of this function.</p>\n<p>but if I remove the enclosing parenthesis on the constructor call like this:</p>\n<pre><code>someClass nuni = someClass(otherClass(weco), otherClass(weco));\n</code></pre>\n<p>The error goes away. Also, if I change <code>weco</code> for another extern variable created just as <code>weco</code> the error goes away even if I enclose the constructor in parenthesis, so it is safe to say that both conditions need to be present for this error to show up.</p>\n<p>Some of you may ask why don't we just remove the parenthesis then, but doing so <em>may</em> hurt parts of the code that are working correctly, so I'm inclined towards understanding if this behavior is expected from a C++ compiler or not or if at least there is a known workaround for it.</p>\n", "Tags": "<c++><parameters><constructor><parentheses><xlc>", "LastEditDate": "2013-01-18T17:09:46.443", "LastActivityDate": "2013-01-18T20:16:45.177", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "1991037"}, "bq_ids": {"n4140": {"so_14403946_14404900_1": {"length": 29, "quality": 0.90625, "section_id": 3202}}, "n3337": {"so_14403946_14404900_1": {"length": 29, "quality": 0.90625, "section_id": 3076}}}, "14404900": {"LastActivityDate": "2013-01-18T20:16:45.177", "CreationDate": "2013-01-18T18:04:51.933", "CommentCount": "1", "Body": "<p>I think that </p>\n<pre><code>(someClass(otherClass(weco), otherClass(weco)))\n</code></pre>\n<p>is being incorrectly parsed as the start of the second production of a <i>cast-expression</i>:</p>\n<blockquote>\n<p id=\"so_14403946_14404900_0\"><i>cast-expression:\n  <br>\u00a0unary-expression\n  <br>\u00a0</br></br></i><code>(</code><i> type-id </i><code>)</code><i> cast-expression</i></p>\n</blockquote>\n<p>Note \u00a7 8.2 paragraph 2 (emphasis added):</p>\n<blockquote>\n<p id=\"so_14403946_14404900_1\">The ambiguity arising from the similarity between a function-style cast and a <i>type-id</i> can occur in different contexts. The ambiguity appears as a choice between a function-style cast expression and a declaration of a type. The resolution is that <b>any construct that could possibly be a <i>type-id</i> in its syntactic context shall be considered a <i>type-id</i></b>.</p>\n</blockquote>\n<p>If you consider the full syntactic context of the <i>type-id</i> in <i>cast-expression</i>, it's not possible for <code>...</code> in <code>(..);</code> to match <code>type-id</code>, because the <i>cast-expression</i> following the <code>)</code> cannot be empty. However, if you only consider the one-token-lookahead context, where the <i>type-id</i> must be followed by <code>)</code>, it could be plausible that 8.2(2) applies. I'm not really inclined to believe that the intention of the standard was to only consider one-token lookahead, though.</p>\n<p><strong>EDIT</strong>\nReported as gcc bug <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=56037\" rel=\"nofollow\">50637</a>. You might want to submit a similar bug report to xlc.</p>\n<p>Since gcc 4.7.2 seems to flag the same error as xlc. I played around with gcc a bit, and convinced myself that the problem is that gcc flags the error in the <i>type-id</i> (i.e., two parameters with the same name) before it figures out that the parenthesized expression cannot be a <i>type-id</i>.</p>\n<p>Here's an example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\nstatic const int zero = 0;\nint main() {\n  // Consistent with 8.2[2]\n  // Example 1. Invalid cast.\n  // Here, 'int(int(zero))' is a type-id, so the compiler must take\n  // the expression to be a cast of '+3' to a function.\n  std::cout &lt;&lt; (int(int(zero))) + 3 &lt;&lt; std::endl;\n  // Example 2: No error.\n  // The parenthesized expression cannot be a type-id in this context\n  std::cout &lt;&lt; (int(int(zero))) &lt;&lt; std::endl;\n  // Example 3: Syntax error: zero redefined.\n  // Here the parenthesized expression could be a type-id, so it must\n  // be parsed as one, even though the type-id is invalid.\n  std::cout &lt;&lt; (std::pair&lt;int,int&gt;(int(zero), int(zero))) + 3 &lt;&lt; std::endl;\n\n  // Apparently not consistent with 8.2[2]\n  // Here the parenthesized expression can't be a type-id, as in example 2.\n  // However, the type-id triggers a syntax error, presumably before gcc\n  // figures out that it's not a cast-expression.\n  std::cout &lt;&lt; (std::pair&lt;int,int&gt;(int(zero), int(zero))) &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>\n<p>See it <a href=\"http://liveworkspace.org/code/zZ0I9%240\" rel=\"nofollow\">on lws</a>. (Toggle between gcc and clang to see the difference.)</p>\n<p>Based on the above analysis that the problem is premature triggering of a type-error, here's one possible workaround:</p>\n<p>1) Add an alias for weco:</p>\n<pre><code>emptyList&amp; weco_alias = weco;\n</code></pre>\n<p>2) Use one of each:</p>\n<pre><code>someClass nuni = (someClass(otherClass(weco), otherClass(weco_alias)));\n</code></pre>\n<p>This works on both gcc 4.7.2 and clang 3.2 (<a href=\"http://liveworkspace.org/code/40Swp1%240\" rel=\"nofollow\">lws</a>).</p>\n", "Id": "14404900", "LastEditDate": "2013-01-18T20:16:45.177", "ParentId": "14403946", "OwnerUserId": "1566221", "PostTypeId": "2", "Score": "2", "LastEditorUserId": "1566221"}});