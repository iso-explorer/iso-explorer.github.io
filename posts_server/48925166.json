post_cb({"bq_ids": {"n4140": {"so_48925166_48925937_0": {"length": 68, "quality": 0.8717948717948718, "section_id": 7194}}, "n3337": {"so_48925166_48925937_0": {"length": 66, "quality": 0.8461538461538461, "section_id": 6938}}, "n4659": {"so_48925166_48925937_0": {"length": 71, "quality": 0.9102564102564102, "section_id": 8703}}}, "48925937": {"Id": "48925937", "PostTypeId": "2", "Body": "<p>Yes it is perfectly legal to pass around references to objects that were not constructed yet, and even use such references in certain limited ways.</p>\n<blockquote>\n<p id=\"so_48925166_48925937_0\">[basic.life] ... Similarly, before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any glvalue that refers to the original object may be used but only in limited ways. For an object under construction or destruction, see [class.cdtor]. Otherwise, such a glvalue refers to allocated storage ([basic.stc.dynamic.allocation]), and using the properties of the glvalue that do not depend on its value is well-defined. The program has undefined behavior if:<br>\n  (7.1) the glvalue is used to access the object, or<br>\n  (7.2) the glvalue is used to call a non-static member function of the object, or<br>\n  (7.3) the glvalue is bound to a reference to a virtual base class ([dcl.init.ref]), or<br>\n  (7.4) the glvalue is used as the operand of a <code>dynamic_\u00adcast</code> ([expr.dynamic.cast]) or as the operand of <code>typeid</code>.</br></br></br></br></p>\n</blockquote>\n<p>As long as you are not doing anything of the above, you are in the clear.</p>\n", "LastActivityDate": "2018-02-22T11:09:48.373", "Score": "10", "CreationDate": "2018-02-22T11:09:48.373", "ParentId": "48925166", "CommentCount": "0", "OwnerUserId": "775806"}, "48925166": {"ViewCount": "313", "Body": "<p>Before explaining the question i want to mark that i know that given example is bad code. I am already looking at <code>std::shared_ptr</code> to achieve my goal in more reasonable way. Reason for this post is just my curiosity and desire to learn new stuff. Thank You in advance for help!</p>\n<p>I was today a little messing with my parser code. Optimalization stuff etc. I focused on few instances of object that where unnecesarly cloned all the way throught parsing. I had not-so-deliberate idea to create few global instances and access them by static method. Anyway (strongly simplifing) i ended with this somewhat interesting case:</p>\n<pre><code>class class_a\n{\n    class_a();\n    class_a&amp; referenceToObject;\n};\n\nclass_a&amp; getGlobalObject();\n\nclass_a::class_a()\n:referenceToObject(getGlobalObject())\n{}\n\nclass_a object;\nclass_a object2;\n\nclass_a&amp; getGlobalObject()\n{\n    return object2;\n}\n</code></pre>\n<p>This obviously means that i did quite a few things very wrong, but at this branch, optimization is the most important matter.</p>\n<p>I am interested what would happen in code like this in wider collection of compilers. <code>GetGlobalObject()</code> is returning reference to object that hadn't it's constructor called. Still it's returning only the reference - that is pointer to space on memory (somewhere on data segment or heap, dunno) known at compile time.</p>\n<p>Assuming that nothing will call any method nor any member of <code>object2</code> reference, is this example undefined behavior?</p>\n", "AcceptedAnswerId": "48925937", "Title": "Reference to uninitialized object", "CreationDate": "2018-02-22T10:33:42.093", "LastActivityDate": "2018-02-22T11:09:48.373", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-02-22T11:05:31.607", "LastEditorUserId": "1594913", "Id": "48925166", "Score": "9", "OwnerUserId": "8745829", "Tags": "<c++><reference><initialization><language-lawyer>", "AnswerCount": "1"}});