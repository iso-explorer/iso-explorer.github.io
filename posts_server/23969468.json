post_cb({"bq_ids": {"n4140": {"so_23969468_23969583_1": {"length": 7, "quality": 1.0, "section_id": 3945}}, "n3337": {"so_23969468_23969583_1": {"length": 7, "quality": 1.0, "section_id": 3804}}, "n4659": {"so_23969468_23969583_1": {"length": 7, "quality": 1.0, "section_id": 4833}}}, "23970230": {"Id": "23970230", "PostTypeId": "2", "Body": "<p>I'm expanding a bit on the problem you've pointed out here.</p>\n<p>Your version would introduce a <strong>reference-dangling</strong> case if you attempt to bind a newly created rvalue to a l-value reference. </p>\n<p>As Mankarse linked, the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2951.html\" rel=\"nofollow\">n2951</a> paper cites this case and, by simplifying it a bit, you can summarize it with the following code</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;typename T, typename U&gt;\nT&amp;&amp; Forward(U&amp;&amp; arg) {\n  return static_cast&lt;T&amp;&amp;&gt;(arg);\n}\n\nclass Container\n{\n    int data_;\npublic:\n    explicit Container(int data = 1) // Set the data variable\n        : data_(data) {}\n    ~Container() {data_ = -1;} // When destructed, first set the data to -1\n\n    void test()\n    {\n        if (data_ &lt;= 0)\n            std::cout &lt;&lt; \"OPS! A is destructed!\\n\";\n        else\n            std::cout &lt;&lt; \"A = \" &lt;&lt; data_ &lt;&lt; '\\n';\n    }\n};\n\n// This class has a reference to the data object\nclass Reference_To_Container_Wrapper\n{\n    const Container&amp; a_;\npublic:\n    explicit Reference_To_Container_Wrapper(const Container&amp; a) : a_(a) {}\n\n    // (I) This line causes problems! This \"Container\" returned will be destroyed and cause troubles!\n    const Container get() const {return a_;} // Build a new Container out of the reference and return it\n};\n\ntemplate &lt;class T&gt;\nstruct ReferenceContainer\n{\n    T should_be_valid_lvalue_ref; \n\n    template &lt;class U&gt; // U = Reference_To_Container_Wrapper\n        ReferenceContainer(U&amp;&amp; u) : \n         // We store a l-value reference to a container, but the container is from line (I)\n         // and thus will soon get destroyed and we'll have a dangling reference\n         should_be_valid_lvalue_ref(Forward&lt;T&gt;(std::move(u).get())) {}\n};\n\nint main() {\n\n    Container a(42); // This lives happily with perfect valid data\n    ReferenceContainer&lt;const Container&amp;&gt; rc( (Reference_To_Container_Wrapper(a)) ); // Parenthesis necessary otherwise most vexing parse will think this is a function pointer..\n    // rc now has a dangling reference\n    Container newContainer = rc.should_be_valid_lvalue_ref; // From reference to Container\n    newContainer.test();\n\n    return 0;\n}\n</code></pre>\n<p>which outputs \"OPS! A is destructed!\"</p>\n<p>if you just add a \"&amp;\" in the line</p>\n<pre><code>const Container&amp; get() const {return a_;}\n</code></pre>\n<p>the above works just fine.</p>\n<p><a href=\"http://ideone.com/SyUXss\" rel=\"nofollow\">http://ideone.com/SyUXss</a></p>\n", "LastActivityDate": "2014-05-31T12:43:55.223", "CommentCount": "3", "CreationDate": "2014-05-31T12:43:55.223", "ParentId": "23969468", "Score": "3", "OwnerUserId": "1938163"}, "23969468": {"ViewCount": "162", "Body": "<p>The implementation of <code>std::forward</code> in VS2013 is</p>\n<pre><code>template&lt;class _Ty&gt; inline\n    _Ty&amp;&amp; forward(typename remove_reference&lt;_Ty&gt;::type&amp; _Arg)\n    {   // forward an lvalue\n    return (static_cast&lt;_Ty&amp;&amp;&gt;(_Arg));\n    }\n\ntemplate&lt;class _Ty&gt; inline\n    _Ty&amp;&amp; forward(typename remove_reference&lt;_Ty&gt;::type&amp;&amp; _Arg) _NOEXCEPT\n    {   // forward anything\n    static_assert(!is_lvalue_reference&lt;_Ty&gt;::value, \"bad forward call\");\n    return (static_cast&lt;_Ty&amp;&amp;&gt;(_Arg));\n    }\n</code></pre>\n<p>One version for lvalue reference, one version for rvalue reference. Why not just use a universal reference for both rvalue and lvalue reference:</p>\n<pre><code>template &lt;typename T, typename U&gt;\nT&amp;&amp; Forward(U&amp;&amp; arg) {\n  return static_cast&lt;T&amp;&amp;&gt;(arg);\n}\n</code></pre>\n", "Title": "Implement a forward function using universal reference", "CreationDate": "2014-05-31T11:23:30.547", "LastActivityDate": "2014-05-31T12:43:55.223", "CommentCount": "1", "PostTypeId": "1", "Id": "23969468", "Score": "3", "OwnerUserId": "2134183", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "23969583": {"Id": "23969583", "PostTypeId": "2", "Body": "<p>Your version is not standard-compliant, as <code>std::forward</code> is is required to not compile when called with on an rvalue if <code>T</code> is an l-value reference. From <code>[forward]</code>:</p>\n<pre><code>template &lt;class T&gt; T&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp; t) noexcept;\ntemplate &lt;class T&gt; T&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp;&amp; t) noexcept;\n</code></pre>\n<blockquote>\n<p id=\"so_23969468_23969583_0\">2 Returns: <code>static_cast&lt;T&amp;&amp;&gt;(t)</code>.</p>\n<p id=\"so_23969468_23969583_1\">3 if the second form is instantiated with an lvalue reference type, the program is ill-formed.</p>\n</blockquote>\n<p><code>std::forward</code> is defined in this way to ensure that (some) misuses of <code>std::forward</code> do not compile. See <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2951.html\" rel=\"nofollow\">n2951</a> for more discussion (although even n2951 does not use this exact form).</p>\n", "LastActivityDate": "2014-05-31T11:35:34.297", "CommentCount": "3", "CreationDate": "2014-05-31T11:35:34.297", "ParentId": "23969468", "Score": "4", "OwnerUserId": "485561"}});