post_cb({"19541597": {"Id": "19541597", "PostTypeId": "2", "Body": "<p>Because <code>T</code> on it's own already has a well defined meaning: the <em>type</em> <code>Class T</code>.  So things like <code>T::b</code> are logically used to mean <em>members</em> of <code>Class T</code>.  To get the address of these members we need more syntax, namely <code>&amp;T::b</code>.  These factors don't come into play with free functions and arrays.</p>\n", "LastActivityDate": "2013-10-23T12:24:19.537", "CommentCount": "0", "CreationDate": "2013-10-23T12:24:19.537", "ParentId": "19541426", "Score": "0", "OwnerUserId": "1312406"}, "19541773": {"Id": "19541773", "PostTypeId": "2", "Body": "<p>The first thing to note is that arrays decay into pointers to the first element.</p>\n<pre><code>int T::*pA = T::b;\n</code></pre>\n<p>There are two issues here, or maybe one, or more than two... The first is the subexpression <code>T::b</code>. The <code>b</code> member variable is not static, and cannot be accessed with that syntax. For pointer to members you need to always use the address-of operator:</p>\n<pre><code>int T::*pa = &amp;T::b;  // still wrong\n</code></pre>\n<p>Now the problem is that the right hand side has type <code>int (T::*)[10]</code> that does not match the left hand side, and that will fail to compile. If you fix the type on the left you get:</p>\n<pre><code>int (T::*pa)[10] = &amp;T::b;\n</code></pre>\n<p>Which is correct. The confusion might have risen by the fact that arrays tend to decay to the first element, so maybe the issue was with the previous expression: <code>int *p = a;</code> which is transformed by the compiler into the more explicit <code>int *p = &amp;a[0];</code>. Arrays and functions have a tendency to decay, but no other element in the language does. And <code>T::b</code> is <em>not</em> an array.</p>\n<hr>\n<p>Edit: I skipped the part about functions... </p>\n<pre><code>   void (*pF)() = fun;        //here also everything is clear\n   void (T::*pF)() = T::fun; \n   //or\n   void (T::*pF)() = &amp;T::fun;\n</code></pre>\n<p>It might not be as clear as it seems. The statement <code>void (T::*pf)() = T::fun;</code> is illegal in C++, the compiler you use is accepting it for no good reason. The correct code is the last one: <code>void (T::*pf)() = &amp;T::fun;</code>.</p>\n</hr>", "LastEditorUserId": "36565", "LastActivityDate": "2013-10-23T12:40:31.160", "Score": "2", "CreationDate": "2013-10-23T12:31:34.750", "ParentId": "19541426", "CommentCount": "0", "OwnerUserId": "36565", "LastEditDate": "2013-10-23T12:40:31.160"}, "19541708": {"Id": "19541708", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_19541426_19541708_0\">Why \"&amp;\" is needed for \"T::b\" ?</p>\n</blockquote>\n<p>Because the standard requires it. This is to distinguish it from accessing a static class member.</p>\n<p>From a standard draft <code>n3337</code>, paragraph 5.3.1/4, emphasis mine:</p>\n<blockquote>\n<p id=\"so_19541426_19541708_1\"><strong>A pointer to member is only formed when an explicit <code>&amp;</code> is used and its operand is a  <em>quali\ufb01ed-id</em> not enclosed\n  in parentheses.</strong> [<em>Note:</em> that is, the expression <code>&amp;(qualified-id)</code>, where the <em>quali\ufb01ed-id</em> is enclosed in\n  parentheses, does not form an expression of type \u201cpointer to member.\u201d Neither does <code>qualified-id</code>, because\n  there is no implicit conversion from a <em>quali\ufb01ed-id</em> for a non-static member function to the type \u201cpointer to\n  member function\u201d as there is from an lvalue of function type to the type \u201cpointer to function\u201d (4.3). Nor is\n  <code>&amp;unqualified-id</code> a pointer to member, even within the scope of the <em>unquali\ufb01ed-id</em>\u2019s class. \u2014 <em>end note</em>]</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_19541426_19541708_2\">For \"standard\" pointer an array name is the representation of the address of the first element of the array. </p>\n</blockquote>\n<p>Not really. An array automatically <em>converts</em> to a pointer to first element, where required. The name of an array is an array, period.  </p>\n<hr>\n<blockquote>\n<p id=\"so_19541426_19541708_3\">Why \"&amp;\" is not needed for the pointer to member function ?</p>\n</blockquote>\n<p>It <strong>is</strong> needed. If your compiler allows it, it's got a bug. See the standardese above.</p>\n<hr>\n<blockquote>\n<p id=\"so_19541426_19541708_4\">For \"standard\" pointer a function name is the representation of the function address, so we can write &amp;funName or just funName when assigning to the pointer. </p>\n</blockquote>\n<p>The same thing aplies here as for arrays. There's an automatic conversion but otherwise a function has got a function type.</p>\n<p>Consider:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T, size_t N&gt;\nvoid foo(T (&amp;)[N]) { std::cout &lt;&lt; \"array\\n\"; }\n\ntemplate&lt;typename T&gt;\nvoid foo(T*) { std::cout &lt;&lt; \"pointer\\n\"; }\n\nint main()\n{\n    int a[5];\n    foo(a);\n}\n</code></pre>\n<p>Output is <code>array</code>.</p>\n<p>Likewise for functions pointers:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nstruct X;\n\ntemplate&lt;typename T, typename U&gt;\nstruct X&lt;T(U)&gt; {\n    void foo() { std::cout &lt;&lt; \"function\\n\"; }\n};\n\ntemplate&lt;typename T, typename U&gt;\nstruct X&lt;T(*)(U)&gt; {\n    void foo() { std::cout &lt;&lt; \"function pointer\\n\"; }\n};\n\nvoid bar(int) {}\n\nint main()\n{\n    X&lt;decltype(bar)&gt; x;\n    x.foo();\n}\n</code></pre>\n<p>Output is <code>function</code>.</p>\n<hr>\n<p>And a clarification about this, because I'm not sure what exactly your comment is meant to say:</p>\n<pre><code>int arrArr[10][10];\nint (*pAA)[10] = arrArr; // Here a pointer is set to the array of arrays not to the array.\n</code></pre>\n<p>Again, array-to-pointer conversion. Note that the elements of <code>arrArr</code> are <code>int[10]</code>s. <code>pAA</code> points to the first element of <code>arrArr</code> which is an array of 10 ints located at <code>&amp;arrArr[0]</code>. If you increment <code>pAA</code> it'll be equal to <code>&amp;arrArr[1]</code> (so naming it <code>pA</code> would be more appropriate).</p>\n<p>If you wanted a pointer to <code>arrArr</code> as a whole, you need to say:</p>\n<pre><code>int (*pAA)[10][10] = &amp;arrArr;\n</code></pre>\n<p>Incrementing <code>pAA</code> will now take you just past the end of <code>arrArr</code>, that's 100 ints away.</p>\n</hr></hr></hr></hr>", "LastEditorUserId": "947836", "LastActivityDate": "2013-10-23T15:18:04.073", "Score": "5", "CreationDate": "2013-10-23T12:28:37.363", "ParentId": "19541426", "CommentCount": "0", "OwnerUserId": "947836", "LastEditDate": "2013-10-23T15:18:04.073"}, "19541426": {"ViewCount": "1824", "Body": "<p>I'm trying to understand how \"pointer to member\" works but not everything is clear for me.</p>\n<p>Here is an example class:</p>\n<pre><code>class T\n{\npublic:\n    int a;\n    int b[10]; \n    void fun(){}\n};\n</code></pre>\n<p>The following code ilustrate the problem and contains questions:</p>\n<pre><code>void fun(){};\n\nvoid main()\n{\n   T obj;                \n   int local;\n   int arr[10];\n   int arrArr[10][10];\n\n   int *p = &amp;local;   // \"standard\" pointer\n   int T::*p = &amp;T::a; // \"pointer to member\" + \"T::\" , that is clear\n\n   void (*pF)() = fun;        //here also everything is clear\n   void (T::*pF)() = T::fun;  \n   //or\n   void (T::*pF)() = &amp;T::fun;  \n\n   int *pA = arr; // ok\n   int T::*pA = T::b; // error\n\n   int (T::*pA)[10] = T::b; // error\n   int (T::*pA)[10] = &amp;T::b; //works;\n\n//1. Why \"&amp;\" is needed for \"T::b\" ? For \"standard\" pointer an array name is the representation of the \n//   address of the first element of the array. \n\n//2. Why \"&amp;\" is not needed for the pointer to member function ? For \"standard\" pointer a function name \n//   is the representation of the function address, so we can write &amp;funName or just funName when assigning to the pointer. \n//   That's rule works there.\n\n//3. Why the above pointer declaration looks like the following pointer declaration ?: \n\n   int (*pAA)[10] = arrArr; // Here a pointer is set to the array of arrays not to the array. \n   system(\"pause\");\n}\n</code></pre>\n", "AcceptedAnswerId": "19544165", "Title": "Trying to understand \"pointer to member\"", "CreationDate": "2013-10-23T12:16:18.080", "Id": "19541426", "CommentCount": "2", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2013-10-24T15:25:21.427", "Score": "14", "OwnerUserId": "1371057", "Tags": "<c++>", "AnswerCount": "8"}, "bq_ids": {"n4140": {"so_19541426_19541708_1": {"length": 47, "quality": 0.8392857142857143, "section_id": 6067}, "so_19541426_19541708_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 6325}, "so_19541426_19541904_1": {"length": 6, "quality": 0.6666666666666666, "section_id": 6325}}, "n3337": {"so_19541426_19541708_1": {"length": 47, "quality": 0.8392857142857143, "section_id": 5835}, "so_19541426_19541708_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 6082}, "so_19541426_19541904_1": {"length": 6, "quality": 0.6666666666666666, "section_id": 6082}}, "n4659": {"so_19541426_19541708_1": {"length": 47, "quality": 0.8392857142857143, "section_id": 7563}, "so_19541426_19541708_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 7835}, "so_19541426_19541904_1": {"length": 6, "quality": 0.6666666666666666, "section_id": 7835}}}, "19544165": {"Id": "19544165", "PostTypeId": "2", "Body": "<p>I think the simplest thing is to forget about the class members for a moment, and recap pointers and decay.</p>\n<pre><code>int local;\nint array[10];\n\nint *p = &amp;local; // \"standard\" pointer to int\n</code></pre>\n<p>There is a tendency for people to say that a \"decayed pointer\" is the same as a pointer to the array.  But there is an important difference between <code>arr</code> and <code>&amp;arr</code>.  The former does not decay into the latter</p>\n<pre><code>int (*p_array_standard)[10] = &amp;arr;\n</code></pre>\n<p>If you do <code>&amp;arr</code>, you get a pointer to an array-of-10-ints.  This is different from a pointer to an array-of-9-ints.  And it's different from a pointer-to-int.  <code>sizeof(*p_array_standard) == 10 * sizeof(int)</code>.</p>\n<p>If you want a pointer to the first element, i.e. a pointer to an <code>int</code>, with <code>sizeof(*p) == sizeof(int))</code>, then you can do:</p>\n<pre><code>int *p_standard = &amp;(arr[0);\n</code></pre>\n<p>Everything so far is based on standard/explicit pointers.</p>\n<p>There is a special rule in C which allows you to replace <code>&amp;(arr[0])</code> with <code>arr</code>.  You can initialize an <code>int*</code> with <code>&amp;(arr[0])</code> or with <code>arr</code>.  But if you actually want a pointer-to-array, you must do <code>int (*p_array_standard)[10] = &amp;arr;</code></p>\n<p>I think the decaying could almost be dismissed as a piece of syntactic sugar.  The decaying doesn't change the meaning of any existing code.  It simply allows code that would otherwise be illegal to become legal.</p>\n<pre><code>int *p = arr; // assigning a pointer with an array.  Why should that work?\n                  // It works, but only because of a special dispensation.\n</code></pre>\n<p>When an array decays, it decays to a pointer to a single element <code>int [10]</code> -&gt; <code>int*</code>.  It does not decay to a pointer to the array, that would be <code>int (*p)[10]</code>.</p>\n<hr>\n<p>Now, we can look at this line from your question:</p>\n<pre><code>int (T::*pA3)[10] = T::b; // error\n</code></pre>\n<p>Again, the class member is not relevant to understanding why this failed.  The type on the left is a pointer-to-array-of-ints, not a pointer-to-int.  Therefore, as we said earlier, decaying is not relevant and you need <code>&amp;</code> to get the pointer-to-array-of-ints type.</p>\n<p>A better question would be to ask why this doesn't work  (<em>Update: I see now that you did have this in your question.</em>)</p>\n<pre><code>int T::*pA3 = T::b;\n</code></pre>\n<p>The right hand side looks like an array, and the left hand side is a pointer to a single element <code>int *</code>, and therefore you could reasonably ask: Why doesn't decay work here?</p>\n<p>To understand why decay is difficult here, let's \"undo\" the syntactic sugar, and replace <code>T::b</code> with <code>&amp;(T::b[0])</code>.</p>\n<pre><code>int T::*pA3 = &amp;(T::b[0]);\n</code></pre>\n<p>I think this is the question that you're interested in.  We've removed the decaying in order to focus on the real issue.  This line works with non-member objects, why doesn't it work with member objects?</p>\n<p>The simple answer is that the standard doesn't require it.  Pointer-decay is a piece of syntactic sugar, and they simply didn't specify that it must work in cases like this.</p>\n<p>Pointers-to-members are basically a little fussier than other pointers.  They must point directly at the 'raw' entity as it appears in the object.\n(<em>Sorry, I mean it should refer (indirectly) by encoding the offset between the start of the class and the location of this member. But I'm not very good at explaining this.</em>)\nThey can't point to sub-objects, such as the first element of the array, or indeed the second element of the array.</p>\n<p><strike>Q: Now I have a question of my own.  Could pointer decay be extended to work on member arrays like this?  I think it makes some sense.</strike>  I'm not the only one to think of this!  See <a href=\"https://stackoverflow.com/a/1929950/146041\">this discussion</a> for more.  It's possible, and I guess there's nothing stopping a compiler from implementing it as an extension.  Subobjects, including array members, are at a fixed offset from the start of the class, so this is pretty logical.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-10-23T17:06:05.113", "Score": "3", "CreationDate": "2013-10-23T14:12:29.823", "ParentId": "19541426", "CommentCount": "2", "OwnerUserId": "146041", "LastEditDate": "2017-05-23T10:28:41.623"}, "19541809": {"Id": "19541809", "PostTypeId": "2", "Body": "<p>A pointer to a class or struct type points to an object in memory.<br>\nA pointer to a member of a class type actually points to an offset from the start of the object.<br>\nYou can think of these kind of pointers as pointers to blocks of memory. These need an actual address and offset, hence the <code>&amp;</code>.</br></br></p>\n<p>A pointer to function points to the access point of the function in the assembly code. A member method in general is the same as a function that passes a <code>this</code> pointer as the first argument.</p>\n<p>That's in crude nut shell the logic behind needing a <code>&amp;</code> to get the address for members and object address in general.</p>\n", "LastActivityDate": "2013-10-23T12:33:03.863", "CommentCount": "1", "CreationDate": "2013-10-23T12:33:03.863", "ParentId": "19541426", "Score": "0", "OwnerUserId": "536086"}, "19541904": {"Id": "19541904", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_19541426_19541904_0\">Why \"&amp;\" is needed for \"T::b\" ?</p>\n</blockquote>\n<p>Because that's how the language is specified. It was decided not to complicate the language with a member-to-pointer conversion just for the sake of saving a single character even though, for historical reasons, we have similar conversions for arrays and functions.</p>\n<blockquote>\n<p id=\"so_19541426_19541904_1\">For \"standard\" pointer an array name is the representation of the address of the first element of the array. </p>\n</blockquote>\n<p>No it isn't; it's convertible to a pointer to its first element due to an arcane conversion rule inherited from C. Unfortunately, that's given rise to a widespread (and wrong) belief that an array is a pointer. This kind of confusion is probably part of the reason for not introducing similar bizarre conversions for member pointers.</p>\n<blockquote>\n<p id=\"so_19541426_19541904_2\">Why \"&amp;\" is not needed for the pointer to member function ?</p>\n</blockquote>\n<p>It is. However, your compiler accepts the incorrect <code>void main()</code>, so it may accept other broken code.</p>\n<blockquote>\n<p id=\"so_19541426_19541904_3\">For \"standard\" pointer a function name is the representation of the function address, so we can write &amp;funName or just funName when assigning to the pointer.</p>\n</blockquote>\n<p>Again, the function name isn't a pointer; it's just convertible to one.</p>\n<blockquote>\n<p id=\"so_19541426_19541904_4\">Why the above pointer declaration looks like the following pointer declaration ?</p>\n</blockquote>\n<p>One is a pointer to an array, the other is a pointer to a member array. They are quite similar, and so look quite similar, apart from the difference which indicates that one's a member pointer and the other's a normal pointer.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2013-10-24T15:25:21.427", "Score": "1", "CreationDate": "2013-10-23T12:36:48.567", "ParentId": "19541426", "CommentCount": "0", "OwnerUserId": "204847", "LastEditDate": "2013-10-24T15:25:21.427"}, "19541807": {"Id": "19541807", "PostTypeId": "2", "Body": "<pre><code>void (*pF)() = fun;        //here also everything is clear\n</code></pre>\n<p>It doesn't work because function fun is undefined</p>\n<pre><code>int T::*pA = T::b; // error\n</code></pre>\n<p>What is T::b? T::b is not static member. So you need specific object. Instead write</p>\n<pre><code>int *pA = &amp;obj.b[0]; \n</code></pre>\n<p>Similarly,</p>\n<pre><code>int (T::*pA)[10] = &amp;T::b; //works;\n</code></pre>\n<p>It can be compiled. But it will not work as you expected. Make b static or call obj.b to get access to defined member of defined object. We can easily check this. Create conctructor for your class T </p>\n<pre><code>class T\n{\npublic:\n    T() {\n        a = 444;\n    }\n    int a;\n    int b[10]; \n    void fun(){}\n};\n</code></pre>\n<p>On what value points pA ? </p>\n<pre><code> int T::*pA = &amp;T::a; \n</code></pre>\n<p>*pA doesn't not point on variable with value 444, because no object has been created, no constructor has been called.</p>\n", "LastEditorUserId": "2471790", "LastActivityDate": "2013-10-23T12:47:26.443", "Score": "-1", "CreationDate": "2013-10-23T12:32:56.923", "ParentId": "19541426", "CommentCount": "4", "OwnerUserId": "2471790", "LastEditDate": "2013-10-23T12:47:26.443"}, "19542399": {"Id": "19542399", "PostTypeId": "2", "Body": "<pre><code>int (T::*pA)[10] = &amp;T::b; //works;\n\n3.Why the above pointer declaration looks like the following pointer declaration ?\n\nint (*pAA)[10] = arrArr;\n</code></pre>\n<p>To understand this, we needn't confuse ourselves with member arrays, simple arrays are good enough. Say've we two</p>\n<pre><code>int a[5];\nint a_of_a[10][5];\n</code></pre>\n<p>The first (left-most) dimension of the array decays and we get a pointer to the first element of the array, when we use just the array's name. E.g.</p>\n<pre><code>int *pa = a;                 // first element is an int for \"a\"\nint (*pa_of_a)[5] = a_of_a;  // first element is an array of 5 ints for \"a_of_a\"\n</code></pre>\n<p>So without using <code>&amp;</code> operator on the array, when we assign its name to pointers, or pass it to function as arguments, it decays as explained and gives a pointer to its first element. However, when we use the <code>&amp;</code> operator, the decay doesn't happen since we're asking for the address of the array and not using the array name as-is. Thus the pointer we get would be to the actual type of the array <em>without</em> any decay. E.g.</p>\n<pre><code>int (*paa) [5] = &amp;a;                   // note the '&amp;'\nint (*paa_of_a) [10][5] = &amp;a_of_a;\n</code></pre>\n<p>Now in your question the upper declaration is a pointer to an array's address without the decay (one dimension stays one dimension), while the lower declaration is a pointer to an array name with decay (two dimensions become one dimension). Thus both the pointers are to an array of same single dimension and look the same. In our example</p>\n<pre><code>int (*pa_of_a)[5]\nint (*paa) [5]\n</code></pre>\n<p>notice that the types of these pointers are the same <code>int (*) [5]</code> although the value they point to are of different array's.</p>\n", "LastEditorUserId": "183120", "LastActivityDate": "2013-10-23T13:22:08.207", "Score": "1", "CreationDate": "2013-10-23T13:00:11.137", "ParentId": "19541426", "CommentCount": "0", "OwnerUserId": "183120", "LastEditDate": "2013-10-23T13:22:08.207"}});