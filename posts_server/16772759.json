post_cb({"16772759": {"CommentCount": "4", "ViewCount": "579", "CreationDate": "2013-05-27T11:59:54.870", "LastActivityDate": "2013-05-27T12:47:26.367", "Title": "how to disambiguate namespace and class with identical names", "AcceptedAnswerId": "16772837", "PostTypeId": "1", "Id": "16772759", "Score": "2", "Body": "<p>consider the following code:</p>\n<pre><code>struct foo {\n    typedef int bar;\n};\n\nnamespace foo {\n    class baz {\n        /* code */\n    };\n}\n</code></pre>\n<p>This is spread over a codebase that I have to work on, and it kind of works sometimes and I don't understand how.</p>\n<p>As long as the namespace and the class don't occur in the same source (after preprocessing) it will work (I understand that part). However if suddenly both the namespace and the class are dragged into the same compilation unit by the preprocessor it (might) clash (I don't know if this ever occurs in the source).</p>\n<p>Is there a convention that allows the compiler to always resolve code structures as those correctly? The most logical would be the forbid by namespaces and classes to have same symbols. The applied coding style allows clashing namespaces with classes albeit the ambiguity thus I would prefer a way to tell the compiler on usage instead of changing the coding convention.</p>\n<p>something like:</p>\n<pre><code>use_namespace(foo)::baz b; \nuse_class(foo) b;\n</code></pre>\n", "Tags": "<c++><c++11>", "OwnerUserId": "887836", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_16772759_16773096_1": {"section_id": 7047, "quality": 1.0, "length": 16}, "so_16772759_16772837_0": {"section_id": 5474, "quality": 0.9047619047619048, "length": 19}, "so_16772759_16772837_2": {"section_id": 5489, "quality": 1.0, "length": 27}}, "n3337": {"so_16772759_16773096_1": {"section_id": 6792, "quality": 1.0, "length": 16}, "so_16772759_16772837_0": {"section_id": 5260, "quality": 0.9047619047619048, "length": 19}, "so_16772759_16772837_2": {"section_id": 5275, "quality": 1.0, "length": 27}}, "n4659": {"so_16772759_16773096_1": {"section_id": 8544, "quality": 1.0, "length": 16}}}, "16773096": {"ParentId": "16772759", "CommentCount": "0", "CreationDate": "2013-05-27T12:20:08.403", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "16773096", "Score": "2", "Body": "<blockquote>\n<p id=\"so_16772759_16773096_0\">As long as the namespace and the class don't occur in the same source (after preprocessing) it will work (I understand that part).</p>\n</blockquote>\n<p>No it doesn't. Declaring the same name for two different entities gives undefined behaviour according to C++11 3.3.1/4:</p>\n<blockquote>\n<p id=\"so_16772759_16773096_1\">Given a set of declarations in a single declarative region, each of which specifies the same unqualified name, <strong>they shall all refer to the same entity</strong></p>\n</blockquote>\n<p>(with some exceptions which do not include giving a class and a namespace the same name).</p>\n<p>Since the declarations are in separate translation units, many compilers can't diagnose the error, so it might appear to work.</p>\n<blockquote>\n<p id=\"so_16772759_16773096_2\">However if suddenly both the namespace and the class are dragged into the same compilation unit by the preprocessor it (might) clash (I don't know if this ever occurs in the source).</p>\n</blockquote>\n<p>Now that they are in the same translation unit, the error can be diagnosed.</p>\n", "LastActivityDate": "2013-05-27T12:20:08.403"}, "16772837": {"ParentId": "16772759", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2013-05-27T12:04:39.140", "Score": "10", "LastEditorUserId": "1932150", "LastEditDate": "2013-05-27T12:47:26.367", "Id": "16772837", "OwnerUserId": "1932150", "Body": "<p>Paragraph 7.3.1/2 of the C++11 Standard simply forbids that:</p>\n<blockquote>\n<p id=\"so_16772759_16772837_0\">The identifier in an <em>original-namespace-definition</em> <strong>shall not have been previously defined in the declarative\n  region in which the <em>original-namespace-definition</em> appears</strong>. The identifier in an <em>original-namespace-definition</em>\n  is the name of the namespace. Subsequently in that declarative region, it is treated as an <em>original-namespacename</em>.</p>\n</blockquote>\n<p>Concerning this statement of yours:</p>\n<blockquote>\n<p id=\"so_16772759_16772837_1\">As long as the namespace and the class don't occur in the same source (after preprocessing) it will work </p>\n</blockquote>\n<p>That's incorrect. Paragraph 7.3.2/4 (and the last sentence in particular) tells you why it <em>seems</em> to be \"working\", although your program is ill-formed:</p>\n<blockquote>\n<p id=\"so_16772759_16772837_2\">A <em>namespace-name</em> or <em>namespace-alias</em> shall not be declared as the name of any other entity in the same\n  declarative region. A <em>namespace-name</em> defined at global scope shall not be declared as the name of any\n  other entity in any global scope of the program. <strong>No diagnostic is required for a violation of this rule by\n  declarations in different translation units</strong>.</p>\n</blockquote>\n<p>This means the codebase you are working with has undefined behavior, and this is potentially a time bomb that may explode in incomprehensible ways.</p>\n", "LastActivityDate": "2013-05-27T12:47:26.367"}});