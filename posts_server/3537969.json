post_cb({"3537998": {"Id": "3537998", "PostTypeId": "2", "Body": "<p>In the C++03 standard, 11.8p1 says: </p>\n<blockquote>\n<p id=\"so_3537969_3537998_0\"><em>The members of a nested class have no special access to members of an enclosing class.</em></p>\n</blockquote>\n<p>However, the resolution for <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#45\" rel=\"noreferrer\">defect report 45</a> (to the standard) states the opposite, and hence defines the behavior you see: </p>\n<blockquote>\n<p id=\"so_3537969_3537998_1\"><em>A nested class is a member and as such has the same access rights as any other member.</em></p>\n</blockquote>\n<p>In C++0x the text of 11.8 has been changed to reflect this fact, so this is valid behavior for both C++03 and C++0x conforming compilers.</p>\n<p>See also <a href=\"http://cboard.cprogramming.com/cplusplus-programming/110207-can-nested-class-access-parent-classs-private-member.html\" rel=\"noreferrer\">this thread</a> from the <a href=\"http://cprogramming.com\" rel=\"noreferrer\">cprogramming.com</a> forums.</p>\n", "LastEditorUserId": "94237", "LastActivityDate": "2010-08-21T15:14:45.393", "Score": "12", "CreationDate": "2010-08-21T15:09:42.853", "ParentId": "3537969", "CommentCount": "4", "OwnerUserId": "94237", "LastEditDate": "2010-08-21T15:14:45.393"}, "3537989": {"Id": "3537989", "PostTypeId": "2", "Body": "<p>I don't have a copy of C++03 handy but from a draft (n3090) of C++0x:</p>\n<blockquote>\n<p id=\"so_3537969_3537989_0\"><strong>11.8 Nested classes</strong> </p>\n<p id=\"so_3537969_3537989_1\"><strong>1</strong> A nested class\n  is a member and as such has the same\n  access rights as any other member. The\n  members of an enclosing class have no\n  special access to members of a nested\n  class; the usual access rules (Clause\n  11) shall be obeyed.</p>\n<p id=\"so_3537969_3537989_2\">[ Example:</p>\n</blockquote>\n<pre><code>class E {\n    int x;\n    class B { };\n    class I {\n        B b; // OK: E::I can access E::B\n        int y;\n        void f(E* p, int i) {\n            p-&gt;x = i; // OK: E::I can access E::x\n        }\n    };\n    int g(I* p) {\n        return p-&gt;y; // error: I::y is private\n    }\n};\n</code></pre>\n<p>So at least in the next standard, enclosed classes can access the outer class' members as any normal member function would.</p>\n<p>Update: <strong>This isn't allowed in the current standard. But a defect report (<a href=\"http://std.dkuug.dk/jtc1/sc22/wg21/docs/cwg_defects.html#45\" rel=\"nofollow noreferrer\">DR 45</a>) was filed to fix this.</strong> <em>(SigTerm's edit took this one out. Please, be careful.)</em></p>\n<p>Update #2: I tried with VS2010, g++ (4.0.1 Apple) with <code>-Wall -ansi -pedantic -std=c++98</code> and Comeau (4.3.10.1) in strict C++03 mode with C++0x extensions disabled -- all of them seem to accept access to the outer class <code>private</code> members in the inner class members.</p>\n", "LastEditorUserId": "66692", "LastActivityDate": "2010-08-21T15:32:47.303", "Score": "5", "CreationDate": "2010-08-21T15:06:18.370", "ParentId": "3537969", "CommentCount": "0", "OwnerUserId": "66692", "LastEditDate": "2010-08-21T15:32:47.303"}, "3537969": {"ViewCount": "4305", "Body": "<p>This code compiles on msvc/g++:</p>\n<pre><code>class A{\nprotected:\n    int i;\n    class B{\n    public:\n        A* a;\n        B(A* a_)\n        :a(a_){\n        }\n        void doSomething(){\n            if (a)\n                a-&gt;i = 0;//&lt;---- this part\n        }       \n    };\npublic:\n    A()\n    :i(0){\n    }\n};\n</code></pre>\n<p>As you can see, B gets access to \"protected\" section of enclosing class, although it isn't declared as friend. </p>\n<p>Is this a standard(standard-conforming) behavior? </p>\n<p>I use this feature sometimes, but I don't remember a rule saying that nested protected class should automatically get access to all protected data of enclosing class.</p>\n", "AcceptedAnswerId": "3537998", "Title": "Nested classes: Access to protected member of enclosing class from a nested protected class", "CreationDate": "2010-08-21T14:56:44.850", "Id": "3537969", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2010-08-21T15:32:47.303", "Score": "15", "OwnerUserId": "271376", "Tags": "<c++>", "AnswerCount": "4"}, "3537988": {"Id": "3537988", "PostTypeId": "2", "Body": "<p>Refer $9.7/1.</p>\n<p>\"The nested class is in the scope of its enclosing class. Except by using explicit pointers, references, and object names, declarations in a nested class can use only\ntype names, static members, and enumerators from the enclosing class.\"</p>\n", "LastActivityDate": "2010-08-21T15:06:05.283", "CommentCount": "0", "CreationDate": "2010-08-21T15:06:05.283", "ParentId": "3537969", "Score": "0", "OwnerUserId": "418110"}, "bq_ids": {"n4140": {"so_3537969_3537998_0": {"length": 7, "quality": 0.7, "section_id": 5928}, "so_3537969_3537989_1": {"length": 23, "quality": 0.9583333333333334, "section_id": 6700}, "so_3537969_3537998_1": {"length": 9, "quality": 1.0, "section_id": 6700}, "so_3537969_3538034_3": {"length": 23, "quality": 0.9583333333333334, "section_id": 6700}}, "n3337": {"so_3537969_3537998_0": {"length": 7, "quality": 0.7, "section_id": 5700}, "so_3537969_3537989_1": {"length": 23, "quality": 0.9583333333333334, "section_id": 6455}, "so_3537969_3537998_1": {"length": 9, "quality": 1.0, "section_id": 6455}, "so_3537969_3538034_3": {"length": 23, "quality": 0.9583333333333334, "section_id": 6455}}, "n4659": {"so_3537969_3537998_0": {"length": 7, "quality": 0.7, "section_id": 7402}, "so_3537969_3537989_1": {"length": 23, "quality": 0.9583333333333334, "section_id": 8174}, "so_3537969_3537998_1": {"length": 9, "quality": 1.0, "section_id": 8174}, "so_3537969_3538034_3": {"length": 23, "quality": 0.9583333333333334, "section_id": 8174}}}, "3538034": {"Id": "3538034", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3537969_3538034_0\">Is this a standard(standard-conforming) behavior?</p>\n</blockquote>\n<p><strong>No</strong>. </p>\n<p>According to C++-2003</p>\n<p><code>Section 11.8.1</code></p>\n<blockquote>\n<p id=\"so_3537969_3538034_1\"><strong>Nested classes</strong></p>\n<p id=\"so_3537969_3538034_2\">The members of a nested class have no special access to members of an enclosing class, nor to classes or functions  that  have  granted  friendship  to  an  enclosing  class;  the  usual  access  rules  (clause  11)  shall  be obeyed.  The members of an enclosing class have no special access to members of a nested class; the usual access rules (clause 11) shall be obeyed.  </p>\n</blockquote>\n<pre><code>[Example:\nclass E {\n\n    int x;\n    class B { };\n    class I {\n\n       B b;  //error: E::B is private\n       int y;\n       void f(E* p, int i)\n       {\n             p-&gt;x = i;           //error: E::x is private\n       }\n    };\n    int g(I* p)\n    {\n           return p-&gt;y;  //error: I::y is private\n    }\n};\n\u2014end example]\n</code></pre>\n<p>But there is a slight modification to that section in <code>ISO/IEC N 3092</code> which says</p>\n<blockquote>\n<p id=\"so_3537969_3538034_3\"><strong>A nested class is a member and as such has the same access rights as any other member</strong>.  The members of an enclosing class have no special access to members of a nested class; the usual access rules (Clause 11) shall be obeyed. </p>\n</blockquote>\n", "LastActivityDate": "2010-08-21T15:26:25.710", "CommentCount": "0", "CreationDate": "2010-08-21T15:26:25.710", "ParentId": "3537969", "Score": "0", "OwnerUserId": "165520"}});