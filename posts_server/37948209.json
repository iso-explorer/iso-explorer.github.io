post_cb({"37948575": {"Id": "37948575", "PostTypeId": "2", "Body": "<p>No, variables can have language linkage too.</p>\n<p>First of all, your book paraphrases standard: </p>\n<blockquote>\n<p id=\"so_37948209_37948575_0\">All function types, function names with external linkage, <strong>and variable names</strong> with external linkage have a language linkage.</p>\n</blockquote>\n<p>This alone suggests that you can apply linkage specifications to variables. </p>\n<p>Further down there is this example:</p>\n<pre><code>extern \"C\" int i; // declaration\nextern \"C\" {\n    int i; // definition\n}\n</code></pre>\n<p>Which shows how can you apply linkage specifier to non-function. In addition there are multiple mentions of <em>functions</em> and <em>variables</em> through whole <strong>[dcl.link]</strong> chapter of standard.</p>\n", "LastActivityDate": "2016-06-21T15:26:57.940", "CommentCount": "0", "CreationDate": "2016-06-21T15:26:57.940", "ParentId": "37948209", "Score": "0", "OwnerUserId": "3410396"}, "bq_ids": {"n4140": {"so_37948209_37948575_0": {"length": 14, "quality": 1.0, "section_id": 5517}}, "n3337": {"so_37948209_37948575_0": {"length": 14, "quality": 1.0, "section_id": 5303}}, "n4659": {"so_37948209_37948575_0": {"length": 14, "quality": 1.0, "section_id": 6952}}}, "37952460": {"Id": "37952460", "PostTypeId": "2", "Body": "<p>Language linkage specifications are intended to enable linking into the same program object files originating from different source languages.</p>\n<p>The problem is that, in general, names of entities (functions, variables, etc) in object files do not exactly match the names of the corresponding entities in the source code.</p>\n<p>C, being  an old and \"simple\" language, didn't concern itself with such considerations and used source names in the object files as is.</p>\n<p>C++, building on top of C, introduced function overloading, allowing different functions to have the same name. Therefore the signature of C++ functions had to be encoded in the symbol name representing that function in an object file.</p>\n<p>Besides, names of C++ entities may contain the following characters (that could not appear in C identifiers):</p>\n<ol>\n<li><strong><code>:</code></strong> - in fully qualified names (<code>std::cout</code>)</li>\n<li><strong><code>&lt;</code></strong>, <strong><code>&gt;</code></strong> - in the names of template specializations</li>\n<li><strong><code>+</code></strong>, <strong><code>-</code></strong>, <strong><code>*</code></strong>, <strong><code>/</code></strong> and other special symbols - in the names of overloaded operators</li>\n</ol>\n<p>Probably enough, old linkers would have trouble dealing with such characters in symbols names, therefore the C++ compilers had to encode those characters using the safe subset.</p>\n<p>Non-function entities in C++ (namely - namespace variables, static data members of non-template and template classes) can have the characters <strong><code>:</code></strong>, <strong><code>&lt;</code></strong>, and <strong><code>&gt;</code></strong> in their names . Therefore, if we consider only C and C++, variables must have language linkage too. However, if a C++ variable's fully qualified name (without including the leading global namespace prefix) doesn't contain the mentioned characters, then its symbol name coincides with its source name. As a result I cannot think of a case when specifying \"C\" linkage for a variable makes a difference.</p>\n<p>In principle, the language linkage specification allows importing names from modules compiled from other programming languages (though, as noted in your quote, those are implementation-defined). If you ever need to link with such a foreign language module and refer to a \"global\" variable therein, you will first have to declare it in your source file using the language linkage specification:</p>\n<pre><code>extern \"Sci++\" {\n    MemAllocFuncPtr Solver##Config##Malloc;\n\n    // Won't the '#' chararcters in the identifier name confuse the C++ compiler?\n    // Maybe C++ will need to be enhanced as below:\n    using SciPPSolverConfigMalloc = Solver##Config##Malloc;\n}\n</code></pre>\n<p>Yet, I don't believe that you will encounter anything like that in practice.</p>\n", "LastActivityDate": "2016-06-21T18:56:09.600", "CommentCount": "0", "CreationDate": "2016-06-21T18:56:09.600", "ParentId": "37948209", "Score": "0", "OwnerUserId": "6394138"}, "37948209": {"ViewCount": "80", "Body": "<p>In <a href=\"https://books.google.com/books?id=Q4iP1mkfdtsC&amp;lpg=PT39&amp;ots=w_m99yO-7q&amp;dq=Every%20function%2C%20function%20type%2C%20and%20object%20has%20a%20language%20linkage%2C%20which%20is%20specified%20as%20a%20simple%20character%20string.%20By%20default%2C%20the%20linkage%20is&amp;pg=PT39#v=onepage&amp;q=Every%20function,%20function%20type,%20and%20object%20has%20a%20language%20linkage,%20which%20is%20specified%20as%20a%20simple%20character%20string.%20By%20default,%20the%20linkage%20is&amp;f=false\" rel=\"nofollow\">Lischner's C++ in a Nutshell 2002</a></p>\n<blockquote>\n<p id=\"so_37948209_37948209_0\"><strong>Every function, function type, and object has a language linkage,</strong> which is specified as a simple character string. By default, the\n  linkage is \"C++\". The only other standard language linkage is \"C\". All\n  other language linkages and the properties associated with different\n  language linkages are implementation-defined.</p>\n</blockquote>\n<p>Does language linkage only belong to a function, not a non-function object? The examples that I have seen seem to say yes. But I guess I miss something. </p>\n<p>What does the quote mean by each 'function type' and 'object' having a language linkage?</p>\n<p>Thanks.</p>\n", "Title": "Does language linkage only belong to a function?", "CreationDate": "2016-06-21T15:10:41.327", "LastActivityDate": "2016-06-21T18:56:09.600", "CommentCount": "2", "LastEditDate": "2016-06-21T15:22:05.763", "PostTypeId": "1", "LastEditorUserId": "156458", "Id": "37948209", "Score": "0", "OwnerUserId": "156458", "Tags": "<c++><linkage>", "AnswerCount": "2"}});