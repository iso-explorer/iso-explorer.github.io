post_cb({"31685448": {"ParentId": "31685132", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2015-07-28T19:29:47.580", "Score": "11", "LastEditorUserId": "1708801", "LastEditDate": "2015-11-08T03:23:10.287", "Id": "31685448", "OwnerUserId": "1708801", "Body": "<p>This is ill-formed and there should be diagnostic, however it can either be a warning(<em>which you received</em>) or an error. <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=55783#c4\" rel=\"noreferrer\">gcc made this a warning for several versions due to porting issue from C++03</a>:</p>\n<blockquote>\n<p id=\"so_31685132_31685448_0\">The standard only requires that \"a conforming implementation shall issue at least one diagnostic message\" so compiling the program with a warning is allowed.  As Andrew said, -Werror=narrowing allows you to make it an error if you want.</p>\n<p id=\"so_31685132_31685448_1\">G++ 4.6 gave an error but it was changed to a warning intentionally for 4.7 because many people (myself included) found that narrowing conversions where one of the most commonly encountered problems when trying to compile large C++03 codebases as C++11.  Previously well-formed code such as char c[] = { i, 0 }; (where i will only ever be within the range of char) caused errors and had to be changed to char c[] = { (char)i, 0 }</p>\n</blockquote>\n<p>but now recent versions of gcc and clang make this an error, <a href=\"http://melpon.org/wandbox/permlink/M4PXlIaPnYqL58AD\" rel=\"noreferrer\">see it live for gcc</a>.</p>\n<p>For reference the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"noreferrer\">draft C++11 standard</a> section <code>8.5.4</code> <em>[dcl.init.list]</em> says:</p>\n<blockquote>\n<p id=\"so_31685132_31685448_2\">Otherwise, if the initializer list has a single element, the object or\n  reference is initialized from that element; if a narrowing conversion\n  (see below) is required to convert the element to T, the program is\n  ill-formed. [ Example:</p>\n<pre><code>int x1 {2}; // OK\nint x2 {2.0}; // error: narrowing\n</code></pre>\n<p id=\"so_31685132_31685448_3\">\u2014end example ]</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_31685132_31685448_4\">A narrowing conversion is an implicit conversion</p>\n<ul>\n<li>from a floating-point type to an integer type, or</li>\n</ul>\n<p id=\"so_31685132_31685448_5\">[...]</p>\n<p id=\"so_31685132_31685448_6\">[ Note: As indicated above, such conversions are not allowed at the top level in list-initializations.\u2014end\n  note ] [ Example:</p>\n<p id=\"so_31685132_31685448_7\">[...]</p>\n<pre><code>int ii = {2.0}; // error: narrows\n</code></pre>\n<p id=\"so_31685132_31685448_8\">[...]</p>\n</blockquote>\n<p>So a floating point to integer conversion is a narrowing conversion and is ill-formed.</p>\n<p>and section <code>1.4</code> Implementation compliance [intro.compliance] says:</p>\n<blockquote>\n<p id=\"so_31685132_31685448_9\">Although this International Standard states only requirements on C++ implementations, those requirements\n  are often easier to understand if they are phrased as requirements on programs, parts of programs, or\n  execution of programs. Such requirements have the following meaning:</p>\n<p id=\"so_31685132_31685448_10\">[...]</p>\n<ul>\n<li>If a program contains a violation of any diagnosable rule or an occurrence of a construct described in\n  this Standard as \u201cconditionally-supported\u201d when the implementation does not support that construct,\n  a conforming implementation shall issue at least one diagnostic message.</li>\n</ul>\n<p id=\"so_31685132_31685448_11\">[...]</p>\n</blockquote>\n<p>Tells us that only a diagnostic is required.</p>\n", "LastActivityDate": "2015-11-08T03:23:10.287"}, "31685132": {"CommentCount": "4", "ViewCount": "610", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-07-28T19:09:36.537", "LastActivityDate": "2015-11-08T03:23:10.287", "Title": "Why doesn't narrowing conversion used with curly-brace-delimited initializer cause an error?", "LastEditDate": "2015-07-29T00:04:21.663", "Id": "31685132", "Score": "12", "Body": "<p>I learnt about curly-brace-delimited initializer in The C++ Programming Language, 4th ed. &gt; Chapter 2: A Tour of C++: The Basics.</p>\n<p>I am quoting from the book below.</p>\n<blockquote>\n<p id=\"so_31685132_31685132_0\">The = form is traditional and dates back to C, but if in doubt, use the general {} -list form (\u00a76.3.5.2).\n  If nothing else, it saves you from conversions that lose information (narrowing conversions; \u00a710.5):</p>\n<pre><code>int i1 = 7.2;    // i1 becomes 7\nint i2 {7.2};    // error : floating-point to integer conversion\nint i3 = {7.2};  // error : floating-point to integer conversion (the = is redundant)\n</code></pre>\n</blockquote>\n<p>However, I am unable to reproduce these results.</p>\n<p>I have the following code.</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    int i1 = 7.2;\n    int i2 {7.2};\n    int i3 = {7.2};\n\n    std::cout &lt;&lt; i1 &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; i2 &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; i3 &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>When I compile and run it, I don't get any error. I get a warning about <code>std=c++11</code> but no error.</p>\n<pre><code>$ g++ init.cpp \ninit.cpp: In function \u2018int main()\u2019:\ninit.cpp:6:12: warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\n     int i2 {7.2};\n            ^\n$ ./a.out \n7\n7\n7\n</code></pre>\n<p>Further, the warning is only for the second assignment but there is no warning for the third assignment. This seems to indicate that the <code>=</code> is not really redundant as mentioned in the book. If <code>=</code> were redundant, either both the second and third assignments would have produced warnings or both would not have produced warnings.\nThen I compile them with the <code>-std=c++11</code> flag.</p>\n<pre><code>$ g++ -std=c++11 init.cpp \ninit.cpp: In function \u2018int main()\u2019:\ninit.cpp:6:16: warning: narrowing conversion of \u20187.2000000000000002e+0\u2019 from \u2018double\u2019 to \u2018int\u2019 inside { } [-Wnarrowing]\n     int i2 {7.2};\n                ^\ninit.cpp:7:18: warning: narrowing conversion of \u20187.2000000000000002e+0\u2019 from \u2018double\u2019 to \u2018int\u2019 inside { } [-Wnarrowing]\n     int i3 = {7.2};\n                  ^\n$ ./a.out \n7\n7\n7\n</code></pre>\n<p>Still no error. Only warnings. Although in this case the second and third assignments behave identically with respect to generating warnings.</p>\n<p>So my question is: Although the book mentions that the second and third assignments are errors, why doesn't this code fail to compile?</p>\n", "Tags": "<c++><c++11><narrowing>", "OwnerUserId": "1175080", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_31685132_31685448_6": {"section_id": 3329, "quality": 0.6363636363636364, "length": 7}, "so_31685132_31685448_2": {"section_id": 3325, "quality": 0.9444444444444444, "length": 17}, "so_31685132_31685448_9": {"section_id": 5770, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_31685132_31685448_6": {"section_id": 3199, "quality": 0.6363636363636364, "length": 7}, "so_31685132_31685448_2": {"section_id": 3195, "quality": 0.9444444444444444, "length": 17}, "so_31685132_31685448_9": {"section_id": 5543, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_31685132_31685448_6": {"section_id": 4095, "quality": 0.6363636363636364, "length": 7}, "so_31685132_31685448_2": {"section_id": 4091, "quality": 0.9444444444444444, "length": 17}, "so_31685132_31685448_9": {"section_id": 7227, "quality": 0.9583333333333334, "length": 23}}}, "31685157": {"ParentId": "31685132", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-07-28T19:11:53.170", "Score": "7", "LastEditorUserId": "187690", "LastEditDate": "2015-07-28T19:18:48.597", "Id": "31685157", "OwnerUserId": "187690", "Body": "<p>C++ language does not distinguish \"warnings\" from \"errors\". C++ only has <em>diagnostic messages</em>. The warnings you received are diagnostic messages. The language specification does not require compilers to stop compilation when they encounter erroneous (aka ill-formed) code. All compilers have to do is issue a diagnostic message, and then they can continue compiling, if they so desire.</p>\n<p>This means that in general case it is your responsibility to tell warnings that are \"just warnings\" from warnings that actually indicate genuine errors, especially with such permissive compilers as GCC. </p>\n<p>This also means that the actual real-life behavior is a matter of your compiler setup. Ask your compiler to be more restrictive in that regard, if possible. In GCC you might try <code>-pedantic-errors</code> switch for that purpose.</p>\n<p>P.S. In my experiments with GCC, <code>-std=c++11</code> is sufficient to make it generate <em>errors</em> for your code. If you are getting warnings instead, it could be a matter of compiler version.</p>\n", "LastActivityDate": "2015-07-28T19:18:48.597"}});