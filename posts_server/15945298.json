post_cb({"bq_ids": {"n4140": {"so_15945298_15945444_4": {"length": 14, "quality": 0.6363636363636364, "section_id": 5961}, "so_15945298_15945444_1": {"length": 76, "quality": 0.8444444444444444, "section_id": 5790}, "so_15945298_15945444_3": {"length": 9, "quality": 1.0, "section_id": 5960}}, "n3337": {"so_15945298_15945444_4": {"length": 14, "quality": 0.6363636363636364, "section_id": 5730}, "so_15945298_15945444_1": {"length": 76, "quality": 0.8444444444444444, "section_id": 5563}, "so_15945298_15945444_3": {"length": 9, "quality": 1.0, "section_id": 5729}}, "n4659": {"so_15945298_15945444_1": {"length": 64, "quality": 0.7111111111111111, "section_id": 7247}, "so_15945298_15945444_3": {"length": 9, "quality": 1.0, "section_id": 7447}}}, "15945298": {"ViewCount": "327", "Body": "<p>Help me to understand this, If I consider all the C++ standards, including C++11, it's correct to say that the only <em>object</em> that I can deal with is an instance of a class ?</p>\n<p>what about other players such as lambdas ? an instance of a POD is considered an object ?</p>\n<p>I know that this sounds like a small detail but most of the times I found concepts from other languages hard to compare when I have this kind of problems defining what is an object and what is not, especially in functional OOP languages.</p>\n", "AcceptedAnswerId": "15945444", "Title": "In C++ a \"class instance\" is the only type of object?", "CreationDate": "2013-04-11T09:30:35.313", "Id": "15945298", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-04-11T12:47:51.570", "Score": "5", "OwnerUserId": "2269624", "Tags": "<c++><oop><design><c++11>", "AnswerCount": "3"}, "15945444": {"Id": "15945444", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15945298_15945444_0\">If I consider all the C++ standards, including C++11, it's correct to say that the only object that I can deal with is an instance of a class ?</p>\n</blockquote>\n<p><strong>No</strong>, this is not correct.</p>\n<p>In C++, the term \"object\" refers to a region of storage which is given a particular interpretation according to properties (such as its type) which are conferred to the object.</p>\n<p>Per Paragraph 1.8/1 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15945298_15945444_1\">The constructs in a C++ program create, destroy, refer to, access, and manipulate objects. <strong>An object is a\n  region of storage</strong>. [ Note: A function is not an object, regardless of whether or not it occupies storage in the\n  way that objects do. \u2014end note ] An object is created by a definition (3.1), by a new-expression (5.3.4)\n  or by the implementation (12.2) when needed. The properties of an object are determined when the object\n  is created. An object can have a name (Clause 3). An object has a storage duration (3.7) which influences\n  its lifetime (3.8). An object has a type (3.9). <strong>The term object type refers to the type with which the object\n  is created</strong>. Some objects are polymorphic (10.3); the implementation generates information associated with\n  each such object that makes it possible to determine that object\u2019s type during program execution. For other\n  objects, the interpretation of the values found therein is determined by the type of the expressions (Clause 5)\n  used to access them.</p>\n</blockquote>\n<p>So basically an <code>int</code> is an object, an instance of a POD is an object, and of course an instance of a class type is an object. In OOP, the term \"object\" is usually meant to denote just the latter entity - but in C++ this is not the case.</p>\n<blockquote>\n<p id=\"so_15945298_15945444_2\">what about other players such as lambdas ?</p>\n</blockquote>\n<p>Lambdas are actually syntactic sugar to define unnamed functors (Paragraph 5.1.2/1):</p>\n<blockquote>\n<p id=\"so_15945298_15945444_3\">Lambda expressions provide a concise way to create simple function objects. [...]</p>\n</blockquote>\n<p>Also (per Paragraph 5.1.2/2):</p>\n<blockquote>\n<p id=\"so_15945298_15945444_4\">The evaluation of a lambda-expression results in a prvalue temporary (12.2). This temporary is called the\n  closure <strong>object</strong>. [...] [ <em>Note</em>: A closure\n  object behaves like a function object (20.8).  \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>Therefore, lambdas are expressions whose evaluation results in the creation of a temporary object (so yes, in some sense one could say lambdas are also objects, or rather that they <em>yield</em> an object).</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-04-11T12:47:51.570", "Score": "8", "CreationDate": "2013-04-11T09:38:12.977", "ParentId": "15945298", "CommentCount": "2", "LastEditDate": "2013-04-11T12:47:51.570", "OwnerUserId": "1932150"}, "15948709": {"Id": "15948709", "PostTypeId": "2", "Body": "<p>Traditional OOP tends to define the notion of \"object\" as a \"polymorphic entity\" that carries methods and data, and can be referenced from other objects an algorithms.</p>\n<p>The C++ definition of object is -in essence- \"whatever thing takes a space to retain a state\".\nThis lead to the main difference that C++ \"objects\" have \"value behavior\" and that \"methods\" are not necessarily members, and object don't need to necessarily support runtime polymorphism.</p>\n<p>C++ program following the traditional OOP definition, ends up with classes referred by (smart)-(base)-(pointers|reference), using the indirection mechanism as a key to resolve polymorphism at runtime.</p>\n<p>Modern C++ uses object as having value-copy or move semantics, and tends to address polymorphism at compile time with templates and generic algorithms and type traits.</p>\n<p>The two things are not one against the other, but C++ is intentionally the merging of both of them, hence reducing the definition of \"object\" the traditional OOP one (instance of a class to be referenced), is -in fact- cutting away one half of the C++ features and possibilities.</p>\n<p>About lambdas, it strict sense they are <em>expressions</em> (not objects themselves) returning <em>anonymous typed objects</em>.</p>\n<p>So saying they are <em>objects</em> is improper: <code>a+b</code>it is not itself an object: it <em>produces</em> an object (the result of the expression). The same is for <code>[](){}</code>: it is not itself an object: it produces an object, you can even store, like in</p>\n<pre><code>auto fn = [](){}; //create a lambda and assign to fn.\nfn();             //just calls it\n</code></pre>\n<p>The fn type is something like</p>\n<pre><code>class lambda_uniquename\n{\npublic:\n   void operator()()\n   {}\n};\n</code></pre>\n<p>The object, here, is not the <code>lambda</code> class, but the <code>fn</code> variable.</p>\n", "LastEditorUserId": "924727", "LastActivityDate": "2013-04-11T12:32:13.490", "Score": "2", "CreationDate": "2013-04-11T12:23:50.293", "ParentId": "15945298", "CommentCount": "0", "LastEditDate": "2013-04-11T12:32:13.490", "OwnerUserId": "924727"}, "15945456": {"Id": "15945456", "PostTypeId": "2", "Body": "<p>in c++ an <strong>object</strong> is a region of storage with an associated type</p>\n<p>e.g. an <code>int</code></p>\n<p>the region needs not necessarily be contiguous</p>\n<p>as an example, with virtual multiple inheritance parts of an object can be (in the sense of, some situations exist where it has to be) spread around</p>\n", "LastActivityDate": "2013-04-11T09:39:02.060", "Score": "2", "CreationDate": "2013-04-11T09:39:02.060", "ParentId": "15945298", "CommentCount": "0", "OwnerUserId": "464581"}});