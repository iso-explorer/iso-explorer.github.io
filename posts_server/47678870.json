post_cb({"47679533": {"Id": "47679533", "PostTypeId": "2", "Body": "<p>Let's start with the simple case:</p>\n<pre><code>template &lt;typename T&gt; using id = T;\n\ntemplate&lt;class T&gt; T f(T);\ntemplate&lt;class T&gt; id&lt;T&gt; f(T);\n</code></pre>\n<p>This to me is clearly ill-formed, no diagnostic required, per <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.over.link#6\" rel=\"nofollow noreferrer\">the relevant rule</a>. The two declarations are functionally equivalent, but not in a way that's simply renaming template parameters (and there aren't any dependent names to consider).</p>\n<hr/>\n<p>With the more complicated case:</p>\n<pre><code>template &lt;typename T&gt; struct id_t { using type = T; };\ntemplate &lt;typename T&gt; using id = typename id_t&lt;T&gt;::type;\n\ntemplate&lt;class T&gt; T f(T);\ntemplate&lt;class T&gt; id&lt;T&gt; f(T);\n</code></pre>\n<p>I think this is probably <em>not</em> ill-formed, because they aren't truly functionally equivalent. There could be specializations of <code>id_t</code> such that these two declarations are actually different - so these are actually different declarations. </p>\n", "CommentCount": "4", "LastActivityDate": "2017-12-06T16:53:16.663", "CreationDate": "2017-12-06T16:53:16.663", "ParentId": "47678870", "Score": "3", "OwnerUserId": "2069064"}, "bq_ids": {"n4140": {"so_47678870_47679353_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 157}}, "n4659": {"so_47678870_47679353_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 161}}}, "47679353": {"PostTypeId": "2", "LastEditDate": "2017-12-06T16:59:18.513", "ParentId": "47678870", "CommentCount": "5", "LastEditorUserId": "27678", "LastActivityDate": "2017-12-06T16:59:18.513", "CreationDate": "2017-12-06T16:44:05.077", "Id": "47679353", "Score": "2", "Body": "<p>I think that in this scenario they are considered different:</p>\n<pre><code>template&lt;class T&gt;\nstruct t_{\n   using type = T;\n   };\n//ill-formed or different?\ntemplate&lt;class T&gt; T f(T);\ntemplate&lt;class T&gt; typename t_&lt;T&gt;::type f(T);\n</code></pre>\n<p>Because [temp.over.link] says (<strong>emphasis mine</strong>)</p>\n<blockquote>\n<p id=\"so_47678870_47679353_0\">For determining whether two\n  dependent names  are equivalent, <strong>only the name itself is considered, not the result of name lookup in\n  the context of the template</strong>.</p>\n</blockquote>\n<p>Since <code>T</code> and <code>typename t_&lt;T&gt;::type</code> differ in naming, the compiler will accept these template declarations.</p>\n<p>Now, you couldn't actually <em>call</em> either of them because the resulting template instantiations are <em>functionally equivalent</em>, resulting in ambiguity. This sort of program is ill-formed, no diagnostic required* (See <a href=\"https://stackoverflow.com/a/47679533/27678\">@Barry's great answer</a>).</p>\n<p><a href=\"http://rextester.com/LKTII28811\" rel=\"nofollow noreferrer\">MSVC 19.00.23506</a>, <a href=\"https://wandbox.org/permlink/frpEr6zTQujIEZFJ\" rel=\"nofollow noreferrer\">clang 6.0.0</a>, and <a href=\"https://wandbox.org/permlink/WMrL5wP1VHxN33Qb\" rel=\"nofollow noreferrer\">gcc 8.0.0</a> all appear to agree with me on this (none of them issue a diagnostic).</p>\n<p>Note that the compiler allows these templates to be declared, so long as they aren't called, whereas something like this won't compile even if the templates are not instantiated:</p>\n<pre><code>template&lt;class U&gt; typename t_&lt;U&gt;::type f(U){return {};}\ntemplate&lt;class T&gt; typename t_&lt;T&gt;::type f(T){return {};}\n</code></pre>\n<hr>\n<p>* \"If a program contains declarations of function\ntemplates that are functionally equivalent but not equivalent, the program is ill-formed, no diagnostic\nrequired.\"</p>\n</hr>", "OwnerUserId": "27678"}, "47678870": {"ViewCount": "96", "LastEditDate": "2017-12-06T16:34:43.170", "AcceptedAnswerId": "47679533", "Title": "Template equivalence or template functional equivalence?", "CreationDate": "2017-12-06T16:18:04.697", "LastActivityDate": "2017-12-06T16:59:18.513", "CommentCount": "0", "FavoriteCount": "1", "OwnerUserId": "5632316", "PostTypeId": "1", "LastEditorUserId": "5632316", "Id": "47678870", "Score": "4", "Body": "<p>In the C++ standard [temp.over.link], it is explained that the determination of function template equivalence should not involve \"heroic efforts\" of the compiler.</p>\n<p>As an example, the C++ standard propose this:</p>\n<pre><code>// guaranteed to be the same\ntemplate &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);\ntemplate &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);\n// guaranteed to be different\ntemplate &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);\ntemplate &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+11&gt;);\n// ill-formed, no diagnostic required\ntemplate &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);\ntemplate &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+1+2+3+4&gt;);\n</code></pre>\n<p>Is this rule also applies to cases involving meta programming, as in the example below?</p>\n<pre><code>template&lt;class T&gt;\nstruct t_{\n   using type = T;\n   };\n//ill-formed or different?\ntemplate&lt;class T&gt; T f(T);\ntemplate&lt;class T&gt; typename t_&lt;T&gt;::type f(T);\n</code></pre>\n", "Tags": "<c++><templates>", "AnswerCount": "2"}});