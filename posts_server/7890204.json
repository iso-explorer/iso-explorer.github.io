post_cb({"7890204": {"CommentCount": "6", "ViewCount": "269", "PostTypeId": "1", "LastEditorUserId": "168175", "CreationDate": "2011-10-25T13:43:45.110", "LastActivityDate": "2016-12-24T17:23:23.430", "Title": "Deducing knowledge of original types, whilst simultaneously forwarding", "AcceptedAnswerId": "7891906", "LastEditDate": "2011-10-25T13:57:13.100", "Id": "7890204", "Score": "8", "Body": "<p>Summary: I want to end up with a function that deduces the <em>exact</em> types it was called with and takes (e.g.) a tuple that forwards them (the types of which will be different from the exact types the function was called with).</p>\n<p>I'm stuck trying to \"know\" via deduction the types of the arguments to a given function, whilst simultaneously forwarding them. I think I might be missing something crucial about how this works.</p>\n<pre><code>#include &lt;tuple&gt;\n#include &lt;string&gt;\n#include &lt;functional&gt;\n\ntemplate &lt;typename ...Args&gt;\nstruct unresolved_linker_to_print_the_type {\n   unresolved_linker_to_print_the_type();\n};\n\nvoid f(int,double,void*,std::string&amp;,const char*) {\n}\n\ntemplate &lt;typename F, typename ...Args&gt;\nvoid g1(F func, Args&amp;&amp;... args) {\n  unresolved_linker_to_print_the_type&lt;Args...&gt;();\n  auto tuple = std::forward_as_tuple(args...);\n  unresolved_linker_to_print_the_type&lt;decltype(tuple)&gt;();\n}\n\ntemplate &lt;typename F, typename T, typename ...Args&gt;\nvoid g2(F func, const T&amp; tuple, Args... args) {\n  unresolved_linker_to_print_the_type&lt;Args...&gt;();\n  unresolved_linker_to_print_the_type&lt;decltype(tuple)&gt;();\n}\n\nint main() {\n  int i;\n  double d;\n  void *ptr;\n  std::string str;\n  std::string&amp; sref = str;\n  const char *cstr = \"HI\";\n\n  g1(f, i,d,ptr,sref,cstr);\n  g2(f, std::forward_as_tuple(i,d,ptr,sref,cstr),  i,d,ptr,sref,cstr);\n}\n</code></pre>\n<p>What I'd like to see is a scenario where when my function (e.g. <code>g1</code> or <code>g2</code>) gets called it knows and can use both the original types - <code>int,double,void*,std::string&amp;,const char*</code> <em>and</em> the forwarded arugments too.</p>\n<p>In this instance I don't seem to be able to find this information from within <code>g1</code> or <code>g2</code>. The (deliberate, to print out the types) linker error shows me in <code>g1</code> they are:</p>\n<pre><code>int&amp;, double&amp;, void*&amp;, std::string&amp;, char const*&amp;\nint&amp;, double&amp;, void*&amp;, std::string&amp;, char const*&amp;\n</code></pre>\n<p>and in <code>g2</code>:</p>\n<pre><code>int, double, void*, std::string, char const*\nint&amp;, double&amp;, void*&amp;, std::string&amp;, char const*&amp;\n</code></pre>\n<p>There are two thing I don't get here:</p>\n<ol>\n<li><p>Why do none of the printed (via the linker error) types match what I actually passed in? (<code>int,double,void*,std::string&amp;,const char</code>). Can I deduce what I actually was passed? Preferably with \"natural\" syntax, i.e. everything just once and nothing explicitly written out. I can explicitly write:</p>\n<pre><code>g2&lt;decltype(&amp;f),decltype(std::forward_as_tuple(i,d,ptr,sref,cstr)),int,double,void*,std::string&amp;,const char*&gt;(f,std::forward_as_tuple(i,d,ptr,sref,cstr),i,d,ptr,sref,cstr);\n</code></pre>\n<p>but that's \"unwieldy\" to say the least!</p></li>\n<li><p>In <code>g1</code> the presence of <code>&amp;&amp;</code> in the function signature declaration seems to alter the types in the template parameter <code>Args</code> itself. Compare that with:</p>\n<pre><code>template &lt;typename T&gt;\nvoid test(T t);\n</code></pre>\n<p>Or:</p>\n<pre><code>template &lt;typename T&gt;\nvoid test(T&amp; t);\n</code></pre>\n<p>using either of those with:</p>\n<pre><code>int i;\ntest(i);\n</code></pre>\n<p>doesn't change the type of <code>T</code>. Why does the <code>&amp;&amp;</code> change the type of <code>T</code> itself when <code>&amp;</code> doesn't?</p></li>\n</ol>\n", "Tags": "<c++><c++11><forwarding><templates-deduction>", "OwnerUserId": "168175", "AnswerCount": "2"}, "7891906": {"ParentId": "7890204", "CommentCount": "4", "Body": "<p>Answer to first question:</p>\n<p>Arguments to functions are <em>expressions</em>, not <em>types</em>.  The difference between these two is expressed in chapter 5 [expr], p5:</p>\n<blockquote>\n<p id=\"so_7890204_7891906_0\">If an expression initially has the type \u201creference to T\u201d (8.3.2,\n  8.5.3), the type is adjusted to T prior to any further analysis.</p>\n</blockquote>\n<p>Thus, there is no difference what-so-ever between <code>g(str)</code> and <code>g(sref)</code>.  <code>g()</code> always sees a <code>std::string</code>, and never a reference.</p>\n<p>Additionally expressions can be lvalue or rvalue (actually that's a simplification of the C++11 rules, but it is close enough for this discussion - if you want the details they're in 3.10 [basic.lval]).</p>\n<p>Answer to second question:</p>\n<p>Template parameters of the form:</p>\n<pre><code>template &lt;class T&gt;\nvoid g(T&amp;&amp;);\n</code></pre>\n<p>are special.  They are unlike <code>T</code>, <code>T&amp;</code>, or even <code>const T&amp;&amp;</code> in the following way:</p>\n<p>When <code>T&amp;&amp;</code> binds to an lvalue, <code>T</code> is deduced as an lvalue reference type, otherwise <code>T</code> deduces exactly as per the normal deduction rules.</p>\n<p>Examples:</p>\n<pre><code>int i = 0;\ng(i);  // calls g&lt;int&amp;&gt;(i)\ng(0);  // calls g&lt;int&gt;(0)\n</code></pre>\n<p>This behavior is to support so called <em>perfect forwarding</em> which typically looks like:</p>\n<pre><code>struct A{};\n\nvoid bar(const A&amp;);\nvoid bar(A&amp;&amp;);\n\ntemplate &lt;class T&gt;\nvoid foo(T&amp;&amp; t)\n{\n     bar(static_cast&lt;T&amp;&amp;&gt;(t));  // real code would use std::forward&lt;T&gt; here\n}\n</code></pre>\n<p>If one calls <code>foo(A())</code> (an rvalue <code>A</code>), <code>T</code> deduces per normal rules as <code>A</code>.  Inside of <code>foo</code> we cast <code>t</code> to an <code>A&amp;&amp;</code> (an rvalue) and call <code>bar</code>.  The overload of <code>bar</code> that takes an rvalue <code>A</code> is then chosen.  I.e. if we call <code>foo</code> with an rvalue, then <code>foo</code> calls <code>bar</code> with an rvalue.</p>\n<p>But if we call <code>foo(a)</code> (an lvalue <code>A</code>), then <code>T</code> deduces as <code>A&amp;</code>.  Now the cast looks like:</p>\n<pre><code>static_cast&lt;A&amp; &amp;&amp;&gt;(t);\n</code></pre>\n<p>which under the reference collapsing rules simplifies to:</p>\n<pre><code>static_cast&lt;A&amp;&gt;(t);\n</code></pre>\n<p>I.e. the lvalue <code>t</code> is cast to an lvalue (a no-op cast), and thus the <code>bar</code> overload taking an lvalue is called.  I.e. if we call <code>foo</code> with an lvalue, then <code>foo</code> calls <code>bar</code> with an lvalue.  And that's where the term <em>perfect forwarding</em> comes from.</p>\n", "OwnerUserId": "576911", "PostTypeId": "2", "Id": "7891906", "Score": "2", "CreationDate": "2011-10-25T15:42:40.210", "LastActivityDate": "2011-10-25T15:42:40.210"}, "7934493": {"ParentId": "7890204", "CommentCount": "1", "Body": "<p>types (even in C++) are mostly a compile type notion (except of course the RTTI in vtables).</p>\n<p>If you need entirely dynamic types, then C++ might not be the best language for that.</p>\n<p>You might perhaps extend GCC (actually <code>g++</code>, assuming it is at least 4.6) with a <strong>plugin</strong> or a <a href=\"http://gcc-melt.org/\" rel=\"nofollow\">GCC MELT</a> extension (MELT is a high level domain specific language to extend GCC) which does what you want (e.g. for instance providing an additional builtin which encode the type of its arguments in some constant string, etc...), but that does require some work (and is specific to GCC).</p>\n<p>But I don't understand why you want to do such baroque things in C. If dynamic typing is so important to you, why don't you use a dynamically typed language??</p>\n", "OwnerUserId": "841108", "PostTypeId": "2", "Id": "7934493", "Score": "0", "CreationDate": "2011-10-28T20:23:32.653", "LastActivityDate": "2011-10-28T20:23:32.653"}, "bq_ids": {"n4140": {"so_7890204_7891906_0": {"section_id": 5938, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_7890204_7891906_0": {"section_id": 5710, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_7890204_7891906_0": {"section_id": 7422, "quality": 0.8181818181818182, "length": 9}}}});