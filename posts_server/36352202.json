post_cb({"36352400": {"ParentId": "36352202", "CommentCount": "0", "Body": "<p>++ is postfix increment. It has precedence over unary <code>*</code>. However, the side effect of updating the variable is done after the variable evaluation (6.5.2.4):</p>\n<blockquote>\n<p id=\"so_36352202_36352400_0\">The value computation of the result is sequenced before the side\n  effect of updating the stored value of the operand.</p>\n</blockquote>\n<p>Therefore <code>*q++</code> will always give you the value of <code>*q</code>, no matter where it is used in your code.</p>\n<p>This is the difference between prefix and postfix increment. <code>*++q</code> would have incremented the pointer first, and then evaluated the value of the new address.</p>\n", "OwnerUserId": "584518", "PostTypeId": "2", "Id": "36352400", "Score": "3", "CreationDate": "2016-04-01T09:14:46.173", "LastActivityDate": "2016-04-01T09:14:46.173"}, "36352416": {"ParentId": "36352202", "CommentCount": "2", "Body": "<p>There are two operators defined for incrementation - pre- and post-increment - and they both return a value! It is as if you called a function:</p>\n<pre><code>printf(\"%d\", *f(q));\n</code></pre>\n<p>The preincrement operator <em>first</em> increments and returns the new value, the postincrement operator returns the value and increments <em>afterwards</em>.</p>\n<p>OK, this is for illustration only - technically, it cannot increment after returning, of course, so it remembers the initial value, increments and returns the remembered one afterwards. This is, btw., the reason why preincrement is more efficient than postincrement, unless the compiler optimizes the differences away...</p>\n", "OwnerUserId": "1312382", "PostTypeId": "2", "Id": "36352416", "Score": "1", "CreationDate": "2016-04-01T09:15:39.453", "LastActivityDate": "2016-04-01T09:15:39.453"}, "36352397": {"ParentId": "36352202", "CommentCount": "0", "Body": "<p>When ++ is after the variable, increment is made after evaluation of the instruction : <code>printf(\"%d\",*q++);</code> is like <code>printf(\"%d\",*q), ++q;</code>.</p>\n<p>So <code>printf</code> prints the \"good\" number, and the pointer is invalidated after that, but the precedence does not change. It is the same in both cases, but in the first case, dereference does nothing.</p>\n", "OwnerUserId": "4498831", "PostTypeId": "2", "Id": "36352397", "Score": "0", "CreationDate": "2016-04-01T09:14:38.417", "LastActivityDate": "2016-04-01T09:14:38.417"}, "36352202": {"CommentCount": "4", "ViewCount": "74", "PostTypeId": "1", "ClosedDate": "2016-04-01T13:24:20.717", "LastEditorUserId": "5649326", "CreationDate": "2016-04-01T09:05:48.047", "LastActivityDate": "2016-04-01T09:20:20.387", "Title": "precedence seems to change in printf", "LastEditDate": "2016-04-01T09:20:20.387", "Id": "36352202", "Score": "-6", "Body": "<p>Suppose you have a int pointer variable, <code>int* q = malloc(sizeof(int))</code></p>\n<p>now doing this </p>\n<pre><code>*q++;\n</code></pre>\n<p><code>q</code> will point to some other memory location since <code>++</code> had precedence right </p>\n<p>however doing the same in printf </p>\n<pre><code>printf(\"%d\",*q++);\n</code></pre>\n<p>gives the dereference(*) operator precedence ?? </p>\n", "Tags": "<c++><c>", "OwnerUserId": "2264687", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_36352202_36352400_0": {"section_id": 6182, "quality": 0.6666666666666666, "length": 8}}, "n3337": {"so_36352202_36352400_0": {"section_id": 5943, "quality": 0.6666666666666666, "length": 8}}, "n4659": {"so_36352202_36352400_0": {"section_id": 7684, "quality": 0.6666666666666666, "length": 8}}}});