post_cb({"12673749": {"ParentId": "12673735", "CommentCount": "6", "Body": "<p>That was probably a trick question. The <code>sizeof(char)</code> is <strong>always</strong> 1.</p>\n<p>If the size differs, it's probably because of a non-conforming compiler, in which case the question should be about the compiler itself, not about the C or C++ language.</p>\n<h3>5.3.3 Sizeof [expr.sizeof]</h3>\n<blockquote>\n<p id=\"so_12673735_12673749_0\">1 <strong>The sizeof operator yields the number of bytes in the object\n  representation of its operand</strong>. The operand is either an expression,\n  which is not evaluated, or a parenthesized type-id. The sizeof\n  operator shall not be applied to an expression that has function or\n  incomplete type, or to an enumeration type before all its enumerators\n  have been declared, or to the parenthesized name of such types, or to\n  an lvalue that designates a bit-field. <strong><code>sizeof(char)</code>, <code>sizeof(signed\n  char)</code> and <code>sizeof(unsigned char)</code> are 1. The result of sizeof applied to any other fundamental type (3.9.1) is\n  implementation-defined.</strong> (emphasis mine)</p>\n</blockquote>\n<p>The sizeof of other types than the ones pointed out are implementation-defined, and they vary for various reasons. An <code>int</code> has better range if it's represented in 64 bits instead of 32, but it's also more efficient as 32 bits on a 32-bit architecture.</p>\n", "OwnerUserId": "673730", "PostTypeId": "2", "Id": "12673749", "Score": "9", "CreationDate": "2012-10-01T12:57:31.283", "LastActivityDate": "2012-10-01T12:57:31.283"}, "12673735": {"CommentCount": "5", "AcceptedAnswerId": "12673749", "PostTypeId": "1", "LastEditorUserId": "784668", "CreationDate": "2012-10-01T12:56:51.610", "LastActivityDate": "2012-10-01T13:35:07.523", "LastEditDate": "2012-10-01T13:05:07.013", "ViewCount": "1009", "FavoriteCount": "1", "Title": "Why do the sizes of data types change as the Operating System changes?", "Id": "12673735", "Score": "5", "Body": "<p>This question was asked to me in an interview, that size of <code>char</code> is 2 bytes in some OS, but in some operating system it is 4 bytes or different.</p>\n<p>Why is that so?</p>\n<p>Why is it different from other fundamental types, such as <code>int</code>?</p>\n", "Tags": "<c++><c><operating-system><size>", "OwnerUserId": "1312147", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_12673735_12673749_0": {"section_id": 6076, "quality": 0.8421052631578947, "length": 48}}, "n3337": {"so_12673735_12673749_0": {"section_id": 5844, "quality": 0.8596491228070176, "length": 49}}, "n4659": {"so_12673735_12673749_0": {"section_id": 7572, "quality": 0.6842105263157895, "length": 39}}}, "12674371": {"ParentId": "12673735", "CommentCount": "0", "Body": "<p>The physical sizes (in terms of the number of bits) of types are usually dictated by the target hardware.</p>\n<p>For example, some CPUs can access memory only in units not smaller than 16-bit. For the best performance, <code>char</code> can then be defined a 16-bit integer. If you want 8-bit chars on this CPU, the compiler has to generate extra code for packing and unpacking of 8-bit values into and from 16-bit memory cells. That extra packing/unpacking code will make your code bigger and slower.</p>\n<p>And that's not the end of it. If you subdivide 16-bit memory cells into 8-bit chars, you effectively introduce an extra bit in addresses/pointers. If normal addresses are 16-bit in the CPU, where do you stick this extra, 17th bit? There are two options:</p>\n<ul>\n<li>make pointers bigger (32-bit, of which 15 are unused) and waste memory and reduce the speed further</li>\n<li>reduce the range of addressable address space by half, wasting memory, and loosing speed</li>\n</ul>\n<p>The latter option can sometimes be practical. For example, if the entire address space is divided in halves, one of which is used by the kernel and the other by user applications, then application pointers will never use one bit in their addresses. You can use that bit to select an 8-bit byte in a 16-bit memory cell.</p>\n<p>C was designed to run on as many different CPUs as possible. This is why the physical sizes of <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>, <code>void*</code>, <code>void(*)()</code>, <code>float</code>, <code>double</code>, <code>long double</code>, <code>wchar_t</code>, etc can vary.</p>\n<p>Now, when we're talking about different physical sizes in different compilers producing code for the same CPU, this becomes more of an arbitrary choice. However, it may be not that arbitrary as it may seem. For example, many compilers for Windows define <code>int</code> = <code>long</code> = 32 bits. They do that to avoid programmer's confusion when using Windows APIs, which expect <code>INT</code> = <code>LONG</code> = 32 bits. Defining <code>int</code> and <code>long</code> as something else would contribute to bugs due to loss of programmer's attention. So, compilers have to follow suit in this case.</p>\n<p>And lastly, the C (and C++) standard operates with <code>chars</code> and <code>bytes</code>. They are the same concept size-wise. But C's bytes aren't your typical 8-bit bytes, they can legally be bigger than that as explained earlier. To avoid confusion you may use the term <code>octet</code>, whose name implies the number 8. A number of protocols uses this word for this very purpose.</p>\n", "OwnerUserId": "968261", "PostTypeId": "2", "Id": "12674371", "Score": "5", "CreationDate": "2012-10-01T13:35:07.523", "LastActivityDate": "2012-10-01T13:35:07.523"}});