post_cb({"47003980": {"Id": "47003980", "PostTypeId": "2", "Body": "<p>Ref-qualifiers is not C++17 feature (looking at the tag of the question), but was a feature introduced in C++11. </p>\n<pre><code>struct Foo\n{\n  void bar() const &amp;  { std::cout &lt;&lt; \"const lvalue Foo\\n\"; }\n  void bar()       &amp;  { std::cout &lt;&lt; \"lvalue Foo\\n\"; }\n  void bar() const &amp;&amp; { std::cout &lt;&lt; \"const rvalue Foo\\n\"; }\n  void bar()       &amp;&amp; { std::cout &lt;&lt; \"rvalue Foo\\n\"; }\n};\n\nconst Foo&amp;&amp; getFoo() { return std::move(Foo()); }\n\nint main()\n{\n  const Foo c_foo;\n  Foo foo;\n\n  c_foo.bar();    // const lvalue Foo\n  foo.bar();      // lvalue Foo\n  getFoo().bar(); // const rvalue Foo\n  Foo().bar();    // rvalue Foo\n}\n</code></pre>\n<p>See e.g. the following blog post for for a brief introduction:</p>\n<ul>\n<li><a href=\"https://akrzemi1.wordpress.com/2014/06/02/ref-qualifiers/\" rel=\"nofollow noreferrer\">Andrzej's C++ blog - Ref-qualifiers</a></li>\n</ul>\n<hr>\n<p>To possibly explain the intent of your recollected quote from the CppCon talk, </p>\n<blockquote>\n<p id=\"so_47002799_47003980_0\">\"... that the only true way of overloading <code>operator=</code> ...\"</p>\n</blockquote>\n<p>we visit <a href=\"http://eel.is/c++draft/over.match.funcs\" rel=\"nofollow noreferrer\">[over.match.funcs]/1, /4 &amp; /5</a> [emphasis mine]:</p>\n<blockquote>\n<p id=\"so_47002799_47003980_1\"><strong>/1</strong> The subclauses of [over.match.funcs] describe the set of candidate functions and the argument list submitted to overload\n  resolution in each context in which overload resolution is used. ...</p>\n<p id=\"so_47002799_47003980_2\"><strong>/4</strong> For non-static member functions, the type of the implicit object parameter is</p>\n<ul>\n<li><p id=\"so_47002799_47003980_3\">(4.1) \u2014 \u201clvalue reference to cv <code>X</code>\u201d for functions declared <strong>without a ref-qualifier or with</strong> the <code>&amp;</code> ref-qualifier</p></li>\n<li><p id=\"so_47002799_47003980_4\">(4.2) \u2014 \u201crvalue reference to cv <code>X</code>\u201d for functions declared with the <code>&amp;&amp;</code> ref-qualifier</p></li>\n</ul>\n<p id=\"so_47002799_47003980_5\">where <code>X</code> is the class of which the function is a member and cv is the\n  cv-qualification on the member function declaration. ...</p>\n<p id=\"so_47002799_47003980_6\"><strong>/5</strong> ... For non-static member functions <strong>declared without a ref-qualifier, an additional rule applies</strong>:</p>\n<ul>\n<li>(5.1) \u2014 even if the implicit object parameter is not const-qualified, <strong>an rvalue can be bound to the parameter as long as\n  in all other respects the argument can be converted to the type of the\n  implicit object parameter.</strong> [\u2009Note: The fact that such an argument is\n  an rvalue does not affect the ranking of implicit conversion\n  sequences. \u2014\u2009end note\u2009]</li>\n</ul>\n</blockquote>\n<p>From /5 above, the following overload (where the explicit <code>&amp;</code> ref-qualifier has been omitted)</p>\n<pre><code>struct test\n{\n    test&amp; operator=(const test&amp;) { return *this }\n}\n</code></pre>\n<p>allows assigning values to r-values, e.g.</p>\n<pre><code>int main()\n{\n    test t1;\n    t1 = test(); // assign to l-value\n    test() = t1; // assign to r-value\n}\n</code></pre>\n<p>However, if we explicitly declare the overload with the <code>&amp;</code> ref-qualifier, <a href=\"http://eel.is/c++draft/over.match.funcs#5.1\" rel=\"nofollow noreferrer\">[over.match.funcs]/5.1</a> does not apply, and as long we do not supply an overload declared with the <code>&amp;&amp;</code> ref-qualifier, r-value assignment will not be allowed.</p>\n<pre><code>struct test\n{\n    test&amp; operator=(const test&amp;) &amp; { return *this; }\n};\n\nint main()\n{\n    test t1;\n    t1 = test(); // assign to l-value\n    test() = t1; // error: passing 'test' as 'this' argument discards qualifiers \n}\n</code></pre>\n<p>I won't place any opinion as to whether explicitly including the <code>&amp;</code> ref-qualifier when declaring custom assignment operator overloads is <em>\"the only true way of overload <code>operator=</code>\"</em>, but would I dare to speculate, then I would guess that the intent behind such a statement is the exclusion of <em>to</em>-r-value assignment, as covered above.</p>\n</hr>", "LastEditorUserId": "4573247", "LastActivityDate": "2017-10-31T19:03:37.330", "Score": "6", "CreationDate": "2017-10-29T18:51:43.983", "ParentId": "47002799", "CommentCount": "0", "OwnerUserId": "4573247", "LastEditDate": "2017-10-31T19:03:37.330"}, "47002897": {"Id": "47002897", "PostTypeId": "2", "Body": "<p>As per <a href=\"http://en.cppreference.com/w/cpp/language/member_functions\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/member_functions</a>\nthe <code>&amp;</code> following your member function declaration is <code>lvalue ref-qualifier</code>.</p>\n<p>In other words, it requires <code>this</code> to be an l-value (<em>the implicit object parameter has type lvalue reference to cv-qualified X</em>). \nThere is also <code>&amp;&amp;</code>, which requires <code>this</code> to be an r-value.</p>\n<p>To copy from documentation (<em>const-, volatile-, and ref-qualified member functions</em>):</p>\n<pre><code>#include &lt;iostream&gt;\nstruct S {\n  void f() &amp; { std::cout &lt;&lt; \"lvalue\\n\"; }\n  void f() &amp;&amp;{ std::cout &lt;&lt; \"rvalue\\n\"; }\n};\n\nint main(){\n  S s;\n  s.f();            // prints \"lvalue\"\n  std::move(s).f(); // prints \"rvalue\"\n  S().f();          // prints \"rvalue\"\n}\n</code></pre>\n", "LastActivityDate": "2017-10-29T17:02:35.640", "CommentCount": "0", "CreationDate": "2017-10-29T17:02:35.640", "ParentId": "47002799", "Score": "2", "OwnerUserId": "6204612"}, "bq_ids": {"n4140": {"so_47002799_47003980_6": {"length": 8, "quality": 0.8888888888888888, "section_id": 569}, "so_47002799_47003980_3": {"length": 6, "quality": 1.0, "section_id": 568}, "so_47002799_47003980_1": {"length": 13, "quality": 0.8125, "section_id": 565}, "so_47002799_47003980_4": {"length": 5, "quality": 1.0, "section_id": 568}, "so_47002799_47003980_2": {"length": 7, "quality": 0.875, "section_id": 568}, "so_47002799_47003980_5": {"length": 8, "quality": 1.0, "section_id": 568}}, "n3337": {"so_47002799_47003980_6": {"length": 8, "quality": 0.8888888888888888, "section_id": 560}, "so_47002799_47003980_3": {"length": 6, "quality": 1.0, "section_id": 559}, "so_47002799_47003980_1": {"length": 13, "quality": 0.8125, "section_id": 556}, "so_47002799_47003980_4": {"length": 5, "quality": 1.0, "section_id": 559}, "so_47002799_47003980_2": {"length": 7, "quality": 0.875, "section_id": 559}, "so_47002799_47003980_5": {"length": 8, "quality": 1.0, "section_id": 559}}, "n4659": {"so_47002799_47003980_6": {"length": 8, "quality": 0.8888888888888888, "section_id": 592}, "so_47002799_47003980_3": {"length": 6, "quality": 1.0, "section_id": 591}, "so_47002799_47003980_1": {"length": 13, "quality": 0.8125, "section_id": 588}, "so_47002799_47003980_4": {"length": 5, "quality": 1.0, "section_id": 591}, "so_47002799_47003980_2": {"length": 7, "quality": 0.875, "section_id": 591}, "so_47002799_47003980_5": {"length": 8, "quality": 1.0, "section_id": 591}}}, "47002799": {"ViewCount": "94", "Body": "<p>I can't remember which talk it was, but recently I watched some talks from CppCon 2017 and there someone mentioned as some kind of side-note, that the only <em>true</em> way of overloading <code>operator=</code> would be in the following fashion:</p>\n<pre><code>class test {\npublic:\n    test&amp; operator=(const test&amp;) &amp;;\n};\n</code></pre>\n<p>He explicitly emphasized the trailing <code>&amp;</code> but didn't say what it does.</p>\n<p>So what does it do?</p>\n", "AcceptedAnswerId": "47003980", "Title": "What does the & (ampersand) at the end of member function signature mean?", "CreationDate": "2017-10-29T16:53:45.197", "Id": "47002799", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-11-01T16:34:25.640", "LastEditorUserId": "167958", "LastActivityDate": "2017-11-01T16:34:25.640", "Score": "3", "OwnerUserId": "7917910", "Tags": "<c++><c++11>", "AnswerCount": "2"}});