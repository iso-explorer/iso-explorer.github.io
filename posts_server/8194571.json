post_cb({"8194621": {"ParentId": "8194571", "CommentCount": "0", "Body": "<p>Pure virtual methods <strong>can</strong> have implementations, but they make the base class abstract and force deriving classes to overwrite those methods.</p>\n<p>Say you have a pointer member in the base class. You want to delete it on the destructor but also make the class abstract - so you implement to pure virtual destructor.</p>\n<p>This is an implementation detail - the fact that the destructor is implemented should't be visible from the outside.</p>\n", "OwnerUserId": "673730", "PostTypeId": "2", "Id": "8194621", "Score": "1", "CreationDate": "2011-11-19T14:20:29.683", "LastActivityDate": "2011-11-19T14:20:29.683"}, "8194628": {"ParentId": "8194571", "CommentCount": "3", "Body": "<p>The destructor is the only method that even if it is pure virtual, has to have an implementation in order for the class it's defined in to be useful. So in contrast to @Kiril's answer I would say that pure virtual functions <strong>can</strong> have implementations.</p>\n<p>Somewhat off topic : </p>\n<pre><code>struct base {\n    virtual void func() = 0;\n};\n\nvoid base::func() { /* default implementation */ }\n\nclass derived : public base{\n    void func() { base::func(); } // have to explicitly call default implementation.\n};\n</code></pre>\n", "OwnerUserId": "880096", "PostTypeId": "2", "Id": "8194628", "Score": "3", "CreationDate": "2011-11-19T14:22:05.017", "LastActivityDate": "2011-11-19T14:22:05.017"}, "8194624": {"ParentId": "8194571", "CommentCount": "1", "Body": "<p>i looked at this page:</p>\n<p><a href=\"http://www.gotw.ca/gotw/031.htm\">http://www.gotw.ca/gotw/031.htm</a></p>\n<p>and from my understanding a pure virtual destructor <strong>must have a definition</strong> (even an empty one) as every derived class has to call the base classes destructor</p>\n", "OwnerUserId": "944201", "PostTypeId": "2", "Id": "8194624", "Score": "7", "CreationDate": "2011-11-19T14:20:52.490", "LastActivityDate": "2011-11-19T14:20:52.490"}, "8194618": {"ParentId": "8194571", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It is invalid syntax to write:</p>\n<pre><code>virtual ~base()=0\n{}\n</code></pre>\n<p>If you want to supply implementation of a pure virtual member function, you should do it outside of the class. Most of the time you should not do this, since pure virtual functions should never be called anyhow. It is however possible to define implementation for pure virtual functions.</p>\n<p>In fact, a pure virtual destructor must have an implementation. This is because destructors of all base classes are called on object destruction regardless of whether destructor in a given class is pure virtual or not.</p>\n<p>Thus, if you create an instance of any of the classes derived from <code>base</code> then at some point destructors of all classes to which the object belongs will be called including the <code>base::~base()</code> destructor. If you do not define it, the linker will not find a required symbol and will complain.</p>\n", "OwnerUserId": "1023815", "LastEditorUserId": "1023815", "LastEditDate": "2011-11-19T14:34:21.740", "Id": "8194618", "Score": "5", "CreationDate": "2011-11-19T14:20:02.317", "LastActivityDate": "2011-11-19T14:34:21.740"}, "8194625": {"ParentId": "8194571", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Your second example is correct.</p>\n<p>A lot of the other answers assume that it is illegal to have a pure virtual function with a default implementation, however that is incorrect. </p>\n<p>In the case of a pure virtual destructor you must have a definition (see the <a href=\"http://www.gotw.ca/gotw/031.htm\">link</a> in xmoex answer).</p>\n<p>It is true that:</p>\n<blockquote>\n<p id=\"so_8194571_8194625_0\">\u00a710.4/2 a function declaration cannot provide both a pure-specifier\n  and a definition</p>\n</blockquote>\n<p>However, as you noticed it possible to provide a definition outside of the declaration.</p>\n", "OwnerUserId": "346804", "LastEditorUserId": "346804", "LastEditDate": "2011-11-19T14:26:53.290", "Id": "8194625", "Score": "11", "CreationDate": "2011-11-19T14:21:22.077", "LastActivityDate": "2011-11-19T14:26:53.290"}, "8194571": {"CommentCount": "3", "AcceptedAnswerId": "8194625", "CreationDate": "2011-11-19T14:11:26.470", "LastActivityDate": "2011-11-19T14:34:21.740", "PostTypeId": "1", "ViewCount": "3984", "FavoriteCount": "3", "Title": "Pure virtual destructor definition inside class gives compilation error", "Id": "8194571", "Score": "12", "Body": "<p>The <code>pure virtual destructor</code> in base class should have a definition. Otherwise compiler will generate a call to base class destructor from the derived class destructor during link-time and will cause a link-error.</p>\n<p>I tried to define the pure virtual destructor inside the base class like below:</p>\n<pre><code>class base\n{\n   public:\n      base()\n      {\n         cout &lt;&lt; \"constructor in base class\\n\";\n      }\n\n      virtual ~base()=0\n      {}\n};\n</code></pre>\n<p>This gave the compilation error:</p>\n<blockquote>\n<p id=\"so_8194571_8194571_0\">error: pure-specifier on function-definition</p>\n</blockquote>\n<p>Then i tried to define the function outside the base class like below:</p>\n<pre><code>class base\n{\n   public:\n      base()\n      {\n         cout &lt;&lt; \"constructor in base class\\n\";\n      }\n\n      virtual ~base()=0;\n};\n\nbase::~base()\n{\n\n}\n</code></pre>\n<p>This removes the compilation error and it behaves as my understanding.</p>\n<p>But my question is how does defining the pure virtual destructor outside the base class removes the compilation error?</p>\n", "Tags": "<c++><inheritance><destructor><pure-virtual>", "OwnerUserId": "1220250", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_8194571_8194625_0": {"section_id": 7019, "quality": 0.875, "length": 7}}, "n3337": {"so_8194571_8194625_0": {"section_id": 6765, "quality": 0.875, "length": 7}}, "n4659": {"so_8194571_8194625_0": {"section_id": 8516, "quality": 0.875, "length": 7}}}});