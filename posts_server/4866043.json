post_cb({"4866043": {"ViewCount": "3773", "Body": "<p>In a mixed C/C++ project, we need to make a call from C to a C++ function. The function to be called is overloaded as three separate functions, but we can ignore that from the C-side, we just pick the one most suitable and stick to that one.</p>\n<p>There's two ways to do this: (1) write a small C++ wrapper with a extern \"C\" function that forwards the call to the chosen overloaded function, or (2) the hackish way to just declare the one function we want to call from C as extern \"C\".</p>\n<p>The question is, is there any disadvantages (apart from nightmares and bad karma) to go for the second variant? In other words, given three overloaded function, where one is declared as exern \"C\", should we expect trouble with the C++ side, or is this well defined according to the standard?</p>\n", "AcceptedAnswerId": "4866087", "Title": "Overload resolution with extern \"C\" linkage", "CreationDate": "2011-02-01T17:44:29.207", "Id": "4866043", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2011-02-01T18:10:03.180", "LastEditorUserId": "126562", "LastActivityDate": "2016-05-09T04:11:56.287", "Score": "9", "OwnerUserId": "270280", "Tags": "<c++><c><function-overloading>", "AnswerCount": "4"}, "4866117": {"Id": "4866117", "PostTypeId": "2", "Body": "<p>Even if it was allowed by the standard, future maintainers of the code will probably be extremely confused and might even remove the extern \"C\", breaking the C code (possibly far enough later that the events aren't linkable).</p>\n<p>Just write the wrapper.</p>\n<p>EDIT:\nFrom C++03 7.5/5:</p>\n<blockquote>\n<p id=\"so_4866043_4866117_0\">If two declarations of the same\n  function or object specify different\n  linkage specifications (that is, the\n  linkage specifications of these\n  declarations specify different\n  string literals), the program is\n  ill-formed if the declarations appear\n  in the same translation unit, and the\n  one definition rule (3.2) applies if\n  the declarations appear in different\n  translation units...</p>\n</blockquote>\n<p>I interpret this to not apply since C and C++ functions with the same name aren't actually the same function but this interpretation may be wrong.</p>\n<p>Then from C++03 7.5/6:</p>\n<blockquote>\n<p id=\"so_4866043_4866117_1\">At most one function with a particular\n  name can have C language linkage...</p>\n</blockquote>\n<p>This then implies that you could have other, non-C-linkage, functions with the same name. In this case, C++ overloads.</p>\n", "LastEditorUserId": "1505939", "LastActivityDate": "2016-05-09T03:56:46.423", "Score": "2", "CreationDate": "2011-02-01T17:51:08.650", "ParentId": "4866043", "CommentCount": "2", "OwnerUserId": "251738", "LastEditDate": "2016-05-09T03:56:46.423"}, "4866087": {"Id": "4866087", "PostTypeId": "2", "Body": "<p>I had said that it was undefined, but rereading the standard, I can't find the language I thought was there. In fact, the example code at \u00a77.5/3 seems to indicate that the result probably <em>is</em> defined -- i.e., you can have other overloads with C++ linkage, as long as there's only one function with \"C\" linkage. The example they show is:</p>\n<pre><code>complex sqrt(complex); // C + + linkage by default\nextern \"C\" {\n    double sqrt(double); // C linkage\n}\n</code></pre>\n<p>Two points: 1) being an example, this isn't normative. 2) It doesn't directly state that both those declarations are actually allowed together in the same program. Nonetheless, I think the intent is that it can be viewed as a single fragment of code which gives defined behavior.</p>\n<p>After rereading, I believe the language in the standard is specifically written to allow exactly one function with \"C\" linkage, and an arbitrary number of other functions with \"C++\" linkage that overload the same name (\u00a77.5/6):</p>\n<blockquote>\n<p id=\"so_4866043_4866087_0\">At most one function with a particular name can have C language linkage. Two declarations for a function with C language linkage with the same function name (ignoring the namespace names that qualify it) that appear in different namespace scopes refer to the same function. Two declarations for an object with C language linkage with the same name (ignoring the namespace names that qualify it) that appear in different namespace scopes refer to the same object.</p>\n</blockquote>\n", "LastEditorUserId": "179910", "LastActivityDate": "2011-02-01T18:08:02.613", "Score": "14", "CreationDate": "2011-02-01T17:48:43.627", "ParentId": "4866043", "CommentCount": "3", "OwnerUserId": "179910", "LastEditDate": "2011-02-01T18:08:02.613"}, "37107630": {"Id": "37107630", "PostTypeId": "2", "Body": "<p>(This answer applies to C++14; other answers so far are C++03).</p>\n<p>It is permitted to use overloading. If there is an <code>extern \"C\"</code> function definition of some particular name then the following conditions apply (references to C++14 in brackets):</p>\n<ul>\n<li>The declaration of the <code>extern \"C\"</code> function must be visible at the point of any declaration or definition of overloads of that function name (7.5/5)</li>\n<li>There must be no other <code>extern \"C\"</code> definition of a function or variable with the same name, anywhere. (7.5/6)</li>\n<li>An overloaded function with the same name must not be declared at global scope. (7.5/6)</li>\n<li>Within the same namespace as the <code>extern \"C\"</code> function, there must not be another function declaration with the same name and parameter list. (7.5/5)</li>\n</ul>\n<p>If any violation of the above rules occurs in the same translation unit the compiler must diagnose it; otherwise it is undefined behaviour with no diagnostic required.</p>\n<p>So your header file might look something like:</p>\n<pre><code>namespace foo\n{\n    extern \"C\" void bar();\n    void bar(int);\n    void bar(std::string);\n}\n</code></pre>\n<p>The last bullet point says that you cannot overload solely on linkage; this is ill-formed:</p>\n<pre><code>namespace foo\n{\n    extern \"C\" void bar();\n    void bar();               // error\n}\n</code></pre>\n<p>However you can do this at different namespaces:</p>\n<pre><code>extern \"C\" void bar();\nnamespace foo\n{\n    void bar();\n}\n</code></pre>\n<p>in which case , normal rules of unqualified lookup determine whether a call <code>bar()</code> in some code finds <code>::bar</code>, <code>foo::bar</code>, or <em>ambiguous</em>.</p>\n", "LastActivityDate": "2016-05-09T04:11:56.287", "CommentCount": "1", "CreationDate": "2016-05-09T04:11:56.287", "ParentId": "4866043", "Score": "1", "OwnerUserId": "1505939"}, "4866302": {"Id": "4866302", "PostTypeId": "2", "Body": "<p>As long as you follow the other rules for extern-C functions (such as their special name requirements), specifying one of the overloads as extern-C is fine according to the standard.  If you happen to use function pointers to these functions, be aware that language linkage is part of the function type, and needing a function pointer to this function may decide the issue for you.</p>\n<p>Otherwise, I don't see any significant disadvantages.  Even the potential disadvantage of copying parameters and return value can be mitigated by compiler- and implementation-specifics that allow you to inline the function \u2013 if that is determined to be a problem.</p>\n<pre><code>namespace your_project {  // You do use one, right? :)\n  void f(int x);\n  void f(char x);\n  void f(other_overloads x);\n}\n\nextern \"C\"\nvoid f(int x) {\n  your_project::f(x);\n}\n</code></pre>\n", "LastActivityDate": "2011-02-01T18:09:14.173", "CommentCount": "2", "CreationDate": "2011-02-01T18:09:14.173", "ParentId": "4866043", "Score": "2", "OwnerUserId": "511601"}, "bq_ids": {"n4140": {"so_4866043_4866087_0": {"length": 44, "quality": 0.9565217391304348, "section_id": 5522}, "so_4866043_4866117_1": {"length": 9, "quality": 1.0, "section_id": 5522}}, "n3337": {"so_4866043_4866087_0": {"length": 44, "quality": 0.9565217391304348, "section_id": 5308}, "so_4866043_4866117_1": {"length": 9, "quality": 1.0, "section_id": 5308}}, "n4659": {"so_4866043_4866087_0": {"length": 44, "quality": 0.9565217391304348, "section_id": 6957}, "so_4866043_4866117_1": {"length": 9, "quality": 1.0, "section_id": 6957}}}});