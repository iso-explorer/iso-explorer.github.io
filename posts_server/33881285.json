post_cb({"33881530": {"ParentId": "33881285", "CommentCount": "3", "Body": "<p>As quoted here <a href=\"http://en.cppreference.com/w/cpp/container/map/rbegin\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/container/map/rbegin</a></p>\n<blockquote>\n<p id=\"so_33881285_33881530_0\">Reverse iterator stores an iterator to the next element than the one it actually refers to</p>\n</blockquote>\n<p>the side effect would be that if you insert something before that iterator (incliding end()) you will see that new value when you dereference that reverse iterator. I do not think that reverse iterator is invalidated in this case.</p>\n", "OwnerUserId": "432358", "PostTypeId": "2", "Id": "33881530", "Score": "3", "CreationDate": "2015-11-23T22:00:57.000", "LastActivityDate": "2015-11-23T22:00:57.000"}, "bq_ids": {"n4140": {"so_33881285_33881710_1": {"section_id": 5600, "quality": 1.0, "length": 14}, "so_33881285_33881710_0": {"section_id": 745, "quality": 0.9375, "length": 15}}, "n3337": {"so_33881285_33881710_1": {"section_id": 5383, "quality": 1.0, "length": 14}, "so_33881285_33881710_0": {"section_id": 734, "quality": 0.9375, "length": 15}}, "n4659": {"so_33881285_33881710_1": {"section_id": 7044, "quality": 1.0, "length": 14}, "so_33881285_33881710_0": {"section_id": 803, "quality": 0.9375, "length": 15}}}, "33881710": {"ParentId": "33881285", "CommentCount": "0", "Body": "<p>According to the C++ Standard (23.2.4 Associative containers)</p>\n<blockquote>\n<p id=\"so_33881285_33881710_0\">9 The insert and emplace members shall not affect the validity of\n  iterators and references to the container, and the erase members shall\n  invalidate only iterators and references to the erased elements.</p>\n</blockquote>\n<p>On the other hand (24.5.1 Reverse iterators)</p>\n<blockquote>\n<p id=\"so_33881285_33881710_1\">1 Class template reverse_iterator is an iterator adaptor that iterates\n  from the end of the sequence defined by its underlying iterator to the\n  beginning of that sequence.</p>\n</blockquote>\n<p>Though in the last quote there is said about class <code>std::reverse_iterator</code> the same is valid for reverse iterators of standard containers.</p>\n<p>According to  Table 97 \u2014 Reversible container requirements</p>\n<p><code>rbegin()</code> corresponds to <code>reverse_iterator(end())</code></p>\n<p>So in your example the reverse iterator still corresponds to <code>end()</code>.\n`</p>\n", "OwnerUserId": "2877241", "PostTypeId": "2", "Id": "33881710", "Score": "4", "CreationDate": "2015-11-23T22:13:16.177", "LastActivityDate": "2015-11-23T22:13:16.177"}, "33907829": {"ParentId": "33881285", "CommentCount": "0", "Body": "<pre><code>std::map&lt;int, int&gt; map2;\nmap2.emplace(2, 2);\nauto fiter = map2.begin();\nstd::cout &lt;&lt; fiter-&gt;first &lt;&lt; \", \" &lt;&lt; fiter-&gt;second &lt;&lt; std::endl;\nmap2.emplace(1, 1);\nstd::cout &lt;&lt; fiter-&gt;first &lt;&lt; \", \" &lt;&lt; fiter-&gt;second &lt;&lt; std::endl;\nfiter = map2.begin();\nstd::cout &lt;&lt; fiter-&gt;first &lt;&lt; \", \" &lt;&lt; fiter-&gt;second &lt;&lt; std::endl;\n</code></pre>\n<p>prints</p>\n<pre><code>2, 2\n2, 2\n1, 1\n</code></pre>\n", "OwnerUserId": "28555", "PostTypeId": "2", "Id": "33907829", "Score": "0", "CreationDate": "2015-11-25T03:06:02.257", "LastActivityDate": "2015-11-25T03:06:02.257"}, "33882062": {"ParentId": "33881285", "LastEditDate": "2015-11-23T22:51:16.980", "CommentCount": "0", "CreationDate": "2015-11-23T22:35:24.143", "OwnerUserId": "2352671", "LastEditorUserId": "2352671", "PostTypeId": "2", "Id": "33882062", "Score": "1", "Body": "<p><code>map.rbegin()</code> returns an iterator that is equal to <code>std::reverse_iterator(map.end());</code></p>\n<p>The problem arises when you dereference a reverse iterator. When you dereference a <code>reverse_iterator</code> the value you actually get is from the iterator before the one is stored inside the <code>reverse_iterator</code>. That might seem strange, but is there for good reasons, and it's unavoidable.  This is so, in order to arrange for the past-the-end element of a range: An iterator pointing to a past-the-end element in a range, when reversed, is pointing to the last element (not past it) of the range (this would be the first element of the reversed range). And if an iterator to the first element in a range is reversed, the reversed iterator points to the element before the first element (this would be the past-the-end element of the reversed range).</p>\n<p>That is, in your case when dereferencing the <code>reverse_iter</code> is equivalent with doing:</p>\n<pre><code>*(--map.end());\n</code></pre>\n<p>Consequently, after the second <code>emplace</code> the last element of the map has changed and dereferencing <code>(--map.end())</code> (i.e., your <code>reverse_iter</code>) you get the new last element in the map.</p>\n", "LastActivityDate": "2015-11-23T22:51:16.980"}, "33881285": {"CommentCount": "5", "CreationDate": "2015-11-23T21:44:52.377", "PostTypeId": "1", "AcceptedAnswerId": "33881530", "LastEditorUserId": "416650", "LastActivityDate": "2015-11-25T03:06:02.257", "LastEditDate": "2015-11-23T21:50:16.420", "ViewCount": "217", "FavoriteCount": "0", "Title": "Is this proper behavior? std::map iterator invalidation", "Id": "33881285", "Score": "5", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nint main(int argc, char** argv)\n{\n  std::map&lt;int, int&gt; map;\n  map.emplace(1, 1);\n  auto reverse_iter = map.rbegin();\n  std::cout &lt;&lt; reverse_iter-&gt;first &lt;&lt; \", \" &lt;&lt; reverse_iter-&gt;second &lt;&lt; std::endl;\n  map.emplace(2, 2);\n  std::cout &lt;&lt; reverse_iter-&gt;first &lt;&lt; \", \" &lt;&lt; reverse_iter-&gt;second &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>\n<p>This prints out:</p>\n<pre><code>1, 1\n2, 2\n</code></pre>\n<p>Is this really what's supposed to happen, according to the standard?  I'm not touching reverse_iter but the value it's pointing to is changing. I thought iterators in std::map were supposed to be safe against insertion. Yet it seems to be deciding that reverse_iter is not to stay pointing to the value I told it to, rather to \"whatever happens to be at the end of the map at this point in time\".</p>\n<p>Update: further info, in case it matters: this doesn't seem to happen with forward iterators (in any situation I can seem to find), and my gcc version is 5.1.1-4.</p>\n", "Tags": "<c++><iterator><stdmap>", "OwnerUserId": "416650", "AnswerCount": "4"}});