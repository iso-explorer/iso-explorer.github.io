post_cb({"26982720": {"ParentId": "26982648", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>If by \"illegal\" you mean ill-formed, then it is illegal if the base class is inaccessible or ambiguous.</p>\n<ul>\n<li><p>It is inaccessible when, for example, the base class is private.</p>\n<pre><code>class A {};\nclass B : A {};\n...\nB b;\nA *pa = &amp;b; // ERROR: base class is inaccessible\n</code></pre>\n<p>Note that even in C++11 a C-style cast can \"break through\" access protection and perform a formally correct upcast </p>\n<pre><code>A *pa = (A *) &amp;b; // OK, not a `reinterpret_cast`, but a valid upcast\n</code></pre>\n<p>This usage should be avoided, of course.</p></li>\n<li><p>It is ambiguous if your source type contains multiple base subobjects of the target type (through multiple inheritance).</p>\n<pre><code>class A {};\nclass B : public A {};\nclass C : public A {};\nclass D : public B, public C {};\n\nD d;\nA *pa = &amp;d; // ERROR: base class is ambiguous\n</code></pre>\n<p>In such cases the upcast can be performed by explicitly \"walking\" the desired upcast path with intermediate upcasts to the point where the base is no longer ambiguous</p>\n<pre><code>B* pb = &amp;d;\nA* pa = pb; // OK: points to 'D::B::A' subobject\n</code></pre></li>\n</ul>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2014-11-18T06:37:47.437", "Id": "26982720", "Score": "48", "CreationDate": "2014-11-17T21:54:54.347", "LastActivityDate": "2014-11-18T06:37:47.437"}, "26982763": {"ParentId": "26982648", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>There are two cases in which upcasting is ill-formed in C++ (diagnosed at compile-time):</p>\n<ol>\n<li><p>The base-class in question is <strong>not accessible</strong>:</p>\n<pre><code>class base {};\nclass derived : base {};\n\nint main() {\n    derived x;\n    base&amp; y = x; // invalid because not accessible.\n    // Solution: C-style cast (as static_cast without access-check)\n    base&amp; y1 = (base&amp;)x;\n}\n</code></pre></li>\n<li><p>The base-class sub-object in question is <strong>not unambiguous</strong>:</p>\n<pre><code>class base {};\nstruct A1 : base {};\nstruct A2 : base {};\n\nstruct derived : A1, A2 {};\nint main() {\n    derived x;\n    base&amp; y = x; // invalid because ambiguous.\n    // Solution 1, scope resolution:\n    base&amp; y1 = static_cast&lt;A1::base&amp;&gt;(x);\n    base&amp; y2 = static_cast&lt;A2::base&amp;&gt;(x);\n    // Solution 2, intermediate unambiguous steps:\n    A1&amp; a1 = x;\n    A2&amp; a2 = x;\n    base&amp; ya1 = a1;\n    base&amp; ya2 = a2;\n}\n</code></pre></li>\n</ol>\n", "OwnerUserId": "3204551", "LastEditorUserId": "3204551", "LastEditDate": "2014-11-17T22:12:27.907", "Id": "26982763", "Score": "10", "CreationDate": "2014-11-17T21:58:15.213", "LastActivityDate": "2014-11-17T22:12:27.907"}, "26982722": {"ParentId": "26982648", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>If the base class is ambiguous (inherited two or more times via different paths) then you can\u2019t do an upcast in a single step.</p>\n<p>If the base class is inaccessible then the only way to upcast is to use a C style cast. This is a special case of that cast, it's the only one that can do the job. Essentially it then behaves as a <code>static_cast</code> that's not limited by accessibility.</p>\n<hr>\n<p>Standardese.</p>\n<p>C++11 \u00a75.4/4:</p>\n<blockquote>\n<p id=\"so_26982648_26982722_0\"><strong>\u201d</strong> \u2026 in [a C cast] performing a <code>static_cast</code> in the following situations the conversion\n  is valid even if the base class is inaccessible:  </p>\n<ul>\n<li>a pointer to an object of derived class type or an lvalue or rvalue of derived class type may be explicitly\n  converted to a pointer or reference to an unambiguous base class type, respectively;  </li>\n<li>a pointer to member of derived class type may be explicitly converted to a pointer to member of an\n  unambiguous non-virtual base class type;  </li>\n<li>a pointer to an object of an unambiguous non-virtual base class type, a glvalue of an unambiguous\n  non-virtual base class type, or a pointer to member of an unambiguous non-virtual base class type may be explicitly converted to a pointer, a reference, or a pointer to member of a derived class type,\n  respectively.</li>\n</ul>\n</blockquote>\n<hr>\n<p>Example of ambiguity:</p>\n<pre><code>struct Base {};\nstruct M1: Base {};\nstruct M2: Base {};\nstruct Derived: M1, M2 {};\n\nauto main() -&gt; int\n{\n    Derived d;\n    //static_cast&lt;Base&amp;&gt;( d );                      //! Ambiguous\n    static_cast&lt;Base&amp;&gt;( static_cast&lt;M2&amp;&gt;( d ) );    // OK\n}\n</code></pre>\n<hr>\n<p>Example of inaccessible base, with (usually) address adjustment in the cast:</p>\n<pre><code>struct Base { int value; Base( int x ): value( x ) {} };\n\nclass Derived\n    : private Base\n{\npublic:\n    virtual ~Derived() {}       // Just to involve an address adjustment.\n    Derived(): Base( 42 ) {}\n};\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nauto main() -&gt; int\n{\n    Derived d;\n    Base&amp; b = (Base&amp;) d;\n    cout &lt;&lt; \"Derived at \" &lt;&lt; &amp;d &lt;&lt; \", base at \" &lt;&lt; &amp;b &lt;&lt; endl;\n    cout &lt;&lt; b.value &lt;&lt; endl;\n};\n</code></pre>\n</hr></hr></hr>", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2014-11-17T22:31:34.990", "Id": "26982722", "Score": "17", "CreationDate": "2014-11-17T21:55:01.847", "LastActivityDate": "2014-11-17T22:31:34.990"}, "bq_ids": {"n4140": {"so_26982648_26982722_0": {"section_id": 6126, "quality": 1.0, "length": 11}}, "n3337": {"so_26982648_26982722_0": {"section_id": 5890, "quality": 1.0, "length": 11}}, "n4659": {"so_26982648_26982722_0": {"section_id": 7623, "quality": 1.0, "length": 11}}}, "26982648": {"CommentCount": "2", "CreationDate": "2014-11-17T21:50:29.697", "PostTypeId": "1", "AcceptedAnswerId": "26982720", "LastEditorUserId": "63550", "LastActivityDate": "2017-11-23T13:13:39.337", "LastEditDate": "2017-11-23T13:13:39.337", "ViewCount": "6244", "FavoriteCount": "9", "Title": "When is upcasting illegal in C++?", "Id": "26982648", "Score": "56", "Body": "<p>I am pretty sure I understand the general difference between upcasting and downcasting, particularly in C++. I understand that we can't always downcast because casting a base class pointer to a derived class pointer would assume that the base class object being pointed to has all the members of the derived class.</p>\n<p>Early in the semester, my professor told the class that it is also sometimes illegal to upcast in C++, but I seem to have missed the reason why in my notes, and I can't remember when this occurs.</p>\n<p>When is it illegal to upcast in C++?</p>\n", "Tags": "<c++><class><base><derived><downcast>", "OwnerUserId": "4154419", "AnswerCount": "3"}});