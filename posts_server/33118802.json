post_cb({"bq_ids": {"n4140": {"so_33118802_33119199_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 5405}, "so_33118802_33119199_0": {"length": 4, "quality": 1.0, "section_id": 5401}}, "n3337": {"so_33118802_33119199_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 5200}, "so_33118802_33119199_0": {"length": 4, "quality": 1.0, "section_id": 5196}}, "n4659": {"so_33118802_33119199_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 6827}, "so_33118802_33119199_0": {"length": 4, "quality": 1.0, "section_id": 6826}}}, "33119199": {"Id": "33119199", "PostTypeId": "2", "Body": "<p>A member function that is not a function template itself can be marked as <code>virtual</code>, even if it's part of a class template, however:</p>\n<p>\u00a7 7.1.2 [dcl.fct.spec]/p1:</p>\n<blockquote>\n<p id=\"so_33118802_33119199_0\"><em>Function-specifiers</em> can be used only in function declarations.</p>\n<pre><code>function-specifier:\n    inline\n    virtual\n    explicit\n</code></pre>\n<p id=\"so_33118802_33119199_1\">The <code>virtual</code> specifier shall be <strong>used only in the initial declaration</strong> of a non-static class member function; see 10.3.</p>\n</blockquote>\n<p>That is, you should remove a <code>virtual</code> keyword from the out-of-class definition:</p>\n<pre><code>template&lt;class T&gt;\nvirtual linearLinkedList&lt;T&gt;::myIterator::~myIterator() { ... }\n~~~~~~^ to be removed\n</code></pre>\n", "LastActivityDate": "2015-10-14T07:29:23.913", "CommentCount": "0", "CreationDate": "2015-10-14T07:29:23.913", "ParentId": "33118802", "Score": "3", "OwnerUserId": "3953764"}, "33118802": {"ViewCount": "144", "Body": "<p>I have an inner class, <code>myIterator</code>, of my template class <code>linearLinkedList&lt;T&gt;</code>, and I'd like to override inherited virtual methods from <code>simpleIterator&lt;T&gt;</code>, but the compiler is rejecting them as \"templates may not be virtual.\" Based on <a href=\"https://stackoverflow.com/questions/4961909/templates-may-not-be-virtual\">this question</a>, though, it seems like this should be possible, as it only depends on the class's type. For example method <code>foo</code> in my code below is legal. How can I implement the virtual functions of the inner class?</p>\n<pre><code>template &lt;class T&gt;\nclass linearLinkedList\n{\npublic:\n...\nvirtual void foo(T data); //OK\nsimpleIterator&lt;T&gt; * iterator();\nprivate:\n...\nclass myIterator : public simpleIterator&lt;T&gt;\n{\n  public:\n    myIterator(node&lt;T&gt; ** head);\n    virtual ~myIterator(); //inherited from simpleIterator; error when implemented\n  private:\n    node&lt;T&gt; ** prev;\n    node&lt;T&gt; ** next;\n    //functions inherited from simpleIterator&lt;T&gt;:\n    virtual bool hasNext_impl(); //error when implemented\n    virtual T next_impl();\n    virtual void remove_impl();\n};\n...\ntemplate&lt;class T&gt;\nvirtual linearLinkedList&lt;T&gt;::myIterator::~myIterator() { ... }\n-&gt;\nlinearLinkedList.h:213:1: error: templates may not be \u00e2virtual\u00e2\nvirtual linearLinkedList&lt;T&gt;::myIterator::~myIterator()\n</code></pre>\n", "AcceptedAnswerId": "33119199", "Title": "How to write virtual function in inner class of template class?", "CreationDate": "2015-10-14T07:08:49.197", "Id": "33118802", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:29:53.007", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-14T07:29:23.913", "Score": "4", "OwnerUserId": "1914005", "Tags": "<c++><templates><inner-classes><virtual-functions>", "AnswerCount": "1"}});