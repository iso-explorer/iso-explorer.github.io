post_cb({"bq_ids": {"n4140": {"so_26435084_26435208_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5440}, "so_26435084_26435208_1": {"length": 9, "quality": 0.9, "section_id": 6005}, "so_26435084_26435208_2": {"length": 8, "quality": 1.0, "section_id": 5862}}, "n3337": {"so_26435084_26435208_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 5235}, "so_26435084_26435208_1": {"length": 9, "quality": 0.9, "section_id": 5773}, "so_26435084_26435208_2": {"length": 8, "quality": 1.0, "section_id": 5632}}, "n4659": {"so_26435084_26435208_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 6867}, "so_26435084_26435208_1": {"length": 8, "quality": 0.8, "section_id": 7504}, "so_26435084_26435208_2": {"length": 8, "quality": 1.0, "section_id": 7345}}}, "26435194": {"Id": "26435194", "PostTypeId": "2", "Body": "<p><a href=\"http://coliru.stacked-crooked.com/a/c72b8dc832d38c3c\" rel=\"nofollow noreferrer\">g++4.9 issues the same error</a></p>\n<p><s>I'm not sure if this is an invalid code, because incomplete types are allowed for <code>declval</code>, and expression in <code>decltype</code> is not evaluated.</s><br>\n<a href=\"https://stackoverflow.com/a/26435208/3959454\">rightf\u00f8ld in his answer</a> explained very good why this code is invalid.</br></p>\n<p>You can use <a href=\"http://en.cppreference.com/w/cpp/types/result_of\" rel=\"nofollow noreferrer\">std::result_of</a>:</p>\n<pre><code>using bar_type = std::result_of&lt;decltype(&amp;foo::bar)(foo)&gt;::type;\n</code></pre>\n<p>Which is actually implemented like this:</p>\n<pre><code>using bar_type = decltype((std::declval&lt;foo&gt;().*std::declval&lt;decltype(&amp;foo::bar)&gt;())());\n</code></pre>\n<p>The difference between this and the code in the question is that pointer-to-member operator (<code>.*</code>) is used instead of member access operator (<code>.</code>), and it doesn't require the type to be complete, which is demonstrated by this code:</p>\n<pre><code>#include &lt;utility&gt;\nstruct foo;\nint main() {\n    int (foo::*pbar)();\n    using bar_type = decltype((std::declval&lt;foo&gt;().*pbar)());\n}\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-18T01:06:37.013", "Score": "9", "CreationDate": "2014-10-18T00:34:22.843", "ParentId": "26435084", "CommentCount": "3", "OwnerUserId": "3959454", "LastEditDate": "2017-05-23T12:34:25.273"}, "26435084": {"ViewCount": "1422", "Body": "<p>The following program yields a compilation error with <code>clang</code>, though it passes on other compilers:</p>\n<pre><code>#include &lt;utility&gt;\n\nstruct foo\n{\n  auto bar() -&gt; decltype(0)\n  {\n    return 0;\n  }\n\n  using bar_type = decltype(std::declval&lt;foo&gt;().bar());\n};\n\nint main()\n{\n  return 0;\n}\n</code></pre>\n<p><code>clang</code> yields:</p>\n<pre><code>$ clang -std=c++11 clang_repro.cpp \nclang_repro.cpp:10:48: error: member access into incomplete type 'foo'\n  using bar_type = decltype(std::declval&lt;foo&gt;().bar());\n                                               ^\nclang_repro.cpp:3:8: note: definition of 'foo' is not complete until the closing '}'\nstruct foo\n       ^\n1 error generated.\n</code></pre>\n<p>Is this program illegal, and if so, is there a correct way to define <code>foo::bar_type</code>?</p>\n<p><code>clang</code> details:</p>\n<pre><code>$ clang --version\nUbuntu clang version 3.5-1ubuntu1 (trunk) (based on LLVM 3.5)\nTarget: x86_64-pc-linux-gnu\nThread model: posix\n</code></pre>\n", "AcceptedAnswerId": "26435194", "Title": "How to get the return type of a member function from within a class?", "CreationDate": "2014-10-18T00:15:13.927", "Id": "26435084", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-10-18T00:20:31.317", "LastEditorUserId": "722294", "LastActivityDate": "2014-10-18T01:06:37.013", "Score": "10", "OwnerUserId": "722294", "Tags": "<c++><clang><return-type-deduction>", "AnswerCount": "2"}, "26435208": {"Id": "26435208", "PostTypeId": "2", "Body": "<p>\u00a77.1.6.2 says:</p>\n<blockquote>\n<p id=\"so_26435084_26435208_0\">For an expression <code>e</code>, the type denoted by <code>decltype(e)</code> is defined as follows:</p>\n<ul>\n<li>if <code>e</code> is an unparenthesized id-expression or an unparenthesized class member access (5.2.5), <code>decltype(e)</code> is the type of the entity named by <code>e</code>. \u2026</li>\n<li>\u2026</li>\n</ul>\n</blockquote>\n<p>\u00a75.2.5 says:</p>\n<blockquote>\n<p id=\"so_26435084_26435208_1\">For the first option (dot) the first expression shall have complete class type. \u2026</p>\n</blockquote>\n<p>\u00a79.2 says:</p>\n<blockquote>\n<p id=\"so_26435084_26435208_2\">A class is considered a completely-defined object type (3.9) (or complete type) at the closing <code>}</code> of the class-specifier. \u2026</p>\n</blockquote>\n<p><code>decltype(std::declval&lt;foo&gt;().bar())</code> (and in turn <code>std::declval&lt;foo&gt;().bar()</code>) appears before the closing <code>}</code>, so <code>foo</code> is incomplete, so <code>std::declval&lt;foo&gt;().bar()</code> is ill-formed, so clang is correct.</p>\n", "LastEditorUserId": "1804599", "LastActivityDate": "2014-10-18T00:47:00.483", "Score": "6", "CreationDate": "2014-10-18T00:37:03.987", "ParentId": "26435084", "CommentCount": "2", "OwnerUserId": "1804599", "LastEditDate": "2014-10-18T00:47:00.483"}});