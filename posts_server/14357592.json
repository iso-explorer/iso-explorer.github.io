post_cb({"14357592": {"CommentCount": "0", "ViewCount": "67", "CreationDate": "2013-01-16T11:40:51.373", "LastActivityDate": "2013-01-16T12:00:50.743", "Title": "Is it true that in the union of the object with the structure, which contains only one this object, they will definitely match each other?", "AcceptedAnswerId": "14357987", "PostTypeId": "1", "Id": "14357592", "Score": "0", "Body": "<p>Is it true that by the standard, in the union of the object with the structure, which contains only one this object, they will definitely match each other?\nAnd is the following code correctly for all types?</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct T {\n  int a;\n  float b;\n  // many other types...\n};\n\nunion T_union {\n T t1;\n struct T_owner {\n  T t;\n } t2;\n};\n\nint main() {\n    T_union un;\n    un.t1.a = 10;\n    cout &lt;&lt; un.t2.t.a &lt;&lt; endl; // I can always do that?\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "1558037", "AnswerCount": "1"}, "14357987": {"ParentId": "14357592", "CommentCount": "1", "Body": "<p>9.5 [class.union] reads:</p>\n<blockquote>\n<p id=\"so_14357592_14357987_0\">One special guarantee is made in order to simplify the use of unions:\n  If a standard-layout union contains several standard-layout structs\n  that share a common initial sequence (9.2), and if an object of this\n  standard-layout union type contains one of the standard-layout\n  structs, it is permitted to inspect the common initial sequence of any\n  of standard-layout struct members.</p>\n</blockquote>\n<p>Structs <code>T</code> and <code>T_owner</code> are standard-layout structs because they only have members of scalar (for <code>T</code>) or standard-layout struct (for <code>T_owner</code>) type and none of the other  (not really relevant to this discussion) constraints specified in 9/7 is violated.</p>\n<p>9.2/19 specifies when there is a common initial sequence:</p>\n<blockquote>\n<p id=\"so_14357592_14357987_1\">Two standard-layout structs share a common initial sequence if\n  corresponding members have layout-compatible types and either neither\n  member is a bit-field or both are bit-fields with the same width for a\n  sequence of one or more initial members.</p>\n</blockquote>\n<p>I interpret this paragraph as saying that there is actually <em>no</em> common initial sequence: the first member of <code>T</code> is an <code>int</code>, while the first member of <code>T_owner</code> is a <code>T</code>. AFAIK these two types are not layout-compatible by the standard's definition, so technically the answer is \"you can't do that\".</p>\n<p>What you can certainly do is this:</p>\n<pre><code>union T_union {\n    T t1;\n    T t2;\n};\n\nint main() {\n    T_union un;\n    un.t1.a = 10;\n    cout &lt;&lt; un.t2.a &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>Of course in practice it's highly unlikely that any compiler would not do the right thing here.</p>\n", "OwnerUserId": "50079", "PostTypeId": "2", "Id": "14357987", "Score": "0", "CreationDate": "2013-01-16T12:00:50.743", "LastActivityDate": "2013-01-16T12:00:50.743"}, "bq_ids": {"n4140": {"so_14357592_14357987_0": {"section_id": 5913, "quality": 1.0, "length": 34}, "so_14357592_14357987_1": {"section_id": 5878, "quality": 1.0, "length": 25}}, "n3337": {"so_14357592_14357987_0": {"section_id": 5685, "quality": 1.0, "length": 34}, "so_14357592_14357987_1": {"section_id": 5649, "quality": 1.0, "length": 25}}, "n4659": {"so_14357592_14357987_0": {"section_id": 7404, "quality": 0.9705882352941176, "length": 33}, "so_14357592_14357987_1": {"section_id": 7359, "quality": 0.6, "length": 15}}}});