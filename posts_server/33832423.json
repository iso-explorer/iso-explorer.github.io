post_cb({"bq_ids": {"n4140": {"so_33832423_33832712_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 3296}, "so_33832423_33832712_1": {"length": 30, "quality": 0.967741935483871, "section_id": 3293}, "so_33832423_33832423_0": {"length": 16, "quality": 1.0, "section_id": 3325}}, "n3337": {"so_33832423_33832712_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 3166}, "so_33832423_33832712_1": {"length": 30, "quality": 0.967741935483871, "section_id": 3163}, "so_33832423_33832423_0": {"length": 11, "quality": 0.6875, "section_id": 3195}}, "n4659": {"so_33832423_33832712_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 4058}, "so_33832423_33832423_0": {"length": 16, "quality": 1.0, "section_id": 4091}}}, "33832423": {"ViewCount": "256", "Body": "<p>In C++14:</p>\n<p>For any integral or enumeration type <code>T</code> and for any expression <code>expr</code>:</p>\n<p>Is there ever a difference between:</p>\n<pre><code>struct S { T t { expr }; };\n</code></pre>\n<p>and</p>\n<pre><code>struct S { T t = { expr }; };\n</code></pre>\n<p><strong>Update:</strong></p>\n<p>I got to <code>[dcl.init.list]p3b5</code> which says:</p>\n<blockquote>\n<p id=\"so_33832423_33832423_0\">If the initializer list has a single element of type E and either T is not a reference type or its referenced type is reference-related to E, the object or reference is initialized from that element.</p>\n</blockquote>\n<p>I believe this quote applies to both <em>direct-list-initialization</em> and <em>copy-list-initialization</em>.</p>\n<p>So I think the answer is no, there is no difference.</p>\n", "AcceptedAnswerId": "33832712", "Title": "Difference between T t {x} and T t = { x } for integral or enumeration type?", "CreationDate": "2015-11-20T17:15:23.200", "Id": "33832423", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-12-23T12:41:32.877", "LastEditorUserId": "3552770", "LastActivityDate": "2017-05-21T14:34:48.310", "Score": "10", "OwnerUserId": "1131467", "Tags": "<c++><initialization><language-lawyer><c++14>", "AnswerCount": "2"}, "33832712": {"Id": "33832712", "PostTypeId": "2", "Body": "<p>If you take a look at <a href=\"http://en.cppreference.com/w/cpp/language/direct_initialization\" rel=\"nofollow noreferrer\">direct initialization</a> and <a href=\"http://en.cppreference.com/w/cpp/language/copy_initialization\" rel=\"nofollow noreferrer\">copy initialization</a> references, you will find the same words:</p>\n<blockquote>\n<p id=\"so_33832423_33832712_0\">if T is a non-class type, standard conversions are used, if necessary, to convert the value of other to the cv-unqualified version of T</p>\n</blockquote>\n<p>so there should be no difference. The difference of these initializations only applies for class types: <em>copy initialization</em> does <em>not</em> consider <code>explicit</code> constructors and <code>explicit</code> user-defined conversion operators, <em>direct initialization</em> does. Integral and enumeration types have neither of them.</p>\n<p><strong>Edit:</strong><br>\n<a href=\"https://stackoverflow.com/a/1051468/3552770\">@\u1405 Johannes Schaub - litb \u140a answered a relative question to this one</a> (only about parentheses, instead of braces) and he referenced <code>8.5/14</code> with similar wording (emphasis mine):</br></p>\n<blockquote>\n<p id=\"so_33832423_33832712_1\"><strong>The form of initialization (using parentheses or =) is generally\n  insignificant, but does matter when the initializer or the entity\n  being initialized has a class type</strong>; see below. If the entity being\n  initialized does not have class type, the expression-list in a\n  parenthesized initializer shall be a single expression.</p>\n</blockquote>\n<p>I could not find the <code>{}</code> counterpart in the standard, either. I hope that this is enough arguments to support the <strong>there's no difference</strong> answer.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-05-21T14:34:48.310", "Score": "5", "CreationDate": "2015-11-20T17:32:53.870", "ParentId": "33832423", "CommentCount": "8", "LastEditDate": "2017-05-23T11:55:10.630", "OwnerUserId": "3552770"}, "33833016": {"Id": "33833016", "PostTypeId": "2", "Body": "<ol>\n<li><code>struct S {T t { expr };};</code>  is a non-static data member initializer\nthat <strong>does not use the equals sign</strong>.</li>\n<li><code>struct S{T t = { expr };};</code> is a non-static data member initializer\nthat <strong>uses the equals sign</strong>.</li>\n</ol>\n<p>The first case is a <em>direct-list-initialization</em> while the second is a <em>copy-list-initialization</em>.</p>\n<p>The difference between <em>direct-list-initialization</em> and <em>copy-list-initialization</em> is that for the first case <strong>both</strong> explicit and non-explicit constructors are considered, while for the second <strong>only</strong> non-explicit constructors may be called.</p>\n<p>To clarify, consider the following example:</p>\n<pre><code>struct Foo {\n  int i;\n  explicit Foo(int i_) : i(i_) {}\n};\n\nstruct Bar {\n  Foo f {1};  \n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/247e135b7e748e60\" rel=\"nofollow\"><strong>Live Demo</strong></a></p>\n<p>In this example <code>Foo</code> has an <code>explicit</code> constructor and <code>Bar</code> direct initializes its member <code>f</code> of type <code>Foo</code>. The example code compiles fine since for direct initialization both <code>explicit</code> and <code>non-explicit</code> constructors are considered.</p>\n<p>Now we alter the example by transforming the non-static data member initializer with no use of equal sign, that is a case of direct-list-initialization to a non-static data member initializer with use of equal sign, which is a case of copy-list-initialization.</p>\n<pre><code>struct Foo {\n  int i;\n  explicit Foo(int i_) : i(i_) {}\n};\n\nstruct Bar {\n  Foo f = {1};  \n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/375831085e13e846\" rel=\"nofollow\"><strong>Live Demo</strong></a></p>\n<p>Now the above example doesn't compile and emits an error: </p>\n<blockquote>\n<p id=\"so_33832423_33833016_0\">error: chosen constructor is explicit in copy-initialization</p>\n</blockquote>\n<p>This is expected because as already been mentioned in copy-list-initialization only non-explicit constructors may called.</p>\n<p><strong>Now for enumerators and other integral types, the difference displayed above won't apply (i.e., no constructors are involved). As such, the two statements (i.e., [1] and [2]) would be equivalent.</strong></p>\n<p>But for completeness sake, lets consider the following examples:</p>\n<pre><code>enum class Foo {A, B, C};\n\nstruct Bar {\n  Foo f{Foo::A};  \n};\n</code></pre>\n<p>and</p>\n<pre><code>enum class Foo {A, B, C};\n\nstruct Bar {\n  Foo f = {Foo::A};  \n};\n</code></pre>\n<p>Both the examples compile fine.</p>\n<p>Also consider the following examples:</p>\n<pre><code>struct Bar {\n  int i {1};  \n};\n</code></pre>\n<p>and </p>\n<pre><code>struct Bar {\n  int i = {1};  \n};\n</code></pre>\n<p>Both examples also compile fine.</p>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2015-11-21T14:38:39.447", "Score": "1", "CreationDate": "2015-11-20T17:50:32.547", "ParentId": "33832423", "CommentCount": "2", "LastEditDate": "2015-11-21T14:38:39.447", "OwnerUserId": "2352671"}});