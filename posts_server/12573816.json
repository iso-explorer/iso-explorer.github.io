post_cb({"20358542": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><strong>If all else fails, recompile.</strong></p>\n<p>I was recently able to get rid of an unresolved external error in Visual Studio 2012 just by recompiling the offending file. When I re-built, the error went away. </p>\n<p>This usually happens when two (or more) libraries have a cyclic dependency. Library A attempts to use symbols in B.lib and library B attempts to use symbols from A.lib. Neither exist to start off with. When you attempt to compile A, the link step will fail because it can't find B.lib. A.lib will be generated, but no dll. You then compile B, which will succeed and generate B.lib. Re-compiling A will now work because B.lib is now found.</p>\n", "OwnerUserId": "1704355", "LastEditorUserId": "673730", "LastEditDate": "2013-12-03T20:56:14.800", "Id": "20358542", "Score": "52", "CreationDate": "2013-12-03T18:11:27.867", "LastActivityDate": "2013-12-03T20:56:14.800"}, "12574417": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "1", "Body": "<h3>Template implementations not visible.</h3>\n<p>Unspecialized templates must have their definitions visible to all translation units that use them. That means you can't separate the definition of a template\nto an implementation file. If you must separate the implementation, the usual workaround is to have an <code>impl</code> file which you include at the end of the header that\ndeclares the template. A common situation is:</p>\n<pre><code>template&lt;class T&gt;\nstruct X\n{\n    void foo();\n};\n\nint main()\n{\n    X&lt;int&gt; x;\n    x.foo();\n}\n\n//differentImplementationFile.cpp\ntemplate&lt;class T&gt;\nvoid X&lt;T&gt;::foo()\n{\n}\n</code></pre>\n<p>To fix this, you must move the definition of <code>X::foo</code> to the header file or some place visible to the translation unit that uses it.</p>\n<p>Specialized templates can be implemented in an implementation file and the implementation doesn't have to be visible, but the specialization must be previously declared.</p>\n<p>For further explanation and another possible solution (explicit instantiation) see <a href=\"https://stackoverflow.com/questions/495021\">this question and answer</a>.</p>\n", "OwnerUserId": "673730", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:46.517", "Id": "12574417", "Score": "44", "CreationDate": "2012-09-24T23:38:55.287", "LastActivityDate": "2015-02-16T08:31:49.523"}, "12573816": {"CommentCount": "9", "AcceptedAnswerId": "12573818", "PostTypeId": "1", "LastEditorUserId": "1151329", "CreationDate": "2012-09-24T22:27:40.680", "LastActivityDate": "2017-11-18T03:51:35.460", "LastEditDate": "2014-08-04T13:33:56.667", "ViewCount": "366961", "FavoriteCount": "389", "Title": "What is an undefined reference/unresolved external symbol error and how do I fix it?", "Id": "12573816", "Score": "1045", "Body": "<p>What are undefined reference/unresolved external symbol errors? What are common causes and how to fix/prevent them?</p>\n<p><sub>Feel free to edit/add your own.</sub></p>\n", "Tags": "<c++><linker-errors><undefined-reference><c++-faq><unresolved-external>", "OwnerUserId": "673730", "AnswerCount": "27"}, "29350920": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong>A wrapper around GNU ld that doesn't support linker scripts</strong></p>\n<p>Some .so files are actually <a href=\"https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Using_ld_the_GNU_Linker/simple-commands.html\">GNU ld linker scripts</a>, e.g. <a href=\"https://www.threadingbuildingblocks.org/download\">libtbb.so</a> file is an ASCII text file with this contents:</p>\n<pre><code>INPUT (libtbb.so.2)\n</code></pre>\n<p>Some more complex builds may not support this. For example, if you include -v in the compiler options, you can see that the <a href=\"http://www.mainsoft.com/content/mainsoft-unix-and-linux-overview\">mainwin gcc wrapper mwdip</a> discards linker script command files in the verbose output list of libraries to link in. A simple work around is to replace the linker script input command file with a copy of the file instead (or a symlink), e.g.</p>\n<pre><code>cp libtbb.so.2 libtbb.so\n</code></pre>\n<p>Or you could replace the -l argument with the full path of the .so, e.g. instead of <code>-ltbb</code> do <code>/home/foo/tbb-4.3/linux/lib/intel64/gcc4.4/libtbb.so.2</code></p>\n", "OwnerUserId": "1007353", "LastEditorUserId": "1007353", "LastEditDate": "2015-03-30T20:47:37.097", "Id": "29350920", "Score": "14", "CreationDate": "2015-03-30T16:03:16.230", "LastActivityDate": "2015-03-30T20:47:37.097"}, "29610614": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>This is one of most confusing error messages that every VC++ programmers have seen time and time again. Let\u2019s make things clarity first.</p>\n<p><strong>A. What is symbol?</strong>\nIn short, a symbol is a name. It can be a variable name, a function name, a class name, a typedef name, or anything except those names and signs that belong to C++ language. It is user defined or introduced by a dependency library (another user-defined).</p>\n<p><strong>B. What is external?</strong>\nIn VC++, every source file (.cpp,.c,etc.) is considered as a translation unit, the compiler compiles one unit at a time, and generate one object file(.obj) for the current translation unit. (Note that every header file that this source file included will be preprocessed and will be considered as part of this translation unit)Everything within a translation unit is considered as internal, everything else is considered as external. In C++, you may reference an external symbol by using keywords like <code>extern</code>, <code>__declspec (dllimport)</code> and so on.</p>\n<p><strong>C. What is \u201cresolve\u201d?</strong>\nResolve is a linking-time term. In linking-time, linker attempts to find the external definition for every symbol in object files that cannot find its definition internally. The scope of this searching process including:</p>\n<ul>\n<li>All object files that generated in compiling time</li>\n<li>All libraries (.lib) that are either explicitly or implicitly\nspecified as additional dependencies of this building application.</li>\n</ul>\n<p>This searching process is called resolve.</p>\n<p><strong>D. Finally, why Unresolved External Symbol?</strong>\nIf the linker cannot find the external definition for a symbol that has no definition internally, it reports an Unresolved External Symbol error.</p>\n<p><strong>E. Possible causes of LNK2019</strong>: Unresolved External Symbol error.\nWe already know that this error is due to the linker failed to find the definition of external symbols, the possible causes can be sorted as:</p>\n<ol>\n<li>Definition exists</li>\n</ol>\n<p>For example, if we have a function called foo defined in a.cpp:</p>\n<pre><code>int foo()\n{\n    return 0;\n}\n</code></pre>\n<p>In b.cpp we want to call function foo, so we add</p>\n<pre><code>void foo();\n</code></pre>\n<p>to declare function foo(), and call it in another function body, say <code>bar()</code>:</p>\n<pre><code>void bar()\n{\n    foo();\n}\n</code></pre>\n<p>Now when you build this code you will get a LNK2019 error complaining that foo is an unresolved symbol. In this case, we know that foo() has its definition in a.cpp, but different from the one we are calling(different return value). This is the case that definition exists.</p>\n<ol start=\"2\">\n<li>Definition does not exist</li>\n</ol>\n<p>If we want to call some functions in a library, but the import library is not added into the additional dependency list (set from: <code>Project | Properties | Configuration Properties | Linker | Input | Additional Dependency</code>) of your project setting. Now the linker will report a LNK2019 since the definition does not exist in current searching scope.</p>\n", "OwnerUserId": "1952158", "LastEditorUserId": "3344612", "LastEditDate": "2017-11-08T09:05:14.923", "Id": "29610614", "Score": "39", "CreationDate": "2015-04-13T16:42:19.767", "LastActivityDate": "2017-11-08T09:05:14.923"}, "12574407": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "6", "Body": "<h2>Class members:</h2>\n<h3>A pure <code>virtual</code> destructor needs an implementation.</h3>\n<p>Declaring a destructor pure still requires you to define it (unlike a regular function):</p>\n<pre><code>struct X\n{\n    virtual ~X() = 0;\n};\nstruct Y : X\n{\n    ~Y() {}\n};\nint main()\n{\n    Y y;\n}\n//X::~X(){} //uncomment this line for successful definition\n</code></pre>\n<p>This happens because base class destructors are called when the object is destroyed implicitly, so a definition is required.    </p>\n<h3><code>virtual</code> methods must either be implemented or defined as pure.</h3>\n<p>This is similar to non-<code>virtual</code> methods with no definition, with the added reasoning that \nthe pure declaration generates a dummy vtable and you might get the linker error without using the function:</p>\n<pre><code>struct X\n{\n    virtual void foo();\n};\nstruct Y : X\n{\n   void foo() {}\n};\nint main()\n{\n   Y y; //linker error although there was no call to X::foo\n}\n</code></pre>\n<p>For this to work, declare <code>X::foo()</code> as pure:</p>\n<pre><code>struct X\n{\n    virtual void foo() = 0;\n};\n</code></pre>\n<h3>Non-<code>virtual</code> class members</h3>\n<p>Some members need to be defined even if not used explicitly:</p>\n<pre><code>struct A\n{ \n    ~A();\n};\n</code></pre>\n<p>The following would yield the error:</p>\n<pre><code>A a;      //destructor undefined\n</code></pre>\n<p>The implementation can be inline, in the class definition itself:</p>\n<pre><code>struct A\n{ \n    ~A() {}\n};\n</code></pre>\n<p>or outside:</p>\n<pre><code>A::~A() {}\n</code></pre>\n<p>If the implementation is outside the class definition, but in a header, the methods have to be marked as <code>inline</code> to prevent a multiple definition.</p>\n<p>All used member methods need to be defined if used.</p>\n<h3>A common mistake is forgetting to qualify the name:</h3>\n<pre><code>struct A\n{\n   void foo();\n};\n\nvoid foo() {}\n\nint main()\n{\n   A a;\n   a.foo();\n}\n</code></pre>\n<p>The definition should be</p>\n<pre><code>void A::foo() {}\n</code></pre>\n<h3><code>static</code> data members must be defined outside the class in a <strong>single translation unit</strong>:</h3>\n<pre><code>struct X\n{\n    static int x;\n};\nint main()\n{\n    int x = X::x;\n}\n//int X::x; //uncomment this line to define X::x\n</code></pre>\n<p>An initializer can be provided for a <code>static</code> <code>const</code> data member of integral or enumeration type within the class definition; however, odr-use of this member will still require a namespace scope definition as described above. C++11 allows initialization inside the class for all <code>static const</code> data members.</p>\n", "OwnerUserId": "673730", "LastEditorUserId": "241631", "LastEditDate": "2014-09-09T01:06:32.873", "Id": "12574407", "Score": "128", "CreationDate": "2012-09-24T23:38:20.420", "LastActivityDate": "2014-09-09T01:06:32.873"}, "27749171": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "2", "Body": "<h2>A bug in the compiler/IDE</h2>\n<p>I recently had this problem, and it turned out <a href=\"https://stackoverflow.com/questions/27748699/unresolved-reference-to-constructor-which-is-defined/27748920#27748920\">it was a bug in Visual Studio Express 2013</a>. I had to remove a source file from the project and re-add it to overcome the bug.</p>\n<p>Steps to try if you believe it could be a bug in compiler/IDE:</p>\n<ul>\n<li>Clean the project (some IDEs have an option to do this, you can also\nmanually do it by deleting the object files)</li>\n<li>Try start a new project,\ncopying all source code from the original one.</li>\n</ul>\n", "OwnerUserId": "2593738", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:18:30.310", "Id": "27749171", "Score": "21", "CreationDate": "2015-01-02T22:06:08.993", "LastActivityDate": "2015-07-16T01:14:30.580"}, "bq_ids": {"n4140": {"so_12573816_35891188_0": {"section_id": 5485, "quality": 0.6923076923076923, "length": 18}, "so_12573816_12573818_0": {"section_id": 5313, "quality": 0.8181818181818182, "length": 9}, "so_12573816_35891188_1": {"section_id": 126, "quality": 0.5555555555555556, "length": 5}, "so_12573816_12573818_1": {"section_id": 5313, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_12573816_35891188_0": {"section_id": 5271, "quality": 0.6538461538461539, "length": 17}, "so_12573816_12573818_0": {"section_id": 5110, "quality": 0.8181818181818182, "length": 9}, "so_12573816_12573818_1": {"section_id": 5110, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_12573816_35891188_0": {"section_id": 6920, "quality": 0.5769230769230769, "length": 15}, "so_12573816_12573818_0": {"section_id": 6737, "quality": 0.8181818181818182, "length": 9}, "so_12573816_35891188_1": {"section_id": 131, "quality": 0.5555555555555556, "length": 5}, "so_12573816_12573818_1": {"section_id": 6737, "quality": 0.8571428571428571, "length": 12}}}, "35599792": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "0", "Body": "<h2>Clean and rebuild</h2>\n<p>A \"clean\" of the build can remove the \"dead wood\" that may be left lying around from previous builds, failed builds, incomplete builds and other build system related build issues.</p>\n<p>In general the IDE or build will include some form of \"clean\" function, but this may not be correctly configured (e.g. in a manual makefile) or may fail (e.g. the intermediate or resultant binaries are read-only).</p>\n<p>Once the \"clean\" has completed, verify that the \"clean\" has succeeded and all the generated intermediate file (e.g. an automated makefile) have been successfully removed.</p>\n<p>This <em>process can be seen as a final resort, but is often a good first step</em>; especially if the code related to the error has recently been added (either locally or from the source repository).</p>\n", "OwnerUserId": "3747990", "LastEditorUserId": "3747990", "LastEditDate": "2016-02-24T12:41:09.513", "Id": "35599792", "Score": "8", "CreationDate": "2016-02-24T10:40:51.590", "LastActivityDate": "2016-02-24T12:41:09.513"}, "12574420": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "2", "Body": "<h3>Symbols were defined in a C program and used in C++ code.</h3>\n<p>The function (or variable) <code>void foo()</code> was defined in a C program and you attempt to use it in a C++ program:</p>\n<pre><code>void foo();\nint main()\n{\n    foo();\n}\n</code></pre>\n<p>The C++ linker expects names to be mangled, so you have to declare the function as:</p>\n<pre><code>extern \"C\" void foo();\nint main()\n{\n    foo();\n}\n</code></pre>\n<p>Equivalently, instead of being defined in a C program, the function (or variable) <code>void foo()</code> was defined in C++ but with C linkage:</p>\n<pre><code>extern \"C\" void foo();\n</code></pre>\n<p>and you attempt to use it in a C++ program with C++ linkage.</p>\n<p>If an entire library is included in a header file (and was compiled as C code); the include will need to be as follows;</p>\n<pre><code>extern \"C\" {\n    #include \"cheader.h\"\n}\n</code></pre>\n", "OwnerUserId": "673730", "LastEditorUserId": "3747990", "LastEditDate": "2014-10-17T07:25:35.783", "Id": "12574420", "Score": "53", "CreationDate": "2012-09-24T23:39:15.303", "LastActivityDate": "2014-10-17T07:25:35.783"}, "24675715": {"ParentId": "12573816", "CommentCount": "1", "Body": "<h3>The order in which interdependent linked libraries are specified is wrong.</h3>\n<p>The order in which libraries are linked DOES matter if the libraries depend on each other. In general, if library <code>A</code> depends on library <code>B</code>, then <code>libA</code> <strong>MUST</strong> appear before <code>libB</code> in the linker flags.</p>\n<p>For example:</p>\n<pre><code>// B.h\n#ifndef B_H\n#define B_H\n\nstruct B {\n    B(int);\n    int x;\n};\n\n#endif\n\n// B.cpp\n#include \"B.h\"\nB::B(int xx) : x(xx) {}\n\n// A.h\n#include \"B.h\"\n\nstruct A {\n    A(int x);\n    B b;\n};\n\n// A.cpp\n#include \"A.h\"\n\nA::A(int x) : b(x) {}\n\n// main.cpp\n#include \"A.h\"\n\nint main() {\n    A a(5);\n    return 0;\n};\n</code></pre>\n<p>Create the libraries:</p>\n<pre><code>$ g++ -c A.cpp\n$ g++ -c B.cpp\n$ ar rvs libA.a A.o \nar: creating libA.a\na - A.o\n$ ar rvs libB.a B.o \nar: creating libB.a\na - B.o\n</code></pre>\n<p>Compile:</p>\n<pre><code>$ g++ main.cpp -L. -lB -lA\n./libA.a(A.o): In function `A::A(int)':\nA.cpp:(.text+0x1c): undefined reference to `B::B(int)'\ncollect2: error: ld returned 1 exit status\n$ g++ main.cpp -L. -lA -lB\n$ ./a.out\n</code></pre>\n<p>So to repeat again, the order <strong>DOES</strong> matter!</p>\n", "OwnerUserId": "1356926", "PostTypeId": "2", "Id": "24675715", "Score": "64", "CreationDate": "2014-07-10T11:46:08.707", "LastActivityDate": "2014-07-10T11:46:08.707"}, "32500124": {"ParentId": "12573816", "CommentCount": "0", "Body": "<p>Since people seem to be directed to this question when it comes to linker errors I am going to add this here.</p>\n<p>One possible reason for linker errors with GCC 5.2.0 is that a new libstdc++ library ABI is now chosen by default.</p>\n<blockquote>\n<p id=\"so_12573816_32500124_0\">If you get linker errors about undefined references to symbols that involve types in the std::__cxx11 namespace or the tag [abi:cxx11] then it probably indicates that you are trying to link together object files that were compiled with different values for the _GLIBCXX_USE_CXX11_ABI macro. This commonly happens when linking to a third-party library that was compiled with an older version of GCC. If the third-party library cannot be rebuilt with the new ABI then you will need to recompile your code with the old ABI.</p>\n</blockquote>\n<p>So if you suddenly get linker errors when switching to a GCC after 5.1.0 this would be a thing to check out.</p>\n", "OwnerUserId": "339652", "PostTypeId": "2", "Id": "32500124", "Score": "15", "CreationDate": "2015-09-10T11:03:35.357", "LastActivityDate": "2015-09-10T11:03:35.357"}, "31946065": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-08-11T15:33:42.163", "Id": "31946065", "LastEditDate": "2017-11-08T10:15:57.057", "OwnerDisplayName": "user4272649", "Score": "22", "Body": "<p>Suppose you have a big project written in c++ which has a thousand of .cpp files and a thousand of .h files.And let's says the project also depends on ten static libraries. Let's says we are on Windows and we build our project in Visual Studio 20xx. When you press Ctrl + F7 Visual Studio to start compiling the whole solution ( suppose we have just one project in the solution )</p>\n<p><strong>What's the meaning of compilation ?</strong></p>\n<ul>\n<li>Visual Studio search into file <strong>.vcxproj</strong> and start compiling each file which has the extension .cpp. Order of compilation is undefined.So you must not assume that the file main.cpp is compiled first</li>\n<li>If .cpp files depends on   additional .h files  in order to find symbols\nthat may or may not be defined in the file .cpp</li>\n<li>If exists one .cpp file in which the compiler could not find one symbol, a <strong>compiler time error</strong> raises the message <em>Symbol x could not be found</em></li>\n<li>For each file with extension .cpp is generated an object file .o and also Visual Studio writes the output in a file named <em>ProjectName.Cpp.Clean.txt</em> which contains all object files that must be processed by the linker.</li>\n</ul>\n<p>The Second step of compilation is done by Linker.Linker should merge all the object file and build finally the output ( which may be an executable or a library)</p>\n<p><strong>Steps In Linking a project</strong> </p>\n<ul>\n<li>Parse all the object files and find the definition which was only declared in headers ( eg: The code of one method of a class as is mentioned in previous answers, or event the initialization of a static variable which is member inside a class)</li>\n<li>If one symbol could not be found in object files he also is searched in Additional Libraries.For adding a new library to a project <strong>Configuration properties</strong> -&gt; <strong>VC++ Directories</strong>  -&gt; <strong>Library Directories</strong> and here you specified additional folder for searching libraries and <strong>Configuration properties</strong> -&gt; <strong>Linker</strong> -&gt; <strong>Input</strong> for specifying the name of the library. \n-If the Linker could not find the symbol which you write in one .cpp he raises a <strong>linker time error</strong> which may sound like \n<code>error LNK2001: unresolved external symbol \"void __cdecl foo(void)\" (?foo@@YAXXZ)</code></li>\n</ul>\n<p><strong>Observation</strong></p>\n<ol>\n<li>Once the Linker find one symbol he doesn't search in other libraries for it</li>\n<li>The order of linking libraries <strong>does matter</strong>.</li>\n<li>If Linker finds an external symbol in one static library he includes the symbol in the output of the project.However, if the library is shared( dynamic ) he doesn't include the code ( symbols ) in output, but  <em>Run-Time</em> crashes may occur</li>\n</ol>\n<p><strong>How To Solve this kind of error</strong></p>\n<p>Compiler Time Error : </p>\n<ul>\n<li>Make sure you write your c++ project syntactical correct.</li>\n</ul>\n<p>Linker Time Error</p>\n<ul>\n<li>Define all your symbol which you declare in your header files</li>\n<li>Use <code>#pragma once</code> for allowing compiler not to include one header if it was already included in the current .cpp which are compiled</li>\n<li>Make sure that your external library doesn't contain symbols that may enter into conflict with other symbols you defined in your header files</li>\n<li>When you use the template to make sure you include the definition of each template function in the header file for allowing the compiler to generate appropriate code for any instantiations.  </li>\n</ul>\n", "LastActivityDate": "2017-11-08T10:15:57.057", "LastEditorUserId": "956198"}, "24291364": {"ParentId": "12573816", "CommentCount": "0", "Body": "<p>Also if you're using 3rd party libraries make sure you have the correct 32/64 bit binaries</p>\n", "OwnerUserId": "359353", "PostTypeId": "2", "Id": "24291364", "Score": "27", "CreationDate": "2014-06-18T17:06:24.813", "LastActivityDate": "2014-06-18T17:06:24.813"}, "25744263": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Microsoft offers a <code>#pragma</code> to reference the correct library at link time;</p>\n<pre><code>#pragma comment(lib, \"libname.lib\")\n</code></pre>\n<p>In addition to the library path including the directory of the library, this should be the full name of the library.</p>\n", "OwnerUserId": "3747990", "LastEditorUserId": "3747990", "LastEditDate": "2014-09-10T06:37:35.877", "Id": "25744263", "Score": "27", "CreationDate": "2014-09-09T12:09:01.367", "LastActivityDate": "2014-09-10T06:37:35.877"}, "31650575": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "0", "Body": "<h2>Use the linker to help diagnose the error</h2>\n<p>Most modern linkers include a verbose option that prints out to varying degrees;</p>\n<ul>\n<li>Link invocation (command line),</li>\n<li>Data on what libraries are included in the link stage,</li>\n<li>The location of the libraries,</li>\n<li>Search paths used.</li>\n</ul>\n<p>For gcc and clang; you would typically add <code>-v -Wl,--verbose</code> or <code>-v -Wl,-v</code> to the command line. More details can be found here;</p>\n<ul>\n<li>Linux <a href=\"http://linux.die.net/man/1/ld\" rel=\"noreferrer\">ld man page</a>.</li>\n<li>LLVM <a href=\"http://llvm.org/releases/3.6.2/docs/CommandGuide/llvm-link.html#cmdoption-v\" rel=\"noreferrer\">linker page</a>.</li>\n<li>\"An introduction to GCC\" <a href=\"http://www.network-theory.co.uk/docs/gccintro/gccintro_75.html\" rel=\"noreferrer\">chapter 9</a>.</li>\n</ul>\n<p>For MSVC, <code>/VERBOSE</code> (in particular <code>/VERBOSE:LIB</code>) is added to the link command line.</p>\n<ul>\n<li>The MSDN page on the <a href=\"https://msdn.microsoft.com/en-us/library/wdsk6as6.aspx\" rel=\"noreferrer\"><code>/VERBOSE</code> linker option</a>.</li>\n</ul>\n", "OwnerUserId": "3747990", "LastEditorUserId": "3747990", "LastEditDate": "2016-02-24T10:41:08.093", "Id": "31650575", "Score": "18", "CreationDate": "2015-07-27T10:20:40.337", "LastActivityDate": "2016-02-24T10:41:08.093"}, "27995557": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "4", "Body": "<p><strong>Visual Studio NuGet package needs to be updated for new toolset version</strong></p>\n<p>I just had this problem trying to link libpng with Visual Studio 2013.  The problem is that the package file only had libraries for Visual Studio 2010 and 2012.</p>\n<p>The correct solution is to hope the developer releases an updated package and then upgrade, but it worked for me by hacking in an extra setting for VS2013, pointing at the VS2012 library files.</p>\n<p>I edited the package (in the <code>packages</code> folder inside the solution's directory) by finding <code>packagename\\build\\native\\packagename.targets</code> and inside that file, copying all the <code>v110</code> sections.  I changed the <code>v110</code> to <code>v120</code> in <strong>the condition fields only</strong> being very careful to leave the filename paths all as <code>v110</code>.  This simply allowed Visual Studio 2013 to link to the libraries for 2012, and in this case, it worked.</p>\n", "OwnerUserId": "308237", "LastEditorUserId": "308237", "LastEditDate": "2015-07-28T03:52:36.150", "Id": "27995557", "Score": "26", "CreationDate": "2015-01-17T02:24:04.753", "LastActivityDate": "2015-07-28T03:52:36.150"}, "12574423": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "2", "Body": "<h3>Incorrectly importing/exporting methods/classes across modules/dll (compiler specific).</h3>\n<p>MSVS requires you to specify which symbols to export and import using <code>__declspec(dllexport)</code> and <code>__declspec(dllimport)</code>.</p>\n<p>This dual functionality is usually obtained through the use of a macro:</p>\n<pre><code>#ifdef THIS_MODULE\n#define DLLIMPEXP __declspec(dllexport)\n#else\n#define DLLIMPEXP __declspec(dllimport)\n#endif\n</code></pre>\n<p>The macro <code>THIS_MODULE</code> would only be defined in the module that exports the function. That way, the declaration:</p>\n<pre><code>DLLIMPEXP void foo();\n</code></pre>\n<p>expands to</p>\n<pre><code>__declspec(dllexport) void foo();\n</code></pre>\n<p>and tells the compiler to export the function, as the current module contains its definition. When including the declaration in a different module, it would expand to   </p>\n<pre><code>__declspec(dllimport) void foo();\n</code></pre>\n<p>and tells the compiler that the definition is in one of the libraries you linked against (also see <strong>1)</strong>). </p>\n<p>You can similary import/export classes:</p>\n<pre><code>class DLLIMPEXP X\n{\n};\n</code></pre>\n", "OwnerUserId": "673730", "LastEditorUserId": "3747990", "LastEditDate": "2016-02-18T06:26:07.230", "Id": "12574423", "Score": "46", "CreationDate": "2012-09-24T23:39:29.873", "LastActivityDate": "2016-02-18T06:26:07.230"}, "43305704": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "0", "Body": "<h2>Your linkage consumes libraries before the object files that refer to them</h2>\n<ul>\n<li>You are trying to compile and link your program with the GCC toolchain.</li>\n<li>Your linkage specifies all of the necessary libraries and library search paths</li>\n<li>If <code>libfoo</code> depends on <code>libbar</code>, then your linkage correctly puts <code>libfoo</code> before <code>libbar</code>.</li>\n<li>Your linkage fails with <code>undefined reference to</code> <em>something</em> errors.</li>\n<li>But all the undefined <em>something</em>s are declared in the header files you have\n<code>#include</code>d and are in fact defined in the libraries that you are linking.</li>\n</ul>\n<p>Examples are in C. They could equally well be C++</p>\n<h3>A minimal example involving a static library you built yourself</h3>\n<p><strong>my_lib.c</strong></p>\n<pre><code>#include \"my_lib.h\"\n#include &lt;stdio.h&gt;\n\nvoid hw(void)\n{\n    puts(\"Hello World\");\n}\n</code></pre>\n<p><strong>my_lib.h</strong></p>\n<pre><code>#ifndef MY_LIB_H\n#define MT_LIB_H\n\nextern void hw(void);\n\n#endif\n</code></pre>\n<p><strong>eg1.c</strong></p>\n<pre><code>#include &lt;my_lib.h&gt;\n\nint main()\n{\n    hw();\n    return 0;\n}\n</code></pre>\n<p>You build your static library:</p>\n<pre><code>$ gcc -c -o my_lib.o my_lib.c\n$ ar rcs libmy_lib.a my_lib.o\n</code></pre>\n<p>You compile your program:</p>\n<pre><code>$ gcc -I. -c -o eg1.o eg1.c\n</code></pre>\n<p>You try to link it with <code>libmy_lib.a</code> and fail:</p>\n<pre><code>$ gcc -o eg1 -L. -lmy_lib eg1.o \neg1.o: In function `main':\neg1.c:(.text+0x5): undefined reference to `hw'\ncollect2: error: ld returned 1 exit status\n</code></pre>\n<p>The same result if you compile and link in one step, like:</p>\n<pre><code>$ gcc -o eg1 -I. -L. -lmy_lib eg1.c\n/tmp/ccQk1tvs.o: In function `main':\neg1.c:(.text+0x5): undefined reference to `hw'\ncollect2: error: ld returned 1 exit status\n</code></pre>\n<h3>A minimal example involving a shared system library, the compression library <code>libz</code></h3>\n<p><strong>eg2.c</strong></p>\n<pre><code>#include &lt;zlib.h&gt;\n#include &lt;stdio.h&gt;\n\nint main()\n{\n    printf(\"%s\\n\",zlibVersion());\n    return 0;\n}\n</code></pre>\n<p>Compile your program:</p>\n<pre><code>$ gcc -c -o eg2.o eg2.c\n</code></pre>\n<p>Try to link your program with <code>libz</code> and fail:</p>\n<pre><code>$ gcc -o eg2 -lz eg2.o \neg2.o: In function `main':\neg2.c:(.text+0x5): undefined reference to `zlibVersion'\ncollect2: error: ld returned 1 exit status\n</code></pre>\n<p>Same if you compile and link in one go:</p>\n<pre><code>$ gcc -o eg2 -I. -lz eg2.c\n/tmp/ccxCiGn7.o: In function `main':\neg2.c:(.text+0x5): undefined reference to `zlibVersion'\ncollect2: error: ld returned 1 exit status\n</code></pre>\n<p>And a variation on example 2 involving <code>pkg-config</code>:</p>\n<pre><code>$ gcc -o eg2 $(pkg-config --libs zlib) eg2.o \neg2.o: In function `main':\neg2.c:(.text+0x5): undefined reference to `zlibVersion'\n</code></pre>\n<h3>What are you doing wrong?</h3>\n<p>In the sequence of object files and libraries you want to link to make your\nprogram, you are placing the libraries before the object files that refer to\nthem. You need to place the libraries <em>after</em> the object files that refer\nto them.</p>\n<p>Link example 1 correctly:</p>\n<pre><code>$ gcc -o eg1 eg1.o -L. -lmy_lib\n</code></pre>\n<p>Success:</p>\n<pre><code>$ ./eg1 \nHello World\n</code></pre>\n<p>Link example 2 correctly:</p>\n<pre><code>$ gcc -o eg2 eg2.o -lz\n</code></pre>\n<p>Success:</p>\n<pre><code>$ ./eg2 \n1.2.8\n</code></pre>\n<p>Link the example 2 <code>pkg-config</code> variation correctly:</p>\n<pre><code>$ gcc -o eg2 eg2.o $(pkg-config --libs zlib) \n$ ./eg2\n1.2.8\n</code></pre>\n<h3>The explanation</h3>\n<p><em>Reading is optional from here on</em>.</p>\n<p>By default, a linkage command generated by GCC, on your distro,\nconsumes the files in the linkage from left to right in\ncommandline sequence. When it finds that a file refers to <em>something</em>\nand does not contain a definition for it, to will search for a definition\nin files further to the right. If it eventually finds a definition, the\nreference is resolved. If any references remain unresolved at the end,\nthe linkage fails: the linker does not search backwards.</p>\n<p>First, <strong>example 1</strong>, with static library <code>my_lib.a</code></p>\n<p>A static library is an indexed archive of object files. When the linker\nfinds <code>-lmy_lib</code> in the linkage sequence and figures out that this refers\nto the static library <code>./libmy_lib.a</code>, it wants to know whether your program\nneeds any of the object files in <code>libmy_lib.a</code>.</p>\n<p>There is only object file in <code>libmy_lib.a</code>, namely <code>my_lib.o</code>, and there's only one thing defined\nin <code>my_lib.o</code>, namely the function <code>hw</code>.</p>\n<p>The linker will decide that your program needs <code>my_lib.o</code> if and only if it already knows that\nyour program refers to <code>hw</code>, in one or more of the object files it has already\nadded to the program, and that none of the object files it has already added\ncontains a definition for <code>hw</code>.</p>\n<p>If that is true, then the linker will extract a copy of <code>my_lib.o</code> from the library and\nadd it to your program. Then, your program contains a definition for <code>hw</code>, so\nits references to <code>hw</code> are <em>resolved</em>.</p>\n<p>When you try to link the program like:</p>\n<pre><code>$ gcc -o eg1 -L. -lmy_lib eg1.o\n</code></pre>\n<p>the linker <em>has not added</em> <code>eg1.o</code> <em>to the program</em> when it sees\n<code>-lmy_lib</code>. Because at that point, it has not seen <code>eg1.o</code>.\nYour program does not yet make any references to <code>hw</code>: it\ndoes not yet make any references <em>at all</em>, because all the references it makes\nare in <code>eg1.o</code>.</p>\n<p>So the linker does not add <code>my_lib.o</code> to the program and has no further\nuse for <code>libmy_lib.a</code>.</p>\n<p>Next, it finds <code>eg1.o</code>, and adds it to be program. An object file in the\nlinkage sequence is always added to the program. Now, the program makes\na reference to <code>hw</code>, and does not contain a definition of <code>hw</code>; but\nthere is nothing left in the linkage sequence that could provide the missing\ndefinition. The reference to <code>hw</code> ends up <em>unresolved</em>, and the linkage fails.</p>\n<p>Second, <strong>example 2</strong>, with shared library <code>libz</code></p>\n<p>A shared library isn't an archive of object files or anything like it. It's\nmuch more like a <em>program</em> that doesn't have a <code>main</code> function and\ninstead exposes multiple other symbols that it defines, so that other\nprograms can use them at runtime.</p>\n<p>Many Linux distros today configure their GCC toolchain so that its language drivers (<code>gcc</code>,<code>g++</code>,<code>gfortran</code> etc)\ninstruct the system linker (<code>ld</code>) to link shared libraries on an <em>as-needed</em> basis.\nYou have got one of those distros.</p>\n<p>This means that when the linker finds <code>-lz</code> in the linkage sequence, and figures out that this refers \nto the shared library (say) <code>/usr/lib/x86_64-linux-gnu/libz.so</code>, it wants to know whether any references that it has added to your program that aren't yet defined have definitions that are exported by <code>libz</code></p>\n<p>If that is true, then the linker will <em>not</em> copy any chunks out of <code>libz</code> and\nadd them to your program; instead, it will just doctor the code of your program \nso that:-</p>\n<ul>\n<li><p>At runtime, the system program loader will load a copy of <code>libz</code> into the\nsame process as your program whenever it loads a copy of your program, to run it.</p></li>\n<li><p>At runtime, whenever your program refers to something that is defined in\n<code>libz</code>, that reference uses the definition exported by the copy of <code>libz</code> in\nthe same process.</p></li>\n</ul>\n<p>Your program wants to refer to just one thing that has a definition exported by <code>libz</code>,\nnamely the function <code>zlibVersion</code>, which is referred to just once, in <code>eg2.c</code>.\nIf the linker adds that reference to your program, and then finds the definition\nexported by <code>libz</code>, the reference is <em>resolved</em> </p>\n<p>But when you try to link the program like:</p>\n<pre><code>gcc -o eg2 -lz eg2.o\n</code></pre>\n<p>the order of events is wrong in just the same way as with example 1.\nAt the point when the linker finds <code>-lz</code>, there are <em>no</em> references to anything\nin the program: they are all in <code>eg2.o</code>, which has not yet been seen. So the\nlinker decides it has no use for <code>libz</code>. When it reaches <code>eg2.o</code>, adds it to the program,\nand then has undefined reference to <code>zlibVersion</code>, the linkage sequence is finished;\nthat reference is unresolved, and the linkage fails.</p>\n<p>Lastly, the <code>pkg-config</code> variation of example 2 has a now obvious explanation.\nAfter shell-expansion:</p>\n<pre><code>gcc -o eg2 $(pkg-config --libs zlib) eg2.o\n</code></pre>\n<p>becomes:</p>\n<pre><code>gcc -o eg2 -lz eg2.o\n</code></pre>\n<p>which is just example 2 again.</p>\n<h3>I can reproduce the problem in example 1, but not in example 2</h3>\n<p>The linkage:</p>\n<pre><code>gcc -o eg2 -lz eg2.o\n</code></pre>\n<p>works just fine for you!</p>\n<p>(Or: That linkage worked fine for you on, say, Fedora 23, but fails on Ubuntu 16.04)</p>\n<p>That's because the distro on which the linkage works is one of the ones that \ndoes not configure its GCC toolchain to link shared libraries <em>as-needed</em>.</p>\n<p>Back in the day, it was normal for unix-like systems to link static and shared \nlibraries by different rules. Static libraries in a linkage sequence were linked \non the <em>as-needed</em> basis explained in example 1, but shared libraries were linked unconditionally.</p>\n<p>This behaviour is economical at linktime because the linker doesn't have to ponder\nwhether a shared library is needed by the program: if it's a shared library,\nlink it. And most libraries in most linkages are shared libraries. But there are disadvantages too:-</p>\n<ul>\n<li><p>It is uneconomical at <em>runtime</em>, because it can cause shared libraries to be\nloaded along with a program even if doesn't need them.</p></li>\n<li><p>The different linkage rules for static and shared libraries can be confusing\nto inexpert programmers, who may not know whether <code>-lfoo</code> in their linkage\nis going to resolve to <code>/some/where/libfoo.a</code> or to <code>/some/where/libfoo.so</code>,\nand might not understand the difference between shared and static libraries\nanyway.</p></li>\n</ul>\n<p>This trade-off has led to the schismatic situation today. Some distros have\nchanged their GCC linkage rules for shared libraries so that the <em>as-needed</em>\nprinciple applies for all libraries. Some distros have stuck with the old\nway.</p>\n<h3>Why do I still get this problem even if I compile-and-link at the same time?</h3>\n<p>If I just do:</p>\n<pre><code>$ gcc -o eg1 -I. -L. -lmy_lib eg1.c\n</code></pre>\n<p>surely gcc has to compile <code>eg1.c</code> first, and then link the resulting\nobject file with <code>libmy_lib.a</code>.  So how can it not know that object file\nis needed when it's doing the linking?</p>\n<p>Because compiling and linking with a single command does not change the\norder of the linkage sequence.</p>\n<p>When you run the command above, <code>gcc</code> figures out that you want compilation +\nlinkage. So behind the scenes, it generates a compilation command, and runs\nit, then generates a linkage command, and runs it, as if <em>you</em> had run the\ntwo commands:</p>\n<pre><code>$ gcc -I. -c -o eg1.o eg1.c\n$ gcc -o eg1 -L. -lmy_lib eg1.o\n</code></pre>\n<p>So the linkage fails just as it does if you <em>do</em> run those two commands. The\nonly difference you notice in the failure is that gcc has generated a\ntemporary object file in the compile + link case, because you're not telling it\nto use <code>eg1.o</code>. We see:</p>\n<pre><code>/tmp/ccQk1tvs.o: In function `main'\n</code></pre>\n<p>instead of:</p>\n<pre><code>eg1.o: In function `main':\n</code></pre>\n<h3>See also</h3>\n<p><a href=\"https://stackoverflow.com/a/24675715/1362568\">The order in which interdependent linked libraries are specified is wrong</a></p>\n<p>Putting interdependent libraries in the wrong order is just one way\nin which you can get files that <em>need</em> definitions of things coming\nlater in the linkage than the files that <em>provide</em> the definitions. Putting libraries before the \nobject files that refer to them is another way of making the same mistake.</p>\n", "OwnerUserId": "1362568", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:34:53.630", "Id": "43305704", "Score": "7", "CreationDate": "2017-04-09T10:34:09.087", "LastActivityDate": "2017-04-09T10:54:44.680"}, "12573818": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Compiling a C++ program takes place in several steps, as specified by <strong>2.2</strong> <a href=\"https://stackoverflow.com/a/8834196/673730\">(credits to Keith Thompson for the reference)</a>:</p>\n<blockquote>\n<p id=\"so_12573816_12573818_0\">The precedence among the syntax rules of translation is specified by the following phases <em>[see footnote]</em>.</p>\n<ol>\n<li>Physical source file characters are mapped, in an implementation-defined manner, to the basic source character set\n  (introducing new-line characters for end-of-line indicators) if\n  necessary. <em>[SNIP]</em></li>\n<li>Each instance of a backslash character (\\) immediately followed by a new-line character is deleted, splicing physical source lines to\n  form logical source lines. <em>[SNIP]</em></li>\n<li>The source file is decomposed into preprocessing tokens (2.5) and sequences of white-space characters (including comments). <em>[SNIP]</em></li>\n<li>Preprocessing directives are executed, macro invocations are expanded, and _Pragma unary operator expressions are executed. <em>[SNIP]</em></li>\n<li>Each source character set member in a character literal or a string literal, as well as each escape sequence and universal-character-name\n  in a character literal or a non-raw string literal, is converted to\n  the corresponding member of the execution character set; <em>[SNIP]</em></li>\n<li>Adjacent string literal tokens are concatenated.</li>\n<li>White-space characters separating tokens are no longer significant. Each preprocessing token is converted into a token. (2.7). The\n  resulting tokens are syntactically and semantically analyzed and\n  translated as a translation unit. <em>[SNIP]</em></li>\n<li>Translated translation units and instantiation units are combined as follows: <em>[SNIP]</em></li>\n<li><strong>All external entity references are resolved. Library components are linked to satisfy external references to entities not defined in the\n  current translation. All such translator output is collected into a\n  program image which contains information needed for execution in its\n  execution environment.</strong> (emphasis mine)</li>\n</ol>\n<p id=\"so_12573816_12573818_1\"><em>[footnote]</em> Implementations must behave as if these separate phases occur, although in practice different phases might be folded together.</p>\n</blockquote>\n<p>The specified errors occur during this last stage of compilation, most commonly referred to as linking. It basically means that you compiled a bunch of implementation files into object files or libraries and now you want to get them to work together.</p>\n<p>Say you defined symbol <code>a</code> in <code>a.cpp</code>. Now, <code>b.cpp</code> <em>declared</em> that symbol and used it. Before linking, it simply assumes that that symbol was defined <em>somewhere</em>, but it doesn't yet care where. The linking phase is responsible for finding the symbol and correctly linking it to <code>b.cpp</code> (well, actually to the object or library that uses it).</p>\n<p>If you're using Microsoft Visual Studio, you'll see that projects generate <code>.lib</code> files. These contain a table of exported symbols, and a table of imported symbols. The imported symbols are resolved against the libraries you link against, and the exported symbols are provided for the libraries that use that <code>.lib</code> (if any).</p>\n<p>Similar mechanisms exist for other compilers/ platforms.</p>\n<p>Common error messages are <code>error LNK2001</code>, <code>error LNK1120</code>, <code>error LNK2019</code> for <strong>Microsoft Visual Studio</strong> and <code>undefined reference to</code> <em>symbolName</em> for <strong>GCC</strong>.</p>\n<p>The code:</p>\n<pre><code>struct X\n{\n   virtual void foo();\n};\nstruct Y : X\n{\n   void foo() {}\n};\nstruct A\n{\n   virtual ~A() = 0;\n};\nstruct B: A\n{\n   virtual ~B(){}\n};\nextern int x;\nvoid foo();\nint main()\n{\n   x = 0;\n   foo();\n   Y y;\n   B b;\n}\n</code></pre>\n<p>will generate the following errors with <strong>GCC</strong>:</p>\n<pre><code>/home/AbiSfw/ccvvuHoX.o: In function `main':\nprog.cpp:(.text+0x10): undefined reference to `x'\nprog.cpp:(.text+0x19): undefined reference to `foo()'\nprog.cpp:(.text+0x2d): undefined reference to `A::~A()'\n/home/AbiSfw/ccvvuHoX.o: In function `B::~B()':\nprog.cpp:(.text._ZN1BD1Ev[B::~B()]+0xb): undefined reference to `A::~A()'\n/home/AbiSfw/ccvvuHoX.o: In function `B::~B()':\nprog.cpp:(.text._ZN1BD0Ev[B::~B()]+0x12): undefined reference to `A::~A()'\n/home/AbiSfw/ccvvuHoX.o:(.rodata._ZTI1Y[typeinfo for Y]+0x8): undefined reference to `typeinfo for X'\n/home/AbiSfw/ccvvuHoX.o:(.rodata._ZTI1B[typeinfo for B]+0x8): undefined reference to `typeinfo for A'\ncollect2: ld returned 1 exit status\n</code></pre>\n<p>and similar errors with <strong>Microsoft Visual Studio</strong>:</p>\n<pre><code>1&gt;test2.obj : error LNK2001: unresolved external symbol \"void __cdecl foo(void)\" (?foo@@YAXXZ)\n1&gt;test2.obj : error LNK2001: unresolved external symbol \"int x\" (?x@@3HA)\n1&gt;test2.obj : error LNK2001: unresolved external symbol \"public: virtual __thiscall A::~A(void)\" (??1A@@UAE@XZ)\n1&gt;test2.obj : error LNK2001: unresolved external symbol \"public: virtual void __thiscall X::foo(void)\" (?foo@X@@UAEXXZ)\n1&gt;...\\test2.exe : fatal error LNK1120: 4 unresolved externals\n</code></pre>\n<p>Common causes include:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/a/12574400/673730\">Failure to link against appropriate libraries/object files or compile implementation files</a></li>\n<li><a href=\"https://stackoverflow.com/a/12574403/673730\">Declared and undefined variable or function.</a></li>\n<li><a href=\"https://stackoverflow.com/a/12574407/673730\">Common issues with class-type members</a></li>\n<li><a href=\"https://stackoverflow.com/a/12574417/673730\">Template implementations not visible.</a></li>\n<li><a href=\"https://stackoverflow.com/a/12574420/673730\">Symbols were defined in a C program and used in C++ code.</a></li>\n<li><a href=\"https://stackoverflow.com/a/12574423/673730\">Incorrectly importing/exporting methods/classes across modules/dll. (MSVS specific)</a></li>\n<li><a href=\"https://stackoverflow.com/a/20358542/673730\">Circular library dependency</a></li>\n<li><a href=\"https://stackoverflow.com/questions/5259714/undefined-reference-to-winmain16/5260237#5260237\">undefined reference to `WinMain@16'</a></li>\n<li><a href=\"https://stackoverflow.com/a/24675715/1356926\">Interdependent library order</a></li>\n<li><a href=\"https://stackoverflow.com/questions/14364362/visualstudio-project-with-multiple-sourcefiles-of-the-same-name\">Multiple source files of the same name</a></li>\n<li><a href=\"https://stackoverflow.com/a/25744263/3747990\">Mistyping or not including the .lib extension when using the <code>#pragma</code> (Microsoft Visual Studio)</a></li>\n<li><a href=\"https://stackoverflow.com/a/35891188/3747990\">Problems with template friends</a></li>\n<li><a href=\"https://stackoverflow.com/a/36475406/3747990\">Inconsistent <code>UNICODE</code> definitions</a></li>\n</ul>\n", "OwnerUserId": "673730", "LastEditorUserId": "7232508", "LastEditDate": "2017-11-18T03:51:35.460", "Id": "12573818", "Score": "592", "CreationDate": "2012-09-24T22:27:40.680", "LastActivityDate": "2017-11-18T03:51:35.460"}, "42572566": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "7", "Body": "<h1>When your include paths are different</h1>\n<p>Linker errors can happen when a header file and its associated shared library (.lib file) go out of sync. Let me explain. </p>\n<p>How do linkers work? The linker matches a function declaration (declared in the header) with its definition (in the shared library) by comparing their signatures. You can get a linker error if the linker doesn't find a function definition that matches perfectly. </p>\n<p>Is it possible to still get a linker error even though the declaration and the definition seem to match? Yes! They might look the same in source code, but it really depends on what the compiler sees. Essentially you could end up with a situation like this:</p>\n<pre><code>// header1.h\ntypedef int Number;\nvoid foo(Number);\n\n// header2.h\ntypedef float Number;\nvoid foo(Number); // this only looks the same lexically\n</code></pre>\n<p>Note how even though both the function declarations look identical in source code, but they are really different according to the compiler.</p>\n<p>You might ask how one ends up in a situation like that? <strong>Include paths</strong> of course! If when compiling the shared library, the include path leads to <code>header1.h</code> and you end up using <code>header2.h</code> in your own program, you'll be left scratching your header wondering what happened (pun intended).</p>\n<p>An example of how this can happen in the real world is explained below.</p>\n<h2>Further elaboration with an example</h2>\n<p>I have two projects: <code>graphics.lib</code> and <code>main.exe</code>. Both projects depend on <code>common_math.h</code>. Suppose the library exports the following function:</p>\n<pre><code>// graphics.lib    \n#include \"common_math.h\" \n\nvoid draw(vec3 p) { ... } // vec3 comes from common_math.h\n</code></pre>\n<p>And then you go ahead and include the library in your own project.</p>\n<pre><code>// main.exe\n#include \"other/common_math.h\"\n#include \"graphics.h\"\n\nint main() {\n    draw(...);\n}\n</code></pre>\n<p>Boom! You get a linker error and you have no idea why it's failing. The reason is that the common library uses different versions of the same include <code>common_math.h</code> (I have made it obvious here in the example by including a different path, but it might not always be so obvious. Maybe the include path is different in the compiler settings).</p>\n<p>Note in this example, the linker would tell you it couldn't find <code>draw()</code>, when in reality you know it obviously is being exported by the library. You could spend hours scratching your head wondering what went wrong. The thing is, the linker sees a different signature because the parameter types are slightly different. In the example, <code>vec3</code> is a different type in both projects as far as the compiler is concerned. This could happen because they come from two slightly different include files (maybe the include files come from two different versions of the library).</p>\n<h2>Debugging the linker</h2>\n<p>DUMPBIN is your friend, if you are using Visual Studio. I'm sure other compilers have other similar tools.</p>\n<p>The process goes like this:</p>\n<ol>\n<li>Note the weird mangled name given in the linker error. (eg. draw@graphics@XYZ).</li>\n<li>Dump the exported symbols from the library into a text file.</li>\n<li>Search for the exported symbol of interest, and notice that the mangled name is different.</li>\n<li>Pay attention to why the mangled names ended up different. You would be able to see that the parameter types are different, even though they look the same in the source code.</li>\n<li>Reason why they are different. In the example given above, they are different because of different include files.</li>\n</ol>\n<p>[1] By project I mean a set of source files that are linked together to produce either a library or an executable.</p>\n<p>EDIT 1: Rewrote first section to be easier to understand. Please comment below to let me know if something else needs to be fixed. Thanks!</p>\n", "OwnerUserId": "2160972", "LastEditorUserId": "2160972", "LastEditDate": "2017-11-12T00:10:26.693", "Id": "42572566", "Score": "7", "CreationDate": "2017-03-03T06:57:30.017", "LastActivityDate": "2017-11-12T00:10:26.693"}, "12574403": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "3", "Body": "<h3>Declared but did not define a variable or function.</h3>\n<p>A typical variable declaration is</p>\n<pre><code>extern int x;\n</code></pre>\n<p>As this is only a declaration, a <strong>single definition</strong> is needed. A corresponding definition would be:</p>\n<pre><code>int x;\n</code></pre>\n<p>For example, the following would generate an error:</p>\n<pre><code>extern int x;\nint main()\n{\n    x = 0;\n}\n//int x; // uncomment this line for successful definition\n</code></pre>\n<p>Similar remarks apply to functions. Declaring a function without defining it leads to the error:</p>\n<pre><code>void foo(); // declaration only\nint main()\n{\n   foo();\n}\n//void foo() {} //uncomment this line for successful definition\n</code></pre>\n<p>Be careful that the function you implement exactly matches the one you declared. For example, you may have mismatched cv-qualifiers:</p>\n<pre><code>void foo(int&amp; x);\nint main()\n{\n   int x;\n   foo(x);\n}\nvoid foo(const int&amp; x) {} //different function, doesn't provide a definition\n                          //for void foo(int&amp; x)\n</code></pre>\n<p>Other examples of mismatches include</p>\n<ul>\n<li>Function/variable declared in one namespace, defined in another.</li>\n<li>Function/variable declared as class member, defined as global (or vice versa).</li>\n<li>Function return type, parameter number and types, and calling convention do not all exactly agree.</li>\n</ul>\n<p>The error message from the compiler will often give you the full declaration of the variable or function that was declared but never defined. Compare it closely to the definition you provided. <em>Make sure every detail matches.</em></p>\n", "OwnerUserId": "673730", "LastEditorUserId": "1087161", "LastEditDate": "2015-06-23T15:54:29.893", "Id": "12574403", "Score": "81", "CreationDate": "2012-09-24T23:38:00.483", "LastActivityDate": "2015-06-23T15:54:29.893"}, "36475406": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "0", "Body": "<h2>Inconsistent <code>UNICODE</code> definitions</h2>\n<p>A Windows UNICODE build is built with <code>TCHAR</code> etc. being defined as <code>wchar_t</code> etc. When not building with <code>UNICODE</code> defined as build with <code>TCHAR</code> defined as <code>char</code> etc. These <code>UNICODE</code> and <code>_UNICODE</code> defines affect all the <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/dd374131(v=vs.85).aspx\" rel=\"noreferrer\">\"<code>T</code>\" string types</a>; <code>LPTSTR</code>, <code>LPCTSTR</code> and their elk.</p>\n<p>Building one library with <code>UNICODE</code> defined and attempting to link it in a project where <code>UNICODE</code> is not defined will result in linker errors since there will be a mismatch in the definition of <code>TCHAR</code>; <code>char</code> vs. <code>wchar_t</code>.</p>\n<p>The error usually includes a function a value with a <code>char</code> or <code>wchar_t</code> derived type, these could include <code>std::basic_string&lt;&gt;</code> etc. as well. When browsing through the affected function in the code, there will often be a reference to <code>TCHAR</code> or <code>std::basic_string&lt;TCHAR&gt;</code> etc. This is a tell-tale sign that the code was originally intended for both a UNICODE and a Multi-Byte Character (or \"narrow\") build.</p>\n<p>To correct this, build all the required libraries and projects with a consistent definition of <code>UNICODE</code> (and <code>_UNICODE</code>).</p>\n<ol>\n<li><p>This can be done with either;</p>\n<pre><code>#define UNICODE\n#define _UNICODE\n</code></pre></li>\n<li><p>Or in the project settings;</p>\n<blockquote>\n<p id=\"so_12573816_36475406_0\">Project Properties &gt; General &gt; Project Defaults &gt; Character Set</p>\n</blockquote></li>\n<li><p>Or on the command line;</p>\n<pre><code>/DUNICODE /D_UNICODE\n</code></pre></li>\n</ol>\n<p>The alternative is applicable as well, if UNICODE is not intended to be used, make sure the defines are not set, and/or the multi-character setting is used in the projects and consistently applied.</p>\n<p>Do not forget to be consistent between the \"Release\" and \"Debug\" builds as well.</p>\n", "OwnerUserId": "3747990", "LastEditorUserId": "3747990", "LastEditDate": "2017-05-12T06:06:08.763", "Id": "36475406", "Score": "9", "CreationDate": "2016-04-07T11:53:38.320", "LastActivityDate": "2017-05-12T06:06:08.763"}, "22866347": {"ParentId": "12573816", "CommentCount": "0", "Body": "<p><strong>Linked .lib file is associated to a .dll</strong></p>\n<p>I had the same issue. Say i have projects MyProject and TestProject. I had effectively linked the lib file for MyProject to the TestProject. However, this lib file was produced as the DLL for the MyProject was built. Also, I did not contain source code for all methods in the MyProject, but only access to the DLL's entry points. </p>\n<p>To solve the issue, i built the MyProject as a LIB, and linked TestProject to this .lib file (i copy paste the generated .lib file into the TestProject folder). I can then build again MyProject as a DLL. It is compiling since the lib to which TestProject is linked does contain code for all methods in classes in MyProject. </p>\n", "OwnerUserId": "1141493", "PostTypeId": "2", "Id": "22866347", "Score": "19", "CreationDate": "2014-04-04T15:02:33.350", "LastActivityDate": "2014-04-04T15:02:33.350"}, "35891188": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "0", "Body": "<h2>Befriending templates...</h2>\n<p>Given the code snippet of a template type with a friend operator (or function);</p>\n<pre><code>template &lt;typename T&gt;\nclass Foo {\n    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; os, const Foo&lt;T&gt;&amp; a);\n};\n</code></pre>\n<p>The <code>operator&lt;&lt;</code> is being declared as a non-template function. For every type <code>T</code> used with <code>Foo</code>, there needs to be a non-templated <code>operator&lt;&lt;</code>. For example, if there is a type <code>Foo&lt;int&gt;</code> declared, then there must be an operator implementation as follows;</p>\n<pre><code>std::ostream&amp; operator&lt;&lt; (std::ostream&amp; os, const Foo&lt;int&gt;&amp; a) {/*...*/}\n</code></pre>\n<p>Since it is not implemented, the linker fails to find it and results in the error.</p>\n<p>To correct this, you can declare a template operator before the <code>Foo</code> type and then declare as a friend, the appropriate instantiation. The syntax is a little awkward, but is looks as follows;</p>\n<pre><code>// forward declare the Foo\ntemplate &lt;typename&gt;\nclass Foo;\n\n// forward declare the operator &lt;&lt;\ntemplate &lt;typename T&gt;\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Foo&lt;T&gt;&amp;);\n\ntemplate &lt;typename T&gt;\nclass Foo {\n    friend std::ostream&amp; operator&lt;&lt; &lt;&gt;(std::ostream&amp; os, const Foo&lt;T&gt;&amp; a);\n    // note the required &lt;&gt;        ^^^^\n    // ...\n};\n\ntemplate &lt;typename T&gt;\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Foo&lt;T&gt;&amp;)\n{\n  // ... implement the operator\n}\n</code></pre>\n<p>The above code limits the friendship of the operator to the corresponding instantiation of <code>Foo</code>, i.e. the <code>operator&lt;&lt; &lt;int&gt;</code> instantiation is limited to access the private members of the instantiation of <code>Foo&lt;int&gt;</code>.</p>\n<p>Alternatives include;</p>\n<ul>\n<li><p>Allowing the friendship to extend to all instantiations of the templates, as follows;</p>\n<pre><code>template &lt;typename T&gt;\nclass Foo {\n    template &lt;typename T1&gt;\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Foo&lt;T1&gt;&amp; a);\n    // ...\n};\n</code></pre></li>\n<li><p>Or, the implementation for the <code>operator&lt;&lt;</code> can be done inline inside the class definition;</p>\n<pre><code>template &lt;typename T&gt;\nclass Foo {\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Foo&amp; a)\n    { /*...*/ }\n    // ...\n};\n</code></pre></li>\n</ul>\n<p><em>Note</em>, when the declaration of the operator (or function) only appears in the class, the name is not available for \"normal\" lookup, only for argument dependent lookup, from <a href=\"http://en.cppreference.com/w/cpp/language/friend\" rel=\"noreferrer\">cppreference</a>;</p>\n<blockquote>\n<p id=\"so_12573816_35891188_0\">A name first declared in a friend declaration within class or class template X becomes a member of the innermost enclosing namespace of X, but is not accessible for lookup (except argument-dependent lookup that considers X) unless a matching declaration at the namespace scope is provided...</p>\n</blockquote>\n<p>There is further reading on template friends at <a href=\"http://en.cppreference.com/w/cpp/language/friend#Template_friends\" rel=\"noreferrer\">cppreference</a> and the <a href=\"https://isocpp.org/wiki/faq/templates#template-friends\" rel=\"noreferrer\">C++ FAQ</a>.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/e9221c4bb23f9cd0\" rel=\"noreferrer\">Code listing showing the techniques above</a>.</p>\n<hr>\n<p><em>As a side note to the failing code sample; g++ warns about this as follows</em></p>\n<blockquote>\n<p id=\"so_12573816_35891188_1\"><code>warning: friend declaration 'std::ostream&amp; operator&lt;&lt;(...)' declares a non-template function [-Wnon-template-friend]</code></p>\n<p id=\"so_12573816_35891188_2\"><code>note: (if this is not what you intended, make sure the function template has already been declared and add &lt;&gt; after the function name here)</code> </p>\n</blockquote>\n</hr>", "OwnerUserId": "3747990", "LastEditorUserId": "3747990", "LastEditDate": "2016-06-10T21:29:24.643", "Id": "35891188", "Score": "12", "CreationDate": "2016-03-09T12:08:26.797", "LastActivityDate": "2016-06-10T21:29:24.643"}, "26233563": {"CommentCount": "0", "CreationDate": "2014-10-07T10:09:10.750", "CommunityOwnedDate": "2014-10-07T10:14:38.267", "LastEditorUserId": "5555440", "LastActivityDate": "2017-08-09T13:30:37.410", "ParentId": "12573816", "PostTypeId": "2", "LastEditDate": "2017-08-09T13:30:37.410", "Id": "26233563", "Score": "53", "Body": "<p><strong>what is an \"undefined reference/unresolved external symbol\"</strong></p>\n<p>I'll try to explain what is an \"undefined reference/unresolved external symbol\".</p>\n<blockquote>\n<p id=\"so_12573816_26233563_0\">note: i use g++ and Linux and all examples is for it </p>\n</blockquote>\n<p>For example we have some code</p>\n<pre><code>// src1.cpp\nvoid print();\n\nstatic int local_var_name; // 'static' makes variable not visible for other modules\nint global_var_name = 123;\n\nint main()\n{\n    print();\n    return 0;\n}\n</code></pre>\n<p>and</p>\n<pre><code>// src2.cpp\nextern \"C\" int printf (const char*, ...);\n\nextern int global_var_name;\n//extern int local_var_name;\n\nvoid print ()\n{\n    // printf(\"%d%d\\n\", global_var_name, local_var_name);\n    printf(\"%d\\n\", global_var_name);\n}\n</code></pre>\n<p>Make object files</p>\n<pre><code>$ g++ -c src1.cpp -o src1.o\n$ g++ -c src2.cpp -o src2.o\n</code></pre>\n<p>After the assembler phase we have an object file, which contains any symbols to export. \nLook at the symbols</p>\n<pre><code>$ readelf --symbols src1.o\n  Num:    Value          Size Type    Bind   Vis      Ndx Name\n     5: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    4 _ZL14local_var_name # [1]\n     9: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 global_var_name     # [2]\n</code></pre>\n<p>I've rejected some lines from output, because they do not matter</p>\n<p>So, we see follow symbols to export.</p>\n<pre><code>[1] - this is our static (local) variable (important - Bind has a type \"LOCAL\")\n[2] - this is our global variable\n</code></pre>\n<p>src2.cpp exports nothing and we have seen no its symbols</p>\n<p>Link our object files</p>\n<pre><code>$ g++ src1.o src2.o -o prog\n</code></pre>\n<p>and run it</p>\n<pre><code>$ ./prog\n123\n</code></pre>\n<p>Linker sees exported symbols and links it. Now we try to uncomment lines in src2.cpp like here</p>\n<pre><code>// src2.cpp\nextern \"C\" int printf (const char*, ...);\n\nextern int global_var_name;\nextern int local_var_name;\n\nvoid print ()\n{\n    printf(\"%d%d\\n\", global_var_name, local_var_name);\n}\n</code></pre>\n<p>and rebuild an object file</p>\n<pre><code>$ g++ -c src2.cpp -o src2.o\n</code></pre>\n<p>OK (no errors), because we only build object file, linking is not done yet.\nTry to link</p>\n<pre><code>$ g++ src1.o src2.o -o prog\nsrc2.o: In function `print()':\nsrc2.cpp:(.text+0x6): undefined reference to `local_var_name'\ncollect2: error: ld returned 1 exit status\n</code></pre>\n<p>It has happened because our local_var_name is static, i.e. it is not visible for other modules. \nNow more deeply. Get the translation phase output</p>\n<pre><code>$ g++ -S src1.cpp -o src1.s\n\n// src1.s\nlook src1.s\n\n    .file   \"src1.cpp\"\n    .local  _ZL14local_var_name\n    .comm   _ZL14local_var_name,4,4\n    .globl  global_var_name\n    .data\n    .align 4\n    .type   global_var_name, @object\n    .size   global_var_name, 4\nglobal_var_name:\n    .long   123\n    .text\n    .globl  main\n    .type   main, @function\nmain:\n; assembler code, not interesting for us\n.LFE0:\n    .size   main, .-main\n    .ident  \"GCC: (Ubuntu 4.8.2-19ubuntu1) 4.8.2\"\n    .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n<p>So, we've seen there is no label for local_var_name, that's why linker hasn't found it. But we are hackers :) and we can fix it. Open src1.s in your text editor and change</p>\n<pre><code>.local  _ZL14local_var_name\n.comm   _ZL14local_var_name,4,4\n</code></pre>\n<p>to </p>\n<pre><code>    .globl  local_var_name\n    .data\n    .align 4\n    .type   local_var_name, @object\n    .size   local_var_name, 4\nlocal_var_name:\n    .long   456789\n</code></pre>\n<p>i.e. you should have like below</p>\n<pre><code>    .file   \"src1.cpp\"\n    .globl  local_var_name\n    .data\n    .align 4\n    .type   local_var_name, @object\n    .size   local_var_name, 4\nlocal_var_name:\n    .long   456789\n    .globl  global_var_name\n    .align 4\n    .type   global_var_name, @object\n    .size   global_var_name, 4\nglobal_var_name:\n    .long   123\n    .text\n    .globl  main\n    .type   main, @function\nmain:\n; ...\n</code></pre>\n<p>we have changed the visibility of local_var_name and set its value to 456789.\nTry to build an object file from it</p>\n<pre><code>$ g++ -c src1.s -o src2.o\n</code></pre>\n<p>ok, see readelf output (symbols)</p>\n<pre><code>$ readelf --symbols src1.o\n8: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 local_var_name\n</code></pre>\n<p>now local_var_name has Bind GLOBAL (was LOCAL)</p>\n<p>link</p>\n<pre><code>$ g++ src1.o src2.o -o prog\n</code></pre>\n<p>and run it</p>\n<pre><code>$ ./prog \n123456789\n</code></pre>\n<p>ok, we hack it :)</p>\n<p>So, as a result - an \"undefined reference/unresolved external symbol error\" happens when the linker cannot find global symbols in the object files.</p>\n", "OwnerUserId": "1526758"}, "12574400": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "0", "Body": "<h3>Failure to link against appropriate libraries/object files or compile implementation files</h3>\n<p>Commonly, each translation unit will generate an object file that contains the definitions of the symbols defined in that translation unit. \nTo use those symbols, you have to link against those object files.</p>\n<p>Under <strong>gcc</strong> you would specify all object files that are to be linked together in the command line, or compile the implementation files together.</p>\n<pre><code>g++ -o test objectFile1.o objectFile2.o -lLibraryName\n</code></pre>\n<p>The <code>libraryName</code> here is just the bare name of the library, without platform-specific additions. So e.g. on Linux library files are usually called <code>libfoo.so</code> but you'd only write <code>-lfoo</code>. On Windows that same file might be called <code>foo.lib</code>, but you'd use the same argument. You might have to add the directory where those files can be found using <code>-L\u2039directory\u203a</code>. Make sure to not write a space after <code>-l</code> or <code>-L</code>.</p>\n<p>For <strong>XCode</strong>:  Add the User Header Search Paths -&gt; add the Library Search Path -&gt; drag and drop the actual library reference into the project folder.</p>\n<p>Under <strong>MSVS</strong>, files added to a project automatically have their object files linked together and a <code>lib</code> file would be generated (in common usage). To use the symbols in a separate project, you'd \nneed to include the <code>lib</code> files in the project settings. This is done in the Linker section of the project properties, in <code>Input -&gt; Additional Dependencies</code>. (the path to the <code>lib</code> file should be\nadded in <code>Linker -&gt; General -&gt; Additional Library Directories</code>) When using a third-party library that is provided with a <code>lib</code> file, failure to do so usually results in the error.</p>\n<p>It can also happen that you forget to add the file to the compilation, in which case the object file won't be generated. In <strong>gcc</strong> you'd add the files to the command line. In <strong>MSVS</strong> adding the file to the project will make it compile it automatically (albeit files can, manually, be individually excluded from the build).</p>\n<p>In Windows programming, the tell-tale sign that you did not link a necessary library is that the name of the unresolved symbol begins with <code>__imp_</code>. Look up the name of the function in the documentation, and it should say which library you need to use. For example, MSDN puts the information in a box at the bottom of each function in a section called \"Library\".</p>\n", "OwnerUserId": "673730", "LastEditorUserId": "1468366", "LastEditDate": "2016-08-23T09:32:00.190", "Id": "12574400", "Score": "84", "CreationDate": "2012-09-24T23:37:30.810", "LastActivityDate": "2016-08-23T09:32:00.190"}, "22160071": {"ParentId": "12573816", "PostTypeId": "2", "CommentCount": "1", "Body": "<p><strong>undefined reference to <code>WinMain@16</code> or similar <em>'unusual'</em> <code>main()</code> entry point reference</strong> (especially for <a class=\"post-tag\" href=\"/questions/tagged/visual-studio\" rel=\"tag\" title=\"show questions tagged 'visual-studio'\">visual-studio</a>).</p>\n<p>You may have missed to choose the right project type with your actual IDE. The IDE may want to bind e.g. Windows Application projects to such entry point function (as specified in the missing reference above), instead of the commonly used <code>int main(int argc, char** argv);</code> signature.</p>\n<p>If your IDE supports <em>Plain Console Projects</em> you might want to choose this project type, instead of a windows application project.</p>\n", "OwnerUserId": "1413395", "LastEditorUserId": "1413395", "LastEditDate": "2014-03-04T00:13:01.683", "Id": "22160071", "Score": "29", "CreationDate": "2014-03-03T23:52:27.623", "LastActivityDate": "2014-03-04T00:13:01.683"}, "45478255": {"ParentId": "12573816", "CommentCount": "0", "Body": "<h2>Missing \"extern\" in <code>const</code> variable declarations/definitions (C++ only)</h2>\n<p>For people coming from C it might be a surprise that in C++ global <code>const</code>variables have internal (or static) linkage. In C this was not the case, as all global variables are implicitly <code>extern</code> (i.e. when the <code>static</code> keyword is missing).</p>\n<p>Example: </p>\n<pre><code>// file1.cpp\nconst int test = 5;    // in C++ same as \"static const int test = 5\"\nint test2 = 5;\n\n// file2.cpp\nextern const int test;\nextern int test2;\n\nvoid foo()\n{\n int x = test;   // linker error in C++ , no error in C\n int y = test2;  // no problem\n}\n</code></pre>\n<p>correct would be to use a header file and include it in file2.cpp <em>and</em> file1.cpp</p>\n<pre><code>extern const int test;\nextern int test2;\n</code></pre>\n<p>Alternatively one could declare the <code>const</code> variable in file1.cpp with explicit <code>extern</code></p>\n", "OwnerUserId": "1739884", "PostTypeId": "2", "Id": "45478255", "Score": "3", "CreationDate": "2017-08-03T08:01:49.237", "LastActivityDate": "2017-08-03T08:01:49.237"}});