post_cb({"28097419": {"ViewCount": "335", "Body": "<p>If I have a container and call <code>clear()</code> on it, does that <em>just</em> destruct all of the elements inside or does it actually free/allocate new memory internally too? Is this behavior outside the scope of the C++ standard?</p>\n<p>This boils down to:</p>\n<pre><code>unordered_set&lt;int&gt; mySet { 1, 2, 3, 4, 5 };\nmySet.reserve(1000);\nmySet.clear();\n\n//Is this pointless/redundant\n//or should I treat my container like it was just constructed?\nmySet.reserve(1000);\n</code></pre>\n<p>A quick test on ideone (<a href=\"http://ideone.com/XQi8IT\" rel=\"noreferrer\">http://ideone.com/XQi8IT</a>) shows that the internal memory buffer is retained after a call to clear. So, at least for new versions of g++ on <code>unordered_set</code> that is the case. My question goes to 1) what the standard says, if anything and 2) whether this behavior is consistent across all containers.</p>\n", "AcceptedAnswerId": "28097899", "Title": "Does container.clear() free/reallocate internal buffers?", "CreationDate": "2015-01-22T19:48:42.063", "Id": "28097419", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2015-01-25T10:29:54.687", "Score": "10", "OwnerUserId": "2843835", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_28097419_28097899_0": {"length": 14, "quality": 1.0, "section_id": 723}, "so_28097419_28097899_3": {"length": 18, "quality": 1.0, "section_id": 744}, "so_28097419_28097899_1": {"length": 4, "quality": 1.0, "section_id": 723}, "so_28097419_28097899_4": {"length": 8, "quality": 1.0, "section_id": 763}}, "n3337": {"so_28097419_28097899_0": {"length": 14, "quality": 1.0, "section_id": 712}, "so_28097419_28097899_3": {"length": 18, "quality": 1.0, "section_id": 733}, "so_28097419_28097899_1": {"length": 4, "quality": 1.0, "section_id": 712}, "so_28097419_28097899_4": {"length": 8, "quality": 1.0, "section_id": 750}}, "n4659": {"so_28097419_28097899_0": {"length": 14, "quality": 1.0, "section_id": 754}, "so_28097419_28097899_3": {"length": 18, "quality": 1.0, "section_id": 802}, "so_28097419_28097899_4": {"length": 7, "quality": 0.875, "section_id": 823}}}, "28098365": {"Id": "28098365", "PostTypeId": "2", "Body": "<p>There is no requirement in the C++ standard for any standard container to free any memory. Even the function <code>std::vector&lt;T&gt;::shrink_to_fit()</code> only requests the shrinking of memory. This function is thought to replace idioms like</p>\n<pre><code>std::vector&lt;T&gt;().swap( myVector );\n</code></pre>\n<p>This idiom was used to really free memory, which is not guaranteed by <code>std::vector&lt;T&gt;::clear()</code>. (In fact, <code>std::vector&lt;T&gt;::clear()</code> is specified to leave the <code>capacity()</code> unchanged.) You can still use this idiom for other containers though, which do not have a function <code>shrink_to_fit()</code>. </p>\n", "LastActivityDate": "2015-01-22T20:45:11.757", "CommentCount": "0", "CreationDate": "2015-01-22T20:45:11.757", "ParentId": "28097419", "Score": "3", "OwnerUserId": "1335865"}, "28097899": {"Id": "28097899", "PostTypeId": "2", "Body": "<p>It's unspecified with what happens to the memory. It just defines the following requirements:</p>\n<p>For sequence containers we have the following requirements for <code>clear()</code>:</p>\n<p><code>[C++11 \u00a723.2.3]</code> Table 100</p>\n<blockquote>\n<p id=\"so_28097419_28097899_0\">Destroys all elements in <code>a</code>. Invalidates all references, pointers,\n  and iterators referring to the elements of <code>a</code> and may invalidate the\n  past-the-end iterator. </p>\n<p id=\"so_28097419_28097899_1\">post: <code>a.empty()</code> returns <code>true</code></p>\n</blockquote>\n<p>Which doesn't really mention anything about memory. For associate containers we have this requirement for <code>clear()</code>:</p>\n<p><code>[C++11 \u00a723.2.4]</code> Table 102</p>\n<blockquote>\n<p id=\"so_28097419_28097899_2\"><code>a.erase(a.begin(),a.end())</code></p>\n</blockquote>\n<p>Which leads to <code>erase(...)</code> requirements which are:</p>\n<blockquote>\n<p id=\"so_28097419_28097899_3\">erases the element pointed to by <code>q</code>. Returns an iterator pointing to the element immediately following <code>q</code> prior to the element being erased. If no such element exists, returns <code>a.end()</code></p>\n</blockquote>\n<p>Which again, mentions nothing about the capacity of the memory buffer of the container. Then we have unordered associate containers which have similar wording:</p>\n<p><code>[C++11 \u00a723.2.5]</code> Table 103</p>\n<blockquote>\n<p id=\"so_28097419_28097899_4\">Erases all elements in the container. Post: <code>a.empty()</code> returns <code>true</code></p>\n</blockquote>\n<p>Overall, the standard doesn't mention anything happens to the internal memory buffers after <code>clear</code>. So that's unspecified behaviour that could vary amongst different implementations.</p>\n<p>Since <code>reserve</code> is not available in all containers (which does change the capacity) and neither is the next best thing (<code>shrink_to_fit</code>) there doesn't seem to be a good way to consistently clear out the internal memory of a container.</p>\n", "LastActivityDate": "2015-01-22T20:16:31.820", "CommentCount": "1", "CreationDate": "2015-01-22T20:16:31.820", "ParentId": "28097419", "Score": "13", "OwnerUserId": "1381108"}});