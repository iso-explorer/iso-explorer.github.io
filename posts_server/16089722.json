post_cb({"16089789": {"ParentId": "16089722", "CommentCount": "11", "Body": "<p>Yes, it's indeed UB (Undefined Behaviour). You cannot modify a <code>const</code> object once it's initialised. What you should do is use the member initialiser list, perhaps together with a function:</p>\n<pre><code>struct qqq {\n  const vector&lt;foo&gt; my_foo;\n\n  qqq(vector&lt;foo&gt; *other) : my_foo(initialiseFoo(*other)) {}\n\n  static vector&lt;foo&gt; initialiseFoo(vector&lt;foo&gt; &amp;other) {\n    vector&lt;foo&gt; tmp;\n    other.swap(tmp);\n    return tmp;\n  }\n};\n</code></pre>\n<p>A decent optimiser should be able to get rid of the temporary.</p>\n<p>If you can use C++11, it's actually even simpler:</p>\n<pre><code>struct qqq {\n  const vector&lt;foo&gt; my_foo;\n\n  qqq(vector&lt;foo&gt; *other) : my_foo(std::move(*other))\n  {\n    other-&gt;clear();  //Just in case the implementation of moving vectors is really weird\n  }\n};\n</code></pre>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "16089789", "Score": "2", "CreationDate": "2013-04-18T17:45:13.500", "LastActivityDate": "2013-04-18T17:45:13.500"}, "16089757": {"ParentId": "16089722", "PostTypeId": "2", "CommentCount": "5", "Body": "<p><strong>It is Undefined Behavior</strong>. Per Paragraph 7.1.6.1/4 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16089722_16089757_0\">Except that any class member declared <code>mutable</code> (7.1.1) can be modified, any attempt to modify a <code>const</code>\n  object during its lifetime (3.8) results in undefined behavior.</p>\n</blockquote>\n<p>In this case, it seems like you want your object to \"become\" constant after construction. This is not possible. </p>\n<p>If your <code>vector</code> is meant to be <code>const</code>, you shall initialize it in the constructor's <a href=\"http://www.cprogramming.com/tutorial/initialization-lists-c++.html\" rel=\"nofollow\"><strong>initialization list</strong></a>:</p>\n<pre><code>qqq(vector&lt;foo&gt;&amp; other) \n    : my_foo(std::move(other)) \n//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n{\n}\n</code></pre>\n<p>Notice, that unless you have a good reason for passing by pointer - in which case, you should also be checking whether the pointer is non-null - you should consider passing by reference (as shown above), which is the common practice.</p>\n<p><strong>UPDATE:</strong></p>\n<p>As Pete Becker correctly points out in the comments, proper design would suggest that the decision to move from the <code>vector</code> argument should belong to the <em>caller</em> of <code>qqq</code>'s constructor, and not to the constructor itself.</p>\n<p>If the constructor is always supposed to move from its argument, then you could let it accept an rvalue reference, making it clear what the constructor itself is expecting out of the caller:</p>\n<pre><code>qqq(vector&lt;foo&gt;&amp;&amp; other) \n//             ^^\n    : my_foo(std::move(other)) \n//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n{\n}\n</code></pre>\n<p>This way, the caller would have to provide an <em>rvalue</em> in input to <code>qqq</code>'s constructor:</p>\n<pre><code>std::vector&lt;foo&gt; v;\n// ...\nqqq q1(v); // ERROR!\nqqq q2(std::move(v)); // OK! Now the client is aware that v must be moved from\n</code></pre>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-04-18T18:26:43.367", "Id": "16089757", "Score": "5", "CreationDate": "2013-04-18T17:43:33.750", "LastActivityDate": "2013-04-18T18:26:43.367"}, "bq_ids": {"n4140": {"so_16089722_16089757_0": {"section_id": 5433, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_16089722_16089757_0": {"section_id": 5228, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_16089722_16089757_0": {"section_id": 6861, "quality": 0.9444444444444444, "length": 17}}}, "16089722": {"CommentCount": "7", "ViewCount": "675", "CreationDate": "2013-04-18T17:40:58.097", "LastActivityDate": "2013-04-18T18:26:43.367", "Title": "const_cast a const member in a class constructor", "AcceptedAnswerId": "16089757", "PostTypeId": "1", "Id": "16089722", "Score": "3", "Body": "<p>I sometimes use const_cast when I want a member variable of a class to be constant during the life of the class, but it needs to be mutable during the constructor.  Example:</p>\n<pre><code>struct qqq {\n const vector&lt;foo&gt; my_foo;\n\n  qqq(vector&lt;foo&gt;* other) {\n    vector&lt;foo&gt;&amp; mutable_foo = const_cast&lt;vector&lt;foo&gt;&amp;&gt;(my_foo)\n    other-&gt;swap(mutable_foo);\n  }\n};\n</code></pre>\n<p>I had assumed that doing this in the constructor was basically OK because nobody else is relying on it at this point so it wouldn't interact badly with optimization, etc.</p>\n<p>However recently someone told me this is \"undefined behavior\" and that it's basically illegal to mutate a const object after it's been constructed under any circumstance.</p>\n<p>Can someone clarify?  Is this a bad / undefined behavior / thing to do?</p>\n", "Tags": "<c++><constructor><const>", "OwnerUserId": "1148117", "AnswerCount": "2"}});