post_cb({"bq_ids": {"n4140": {"so_18895737_18896048_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 3325}, "so_18895737_18895841_1": {"length": 11, "quality": 1.0, "section_id": 386}}, "n3337": {"so_18895737_18896048_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 599}, "so_18895737_18895841_1": {"length": 11, "quality": 1.0, "section_id": 377}}, "n4659": {"so_18895737_18896048_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 4091}, "so_18895737_18895841_1": {"length": 11, "quality": 1.0, "section_id": 403}}}, "18895841": {"Id": "18895841", "PostTypeId": "2", "Body": "<p><code>B b{\"Hey\"};</code> requires conversion to <code>std::string</code> and then conversion to <code>A</code>, and that are two conversions.</p>\n<blockquote>\n<p id=\"so_18895737_18895841_0\">Does constructor conversion really only work with a single conversion, and why is this the case?</p>\n</blockquote>\n<p>Yes. That is what the standard requires.</p>\n<p>[class.conv]/4 :</p>\n<blockquote>\n<p id=\"so_18895737_18895841_1\">At most one user-defined conversion (constructor or conversion function) is implicitly applied to a single value.</p>\n</blockquote>\n", "LastActivityDate": "2013-09-19T13:22:16.093", "CommentCount": "0", "CreationDate": "2013-09-19T13:22:16.093", "ParentId": "18895737", "Score": "2", "OwnerUserId": "476681"}, "18896048": {"Id": "18896048", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_18895737_18896048_0\">Does constructor conversion really only work with a single conversion?</p>\n</blockquote>\n<p>A single <em>user-defined</em> conversion, yes. It can also involve standard conversions before or after that conversion.</p>\n<blockquote>\n<p id=\"so_18895737_18896048_1\">why is this the case?</p>\n</blockquote>\n<p>The simple answer is because that's how the language is specified.</p>\n<p>More usefully: if two conversions were allowed, then the compiler would have to consider <em>every type</em> that it knows about, to determine whether there's a suitable intermediate type. Not only would this be a lot of work (with a combinatorial explosion, if you allow any number of conversions), but you're likely to get ambiguities, and subtle changes of behaviour depending on which types happen to be defined at that point in the code.</p>\n", "LastActivityDate": "2013-09-19T13:31:00.810", "CommentCount": "0", "CreationDate": "2013-09-19T13:31:00.810", "ParentId": "18895737", "Score": "3", "OwnerUserId": "204847"}, "18895737": {"ViewCount": "114", "Body": "<p>Implicit constructor conversion only seems to work with a single conversion.</p>\n<pre><code>class A {\npublic:\n    A(std::string s) {}\n};\nclass B {\npublic:\n    B(A a) { }\n};\n</code></pre>\n<p>With the above code, running</p>\n<pre><code>B b{std::string(\"Hey\")};\n</code></pre>\n<p>works fine. </p>\n<p>On the other hand,</p>\n<pre><code>B b{\"Hey\"};\n</code></pre>\n<p>does not.</p>\n<p>Does constructor conversion really only work with a single conversion, and why is this the case? To avoid possible ambiguity when different constructors are provided? </p>\n", "AcceptedAnswerId": "18896048", "Title": "Multiple implicit constructor conversion", "CreationDate": "2013-09-19T13:17:37.607", "Id": "18895737", "CommentCount": "3", "LastEditDate": "2013-09-19T13:27:58.013", "PostTypeId": "1", "LastEditorUserId": "1930535", "LastActivityDate": "2013-09-19T13:31:00.810", "Score": "1", "OwnerUserId": "1930535", "Tags": "<c++><c++11>", "AnswerCount": "2"}});