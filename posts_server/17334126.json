post_cb({"17334170": {"ParentId": "17334126", "CommentCount": "0", "Body": "<p>C++11, \u00a73.9.1/6:</p>\n<blockquote>\n<p id=\"so_17334126_17334170_0\">Values of type bool are either true or false. [...]</p>\n</blockquote>\n", "OwnerUserId": "777186", "PostTypeId": "2", "Id": "17334170", "Score": "2", "CreationDate": "2013-06-27T03:43:45.623", "LastActivityDate": "2013-06-27T03:43:45.623"}, "17334156": {"ParentId": "17334126", "CommentCount": "0", "Body": "<p><code>bool a = 0x03;</code> converts 0x03 to a boolean value. Since every numeric value that is not zero will be evaluated to be true, you'll see the first result, regardless of which data you'll assign.</p>\n", "OwnerUserId": "951423", "PostTypeId": "2", "Id": "17334156", "Score": "4", "CreationDate": "2013-06-27T03:41:37.520", "LastActivityDate": "2013-06-27T03:41:37.520"}, "17334277": {"ParentId": "17334126", "CommentCount": "0", "Body": "<p>A <code>bool</code> can only hold two values: <code>false</code> and <code>true</code>.</p>\n<p>When/if used in an integer context, a <code>bool</code> can be converted to an <code>int</code>. In this case, <code>false</code> converts to <code>0</code> and <code>true</code> converts to <code>1</code>.</p>\n<p>Regardless of the size of storage used for a <code>bool</code> (e.g., <code>sizeof(bool)==1</code> and <code>sizeof(bool)==4</code> are both fairly common) it can still only hold the two values <code>false</code> and <code>true</code>, which always convert to <code>0</code> and <code>1</code> respectively. No other value is possible.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "17334277", "Score": "1", "CreationDate": "2013-06-27T03:58:57.083", "LastActivityDate": "2013-06-27T03:58:57.083"}, "17334182": {"ParentId": "17334126", "CommentCount": "0", "Body": "<p>\u00a74.12 Boolean conversions [conv.bool]</p>\n<blockquote>\n<p id=\"so_17334126_17334182_0\">1 A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a prvalue of type bool. <strong>A zero value, null pointer value, or null member pointer value is converted to false</strong>; <strong>any other value is converted to true</strong>. A prvalue of type std::nullptr_t can be converted to a prvalue of type bool; the resulting value is false.</p>\n</blockquote>\n", "OwnerUserId": "951757", "PostTypeId": "2", "Id": "17334182", "Score": "7", "CreationDate": "2013-06-27T03:44:30.113", "LastActivityDate": "2013-06-27T03:44:30.113"}, "17334154": {"ParentId": "17334126", "CommentCount": "2", "Body": "<p>Why would you even think you could?\nIt's like saying <code>int i = \"abc\";</code>.</p>\n", "OwnerUserId": "857132", "PostTypeId": "2", "Id": "17334154", "Score": "0", "CreationDate": "2013-06-27T03:41:22.100", "LastActivityDate": "2013-06-27T03:41:22.100"}, "17334389": {"ParentId": "17334126", "CommentCount": "0", "Body": "<p>The only values you can <em>legitimately</em> store in a <code>bool</code> object are <code>false</code> and <code>true</code>. All conversions from other types to <code>bool</code> yield one of those two values. A <code>bool</code> object is always at least 8 bits in size (unless it's a bit field), but the language deliberately makes it difficult to store any of the other 254 (or more) possible values.</p>\n<p>You <em>can</em> play tricks, like using <code>memcpy</code>, or using a union, or using pointer conversions, to store any other value that will fit. But if you do so, it <em>probably</em> makes your program's behavior undefined. What that means is that the compiler is permitted to generate code that <em>assumes</em> the stored value is either <code>false</code> or <code>true</code> (or <code>0</code> or <code>1</code>). Store something else, and your program's behavior is unpredictable.</p>\n<p><code>bool</code> is at least 8 bits because the C++ memory model doesn't deal well with sub-byte objects (other than bit fields). You're not supposed to use those other 7 (or more) bits.</p>\n<p>IF you want to store more than 2 values in an object, don't make it a <code>bool</code>.</p>\n", "OwnerUserId": "827263", "PostTypeId": "2", "Id": "17334389", "Score": "2", "CreationDate": "2013-06-27T04:09:46.417", "LastActivityDate": "2013-06-27T04:09:46.417"}, "17334126": {"CommentCount": "1", "ViewCount": "1125", "PostTypeId": "1", "LastEditorUserId": "951757", "CreationDate": "2013-06-27T03:38:05.600", "LastActivityDate": "2013-07-07T06:34:27.510", "Title": "Can a bool variable store more than 0x01?", "LastEditDate": "2013-07-07T06:34:27.510", "Id": "17334126", "Score": "2", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;bitset&gt;\n\nusing namespace std;\n\nint main()\n{\n    bool a = 0x03;\n    bitset&lt;8&gt; x(a);\n    cout&lt;&lt;x&lt;&lt;endl;\n\n    a = a&gt;&gt;1;\n    bitset&lt;8&gt; y(a);\n    cout&lt;&lt;y&lt;&lt;endl; \n}\n</code></pre>\n<p>The result is:</p>\n<pre><code>00000001    \n00000000\n</code></pre>\n<p>The result is <strong>not</strong>:</p>\n<pre><code>00000011\n00000001\n</code></pre>\n<p>If I change the type of <code>a</code> from <code>bool</code> to <code>char</code>, the result will be the second one.\nIt means that I cannot store more than 0x01 in a <code>bool</code>, all right value greater than 0x01 are treat as 0x01. </p>\n<p>All compiler has the behavior?  </p>\n", "Tags": "<c++><binary><boolean><shift>", "OwnerUserId": "2261693", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_17334126_17334170_0": {"section_id": 7215, "quality": 1.0, "length": 6}, "so_17334126_17334182_0": {"section_id": 44, "quality": 1.0, "length": 39}}, "n3337": {"so_17334126_17334170_0": {"section_id": 6959, "quality": 1.0, "length": 6}, "so_17334126_17334182_0": {"section_id": 41, "quality": 1.0, "length": 39}}, "n4659": {"so_17334126_17334170_0": {"section_id": 8724, "quality": 1.0, "length": 6}, "so_17334126_17334182_0": {"section_id": 45, "quality": 1.0, "length": 39}}}});