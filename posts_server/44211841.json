post_cb({"44211924": {"ParentId": "44211841", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The short answer is \"no\".</p>\n<p>Floating point representation is implementation defined, and the type of concerns you mention between floating point types also occur when converting floating point values to other types.</p>\n<p>Also, a number of properties of <code>int</code> - including size, range of values it can represent, and representation (e.g. organisation of bits) are also implementation defined.</p>\n<p>The net effect is that some conversions from <code>float</code> to <code>int</code> will work reliably between implementations, and some won't.   Some values will be rounded down when converting <code>float</code> to <code>int</code>.    A <code>float</code> can also represent a larger range of values than an <code>int</code>,and converting \"out of range\" values can give undefined behaviour.</p>\n<p>Rather than trying to use floating point literals to initialise your variables, consider using string literals (and wrapping the values in double quotes).   The tradeoff is overhead of parsing a string to initialise your variables.</p>\n", "OwnerUserId": "4706785", "LastEditorUserId": "4706785", "LastEditDate": "2017-05-27T03:53:27.730", "Id": "44211924", "Score": "5", "CreationDate": "2017-05-27T01:05:52.820", "LastActivityDate": "2017-05-27T03:53:27.730"}, "44211841": {"CommentCount": "6", "ViewCount": "109", "CreationDate": "2017-05-27T00:48:11.290", "LastActivityDate": "2017-05-27T03:53:27.730", "Title": "Is conversion from float to int consistent across all platforms and processor architectures?", "AcceptedAnswerId": "44211924", "PostTypeId": "1", "Id": "44211841", "Score": "2", "Body": "<p>I'm working on a multiplayer game that depends so called \"floating point determinism\", or in other words, the result of all calculations must be exactly the same across everyone running the game.  This essentially means not using IEEE 754 floating point since operations can result in different values depending on rounding modes, fused multiply-add or inverse square root instructions being used, different libc implementations, etc etc.</p>\n<p>So I've gone and made fixed point versions of all the basic arithmetic operations and even some transcendental functions.  However I'd still like to use floating point literals for configuring gameplay variables.  In doing so, I end up with some code that looks like this to convert from floating point to fixed point:</p>\n<pre><code>explicit NetFixedPoint(float val)\n{\n  static const StorageType kOne = StorageType(1) &lt;&lt; FractionalBits;\n  m_Value = ((StorageType)(val * kOne));\n}\n</code></pre>\n<p>Will this give me the same result across all platforms and processor architectures?</p>\n", "Tags": "<c++><c><floating-point>", "OwnerUserId": "8072721", "AnswerCount": "3"}, "44211915": {"ParentId": "44211841", "CommentCount": "1", "Body": "<p>The details of a C++ implementation's conversion from floating point values to integer values is mostly a moot point, when the C++ standard does not give much of a guarantee as to what a floating point value is in the first place.</p>\n<p>The C++ standard only guarantees you that:</p>\n<blockquote>\n<p id=\"so_44211841_44211915_0\">[basic.fundamental]</p>\n<p id=\"so_44211841_44211915_1\">There are three floating point types: float, double, and long double.\n  The type double provides at least as much precision as float, and the\n  type long double provides at least as much precision as double. The\n  set of values of the type float is a subset of the set of values of\n  the type double; the set of values of the type double is a subset of\n  the set of values of the type long double. <strong><em>The value representation of\n  floating-point types is implementation-defined.</em></strong></p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>When \"the value of representation of floating-point types is implementation-defined\", that pretty much rules everything out. You do not have any kind of a guarantee on floating to integer value conversion consistency between different C++ implementations, since the standard does not give you any guarantee that different C++ implementations' floating point values will have consistent value representations in the first place!</p>\n<p>If you need well-defined floating point semantics, your only realistic option is to use special-purpose, arbitrary precision math libraries, like Gnu MP, where you get complete control over floating point precision and value conversions.</p>\n", "OwnerUserId": "3943312", "PostTypeId": "2", "Id": "44211915", "Score": "1", "CreationDate": "2017-05-27T01:04:47.660", "LastActivityDate": "2017-05-27T01:04:47.660"}, "44211999": {"ParentId": "44211841", "CommentCount": "4", "Body": "<p>Conversion from floating point to integer is strictly defined if the floating point value, truncated towards zero, is representable in the integer type. If not, it's undefined.</p>\n<p>The other answers seem to be being intentionally obtuse; if you're depending on any kind of floating point determinism at all, you need to be assuming an implementation that conforms to IEEE-754, not the bogus gratuitous generality the C++ standard allows for implementations that don't conform to IEEE-754. In this case you have a fair degree of determinism, assuming your compiler isn't buggy, and your concerns will be in areas other than float to int conversion.</p>\n", "OwnerUserId": "379897", "PostTypeId": "2", "Id": "44211999", "Score": "4", "CreationDate": "2017-05-27T01:16:34.743", "LastActivityDate": "2017-05-27T01:16:34.743"}, "bq_ids": {"n4140": {"so_44211841_44211915_1": {"section_id": 7217, "quality": 0.9019607843137255, "length": 46}}, "n3337": {"so_44211841_44211915_1": {"section_id": 6961, "quality": 0.9019607843137255, "length": 46}}, "n4659": {"so_44211841_44211915_1": {"section_id": 8726, "quality": 0.8823529411764706, "length": 45}}}});