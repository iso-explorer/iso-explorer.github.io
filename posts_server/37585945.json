post_cb({"bq_ids": {"n4140": {"so_37585945_37586303_0": {"length": 4, "quality": 0.8, "section_id": 482}}, "n3337": {"so_37585945_37586303_0": {"length": 4, "quality": 0.8, "section_id": 473}}, "n4659": {"so_37585945_37586047_0": {"length": 48, "quality": 0.96, "section_id": 464}}}, "37585945": {"ViewCount": "171", "Body": "<p>Consider following code:</p>\n<pre><code>class TBase {\npublic:\n   TBase();\n   TBase(const TBase &amp;);\n};\n\nclass TDerived: public TBase {\npublic:\n   using TBase::TBase;\n};\n\nvoid f() {\n   TBase Base;\n   TDerived Derived(Base); // &lt;=== ERROR\n}\n</code></pre>\n<p>so, I have base and derived classes, and want to use \"using TBase::TBase\" to pull copy ctor from base class to be able to create instance of derived class in such way:</p>\n<pre><code>   TDerived Derived(Base);\n</code></pre>\n<p>But <a href=\"https://gcc.godbolt.org/#compilers:!((compiler:clang380,options:'-O3+-std%3Dc%2B%2B11',sourcez:AQ4YwGwQwZx4AqAhWBTYBvAUKYAHAVwCMIBLMALh11GTQAoBKAbmpsRRlXrAHsA7GABcOaYADIWbYAF9W0yLHgIAIqgBOpAG6oAJhXzEyYUV0zTCJclXYgCMUvwDmp1BQp0urXHKxYtvKS6wABmTOa0nOhR3iCqGtp6wGqaOrr0UVJYMkAA%3D)),filterAsm:(commentOnly:!t,directives:!t,labels:!t),version:3\" rel=\"nofollow\">all compilers</a> rejects this with these error messages</p>\n<pre><code>7 : note: candidate constructor (the implicit copy constructor) not viable: no known conversion from 'TBase' to 'const TDerived' for 1st argument\n</code></pre>\n<p>Why? What am I doing wrong? Why \"using TBase::TBase\" does not work in this situation?</p>\n<p><strong>UPDATE</strong>\nHow can be explained following piece of code from <a href=\"http://en.cppreference.com/w/cpp/language/using_declaration\" rel=\"nofollow\">cppreference.com</a>?</p>\n<pre><code>struct B1 {\n    B1(int);\n};\nstruct D1 : B1 {\n    using B1::B1;\n// The set of inherited constructors is \n// 1. B1(const B1&amp;)\n// 2. B1(B1&amp;&amp;)\n// 3. B1(int)\n</code></pre>\n", "AcceptedAnswerId": "37586303", "Title": "C++, inherited copy ctors does not work?", "CreationDate": "2016-06-02T08:00:22.850", "Id": "37585945", "CommentCount": "1", "LastEditDate": "2016-06-02T08:13:26.053", "PostTypeId": "1", "LastEditorUserId": "2928427", "LastActivityDate": "2016-06-02T10:21:55.740", "Score": "3", "OwnerUserId": "2928427", "Tags": "<c++><c++11>", "AnswerCount": "3"}, "37586300": {"Id": "37586300", "PostTypeId": "2", "Body": "<p>If you further read the same piece of code, it says:</p>\n<pre><code>// D1 has the following constructors:\n// 1. D1()\n// 2. D1(const D1&amp;) \n// 3. D1(D1&amp;&amp;)\n// 4. D1(int) &lt;- inherited\n};\n</code></pre>\n<p>Thus a copy ctor is still the copy ctor, it accepts an argument of class TDerived. D1(int) is generated automatically nevertheless.</p>\n", "LastActivityDate": "2016-06-02T08:18:06.167", "CommentCount": "0", "CreationDate": "2016-06-02T08:18:06.167", "ParentId": "37585945", "Score": "3", "OwnerUserId": "2749717"}, "37586047": {"Id": "37586047", "PostTypeId": "2", "Body": "<p>As per standard <em>12.6.3/p1 Initialization by inherited constructor [class.inhctor.init]</em> (<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_37585945_37586047_0\"><strong>When a constructor for type <code>B</code> is invoked to initialize an object of a\n  different type <code>D</code> (that is, when the constructor was inherited\n  (7.3.3)), initialization proceeds as if a defaulted default\n  constructor were used to initialize the <code>D</code> object and each base class\n  subobject from which the constructor was inherited, except that the <code>B</code>\n  subobject is initialized by the invocation of the inherited\n  constructor.</strong> The complete initialization is considered to be a single\n  function call; in particular, the initialization of the inherited\n  constructor\u2019s parameters is sequenced before the initialization of any\n  part of the <code>D</code> object.</p>\n</blockquote>\n<p>Thus, constructors are not actually inherited but rather they're implicitly or explicitly called by the respective derived constructor. Also keep in mind that the inherited constructors are simply calling the base constructors and do not perform any member initialization in the derived object.</p>\n<p>To clarify this consider the following example:</p>\n<pre><code>struct Base {\n  Base(int);\n  ...\n};\n\nstruct Derived : Base {\n  using Base::Base;\n  ...\n};\n</code></pre>\n<p>The above <code>Derived</code> class definition is syntactically equivalent with:  </p>\n<pre><code>struct Derived : Base {\n  Derived(int i) : Base(i) {}\n  ...\n};\n</code></pre>\n<p>That is, the <code>using</code> declaration in the <code>Derived</code> class implicitly defines the constructor <code>Derived(int)</code>. At this point mind also that if the constructor is inherited from multiple base class sub-objects Derived, the program is ill-formed.</p>\n<p>In the same manner you've been lead to the logical conclusion that since I've declared in the base class a copy constructor with the using declaration:</p>\n<pre><code>class TBase {\npublic:\n   TBase();\n   TBase(const TBase &amp;);\n};\n\nclass TDerived: public TBase {\npublic:\n   using TBase::TBase;\n};\n</code></pre>\n<p>I would get the following syntactical equivalent <code>Derived</code> class:</p>\n<pre><code>class TDerived: public TBase {\npublic:\n   TDerived() : Base() {}\n   TDerived(TBase const &amp;other) : Base(other) {}\n};\n</code></pre>\n<p>However, this is not the case. You can't \"inherit\" a copy constructor neither a default constructor neither a move constructor. Why? because this is how the C++ standard dictates so.</p>\n<p>What you can do instead is to define a user defined constructor that will take as input a base class object:</p>\n<pre><code>class TDerived: public TBase {\npublic:\n   TDerived(TBase const &amp;other) {}\n};\n</code></pre>\n<p>After all <code>TDerived</code> and <code>TBase</code> are different classes even though the first inherits the second one.</p>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2016-06-02T10:21:55.740", "Score": "1", "CreationDate": "2016-06-02T08:05:09.070", "ParentId": "37585945", "CommentCount": "1", "OwnerUserId": "2352671", "LastEditDate": "2016-06-02T10:21:55.740"}, "37586303": {"Id": "37586303", "PostTypeId": "2", "Body": "<p>Copy and move consturctors (and the default constructor) are never inherited, simply because the standard says so. All other constructors are.</p>\n<p>That comment on cppreference was misleading<sup>(1)</sup>. The same comment in the standard says:</p>\n<blockquote>\n<p id=\"so_37585945_37586303_0\">The <strong>candidate set</strong> of inherited constructors in <code>D1</code> for <code>B1</code> is</p>\n</blockquote>\n<p>(Emphasis mine).</p>\n<p>The standard then goes on to say that only the <code>D1(int)</code> constructor is actually inherited. The copy and move constructors for <code>D1</code> are implicitly-declared as for any other class, <em>not</em> inherited.</p>\n<p>Refer to C++14 12.9 [class.inhctor] for details.</p>\n<hr>\n<p><sup>(1)</sup> I submitted a change to cppreference to hopefully clarify this.</p>\n</hr>", "LastEditorUserId": "1782465", "LastActivityDate": "2016-06-02T08:26:32.017", "Score": "8", "CreationDate": "2016-06-02T08:18:13.660", "ParentId": "37585945", "CommentCount": "0", "OwnerUserId": "1782465", "LastEditDate": "2016-06-02T08:26:32.017"}});