post_cb({"bq_ids": {"n4140": {"so_17790278_17790901_0": {"section_id": 5913, "quality": 0.7777777777777778, "length": 7}, "so_17790278_17790901_1": {"section_id": 435, "quality": 0.6538461538461539, "length": 17}}, "n3337": {"so_17790278_17790901_0": {"section_id": 5686, "quality": 1.0, "length": 9}, "so_17790278_17790901_1": {"section_id": 427, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_17790278_17790901_0": {"section_id": 454, "quality": 0.6666666666666666, "length": 6}, "so_17790278_17790901_1": {"section_id": 454, "quality": 0.6538461538461539, "length": 17}}}, "17790278": {"CommentCount": "3", "AcceptedAnswerId": "17790901", "PostTypeId": "1", "LastEditorUserId": "514235", "CreationDate": "2013-07-22T14:33:24.667", "LastActivityDate": "2013-07-22T15:09:39.223", "LastEditDate": "2013-07-22T14:52:36.183", "ViewCount": "251", "FavoriteCount": "1", "Title": "C++11 \"In class initialization\" feature is not working for unions", "Id": "17790278", "Score": "9", "Body": "<p>Minimal code example:</p>\n<pre><code>struct B { \n  union U {\n    struct S {} s;\n    int i = 100;\n  }\n  u;  \n};\n</code></pre>\n<p>Now if we declare a <code>B obj;</code> then the <code>obj.u.i</code> is assigned a garbage value instead of <code>100</code>.   See the <a href=\"http://ideone.com/0213tb\" rel=\"nofollow\">demo here</a>. (The garbage value differs based on optimization flags etc.).</p>\n<p>Is the \"In class initialization\" feature supposed to work with unions.</p>\n<ul>\n<li>If yes, then what is the correct syntax? Or is this a g++ bug?</li>\n<li>If not then what <code>int i = 100;</code> does?</li>\n</ul>\n", "Tags": "<c++><c++11><unions><in-class-initialization>", "OwnerUserId": "514235", "AnswerCount": "2"}, "17790901": {"ParentId": "17790278", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>This looks like a GCC bug. The standard says (9.5p2):</p>\n<blockquote>\n<p id=\"so_17790278_17790901_0\">At most one non-static data member of a union may have a <em>brace-or-equal-initializer</em>.</p>\n</blockquote>\n<p>Otherwise, the rules are the same as for a regular class.</p>\n<p>EDIT: In addition, 12.6.2p8:</p>\n<blockquote>\n<p id=\"so_17790278_17790901_1\">In a non-delegating constructor, if a given non-static data member or\n  base class is not designated by a <em>mem-initializer-id</em> (including the\n  case where there is no\n  <em>mem-initializer-list</em> because the constructor has no <em>ctor-initializer</em>) and the entity is not a virtual base class of an abstract class (10.4), then</p>\n<ul>\n<li>if the entity is a non-static data member that has a <em>brace-or-equal-initializer</em>, the entity is initialized as specified in 8.5;</li>\n<li>otherwise, if the entity is a variant member (9.5), no initialization is performed;</li>\n<li>otherwise, the entity is default-initialized (8.5).</li>\n</ul>\n</blockquote>\n<p>Presumably the implicitly defined default constructor counts here. The <code>i</code> member meets the criteria in the first bullet point, so it's initialized like it were a regular class member. The <code>s</code> member matches the second bullet point, so it's left uninitialized.</p>\n", "OwnerUserId": "279597", "LastEditorUserId": "279597", "LastEditDate": "2013-07-22T15:09:39.223", "Id": "17790901", "Score": "3", "CreationDate": "2013-07-22T15:00:56.920", "LastActivityDate": "2013-07-22T15:09:39.223"}, "17790409": {"ParentId": "17790278", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>I think it is like that because a union reunites more than one element. Below is the work around syntax:</p>\n<pre><code>struct B { \n  union U {\n    int i;\n  }\n  u {100};  \n};\n\nint main () {\n  B obj;\n  std::cout &lt;&lt; \"obj.u.i = \" &lt;&lt; obj.u.i &lt;&lt; \"\\n\";\n}\n</code></pre>\n", "OwnerUserId": "1037662", "LastEditorUserId": "514235", "LastEditDate": "2013-07-22T14:55:36.730", "Id": "17790409", "Score": "2", "CreationDate": "2013-07-22T14:39:54.793", "LastActivityDate": "2013-07-22T14:55:36.730"}});