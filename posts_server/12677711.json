post_cb({"12677711": {"ViewCount": "368", "Body": "<p>Is this program legal?</p>\n<pre><code>struct X { X(const X &amp;); };\nstruct Y { operator X() const; };\n\nint main() {\n  X{Y{}};   // ?? error\n}\n</code></pre>\n<p>After <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.htm\" rel=\"nofollow\">n2672</a>, and as amended by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3006.html#978\" rel=\"nofollow\">defect 978</a>, <strong>13.3.3.1 [over.best.ics]</strong> has:</p>\n<blockquote>\n<p id=\"so_12677711_12677711_0\">4 - However, when considering the argument of a constructor or user-defined conversion function that is a candidate [...] by 13.3.1.7 [...] when the initializer list has exactly one element and a conversion to some class X or reference to (possibly cv-qualified) X is considered for the first parameter of a constructor of X [...], only standard conversion sequences and ellipsis conversion sequences are considered.</p>\n</blockquote>\n<p>This seems rather perverse; it has the result that specifying a conversion using a list-initialization cast is illegal:</p>\n<pre><code>void f(X);\nf(Y{});     // OK\nf(X{Y{}});  // ?? error\n</code></pre>\n<p>As I understand <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2640.pdf\" rel=\"nofollow\">n2640</a>, list-initialization is supposed to be able to replace all uses of direct-initialization and copy-initialization, but there seems no way to construct an object of type <code>X</code> from an object of type <code>Y</code> using only list-initialization:</p>\n<pre><code>X x1(Y{});  // OK\nX x2 = Y{}; // OK\nX x3{Y{}};  // ?? error\n</code></pre>\n<p>Is this the actual intent of the standard; if not, how should it read or be read?</p>\n", "Title": "Is it possible to invoke a user-defined conversion function via list-initialization?", "CreationDate": "2012-10-01T16:59:36.363", "LastActivityDate": "2012-10-04T17:40:37.733", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-10-03T19:07:20.140", "LastEditorUserId": "636019", "Id": "12677711", "Score": "5", "OwnerUserId": "567292", "Tags": "<c++><c++11><implicit-conversion><list-initialization>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_12677711_12677711_0": {"length": 17, "quality": 0.5666666666666667, "section_id": 609}, "so_12677711_12732730_3": {"length": 12, "quality": 0.5217391304347826, "section_id": 609}, "so_12677711_12732730_6": {"length": 6, "quality": 0.6666666666666666, "section_id": 609}, "so_12677711_12732730_4": {"length": 6, "quality": 0.75, "section_id": 609}, "so_12677711_12732730_0": {"length": 11, "quality": 1.0, "section_id": 386}}, "n3337": {"so_12677711_12732730_2": {"length": 22, "quality": 0.6875, "section_id": 599}, "so_12677711_12732730_6": {"length": 9, "quality": 1.0, "section_id": 599}, "so_12677711_12732730_4": {"length": 8, "quality": 1.0, "section_id": 599}, "so_12677711_12732730_3": {"length": 21, "quality": 0.9130434782608695, "section_id": 599}, "so_12677711_12677711_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 599}, "so_12677711_12732730_1": {"length": 11, "quality": 0.5238095238095238, "section_id": 599}, "so_12677711_12732730_0": {"length": 11, "quality": 1.0, "section_id": 377}}, "n4659": {"so_12677711_12677711_0": {"length": 17, "quality": 0.5666666666666667, "section_id": 635}, "so_12677711_12732730_6": {"length": 6, "quality": 0.6666666666666666, "section_id": 635}, "so_12677711_12732730_4": {"length": 6, "quality": 0.75, "section_id": 635}, "so_12677711_12732730_0": {"length": 11, "quality": 1.0, "section_id": 403}}}, "12732730": {"Id": "12732730", "PostTypeId": "2", "Body": "<p>The original intent of 13.3.3.1p4 is to describe how to apply the requirement in 12.3p4 that:</p>\n<blockquote>\n<p id=\"so_12677711_12732730_0\">4 - At most one user-defined conversion (constructor or conversion function) is implicitly applied to a single value.</p>\n</blockquote>\n<p>Before <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#84\" rel=\"nofollow noreferrer\">defect 84</a>, 13.3.3.1p4 was <em>almost</em> purely informative:</p>\n<blockquote>\n<p id=\"so_12677711_12732730_1\">4 - In the context of an initialization by user-defined conversion (i.e., when considering the argument of a user-defined conversion function; see 13.3.1.4 [over.match.copy], 13.3.1.5 [over.match.conv]), only standard conversion sequences and ellipsis conversion sequences are allowed.</p>\n</blockquote>\n<p>This is because 13.3.1.4 paragraph 1 bullet 2 and 13.3.1.5p1b1 restrict the candidate functions to those on class <code>S</code> yielding type <code>T</code>, where <code>S</code> is the class type of the initializer expression and <code>T</code> is the type of the object being initialized, so there is no latitude for another user-defined conversion conversion sequence to be inserted.  (13.3.1.4p1b1 is another matter; see below).</p>\n<p>Defect 84 repaired the <code>auto_ptr</code> loophole (i.e. <code>auto_ptr&lt;Derived&gt; -&gt; auto_ptr&lt;Base&gt; -&gt; auto_ptr_ref&lt;Base&gt; -&gt; auto_ptr&lt;Base&gt;</code>, via two conversion functions and a converting constructor) by restricting the conversion sequences allowable for the single parameter of the constructor in the second step of class copy-initialization (here the constructor of <code>auto_ptr&lt;Base&gt;</code> taking <code>auto_ptr_ref&lt;Base&gt;</code>, disallowing the use of a conversion function to convert its argument from <code>auto_ptr&lt;Base&gt;</code>):</p>\n<blockquote>\n<p id=\"so_12677711_12732730_2\">4 - However, when considering the argument of a user-defined conversion function that is a candidate by 13.3.1.3 [over.match.ctor] when invoked for the copying of the temporary in the second step of a class copy-initialization, or by 13.3.1.4 [over.match.copy], 13.3.1.5 [over.match.conv], or 13.3.1.6 [over.match.ref] in all cases, only standard conversion sequences and ellipsis conversion sequences are allowed.</p>\n</blockquote>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.htm\" rel=\"nofollow noreferrer\">n2672</a> then adds:</p>\n<blockquote>\n<p id=\"so_12677711_12732730_3\">[...] by 13.3.1.7 [over.match.list] when passing the initializer list as a single argument or when the initializer list has exactly one element and a conversion to some class X or reference to (possibly cv-qualified) X is considered for the first parameter of a constructor of X, [...]</p>\n</blockquote>\n<p>This is clearly confused, as the only conversions that are a candidate by 13.3.1.3 and 13.3.1.7 are constructors, not conversion functions.  <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3006.html#978\" rel=\"nofollow noreferrer\">Defect 978</a> corrects this:</p>\n<blockquote>\n<p id=\"so_12677711_12732730_4\">4 - However, when considering the argument of a constructor or user-defined conversion function [...]</p>\n</blockquote>\n<p>This also makes 13.3.1.4p1b1 consistent with 12.3p4, as it otherwise would allow unlimited application of converting constructors in copy-initialization:</p>\n<pre><code>struct S { S(int); };\nstruct T { T(S); };\nvoid f(T);\nf(0);   // copy-construct T by (convert int to S); error by 12.3p4\n</code></pre>\n<p>The issue is then what the language referring to 13.3.1.7 means.  <code>X</code> is being copy or move constructed so the language is excluding applying a user-defined conversion to arrive at its <code>X</code> argument.  <code>std::initializer_list</code> has no conversion functions so the language must be intended to apply to something else; if it isn't intended to exclude conversion functions, it must exclude converting constructors:</p>\n<pre><code>struct R {};\nstruct S { S(R); };\nstruct T { T(const T &amp;); T(S); };\nvoid f(T);\nvoid g(R r) {\n    f({r});\n}\n</code></pre>\n<p>There are two available constructors for the list-initialization; <code>T::T(const T &amp;)</code> and <code>T::T(S)</code>.  By excluding the copy constructor from consideration (as its argument would need to be converted via a user-defined conversion sequence) we ensure that only the correct <code>T::T(S)</code> constructor is considered.  In the absence of this language the list-initialization would be ambiguous.  Passing the initializer list as a single argument works similarly:</p>\n<pre><code>struct U { U(std::initializer_list&lt;int&gt;); };\nstruct V { V(const V &amp;); V(U); };\nvoid h(V);\nh({{1, 2, 3}});\n</code></pre>\n<p>Edit: and having gone through all that, I've found <a href=\"https://groups.google.com/d/msg/comp.lang.c++/C-DccEq1Axs/gXht8SCv3ckJ\" rel=\"nofollow noreferrer\">a discussion</a> by <a href=\"https://stackoverflow.com/users/34509/johannes-schaub-litb\">Johannes Schaub</a> that confirms this analysis:</p>\n<blockquote>\n<p id=\"so_12677711_12732730_5\">This is intended to factor out the copy constructor for list initialization \n  because since we are allowed to use nested user defined conversions, we \n  could always produce an ambiguous second conversion path by first invoking \n  the copy constructor and then doing the same as we did for the other \n  conversions.</p>\n</blockquote>\n<hr>\n<p>OK, off to submit a defect report.  I'm going to propose splitting up 13.3.3.1p4:</p>\n<blockquote>\n<p id=\"so_12677711_12732730_6\">4 - However, when considering the argument of a constructor or user-defined conversion function that is a candidate:</p>\n<ul>\n<li>by 13.3.1.3 [over.match.ctor] when invoked for the copying of the temporary in the second step of a class copy-initialization, or</li>\n<li>by 13.3.1.4 [over.match.copy], 13.3.1.5 [over.match.conv], or 13.3.1.6 [over.match.ref] in all cases,</li>\n</ul>\n<p id=\"so_12677711_12732730_7\">only standard conversion sequences and ellipsis conversion sequences are considered; when considering the first argument of a constructor of a class <code>X</code> that is a candidate by 13.3.1.7 [over.match.list] when passing the initializer list as a single argument or when the initializer list has exactly one element, a user-defined conversion to <code>X</code> or reference to (possibly <em>cv</em>-qualified) <code>X</code> is only considered if its user-defined conversion is specified by a conversion function. [<em>Note:</em> because more than one user-defined conversion is allowed in an implicit conversion sequence in the context of list-initialization, this restriction is necessary to ensure that a converting constructor of <code>X</code>, called with a single argument <code>a</code> that is not of type <code>X</code> or a type derived from <code>X</code>, is not ambiguous against a constructor of <code>X</code> called with a temporary <code>X</code> object itself constructed from <code>a</code>. <em>-- end note</em>]</p>\n</blockquote>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2012-10-04T17:40:37.733", "Score": "4", "CreationDate": "2012-10-04T17:40:37.733", "ParentId": "12677711", "CommentCount": "1", "OwnerUserId": "567292", "LastEditDate": "2017-05-23T12:18:49.447"}, "12679445": {"Id": "12679445", "PostTypeId": "2", "Body": "<p>The version of clang 3.1 shipped with XCode 4.4 agrees with your interpretation and rejects <code>X{Y{}};</code>. As do I, after re-reading the relevant parts of the standard a few times, FWIW.</p>\n<p>If I modify <code>X</code>'s constructor to take two arguments, both of type <code>const X&amp;</code>, clang accepts the statement <code>Y y; X{y,y}</code>. (It crashes if I try <code>X{Y{},Y{}}</code>...). This seems to be consistent with 13.3.3.1p4 which demands user-defined conversions to be skipped only for the single-element case.</p>\n<p>It seems that the restriction to standard and ellipsis conversion sequences was added initially only in cases where <em>another</em> user-defined conversion has already taken place. Or at least that is how I read <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#84\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#84</a>.</p>\n<p>It's interesting how the standard is careful to apply the restriction <em>only</em> to the second step of copy initialization, which copies from a temporary which already has the correct type (and was obtain potentially through a user-defined conversion!). Yet for list-initialization, no similar mechanism seems to exists...</p>\n", "LastActivityDate": "2012-10-01T19:08:19.893", "CommentCount": "2", "CreationDate": "2012-10-01T19:08:19.893", "ParentId": "12677711", "Score": "2", "OwnerUserId": "1582403"}});