post_cb({"42192607": {"ParentId": "8888748", "CommentCount": "0", "Body": "<p><code>#include &lt;regex&gt;</code></p>\n<pre><code>std::string string( \"I only have 3 dollars!\" );\nstd::cout &lt;&lt; std::regex_search( string, std::regex( \"\\\\d+\" ) ); // true\n</code></pre>\n<p>and </p>\n<pre><code>std::string string( \"I only have three dollars!\" );\nstd::cout &lt;&lt; std::regex_search( string, std::regex( \"\\\\d+\" ) ); // false\n</code></pre>\n", "OwnerUserId": "4643584", "PostTypeId": "2", "Id": "42192607", "Score": "0", "CreationDate": "2017-02-12T20:04:36.897", "LastActivityDate": "2017-02-12T20:04:36.897"}, "8888762": {"ParentId": "8888748", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The <code>cctype</code> header file has a good number of character classifications functions which you can use on each character in the string. For numeric checks, that would be <code>isdigit</code>.</p>\n<p>The following program shows how to check each character of a C or C++ string ( the process is pretty much identical in terms of checking the actual characters, the only real difference being how to get the length):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;cctype&gt;\nint main (void) {\n    const char *xyzzy = \"42x\";\n    std::cout &lt;&lt; xyzzy &lt;&lt; '\\n';\n    for (int i = 0; i &lt; std::strlen (xyzzy); i++) {\n        if (! std::isdigit (xyzzy[i])) {\n            std::cout &lt;&lt; xyzzy[i] &lt;&lt; \" is not numeric.\\n\";\n        }\n    }\n\n    std::string plugh (\"3141y59\");\n    std::cout &lt;&lt; plugh &lt;&lt; '\\n';\n    for (int i = 0; i &lt; plugh.length(); i++) {\n        if (! std::isdigit (plugh[i])) {\n            std::cout &lt;&lt; plugh[i] &lt;&lt; \" is not numeric.\\n\";\n        }\n    }\n\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2012-01-17T01:57:30.010", "Id": "8888762", "Score": "3", "CreationDate": "2012-01-17T01:50:12.977", "LastActivityDate": "2012-01-17T01:57:30.010"}, "8888748": {"CommentCount": "0", "AcceptedAnswerId": "8889045", "CreationDate": "2012-01-17T01:47:32.380", "LastActivityDate": "2017-03-21T00:36:36.607", "PostTypeId": "1", "ViewCount": "56374", "FavoriteCount": "5", "Title": "how to check if given c++ string or char* contains only digits?", "Id": "8888748", "Score": "36", "Body": "<p>Or from the other way around find first non digit character.</p>\n<p>Do the same functions apply for string and for char* ?</p>\n", "Tags": "<c++><string><pattern-matching>", "OwnerUserId": "393087", "AnswerCount": "8"}, "8888811": {"ParentId": "8888748", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Several people already mentioned to use <code>isdigit()</code>. However, note that this isn't entirely trivial because <code>char</code> can be signed which would cause a negative value to be passed to <code>isdigit()</code>. However, this function can only take positive values. That is, you want something akin to this:</p>\n<pre><code>if (s.end() == std::find_if(s.begin(), s.end(),\n    [](unsigned char c)-&gt;bool { return !isdigit(c); })) {\n    std::cout &lt;&lt; \"string '\" &lt;&lt; s &lt;&lt; \"' contains only digits\\n\";\n}\n</code></pre>\n<p>It seems the reasoning for the conversion to <code>unsigned char</code> isn't obvious. So, here are the relevant quotes from their respective standards:</p>\n<p>According to ISO/IEC 9899:2011 (or ISO/IEC 9899:1999) 7.4 paragraph 1 the following applies to the arguments of the functions from <code>&lt;ctype.h&gt;</code>:</p>\n<blockquote>\n<p id=\"so_8888748_8888811_0\">... In all cases the argument is an <code>int</code>, the value of which shall be\n  representable as an <code>unsigned char</code> or shall equal the value of the macro <code>EOF</code>. If the\n  argument has any other value, the behavior is undefined.</p>\n</blockquote>\n<p>Unfortunately, the C++ standard doesn't specify that <code>char</code> is an unsigned type. Instead it specifies in ISO/IEC 14882:2011 3.9.1 [basic.fundamental] paragraph 1:</p>\n<blockquote>\n<p id=\"so_8888748_8888811_1\">... It is implementation-defined whether a <code>char</code> object can hold negative values. ...</p>\n</blockquote>\n<p>Clearly, a negative value cannot be represented as an <code>unsigned char</code>. That is, if <code>char</code> is using a signed type on an implementation (there are actually several which do, e.g., it is signed on MacOS using gcc or clang) there is the danger that calling any of the <code>&lt;ctype.h&gt;</code> function would cause undefined behavior.</p>\n<p>Now, why does the conversion to <code>unsigned char</code> does the right things?</p>\n<p>According to 4.7 [conv.integral] paragraph 2:</p>\n<blockquote>\n<p id=\"so_8888748_8888811_2\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2<sup>n</sup> where n is the number of bits used to represent the unsigned type). [ Note: In a two\u2019s complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation). \u2014end note ]</p>\n</blockquote>\n<p>That is, the conversion from a [potentially] signed <code>char</code> to <code>unsigned char</code> is well-defined and causes the result to be in the permitted range for the <code>&lt;ctype.h&gt;</code> functions.</p>\n", "OwnerUserId": "1120273", "LastEditorUserId": "1120273", "LastEditDate": "2013-02-13T22:56:44.210", "Id": "8888811", "Score": "10", "CreationDate": "2012-01-17T02:00:36.730", "LastActivityDate": "2013-02-13T22:56:44.210"}, "8888829": {"ParentId": "8888748", "CommentCount": "0", "Body": "<p>If it's a strict requirement that you can find exactly where the first non-character digit is, then you'll have to check each character. If not, I'd use either something like this:</p>\n<pre><code>unsigned safe_atoi(const std::string&amp; a)\n{\n    std::stringstream s(a);\n    unsigned b;\n    s &gt;&gt; b;\n    return b;\n}\n</code></pre>\n", "OwnerUserId": "1085573", "PostTypeId": "2", "Id": "8888829", "Score": "0", "CreationDate": "2012-01-17T02:04:11.300", "LastActivityDate": "2012-01-17T02:04:11.300"}, "8892640": {"ParentId": "8888748", "CommentCount": "1", "Body": "<p>In the same spirit as Misha's answer, but more correct: <code>sscanf(buf, \"%*u%*c\")==1</code>.</p>\n<p><code>scanf</code> returns 0 if the <code>%d</code> digit extraction fails, and 2 if there is anything after the digits captured by <code>%c</code>. And since <code>*</code> prevents the value from being stored, you can't even get an overflow.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "8892640", "Score": "4", "CreationDate": "2012-01-17T09:59:16.410", "LastActivityDate": "2012-01-17T09:59:16.410"}, "8889045": {"ParentId": "8888748", "CommentCount": "8", "Body": "<p>Of course, there are many ways to test a string for only numeric characters. Two possible methods are:</p>\n<pre><code>bool is_digits(const std::string &amp;str)\n{\n    return str.find_first_not_of(\"0123456789\") == std::string::npos;\n}\n</code></pre>\n<p>or</p>\n<pre><code>bool is_digits(const std::string &amp;str)\n{\n    return std::all_of(str.begin(), str.end(), ::isdigit); // C++11\n}\n</code></pre>\n", "OwnerUserId": "445976", "PostTypeId": "2", "Id": "8889045", "Score": "74", "CreationDate": "2012-01-17T02:42:19.243", "LastActivityDate": "2012-01-17T02:42:19.243"}, "42916452": {"ParentId": "8888748", "CommentCount": "0", "Body": "<p>From the <a href=\"http://www.cplusplus.com/reference/locale/isdigit/\" rel=\"nofollow noreferrer\">cplusplus.com</a> you can use isdigit function as follow: </p>\n<pre><code>// isdigit example (C++)\n#include &lt;iostream&gt;       // std::cout\n#include &lt;string&gt;         // std::string\n#include &lt;locale&gt;         // std::locale, std::isdigit\n#include &lt;sstream&gt;        // std::stringstream\n\nint main ()\n{\n  std::locale loc;\n  std::string str=\"1776ad\";\n  if (isdigit(str[0],loc))\n  {\n    int year;\n    std::stringstream(str) &gt;&gt; year;\n    std::cout &lt;&lt; \"The year that followed \" &lt;&lt; year &lt;&lt; \" was \" &lt;&lt; (year+1) &lt;&lt; \".\\n\";\n  }\n  return 0;\n}\n</code></pre>\n<p>Note: there is 2 types of isdigit the other version is local independent and ASCII based.</p>\n", "OwnerUserId": "874880", "PostTypeId": "2", "Id": "42916452", "Score": "0", "CreationDate": "2017-03-21T00:36:36.607", "LastActivityDate": "2017-03-21T00:36:36.607"}, "bq_ids": {"n4140": {"so_8888748_8888811_2": {"section_id": 31, "quality": 0.90625, "length": 29}, "so_8888748_8888811_1": {"section_id": 7210, "quality": 0.875, "length": 7}}, "n3337": {"so_8888748_8888811_2": {"section_id": 28, "quality": 0.90625, "length": 29}, "so_8888748_8888811_1": {"section_id": 6954, "quality": 0.875, "length": 7}}, "n4659": {"so_8888748_8888811_2": {"section_id": 31, "quality": 0.90625, "length": 29}, "so_8888748_8888811_1": {"section_id": 8719, "quality": 0.875, "length": 7}}}, "8888770": {"ParentId": "8888748", "CommentCount": "0", "Body": "<p><code>isdigit(int)</code> tells you if a character is a digit. If you are going to assume ASCII and base 10, you can also use: </p>\n<pre><code>int first_non_digit_offset= strspn(string, \"0123456789\")\n</code></pre>\n", "OwnerUserId": "6210", "PostTypeId": "2", "Id": "8888770", "Score": "5", "CreationDate": "2012-01-17T01:51:50.740", "LastActivityDate": "2012-01-17T01:51:50.740"}});