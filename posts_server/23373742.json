post_cb({"bq_ids": {"n4140": {"so_23373742_23373833_0": {"length": 22, "quality": 0.88, "section_id": 7224}, "so_23373742_23375539_7": {"length": 11, "quality": 0.7333333333333333, "section_id": 7212}, "so_23373742_23375539_8": {"length": 7, "quality": 0.875, "section_id": 5946}, "so_23373742_23375539_3": {"length": 15, "quality": 0.8823529411764706, "section_id": 6965}, "so_23373742_23375539_2": {"length": 26, "quality": 0.9629629629629629, "section_id": 6964}}, "n3337": {"so_23373742_23373833_0": {"length": 22, "quality": 0.88, "section_id": 6968}, "so_23373742_23375539_7": {"length": 11, "quality": 0.7333333333333333, "section_id": 6956}, "so_23373742_23375539_8": {"length": 7, "quality": 0.875, "section_id": 5913}, "so_23373742_23375539_3": {"length": 15, "quality": 0.8823529411764706, "section_id": 6712}, "so_23373742_23375539_2": {"length": 26, "quality": 0.9629629629629629, "section_id": 6711}}, "n4659": {"so_23373742_23373833_0": {"length": 20, "quality": 0.8, "section_id": 8734}, "so_23373742_23375539_7": {"length": 11, "quality": 0.7333333333333333, "section_id": 8721}, "so_23373742_23375539_8": {"length": 7, "quality": 0.875, "section_id": 7432}, "so_23373742_23375539_2": {"length": 18, "quality": 0.6666666666666666, "section_id": 8462}}}, "23373742": {"ViewCount": "285", "Body": "<p>So apparently a <code>std::nullptr_t</code> argument is converted to a null pointer of type <code>void *</code> (Section 5.2.2/7 of N3337) when passed without a parameter (via <code>...</code>). This means that to properly pass a null <code>char *</code> pointer, for example, a cast is still needed:</p>\n<blockquote>\n<p id=\"so_23373742_23373742_0\">some_variadic_function(\"a\", \"b\", \"c\", (const char *) std::nullptr);</p>\n</blockquote>\n<p>since there is no guarantee that a null <code>void *</code> has the same bit pattern as a null <code>char *</code>. Correct?</p>\n<p>This also means that there is no advantage to <code>std::nullptr</code> over <code>0</code> in such cases, except perhaps for clarity.</p>\n", "AcceptedAnswerId": "23375539", "Title": "std::nullptr_t arguments in variadic functions", "CreationDate": "2014-04-29T19:36:37.270", "Id": "23373742", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-04-29T21:51:58.717", "Score": "5", "OwnerUserId": "3521733", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "23373833": {"Id": "23373833", "PostTypeId": "2", "Body": "<p>You are wrong. One of the few guarantees are that a <code>char*</code> has the same size and representation as the corresponding <code>void*</code>.</p>\n<blockquote>\n<h3>3.9.2 Compound Types \u00a74</h3>\n<p id=\"so_23373742_23373833_0\">A pointer to cv-qualified (3.9.3) or cv-unqualified void can be used to point to objects of unknown type.\n  Such a pointer shall be able to hold any object pointer. <strong>An object of type cv <code>void*</code> shall have the same\n  representation and alignment requirements as cv <code>char*</code>.</strong></p>\n</blockquote>\n<p>Edit: Looks like <a href=\"https://stackoverflow.com/a/23375539/3204551\">this answer by hvd</a> is better, showing a few more traps specific to the variadic function part of the question.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-04-29T21:51:58.717", "Score": "2", "CreationDate": "2014-04-29T19:41:56.180", "ParentId": "23373742", "CommentCount": "8", "OwnerUserId": "3204551", "LastEditDate": "2017-05-23T12:17:10.753"}, "23375539": {"Id": "23375539", "PostTypeId": "2", "Body": "<p>You ask:</p>\n<blockquote>\n<p id=\"so_23373742_23375539_0\">since there is no guarantee that a null <code>void *</code> has the same bit pattern as a null <code>char *</code>. Correct?</p>\n</blockquote>\n<p>Well, actually, that guarantee does exist, Deduplicator's answer already shows where the standard requires this. But that is not relevant to your question.</p>\n<p>Passing <code>void *</code> to a variadic function, and accessing it using <code>va_arg</code> as <code>char *</code>, is specifically allowed as a special exception.</p>\n<p>C++11:</p>\n<blockquote>\n<p id=\"so_23373742_23375539_1\"><strong>18.10 Other runtime support [support.runtime]</strong></p>\n<p id=\"so_23373742_23375539_2\">1 Headers <code>&lt;csetjmp&gt;</code> (nonlocal jumps), <code>&lt;csignal&gt;</code> (signal handling), <code>&lt;cstdalign&gt;</code> (alignment), <code>&lt;cstdarg&gt;</code> (variable arguments), <code>&lt;cstdbool&gt;</code> (<code>__bool_true_false_are_defined</code>).  (runtime environment\n  <code>getenv()</code>, <code>system()</code>), and <code>&lt;ctime&gt;</code> (system clock <code>clock()</code>, <code>time()</code>) provide further compatibility with C code.</p>\n<p id=\"so_23373742_23375539_3\">2 The contents of these headers are the same as the Standard C library headers <code>&lt;setjmp.h&gt;</code>, <code>&lt;signal.h&gt;</code>, <code>&lt;stdalign.h&gt;</code>, <code>&lt;stdarg.h&gt;</code>, <code>&lt;stdbool.h&gt;</code>, <code>&lt;stdlib.h&gt;</code>, and <code>&lt;time.h&gt;</code>, respectively, with the following\n  changes:</p>\n<p id=\"so_23373742_23375539_4\">[... nothing about <code>va_arg</code>]</p>\n</blockquote>\n<p>C99:</p>\n<blockquote>\n<p id=\"so_23373742_23375539_5\"><strong>7.15.1.1 The <code>va_arg</code> macro</strong></p>\n<p id=\"so_23373742_23375539_6\">[...] If there is no actual next argument, or if <em>type</em> is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined, except for the following cases:</p>\n<p id=\"so_23373742_23375539_7\">-- one type is a signed integer type, the other type is the corresponding unsigned integer type, and the value is representable in both types;</p>\n<p id=\"so_23373742_23375539_8\">-- one type is pointer to void and the other is a pointer to a character type.</p>\n</blockquote>\n<p>However, this does mean that in other cases where two types <code>T1</code> and <code>T2</code> have the same representation and alignment requirements, the behaviour is undefined if <code>T1</code> is passed to a variadic function, and it is retrieved as <code>T2</code>.</p>\n<p>An example of this: passing <code>(void *) 0</code> and accessing it as <code>char *</code>, is allowed, passing <code>(void *) 0</code> and accessing it as <code>unsigned char *</code> is also allowed, but passing <code>(char *) 0</code> and accessing it as <code>unsigned char *</code> is <em>not</em> allowed. If a compiler is capable of inlining calls to variadic functions, and optimises based on the strict requirements of the standard, such mismatches could break badly.</p>\n<blockquote>\n<p id=\"so_23373742_23375539_9\">This also means that there is no advantage to <code>std::nullptr</code> over <code>0</code> in such cases, except perhaps for clarity.</p>\n</blockquote>\n<p>I would definitely <em>not</em> use <code>nullptr</code> without casting it, even though in this one special case it is valid. It is far too hard to see that it is valid. And if a cast is included anyway, <code>(char *) 0</code> is just as clear as a null pointer value.</p>\n", "LastActivityDate": "2014-04-29T21:22:49.233", "CommentCount": "0", "CreationDate": "2014-04-29T21:22:49.233", "ParentId": "23373742", "Score": "6", "OwnerUserId": "743382"}});