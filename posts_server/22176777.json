post_cb({"22176777": {"ViewCount": "3783", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nconstexpr int f()\n{\n    return printf(\"a side effect!\\n\");\n}\n\nint main()\n{\n    char a[f()];\n    printf(\"%zd\\n\", sizeof a);\n}\n</code></pre>\n<p>I would have expected the compiler to complain about the call to <code>printf</code> inside <code>f</code>, because <code>f</code> is supposed to be <code>constexpr</code>, but <code>printf</code> is not. Why does the program <a href=\"https://ideone.com/QNL5u8\" rel=\"noreferrer\">compile and print 15</a>?</p>\n", "AcceptedAnswerId": "22177425", "Title": "Why can I call a non-constexpr function inside a constexpr function?", "CreationDate": "2014-03-04T15:57:36.923", "Id": "22176777", "CommentCount": "18", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2014-03-04T21:01:24.063", "LastEditorUserId": "1708801", "LastActivityDate": "2015-01-08T16:46:12.883", "Score": "14", "OwnerUserId": "252000", "Tags": "<c++><gcc><c++11><constexpr><side-effects>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_22176777_22177425_1": {"length": 7, "quality": 0.7, "section_id": 6185}, "so_22176777_22177425_0": {"length": 12, "quality": 0.631578947368421, "section_id": 5421}, "so_22176777_22177425_2": {"length": 14, "quality": 0.7777777777777778, "section_id": 6185}}, "n3337": {"so_22176777_22177425_1": {"length": 10, "quality": 1.0, "section_id": 5946}, "so_22176777_22177425_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 5216}, "so_22176777_22177425_2": {"length": 14, "quality": 0.7777777777777778, "section_id": 5946}}, "n4659": {"so_22176777_22177425_0": {"length": 12, "quality": 0.631578947368421, "section_id": 6843}, "so_22176777_22177425_2": {"length": 14, "quality": 0.7777777777777778, "section_id": 7687}}}, "22177425": {"Id": "22177425", "PostTypeId": "2", "Body": "<p>The program is <em>ill-formed</em> and requires no diagnostic according to the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow noreferrer\">C++11 draft standard</a> section <code>7.1.5</code> <em>The constexpr specifier</em> paragraph <em>5</em> which says:</p>\n<blockquote>\n<p id=\"so_22176777_22177425_0\">For a constexpr function, if no function argument values exist such\n  that the function invocation substitution would produce a constant\n  expression (5.19), the program is ill-formed; no diagnostic required.</p>\n</blockquote>\n<p>and provides the following example:</p>\n<pre><code>constexpr int f(bool b)\n  { return b ? throw 0 : 0; } // OK\nconstexpr int f() { return f(true); } // ill-formed, no diagnostic required\n</code></pre>\n<p>and section <code>5.19</code> paragraph <em>2</em> says:</p>\n<blockquote>\n<p id=\"so_22176777_22177425_1\">A conditional-expression is a core constant expression unless it\n  involves one of the following as a potentially evaluated subexpression\n  [...]</p>\n</blockquote>\n<p>and includes:</p>\n<blockquote>\n<p id=\"so_22176777_22177425_2\">\u2014 an invocation of a function other than a constexpr constructor for a\n  literal class or a  constexpr function [ Note: Overload resolution\n  (13.3) is applied as usual \u2014end note ];</p>\n</blockquote>\n<p>We would probably prefer a diagnostic in this case, it could just be an oversight, I have a bug report for a similar situation where <code>gcc</code> does not produce an error but we would probably like it to: <a href=\"https://stackoverflow.com/questions/21502017/is-the-compiler-allowed-leeway-in-what-it-considers-undefined-behavior-in-a-cons\">Is the compiler allowed leeway in what it considers undefined behavior in a constant expression?</a>. </p>\n<p><b>Update</b></p>\n<p>Using the <code>-fno-builtin</code> flag will cause <code>gcc</code> to generate the following error:</p>\n<pre><code> error: call to non-constexpr function 'int printf(const char*, ...)'\n return printf(\"a side effect!\\n\");\n                                 ^\n</code></pre>\n<p>So <code>gcc</code> does consider this <em>ill-formed</em> it is just  ignores it when it is using the builtin version of <code>printf</code>. </p>\n<p>Although somewhat inconsistently using the <code>-pedantic</code> produces the following warning:</p>\n<pre><code>warning: ISO C++ forbids variable length array 'a' [-Wvla]\n char a[f()];\n           ^\n</code></pre>\n<p>Note that using <code>f()</code> to initialized a <em>constexpr</em> variable:</p>\n<pre><code>constexpr int x = f() ;\n</code></pre>\n<p>does generate an error:</p>\n<pre><code>error: 'printf(((const char*)\"a side effect!\\012\"))' is not a constant expression\n</code></pre>\n<p>Note that additionally in the more general case a compiler is not allowed mark standard library functions as <em>constexpr</em> <a href=\"https://stackoverflow.com/q/27744079/1708801\">unless explicitly allowed by the standard</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-08T16:46:12.883", "Score": "11", "CreationDate": "2014-03-04T16:25:20.970", "ParentId": "22176777", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T12:00:10.983"}});