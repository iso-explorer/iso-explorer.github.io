post_cb({"9945598": {"Id": "9945598", "PostTypeId": "2", "Body": "<p>I was researching this to answer another question that was closed as a dupe, so in order to not let the work go to waste I 'm answering this one instead.</p>\n<p>A statement of the form <code>A a = A(5)</code> is called <em>copy-initialization</em> of the variable <code>a</code>. The C++11 standard, 8.5/16 states:</p>\n<blockquote>\n<p id=\"so_1758142_9945598_0\">The function selected is called with the initializer expression as\n  its argument; if the function is a constructor, the call initializes a\n  temporary of the cv-unqualified version of the destination type. The\n  temporary is a prvalue. The result of the call (which is the temporary\n  for the constructor case) is then used to direct-initialize, according\n  to the rules above, the object that is the destination of the\n  copy-initialization. <strong>In certain cases, an implementation is permitted\n  to eliminate the copying inherent in this direct-initialization by\n  constructing the intermediate result directly into the object being\n  initialized; see 12.2, 12.8</strong>.</p>\n</blockquote>\n<p>This means that the compiler looks up the appropriate constructor to handle <code>A(5)</code>, creates a temporary and copies that temporary into <code>a</code>. But under what circumstances can the copy be eliminated?</p>\n<p>Let's see what 12.8/31 says:</p>\n<blockquote>\n<p id=\"so_1758142_9945598_1\"><strong>When certain criteria are met, an implementation is allowed to omit\n  the copy/move construction of a class object, even if the copy/move\n  constructor and/or destructor for the object have side effects.</strong> In\n  such cases, the implementation treats the source and target of the\n  omitted copy/move operation as simply two different ways of referring\n  to the same object, and the destruction of that object occurs at the\n  later of the times when the two objects would have been destroyed\n  without the optimization. This elision of copy/move operations,\n  called <em>copy elision</em>, is permitted in the following circumstances\n  (which may be combined to eliminate multiple copies):</p>\n<p id=\"so_1758142_9945598_2\">[...]</p>\n<ul>\n<li><strong>when a temporary class object that has not been bound to a reference (12.2) would be copied/moved\n  to a class object with the same cv-unqualified type</strong>, the copy/move operation can be\n  omitted by constructing the temporary object directly into the target of the omitted copy/move</li>\n</ul>\n</blockquote>\n<p>Having all this in mind, here's what happens with the expression <code>A a = A(5)</code>:</p>\n<ol>\n<li>The compiler sees a declaration with copy-initialization</li>\n<li>The <code>A(int)</code> constructor is selected to initialize a temporary object</li>\n<li>Because the temporary object is <em>not</em> bound to a reference, and it does have the same type <code>A</code> as the destination type in the copy-initialization expression, the compiler is permitted to directly construct an object into <code>a</code>, eliding the temporary</li>\n</ol>\n", "LastActivityDate": "2012-03-30T15:06:03.100", "CommentCount": "0", "CreationDate": "2012-03-30T15:06:03.100", "ParentId": "1758142", "Score": "4", "OwnerUserId": "50079"}, "1758617": {"Id": "1758617", "PostTypeId": "2", "Body": "<p>Here you have <em>copy-initialization</em> of <code>a</code> from temporary <code>A(5)</code>. Implementation allowed to skip calling copy constructor here according to C++ Standard 12.2/2.</p>\n", "LastActivityDate": "2009-11-18T19:54:19.203", "CommentCount": "1", "CreationDate": "2009-11-18T19:54:19.203", "ParentId": "1758142", "Score": "4", "OwnerUserId": "123111"}, "1758142": {"ViewCount": "2002", "Body": "<p>Here is the little code snippet:</p>\n<pre><code>class A\n{\npublic:\n    A(int value) : value_(value)\n    {\n        cout &lt;&lt;\"Regular constructor\" &lt;&lt;endl;\n    }\n\n    A(const A&amp; other)   : value_(other.value_)  \n    {\n        cout &lt;&lt;\"Copy constructor\" &lt;&lt;endl;\n    }\n\nprivate:\n    int value_;\n};\nint main()\n{\n    A a = A(5);\n}\n</code></pre>\n<p>I assumed that output would be \"Regular Constructor\" (for RHS) followed by \"Copy constructor\" for LHS. So I avoided this style and always declared variable of class as <code>A a(5);</code>.  But to my surprise in the code above copy constructor is never called (Visual C++ 2008)</p>\n<p>Does anybody know if this behavior is a result of compiler optimization, or some documented (and portable) feature of C++? Thanks.</p>\n", "Title": "Why copy constructor is not called in this case?", "CreationDate": "2009-11-18T18:40:05.133", "LastActivityDate": "2012-03-30T15:06:03.100", "CommentCount": "3", "FavoriteCount": "3", "PostTypeId": "1", "Id": "1758142", "Score": "10", "OwnerUserId": "207064", "Tags": "<c++><constructor><copy-constructor>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_1758142_9945598_1": {"length": 62, "quality": 0.96875, "section_id": 480}, "so_1758142_1765193_0": {"length": 16, "quality": 0.7619047619047619, "section_id": 374}, "so_1758142_9945598_0": {"length": 48, "quality": 0.9056603773584906, "section_id": 3296}}, "n3337": {"so_1758142_9945598_1": {"length": 63, "quality": 0.984375, "section_id": 471}, "so_1758142_9945598_0": {"length": 48, "quality": 0.9056603773584906, "section_id": 3166}, "so_1758142_1765193_0": {"length": 16, "quality": 0.7619047619047619, "section_id": 365}}, "n4659": {"so_1758142_9945598_1": {"length": 62, "quality": 0.96875, "section_id": 502}, "so_1758142_9945598_0": {"length": 27, "quality": 0.5094339622641509, "section_id": 4058}, "so_1758142_1765193_0": {"length": 16, "quality": 0.7619047619047619, "section_id": 388}}}, "1765193": {"Id": "1765193", "PostTypeId": "2", "Body": "<pre><code>A a = A(5);\n</code></pre>\n<p>This line is equivalent to</p>\n<pre><code>A a(5);\n</code></pre>\n<p>Despite its function-style appearance, the first line simply constructs <code>a</code> with the argument 5.  No copying or temporaries are involved.  From the C++ standard, section 12.1.11:</p>\n<blockquote>\n<p id=\"so_1758142_1765193_0\">A functional notation type conversion (5.2.3) can be used to create new objects of its type. [ Note: The\n  syntax looks like an explicit call of the constructor. \u2014end note ]</p>\n</blockquote>\n", "LastActivityDate": "2009-11-19T17:46:09.027", "CommentCount": "1", "CreationDate": "2009-11-19T17:46:09.027", "ParentId": "1758142", "Score": "-1", "OwnerUserId": "46821"}, "1758221": {"Id": "1758221", "PostTypeId": "2", "Body": "<p>From another comment: \"So by default I should not rely on it (as it may depend on the compiler)\"</p>\n<p>No, it does not depend on the compiler, practically anyway. Any compiler worth a grain of sand won't waste time constructing an A, then copying it over.</p>\n<p>In the standard it explicitly says that it is completely acceptable for <code>T = x;</code> to be equivalent to saying <code>T(x);</code>. (\u00a712.8.15, pg. 211) Doing this with <code>T(T(x))</code> is obviously redundant, so it removes the inner <code>T</code>.</p>\n<p>To get the desired behavior, you'd force the compiler to default construct the first A:</p>\n<pre><code>A a;\n// A is now a fully constructed object,\n// so it can't call constructors again:\na = A(5);\n</code></pre>\n", "LastEditorUserId": "87234", "LastActivityDate": "2009-11-18T19:03:18.760", "Score": "13", "CreationDate": "2009-11-18T18:53:02.790", "ParentId": "1758142", "CommentCount": "3", "OwnerUserId": "87234", "LastEditDate": "2009-11-18T19:03:18.760"}});