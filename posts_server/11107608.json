post_cb({"11107667": {"CommentCount": "20", "CreationDate": "2012-06-19T19:05:30.863", "CommunityOwnedDate": "2013-05-14T17:58:55.253", "LastEditorUserId": "365496", "LastActivityDate": "2014-05-11T06:56:37.883", "ParentId": "11107608", "PostTypeId": "2", "LastEditDate": "2014-05-11T06:56:37.883", "Id": "11107667", "Score": "103", "Body": "<h3>What is wchar_t?</h3>\n<p>wchar_t is defined such that any locale's char encoding can be converted to a wchar_t representation where every wchar_t represents exactly one codepoint:</p>\n<blockquote>\n<p id=\"so_11107608_11107667_0\">Type wchar_t is a distinct type whose values can represent distinct codes for all members of the largest extended character set specified among the supported locales (22.3.1).</p>\n<p id=\"so_11107608_11107667_1\">\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>\u2014 C++ [basic.fundamental] 3.9.1/5</em></p>\n</blockquote>\n<p>This <em>does not</em> require that wchar_t be large enough to represent any character from all locales simultaneously. That is, the encoding used for wchar_t may differ between locales. Which means that you cannot necessarily convert a string to wchar_t using one locale and then convert back to char using another locale.<sup>1</sup></p>\n<p>Since using wchar_t as a common representation between all locales seems to be the primary use for wchar_t in practice you might wonder what it's good for if not that.</p>\n<p>The original intent and purpose of wchar_t was to make text processing simple by defining it such that it requires a one-to-one mapping from a string's code-units to the text's characters, thus allowing the use of the same simple algorithms as are used with ascii strings to work with other languages.</p>\n<p>Unfortunately the wording of wchar_t's specification assume a one-to-one mapping between characters and codepoints to achieve this. Unicode breaks that assumption<sup>2</sup>, so you can't safely use wchar_t for simple text algorithms either.</p>\n<p>This means that portable software cannot use wchar_t either as a common representation for text between locales, or to enable the use of simple text algorithms.</p>\n<h3>What use is wchar_t today?</h3>\n<p>Not much, for portable code anyway. If <code>__STDC_ISO_10646__</code> is defined then values of wchar_t directly represent Unicode codepoints with the same values in all locales. That makes it safe to do the inter-locale conversions mentioned earlier. However you can't rely only on it to decide that you can use wchar_t this way because, while most unix platforms define it, Windows does not even though Windows uses the same wchar_t locale in all locales.</p>\n<p>The reason Windows doesn't define <code>__STDC_ISO_10646__</code> is because Windows use UTF-16 as its wchar_t encoding, and because UTF-16 uses surrogate pairs to represent codepoints greater than U+FFFF, which means that UTF-16 doesn't satisfy the requirements for <code>__STDC_ISO_10646__</code>.</p>\n<p>For platform specific code wchar_t may be more useful. It's essentially required on Windows (e.g., some files simply cannot be opened without using wchar_t filenames), though Windows is the only platform where this is true as far as I know (so maybe we can think of wchar_t as 'Windows_char_t').</p>\n<p>In hindsight wchar_t is clearly not useful for simplifying text handling, or as storage for locale independent text. Portable code should not attempt to use it for these purposes. Non-portable code may find it useful simply because some API requires it.</p>\n<h3>Alternatives</h3>\n<p>The alternative I like is to use UTF-8 encoded C strings, even on platforms not particularly friendly toward UTF-8.</p>\n<p>This way one can write portable code using a common text representation across platforms, use standard datatypes for their intended purpose, get the language's support for those types (e.g. string literals, though some tricks are necessary to make it work for some compilers), some standard library support, debugger support (more tricks may be necessary), etc. With wide characters it's generally harder or impossible to get all of this, and you may get different pieces on different platforms.</p>\n<p>One thing UTF-8 does not provide is the ability to use simple text algorithms such as are possible with ASCII. In this UTF-8 is no worse than any other Unicode encoding. In fact it may be considered to be better because multi-code unit representations in UTF-8 are more common and so bugs in code handling such variable width representations of characters are more likely to be noticed and fixed than if you try to stick to UTF-32 with NFC or NFKC.</p>\n<p>Many platforms use UTF-8 as their native char encoding and many programs do not require any significant text processing, and so writing an internationalized program on those platforms is little different from writing code without considering internationalization. Writing more widely portable code, or writing on other platforms requires inserting conversions at the boundaries of APIs that use other encodings.</p>\n<p>Another alternative used by some software is to choose a cross-platform representation, such as unsigned short arrays holding UTF-16 data, and then to supply all the library support and simply live with the costs in language support, etc.</p>\n<p>C++11 adds new kinds of wide characters as alternatives to wchar_t, char16_t and char32_t with attendant language/library features. These aren't actually guaranteed to be UTF-16 and UTF-32, but I don't imagine any major implementation will use anything else. C++11 also improves UTF-8 support, for example with UTF-8 string literals so it won't be necessary to trick VC++ into producing UTF-8 encoded strings (although I may continue to do so rather than use the <code>u8</code> prefix).</p>\n<h3>Alternatives to avoid</h3>\n<p>TCHAR: TCHAR is for migrating ancient Windows programs that assume legacy encodings from char to wchar_t, and is best forgotten unless your program was written in some previous millennium. It's not portable and is inherently unspecific about its encoding and even its data type, making it unusable with any non-TCHAR based API. Since its purpose is migration to wchar_t, which we've seen above isn't a good idea, there is no value whatsoever in using TCHAR.</p>\n<hr>\n<p><em>\n<sub>1. Characters which are representable in wchar_t strings but which are not supported in any locale are not required to be represented with a single wchar_t value. This means that wchar_t could use a variable width encoding for certain characters, another clear violation of the intent of wchar_t. Although it's arguable that a character being representable by wchar_t is enough to say that the locale 'supports' that character, in which case variable-width encodings aren't legal and Window's use of UTF-16 is non-conformant.</sub></em></p>\n<p><sub>2. Unicode allows many characters to be represented with multiple code points, which creates the same problems for simple text algorithms as variable width encodings. Even if one strictly maintains a composed normalization, some characters still require multiple code points. See: <a href=\"http://www.unicode.org/standard/where/\" rel=\"noreferrer\">http://www.unicode.org/standard/where/</a></sub>\n</p></hr>\n", "OwnerUserId": "365496"}, "11107608": {"CommentCount": "9", "AcceptedAnswerId": "11107667", "PostTypeId": "1", "LastEditorUserId": "1237747", "CreationDate": "2012-06-19T19:00:50.673", "LastActivityDate": "2014-05-11T06:56:37.883", "LastEditDate": "2013-08-23T09:03:44.650", "ViewCount": "25849", "FavoriteCount": "31", "Title": "What's \"wrong\" with C++ wchar_t and wstrings? What are some alternatives to wide characters?", "Id": "11107608", "Score": "76", "Body": "<p>I have seen a lot of people in the C++ community(particularly ##c++ on freenode) resent the use of <code>wstrings</code> and <code>wchar_t</code>, and their use in the windows api. What is exactly \"wrong\" with <code>wchar_t</code> and <code>wstring</code>, and if I want to support internationalization, what are some alternatives to wide characters?</p>\n", "Tags": "<c++><winapi><unicode><internationalization><wstring>", "OwnerUserId": "596065", "AnswerCount": "3"}, "11197888": {"ParentId": "11107608", "CommentCount": "0", "Body": "<p>There's nothing \"wrong\" with wchar_t.  The problem is that, back in NT 3.x days, Microsoft decided that Unicode was Good (it is), and to implement Unicode as 16-bit, wchar_t characters.  So most Microsoft literature from the mid-90's pretty much equated Unicode == utf16 == wchar_t.</p>\n<p>Which, sadly, is not at all the case.  \"Wide characters\" are <em>not</em> necessarily 2 bytes, on all platforms, under all circumstances.</p>\n<p>This is one of the best primers on \"Unicode\" (independent of this question, independent of C++) I've ever seen: I <em>highly</em> recommend it:</p>\n<ul>\n<li><a href=\"http://www.joelonsoftware.com/articles/Unicode.html\" rel=\"noreferrer\">http://www.joelonsoftware.com/articles/Unicode.html</a></li>\n</ul>\n<p>And I honestly believe the best way to deal with \"8-bit ASCII\" vs \"Win32 wide characters\" vs \"wchar_t-in-general\" is simply to accept that \"Windows is Different\" ... and code accordingly.</p>\n<p>IMHO...</p>\n<p>PS:</p>\n<p>I totally agree with jamesdlin above:</p>\n<blockquote>\n<p id=\"so_11107608_11197888_0\">On Windows, you don't really have a choice. Its internal APIs were\n  designed for UCS-2, which was reasonable at the time since it was\n  before the variable-length UTF-8 and UTF-16 encodings were\n  standardized. But now that they support UTF-16, they've ended up with\n  the worst of both worlds.</p>\n</blockquote>\n", "OwnerUserId": "421195", "PostTypeId": "2", "Id": "11197888", "Score": "16", "CreationDate": "2012-06-25T21:52:32.737", "LastActivityDate": "2012-06-25T21:52:32.737"}, "bq_ids": {"n4140": {"so_11107608_11107667_0": {"section_id": 7214, "quality": 0.9523809523809523, "length": 20}}, "n3337": {"so_11107608_11107667_0": {"section_id": 6958, "quality": 0.9523809523809523, "length": 20}}, "n4659": {"so_11107608_11107667_0": {"section_id": 8723, "quality": 0.9523809523809523, "length": 20}}}, "11111005": {"ParentId": "11107608", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Mandatory reading:</p>\n<h2><code><a href=\"http://www.joelonsoftware.com/articles/Unicode.html\" rel=\"nofollow\">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a></code></h2>\n<p>If you program in Java or .Net (VB.Net or C#) - it's largely a non-issue: both are Unicode by default.  If you program in the \"classic\" Win32 API), your best bet is probably to use TCHAR and _T() macros (rather than explictly use wchar).</p>\n<p>All Microsoft compilers VS2005 and later, I believe, default to 16-bit for C/C++ anyway (part of the reason I still use MSVS 6.0 whenever I can ;)).</p>\n<p>One other good (albeit somewhat dated link):</p>\n<ul>\n<li><a href=\"http://www.codeproject.com/Articles/2995/The-Complete-Guide-to-C-Strings-Part-I-Win32-Chara\" rel=\"nofollow\">http://www.codeproject.com/Articles/2995/The-Complete-Guide-to-C-Strings-Part-I-Win32-Chara</a></li>\n</ul>\n", "OwnerUserId": "421195", "LastEditorUserId": "421195", "LastEditDate": "2012-06-19T23:47:26.920", "Id": "11111005", "Score": "-4", "CreationDate": "2012-06-19T23:39:38.543", "LastActivityDate": "2012-06-19T23:47:26.920"}});