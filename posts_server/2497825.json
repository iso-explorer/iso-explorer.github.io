post_cb({"bq_ids": {"n4140": {"so_2497825_2497846_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5945}}, "n3337": {"so_2497825_2497846_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5716}}, "n4659": {"so_2497825_2497846_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 7430}}}, "2497846": {"Id": "2497846", "PostTypeId": "2", "Body": "<p>The problem is likely the result of losing some precision when storing the result of an expression vs. the compiler not doing so in a local as an optimization:</p>\n<pre><code>double d = v[i % 4] * i;  // the result, `d`, might be kept in a register \n                          //   instead of storing it in a memory location, \n                          //   keeping full precision\n\nif(lst[i] != d) {         // the value stored in lst[i] may have lost some \n                          //   precision since it had to be stored in memory,\n                          //   which might not be able to hold the full \n                          //   precision that the expression generated\n</code></pre>\n<p>The C99 standard says in 6.3.1.8/2  \"Usual arithmetic conversions\":</p>\n<blockquote>\n<p id=\"so_2497825_2497846_0\">The  values  of  floating  operands  and  of  the  results  of  floating  expressions  may  be\n  represented in greater precision and range than that required by the type; the types are not\n  changed thereby.</p>\n</blockquote>\n", "LastActivityDate": "2010-03-23T05:53:46.503", "CommentCount": "3", "CreationDate": "2010-03-23T05:53:46.503", "ParentId": "2497825", "Score": "4", "OwnerUserId": "12711"}, "2497870": {"Id": "2497870", "PostTypeId": "2", "Body": "<p>The fact that the result depends on the optimization settings suggests it might be the x87 extended precision messing with things (as Michael Burr says).</p>\n<p>Here's some code I use (with gcc on x86 processors) to switch the extended precision off:</p>\n<pre><code>static const unsigned int PRECISION_BIT_MASK = 0x300;\n///&lt; bitmask to mask out all non-precision bits in the fpu control word \\cite{INTEL}.\nstatic const unsigned int EXTENDED_PRECISION_BITS = 0x300;\n///&lt; add to the fpu control word (after zeroing precision bits) to turn on extended precision \\cite{INTEL}.\nstatic const unsigned int STANDARD_PRECISION_BITS = 0x200;\n///&lt; add to the fpu control word (after zeroing precision bits) to turn off extended precision \\cite{INTEL}.\n\nvoid set_fpu_control_word(unsigned int mode)\n{\n  asm (\"fldcw %0\" : : \"m\" (*&amp;mode));\n}\n\nunsigned int get_fpu_control_word()\n{\n  volatile unsigned int mode = 0;\n  asm (\"fstcw %0\" : \"=m\" (*&amp;mode));\n  return mode;\n}\n\nbool fpu_set_extended_precision_is_on(bool state)\n{\n  unsigned int old_cw = get_fpu_control_word();\n  unsigned int masked = old_cw &amp; ~PRECISION_BIT_MASK;\n  unsigned int new_cw;\n  if(state)\n    new_cw = masked + EXTENDED_PRECISION_BITS;\n  else\n    new_cw = masked + STANDARD_PRECISION_BITS;\n  set_fpu_control_word(new_cw);\n  return true;\n}\n\nbool fpu_get_extended_precision_is_on()\n{\n  unsigned int old_cw = get_fpu_control_word();\n  return  ((old_cw &amp; PRECISION_BIT_MASK) == 0x300);\n}\n</code></pre>\n<p>Or you can just run your code with valgrind, which doesn't simulate the 80-bit registers, and is probably easier for a short program like this!</p>\n", "LastActivityDate": "2010-03-23T05:57:57.523", "CommentCount": "6", "CreationDate": "2010-03-23T05:57:57.523", "ParentId": "2497825", "Score": "6", "OwnerUserId": "187599"}, "2497825": {"ViewCount": "1632", "Body": "<p>I have the following bit of code, however when compiling it with GCC 4.4 with various optimization flags I get some unexpected results when its run.</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n   const unsigned int cnt = 10;\n   double lst[cnt] = { 0.0 };\n   const double v[4] = { 131.313, 737.373, 979.797, 731.137 };\n\n   for(unsigned int i = 0; i &lt; cnt; ++i) {\n      lst[i] = v[i % 4] * i;\n   }\n\n   for(unsigned int i = 0; i &lt; cnt; ++i) {\n      double d = v[i % 4] * i;\n      if(lst[i] != d) {\n         std::cout &lt;&lt; \"error @ : \" &lt;&lt; i &lt;&lt; std::endl;\n         return 1;\n      }\n   }\n   return 0;\n}\n</code></pre>\n<ul>\n<li><p>when compiled with: <strong><em>\"g++ -pedantic -Wall -Werror -O1 -o test test.cpp\"</em></strong> I get the following output: \"error @ : 3\"</p></li>\n<li><p>when compiled with: <strong><em>\"g++ -pedantic -Wall -Werror -O2 -o test test.cpp\"</em></strong> I get the following output: \"error @ : 3\"</p></li>\n<li><p>when compiled with: <strong><em>\"g++ -pedantic -Wall -Werror -O3 -o test test.cpp\"</em></strong> I get no errors</p></li>\n<li><p>when compiled with: <strong><em>\"g++ -pedantic -Wall -Werror -o test test.cpp\"</em></strong> I get no errors</p></li>\n</ul>\n<p>I do not believe this to be an issue related to rounding, or epsilon difference in the comparison. I've tried this with Intel v10 and MSVC 9.0 and they all seem to work as expected. I believe this should be nothing more than a bitwise compare.</p>\n<p>If I replace the if-statement with the following:  <strong><em><code>if (static_cast&lt;long long int&gt;(lst[i]) != static_cast&lt;long long int&gt;(d))</code></em></strong>, and add \"-Wno-long-long\" I get no errors in any of the optimization modes when run.</p>\n<p>If I add <strong><em><code>std::cout &lt;&lt; d &lt;&lt; std::endl;</code></em></strong> before the \"return 1\", I get no errors in any of the optimization modes when run.</p>\n<p>Is this a bug in my code, or is there something wrong with GCC and the way it handles the double type?</p>\n<p><strong>Note:</strong> I've just tried this with gcc versions 4.3 and 3.3, the error is not exhibited.</p>\n<p><strong>Resolution:</strong> Mike Dinsdale noted the following bug report: <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=323\" rel=\"noreferrer\">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=323</a>  It seems the GCC team are not <em>completely sure</em> about nature of problem. </p>\n<p>As suggested in the bug report a possible resolution is to use the ffloat-store option. I've tried this and it works, however the results from a performance point of view are not that great, though ymmv.</p>\n", "Title": "GCC problem with raw double type comparisons", "CreationDate": "2010-03-23T05:47:25.757", "LastActivityDate": "2010-03-23T06:48:55.290", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2010-03-23T06:48:55.290", "LastEditorDisplayName": "Matthieu N.", "OwnerDisplayName": "Matthieu N.", "Id": "2497825", "Score": "8", "Tags": "<c++><gcc><double><compare>", "AnswerCount": "3"}, "2497857": {"Id": "2497857", "PostTypeId": "2", "Body": "<p>The width of the floating point registers in x86 is different from the width of the <code>double</code> in RAM. Therefore comparisons may succeed or fail depending entirely on how the compiler decides to optimize the loads of floating point values.</p>\n", "LastActivityDate": "2010-03-23T05:55:37.293", "CommentCount": "4", "CreationDate": "2010-03-23T05:55:37.293", "ParentId": "2497825", "Score": "3", "OwnerUserId": "13422"}});