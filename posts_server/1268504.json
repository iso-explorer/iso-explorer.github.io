post_cb({"bq_ids": {"n4140": {"so_1268504_1268915_1": {"length": 43, "quality": 0.9772727272727273, "section_id": 337}}, "n3337": {"so_1268504_1268915_1": {"length": 43, "quality": 0.9772727272727273, "section_id": 327}}, "n4659": {"so_1268504_1268915_1": {"length": 43, "quality": 0.9772727272727273, "section_id": 346}}}, "1268915": {"Id": "1268915", "PostTypeId": "2", "Body": "<p>It is looks like nondeduced context. According to C++ Standard 14.8.2.4/4:</p>\n<blockquote>\n<p id=\"so_1268504_1268915_0\">The nondeduced contexts are:</p>\n<ul>\n<li>The <em>nested-name-specifier</em> of a type that was specified using a <em>qualified-id</em>.</li>\n<li>A type that is a <em>template-id</em> in which one or more of the <em>template-arguments</em> is an expression that references a <em>template-parameter</em>.</li>\n</ul>\n<p id=\"so_1268504_1268915_1\">When a type name is specified in a way that includes a nondeduced context, all of the types that comprise that type name are also nondeduced.  However, a compound type can include both deduced and nondeduced types.  [<em>Example</em>: If a type is specified as <code>A&lt;T&gt;::B&lt;T2&gt;</code>, both <code>T</code> and <code>T2</code> are nondeduced.  Likewise, if a type is specified as <code>A&lt;I+J&gt;::X&lt;T&gt;</code>, <code>I</code>, <code>J</code>, and <code>T</code> are nondeduced.  If a type is specified as <code>void f(typename  A&lt;T&gt;::B,  A&lt;T&gt;)</code>, the <code>T</code> in <code>A&lt;T&gt;::B</code> is nondeduced but the <code>T</code> in <code>A&lt;T&gt;</code> is deduced. ]</p>\n</blockquote>\n", "LastActivityDate": "2009-08-12T21:43:50.497", "CommentCount": "2", "CreationDate": "2009-08-12T21:43:50.497", "ParentId": "1268504", "Score": "6", "OwnerUserId": "123111"}, "1268905": {"Id": "1268905", "PostTypeId": "2", "Body": "<p>Just as first note, typename name is used when you mention a <em>dependent</em> name. So you don't need it here.</p>\n<pre><code>\ntemplate &lt;class T&gt;\nstruct S\n{\n    typedef T&amp; type;\n};\n</code></pre>\n<p>Regarding the template instantiation, the problem is that <code>typename S&lt;A&gt;::type</code> characterizes a <em>nondeduced</em> context for A. When a template parameter is used only in a nondeduced context (the case for A in your functions) it's not taken into consideration for template argument deduction. The details are at section 14.8.2.4 of the C++ Standard (2003).</p>\n<p>To make your call work, you need to explicitly specify the type:</p>\n<pre><code>\ntemp&lt;char&gt;(c);\n</code></pre>\n", "LastActivityDate": "2009-08-12T21:42:18.627", "CommentCount": "2", "CreationDate": "2009-08-12T21:42:18.627", "ParentId": "1268504", "Score": "27", "OwnerUserId": "155191"}, "1268946": {"Id": "1268946", "PostTypeId": "2", "Body": "<p>Deduction works in the forward direction:</p>\n<pre><code>template &lt;class T&gt; void f(T);\n\nf(2); // can deduce int from T\n</code></pre>\n<blockquote>\n<p id=\"so_1268504_1268946_0\">Why is this happening?</p>\n</blockquote>\n<p>It doesn't work in the backwards direction (your example):</p>\n<pre><code>template &lt;class A&gt; void g(typename S&lt;A&gt;::type);\n</code></pre>\n<blockquote>\n<p id=\"so_1268504_1268946_1\">Is it that hard to see that the template arguments are char and int values?</p>\n</blockquote>\n<p>Template deduction can do some magical (Turing-complete) things, but I don't think this is one of them.</p>\n<p>You might use something like (untested):</p>\n<pre><code>template &lt;class SA&gt; void h(SA a1)\n{\n    STATIC_ASSERT(same_type&lt;SA, S&lt;A&gt;::type&gt;::value);\n    typedef typename SA::type A;\n\n    ...\n}\n</code></pre>\n<p>Using your favorite static assert library (Boost has two).</p>\n", "LastEditorUserId": "56338", "LastActivityDate": "2012-01-18T14:14:29.343", "Score": "4", "CreationDate": "2009-08-12T21:50:51.730", "ParentId": "1268504", "CommentCount": "1", "OwnerUserId": "116270", "LastEditDate": "2012-01-18T14:14:29.343"}, "1268504": {"ViewCount": "3431", "Body": "<p>I created two simple functions which get template parameters and an empty struct defining a type:</p>\n<pre><code>//S&lt;T&gt;::type results in T&amp;\ntemplate &lt;class T&gt;\nstruct S\n{\n    typedef typename T&amp; type;\n};\n\n//Example 1: get one parameter by reference and return it by value\ntemplate &lt;class A&gt;\nA\ntemp(typename S&lt;A&gt;::type a1)\n{\n    return a1;\n}\n\n//Example 2: get two parameters by reference, perform the sum and return it\ntemplate &lt;class A, class B&gt;\nB\ntemp2(typename S&lt;A&gt;::type a1, B a2)//typename struct S&lt;B&gt;::type a2)\n{\n    return a1 + a2;\n}\n</code></pre>\n<p>The argument type is applied to the struct S to get the reference. I call them with some integer values but the compiler is unable to deduce the arguments:</p>\n<pre><code>int main()\n{\n    char c=6;\n    int d=7;\n    int res = temp(c);\n    int res2 = temp2(d,7);\n}\n</code></pre>\n<blockquote>\n<p id=\"so_1268504_1268504_0\">Error 1   error C2783: 'A\n  temp(S::type)' : could not deduce\n  template argument for 'A'</p>\n<p id=\"so_1268504_1268504_1\">Error 2   error C2783: 'B\n  temp2(S::type,B)' : could not\n  deduce template argument for 'A'</p>\n</blockquote>\n<hr>\n<p>Why is this happening? Is it that hard to see that the template arguments are <em>char</em> and <em>int</em> values?</p>\n</hr>", "AcceptedAnswerId": "1268905", "Title": "Why is the template argument deduction not working here?", "CreationDate": "2009-08-12T20:21:56.230", "Id": "1268504", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-01-18T14:51:28.010", "LastEditorUserId": "476681", "LastActivityDate": "2012-01-18T14:51:28.010", "Score": "21", "OwnerUserId": "155391", "Tags": "<c++><templates>", "AnswerCount": "3"}});