post_cb({"bq_ids": {"n4140": {"so_9777561_9777679_0": {"length": 19, "quality": 0.95, "section_id": 3917}, "so_9777561_9777705_0": {"length": 18, "quality": 1.0, "section_id": 5810}}, "n3337": {"so_9777561_9777679_0": {"length": 19, "quality": 0.95, "section_id": 3777}, "so_9777561_9777705_0": {"length": 18, "quality": 1.0, "section_id": 5583}}, "n4659": {"so_9777561_9777679_0": {"length": 19, "quality": 0.95, "section_id": 4803}, "so_9777561_9777705_0": {"length": 18, "quality": 1.0, "section_id": 7271}}}, "9777679": {"Id": "9777679", "PostTypeId": "2", "Body": "<p>C++03 6.7/2 \"Declaration statement\" says:</p>\n<blockquote>\n<p id=\"so_9777561_9777679_0\">Variables with automatic storage duration (3.7.2) are initialized each time their declaration-statement is executed.  Variables with automatic storage duration declared in the block are destroyed on exit from the block</p>\n</blockquote>\n", "LastActivityDate": "2012-03-19T20:46:12.877", "Score": "0", "CreationDate": "2012-03-19T20:46:12.877", "ParentId": "9777561", "CommentCount": "0", "OwnerUserId": "12711"}, "9777561": {"ViewCount": "114", "Body": "<p>Can anyone point me to a reference in the C++ standard that guarantees me that the automatic <em>char</em>* <em>q</em> in the function <em>foo1()</em> will always be initialized after <em>p = bar()</em> has been called in <em>foo1()</em>. I am so used to creating a new block like in <em>foo2()</em> and am wondering if I am being overly blockish and paranoid of the optimizing compiler. Or I am correct in being paranoid and should not assume that the compiler will not optimize the code such that <em>p = bar()</em> will always be called before <em>q(p)</em>?\nThanks!</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;strings.h&gt;\n\n\nchar* bar()\n{\n    char* t = (char*)malloc(15);\n    strcpy(t, \"Hello World!\");\n    return t;\n}\n\nvoid foo1(void)\n{\n    char* p = NULL;\n\n    printf(\"foo1: do some stuff\\n\");\n\n    p = bar();\n\n    printf(\"foo1: do some more stuff\\n\");\n\n    char* q(p);\n\n    printf(\"foo1: q says:%s\\n\", q);\n\n    free(p);\n}\n\nvoid foo2(void)\n{\n    char* p = NULL;\n\n    printf(\"foo2: do some stuff\\n\");\n\n    p = bar();\n\n    printf(\"foo2: do some more stuff\\n\");\n\n    // is this block necessary?\n    {\n        char* q(p);\n\n        printf(\"foo2: q says:%s\\n\", q);\n    }\n\n    free(p);\n}\n\nint main(int ac, char* av[])\n{\n    foo1();\n    foo2();\n    return 0;\n}\n</code></pre>\n", "Title": "C++ initialization of automatics and scope", "CreationDate": "2012-03-19T20:37:38.507", "LastActivityDate": "2012-03-19T20:48:27.993", "CommentCount": "5", "PostTypeId": "1", "Id": "9777561", "Score": "1", "OwnerUserId": "1279477", "Tags": "<c++><initialization><scope>", "AnswerCount": "3"}, "9777615": {"Id": "9777615", "PostTypeId": "2", "Body": "<p>You can safely assume that <code>p = bar()</code> will occur before <code>char * q(p)</code> due to the existence of <a href=\"http://en.wikipedia.org/wiki/Sequence_point\" rel=\"nofollow\"><em>sequence points</em></a>.</p>\n<p>I can't bring myself to wade through the C++ standard right now, but I can give you the equivalent from the C99 standard, which I hope will put your mind at ease sufficiently:</p>\n<p><strong>5.1.2.3:</strong></p>\n<blockquote>\n<p id=\"so_9777561_9777615_0\">Accessing a volatile object, modifying an object, modifying a file, or calling a function\n  that does any of those operations are all side effects, which are changes in the state of\n  the execution environment. Evaluation of an expression may produce side effects. At\n  certain specified points in the execution sequence called sequence points, all side effects\n  of previous evaluations shall be complete and no side effects of subsequent evaluations\n  shall have taken place.</p>\n</blockquote>\n<p><strong>Annex C:</strong> <em>(emphasis mine)</em></p>\n<blockquote>\n<p id=\"so_9777561_9777615_1\">The following are the sequence points described in 5.1.2.3:</p>\n<ul>\n<li>The call\n  to a function, after the arguments have been evaluated.</li>\n<li>The end of the first operand of the following operators: logical AND\n  <code>&amp;&amp;</code>; logical OR <code>||</code>; conditional <code>?</code>; comma <code>,</code>.</li>\n<li>The end of a full declarator;</li>\n<li>The\n  end of a full expression: <strong>an initializer</strong>; the expression in an\n  expression statement; the controlling expression of a\n  selection statement (<code>if</code> or <code>switch</code>); the controlling expression\n  of a <code>while</code> or <code>do</code> statement; each of the expressions of a <code>for</code>\n  statement; the expression in a <code>return</code> statement.</li>\n<li>Immediately before a library function returns.</li>\n<li>After the\n  actions associated with each formatted input/output function\n  conversion specifier.</li>\n<li>Immediately before and\n  immediately after each call to a comparison function, and also between\n  any call to a comparison function and any movement of the objects\n  passed as arguments to that call.</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "129570", "LastActivityDate": "2012-03-19T20:47:42.460", "Score": "2", "CreationDate": "2012-03-19T20:41:28.510", "ParentId": "9777561", "CommentCount": "3", "LastEditDate": "2012-03-19T20:47:42.460", "OwnerUserId": "129570"}, "9777705": {"Id": "9777705", "PostTypeId": "2", "Body": "<p>You don't need to be this paranoid. C++ says </p>\n<blockquote>\n<p id=\"so_9777561_9777705_0\">Every value computation and side effect associated with a\n  full-expression is sequenced before every value computation and side\n  effect associated with the next full-expression to be evaluated.</p>\n<p id=\"so_9777561_9777705_1\"><strong>[intro.execution] 1.9 /14 ,n3337</strong></p>\n</blockquote>\n", "LastActivityDate": "2012-03-19T20:48:27.993", "Score": "1", "CreationDate": "2012-03-19T20:48:27.993", "ParentId": "9777561", "CommentCount": "3", "OwnerUserId": "365496"}});