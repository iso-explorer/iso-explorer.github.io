post_cb({"7372307": {"Id": "7372307", "PostTypeId": "2", "Body": "<p>I highly expect all standard container implementations to be thread safe for <em>unshared</em> collections (i.e. distinct collections of the same type, like you put it).</p>\n<p>But, to be precise, you'll HAVE to consult your library's documentation, as the standard doesn't address threading at all (c++11 makes some amendments there, but implementations are not widely on par with that)</p>\n<p>The only edge case would be some string library implementation and especially io streams (mainly because of shared information like locale definitions, character sets and possibly sentries that could be lazily constructed; mainly the risk would be multiple threads constructing the same global data concurrently. The risk gets bigger when you actively manipulate and imbue locale facets).</p>\n", "LastActivityDate": "2011-09-10T14:16:25.063", "CommentCount": "0", "CreationDate": "2011-09-10T14:16:25.063", "ParentId": "7372258", "Score": "1", "OwnerUserId": "85371"}, "7372299": {"Id": "7372299", "PostTypeId": "2", "Body": "<p>STL containers are not Thread Safe. So you will have to implement your own synchronization mechanisms to use STL in a multithreaded environment.</p>\n<p>Given the above, to answer your question:<br>\nIt is safe to read and write to one instance of a type even if another thread is reading or writing to a different instance of the same type.<br>\nFor example, given objects <code>A</code> and <code>B</code> of the same type(<code>std::vector</code> in your case), it is safe if <code>A</code> is being written in thread 1 and <code>B</code> is being read in thread 2.</br></br></p>\n<p><strong>Why is this different to writing to two ints on different threads?</strong><br>\nIt is just the same.<br>\nJust like you would not require any synchronization to writing to two separate integers in two different threads, You do not require any synchronization to write to two different vectors in two separate threads.</br></br></p>\n<hr>\n<p>Here is the <strong><a href=\"http://msdn.microsoft.com/en-us/library/c9ceah3b.aspx\" rel=\"nofollow\">relevant citation</a></strong> from MSDN:   </p>\n<p>The following thread safety rules apply to all classes in the Standard C++ Library (except <code>shared_ptr</code> and <code>iostream</code> classes, as described below).</p>\n<blockquote>\n<p id=\"so_7372258_7372299_0\"><strong>A single object is thread safe for reading from multiple threads.</strong><br>\n  For example:  Given an object <code>A</code>, it is safe to read <code>A</code> from <code>thread 1</code> and from <code>thread 2</code> simultaneously.</br></p>\n<p id=\"so_7372258_7372299_1\"><strong>If a single object is being written to by one thread, then all reads and writes to that object on the same or other threads must be protected.</strong><br>\n  For example: Given an object <code>A</code>, if <code>thread 1</code> is writing to <code>A</code>, then <code>thread 2</code> must be prevented from reading from or writing to <code>A</code>.</br></p>\n<p id=\"so_7372258_7372299_2\"><strong>It is safe to read and write to one instance of a type even if another thread is reading or writing to a different instance of the same type</strong>.<br>\n  For example: Given objects <code>A</code> and <code>B</code> of the same type, it is safe if <code>A</code> is being written in <code>thread 1</code> and <code>B</code> is being read in <code>thread 2</code>.</br></p>\n</blockquote>\n</hr>", "LastEditorUserId": "452307", "LastActivityDate": "2011-09-10T14:27:52.317", "Score": "2", "CreationDate": "2011-09-10T14:13:54.137", "ParentId": "7372258", "CommentCount": "0", "OwnerUserId": "452307", "LastEditDate": "2011-09-10T14:27:52.317"}, "7372475": {"Id": "7372475", "PostTypeId": "2", "Body": "<p>Yes, it's safe. If thread 1 allocates vector A, and thread 2 allocates vector B, and neither knows anything about the other's vector instance, it will be safe. It won't be any different than accessing ints. </p>\n<p>Now, if thread 1 and thread 2 are trying to access the same vector or int, that is not thread safe and you'll have to add synchronization.</p>\n", "LastActivityDate": "2011-09-10T14:45:19.227", "CommentCount": "0", "CreationDate": "2011-09-10T14:45:19.227", "ParentId": "7372258", "Score": "0", "OwnerUserId": "53089"}, "7372354": {"Id": "7372354", "PostTypeId": "2", "Body": "<p>References given relating to C++0x FDIS as C++03 did not mentionned threads at all.</p>\n<p>First: yes, using two distinct containers (beware of aliasing through references/pointers) in two distinct threads is safe.</p>\n<blockquote>\n<p id=\"so_7372258_7372354_0\"><strong>\u00a7 17.6.5.9 Data race avoidance</strong></p>\n<p id=\"so_7372258_7372354_1\">2/ A C++ standard library function shall not directly or indirectly access objects (1.10) accessible by threads other than the current thread unless the objects are accessed directly or indirectly via the function\u2019s arguments, including this.</p>\n<p id=\"so_7372258_7372354_2\">3/ A C++ standard library function shall not directly or indirectly modify objects (1.10) accessible by threads other than the current thread unless the objects are accessed directly or indirectly via the function\u2019s non-const arguments, including this.</p>\n</blockquote>\n<p><em>(further notes precise that if the implementation use shared states between different objects, access shall be protected appropriately so that it is invisible to the user)</em></p>\n<p>Even more, accessing two differents objects within one container is safe!</p>\n<blockquote>\n<p id=\"so_7372258_7372354_3\"><strong>\u00a7 23.2.2 Container data races</strong></p>\n<p id=\"so_7372258_7372354_4\">2/ Notwithstanding (17.6.5.9), implementations are required to avoid data races when the contents of the contained object in different elements in the same sequence, excepting <code>vector&lt;bool&gt;</code>, are modified concurrently.</p>\n</blockquote>\n<p>Also, even though C++98/C++03 did not address this question in the Standard, any quality implementation already conformed. If you are using either MSVC's or gcc's library, it already works, and it probably works for most of the other compilers' library too.</p>\n", "LastActivityDate": "2011-09-10T14:24:13.690", "CommentCount": "0", "CreationDate": "2011-09-10T14:24:13.690", "ParentId": "7372258", "Score": "1", "OwnerUserId": "147192"}, "bq_ids": {"n4140": {"so_7372258_7372354_4": {"length": 17, "quality": 0.8947368421052632, "section_id": 718}, "so_7372258_7372354_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 6347}, "so_7372258_7372354_2": {"length": 21, "quality": 0.9545454545454546, "section_id": 6348}}, "n3337": {"so_7372258_7372354_4": {"length": 18, "quality": 0.9473684210526315, "section_id": 707}, "so_7372258_7372354_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 6104}, "so_7372258_7372354_2": {"length": 21, "quality": 0.9545454545454546, "section_id": 6105}}, "n4659": {"so_7372258_7372354_4": {"length": 17, "quality": 0.8947368421052632, "section_id": 749}, "so_7372258_7372354_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 7856}, "so_7372258_7372354_2": {"length": 21, "quality": 0.9545454545454546, "section_id": 7857}}}, "7372258": {"ViewCount": "404", "Body": "<p>I have a Vector A on Thread 1, I also have a Vector B on Thread 2.</p>\n<p>Is it safe to write to vectors A and B at the same time, given they are different instantiated objects but of the same type?</p>\n<p>If not, why is this different from the writing to an int c on Thread 1 and an int d on Thread 2?</p>\n", "Title": "Are STL Container Classes Of Same Type Thread Safe?", "CreationDate": "2011-09-10T14:07:40.037", "LastActivityDate": "2011-09-10T14:45:19.227", "CommentCount": "1", "PostTypeId": "1", "Id": "7372258", "Score": "0", "OwnerUserId": "938247", "Tags": "<c++><multithreading>", "AnswerCount": "5"}, "7372275": {"Id": "7372275", "PostTypeId": "2", "Body": "<p>None of standard container classes are thread-safe. If two different threads access the same member function which modifies the <em>shared</em> resource(s), then your code is not safe.</p>\n<p>But in your code, <code>vectorA</code> and <code>vectorB</code> are not <em>shared</em> resources, then your code is safe, assuming that the vectors do <em>not</em> contain <em>shared</em> resources themselves.</p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2011-09-10T14:15:53.620", "Score": "3", "CreationDate": "2011-09-10T14:10:47.913", "ParentId": "7372258", "CommentCount": "3", "OwnerUserId": "415784", "LastEditDate": "2011-09-10T14:15:53.620"}});