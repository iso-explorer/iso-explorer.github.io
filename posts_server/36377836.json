post_cb({"36377836": {"ViewCount": "333", "Body": "<p>I came across a difference in behavior, between gcc (4.9.2) and clang (3.5.0), which surprised me.</p>\n<p>When I try to feed an <code>unsigned int</code> from an <code>std::istringstream</code> initialized with a negative value (\"-15\", in the example) I get</p>\n<ul>\n<li>an error (with <code>fail()</code> bit raised) with clang++</li>\n<li>the initialization with <code>signed(-15)</code> with gcc++</li>\n</ul>\n<p>I prepared the trivial following example program.</p>\n<pre><code>#include &lt;sstream&gt;\n#include &lt;iostream&gt;\n\nint main ()\n {\n   std::istringstream iss(\"-15\");\n\n   unsigned int  ui;\n\n   iss &gt;&gt; ui;\n\n   std::cout &lt;&lt; \"ui[\" &lt;&lt; ui &lt;&lt; \"] signed(ui)[\" &lt;&lt; signed(ui)\n      &lt;&lt; \"] flags[\" &lt;&lt; iss.fail() &lt;&lt; iss.good() &lt;&lt; iss.bad()\n      &lt;&lt; iss.eof() &lt;&lt; \"]\\n\";\n\n   return 0;\n }\n</code></pre>\n<p>With clang++, I obtain the following output</p>\n<pre><code>ui[0] signed(ui)[0] flags[1001]\n</code></pre>\n<p>With g++, I obtain the following output</p>\n<pre><code>ui[4294967281] signed(ui)[-15] flags[0001]\n</code></pre>\n<p>I have two questions.</p>\n<p>The first is obvious: who's right? clang++, g++ or is an undefined behaviour?</p>\n<p>The second is: how can I force the gcc++ to behave like the clang++, giving an error when extracting an unsigned value from a string beginning with a minus?</p>\n<p>Thanks and sorry for my bad english.</p>\n<p><strong>EDIT 2016.04.03</strong></p>\n<p>I realized that this isn't a difference between g++ and clang++, but a difference between libstd++ and libc++.</p>\n<p>Compiling and linking with clang++ and libstd++, I obtain the same output I get with g++.</p>\n<p>Sorry.</p>\n", "Title": "g++ and clang++ different behaviour with stream input and unsigned integer", "CreationDate": "2016-04-02T19:31:51.667", "LastActivityDate": "2016-08-26T06:46:52.807", "CommentCount": "13", "LastEditDate": "2016-04-03T13:39:36.923", "PostTypeId": "1", "LastEditorUserId": "6022656", "Id": "36377836", "Score": "19", "OwnerUserId": "6022656", "Tags": "<c++><clang++><libstdc++><libc++><istringstream>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_36377836_39159956_0": {"length": 19, "quality": 1.0, "section_id": 6536}}, "n3337": {"so_36377836_39159956_0": {"length": 19, "quality": 1.0, "section_id": 6291}}, "n4659": {"so_36377836_39159956_0": {"length": 14, "quality": 0.7368421052631579, "section_id": 8018}}}, "39159956": {"Id": "39159956", "PostTypeId": "2", "Body": "<p>This has been discussed before here: <a href=\"https://stackoverflow.com/questions/13045693/negative-numeric-string-e-g-10-to-unsigned-short/13046160#13046160\">Negative numeric string (e.g. \"-10\") to unsigned short</a></p>\n<p>The answer is that according to the C++ standard 22.4.2.1.2p3, the conversion is required to fail and the value stores should be:</p>\n<blockquote>\n<p id=\"so_36377836_39159956_0\">the most negative representable value <strong>or zero for an unsigned integer type</strong>, if the field represents a value too large negative to be represented in val. ios_base::failbit is assigned to err.</p>\n</blockquote>\n<p>Therefore, clang++ is the correct behavior.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-08-26T06:46:52.807", "Score": "1", "CreationDate": "2016-08-26T06:46:52.807", "ParentId": "36377836", "CommentCount": "0", "OwnerUserId": "55935", "LastEditDate": "2017-05-23T12:08:35.727"}});