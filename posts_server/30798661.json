post_cb({"30799219": {"ParentId": "30798661", "CommentCount": "1", "Body": "<p>Two separate issues.</p>\n<ol>\n<li><p>By default MSVC issues a warning (<a href=\"https://msdn.microsoft.com/en-us/library/x9db2t0x.aspx\" rel=\"nofollow\">C4114</a>) for repeated qualifiers rather than an error. The standard permits this since all that's required is a diagnostic message, and a warning satisfies this requirement.</p></li>\n<li><p>The final <code>const</code>s compile only when they are actually part of a subsequent declaration. For instance:</p>\n<pre><code>const const int const const * const const Get(){ return new int(1); } const const\n\nint main() {}\n</code></pre>\n<p>This is actually</p>\n<pre><code>const const int const const * const const Get(){ return new int(1); } \n\nconst const int main() {}\n</code></pre>\n<p>which is \"OK\" modulo the repeated qualifiers part.</p></li>\n</ol>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "30799219", "Score": "0", "CreationDate": "2015-06-12T09:02:02.737", "LastActivityDate": "2015-06-12T09:02:02.737"}, "30798661": {"CommentCount": "12", "ViewCount": "280", "PostTypeId": "1", "LastEditorUserId": "2277256", "CreationDate": "2015-06-12T08:28:43.887", "LastActivityDate": "2015-06-12T09:45:01.037", "Title": "Quadruple \"const\" in function definition", "FavoriteCount": "1", "LastEditDate": "2015-06-12T09:02:05.803", "Id": "30798661", "Score": "4", "Body": "<p>I am wondering about how C++ uses its const keyword.</p>\n<p>I have the following function definition. Which alone looks quite insane, but works just fine.</p>\n<pre><code>const int const * const Get(){ return new int(1); } const\n</code></pre>\n<p>I am aware of what each placement of the const means, this question isn't about the meaning of the placement of the const keyword.</p>\n<p>I am quite confused by the use of the const keywords, because you can duplicate them.</p>\n<pre><code>const int const const * const Get(){ return new int(1); } const\n\n// or even\n\nconst const int const const * const const Get(){ return new int(1); } const const\n\n// or even yet\n\nconst const const int const const const * const const const Get(){ return new int(1); } const const const\n</code></pre>\n<p>Why does the language allow you to do this?</p>\n<p>EDIT:\nThis code can be compiled in Visual Studio 2013, Visual C++ compiler. I am not sure about the actual name of the compiler.</p>\n<p>EDIT2:\nSo the answer is that this is against the standard. The code only compiles wihout using <code>/Za</code> option.</p>\n<p>I am voting to close the question.</p>\n", "Tags": "<c++><const><language-lawyer>", "OwnerUserId": "2277256", "AnswerCount": "5"}, "30798885": {"ParentId": "30798661", "LastEditDate": "2015-06-12T09:09:11.227", "CommentCount": "3", "CreationDate": "2015-06-12T08:42:46.790", "OwnerUserId": "464581", "LastEditorUserId": "464581", "PostTypeId": "2", "Id": "30798885", "Score": "3", "Body": "<p>Re </p>\n<blockquote>\n<p id=\"so_30798661_30798885_0\"><strong>\u201d</strong> Why does the language allow you to do this?\"</p>\n</blockquote>\n<p>it doesn't. The code presented is <strong>not real code</strong>. E.g.</p>\n<pre><code>const int const * const Get(){ return new int(1); } const\n</code></pre>\n<p>(the first example) will not compile with any standard-conforming compiler, for two reasons:</p>\n<ul>\n<li>The multiple <code>const</code>s at the start (for the <code>int</code>) are not permitted.</li>\n<li>The <code>const</code> at the end is a syntax error.</li>\n</ul>\n<p>Standardeese for the first point: C++11 \u00a77.1.6/2,</p>\n<blockquote>\n<p id=\"so_30798661_30798885_1\"><strong>\u201d</strong> <code>const</code> can be combined with any type specifier except itself.</p>\n</blockquote>\n", "LastActivityDate": "2015-06-12T09:09:11.227"}, "30799045": {"ParentId": "30798661", "LastEditDate": "2015-06-12T09:06:21.107", "CommentCount": "2", "CreationDate": "2015-06-12T08:51:44.953", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "PostTypeId": "2", "Id": "30799045", "Score": "0", "Body": "<p>This function declaration (and others)</p>\n<pre><code>const int const * const Get(){ return new int(1); } const;\n</code></pre>\n<p>will not compile because according to the C++ Standard (7.1.6 Type specifiers, #2)</p>\n<blockquote>\n<p id=\"so_30798661_30799045_0\">\u2014 const can be combined with any type specifier <strong>except itself</strong>.</p>\n</blockquote>\n<p>and (7.1.6.1 The cv-qualifiers)</p>\n<blockquote>\n<p id=\"so_30798661_30799045_1\">1 There are two cv-qualifiers, const and volatile. Each cv-qualifier\n  <strong>shall appear at most once</strong> in a cvqualifier- seq.</p>\n</blockquote>\n<p>In this declaration for example qualifier const is combined with itself</p>\n<pre><code>const int const * const Get(){ return new int(1); } const;\n^^^^^     ^^^^^\n</code></pre>\n<p>Moreover the last qualifier is placed in the wrong place.:) </p>\n<pre><code>const int const * const Get(){ return new int(1); } const;\n                                                    ^^^^^ \n</code></pre>\n<p>At leats there should be</p>\n<pre><code>const int const * const Get() const { return new int(1); };\n                              ^^^^^ \n</code></pre>\n<p>Or in this declaration (if to place the cv-qualifier sequence correctly) at least cv-qualifier sequence has more than one const qualifier</p>\n<pre><code>const const int const const * const const Get() const const { return new int(1); };\n                                                ^^^^^ ^^^^^\n</code></pre>\n<p>Opposite to C++ in C you may combine several qualifiers in a declaration. The redundant qualifiers are simply ignored. For example</p>\n<pre><code>const long const long const int const x = 10;\n</code></pre>\n<p>that is equivalent to</p>\n<pre><code>const long long int x = 10;\n</code></pre>\n<p>However in C++ this declaration will not compile.</p>\n", "LastActivityDate": "2015-06-12T09:06:21.107"}, "30798876": {"ParentId": "30798661", "LastEditDate": "2015-06-12T09:37:55.643", "CommentCount": "7", "CreationDate": "2015-06-12T08:42:09.843", "OwnerUserId": "496161", "LastEditorUserId": "496161", "PostTypeId": "2", "Id": "30798876", "Score": "10", "Body": "<p>Explicitly repeating <code>const</code> in the same type specifier sequence is disallowed in the standard.</p>\n<p>[dcl.type]/2 (emphasis mine)</p>\n<blockquote>\n<p id=\"so_30798661_30798876_0\">As a general rule, at most one type-specifier is allowed in the complete decl-specifier-seq of a declaration or\n  in a type-specifier-seq or trailing-type-specifier-seq.</p>\n<p id=\"so_30798661_30798876_1\">...</p>\n<p id=\"so_30798661_30798876_2\">\u2014 <strong>const can be combined with any type specifier except itself.</strong></p>\n</blockquote>\n<p>One might think that this is allowed from the following quote (found by @davidhigh):</p>\n<p>[dcl.type.cv]/1</p>\n<blockquote>\n<p id=\"so_30798661_30798876_3\">There are two cv-qualifiers, const and volatile. Each cv-qualifier shall appear at most once in a cv-qualifier-seq. If a cv-qualifier appears in a decl-specifier-seq, the init-declarator-list of the declaration shall not be empty. [ Note: 3.9.3 and 8.3.5 describe how cv-qualifiers affect object and function types. \u2014 end note ] <strong>Redundant cv-qualifications are ignored</strong>. [ Note: For example, these could be introduced by typedefs. \u2014 end note ]</p>\n</blockquote>\n<p>However, this rule is to allow <code>const</code> duplications which arise through substitution in templates or <code>typedef</code>s, not those explicitly typed by the programmer.</p>\n<p>Taking one of your examples:</p>\n<pre><code>const const int const const * const const Get(){ return new int(1); } const const\n</code></pre>\n<p>The first four <code>const</code>s all apply to the <code>int</code>, breaking the rule posted above.</p>\n<p>The next two <code>const</code>s apply to the pointer and are invalid by the same rule.</p>\n<p>The final two <code>const</code>s are not even part of the declaration for <code>Get</code>. They will be applied to whatever the parser finds next, becoming invalid by either the same rules as above, or by other C++ syntax rules.</p>\n<p>VS2013 may compile such code using language extensions, but this is not standard behaviour. <a href=\"http://goo.gl/mMVV6g\" rel=\"nofollow\">gcc 5.1.0</a> and <a href=\"http://goo.gl/9cuNhh\" rel=\"nofollow\">clang 3.5.1</a> will both refuse to compile your code and both provide a reasonable diagnostic.</p>\n", "LastActivityDate": "2015-06-12T09:37:55.643"}, "30798774": {"ParentId": "30798661", "LastEditDate": "2015-06-12T09:45:01.037", "CommentCount": "4", "CreationDate": "2015-06-12T08:35:00.150", "OwnerUserId": "2412846", "LastEditorUserId": "2412846", "PostTypeId": "2", "Id": "30798774", "Score": "2", "Body": "<p>Why? Because the standard says so. Here is an excerpt from [dcl.type.cv] which states exactly this (emphasis mine) :</p>\n<blockquote>\n<p id=\"so_30798661_30798774_0\">There are two cv-qualifiers, const and volatile. Each cv-qualifier shall appear at most once in a cv-qualifier-seq.\n  If a cv-qualifier appears in a decl-specifier-seq, the init-declarator-list of the declaration shall\n  not be empty. [ Note: 3.9.3 and 8.3.5 describe how cv-qualifiers affect object and function types. \u2014 end note ]\n  <strong>Redundant cv-qualifications are ignored.</strong> [ Note: For example, these could be introduced by typedefs. \u2014 end\n  note ]</p>\n</blockquote>\n<p>This makes sense in templates, for example. If the template parameter is deduced as <code>const</code>, it can easily happen that another const is added somewehere.</p>\n<hr>\n<p><strong>EDIT</strong>: as noted several times and redundantly, my above answer is misleading in that it does not qualify here. It is opposed by the rule in [dcl.type] which explicitly disallows explicitly typed <code>const</code> qualifiers (see the fine comment by @TartanLlama in his answer). </p>\n<hr>\n<p><strong>EDIT 2</strong>: the application of the rule everyone seems to agree on states: first redundant <code>const</code>s are disallowed, and if they still should somewhere occur they are ignored.</p>\n<p>This, however, requires a priority of the standard quotes. </p>\n<p>Without, one could also think of an order like: first remove redundant <code>const</code>s, and only then apply the rule that multiple <code>const</code>s are not allowed (which, of course, would render the latter rule itself redundant).</p>\n<p>In this case, obviously, the quote shows how it is meant to be interpreted. But, being pedantic, <em>it does not have to be interpreted like this</em> -- unless there is some form of priority in the standard quotes.</p>\n</hr></hr>", "LastActivityDate": "2015-06-12T09:45:01.037"}, "bq_ids": {"n4140": {"so_30798661_30798876_2": {"section_id": 5427, "quality": 1.0, "length": 7}, "so_30798661_30798876_3": {"section_id": 5430, "quality": 0.775, "length": 31}, "so_30798661_30798876_0": {"section_id": 5427, "quality": 1.0, "length": 11}, "so_30798661_30799045_0": {"section_id": 5427, "quality": 1.0, "length": 7}, "so_30798661_30798885_1": {"section_id": 5427, "quality": 1.0, "length": 7}, "so_30798661_30798774_0": {"section_id": 5430, "quality": 0.775, "length": 31}, "so_30798661_30799045_1": {"section_id": 5430, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_30798661_30798876_2": {"section_id": 5222, "quality": 1.0, "length": 7}, "so_30798661_30798876_3": {"section_id": 5225, "quality": 0.625, "length": 25}, "so_30798661_30798876_0": {"section_id": 5222, "quality": 1.0, "length": 11}, "so_30798661_30799045_0": {"section_id": 5222, "quality": 1.0, "length": 7}, "so_30798661_30798885_1": {"section_id": 5222, "quality": 1.0, "length": 7}, "so_30798661_30798774_0": {"section_id": 5225, "quality": 0.625, "length": 25}}, "n4659": {"so_30798661_30798774_0": {"section_id": 6858, "quality": 0.775, "length": 31}, "so_30798661_30798876_3": {"section_id": 6858, "quality": 0.775, "length": 31}, "so_30798661_30798876_0": {"section_id": 6855, "quality": 0.8181818181818182, "length": 9}, "so_30798661_30799045_0": {"section_id": 6855, "quality": 1.0, "length": 7}, "so_30798661_30798885_1": {"section_id": 6855, "quality": 1.0, "length": 7}, "so_30798661_30798876_2": {"section_id": 6855, "quality": 1.0, "length": 7}, "so_30798661_30799045_1": {"section_id": 6858, "quality": 0.9166666666666666, "length": 11}}}});