post_cb({"38415914": {"CommentCount": "6", "AcceptedAnswerId": "38416985", "PostTypeId": "1", "LastEditorUserId": "440403", "CreationDate": "2016-07-16T21:42:31.620", "LastActivityDate": "2016-07-17T01:45:20.637", "LastEditDate": "2016-07-17T01:10:36.453", "ViewCount": "203", "FavoriteCount": "2", "Title": "Should items with duplicate keys in unordered_multimap be kept in the order of their insertion?", "Id": "38415914", "Score": "2", "Body": "<p>One book mentioned that for <code>std::unordered_multimap</code>:</p>\n<blockquote>\n<p id=\"so_38415914_38415914_0\">The order of the elements is undefined. The only guarantee is that\n  duplicates, which are possible because a multiset is used, are grouped\n  together in the order of their insertion.</p>\n</blockquote>\n<p>But from the output of the example below, we can see that the print order is reverse from their insertion.</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n\nint main()\n{\n    std::unordered_multimap&lt;int, std::string&gt; um;\n    um.insert( {1,\"hello1.1\"} );\n    um.insert( {1,\"hello1.2\"} );\n    um.insert( {1,\"hello1.3\"} );\n\n    for (auto &amp;a: um){\n        cout &lt;&lt; a.first &lt;&lt; '\\t' &lt;&lt; a.second &lt;&lt; endl;\n    }\n}\n</code></pre>\n<p>Which when compiled and run produces this output (g++ 5.4.0):</p>\n<pre><code>1   hello1.3  \n1   hello1.2  \n1   hello1.1  \n</code></pre>\n<p><strong>updated:</strong> unordered_multiset has the same issue:</p>\n<pre><code>auto cmp = [](const pair&lt;int,string&gt; &amp;p1, const pair&lt;int,string&gt; &amp;p2)\n            {return p1.first == p2.first;};\nauto hs = [](const pair&lt;int,string&gt; &amp;p1){return std::hash&lt;int&gt;()(p1.first);};\n\nunordered_multiset&lt;pair&lt;int, string&gt;, decltype(hs), decltype(cmp)&gt; us(0, hs, cmp);\nus.insert({1,\"hello1.1\"});\nus.insert({1,\"hello1.2\"});\nus.insert({1,\"hello1.3\"});\n\nfor(auto &amp;a:us){\n    cout&lt;&lt;a.first&lt;&lt;\"\\t\"&lt;&lt;a.second&lt;&lt;endl;\n}\n</code></pre>\n<p>output:</p>\n<pre><code>1   hello1.3\n1   hello1.2\n1   hello1.1\n</code></pre>\n", "Tags": "<c++><c++11><c++-standard-library><unordered-multimap>", "OwnerUserId": "440403", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_38415914_38416985_0": {"section_id": 758, "quality": 0.9795918367346939, "length": 48}}, "n3337": {"so_38415914_38416985_0": {"section_id": 746, "quality": 0.9795918367346939, "length": 48}}, "n4659": {"so_38415914_38416985_0": {"section_id": 818, "quality": 0.9591836734693877, "length": 47}}}, "38416985": {"ParentId": "38415914", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2016-07-17T00:56:55.897", "Score": "3", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:32:37.620", "Id": "38416985", "OwnerUserId": "2079303", "Body": "<p>Here is what the standard says of the ordering <a href=\"http://eel.is/c++draft/unord.req\" rel=\"nofollow noreferrer\">[unord.req] / \u00a76</a>:</p>\n<blockquote>\n<p id=\"so_38415914_38416985_0\">...  In containers that support equivalent keys, elements with equivalent keys are adjacent to each other in the iteration order of the container. Thus, although the absolute order of elements in an unordered container is not specified, its elements are grouped into equivalent-key groups such that all elements of each group have equivalent keys. Mutating operations on unordered containers shall preserve the relative order of elements within each equivalent-key group unless otherwise specified.</p>\n</blockquote>\n<p>So, to answer the question:</p>\n<blockquote>\n<p id=\"so_38415914_38416985_1\">Should items with duplicate keys in unordered_multimap be kept in the order of their insertion?</p>\n</blockquote>\n<p>No, there is no such requirement, or guarantee. If the book makes such claim about the standard, then it is not correct. If the book describes a particular implementation of <code>std::unordered_multimap</code>, then the description could be true for that implementation.</p>\n<hr>\n<p>The requirements of the standard make an implementation using open addressing impractical. Therefore, compliant implementations typically use separate chaining of hash collisions, see <a href=\"https://stackoverflow.com/questions/21518704/how-does-c-stl-unordered-map-resolve-collisions\">How does C++ STL unordered_map resolve collisions?</a></p>\n<p>Because equivalent keys - which necessarily collide - are (in practice, not explicitly required to be) stored in a separate linked list, the most efficient way to insert them, is in order of insertion (push_back) or in reverse (push_front). Only the latter is efficient if the separate chain is singly linked.</p>\n</hr>", "LastActivityDate": "2016-07-17T01:45:20.637"}});