post_cb({"28167167": {"ParentId": "28167166", "CommentCount": "0", "Body": "<p>The cleanest option that comes to mind is templates:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;typename T&gt;\nT foo() {\n    return 0;\n}\n\nint main() {\n    long a = foo&lt;long&gt;();\n    cout &lt;&lt; sizeof a &lt;&lt; \" bytes with value \" &lt;&lt; a &lt;&lt; endl;\n\n    int b = foo&lt;int&gt;();\n    cout &lt;&lt; sizeof b &lt;&lt; \" bytes with value \" &lt;&lt; b &lt;&lt; endl;\n\n    short c = foo&lt;short&gt;();\n    cout &lt;&lt; sizeof c &lt;&lt; \" bytes with value \" &lt;&lt; c &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>In ideone.com this outputs:</p>\n<pre><code>4 bytes with value 0\n4 bytes with value 0\n2 bytes with value 0\n</code></pre>\n<p>Hopefully this is what you needed.</p>\n<hr>\n<p>If for some reason you really need to pass an actual function around, I would recommend looking into std::function and trying to write some template code using that.</p>\n</hr>", "OwnerUserId": "2727470", "Id": "28167167", "PostTypeId": "2", "OwnerDisplayName": "Ixrec", "Score": "-1", "CreationDate": "2015-01-23T23:05:05.410", "LastActivityDate": "2015-01-23T23:05:05.410"}, "28167168": {"ParentId": "28167166", "CommentCount": "3", "Body": "<p>No, you can't do that in a statically typed language unless your types all have a common super type, and C++ doesn't have that for primitives.  You would need to box them into an object, then have the function return the object.  </p>\n<p>However, if you did that, you may as well just keep an object pointer around and use that instead of a function pointer, especially since it's going to make it easier to actually do something useful with the result without doing casts all over the place.</p>\n<p>For example, in a calculator I wrote in Java, I wanted to work with BigInteger fractions as much as possible to preserve precision, but fallback to doubles for operations that returned irrational numbers.  I created a <code>Result</code> interface, with <code>BigFractionResult</code> and <code>DoubleResult</code> implementations.  The UI code would call things like <code>Result sum = firstOperand.add(otherOperand)</code> and didn't have to care which implementation of <code>add</code> it was using.</p>\n", "OwnerUserId": "389146", "Id": "28167168", "PostTypeId": "2", "OwnerDisplayName": "Karl Bielefeldt", "Score": "0", "CreationDate": "2015-01-24T02:17:46.267", "LastActivityDate": "2015-01-24T02:17:46.267"}, "28167166": {"CommentCount": "7", "ViewCount": "124", "PostTypeId": "1", "LastEditorUserId": "988175", "CreationDate": "2015-01-23T22:40:33.627", "LastActivityDate": "2015-01-31T17:53:10.287", "Title": "How can set different function signature to the same function pointer?", "OwnerDisplayName": "Raffaello", "LastEditDate": "2015-01-31T17:53:10.287", "Id": "28167166", "Score": "1", "Body": "<p>How can I set a function pointer depending on some condition to functions with different signature?</p>\n<p><strong>Example:</strong></p>\n<pre><code>short int A() \n{\n    return 0;\n}\n\nlong int B()\n{\n    return 0;\n}\n\nvoid main()\n{\n   std::function&lt;short int()&gt; f = A;\n   f();\n   if(true)\n   {\n      //error\n      f = B;\n   }\n}\n</code></pre>\n<p>How can use the same function pointer for two functions with different signature?\nIs it possible?</p>\n<p>If is not, there is an efficient way to call the appropriate function depending on behavior instead of use a variable and split the whole code with if statements?</p>\n<p><strong>EDIT / EXPANSION (\"2nd case\")</strong> </p>\n<pre><code>#include &lt;SDL.h&gt;\n\nclass Obj { //whatever ...}\n\nclass A \n{\nprivate:\n    Uint16 ret16() { return SDL_ReadLE16(_pFile); }\n    Uint32 ret32() { return SDL_ReadLE32(_pFile); }\n    _pFile = nullptr;\npublic:\n    Obj* func() \n    {\n        Obj obj = new Obj();\n        _pFile = SDL_RWFromFile(\"filename.bin\",\"r\"));\n        auto ret = std::mem_fn(&amp;SHPfile::ret16); \n        if(true)\n        {\n            ret = std::mem_fn(&amp;SHPfile::ret32);          \n        }\n\n        //ret();\n        // continue whatever\n        // ....\n        SDL_RWclose(_pFile);\n        return *obj;\n    }\n}\n</code></pre>\n<p>I have a compilation error on a similar case using the <code>Uint16</code> and <code>Uint32</code> variable of <code>SDL 2</code> library, using <code>std::mem_fn</code></p>\n<p>the compiler give me this error (relative to my code, but it's implemented in a way like the above example):</p>\n<pre><code>error: no match for \u2018operator=\u2019 (operand types are \u2018std::_Mem_fn&lt;short unsigned int (IO::File::*)()&gt;\u2019 and \u2018std::_Mem_fn&lt;unsigned int (IO::File::*)()&gt;\u2019)\n</code></pre>\n<p>To resolve this compilation error, I forced both the function to return a <code>int</code> type.</p>\n<p>Is there a better way? </p>\n<p>Or I did something wrong?</p>\n", "Tags": "<function><pointers><c++11><sdl-2>", "OwnerUserId": "988175", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_28167166_28167455_4": {"section_id": 4651, "quality": 0.8333333333333334, "length": 15}}, "n3337": {"so_28167166_28167455_4": {"section_id": 4462, "quality": 0.8333333333333334, "length": 15}, "so_28167166_28167455_2": {"section_id": 4470, "quality": 0.8, "length": 12}}, "n4659": {"so_28167166_28167455_4": {"section_id": 6020, "quality": 0.7777777777777778, "length": 14}}}, "28167455": {"ParentId": "28167166", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The comments already say that clang accepts the code as is, and I can now say that GCC 4.8.4 and GCC 4.9.2 both accept it as well, after fixing <code>void main()</code> to say <code>int main()</code>.</p>\n<p>This use of <code>std::function</code> is perfectly valid. The C++11 standard says:</p>\n<blockquote>\n<p id=\"so_28167166_28167455_0\"><strong>20.8.11.2 Class template function [func.wrap.func]</strong></p>\n<pre><code>function&amp; operator=(const function&amp;);\nfunction&amp; operator=(function&amp;&amp;);\nfunction&amp; operator=(nullptr_t);\n</code></pre>\n</blockquote>\n<p>There is no template assignment operator here, so assignment of <code>B</code> could only construct a new temporary <code>function&lt;short int()&gt;</code> object, and move-assign from that. To determine whether the construction of that temporary is possible:</p>\n<blockquote>\n<p id=\"so_28167166_28167455_1\"><strong>20.8.11.2.1 function construct/copy/destroy [func.wrap.func.con]</strong></p>\n<pre><code>template&lt;class F&gt; function(F f);\ntemplate &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);\n</code></pre>\n<p id=\"so_28167166_28167455_2\">7 <em>Requires:</em> <code>F</code> shall be <code>CopyConstructible</code>. <code>f</code> shall be <code>Callable</code> (20.8.11.2) for argument types <code>ArgTypes</code> and return type <code>R</code>. The copy constructor and destructor of <code>A</code> shall not throw exceptions.</p>\n<p id=\"so_28167166_28167455_3\"><strong>20.8.11.2 Class template function [func.wrap.func]</strong></p>\n<p id=\"so_28167166_28167455_4\">2 A callable object <code>f</code> of type <code>F</code> is <code>Callable</code> for argument types <code>ArgTypes</code> and return type <code>R</code> if the expression <em><code>INVOKE</code></em><code>(f, declval&lt;ArgTypes&gt;()..., R)</code>, considered as an unevaluated operand (Clause 5), is well formed (20.8.2).</p>\n<p id=\"so_28167166_28167455_5\"><strong>20.8.2 Requirements [func.require]</strong></p>\n<p id=\"so_28167166_28167455_6\">2 Define <em><code>INVOKE</code></em><code>(f, t1, t2, ..., tN, R)</code> as <em><code>INVOKE</code></em><code>(f, t1, t2, ..., tN)</code> implicitly converted to <code>R</code>.</p>\n<p id=\"so_28167166_28167455_7\">1 Define <em><code>INVOKE</code></em><code>(f, t1, t2, ..., tN)</code> as follows:</p>\n<ul>\n<li>... <em>(all related to pointer-to-member types)</em></li>\n<li><code>f(t1, t2, ..., tN)</code> in all other cases.</li>\n</ul>\n</blockquote>\n<p>In short, this means that <code>std::function&lt;short int()&gt;</code> can be used with any function that can be called with no arguments, and which has a return type that can be implicitly converted to <code>short</code>. <code>long</code> clearly can be implicitly converted to <code>short</code>, so there is no problem whatsoever.</p>\n<p>If your compiler's library doesn't accept it, and you cannot upgrade to a more recent version, one alternative is to try <code>boost::function</code> instead.</p>\n<p>Aaron McDaid points out lambdas as another alternative: if your library's <code>std::function</code> is lacking, you can write</p>\n<pre><code>std::function&lt;short int()&gt; f = A;\nf = []() -&gt; short int { return B(); };\n</code></pre>\n<p>but if you take this route, you can take it a step further and avoid <code>std::function</code> altogether:</p>\n<pre><code>short int (*f)() = A;\nf = []() -&gt; short int { return B(); };\n</code></pre>\n<p>This works because lambas that don't capture anything are implicitly convertible to a pointer-to-function type that matches the lambda's arguments and return type. Effectively, it's short for writing</p>\n<pre><code>short int B_wrapper() { return B(); }\n...\nf = B_wrapper;\n</code></pre>\n<p>Note: the conversion from <code>long</code> to <code>short</code> may lose data. If you want to avoid that, you can use <code>std::function&lt;long int()&gt;</code> or <code>long int (*)()</code> instead.</p>\n", "OwnerUserId": "743382", "LastEditorUserId": "743382", "LastEditDate": "2015-01-27T10:51:38.450", "Id": "28167455", "Score": "4", "CreationDate": "2015-01-27T09:50:06.833", "LastActivityDate": "2015-01-27T10:51:38.450"}});