post_cb({"bq_ids": {"n4140": {"so_20397165_20397398_3": {"length": 20, "quality": 0.8333333333333334, "section_id": 3345}, "so_20397165_20397398_2": {"length": 58, "quality": 0.9354838709677419, "section_id": 3344}, "so_20397165_20397398_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 3383}}, "n3337": {"so_20397165_20397398_3": {"length": 21, "quality": 0.875, "section_id": 3215}, "so_20397165_20397398_2": {"length": 58, "quality": 0.9354838709677419, "section_id": 3214}, "so_20397165_20397398_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 3252}}, "n4659": {"so_20397165_20397398_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 4143}}}, "20397165": {"ViewCount": "383", "Body": "<p>I have a code such as this:</p>\n<pre><code>class myclass\n{\n     myclass()\n     {\n        // doing some init here\n      }\n     ~myclass()\n     {\n        // doing some important clean up here\n     }\n     void Do()\n     {\n          //    doing some work which may throw exception\n      }\n}\n</code></pre>\n<p>and I am using this class in this way:</p>\n<pre><code>MyFunction()\n{\n    myclass mc;\n    mc.do();\n }\n</code></pre>\n<p>My question is :</p>\n<p>If there is an exception in do function, what would happen? Is destructor of myclass called?</p>\n<p>If no, what is the best way to handle this type of situations? Assume that I don't have the source code and I am sure about what is happening in destructor.</p>\n", "AcceptedAnswerId": "20397398", "Title": "cleaning up after an exception", "CreationDate": "2013-12-05T10:14:09.633", "Id": "20397165", "CommentCount": "6", "PostTypeId": "1", "ClosedDate": "2013-12-05T13:45:17.973", "LastActivityDate": "2013-12-05T10:39:46.483", "Score": "2", "OwnerUserId": "654019", "Tags": "<c++><exception>", "AnswerCount": "3"}, "20397398": {"Id": "20397398", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_20397165_20397398_0\">If there is an exception in do function, what would happen?</p>\n</blockquote>\n<p>If you have any handler, it will be handled.</p>\n<blockquote>\n<p id=\"so_20397165_20397398_1\">Is destructor of myclass called?</p>\n</blockquote>\n<p>Yes, definitely. The standard quotes this::</p>\n<blockquote>\n<p id=\"so_20397165_20397398_2\">An object of any storage duration whose initialization or destruction\n  is terminated by an exception will have destructors executed for all\n  of its fully constructed subobjects (excluding the variant members of\n  a union-like class), that is, for subobjects for which the principal\n  constructor (12.6.2) has completed execution and the destructor has\n  not yet begun execution. Similarly, if the non-delegating constructor\n  for an object has completed execution and a delegating constructor for\n  that object exits with an exception, the object\u2019s destructor will be\n  invoked. If the object was allocated in a new-expression, the matching\n  deallocation function (3.7.4.2, 5.3.4, 12.5), if any, is called to\n  free the storage occupied by the object.</p>\n</blockquote>\n<p>This whole process is known as \"stack unwinding\":</p>\n<blockquote>\n<p id=\"so_20397165_20397398_3\">The process of calling destructors for automatic objects constructed\n  on the path from a try block to a throw-expression is called \u201cstack\n  unwinding.\u201d If a destructor called during stack unwinding exits with\n  an exception, std::terminate is called (15.5.1).</p>\n<p id=\"so_20397165_20397398_4\">C++11 15.5.1 The std::terminate() function [except.terminate]</p>\n<p id=\"so_20397165_20397398_5\">2 \u2026 In the situation where no matching handler is found, it is\n  implementation-defined whether or not the stack is unwound before\n  std::terminate() is called.</p>\n</blockquote>\n", "LastEditorUserId": "1182192", "LastActivityDate": "2013-12-05T10:39:46.483", "Score": "5", "CreationDate": "2013-12-05T10:25:34.750", "ParentId": "20397165", "CommentCount": "0", "OwnerUserId": "1182192", "LastEditDate": "2013-12-05T10:39:46.483"}, "20397417": {"Id": "20397417", "PostTypeId": "2", "Body": "<p>If the exception is caught somewhere, then <em>stack unwinding</em> will guarantee that the destructor is called for this object (and, in general, all automatic variables that go out of scope as a result of the exception). This is a very important guarantee, without which we could not use techniques like <a href=\"http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\" rel=\"nofollow\">RAII</a> to write exception-safe code.</p>\n<p>If the exception is not caught, then the program will be terminated, and it's implementation-dependent whether or not the stack will be unwound first. If it's important to destroy the object cleanly even in that situation, then one option is to catch and rethrow the exception, outside the object's scope.</p>\n<p>If the program is ended in some other way, e.g. by calling <code>exit()</code> or <code>terminate()</code>, or receiving an unhandled signal, then the stack won't be unwound. If you need clean destruction in these situations, then things will get messy.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2013-12-05T10:35:33.233", "Score": "3", "CreationDate": "2013-12-05T10:26:31.443", "ParentId": "20397165", "CommentCount": "0", "OwnerUserId": "204847", "LastEditDate": "2013-12-05T10:35:33.233"}, "20397490": {"Id": "20397490", "PostTypeId": "2", "Body": "<p>C++ does not have explicit \"finally\" clauses like many other languages, but instead you rely in \"RAII\" which essentially is a technique of using scoped \"automatic\" variables and relying on the fact that their destructor will get called at the appropriate moment when they go out of scope.</p>\n<p>In your case the destructor of myclass will be called even if <code>mc.do()</code> throws an exception. In a lot of these \"closure\" issues, the object you put at the top of the scope block is a class that is used only for the purpose of invoking the destructor on termination.</p>\n<p>The \"D\" language comes with a special closure syntax. There have been attempts to write libraries that do that in C++ and with lambdas it is certainly easier to write than now than it used to be although I do not think they are a formal part of C++ as yet.</p>\n", "LastActivityDate": "2013-12-05T10:28:43.080", "CommentCount": "0", "CreationDate": "2013-12-05T10:28:43.080", "ParentId": "20397165", "Score": "0", "OwnerUserId": "442284"}});