post_cb({"37425307": {"ViewCount": "313", "Body": "<p>I get different behavior when trying to overload function and function template. For function:</p>\n<pre><code>void foo(int)\n{\n    std::cout &lt;&lt; \"int\";\n}\n\nvoid foo(char)\n{\n    std::cout &lt;&lt; \"char\";\n}\n</code></pre>\n<p><code>foo(42)</code> is <code>int</code>. But for function template:</p>\n<pre><code>template &lt;int T&gt;\nvoid bar()\n{\n    std::cout &lt;&lt; \"int T\";\n}\n\ntemplate &lt;char T&gt;\nvoid bar()\n{\n    std::cout &lt;&lt; \"char T\";\n}\n</code></pre>\n<p><code>bar&lt;42&gt;()</code> is ambiguous call. This happens even if I use a char, like <code>bar&lt;'a'&gt;()</code>. Why does one work and not the other?</p>\n", "Title": "Function template overloading difference", "CreationDate": "2016-05-24T23:04:47.127", "LastActivityDate": "2016-05-25T23:40:54.130", "CommentCount": "8", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-05-25T01:08:16.043", "LastEditorUserId": "315052", "Id": "37425307", "ClosedDate": "2016-05-25T18:30:09.110", "Score": "16", "OwnerUserId": "6378568", "Tags": "<c++><language-lawyer>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_37425307_37425433_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 301}}, "n3337": {"so_37425307_37425433_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 292}}}, "37425433": {"Id": "37425433", "PostTypeId": "2", "Body": "<p>The standard <strong>N4140</strong> (credit goes to <strong>M.M</strong>) gives this explanation and sample in <strong>14.8.2 Template argument deduction</strong>:</p>\n<blockquote>\n<p id=\"so_37425307_37425433_0\"><sup>9</sup> Except as described above, the use of an invalid value shall not cause type deduction to fail. [<em>Example:</em>\n  In the following example 1000 is converted to <code>signed char</code> and results in an implementation-defined value\n  as specified in (4.7). In other words, both templates are considered even though 1000, when converted to\n  signed char, results in an implementation-defined value.</p>\n<pre><code>template &lt;int&gt; int f(int);\ntemplate &lt;signed char&gt; int f(int);\nint i1 = f&lt;1&gt;(0);    // ambiguous\nint i2 = f&lt;1000&gt;(0); // ambiguous\n</code></pre>\n<p id=\"so_37425307_37425433_1\">\u2014 <em>end example</em> ]</p>\n</blockquote>\n<p>However, note that in following drafts the rules are changed <a href=\"http://wg21.cmeerw.net/cwg/issue1809\" rel=\"nofollow noreferrer\">because</a>:</p>\n<blockquote>\n<p id=\"so_37425307_37425433_2\">This is no longer correct, even ignoring the fact that some implementations may be able to represent the value 1000 as a <code>signed char</code>: integral and enumeration non-type template arguments are now converted constant expressions (14.3.2 [temp.arg.nontype] paragraph 1), and converted constant expressions disallow narrowing conversions (5.20 [expr.const] paragraph 3).</p>\n</blockquote>\n<p>The proposed sample is:</p>\n<blockquote id=\"so_37425307_37425433_3\">\n<pre><code>template &lt;int&gt; int f(int);\ntemplate &lt;signed char&gt; int f(int);\n\nint i1 = f&lt;1000&gt;(0); // OK\nint i2 = f&lt;1&gt;(0);    // ambiguous; not narrowing\n</code></pre>\n</blockquote>\n", "LastEditorUserId": "3246555", "LastActivityDate": "2016-05-25T23:40:54.130", "CommentCount": "12", "CreationDate": "2016-05-24T23:18:39.513", "ParentId": "37425307", "Score": "7", "OwnerUserId": "3246555", "LastEditDate": "2016-05-25T23:40:54.130"}, "37425834": {"PostTypeId": "2", "Body": "<p>There's a difference between how overloads and specializations are chosen. Overload resolution <a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution\" rel=\"nofollow\">ranks implicit conversions</a>. No conversion is required to convert <code>42</code> to <code>int</code>, so it is an <strong>Exact Match</strong>, which beats the implicit conversion required for <code>42</code> to <code>char</code>.</p>\n<p>On the other hand, function template specialization \"overloading\" uses <a href=\"http://eel.is/c++draft/temp.deduct.partial\" rel=\"nofollow\">partial ordering rules</a>, which uses template argument deduction to determine which is more \"specialized\" than the other. Without going into too much detail, deduction doesn't fail for either <code>int</code> or <code>char</code> with a value of <code>42</code>, so they're both equally specialized. If you were to use a value outside the range of an signed char, i.e <code>128</code>, deduction would fail and the <code>int</code> specialization would be chosen.</p>\n", "LastActivityDate": "2016-05-25T00:03:23.853", "Id": "37425834", "CommentCount": "2", "CreationDate": "2016-05-25T00:03:23.853", "ParentId": "37425307", "Score": "3", "OwnerUserId": "6292850"}, "37425762": {"Id": "37425762", "PostTypeId": "2", "Body": "<p>According to this <a href=\"http://www.gotw.ca/publications/mill17.htm\" rel=\"nofollow\">website</a>, which has a very good examples and explanation, \"<em>function template specializations don't overload</em>.\" Which is why you are receiving <code>call to 'bar' is ambiguous</code>.</p>\n", "LastEditorUserId": "4513509", "LastActivityDate": "2016-05-25T05:03:42.817", "CommentCount": "0", "CreationDate": "2016-05-24T23:54:18.177", "ParentId": "37425307", "Score": "1", "OwnerUserId": "4513509", "LastEditDate": "2016-05-25T05:03:42.817"}});