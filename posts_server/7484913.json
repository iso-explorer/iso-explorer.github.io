post_cb({"7484984": {"Id": "7484984", "PostTypeId": "2", "Body": "<p><code>static_cast</code> is a compile time construct. it checks for the validity of cast at compile time and gives an compilation error if invalid cast.  </p>\n<p><code>virtual</code>ism is a runtime phenomenon. </p>\n<p>Both can't go together.</p>\n<p>C++03 Standard \u00a75.2.9/2 and \u00a75.2.9/9 ar relevant in this case.  </p>\n<blockquote>\n<p id=\"so_7484913_7484984_0\">An rvalue of type \u201cpointer to cv1 B\u201d, where B is a class type, can be converted to an rvalue of type \u201cpointer to cv2 D\u201d, where D is a class derived (clause 10) from B, if a valid standard conversion from \u201cpointer to D\u201d to \u201cpointer to B\u201d exists (4.10), cv2 is the same cv-qualification as, or greater cv-qualification than, cv1, <strong>and B is not a virtual base class of D</strong>. The null pointer value (4.10) is converted to the null pointer value of the destination type. If the rvalue of type \u201cpointer to cv1 B\u201d points to a B that is actually a sub-object of an object of type D, the resulting pointer points to the enclosing object of type D. Otherwise, the result of the cast is undefined.</p>\n</blockquote>\n", "LastEditorUserId": "452307", "LastActivityDate": "2011-09-20T12:23:00.127", "Score": "1", "CreationDate": "2011-09-20T12:15:44.930", "ParentId": "7484913", "CommentCount": "10", "OwnerUserId": "452307", "LastEditDate": "2011-09-20T12:23:00.127"}, "7485495": {"Id": "7485495", "PostTypeId": "2", "Body": "<p>Fundamentally, there's no real reason, but the intention is that\n<code>static_cast</code> be very cheap, involving at most an addition or a\nsubtraction of a constant to the pointer.  And there's no way to\nimplement the cast you want that cheaply; basically, because the\nrelative positions of <code>Derived</code> and <code>Base</code> within the object may change\nif there is additional inheritance, the conversion would require a good\ndeal of the overhead of <code>dynamic_cast</code>; the members of the committee\nprobably thought that this defeats the reasons for using <code>static_cast</code>\ninstead of <code>dynamic_cast</code>. </p>\n", "LastActivityDate": "2011-09-20T12:55:10.353", "CommentCount": "5", "CreationDate": "2011-09-20T12:55:10.353", "ParentId": "7484913", "Score": "2", "OwnerUserId": "649665"}, "7485120": {"Id": "7485120", "PostTypeId": "2", "Body": "<p>I suppose, this is due to classes with virtual inheritance having different memory layout. The parent has to be shared between children, therefore only one of them could be laid out continuously. That means, you are not guaranteed to be able to separate a continuous area of memory to treat it as a derived object.</p>\n", "LastEditorUserId": "486820", "LastActivityDate": "2011-09-20T12:53:55.333", "Score": "1", "CreationDate": "2011-09-20T12:26:52.423", "ParentId": "7484913", "CommentCount": "0", "OwnerUserId": "486820", "LastEditDate": "2011-09-20T12:53:55.333"}, "7484913": {"ViewCount": "11531", "Body": "<p>Consider the following code:</p>\n<pre><code>struct Base {};\nstruct Derived : public virtual Base {};\n\nvoid f()\n{\n    Base* b = new Derived;\n    Derived* d = static_cast&lt;Derived*&gt;(b);\n}\n</code></pre>\n<p>This is prohibited by the standard (<code>[n3290: 5.2.9/2]</code>) so the code does not compile, because <code>Derived</code> <em>virtually</em> inherits from <code>Base</code>. Removing the <code>virtual</code> from the inheritance makes the code valid.</p>\n<p>What's the technical reason for this rule to exist?</p>\n", "AcceptedAnswerId": "7485177", "Title": "Why can't static_cast be used to down-cast when virtual inheritance is involved?", "CreationDate": "2011-09-20T12:10:12.453", "Id": "7484913", "CommentCount": "1", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2011-09-20T12:44:03.597", "LastEditorUserId": "560648", "LastActivityDate": "2017-06-09T21:30:31.577", "Score": "30", "OwnerUserId": "26039", "Tags": "<c++><virtual-inheritance><downcasting><static-cast>", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_7484913_7484984_0": {"length": 54, "quality": 0.8571428571428571, "section_id": 6037}}, "n3337": {"so_7484913_7484984_0": {"length": 56, "quality": 0.8888888888888888, "section_id": 5805}}, "n4659": {"so_7484913_7484984_0": {"length": 49, "quality": 0.7777777777777778, "section_id": 7536}}}, "44466962": {"Id": "44466962", "PostTypeId": "2", "Body": "<p><code>static_cast</code> can perform only those casts where memory layout between the classes is known at compile-time. <code>dynamic_cast</code> can check information at run-time, which allows to more accurately check for cast correctness, as well as read run-time information regarding the memory layout.</p>\n<p>Virtual inheritance puts a run-time information into each object which specifies what is the memory layout between the <code>Base</code> and <code>Derived</code>. Is one right after another or is there an additional gap? Because <code>static_cast</code> cannot access such information, the compiler will act conservatively and just give a compiler error.</p>\n<hr>\n<p><strong>In more detail:</strong></p>\n<p>Consider a complex inheritance structure, where - due to multiple inheritance - there are multiple copies of <code>Base</code>. The most typical scenario is a diamond inheritance:</p>\n<pre><code>class Base {...};\nclass Left : public Base {...};\nclass Right : public Base {...};\nclass Bottom : public Left, public Right {...};\n</code></pre>\n<p>In this scenario <code>Bottom</code> consists of <code>Left</code> and <code>Right</code>, where <em>each</em> has its own copy of <code>Base</code>. The memory structure of all the above classes is known at compile time and <code>static_cast</code> can be used without a problem.</p>\n<p>Let us now consider the similar structure but with virtual inheritance of <code>Base</code>:</p>\n<pre><code>class Base {...};\nclass Left : public virtual Base {...};\nclass Right : public virtual Base {...};\nclass Bottom : public Left, public Right {...};\n</code></pre>\n<p>Using the virtual inheritance ensures that when <code>Bottom</code> is created, it contains only <em>one</em> copy of <code>Base</code> that is <em>shared</em> between object parts <code>Left</code> and <code>Right</code>. The layout of <code>Bottom</code> object can be for example:</p>\n<pre><code>Base part\nLeft part\nRight part\nBottom part\n</code></pre>\n<p>Now, consider that you cast <code>Bottom</code> to <code>Right</code> (that is a valid cast). You obtain a <code>Right</code> pointer to an object that is in two pieces: <code>Base</code> and <code>Right</code> have a memory gap in between, containing the (now-irrelevant) <code>Left</code> part. The information about this gap is stored at run-time in a hidden field of <code>Right</code> (typically referred to as <code>vbase_offset</code>). You can read the details for example <a href=\"https://ww2.ii.uj.edu.pl/~kapela/pn/cpp_vtable.html\" rel=\"nofollow noreferrer\">here</a>.</p>\n<p>However, the gap would not exist if you would just create a standalone <code>Right</code> object.</p>\n<p>So, if I give you just a pointer to <code>Right</code> you do not know at compile time if it is a standalone object, or a part of something bigger (e.g. <code>Bottom</code>). You need to check the run-time information to properly cast from <code>Right</code> to <code>Base</code>. That is why <code>static_cast</code> will fail and <code>dynamic_cast</code> will not.</p>\n<hr>\n<p><strong>Note on dynamic_cast:</strong></p>\n<p>While <code>static_cast</code> does not use run-time information about the object, <code>dynamic_cast</code> uses and <em>requires</em> it to exist! Thus, the latter cast can be used only on those classes which contain at least one virtual function (e.g. a virtual destructor)</p>\n</hr></hr>", "LastActivityDate": "2017-06-09T21:30:31.577", "CommentCount": "0", "CreationDate": "2017-06-09T21:30:31.577", "ParentId": "7484913", "Score": "0", "OwnerUserId": "635654"}, "7485407": {"Id": "7485407", "PostTypeId": "2", "Body": "<p>Consider the following function <code>foo</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    int Ax;\n};\n\nstruct B : virtual A\n{\n    int Bx;\n};\n\nstruct C : B, virtual A\n{\n    int Cx;\n};\n\n\nvoid foo( const B&amp; b )\n{\n    const B* pb = &amp;b;\n    const A* pa = &amp;b;\n\n    std::cout &lt;&lt; (void*)pb &lt;&lt; \", \" &lt;&lt; (void*)pa &lt;&lt; \"\\n\";\n\n    const char* ca = reinterpret_cast&lt;const char*&gt;(pa);\n    const char* cb = reinterpret_cast&lt;const char*&gt;(pb);\n\n    std::cout &lt;&lt; \"diff \" &lt;&lt; (cb-ca) &lt;&lt; \"\\n\";\n}\n\nint main(int argc, const char *argv[])\n{\n    C c;\n    foo(c);\n\n    B b;\n    foo(b);\n}\n</code></pre>\n<p>Although not really portable, this function shows us the \"offset\" of A and B. Since the compiler can be quite liberal in placing the A subobject in case of inheritance (also remember that the most derived object calls the virtual base ctor!), the actual placement depends on the \"real\" type of the object. But since foo only gets a ref to B, any static_cast (which works at compile time by at most applying some offset) is bound to fail.</p>\n<p>ideone.com (http://ideone.com/2qzQu) outputs for this:</p>\n<pre><code>0xbfa64ab4, 0xbfa64ac0\ndiff -12\n0xbfa64ac4, 0xbfa64acc\ndiff -8\n</code></pre>\n", "LastActivityDate": "2011-09-20T12:48:53.743", "CommentCount": "0", "CreationDate": "2011-09-20T12:48:53.743", "ParentId": "7484913", "Score": "2", "OwnerUserId": "833362"}, "7485177": {"Id": "7485177", "PostTypeId": "2", "Body": "<p>The technical problem is that there's no way to work out from a <code>Base*</code> what the offset is between the start of the <code>Base</code> sub-object and the start of the <code>Derived</code> object. </p>\n<p>In your example it appears OK, because there's only one class in sight with a <code>Base</code> base, and so it appears irrelevant that the inheritance is virtual. But the compiler doesn't know whether someone defined another <code>class Derived2 : public virtual Base, public Derived {}</code>, and is casting a <code>Base*</code> pointing at the <code>Base</code> subobject of that. In general[*], the offset between the <code>Base</code> subobject and the <code>Derived</code> subobject within <code>Derived2</code> might not be the same as the offset between the <code>Base</code> subobject and the complete <code>Derived</code> object of an object whose most-derived type is <code>Derived</code>, precisely because <code>Base</code> is virtually inherited.</p>\n<p>So there's no way to know the dynamic type of the complete object, and different offsets between the pointer you've given the cast, and the required result, depending what that dynamic type is. Hence the cast is impossible.</p>\n<p>Your <code>Base</code> has no virtual functions and hence no RTTI, so there certainly is no way to tell the type of the complete object. The cast is still banned even if <code>Base</code> does have RTTI (I don't immediately know why), but I guess without checking that a <code>dynamic_cast</code> is possible in that case.</p>\n<p>[*] by which I mean, if this example doesn't prove the point then keep adding more virtual inheritance until you find a case where the offsets are different ;-)</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2011-09-20T12:46:02.040", "Score": "31", "CreationDate": "2011-09-20T12:30:05.970", "ParentId": "7484913", "CommentCount": "8", "OwnerUserId": "13005", "LastEditDate": "2011-09-20T12:46:02.040"}});