post_cb({"bq_ids": {"n4140": {"so_21070032_21070985_4": {"length": 9, "quality": 1.0, "section_id": 303}, "so_21070032_21070985_5": {"length": 9, "quality": 1.0, "section_id": 303}, "so_21070032_21070985_3": {"length": 11, "quality": 1.0, "section_id": 303}, "so_21070032_21070985_6": {"length": 6, "quality": 1.0, "section_id": 304}, "so_21070032_21070985_7": {"length": 13, "quality": 1.0, "section_id": 304}, "so_21070032_21070985_2": {"length": 11, "quality": 1.0, "section_id": 303}}, "n3337": {"so_21070032_21070985_4": {"length": 9, "quality": 1.0, "section_id": 294}, "so_21070032_21070985_5": {"length": 9, "quality": 1.0, "section_id": 294}, "so_21070032_21070985_6": {"length": 6, "quality": 1.0, "section_id": 295}, "so_21070032_21070985_3": {"length": 11, "quality": 1.0, "section_id": 294}, "so_21070032_21070985_7": {"length": 13, "quality": 1.0, "section_id": 295}, "so_21070032_21070985_2": {"length": 11, "quality": 1.0, "section_id": 294}}, "n4659": {"so_21070032_21070985_4": {"length": 7, "quality": 0.7777777777777778, "section_id": 310}, "so_21070032_21070985_5": {"length": 7, "quality": 0.7777777777777778, "section_id": 310}, "so_21070032_21070985_6": {"length": 6, "quality": 1.0, "section_id": 311}, "so_21070032_21070985_3": {"length": 11, "quality": 1.0, "section_id": 310}, "so_21070032_21070985_7": {"length": 13, "quality": 1.0, "section_id": 311}, "so_21070032_21070985_2": {"length": 11, "quality": 1.0, "section_id": 310}}}, "21070985": {"Id": "21070985", "PostTypeId": "2", "Body": "<p>dyp is correct and I would like to elaborate.</p>\n<p>First of all, the conclusion is the from dyp:</p>\n<blockquote>\n<p id=\"so_21070032_21070985_0\">The type deduced for <code>auto</code> in the declaration of a variable is defined\n  via the rules of template argument deduction, see [dcl.spec.auto]/6;\n  with one exception: if the initializer is a braced-init-list, the\n  deduced type is a <code>std::initializer_list</code>.</p>\n</blockquote>\n<p>I'll explain.</p>\n<p>First, </p>\n<pre><code>auto s = expr;\n</code></pre>\n<p>This is same as deducing the <code>T</code> from <code>expr</code>,</p>\n<pre><code>template&lt;class T&gt;\nvoid f(T s);\n\nf(expr);\n</code></pre>\n<p>The rule for template argument deduction is quite complicated, since you are only concerning with the lvalue and rvalue stuff, let's focus on this.</p>\n<p>Template argument deduction is by comparing the template parameter type (call it <code>P</code>, in this case <code>P</code> is <code>T</code>), and the corresponding argument (call it <code>A</code>, in this case, the type of <code>expr</code>).</p>\n<p>From 14.8.2.1,</p>\n<blockquote>\n<p id=\"so_21070032_21070985_1\">If P is not a reference type:</p>\n<p id=\"so_21070032_21070985_2\">\u2014 If A is an array type, the pointer type produced by the array-to-pointer standard conversion (4.2) is\n  used in place of A for type deduction; otherwise,</p>\n<p id=\"so_21070032_21070985_3\">\u2014 If A is a function type, the pointer type produced by the function-to-pointer standard conversion (4.3)\n  is used in place of A for type deduction; otherwise,</p>\n<p id=\"so_21070032_21070985_4\">\u2014 If A is a cv-qualified type, the top level cv-qualifiers of A\u2019s type are ignored for type deduction.</p>\n</blockquote>\n<p>So, if <code>expr</code> is array or function, it will be treated as pointers, if expr has cv-qualification (<code>const</code> etc), they will be ignored. </p>\n<blockquote>\n<p id=\"so_21070032_21070985_5\">If <code>P</code> is a cv-qualified type, the top level cv-qualifiers of <code>P</code>\u2019s type are ignored for type deduction.</p>\n</blockquote>\n<p>This actually says:</p>\n<pre><code>const auto s = expr;\n</code></pre>\n<p><code>s</code> is a <code>const</code> variable, but for type deduction for <code>auto</code> purposes, the <code>const</code> will be removed.</p>\n<p>Thus, from the above rules, <code>auto</code> will be deduced to the type of <code>expr</code> (after some type conversion stated above).</p>\n<p>Note that, when an expression is a reference to <code>T</code>, it will be adjusted to <code>T</code> before prior analysis.</p>\n<p>So whatever <code>expr</code> is \u2013 rvalue, lvalue, or lvalue/rvalue ref type \u2013 the type of <code>auto</code> will always be the type of <code>expr</code> without reference.</p>\n<pre><code>auto s1 = 1; //int\nint &amp;x = s1;\nauto s2 = x; //int\nint &amp;&amp;y = 2;\nauto s3 = y; //int\n</code></pre>\n<p>Second, let's look at</p>\n<pre><code>auto &amp;s = expr;\n</code></pre>\n<p>This will be same as</p>\n<pre><code>template&lt;class T&gt;\nvoid f(T &amp;s);\n\nf(expr);\n</code></pre>\n<p>The extra rule from standard is as follows:</p>\n<blockquote>\n<p id=\"so_21070032_21070985_6\">If <code>P</code> is a reference type, the type referred to by <code>P</code> is used for type deduction.</p>\n</blockquote>\n<p>So the deduction of auto will be exactly same as without <code>&amp;</code>, but after the <code>auto</code> type is deducted, the <code>&amp;</code> is added to the end of <code>auto</code>.</p>\n<pre><code>//auto &amp;s1 = 1; //auto is deducted to int, int &amp;s1 = 1, error!\nconst auto &amp;s1 = 1; //auto is deducted to int, const int &amp;s1 = 1; ok!\nconst int &amp;x = s1;\nauto &amp;s2 = x; //auto is int, int &amp;s2 = x; ok!\nint &amp;&amp;y = 2;\nauto &amp;s3 = y; //auto is int, int &amp;s3 = y; ok! \n</code></pre>\n<p>Note that the last <code>y</code> is an lvalue. The rule of C++ is: named rvalue reference is an lvalue.</p>\n<p>Lastly:</p>\n<pre><code>auto &amp;&amp;s = expr;\n</code></pre>\n<p>This is no doubt same as</p>\n<pre><code>template&lt;class T&gt;\nvoid f(T &amp;&amp;s);\n\nf(expr);\n</code></pre>\n<p>One additional rule from standard:</p>\n<blockquote>\n<p id=\"so_21070032_21070985_7\">If <code>P</code> is an rvalue reference to a cv-unqualified template parameter and\n  the argument is an lvalue, the type \u201clvalue reference to A\u201d is used in\n  place of <code>A</code> for type deduction.</p>\n</blockquote>\n<p>This actually says that, if <code>expr</code> is an rvalue, the rule will be same as the second case (lvalue case), but if <code>expr</code> is an lvalue, the type of <code>A</code> will be an lvalue reference to <code>A</code>.</p>\n<p>Note from previous explained, <code>A</code> is never reference, because the type of an expression is never a reference. But for this special case (<code>auto &amp;&amp;</code>, and <code>A</code> is an lvalue), reference to <code>A</code> must be used, regardless <code>expr</code> itself is a reference type or not.</p>\n<p>Example:</p>\n<pre><code>auto &amp;&amp;s1 = 1; //auto is deducted to int, int &amp;&amp;s1 = 1, ok!\nint x = 1;\nauto &amp;&amp;s2 = x; //x is lvalue, so A is int &amp;, auto is deducted to int &amp;, int &amp; &amp;&amp;s2 = x; ok!\nint &amp;&amp;y = 2;\nauto &amp;&amp;s3 = y; //y is lvalue, auto is int &amp;, int &amp; &amp;&amp;s3 = y; ok!\n</code></pre>\n", "LastEditorUserId": "58635", "LastActivityDate": "2017-05-25T12:27:47.117", "Score": "5", "CreationDate": "2014-01-12T03:32:20.250", "ParentId": "21070032", "CommentCount": "3", "OwnerUserId": "534498", "LastEditDate": "2017-05-25T12:27:47.117"}, "21070463": {"Id": "21070463", "PostTypeId": "2", "Body": "<p>Since no one gives an answer and I kinda understand now (thanks to @dyp), I would just post answer myself. Point out error if any:</p>\n<pre><code>auto s = expr;\n</code></pre>\n<p>If <code>expr</code> is lvalue, prvalue, or any reference, <code>s</code> is always a lvalue and a copy is made.</p>\n<pre><code>auto&amp; s = expr;\n</code></pre>\n<p>If <code>expr</code> is lvalue, lvalue reference or rvalue reference, <code>s</code> is lvalue reference.\nIf <code>expr</code> is prvalue, it is an error and not legal.</p>\n<pre><code>auto&amp;&amp; s = expr;\n</code></pre>\n<p><code>s</code> is perfectly forwarded (rvalue would become rvalue reference and collapse).</p>\n", "LastEditorUserId": "1270003", "LastActivityDate": "2014-01-12T02:16:38.277", "Score": "0", "CreationDate": "2014-01-12T02:09:34.793", "ParentId": "21070032", "CommentCount": "0", "OwnerUserId": "1270003", "LastEditDate": "2014-01-12T02:16:38.277"}, "21070032": {"ViewCount": "511", "Body": "<p>I have some cases of use of <code>auto</code>:</p>\n<pre><code>auto s = expr;          //s is always lvalue\nauto &amp; s = expr;        //s is always lvalue reference? What if expr is rvalue?\nauto &amp;&amp; s = expr;       //s is perfectly forwarded\n</code></pre>\n<p>Are they true? If not, why?</p>\n", "AcceptedAnswerId": "21070985", "Title": "How does auto deduce type?", "CreationDate": "2014-01-12T01:03:15.860", "Id": "21070032", "CommentCount": "8", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-05-25T12:27:47.117", "Score": "4", "OwnerUserId": "1270003", "Tags": "<c++><c++11>", "AnswerCount": "2"}});