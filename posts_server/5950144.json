post_cb({"5950144": {"CommentCount": "5", "AcceptedAnswerId": "5950176", "CreationDate": "2011-05-10T12:39:42.033", "LastActivityDate": "2011-05-10T12:56:41.147", "PostTypeId": "1", "ViewCount": "314", "FavoriteCount": "2", "Title": "Weird c++ code snippet", "Id": "5950144", "Score": "4", "Body": "<p>I have this snippet:</p>\n<pre><code>template&lt;class T&gt;\nclass VECTOR_2D \n{\npublic:\n    T x,y;\n\n    VECTOR_2D() \n        :x(T()),y(T())\n    {}\n}\n</code></pre>\n<p>What are x and y initialized to in the constructor?</p>\n", "Tags": "<c++>", "OwnerUserId": "183667", "AnswerCount": "4"}, "5950164": {"ParentId": "5950144", "CommentCount": "0", "CreationDate": "2011-05-10T12:41:21.080", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "5950164", "Score": "1", "Body": "<p>The use of <code>T()</code> in an expression creates an rvalue of type <code>T</code> and <em>value-initializes</em> it. </p>\n<p>If <code>T</code> has a default constructor that constructor will be called, if <code>T</code> is an aggregate type, each one of the attributes will be <em>value-initialized</em>, for <em>primitive</em> types (using <em>primitive</em> in the Java sense: integer, float, double, char, pointers), they will be set to 0.</p>\n", "LastActivityDate": "2011-05-10T12:41:21.080"}, "5950157": {"ParentId": "5950144", "CommentCount": "6", "CreationDate": "2011-05-10T12:40:52.740", "OwnerUserId": "28169", "PostTypeId": "2", "Id": "5950157", "Score": "3", "Body": "<p>An instance (each) of <code>T</code>, built by that type's <a href=\"http://en.wikipedia.org/wiki/Default_constructor\" rel=\"nofollow\">default constructor</a>.</p>\n", "LastActivityDate": "2011-05-10T12:40:52.740"}, "5950192": {"ParentId": "5950144", "CommentCount": "0", "CreationDate": "2011-05-10T12:43:25.767", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "5950192", "Score": "2", "Body": "<p>Someone's not realised that you can default-initialise like this:</p>\n<pre><code>VECTOR_2D() : x(), y() {};\n</code></pre>\n<p>So, instead, they're being <em>really verbose</em> by doing something that's a bit like this:</p>\n<pre><code>X x = X();\n</code></pre>\n<p>The pointless copy should be optimised out by any sane compiler, but it's still a bit daft.</p>\n", "LastActivityDate": "2011-05-10T12:43:25.767"}, "5950176": {"ParentId": "5950144", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-05-10T12:41:53.207", "Score": "6", "LastEditorUserId": "636019", "LastEditDate": "2011-05-10T12:56:41.147", "Id": "5950176", "OwnerUserId": "636019", "Body": "<p><code>x</code> and <code>y</code> are <em>copy-initialized</em> to <code>T</code>'s <em>value-initialized</em> value.</p>\n<p>From the C++03 standard, \u00a78.5/7:</p>\n<blockquote>\n<p id=\"so_5950144_5950176_0\">An object whose initializer is an empty set of parentheses, i.e., (), shall be value-initialized.</p>\n</blockquote>\n<p>And from \u00a78.5/5:</p>\n<blockquote>\n<p id=\"so_5950144_5950176_1\">To <em>value-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li>if <code>T</code> is a class type with a user-declared constructor, then the default constructor for <code>T</code> is called (and the initialization is ill-formed if <code>T</code> has no accessible default constructor);</li>\n<li>if <code>T</code> is a non-union class type without a user-declared constructor, then every non-static data member and base-class component of <code>T</code> is value-initialized;</li>\n<li>if <code>T</code> is an array type, then each element is value-initialized;</li>\n<li>otherwise, the object is zero-initialized</li>\n</ul>\n<p id=\"so_5950144_5950176_2\">To <em>zero-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li>if <code>T</code> is a scalar type, the object is set to the value of <code>0</code> (zero) converted to <code>T</code>;</li>\n<li>if <code>T</code> is a non-union class type, each nonstatic data member and each base-class subobject is zero-initialized;</li>\n<li>if <code>T</code> is a union type, the object\u2019s first named data member) is zero-initialized;</li>\n<li>if <code>T</code> is an array type, each element is zero-initialized;</li>\n<li>if <code>T</code> is a reference type, no initialization is performed.</li>\n</ul>\n</blockquote>\n<hr>\n<p><code>x(T()),y(T())</code> could be replaced with <code>x(),y()</code> to instead value-initialize <code>x</code> and <code>y</code> directly. In most circumstances this will achieve the same net effect (assuming <code>T</code> is copy constructable), but in some cases this will be more efficient, so as a general rule this approach should always be preferred.</p>\n</hr>", "LastActivityDate": "2011-05-10T12:56:41.147"}, "bq_ids": {"n4140": {"so_5950144_5950176_2": {"section_id": 3285, "quality": 1.0, "length": 4}, "so_5950144_5950176_1": {"section_id": 3287, "quality": 1.0, "length": 4}, "so_5950144_5950176_0": {"section_id": 3290, "quality": 1.0, "length": 7}}, "n3337": {"so_5950144_5950176_2": {"section_id": 3155, "quality": 1.0, "length": 4}, "so_5950144_5950176_1": {"section_id": 3157, "quality": 1.0, "length": 4}, "so_5950144_5950176_0": {"section_id": 3160, "quality": 1.0, "length": 7}}, "n4659": {"so_5950144_5950176_0": {"section_id": 4052, "quality": 1.0, "length": 7}}}});