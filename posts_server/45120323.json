post_cb({"bq_ids": {"n4140": {"so_45120323_45120376_0": {"length": 32, "quality": 0.7441860465116279, "section_id": 7041}}, "n3337": {"so_45120323_45120376_0": {"length": 32, "quality": 0.7441860465116279, "section_id": 6786}}, "n4659": {"so_45120323_45120376_0": {"length": 39, "quality": 0.9069767441860465, "section_id": 8538}}}, "45120323": {"ViewCount": "120", "Body": "<p>Let's consider some synthetic but expressive example. Suppose we have Header.h:</p>\n<p>Header1.h</p>\n<pre><code>#include &lt;iostream&gt;\n\n// Define generic version\ntemplate&lt;typename T&gt;\ninline void Foo()\n{\n    std::cout &lt;&lt; \"Generic\\n\";\n}\n</code></pre>\n<p>Header2.h</p>\n<pre><code>void Function1();\n</code></pre>\n<p>Header3.h</p>\n<pre><code>void Function2();\n</code></pre>\n<p>Source1.cpp</p>\n<pre><code>#include \"Header1.h\"\n#include \"Header3.h\"\n\n// Define specialization 1\ntemplate&lt;&gt;\ninline void Foo&lt;int&gt;()\n{\n    std::cout &lt;&lt; \"Specialization 1\\n\";\n}\n\nvoid Function1()\n{\n    Foo&lt;int&gt;();\n}\n</code></pre>\n<p>Later I or some else defines similar conversion in another source file.\nSource2.cpp</p>\n<pre><code>#include \"Header1.h\"\n\n// Define specialization 2\ntemplate&lt;&gt;\ninline void Foo&lt;int&gt;()\n{\n    std::cout &lt;&lt; \"Specialization 2\\n\";\n}\n\nvoid Function2()\n{\n    Foo&lt;int&gt;();\n}\n</code></pre>\n<p>main.cpp</p>\n<pre><code>#include \"Header2.h\"\n#include \"Header3.h\"\n\nint main()\n{\n    Function1();\n    Function2();\n}\n</code></pre>\n<p>The question is what will print Function1() and Function2()? The answer is undefined behavior.</p>\n<p>I expect to see in output: \nSpecialization 1\nSpecialization 2</p>\n<p>But I see: \nSpecialization 2\nSpecialization 2</p>\n<p>Why C++ compilers are silent about ODR violation? I would prefer compilation to be failed in this case.</p>\n<p>I found only one workaround: define template functions in unnamed namespace. </p>\n", "AcceptedAnswerId": "45120376", "Title": "Why C++ linker is silent about ODR violation?", "CreationDate": "2017-07-15T16:20:25.777", "Id": "45120323", "CommentCount": "4", "LastEditDate": "2017-08-31T08:17:36.780", "PostTypeId": "1", "LastEditorUserId": "7010551", "LastActivityDate": "2017-08-31T08:17:36.780", "Score": "1", "OwnerUserId": "7010551", "Tags": "<c++><templates><one-definition-rule>", "AnswerCount": "1"}, "45120376": {"Id": "45120376", "PostTypeId": "2", "Body": "<p>The compiler is silent, because it's not <em>required</em> to emit anything by <a href=\"http://eel.is/c++draft/basic.def.odr#4\" rel=\"noreferrer\">[basic.def.odr/4]</a>:</p>\n<blockquote>\n<p id=\"so_45120323_45120376_0\">Every program shall contain exactly one definition of every non-inline\n  function or variable that is odr-used in that program outside of a\n  discarded statement; <strong>no diagnostic required.</strong> The definition can\n  appear explicitly in the program, it can be found in the standard or a\n  user-defined library, or (when appropriate) it is implicitly defined\n  (see [class.ctor], [class.dtor] and [class.copy]). An inline function\n  or variable shall be defined in every translation unit in which it is\n  odr-used outside of a discarded statement.</p>\n</blockquote>\n", "LastActivityDate": "2017-07-15T16:25:24.407", "CommentCount": "0", "CreationDate": "2017-07-15T16:25:24.407", "ParentId": "45120323", "Score": "7", "OwnerUserId": "817643"}});