post_cb({"bq_ids": {"n4140": {"so_46754725_46755237_1": {"length": 33, "quality": 0.9166666666666666, "section_id": 7192}}, "n3337": {"so_46754725_46755237_1": {"length": 33, "quality": 0.9166666666666666, "section_id": 6936}}, "n4659": {"so_46754725_46755237_1": {"length": 33, "quality": 0.9166666666666666, "section_id": 8701}}}, "46754725": {"ViewCount": "75", "Body": "<p>As an example let's talk about singleton implementation using <code>new</code> (the one where you create the actual instance at the first call to <code>getInstance()</code> method instead of using a static field. It dawned on me that it never frees that memory up. But then again it would have to do it right before the application closes so the system will free that memory up anyway.</p>\n<p>Aside from bad design, what practical downsides does this approach have?</p>\n<p>Edit: Ad comments - all valid points, thanks guys. So let me ask this instead - for a single thread app and POD singleton class are there any practical downsides? Just theoretically, I'm not going to actually do that.</p>\n", "Title": "How bad is not freeing up memory right before the end of program?", "CreationDate": "2017-10-15T11:53:51.903", "LastActivityDate": "2017-10-15T13:25:10.850", "CommentCount": "6", "LastEditDate": "2017-10-15T12:18:23.943", "PostTypeId": "1", "LastEditorUserId": "1030598", "Id": "46754725", "Score": "0", "OwnerUserId": "1030598", "Tags": "<c++><memory-management><design><singleton>", "AnswerCount": "2"}, "46755261": {"Id": "46755261", "PostTypeId": "2", "Body": "<p>Use a schwartz counter for all singleton types. It's how <code>std::cout</code> is implemented. </p>\n<p>Benefits:</p>\n<ul>\n<li><p>thread safe</p></li>\n<li><p>correct initialisation order guaranteed when singletons depend on each other</p></li>\n<li><p>correct destruction order at program termination</p></li>\n<li><p>does not use the heap</p></li>\n<li><p>100% compliant with c++98, c++03, c++11, c++14, c++17...</p></li>\n<li><p>no need for an ugly getInstance() function. Just use the global object.</p></li>\n</ul>\n<p><a href=\"https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Nifty_Counter\" rel=\"nofollow noreferrer\">https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Nifty_Counter</a></p>\n<p>As for the headline question:</p>\n<blockquote>\n<p id=\"so_46754725_46755261_0\">How bad is not freeing up memory right before the end of program?</p>\n</blockquote>\n<p>Not freeing memory is not so bad when the program is running under an OS which manages process memory.</p>\n<p>However, other things that singletons do could include flushing IO buffers (e.g. <code>std::cout</code>, <code>std::cerr</code>). That's probably something you want to avoid losing.</p>\n", "LastEditorUserId": "2015579", "LastActivityDate": "2017-10-15T13:25:10.850", "Score": "0", "CreationDate": "2017-10-15T12:54:18.933", "ParentId": "46754725", "CommentCount": "5", "OwnerUserId": "2015579", "LastEditDate": "2017-10-15T13:25:10.850"}, "46755237": {"Id": "46755237", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_46754725_46755237_0\">for a single thread app and POD singleton class are there any practical downsides? Just theoretically, I'm not going to actually do that.</p>\n</blockquote>\n<p>in standardese</p>\n<blockquote>\n<p id=\"so_46754725_46755237_1\">[c++14-Object lifetime-4]For an object of a class type with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage which the object occupies is reused or released; however, if there is no explicit call to the destructor or if a delete-expression (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and any program that depends on the side effects produced by the destructor has undefined behavior.</p>\n</blockquote>\n<p>where the dtor is implicitly called on automatic/static variables and such. </p>\n<p>So, (assuming a new expression were used to construct the object) the runtime implementation of the invoked allocation function is free to release the memory and let the object decay in oblivion, as long as no observable effects depends on its destruction ( which is trivially true for types with trivial dtors ).</p>\n", "LastEditorUserId": "8631381", "LastActivityDate": "2017-10-15T12:57:24.490", "Score": "0", "CreationDate": "2017-10-15T12:51:21.843", "ParentId": "46754725", "CommentCount": "2", "OwnerUserId": "8631381", "LastEditDate": "2017-10-15T12:57:24.490"}});