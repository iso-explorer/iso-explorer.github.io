post_cb({"22198779": {"ViewCount": "155", "Body": "<p>According to Bjarne Stroustrup's <em>Programming Principles and Practice Using C++ (Sixth Printing, November 2012)</em>, <strong>\"each of [the] types [<code>int</code>, <code>double</code>, <code>char</code>, <code>string</code>, and <code>bool</code>] has its own characteristic style of literals\"</strong> (p.63).</p>\n<p>In \u00a7A.2 of the same book, additional varieties of <code>int</code> (unsigned; long) and floating-point-literals are mentioned, as well as the (null) pointer literal.</p>\n<p><strong>Does <em>every</em> type have a corresponding literal?</strong></p>\n", "AcceptedAnswerId": "22214978", "Title": "Does every type have a corresponding literal?", "CreationDate": "2014-03-05T13:12:00.097", "Id": "22198779", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-03-05T14:17:39.957", "LastEditorUserId": "82216", "LastActivityDate": "2014-04-10T23:24:52.723", "Score": "0", "OwnerUserId": "82216", "Tags": "<c++><oop>", "AnswerCount": "6"}, "22199042": {"Id": "22199042", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_22198779_22199042_0\">C++ Standard n3337  <strong>\u00a7</strong> 2.14.1/1:</p>\n<p id=\"so_22198779_22199042_1\">There are several kinds of literals.</p>\n<p id=\"so_22198779_22199042_2\">literal:</p>\n<p id=\"so_22198779_22199042_3\">integer-literal</p>\n<p id=\"so_22198779_22199042_4\">character-literal</p>\n<p id=\"so_22198779_22199042_5\">floating-literal</p>\n<p id=\"so_22198779_22199042_6\">string-literal</p>\n<p id=\"so_22198779_22199042_7\">boolean-literal</p>\n<p id=\"so_22198779_22199042_8\">pointer-literal</p>\n<p id=\"so_22198779_22199042_9\">user-defined-literal</p>\n</blockquote>\n<p>No, not avery type has a literal. Classes do not have literal, as well as i.e <code>void</code>, <code>int*</code>, <code>signed char</code>, <code>unsigned char</code>, <code>short</code>, <code>unsigned short</code>.</p>\n<hr>\n<h2>Literals explained:</h2>\n<p><strong>integer-literal</strong></p>\n<p>An integer literal is a sequence of digits that has no period or exponent part. </p>\n<p>example:  <code>1</code></p>\n<p><strong>character-literal</strong></p>\n<p>A character literal is one or more characters enclosed in single quotes, as in \u2019x\u2019, optionally preceded by\none of the letters u, U, or L, as in u\u2019y\u2019, U\u2019z\u2019, or L\u2019x\u2019, respectively.</p>\n<p>\u2019 c-char-sequence \u2019</p>\n<p>u\u2019 c-char-sequence \u2019</p>\n<p>U\u2019 c-char-sequence \u2019</p>\n<p>L\u2019 c-char-sequence \u2019</p>\n<p>example:  <code>'a'</code>, <code>'ab'</code>, <code>'\\''</code>, <code>L'0'</code>, <code>'('</code></p>\n<p><strong>floating-literal</strong></p>\n<p>A floating literal consists of an integer part, a decimal point, a fraction part, an e or E, an optionally signed\ninteger exponent, and an optional type suffix. The integer and fraction parts both consist of a sequence of\ndecimal (base ten) digits. Either the integer part or the fraction part (not both) can be omitted; either the\ndecimal point or the letter e (or E ) and the exponent (not both) can be omitted. The integer part, the\noptional decimal point and the optional fraction part form the significant part of the floating literal. The\nexponent, if present, indicates the power of 10 by which the significant part is to be scaled.</p>\n<p>example: <code>123.456e-67</code>, <code>.1E1f</code>, <code>42.</code>, 1<code>3e3</code></p>\n<p><strong>string-literal</strong></p>\n<p>A string literal is a sequence of characters (as defined in 2.14.3) surrounded by double quotes, optionally\nprefixed by R, u8, u8R, u, uR, U, UR, L, or LR, as in \"...\", R\"(...)\", u8\"...\", u8R\"<strong>(...)</strong>\", u\"...\",\nuR\"* \u0303(...)* \u0303\", U\"...\", UR\"zzz(...)zzz\", L\"...\", or LR\"(...)\", respectively.</p>\n<p>encoding-prefixopt \" s-char-sequenceopt \"</p>\n<p>encoding-prefixopt R raw-string</p>\n<p>example: <code>\"me\"</code>, <code>L\"you\"</code></p>\n<p><strong>boolean-literal</strong></p>\n<p>The Boolean literals are the keywords <code>false</code> and <code>true</code>. Such literals are <code>prvalues</code> and have type <code>bool</code>.</p>\n<pre><code>false\ntrue\n</code></pre>\n<p><strong>pointer-literal</strong></p>\n<p>The pointer literal is the keyword <code>nullptr</code>. It is a prvalue of type <code>std::nullptr_t</code>.</p>\n<pre><code>nullptr\n</code></pre>\n<p><strong>user-defined-literal</strong></p>\n<p>Overload of <code>operator\"\"</code> that allows to interpret literal using user-defined logic.</p>\n<p>example:</p>\n<pre><code>typedef double signalf;\nconstexpr signalf operator\"\" _percent( long double val) { return val / 100 ; }\n\nstd::cout  &lt;&lt; 12.34_percent; // prints 0.1234\n</code></pre>\n</hr>", "LastEditorUserId": "1141471", "LastActivityDate": "2014-04-10T23:24:52.723", "Score": "5", "CreationDate": "2014-03-05T13:22:45.513", "ParentId": "22198779", "CommentCount": "2", "OwnerUserId": "1141471", "LastEditDate": "2014-04-10T23:24:52.723"}, "22198882": {"Id": "22198882", "PostTypeId": "2", "Body": "<p>Most types do not have a literal. Classes do not have one. Pointers, references, r-value references have none, as well. <code>void</code> does not have a literal. </p>\n<p>You mentioned <code>string</code> which also does not have a literal, it only has a constructor that takes a <code>const char*</code> literal! C++ calls this constructor implicitly, when assigning a <code>const char*</code> literal to a string.</p>\n", "LastActivityDate": "2014-03-05T13:16:26.043", "CommentCount": "3", "CreationDate": "2014-03-05T13:16:26.043", "ParentId": "22198779", "Score": "1", "OwnerUserId": "1408611"}, "bq_ids": {"n4140": {"so_22198779_22199042_1": {"length": 4, "quality": 1.0, "section_id": 5339}}, "n3337": {"so_22198779_22199042_1": {"length": 4, "quality": 1.0, "section_id": 5136}}, "n4659": {"so_22198779_22199042_1": {"length": 4, "quality": 1.0, "section_id": 6760}}}, "22198955": {"Id": "22198955", "PostTypeId": "2", "Body": "<p>First of all type <code>std::string</code> has no its own literals.\nOnly arithmetic types have their own literals. The exception is string literals that has type of <code>const char arrays</code> and not so fer introduced in the C++ 11 <code>nullptr</code> of type <code>std::nullptr_t</code></p>\n<p>Take into account that <code>bool</code> is an arithmetic type.</p>\n", "LastActivityDate": "2014-03-05T13:19:21.877", "CommentCount": "1", "CreationDate": "2014-03-05T13:19:21.877", "ParentId": "22198779", "Score": "0", "OwnerUserId": "2877241"}, "22198919": {"Id": "22198919", "PostTypeId": "2", "Body": "<p>Adding to the list, there's no literals for <code>signed char</code>, <code>unsigned char</code>, <code>short</code>, <code>unsigned short</code>.</p>\n<p>You should probably think in terms of the limited list of types for which there are literals, rather than the types for which there are not. Literals are for:</p>\n<ul>\n<li>bool</li>\n<li>char, wchar_t, char16_t, char32_t</li>\n<li>\"array of const\" char, wchar_t, char16_t, char32_t (that is, string literals)</li>\n<li>int, unsigned int</li>\n<li>long, unsigned long</li>\n<li>long long, unsigned long long</li>\n<li>float, double, long double</li>\n<li>std::nullptr_t</li>\n</ul>\n<p>plus user-defined literals.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2014-03-05T13:24:00.467", "Score": "1", "CreationDate": "2014-03-05T13:17:52.057", "ParentId": "22198779", "CommentCount": "3", "OwnerUserId": "13005", "LastEditDate": "2014-03-05T13:24:00.467"}, "22214978": {"Id": "22214978", "PostTypeId": "2", "Body": "<p>Bjarne Stroustrup's <em>Programming Principles and Practice Using C++ (Sixth Printing, November 2012)</em> refers to <a href=\"http://cs.nyu.edu/courses/fall11/CSCI-GA.2110-003/documents/c++2003std.pdf\" rel=\"nofollow noreferrer\">ISO/IEC 14882:2003</a> as the relevant C++ standard. In this can be found the pertinent section, \u00a72.13, which reads as follows:</p>\n<pre class=\"lang-none prettyprint-override\"><code>2.13 Literals\n\nThere are several kinds of literals.\n\nliteral:\n    integer-literal\n    character-literal\n    floating-literal\n    string-literal\n    boolean-literal\n</code></pre>\n<p>Apparently, this is an exhaustive list; and because there can be many more types than there are kinds of literal in that list, the answer is: <strong>no, not every type has a corresponding literal.</strong></p>\n<p><em>N.B. for the C++11 case, please see <a href=\"https://stackoverflow.com/a/22199042/82216\">Lizusek's answer</a>.</em></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-03-06T04:30:13.740", "Score": "0", "CreationDate": "2014-03-06T04:30:13.740", "ParentId": "22198779", "CommentCount": "1", "OwnerUserId": "82216", "LastEditDate": "2017-05-23T10:26:11.130"}, "22198825": {"Id": "22198825", "PostTypeId": "2", "Body": "<p>There's no literal for <code>int*</code>. The closest you get is <code>nullptr</code>, but its type is <code>nullptr_t</code>.</p>\n", "OwnerDisplayName": "user2033018", "LastActivityDate": "2014-03-05T13:14:15.577", "Score": "1", "CreationDate": "2014-03-05T13:14:15.577", "ParentId": "22198779", "CommentCount": "0"}});