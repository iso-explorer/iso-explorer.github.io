post_cb({"35087786": {"ParentId": "35087542", "CommentCount": "0", "Body": "<p>If you question if you can rely on <code>sizeof</code> of the following type:</p>\n<pre><code>struct A\n{\n   int&amp; r;\n};\n</code></pre>\n<p>Then yes - you can rely on <code>sizeof</code> in structs containing references.</p>\n<p>E.g. this code is safe:</p>\n<pre><code>   char* buffer = new char[sizeof(A)];\n   int value;\n   A* valueRef = new (buffer) A{value};\n</code></pre>\n<p>You have enough bytes in buffer to store A object.</p>\n", "OwnerUserId": "1463922", "PostTypeId": "2", "Id": "35087786", "Score": "0", "CreationDate": "2016-01-29T15:12:13.310", "LastActivityDate": "2016-01-29T15:12:13.310"}, "35087805": {"ParentId": "35087542", "CommentCount": "0", "Body": "<pre><code>struct S {\n    long double&amp; d;\n};\n\nstatic_assert(sizeof(S::d) == sizeof(long double));\nstatic_assert(sizeof(S) != sizeof(S::d));  // true on most platforms\n</code></pre>\n<p>The compiler is smart enough to know the size of <code>S</code>, it doesn't get confused and think it is <code>sizeof(S::d)</code> because that would be stupid.</p>\n", "OwnerUserId": "981959", "PostTypeId": "2", "Id": "35087805", "Score": "0", "CreationDate": "2016-01-29T15:13:46.810", "LastActivityDate": "2016-01-29T15:13:46.810"}, "35087542": {"CommentCount": "8", "ViewCount": "135", "PostTypeId": "1", "LastEditorUserId": "4760251", "CreationDate": "2016-01-29T15:01:15.347", "LastActivityDate": "2016-01-29T16:50:43.667", "Title": "Reference \u2014 does sizeof return the real memory size?", "LastEditDate": "2016-01-29T15:24:00.740", "Id": "35087542", "Score": "2", "Body": "<p>I know this question has probably been asked in many different ways, but I'm adding my own because this is still unclear for me.</p>\n<p>Consider this code: </p>\n<pre><code>long double q = 1.2;\nlong double &amp;p = q;\ncout &lt;&lt; sizeof(p) &lt;&lt; endl;`\n</code></pre>\n<p><code>long double</code> is 12 bytes on my machine, and the output of the code is as expected 12 because as the standard says: </p>\n<blockquote>\n<p id=\"so_35087542_35087542_0\">When applied to a reference or a reference type, the result is the\n  size of the referenced type. (ISO C++ $5.3.3/2)</p>\n</blockquote>\n<p>But as you most likely all know, references implementation is free, and thus, as the standard says again:</p>\n<blockquote>\n<p id=\"so_35087542_35087542_1\">It is unspecified whether or not a reference requires storage (3.7).</p>\n</blockquote>\n<p>So it seems that tomorrow I can come up with my own reference implementation that takes 200 bytes and make sure that the <code>sizeof</code> operator returns the right object size (instead of returning what would be the true implementation size of my reference)</p>\n<p>So my question is actually extremely simple: </p>\n<p>Can we rely on the <code>sizeof</code> operator to return the real memory occupation of a class when it contains, specifically, reference members?</p>\n", "Tags": "<c++><reference><sizeof>", "OwnerUserId": "4760251", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_35087542_35087542_0": {"section_id": 6077, "quality": 0.8181818181818182, "length": 9}, "so_35087542_35087542_1": {"section_id": 3221, "quality": 1.0, "length": 5}}, "n3337": {"so_35087542_35087542_0": {"section_id": 5845, "quality": 0.8181818181818182, "length": 9}, "so_35087542_35087542_1": {"section_id": 3095, "quality": 1.0, "length": 5}}, "n4659": {"so_35087542_35087542_0": {"section_id": 7573, "quality": 0.8181818181818182, "length": 9}, "so_35087542_35087542_1": {"section_id": 3978, "quality": 1.0, "length": 5}}}, "35087779": {"ParentId": "35087542", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>Compare and contrast:</p>\n<pre><code>struct container {\n  long double&amp; dbl;\n};\n\nstd::cout &lt;&lt; sizeof(container::dbl) &lt;&lt; '\\n';\nstd::cout &lt;&lt; sizeof(container)      &lt;&lt; '\\n';\n</code></pre>\n<p>(<a href=\"http://ideone.com/KIhFJt\" rel=\"nofollow noreferrer\">Live on ideone</a>)</p>\n<p>One line tells you the size of a referred-to object. The other tells you the size of the structure containing the reference.</p>\n<p>That behaviour is not by chance. It's defined by the standard and yes, you can rely on it.</p>\n<p>There seems to be an assumption behind this question that the behaviour of the <code>sizeof</code> operator with a reference or reference type is somehow arbitrary and conventional. That is not the case; it falls out of the same logic that generally applies to references.</p>\n<p>If I have</p>\n<pre><code>long double dbl;\n</code></pre>\n<p>then any use of <code>dbl</code> in its scope is an lvalue, which is to say a <em>reference</em>. That is necessary in order for it to be possible to assign a value to <code>dbl</code>. So the type of <code>dbl</code> (as revealed, for example, by <code>decltype(dbl)</code>) is <code>long double&amp;</code>, not <code>long double</code>.</p>\n<p>It would be ridiculous for <code>sizeof(dbl)</code> to return the size of the reference itself rather than the size of the referenced object.</p>\n<p>Once you put the reference into a structure, you have a completely different beast. <em>As part of an object</em>, the reference occupies space, which cannot be optimized away unless the entire object containing it can be optimized away.</p>\n", "OwnerUserId": "1566221", "LastEditorUserId": "1566221", "LastEditDate": "2016-01-29T16:50:43.667", "Id": "35087779", "Score": "6", "CreationDate": "2016-01-29T15:11:42.640", "LastActivityDate": "2016-01-29T16:50:43.667"}});