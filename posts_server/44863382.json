post_cb({"44863566": {"ParentId": "44863382", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From the standard (Section 15.8.1 [class.copy.ctor])</p>\n<blockquote>\n<p id=\"so_44863382_44863566_0\">(14) The implicitly-defined copy/move constructor for a non-union class X\n  performs a memberwise copy/move of its bases and members. [ Note:\n  Default member initializers of non-static data members are ignored.\n  See also the example in 15.6.2. \u2014 end note ] The order of\n  initialization is the same as the order of initialization of bases and\n  members in a user-defined constructor (see 15.6.2)</p>\n</blockquote>\n<p>Following the link leads us to\nSection 15.6.2 [class.base.init]</p>\n<blockquote>\n<p id=\"so_44863382_44863566_1\">(13.3) Then, non-static data members are initialized in the order they\n  were declared in the class definition (again regardless of the order\n  of the mem-initializer s)</p>\n</blockquote>\n<hr>\n<p>Not quite answering the question to the point, but as Igor Tandetnik also said in his answer, it is legal to transform a trivial constructor into a  <code>std::memmove</code></p>\n</hr>", "OwnerUserId": "3750062", "LastEditorUserId": "3750062", "LastEditDate": "2017-07-01T17:50:01.313", "Id": "44863566", "Score": "2", "CreationDate": "2017-07-01T17:15:00.903", "LastActivityDate": "2017-07-01T17:50:01.313"}, "44863678": {"ParentId": "44863382", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_44863382_44863678_0\"><strong>[basic.types]/3</strong> For any trivially copyable type <code>T</code>, if two pointers to <code>T</code> point to distinct <code>T</code> objects <code>obj1</code> and <code>obj2</code>, where neither <code>obj1</code> nor <code>obj2</code> is a base-class subobject, if the underlying bytes (1.7) making up <code>obj1</code> are copied into <code>obj2</code>, <code>obj2</code> shall subsequently hold the same value as <code>obj1</code>.</p>\n</blockquote>\n<p>So for a trivially copyable type, it would be safe to simply copy the bytes, e.g. with <code>memmove</code>. You can test for this trait with <code>std::is_trivially_copyable</code>.</p>\n<p>Note that <em>trivially move constructible</em> is a necessary but not sufficient condition of being trivially copyable:</p>\n<blockquote>\n<p id=\"so_44863382_44863678_1\"><strong>[class]/6</strong> A <em>trivially copyable class</em> is a class:</p>\n<p id=\"so_44863382_44863678_2\">(6.1) \u2014 where each copy constructor, move constructor, copy assignment operator, and move assignment operator (12.8, 13.5.3) is either deleted or trivial,</p>\n<p id=\"so_44863382_44863678_3\">(6.2) \u2014 that has at least one non-deleted copy constructor, move constructor, copy assignment operator, or move assignment operator, and</p>\n<p id=\"so_44863382_44863678_4\">(6.3) \u2014 that has a trivial, non-deleted destructor (12.4).</p>\n</blockquote>\n", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "44863678", "Score": "0", "CreationDate": "2017-07-01T17:30:20.097", "LastActivityDate": "2017-07-01T17:30:20.097"}, "44863382": {"CommentCount": "5", "ViewCount": "100", "CreationDate": "2017-07-01T16:54:56.747", "LastActivityDate": "2017-07-01T17:50:01.313", "Title": "What is the order of assignments inside a default move constructor?", "AcceptedAnswerId": "44863566", "PostTypeId": "1", "Id": "44863382", "Score": "2", "Body": "<p>I am currently working on a custom allocator in c++. This allocator has to defragment its memory on a regular basis, by shifting the memory and objects around. These shifts are always downward, meaning that the address of a moved memory chunk always decreases when it gets moved. There is no problem doing so when the old memory chunk and the new memory chunk don't overlap. If they are overlapping I first must move the object into a temporary area outside of the allocator memory and then move it back to the new memory chunk.</p>\n<p>If std::is_trivially_move_constructible is true for the moved type, then I might save this extra move to a temporary memory chunk if the order of assignments inside a default move constructor is well defined. This leads to my question: Is the order of assignments well defined or is it platform specific?</p>\n", "Tags": "<c++><memory><move-semantics><allocator><move-constructor>", "OwnerUserId": "7130273", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_44863382_44863678_0": {"section_id": 7201, "quality": 0.9375, "length": 30}, "so_44863382_44863566_0": {"section_id": 464, "quality": 0.7368421052631579, "length": 28}, "so_44863382_44863678_3": {"section_id": 469, "quality": 0.8461538461538461, "length": 11}, "so_44863382_44863678_1": {"section_id": 4706, "quality": 0.8, "length": 4}, "so_44863382_44863678_2": {"section_id": 469, "quality": 0.5882352941176471, "length": 10}, "so_44863382_44863566_1": {"section_id": 438, "quality": 0.875, "length": 14}}, "n3337": {"so_44863382_44863678_0": {"section_id": 6945, "quality": 0.9375, "length": 30}, "so_44863382_44863566_0": {"section_id": 455, "quality": 0.7368421052631579, "length": 28}, "so_44863382_44863678_3": {"section_id": 460, "quality": 0.8461538461538461, "length": 11}, "so_44863382_44863678_1": {"section_id": 4515, "quality": 0.8, "length": 4}, "so_44863382_44863678_2": {"section_id": 460, "quality": 0.6470588235294118, "length": 11}, "so_44863382_44863566_1": {"section_id": 429, "quality": 0.875, "length": 14}}, "n4659": {"so_44863382_44863678_0": {"section_id": 8710, "quality": 0.9375, "length": 30}, "so_44863382_44863566_1": {"section_id": 458, "quality": 0.875, "length": 14}, "so_44863382_44863678_3": {"section_id": 7329, "quality": 1.0, "length": 13}, "so_44863382_44863678_1": {"section_id": 6103, "quality": 0.8, "length": 4}, "so_44863382_44863678_2": {"section_id": 7329, "quality": 0.8823529411764706, "length": 15}, "so_44863382_44863566_0": {"section_id": 487, "quality": 0.8157894736842105, "length": 31}}}});