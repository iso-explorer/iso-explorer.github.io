post_cb({"40483360": {"ParentId": "40483266", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It's not the same. Try <code>num = -79</code>, and you will get different results from both operations. <code>(-79) % 256 = -79</code>, while <code>(-79) &amp; 0xff</code> is some positive number. </p>\n<p>Using <code>unsigned int</code>, the operations are the same, and the code will likely be the same. </p>\n<p><strong>PS-</strong> Someone commented </p>\n<blockquote>\n<p id=\"so_40483266_40483360_0\">They shouldn't be the same, <code>a % b</code> is defined as <code>a - b * floor (a / b)</code>.</p>\n</blockquote>\n<p>That's not how it is defined in C, C++, Objective-C (ie all the languages where the code in the question would compile). </p>\n", "OwnerUserId": "3255455", "LastEditorUserId": "254477", "LastEditDate": "2016-11-10T20:03:40.103", "Id": "40483360", "Score": "226", "CreationDate": "2016-11-08T09:33:36.150", "LastActivityDate": "2016-11-10T20:03:40.103"}, "40483351": {"ParentId": "40483266", "CommentCount": "1", "Body": "<p>I don't have telepathic insight into the compiler's reasoning, but in the case of <code>%</code> there is the necessity of dealing with negative values (and division rounds towards zero), while with <code>&amp;</code> the result is always the lower 8 bits.</p>\n<p>The <code>sar</code> instruction sounds to me like \"shift arithmetic right\", filling up the vacated bits with the sign bit value.</p>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "40483351", "Score": "11", "CreationDate": "2016-11-08T09:33:16.310", "LastActivityDate": "2016-11-08T09:33:16.310"}, "40483294": {"ParentId": "40483266", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>Since C++11, <code>num % 256</code> has to be non-positive if <code>num</code> is negative.</p>\n<p>So the bit pattern would depend on the implementation of signed types on your system: for a negative first argument, the result is not the extraction of the least significant 8 bits.</p>\n<p>It would be a different matter if <code>num</code> in your case was <code>unsigned</code>: these days I'd almost <em>expect</em> a compiler to make the optimisation that you cite.</p>\n", "OwnerUserId": "2380830", "LastEditorUserId": "2380830", "LastEditDate": "2016-11-08T16:47:36.973", "Id": "40483294", "Score": "50", "CreationDate": "2016-11-08T09:30:15.820", "LastActivityDate": "2016-11-08T16:47:36.973"}, "40511115": {"ParentId": "40483266", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Mathematically speaking, modulo is defined to be the following:</p>\n<p>a % b = a - b * floor(a/b)</p>\n<p>This right here should clear it up for you. We can eliminate floor for integers because integer division is equivalent to floor(a/b). However, if the compiler were to use a general trick like you suggest, it would need to work for all a and all b. Unfortunately, this just isn't the case. Mathematically speaking, your trick is 100% correct for unsigned integers (I see an answer states signed integers break but I can confirm nor deny this as -a % b should be positive). However, can you do this trick for all b? Probably not. That's why the compiler doesn't do it. After all, if modulo were easily written as one bitwise operation, then we would just add a modulo circuit like for addition and the other operations.</p>\n", "OwnerUserId": "5577239", "LastEditorUserId": "5577239", "LastEditDate": "2016-11-10T01:55:03.537", "Id": "40511115", "Score": "0", "CreationDate": "2016-11-09T15:58:18.827", "LastActivityDate": "2016-11-10T01:55:03.537"}, "40490924": {"ParentId": "40483266", "PostTypeId": "2", "CommentCount": "0", "Body": "<h2>Short answer</h2>\n<p><code>-1 % 256</code> yields <code>-1</code> and not <code>255</code> which is <code>-1 &amp; 0xFF</code>. Therefore, the optimization would be incorrect. </p>\n<h2>Long answer</h2>\n<p>C++ has the convention that <code>(a/b)*b + a%b == a</code>, which seems quite natural. <code>a/b</code> always returns the arithmetic result without the fractional part (truncating towards 0). As a consequence, <code>a%b</code> has the same sign as <code>a</code> or is 0. </p>\n<p>The division <code>-1/256</code> yields <code>0</code> and hence <code>-1%256</code> must be <code>-1</code> in order to satisfy the above condition (<code>(-1%256)*256 + -1%256 == -1</code>). This is obviously different from <code>-1&amp;0xFF</code> which is <code>0xFF</code>. Therefore, the compiler cannot optimize the way you want.</p>\n<p>The relevant section in the <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/n4606.pdf\" rel=\"nofollow noreferrer\">C++ standard [expr.mul \u00a74] as of N4606</a> states:</p>\n<blockquote>\n<p id=\"so_40483266_40490924_0\">For integral operands the <code>/</code> operator yields the algebraic quotient with any fractional part discarded; if the quotient <code>a/b</code> is representable in the type of the result, <code>(a/b)*b + a%b</code> is equal to <code>a</code> [...].</p>\n</blockquote>\n<h2>Enabling the optimization</h2>\n<p>However, <strong>using <code>unsigned</code> types, the optimization would be completely correct</strong>, satisfying the above convention:</p>\n<pre><code>unsigned(-1)%256 == 0xFF\n</code></pre>\n<p>See also <a href=\"https://en.wikipedia.org/wiki/Modulo_operation#Performance_issues\" rel=\"nofollow noreferrer\">this</a>. </p>\n<h2>Other languages</h2>\n<p>This is handled very different across different programming languages as you can look up on <a href=\"https://en.wikipedia.org/wiki/Modulo_operation\" rel=\"nofollow noreferrer\">Wikipedia</a>. </p>\n", "OwnerUserId": "1335865", "LastEditorUserId": "1335865", "LastEditDate": "2016-11-22T08:12:32.503", "Id": "40490924", "Score": "53", "CreationDate": "2016-11-08T15:41:39.420", "LastActivityDate": "2016-11-22T08:12:32.503"}, "40483266": {"CommentCount": "18", "CreationDate": "2016-11-08T09:29:01.957", "PostTypeId": "1", "AcceptedAnswerId": "40483360", "LastEditorUserId": "743214", "LastActivityDate": "2016-11-22T08:12:32.503", "LastEditDate": "2016-11-09T14:19:51.773", "ViewCount": "14430", "FavoriteCount": "16", "Title": "Why is (a % 256) different than (a & 0xFF)?", "Id": "40483266", "Score": "137", "Body": "<p>I always assumed that when doing <code>(a % 256)</code> the optimizer would naturally use an efficient bitwise operation, as if I wrote <code>(a &amp; 0xFF)</code>.</p>\n<p>When testing on compiler explorer gcc-6.2 (-O3):</p>\n<pre><code>// Type your code here, or load an example.\nint mod(int num) {\n    return num % 256;\n}\n\nmod(int):\n    mov     edx, edi\n    sar     edx, 31\n    shr     edx, 24\n    lea     eax, [rdi+rdx]\n    movzx   eax, al\n    sub     eax, edx\n    ret\n</code></pre>\n<p>And when trying the other code:</p>\n<pre><code>// Type your code here, or load an example.\nint mod(int num) {\n    return num &amp; 0xFF;\n}\n\nmod(int):\n    movzx   eax, dil\n    ret\n</code></pre>\n<p>Seems like I'm completely missing something out.\nAny ideas?</p>\n", "Tags": "<c++><optimization>", "OwnerUserId": "5470144", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_40483266_40490924_0": {"section_id": 6137, "quality": 0.875, "length": 14}}, "n3337": {"so_40483266_40490924_0": {"section_id": 5901, "quality": 0.875, "length": 14}}, "n4659": {"so_40483266_40490924_0": {"section_id": 7634, "quality": 0.875, "length": 14}}}});