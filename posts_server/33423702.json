post_cb({"33423703": {"ParentId": "33423702", "CommentCount": "0", "Body": "<p>Yes, you should use parentheses:</p>\n<pre><code>template &lt;class T&gt;\ntypename std::enable_if&lt;(sizeof(T) &gt; 1), void&gt;::type\nfoobify(T v) {\n    // ...\n}\n</code></pre>\n", "OwnerUserId": "15055", "PostTypeId": "2", "Id": "33423703", "Score": "12", "CreationDate": "2015-10-29T20:11:10.843", "LastActivityDate": "2015-10-29T20:11:10.843"}, "bq_ids": {"n4140": {"so_33423702_33423740_0": {"section_id": 71, "quality": 0.8571428571428571, "length": 12}, "so_33423702_33423740_2": {"section_id": 71, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_33423702_33423740_0": {"section_id": 66, "quality": 0.8571428571428571, "length": 12}, "so_33423702_33423740_2": {"section_id": 66, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_33423702_33423740_0": {"section_id": 73, "quality": 0.8571428571428571, "length": 12}, "so_33423702_33423740_2": {"section_id": 73, "quality": 0.9285714285714286, "length": 13}}}, "33423740": {"ParentId": "33423702", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, expressions using that operator must be parenthesized. See [temp.names]/3:</p>\n<blockquote>\n<p id=\"so_33423702_33423740_0\">When parsing a <em>template-argument-list</em>, <strong>the first non-nested <code>&gt;</code><sup>138</sup> is taken as the ending delimiter\n  rather than a greater-than operator.</strong> [..] [ <em>Example:</em></p>\n<pre><code>template&lt;int i&gt; class X { /* ...*/ };\n\nX&lt; 1&gt;2 &gt; x1; // syntax error\nX&lt;(1&gt;2)&gt; x2; // OK\n</code></pre>\n<p id=\"so_33423702_33423740_1\"><em>\u2014 end example</em> ]</p>\n<p id=\"so_33423702_33423740_2\"><sup> 138) A <code>&gt;</code> that encloses the <em>type-id</em> of a <code>dynamic_cast</code>, <code>static_cast</code>, <code>reinterpret_cast</code> or <code>const_cast</code>, or which encloses the\n  <em>template-argument</em>s of a subsequent <em>template-id</em>, is considered nested for the purpose of this description.</sup></p>\n</blockquote>\n<p>Clearly that doesn't apply if you use the symmetric counterpart of that comparison, i.e. employing <code>&lt;</code>, instead - parsing is unambiguous in that case.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-10-29T20:17:53.777", "Id": "33423740", "Score": "20", "CreationDate": "2015-10-29T20:13:32.327", "LastActivityDate": "2015-10-29T20:17:53.777"}, "33423702": {"CommentCount": "2", "AcceptedAnswerId": "33423740", "CreationDate": "2015-10-29T20:11:10.843", "LastActivityDate": "2015-10-29T20:17:53.777", "PostTypeId": "1", "ViewCount": "1598", "FavoriteCount": "0", "Title": "How to use > (greater-than) inside a template parameter and not get a parsing error?", "Id": "33423702", "Score": "14", "Body": "<p>I want to only define a function based on the size of the template parameter:</p>\n<pre><code>template &lt;class T&gt;\ntypename std::enable_if&lt;sizeof(T) &gt; 1, void&gt;::type\nfoobify(T v) {\n    // ...\n}\n\nint main() {\n    //foobify((unsigned char)30); // should not compile\n    foobify((long)30);\n}\n</code></pre>\n<p>However, I get:</p>\n<pre><code>main.cpp:8:41: error: expected unqualified-id before numeric constant\n     typename std::enable_if&lt;sizeof(T) &gt; 1, void&gt;::type\n</code></pre>\n<p>It works if I instead do <code>1 &lt; sizeof(T)</code>. Thus I believe GCC is thinking I am ending the template parameter, instead of continuing the boolean expression. </p>\n<p>Is there any way to use <code>&gt;</code> itself without having to work around it?</p>\n", "Tags": "<c++><parsing><templates>", "OwnerUserId": "15055", "AnswerCount": "2"}});