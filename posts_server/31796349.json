post_cb({"31796349": {"ViewCount": "506", "Body": "<p>Consider the following code:</p>\n<pre><code>class A1\n{\n    virtual void a() = 0;\n};\n\nclass A2\n{\n    virtual int a(int x) = 0;\n};\n\nclass B : public A1, public A2\n{\n    void a() {}\n    int  a(int x) { return x; }\n};\n\n\nint main()\n{\n    A1* pa1;\n    pa1 = new B;\n    delete pa1;\n\n    A2* pa2;\n    pa2 = new B;\n    delete pa2;\n    return 0;\n}\n</code></pre>\n<p>Classes A1 and A2 are just pure abstract, so multiple inheritance should do no harm. Now, the above code will cause a crash during destructor call, but what is peculiar, only for one object: pa2. The fix to this problem seems quite obvious - use virtual destructors ~A1() and ~A2(). However, there are still two questions:</p>\n<ol>\n<li><p>Why the virtual destructors are necessary, since we do not have any data in any of these classes?</p></li>\n<li><p>Why is the behavior different for pa1 and pa2? I have found that this is related to the order in which classes are placed on the parent list. If you changed it to:</p></li>\n</ol>\n<p><code>class B : public A2, public A1</code></p>\n<p>then </p>\n<p><code>delete pa1;</code></p>\n<p>would cause crash.</p>\n", "Title": "Multiple inheritance and polymorphism in C++", "CreationDate": "2015-08-03T20:38:00.220", "LastActivityDate": "2015-08-04T00:25:43.023", "CommentCount": "2", "PostTypeId": "1", "Id": "31796349", "Score": "2", "OwnerUserId": "4837295", "Tags": "<c++><inheritance><polymorphism>", "AnswerCount": "3"}, "31796446": {"Id": "31796446", "PostTypeId": "2", "Body": "<p>From [expr.delete]:</p>\n<blockquote>\n<p id=\"so_31796349_31796446_0\">In the first alternative (delete object), if the static type of the object to be deleted is different from its\n  dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the\n  static type shall have a virtual destructor <strong>or the behavior is undefined</strong>.</p>\n</blockquote>\n<p>Undefined behavior is undefined. The virtual destructor is necessary because the standard says so (see also <a href=\"https://stackoverflow.com/a/31796529/2069064\">dyp's answer</a>)</p>\n<p>Compiling with warnings also helps:</p>\n<pre><code>main.cpp: In function 'int main()':\nmain.cpp:22:12: warning: deleting object of abstract class type 'A1' which has non-virtual destructor will cause undefined behaviour [-Wdelete-non-virtual-dtor]\n     delete pa1;\n            ^\nmain.cpp:26:12: warning: deleting object of abstract class type 'A2' which has non-virtual destructor will cause undefined behaviour [-Wdelete-non-virtual-dtor]\n     delete pa2;\n            ^\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-08-04T00:25:43.023", "Score": "7", "CreationDate": "2015-08-03T20:44:14.920", "ParentId": "31796349", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2017-05-23T11:57:58.907"}, "31796529": {"Id": "31796529", "PostTypeId": "2", "Body": "<p>A possible and typical memory layout:</p>\n<pre>\n+-A1---+\n| vptr |\n+------+\n\n+-A2---+\n| vptr |\n+------+\n\n+-B------------------+\n| +-A1---+  +-A2---+ |\n| | vptr |  | vptr | |\n| +------+  +------+ |\n+--------------------+\n</pre>\n<p><code>vptr</code> is a pointer that points to some information about the most-derived type, e.g. the virtual function table, RTTI etc. (see e.g. the <a href=\"http://mentorembedded.github.io/cxx-abi/abi.html#vtable\">Itanium C++ ABI vtable layout</a>)</p>\n<p>So, when you write <code>A2* p = new B</code>, you'll end up with:</p>\n<pre>\n+-B------------------+\n| +-A1---+  +-A2---+ |\n| | vptr |  | vptr | |\n| +------+  +------+ |\n+-----------^--------+\n^           | p\n| new B\n</pre>\n<p>When you now <code>delete p;</code>, this can cause trouble in the free store deallocator, since the address stored in <code>p</code> is not the same as the address you've received from the allocator (<code>new B</code>). This won't happen if you cast to <code>A1</code>, i.e. <code>A1* p = new B</code>, since there's no offset in this case.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/c91f74553c53e138\">Live example</a></p>\n<p>You can avoid try to avoid this particular problem by restoring the original pointer via a <code>dynamic_cast</code>:</p>\n<pre><code>delete dynamic_cast&lt;void*&gt;(p);\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/9cdde60207221065\">Live example</a></p>\n<p>But <strong>do not rely on this</strong>. It is still Undefined Behaviour (see Barry's answer).</p>\n", "LastEditorUserId": "420683", "LastActivityDate": "2015-08-03T21:01:20.980", "Score": "8", "CreationDate": "2015-08-03T20:50:53.300", "ParentId": "31796349", "CommentCount": "1", "OwnerUserId": "420683", "LastEditDate": "2015-08-03T21:01:20.980"}, "bq_ids": {"n4140": {"so_31796349_31796446_0": {"length": 27, "quality": 1.0, "section_id": 6107}}, "n3337": {"so_31796349_31796446_0": {"length": 27, "quality": 1.0, "section_id": 5873}}, "n4659": {"so_31796349_31796446_0": {"length": 27, "quality": 1.0, "section_id": 7604}}}, "31796606": {"Id": "31796606", "PostTypeId": "2", "Body": "<p>The order is sort of relevant because the order of destructors is opposite of the declaration order. However, it is actually \"lucky\" that it even works for pa1, since deleting objects of abstact class type with non-virtual destructor causes undefined behaviour. One always needs to add a virtual destructor for abstract classes. </p>\n", "LastActivityDate": "2015-08-03T20:55:47.453", "CommentCount": "0", "CreationDate": "2015-08-03T20:55:47.453", "ParentId": "31796349", "Score": "0", "OwnerUserId": "5186984"}});