post_cb({"44338584": {"CommentCount": "0", "ViewCount": "174", "CreationDate": "2017-06-02T23:09:32.290", "LastActivityDate": "2017-06-03T02:16:00.307", "Title": "Deduction guide and variadic templates", "AcceptedAnswerId": "44339464", "PostTypeId": "1", "Id": "44338584", "Score": "8", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;tuple&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt;\nstruct custom_wrapper\n{\n    template &lt;class Arg&gt;\n    custom_wrapper(Arg arg): data(arg) {}\n    T data;\n};\n\ntemplate &lt;class Arg&gt;\ncustom_wrapper(Arg arg) -&gt; custom_wrapper&lt;Arg&gt;;\n\ntemplate &lt;class... T&gt;\nstruct custom_tuple\n{\n    template &lt;class... Args&gt;\n    custom_tuple(Args... args): data(args...) {}\n    std::tuple&lt;T...&gt; data;\n};\n\ntemplate &lt;class... Args&gt;\ncustom_tuple(Args... args) -&gt; custom_tuple&lt;Args...&gt;;\n\nint main(int argc, char* argv[])\n{\n    custom_wrapper&lt;int&gt; w1(42);  // OK\n    custom_wrapper w2(42);       // OK\n    custom_tuple&lt;int&gt; t1(42);    // OK\n    custom_tuple t2(42);         // Fails\n    return 0;\n}\n</code></pre>\n<p>The line that fails return the following error under g++7:</p>\n<pre><code>variadic_deduction_guide.cpp: In instantiation of 'custom_tuple&lt;T&gt;::custom_tuple(Args ...) [with Args = {int}; T = {}]':\nvariadic_deduction_guide.cpp:31:23:   required from here\nvariadic_deduction_guide.cpp:19:45: error: no matching function for call to 'std::tuple&lt;&gt;::tuple(int&amp;)'\n     custom_tuple(Args... args): data(args...) {}\n</code></pre>\n<p>Is that normal or is that a compiler bug?</p>\n", "Tags": "<c++><g++><tuples><c++1z><deduction-guide>", "OwnerUserId": "882932", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_44338584_44339464_0": {"section_id": 286, "quality": 1.0, "length": 30}, "so_44338584_44339464_1": {"section_id": 603, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_44338584_44339464_0": {"section_id": 277, "quality": 1.0, "length": 30}, "so_44338584_44339464_1": {"section_id": 593, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_44338584_44339464_0": {"section_id": 293, "quality": 1.0, "length": 30}, "so_44338584_44339464_1": {"section_id": 629, "quality": 0.9090909090909091, "length": 10}}}, "44339464": {"ParentId": "44338584", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>This is <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=80871\" rel=\"nofollow noreferrer\">gcc bug 80871</a>. What follows is an explanation of why the code is well-formed (and clang is correct in deciding that <code>t2</code> is a <code>custom_tuple&lt;int&gt;</code>).</p>\n<hr/>\n<p>The process for figuring out what to do with</p>\n<pre><code>custom_tuple t2(42);\n</code></pre>\n<p>basically involves synthesizing a bunch of functions and performing overload resolution on them. The relevant candidates are the synthesized functions from the one constructor and the deduction guide:</p>\n<pre><code>template &lt;class... T, class... Args&gt;\ncustom_tuple&lt;T...&gt; foo(Args... );     // the constructor\n\ntemplate &lt;class... Args&gt;\ncustom_tuple&lt;Args...&gt; foo(Args... );  // the deduction guide\n</code></pre>\n<p>From this point it's a choose your own adventure based on your interpretation of what a \"trailing parameter pack\" is according to <a href=\"http://eel.is/c++draft/temp.arg.explicit#3\" rel=\"nofollow noreferrer\">[temp.arg.explicit]/3</a>:</p>\n<blockquote>\n<p id=\"so_44338584_44339464_0\">A trailing template parameter pack not otherwise deduced will be deduced to an empty sequence of template arguments. If all of the template arguments can be deduced, they may all be omitted; in this case, the empty template argument list <code>&lt;&gt;</code> itself may also be omitted.</p>\n</blockquote>\n<p><strong><code>T...</code> isn't trailing</strong></p>\n<p>This case is easy. We only have one viable candidate (because <code>T...</code> isn't deducible) - the deduction-guide candidate. We deduce <code>Args...</code> as <code>{int}</code>, so we end up with <code>custom_tuple&lt;int&gt;</code>. </p>\n<p><strong><code>T...</code> is trailing</strong></p>\n<p>Both gcc and clang actually do consider deduction to succeed for the constructor. So we go to the tiebreakers in <a href=\"http://eel.is/c++draft/over.match.best\" rel=\"nofollow noreferrer\">[over.match.best]</a>:</p>\n<blockquote>\n<p id=\"so_44338584_44339464_1\">Given these definitions, a viable function <code>F1</code> is defined to be a <em>better</em> function than another viable function <code>F2</code> if [...]  </p>\n<ul>\n<li><code>F1</code> and <code>F2</code> are function template specializations, and the function template for <code>F1</code> is more specialized than the template for <code>F2</code> according to the partial ordering rules described in [temp.func.order], or, if not that,  </li>\n<li><code>F1</code> is generated from a deduction-guide ([over.match.class.deduct]) and <code>F2</code> is not, or, if not that, [...]</li>\n</ul>\n</blockquote>\n<p>For purposes of partial ordering, the <a href=\"https://timsong-cpp.github.io/cppwp/temp.deduct.partial#3.1\" rel=\"nofollow noreferrer\">relevant types</a> are just those which correspond to function parameters, and we're allowed to <a href=\"https://timsong-cpp.github.io/cppwp/temp.deduct.partial#12\" rel=\"nofollow noreferrer\">ignore unused template parameters</a>, so neither function template is considered more specialized than the other.</p>\n<p>This leaves us to simply preferring the deduction-guide, which has been the simplest step of this whole process. We deduce <code>Args...</code> as <code>{int}</code>, so we end up with <code>custom_tuple&lt;int&gt;</code>. </p>\n<hr/>\n<p>Either way, <code>custom_tuple&lt;int&gt;</code> is the correct decision. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2017-06-03T02:16:00.307", "Id": "44339464", "Score": "3", "CreationDate": "2017-06-03T01:43:58.797", "LastActivityDate": "2017-06-03T02:16:00.307"}});