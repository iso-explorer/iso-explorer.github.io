post_cb({"18370694": {"ViewCount": "726", "Body": "<p>I was wondering how strings and memory work together. <p> As far as I'm aware, I know that when a string is created, it puts some array of characters + '\\0' into memory. I also know that they're immutable. So for things like concatenation, what happens in memory that allows you to access the same string? <p>I don't imagine that the string or character you concatenated is put directly after the addresses of the original strings because that might overlap some needed memory. <p> In C# and other languages, you can say: <p><code>string s = \"Hello\"</code> <code>...</code> <code>s = s + '!'</code> <p>\nWould this be creating a new string? One that is pointing to a new location that says \"Hello!\", leaving the original never to be referenced?</p>\n<p>Or is there a default char buffer that strings use that allows for some space in concatenation?</p>\n</p></p></p></p></p>", "AcceptedAnswerId": "18370811", "Title": "How are concatenated strings allocated?", "CreationDate": "2013-08-22T02:23:48.360", "Id": "18370694", "CommentCount": "2", "LastEditDate": "2013-08-22T17:56:59.700", "PostTypeId": "1", "LastEditorUserId": "204390", "LastActivityDate": "2013-08-22T17:56:59.700", "Score": "0", "OwnerUserId": "2697944", "Tags": "<c++><string><memory><concatenation>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_18370694_18371156_12": {"length": 12, "quality": 1.0, "section_id": 1569}, "so_18370694_18371156_10": {"length": 5, "quality": 0.7142857142857143, "section_id": 1585}, "so_18370694_18371156_14": {"length": 4, "quality": 1.0, "section_id": 1569}, "so_18370694_18371156_8": {"length": 32, "quality": 0.6808510638297872, "section_id": 1729}, "so_18370694_18371156_2": {"length": 8, "quality": 0.6153846153846154, "section_id": 1588}}, "n3337": {"so_18370694_18371156_12": {"length": 12, "quality": 1.0, "section_id": 1565}, "so_18370694_18371156_14": {"length": 4, "quality": 1.0, "section_id": 1565}, "so_18370694_18371156_10": {"length": 5, "quality": 0.7142857142857143, "section_id": 1581}, "so_18370694_18371156_2": {"length": 8, "quality": 0.6153846153846154, "section_id": 1584}, "so_18370694_18371156_8": {"length": 32, "quality": 0.6808510638297872, "section_id": 1723}}, "n4659": {"so_18370694_18371156_12": {"length": 12, "quality": 1.0, "section_id": 1718}, "so_18370694_18371156_14": {"length": 4, "quality": 1.0, "section_id": 1718}, "so_18370694_18371156_10": {"length": 5, "quality": 0.7142857142857143, "section_id": 1737}, "so_18370694_18371156_8": {"length": 32, "quality": 0.6808510638297872, "section_id": 1892}}}, "18371156": {"Id": "18371156", "PostTypeId": "2", "Body": "<p>The behavior for the expression you're questioning is well-defined by the standard and is required for implementations to follow. The relevant sections of the standard are as follows:</p>\n<p><strong>C++11 \u00a7 21.4.8.1-11</strong></p>\n<pre><code>template&lt;class charT, class traits, class Allocator&gt; \n    basic_string&lt;charT,traits,Allocator&gt;\noperator+(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,\n          const charT* rhs);\n</code></pre>\n<blockquote>\n<p id=\"so_18370694_18371156_0\">Returns: <code>lhs + basic_string&lt;charT,traits,Allocator&gt;(rhs)</code></p>\n</blockquote>\n<p>This leads to:</p>\n<p><strong>C++11 \u00a7 21.4.8.1-3</strong></p>\n<pre><code>template&lt;class charT, class traits, class Allocator&gt;\n    basic_string&lt;charT,traits,Allocator&gt;\noperator+(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,\n          basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);\n</code></pre>\n<blockquote>\n<p id=\"so_18370694_18371156_1\">Returns: <code>std::move(rhs.insert(0, lhs))</code></p>\n</blockquote>\n<p>and finally...</p>\n<p><strong>C++11 \u00a7 21.4.2-22</strong></p>\n<pre><code>basic_string&lt;charT,traits,Allocator&gt;&amp;\n  operator=(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; str) noexcept;\n</code></pre>\n<blockquote>\n<p id=\"so_18370694_18371156_2\">Effects: If *this and str are not the same object, modifies *this as\n  shown in Table 71. [Note: A valid implementation is swap(str). \u2014 end\n  note ]</p>\n</blockquote>\n<p>In other words, a temporary is created for the rhs of the <code>+</code> operator, that rvalue-reference is then modified using <code>rhs.insert(0,lhs)</code>, and finally, the results are sent to the rvalue-reference version of the assignment operator, which can validly perform a move operation.</p>\n<p>See the relevant sections of the standard for more info.</p>\n<hr>\n<p><strong>C++03x Notes</strong></p>\n<p>It has been requested I provide the same walk-through for C++03x. I'm not positive as to the last(official) rev of the standard, but for reference the following is based on ISO/IEC 14882:2003(E). Use at your own discretion.</p>\n<p>A similar walk-through is also wall defined for C++03x, as described below with relevant sections of the standard duly noted.</p>\n<p><strong>C++03x \u00a7 21.3.7.1-5</strong></p>\n<pre><code>template&lt;class charT, class traits, class Allocator&gt;\n             basic_string&lt;charT,traits,Allocator&gt;\noperator+(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs, const charT* rhs);\n</code></pre>\n<blockquote>\n<p id=\"so_18370694_18371156_3\">Returns: <code>lhs + basic_string&lt;charT,traits,Allocator&gt;(rhs)</code></p>\n</blockquote>\n<p>So like C++11, a temporary is constructed from the <em>rhs</em> of the expression. From there...</p>\n<p><strong>C++03x \u00a7 21.3.7.1-1</strong></p>\n<pre><code>template&lt;class charT, class traits, class Allocator&gt;\n             basic_string&lt;charT,traits,Allocator&gt;\noperator+(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs, \n          const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs);\n</code></pre>\n<blockquote>\n<p id=\"so_18370694_18371156_4\">Returns: basic_string(lhs).append(rhs)</p>\n</blockquote>\n<p>Here we differ from C++11. We construct a temporary of the <em>lhs</em>, then append the given <em>rhs</em> (the temporary from the first step) using the <code>append()</code> member function. I'm omitting the const-reference constructor for the temporary of the <em>lhs</em> for brevity. This takes us to....</p>\n<p><strong>C++03x \u00a7 21.3.5.2-1</strong></p>\n<pre><code>basic_string&lt;charT,traits,Allocator&gt;&amp;\n  append(const basic_string&lt;charT,traits&gt;&amp; str);\n</code></pre>\n<blockquote>\n<p id=\"so_18370694_18371156_5\">Returns: <code>append(str, 0, npos)</code></p>\n</blockquote>\n<p>This forwards the call to the related member function that accepts the starting and stopping indexes from the rhs from which to enumerate. This takes us to...</p>\n<p><strong>C++03x \u00a7 21.3.5.2-2..5</strong>\n    basic_string&amp;\n      append(const basic_string&amp; str, size_type pos, size_type n);</p>\n<blockquote>\n<p id=\"so_18370694_18371156_6\">Requires: pos &lt;= str.size()</p>\n<p id=\"so_18370694_18371156_7\">Throws: out_of_range if pos &gt; str.size().</p>\n<p id=\"so_18370694_18371156_8\">Effects: Determines the effective length rlen of the string to append as the smaller of n and str.size() - pos. The function then throws length_error if size() &gt;= npos - rlen. Otherwise, the function replaces the string controlled by *this with a string of length size() + rlen whose first size() elements are a copy of the original string controlled by *this and whose remaining elements are a copy of the initial elements of the string controlled by str beginning at position pos.</p>\n<p id=\"so_18370694_18371156_9\">Returns: *this.</p>\n</blockquote>\n<p>Essentially this does some sanity checks on the positional parameters, then performs the replacement with concatenated content. And finally, now that are finished rhs of the assignment is complete, we can perform the assignment operation to the target of this whole fiasco, which takes us to...</p>\n<p><strong>C++03x \u00a7 21.3.1-16</strong></p>\n<pre><code>basic_string&lt;charT,traits,Allocator&gt;&amp;\n  operator=(const basic_string&lt;charT,traits,Allocator&gt;&amp; str);\n</code></pre>\n<blockquote>\n<p id=\"so_18370694_18371156_10\">Effects: If *this and str are not the same object, modifies *this as shown in Table-43</p>\n<p id=\"so_18370694_18371156_11\">Returns: *this</p>\n</blockquote>\n<p>Table-43 denotes the following required effects.</p>\n<blockquote>\n<p id=\"so_18370694_18371156_12\"><code>data()</code> -  points to the first element of an allocated copy of the array whose first element is pointed at by the <code>str.data()</code></p>\n<p id=\"so_18370694_18371156_13\"><code>size()</code> -  <code>str.size()</code></p>\n<p id=\"so_18370694_18371156_14\"><code>capacity()</code> - At least as large as <code>size()</code></p>\n</blockquote>\n<p>My assessment of that is the implementation can do what it wants to achieve those effects (in Table 43; the path of implementation as shown here is still required).</p>\n<p>I'm too tired to drive into C++98. I hope this is enough.</p>\n</hr>", "LastEditorUserId": "1322972", "LastActivityDate": "2013-08-22T17:09:44.643", "Score": "4", "CreationDate": "2013-08-22T03:23:11.770", "ParentId": "18370694", "CommentCount": "5", "OwnerUserId": "1322972", "LastEditDate": "2013-08-22T17:09:44.643"}, "18370798": {"Id": "18370798", "PostTypeId": "2", "Body": "<p>Up to C++11, it was implementation-dependent.  However, libraries had (and still have) a much better chance of optimizing when you use <code>+=</code> than when you use <code>+</code> .  The big difference is that C++11 now specifies (and mandates) these optimizations.</p>\n<p>The general rule (with past, present, and future specifications of the language and even  similar languages) is:  always prefer</p>\n<pre><code>s+= \"!\" ;\n</code></pre>\n<p>in place of the example code you used.</p>\n<p>The reason is that <code>string</code>s are not language primitives.  They are just another \"user\" type (that happens to come with the compiler, but that's another story).  When you write</p>\n<pre><code>s = s + \"!\" ;\n</code></pre>\n<p>the <code>+</code> method of class <code>string</code> is invoked.  However, it is forced to create a new object (maybe sharing some storage with <code>s</code>), because you could have used it in this other context:</p>\n<pre><code>t = s + \"!\" ;\n</code></pre>\n<p>Conversely, the <code>+=</code> method can be sure you want to append to the current string, and thus optimize a bit (example:  use available space in an internal buffer).</p>\n", "LastEditorUserId": "2544089", "LastActivityDate": "2013-08-22T16:41:28.940", "Score": "0", "CreationDate": "2013-08-22T02:35:53.910", "ParentId": "18370694", "CommentCount": "6", "OwnerUserId": "2544089", "LastEditDate": "2013-08-22T16:41:28.940"}, "18370811": {"Id": "18370811", "PostTypeId": "2", "Body": "<p>As pointed out in the comments, <code>std::string</code> isn't immutable.</p>\n<p>When using the + operator with strings, as in <code>s + '!'</code>, a new temporary string is created which contains the result. <code>s = s + '!'</code> copies this temporary string back into the original <code>s</code>, replacing the original text. This is how immutable strings work in other languages.</p>\n<p>When you use += operator or append function, the string is modified and the extra characters are added to the same string object. However, internally a new memory buffer may be allocated if the old one isn't big enough. When reallocating, some extra space is usually requested to allow small future appends without reallocating (more efficient). You can optionally increase the minimum size of the internal buffer with the reserve function. This is more efficient if you know how much data you will append.</p>\n", "LastActivityDate": "2013-08-22T02:37:14.297", "CommentCount": "8", "CreationDate": "2013-08-22T02:37:14.297", "ParentId": "18370694", "Score": "2", "OwnerUserId": "2068573"}});