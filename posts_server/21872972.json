post_cb({"bq_ids": {"n4140": {"so_21872972_21873375_1": {"length": 31, "quality": 0.9393939393939394, "section_id": 3913}}, "n3337": {"so_21872972_21873375_1": {"length": 31, "quality": 0.9393939393939394, "section_id": 3773}}}, "21873347": {"Id": "21873347", "PostTypeId": "2", "Body": "<p>The return type of <code>bar</code> is <code>Foo</code>. There is no copy constructor, and an explicit move constructor cannot work because an <em>implicit conversion</em> between <code>Foo&amp;&amp;</code> and <code>Foo</code> is still required. In this sense, <code>explicit Foo(Foo&amp;&amp;)</code> is no different to any other <code>explicit</code> converting constructor. The problem wold still occur with a conversion from a different type. This is an analogous example using <code>int</code>:</p>\n<pre><code>struct Foo\n{\n    explicit Foo(int) {}\n};\n\nFoo bar ( void )\n{\n    return 42; // error: could not convert '42' from 'int' to 'Foo'\n}\n</code></pre>\n<p><strong>Q1</strong>: Because there is nothing else it can use.</p>\n<p><strong>Q2</strong>: Because it uses the move constructor to implicitly convert from <code>Foo&amp;&amp;</code> to <code>Foo</code>.</p>\n<p><strong>Q3</strong>: It means the same as it does with plain converting constructors.</p>\n", "CommentCount": "6", "LastEditorUserId": "661519", "LastActivityDate": "2014-02-19T08:09:18.780", "CreationDate": "2014-02-19T07:02:33.567", "ParentId": "21872972", "Score": "6", "OwnerUserId": "661519", "LastEditDate": "2014-02-19T08:09:18.780"}, "21873375": {"Id": "21873375", "PostTypeId": "2", "Body": "<p>It is because returning a value is considered an <a href=\"http://en.cppreference.com/w/cpp/language/implicit_cast\" rel=\"nofollow\">implicit conversion</a>.</p>\n<p>Quoting from the C++11 standard:</p>\n<blockquote>\n<h3>6.6.3 The return statement</h3>\n<p id=\"so_21872972_21873375_0\"><sup>2</sup> [...]</p>\n<p id=\"so_21872972_21873375_1\">A return statement with an expression of non-void type can be used only in functions returning a value; the value of the expression is returned to the caller of the function. <strong>The value of the expression is implicitly converted to the return type of the function in which it appears.</strong> A return statement can involve the construction and copy or move of a temporary object (12.2). [...]</p>\n</blockquote>\n<p>The conversion from the return expression to the temporary object to hold the return value is implicit. So just as this would result in an error</p>\n<pre><code>Foo f = Foo();   // Copy initialization, which means implicit conversion\n</code></pre>\n<p>having code as your example would also trigger a similar one.</p>\n<hr>\n<blockquote>\n<p id=\"so_21872972_21873375_2\">Question 1: Why does the compiler need the copy-ctor of Foo? I expected the return value of bar to be constructed from the rvalue Foo() with move-ctor.</p>\n</blockquote>\n<p>It is because <code>Foo(Foo&amp;&amp;)</code> is not a viable overload, because of the reasons above. The rules state that whenever the move constructor cannot be used, it is when the compiler shall then consider the copy constructor, which, in your case, is implicitly deleted due to the presence of a user-defined move constructor.</p>\n<blockquote>\n<p id=\"so_21872972_21873375_3\">Question 2: Why the compiler does not need copy-ctor any more when I redeclare the move-ctor as implicit?</p>\n</blockquote>\n<p>It is because your move constructor can be used now. Thus, the compiler can immediately use it without even considering the presence of the copy constructor.</p>\n<blockquote>\n<p id=\"so_21872972_21873375_4\">Question 3: What does explicit keyword mean in the context of copy and move ctors as it definitely means something different from from the context of regular ctors.</p>\n</blockquote>\n<p>IMHO, it doesn't make sense, and it only leads to problems, just as in your case.</p>\n</hr>", "CommentCount": "0", "LastEditorUserId": "1619294", "LastActivityDate": "2014-02-19T07:32:58.247", "CreationDate": "2014-02-19T07:03:40.890", "ParentId": "21872972", "Score": "8", "OwnerUserId": "1619294", "LastEditDate": "2014-02-19T07:32:58.247"}, "21872972": {"ViewCount": "843", "Body": "<p>Trying to compile the following code:</p>\n<pre><code>struct Foo\n{\n    explicit Foo ( void ) { }\n    explicit Foo ( Foo&amp;&amp; rhs ) { }\n};\n\nFoo bar ( void )\n{\n    return Foo();\n}\n</code></pre>\n<p>Getting the following error:</p>\n<blockquote>\n<p id=\"so_21872972_21872972_0\">call to implicitly-deleted copy constructor of 'Foo'</p>\n</blockquote>\n<p>Well, it's quite obvious that the copy-ctor is implicitly deleted.</p>\n<p><strong>Question 1:</strong> Why does the compiler need the copy-ctor of <code>Foo</code>? I expected the return value of <code>bar</code> to be constructed from the rvalue <code>Foo()</code> with move-ctor.</p>\n<p>Then I redeclare the move-ctor as implicit and everything compiles successfully.</p>\n<p><strong>Question 2:</strong> Why the compiler does not need copy-ctor any more when I redeclare the move-ctor as implicit?</p>\n<p><strong>Question 3:</strong> What does <code>explicit</code> keyword mean in the context of copy and move ctors as it definitely means something different from from the context of regular ctors.</p>\n", "AcceptedAnswerId": "21873375", "Title": "Explicit move constructor", "CreationDate": "2014-02-19T06:40:19.230", "Id": "21872972", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-08-19T06:00:20.160", "LastEditorUserId": "1619294", "LastActivityDate": "2014-08-19T06:00:20.160", "Score": "8", "OwnerUserId": "1574294", "Tags": "<c++><c++11><constructor><move-constructor><c++14>", "AnswerCount": "3"}, "21874235": {"PostTypeId": "2", "Body": "<p>This has to do with how overload resolution works in C++.</p>\n<p>The first step of overload resolution is to form a set of <em>candidate functions</em>. The second step is to narrow the set of candidate functions down to a set of <em>viable functions</em>. The third step is to select the unique <em>best viable function</em>, if there is one. If the best viable function is deleted, then the program is ill-formed.</p>\n<p>Because the move constructor is declared <code>explicit</code>, it is <strong>not a candidate function</strong> for the implicit conversion of <code>Foo()</code> to the return type of the function. The only candidate function is <code>Foo::Foo(const Foo&amp;)</code>, the implicitly declared copy constructor. <strong>This is a candidate function even though it is declared as deleted</strong>. It is selected by overload resolution, being the only viable function; and then you get an error for trying to call a deleted function.</p>\n<p>If you don't declare the move constructor <code>explicit</code>, then <em>both</em> the move constructor and the implicitly declared copy constructor are candidate functions. Both will also be viable in this case. However, the move constructor wins overload resolution because rvalues prefer to bind to rvalue references over const lvalue references. Therefore the move constructor is the <em>best viable function</em>. In this case it doesn't matter that the copy constructor is deleted, because it loses in overload resolution.</p>\n<p>tl;dr:</p>\n<p><strong>Answer 1</strong>: Because the move constructor is not a <em>candidate function</em> for the conversion.</p>\n<p><strong>Answer 2</strong>: Because the move constructor is a candidate function, and wins overload resolution.</p>\n<p><strong>Answer 3</strong>: Nope, it means the same thing.</p>\n", "LastActivityDate": "2014-02-19T07:51:07.037", "Id": "21874235", "CommentCount": "0", "CreationDate": "2014-02-19T07:51:07.037", "ParentId": "21872972", "Score": "1", "OwnerUserId": "481267"}});