post_cb({"bq_ids": {"n4140": {"so_20011851_20011912_1": {"length": 9, "quality": 0.9, "section_id": 2356}}, "n3337": {"so_20011851_20011912_1": {"length": 9, "quality": 0.9, "section_id": 2341}}, "n4659": {"so_20011851_20011912_1": {"length": 9, "quality": 0.9, "section_id": 2631}}}, "20011851": {"ViewCount": "2986", "Body": "<p>I can't tell from the documentation how <code>std::stringstream.read()</code> works. Does it consume the stream or not?</p>\n<p>In other words:</p>\n<pre><code>std::stringstream ss;\nchar buffer[6];\n\nss &lt;&lt; \"Hello world!\";\nss.read(buffer, 6);\n\nstd::cout &lt;&lt; ss.str(); // Is this \"Hello world!\" or just \"world!\"\n</code></pre>\n", "AcceptedAnswerId": "20011912", "Title": "Does stringstream.read() consume the stream?", "CreationDate": "2013-11-15T22:38:32.933", "Id": "20011851", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2014-04-17T15:49:14.340", "Score": "2", "OwnerUserId": "2105930", "Tags": "<c++><stringstream>", "AnswerCount": "3"}, "23137539": {"Id": "23137539", "PostTypeId": "2", "Body": "<p>Yes it consumes the stream.<br>\nHowever str() function returns complete string in buffer.<br>\nYou can use ss.rdbuf()-&gt;in_avail() to get size of data available after read/&gt;&gt; operations:</br></br></p>\n<pre><code>ss &lt;&lt; \"Hello world!\";\nss.read(buffer, 6);\n\nstd::cout &lt;&lt; ss.rdbuf()-&gt;in_avail(); // 6 characters available (\"world!\").\n</code></pre>\n", "LastEditorUserId": "1223728", "LastActivityDate": "2014-04-17T15:49:14.340", "Score": "1", "CreationDate": "2014-04-17T15:42:10.330", "ParentId": "20011851", "CommentCount": "0", "LastEditDate": "2014-04-17T15:49:14.340", "OwnerUserId": "1223728"}, "20011912": {"Id": "20011912", "PostTypeId": "2", "Body": "<p>The member <code>std::istream::read()</code> advances the stream position for as many characters it returns. I guess, this is what you mean with \"consuming the stream\". After reading 6 characters from <code>ss</code>, the next character read will be the <code>w</code>.</p>\n<p>However, the string stream's internal buffer is still the entire string, i.e., the result of <code>str()</code> is unaffected by the read position: <code>std::stringstream::str()</code> returns all characters. In 27.8.2.3 [stringbuf.members] paragraph 1 it says:</p>\n<blockquote>\n<p id=\"so_20011851_20011912_0\"><code>basic_string&lt;charT,traits,Allocator&gt; str() const;</code></p>\n<p id=\"so_20011851_20011912_1\">Returns: A basic_string object whose content is equal to the basic_stringbuf underlying character sequence. ...</p>\n</blockquote>\n<p>The paragraph goes on describing what the underlying character sequence is but it amounts to: the entire original string in input mode and the original characters plus additional written characters in output mode.</p>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2013-11-15T22:52:36.573", "Score": "5", "CreationDate": "2013-11-15T22:43:54.217", "ParentId": "20011851", "CommentCount": "3", "LastEditDate": "2013-11-15T22:52:36.573", "OwnerUserId": "1120273"}, "20011874": {"Id": "20011874", "PostTypeId": "2", "Body": "<p><code>read</code> is an unformmatted input function; it extracts a specified amount of characters from the internal buffer into the byte array that you supply. In this case, it extracts 6 characters from the buffer into <code>buffer</code>. So the content of <code>buffer</code> will be <code>\"Hello \"</code>.</p>\n<p>The opposite goes for <code>write</code>. <code>write</code> will insert a specified amount of characters from the supplied byte array into the internal buffer of the output stream.</p>\n", "LastEditorUserId": "701092", "LastActivityDate": "2013-11-15T22:46:14.810", "Score": "-1", "CreationDate": "2013-11-15T22:41:00.980", "ParentId": "20011851", "CommentCount": "0", "LastEditDate": "2013-11-15T22:46:14.810", "OwnerUserId": "701092"}});