post_cb({"bq_ids": {"n4140": {"so_13466556_14557329_1": {"length": 18, "quality": 0.5806451612903226, "section_id": 40}, "so_13466556_14557329_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 6092}, "so_13466556_14557329_3": {"length": 36, "quality": 1.0, "section_id": 6039}, "so_13466556_14557329_2": {"length": 29, "quality": 0.9354838709677419, "section_id": 6030}}, "n3337": {"so_13466556_14557329_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 5859}, "so_13466556_14557329_1": {"length": 30, "quality": 0.967741935483871, "section_id": 37}, "so_13466556_14557329_3": {"length": 36, "quality": 1.0, "section_id": 5807}, "so_13466556_14557329_2": {"length": 30, "quality": 0.967741935483871, "section_id": 5798}}, "n4659": {"so_13466556_14557329_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 7588}, "so_13466556_14557329_3": {"length": 26, "quality": 0.7222222222222222, "section_id": 7538}}}, "13466556": {"ViewCount": "1103", "Body": "<p>I'm currently using aligned_storage to implement an 'Optional' type similar to that of boost::optional. To accomplish this I have a class member like so:</p>\n<pre><code>typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type t_;\n</code></pre>\n<p>I use placement new to create the object, however I don't store the pointer returned anywhere. Instead, I access the underlying type of the object in all my member functions like this (obviously with checks to ensure the object is valid via a boolean flag also stored in my Optional type):</p>\n<pre><code>T const* operator-&gt;() const {\n    return static_cast&lt;T const*&gt;(static_cast&lt;void const*&gt;(&amp;t_));\n}\n</code></pre>\n<p>My question is whether this is safe. My understanding is that my usage of placement new changes the 'dynamic type' of the object, and as long as I keep accessing the memory using that type I'll be okay. However I'm not clear on whether I have to hold the pointer returned from the placement new or whether I'm allowed to just cast to the underlying type whenever I need to access it. I have read section 3.10 of the C++11 standard, however I'm not fluent enough in standardese to be sure.</p>\n<p>If possible, I would feel better if you could give reference to the standard in your answer (it helps me sleep at night :P).</p>\n", "AcceptedAnswerId": "14557329", "Title": "aligned_storage and strict aliasing", "CreationDate": "2012-11-20T04:20:19.587", "Id": "13466556", "CommentCount": "2", "FavoriteCount": "9", "PostTypeId": "1", "LastEditDate": "2016-09-10T19:30:34.483", "LastEditorUserId": "3614835", "LastActivityDate": "2016-09-10T19:30:34.483", "Score": "23", "OwnerUserId": "75002", "Tags": "<c++><undefined-behavior><language-lawyer><strict-aliasing><type-punning>", "AnswerCount": "1"}, "14557329": {"Id": "14557329", "PostTypeId": "2", "Body": "<p>ABICT your use is safe.</p>\n<ul>\n<li>Placement new of an object of type T will create an object starting at the address passed in. </li>\n</ul>\n<p>\u00a75.3.4/10 says:</p>\n<blockquote>\n<p id=\"so_13466556_14557329_0\">A new-expression passes the amount of space requested to the\n  allocation function as the first argument of type std::size_t. That\n  argument shall be no less than the size of the object being created;\n  it may be greater than the size of the object being created only if\n  the object is an array.</p>\n</blockquote>\n<p>For a non-array object, the size allocated cannot be greater that the size of the object, so the object representation must start at the beginning of the allocated memory in order to fit.</p>\n<p>Placement new returns the pointer passed in (see \u00a7 18.6.1.3/2) as the result of the \"allocation\", so the object representation of the constructed object will start at that address.</p>\n<ul>\n<li>static_cast&lt;&gt; and implicit conversions between <code>T*</code> type and <code>void*</code> convert between a pointer to the object and a pointer to its storage, if the object is a complete object.</li>\n</ul>\n<p>\u00a74.10/2 says:</p>\n<blockquote>\n<p id=\"so_13466556_14557329_1\">A prvalue of type \u201cpointer to cv T,\u201d where T is an object type, can be\n  converted to a prvalue of type \u201cpointer to cv void\u201d. The result of\n  converting a \u201cpointer to cv T\u201d to a \u201cpointer to cv void\u201d points to the\n  start of the storage location where the object of type T resides, as\n  if the object is a most derived object (1.8) of type T [...]</p>\n</blockquote>\n<p>This defines the implicit conversion to convert as stated. Further \u00a75.2.9[expr.static.cast]/4 defines static_cast&lt;&gt; for explicit conversions, where an implicit conversion exists to have the same effect as the implicit conversion:</p>\n<blockquote>\n<p id=\"so_13466556_14557329_2\">Otherwise, an expression <code>e</code> can be explicitly converted to a type <code>T</code>\n  using a <code>static_cast</code> of the form <code>static_cast&lt;T&gt;(e)</code> if the declaration\n  <code>T t(e);</code> is well-formed, for some invented temporary variable <code>t</code> (8.5).\n  The effect of such an explicit conversion is the same as performing\n  the declaration and initialization and then using the temporary\n  variable as the result of the conversion. [...]</p>\n</blockquote>\n<p>For the inverse static_cast&lt;&gt; (from <code>void*</code> to <code>T*</code>), \u00a75.2.9/13 states:</p>\n<blockquote>\n<p id=\"so_13466556_14557329_3\">A prvalue of type \u201cpointer to cv1 void\u201d can be converted to a prvalue\n  of type \u201cpointer to cv2 T,\u201d where T is an object type and cv2 is the\n  same cv-qualification as, or greater cv-qualification than, cv1. [...]\n  A value of type pointer to object converted to \u201cpointer to cv void\u201d\n  and back, possibly with different cv-qualification, shall have its\n  original value.</p>\n</blockquote>\n<p>So if you have a <code>void*</code> pointing to the storage of the <code>T</code> object (which is the pointer value that would result from the implicit conversion of a <code>T*</code> to the object, then a <code>static_cast</code> of that to a <code>T*</code> will produce a valid pointer to the object.</p>\n<p>Returning to your question, the preceding points imply that if you have</p>\n<pre><code>typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type t_;\nvoid * pvt_ = &amp;t_;\n\nT* pT = new (&amp;t_) T(args...);\nvoid * pvT = pT;\n</code></pre>\n<p>then </p>\n<ul>\n<li>the storage of <code>*pT</code> exactly overlays the first size(T) bytes of the storage of <code>t_</code>, so that <code>pvT == pvt_</code></li>\n<li><code>pvt_ == static_cast&lt;void*&gt;(&amp;t_)</code></li>\n<li><code>static_cast&lt;T*&gt;(pvT) == pT</code></li>\n<li>Taken together that yields <code>static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(&amp;t_)) == pT</code></li>\n</ul>\n", "LastActivityDate": "2013-01-28T07:25:18.593", "CommentCount": "4", "CreationDate": "2013-01-28T07:25:18.593", "ParentId": "13466556", "Score": "10", "OwnerUserId": "585729"}});