post_cb({"bq_ids": {"n4140": {"so_19311239_19311738_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 6138}, "so_19311239_19311738_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 17}}, "n3337": {"so_19311239_19311738_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 5902}, "so_19311239_19311738_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 14}}, "n4659": {"so_19311239_19311738_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 7635}, "so_19311239_19311738_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 8732}}}, "19311537": {"Id": "19311537", "PostTypeId": "2", "Body": "<p>The only things I know of is that if you are subtracting pointers, they have to be the same type and point to \"the same block of memory\" (two pointers to the same allocation and/or two pointers to the same array). It is also allowed to point \"one element beyond\" the allocation. Similarly, you can't add more than to one past the end of the block of memory.  </p>\n<p>It is undefined behaviour to use pointers across blocks of memory because of certain architectures having distinct memory regions, in such a way that a pointer to one region won't trivially (or at all) subtract from another pointer from another region (with a \"good\" outcome) - for example, OS/2 in 16-bit mode would have a segment register which holds a base-address for a memory region of up to 64KB. Another memory region would have another base-address, and the user-mode code can't get the base-address at all, so there is no way to subtract/add to a pointer to get outside of the region and still \"know where you are\". </p>\n<p>In MOST (now) commonly available architectures, it works just fine to do math for any address in the system, but it's by no means guaranteed by the standard. </p>\n", "LastActivityDate": "2013-10-11T06:22:25.927", "Score": "0", "CreationDate": "2013-10-11T06:22:25.927", "ParentId": "19311239", "CommentCount": "2", "OwnerUserId": "1919155"}, "19311239": {"ViewCount": "842", "Body": "<p>As per <a href=\"https://stackoverflow.com/q/3523145/1814023\">Pointer arithmetic for void pointer in C</a>, we can't do pointer arithmetic on <code>void</code> pointers.</p>\n<p>Also, we can't add, multiply or divide <code>two pointers</code> but we <code>can subtract two pointers</code>.</p>\n<p>As per <code>#6.5.6-2</code> - we can add a pointer and an <code>int</code> type.</p>\n<p>Are there any rules for doing pointer arithmetic?</p>\n", "Title": "Rules for doing pointer arithmetic", "CreationDate": "2013-10-11T06:00:40.003", "Id": "19311239", "CommentCount": "16", "LastEditDate": "2017-05-23T11:50:05.283", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2013-10-11T07:56:32.340", "Tags": "<c++><c><pointers>", "Score": "-1", "OwnerUserId": "2711579", "ClosedDate": "2013-10-11T10:30:39.203", "AnswerCount": "3"}, "19311669": {"Id": "19311669", "PostTypeId": "2", "Body": "<p>The pointer arithmetic is explained here :: </p>\n<p><a href=\"http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/BitOp/pointer.html\" rel=\"nofollow\">Pointer Arithmetic</a></p>\n<p>Thank you </p>\n<p>:::::: Some more explaination :::::::::</p>\n<p>Pointers and integers are not interchangeable. (except for 0.) We will have to treat arithmetic between a pointer and an integer, and arithmetic between two pointers, separately.</p>\n<p>Suppose you have a pointer to a long.</p>\n<pre><code>long *ptrlng;\n</code></pre>\n<p><em><strong>Binary Operations between a pointer and an integer</strong></em></p>\n<pre><code>1. ptrlng+n is valid, if n is an integer. The result is the following byte address\nptrlng + n*sizeof(long) and not ptrlng + n.\nIt advances the pointer by n number of longs.\n\n2 ptrlng-n is similar.\n</code></pre>\n<p>Consider two pointers ptr1 and ptr2 which point to the same type of data.</p>\n<pre><code>&lt;datatype&gt; *ptr1, *ptr2;\n</code></pre>\n<p><em><strong>Binary operations between two Pointers</strong></em></p>\n<pre><code>1.Surprise: Adding two pointers together is not allowed!\n2.ptr1 - ptr 2 is allowed, as long as they are pointing to elements of the same array. \nThe result is\n(ptr1 - ptr2)/sizeof(datatype)\n\nIn other settings, this operation is undefined (may or may not give the correct answer).\n</code></pre>\n<p>Why all these special cases? These rules for pointer arithmetic are intended to handle addressing inside arrays correctly.</p>\n<p>If we can subtract a pointer from another, all the relational operations can be supported!</p>\n<p><em><strong>Logical Operations on Pointers</strong></em></p>\n<pre><code>1. ptr1 &gt; ptr2 is the same as ptr1 - ptr2 &gt; 0,\n2. ptr1 = ptr2 is the same as ptr1 - ptr2 = 0,\n3. ptr1 &lt; ptr2 is the same as ptr1 - ptr2 &lt; 0,\n4. and so on.\n</code></pre>\n<p>Hope this helps.</p>\n", "LastEditorUserId": "2837437", "LastActivityDate": "2013-10-11T07:56:32.340", "Score": "-4", "CreationDate": "2013-10-11T06:30:41.163", "ParentId": "19311239", "CommentCount": "2", "LastEditDate": "2013-10-11T07:56:32.340", "OwnerUserId": "2837437"}, "19311738": {"Id": "19311738", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_19311239_19311738_0\">As per Pointer arithmetic for void pointer in C, we can't do pointer arithmetic on void pointers</p>\n</blockquote>\n<p>Correct, you cannot do that, as per C11 6.5.6/2:</p>\n<blockquote>\n<p id=\"so_19311239_19311738_1\">For addition, either both operands shall have arithmetic type, or one\n  operand shall be a pointer to a complete object type and the other\n  shall have integer type.</p>\n</blockquote>\n<p>A void pointer is a pointer to an incomplete type and none of the above.</p>\n<blockquote>\n<p id=\"so_19311239_19311738_2\">As per #6.5.6-2 - we can add a pointer and an int type.</p>\n</blockquote>\n<p>Indeed.</p>\n<blockquote>\n<p id=\"so_19311239_19311738_3\">Are there any rules for doing pointer arithmetic?</p>\n</blockquote>\n<p>Yes. Those are found in chapter 6.5.6 in the standard. </p>\n", "LastActivityDate": "2013-10-11T06:35:43.950", "Score": "3", "CreationDate": "2013-10-11T06:35:43.950", "ParentId": "19311239", "CommentCount": "1", "OwnerUserId": "584518"}});