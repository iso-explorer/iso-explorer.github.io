post_cb({"bq_ids": {"n4140": {"so_13780417_34093903_0": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_13780417_34093903_2": {"length": 11, "quality": 0.8461538461538461, "section_id": 3321}}, "n3337": {"so_13780417_34093903_0": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_13780417_34093903_2": {"length": 11, "quality": 0.8461538461538461, "section_id": 3191}}, "n4659": {"so_13780417_34093903_0": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_13780417_34093903_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 4087}}}, "13780417": {"ViewCount": "306", "Body": "<p>I noticed that assigning a <code>char</code> to a <code>const int&amp;</code> compiles, but assigning it to a <code>int&amp;</code> gives a compilation error. </p>\n<pre><code>char c;\nint&amp; x = c;    // this fails to compile\nconst int&amp; y = c;    // this is ok\n</code></pre>\n<p>I understand that it is not a good practice to do this, but I am curious to know the reason why it happens. </p>\n<p>I have searched for an answer by looking for \"assigning to reference of different type\", \"assigning char to a int reference\", and \"difference between const reference and non-const reference\", and came across a number of useful posts (<a href=\"https://stackoverflow.com/questions/4705593/int-vs-const-int\">int vs const int&amp;</a> , <a href=\"https://stackoverflow.com/questions/10716894/weird-behaviour-when-assigning-a-char-to-a-int-variable\">Weird behaviour when assigning a char to a int variable</a> , <a href=\"https://stackoverflow.com/questions/5029840/convert-char-to-int-in-c-and-c\">Convert char to int in C and C++</a> , <a href=\"https://stackoverflow.com/questions/1719818/difference-between-reference-and-const-reference-as-function-parameter\">Difference between reference and const reference as function parameter?</a>), but they do not seem to be addressing my question. </p>\n<p>My apologies if this has been already answered before.  </p>\n", "AcceptedAnswerId": "13780451", "Title": "assigning char to int reference and const int reference in C++", "CreationDate": "2012-12-08T18:21:09.143", "Id": "13780417", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:09:45.650", "LastEditorUserId": "-1", "LastActivityDate": "2015-12-04T17:18:34.320", "Score": "8", "OwnerUserId": "252576", "Tags": "<c++><reference><casting><const><c++03>", "AnswerCount": "3"}, "13780451": {"Id": "13780451", "PostTypeId": "2", "Body": "<pre><code>int&amp; x = c;\n</code></pre>\n<p>Here an implicit conversion from <code>char</code> to <code>int</code> is being performed by the compiler. The resulting temporary <code>int</code> can only be bound to a <code>const</code> reference. Binding to a <code>const int&amp;</code> will also extend the lifetime of the temporary result to match that of the reference it is bound to.</p>\n", "LastActivityDate": "2012-12-08T18:23:28.320", "Score": "7", "CreationDate": "2012-12-08T18:23:28.320", "ParentId": "13780417", "CommentCount": "1", "OwnerUserId": "241631"}, "34093921": {"Id": "34093921", "PostTypeId": "2", "Body": "<p>The fact that the line</p>\n<pre><code>const int&amp; y = c; \n</code></pre>\n<p>creates a temporary and <code>y</code> binds to the temporary can be verified by the following:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n   char c = 10;\n   const int&amp; y = c;\n\n   std::cout &lt;&lt; (int)c &lt;&lt; std::endl;\n   std::cout &lt;&lt; y &lt;&lt; std::endl;\n\n   c = 20;\n\n   std::cout &lt;&lt; (int)c &lt;&lt; std::endl;\n   std::cout &lt;&lt; y &lt;&lt; std::endl;\n\n   return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre class=\"lang-none prettyprint-override\"><code>10\n10\n20\n10\n</code></pre>\n<p>The value of <code>y</code> did not change when the value of <code>c</code> was changed.</p>\n", "LastActivityDate": "2015-12-04T17:18:34.320", "Score": "0", "CreationDate": "2015-12-04T17:18:34.320", "ParentId": "13780417", "CommentCount": "0", "OwnerUserId": "434551"}, "34093903": {"Id": "34093903", "PostTypeId": "2", "Body": "<p>This behaviour is justified in the standard <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf\" rel=\"nofollow\">N4527</a> at <em>8.5.3/p5.2 References [dcl.init.ref]</em></p>\n<blockquote>\n<p id=\"so_13780417_34093903_0\">5 A reference to type \u201ccv1 T1\u201d is initialized by an expression of type\n  \u201ccv2 T2\u201d as follows:</p>\n<p id=\"so_13780417_34093903_1\">...</p>\n<p id=\"so_13780417_34093903_2\">5.2 Otherwise, the reference shall be an lvalue reference to a\n  non-volatile const type (i.e., cv1 shall be const), or the reference\n  shall be an rvalue reference. [ Example:</p>\n<pre><code>double&amp; rd2 = 2.0; // error: not an lvalue and reference not const\nint i = 2;\ndouble&amp; rd3 = i; // error: type mismatch and reference not const\n</code></pre>\n<p id=\"so_13780417_34093903_3\">\u2014 end example ]</p>\n</blockquote>\n", "LastActivityDate": "2015-12-04T17:16:57.163", "Score": "2", "CreationDate": "2015-12-04T17:16:57.163", "ParentId": "13780417", "CommentCount": "0", "OwnerUserId": "2352671"}});