post_cb({"bq_ids": {"n4140": {"so_29399870_29401520_2": {"length": 21, "quality": 0.9545454545454546, "section_id": 3304}, "so_29399870_29401520_0": {"length": 17, "quality": 0.7391304347826086, "section_id": 3298}, "so_29399870_29401520_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 3298}}, "n3337": {"so_29399870_29401520_2": {"length": 17, "quality": 0.7727272727272727, "section_id": 3174}, "so_29399870_29401520_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 3168}, "so_29399870_29401520_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 3168}}, "n4659": {"so_29399870_29401520_2": {"length": 16, "quality": 0.7272727272727273, "section_id": 4070}, "so_29399870_29401520_0": {"length": 12, "quality": 0.5217391304347826, "section_id": 4063}, "so_29399870_29401520_1": {"length": 12, "quality": 0.631578947368421, "section_id": 4063}}}, "29401520": {"Id": "29401520", "PostTypeId": "2", "Body": "<p>Under C++11 rules, <code>B</code> is not an aggregate type. C++11 [dcl.init.aggr]/1:</p>\n<blockquote>\n<p id=\"so_29399870_29401520_0\">An <em>aggregate</em> is an array or a class (Clause 9) with no user-provided constructors (12.1), <strong>no <em>brace-or-equal-initializers</em> for non-static data members</strong> (9.2), no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p><code>B</code> only has a default constructor, and thus cannot be initialized from the <em>braced-initializer-list</em> <code>{2}</code>. </p>\n<p>C++14 allows <em>brace-or-equal-initializers</em> for non-static data members in an aggregate. N4140 [dcl.init.aggr]/1:</p>\n<blockquote>\n<p id=\"so_29399870_29401520_1\">An <em>aggregate</em> is an array or a class (Clause 9) with no user-provided constructors (12.1), no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>With fairly straight-forward semantics: fields for which there is no initializer specified are initialized from their <em>brace-or-equal-initializer</em>, if any, and otherwise initialized with <code>{}</code> [dcl.init.aggr]/7:</p>\n<blockquote>\n<p id=\"so_29399870_29401520_2\">If there are fewer <em>initializer-clauses</em> in the list than there are members in the aggregate, then each member not explicitly initialized shall be initialized from its <em>brace-or-equal-initializer</em> or, if there is no <em>brace-or-equal-initializer</em>, from an empty initializer list (8.5.4).</p>\n</blockquote>\n<p>Your program is thus valid C++14 (<a href=\"http://melpon.org/wandbox/permlink/IoUviio8T4DOUqUY\" rel=\"nofollow\"><strong>DEMO</strong></a>). Essentially, the prohibition of <em>brace-or-equal-initializer</em>s in C++11 was a mistake that C++14 corrected.</p>\n", "LastEditorUserId": "923854", "LastActivityDate": "2015-04-01T22:00:46.413", "Score": "2", "CreationDate": "2015-04-01T21:54:19.450", "ParentId": "29399870", "CommentCount": "1", "LastEditDate": "2015-04-01T22:00:46.413", "OwnerUserId": "923854"}, "29399870": {"ViewCount": "154", "Body": "<p>I try to use value-initialization for members with value-initialization for constructors (I don't know if I really use the good terms...)</p>\n<p>So... When I define:</p>\n<pre><code>struct A\n{\n  int a_;\n};\n</code></pre>\n<p>I'm able to use:</p>\n<pre><code>A a{5};\nassert(m.a_==5);   \n</code></pre>\n<p>However, if I want to use the member brace initializer AND an initialization-list constructor</p>\n<pre><code>struct B\n{\n  int b_ {1};\n};\n</code></pre>\n<p>This doesn't compile (c++14: <a href=\"http://ideone.com/MQ1FMU\">http://ideone.com/MQ1FMU</a>):</p>\n<pre><code>B b{2};\n</code></pre>\n<p>Here is the error:</p>\n<pre><code>prog.cpp:19:7: error: no matching function for call to 'B::B(&lt;brace-enclosed initializer list&gt;)'\n  B b{2};\n       ^\nprog.cpp:19:7: note: candidates are:\nprog.cpp:10:8: note: constexpr B::B()\n struct B\n        ^\nprog.cpp:10:8: note:   candidate expects 0 arguments, 1 provided\nprog.cpp:10:8: note: constexpr B::B(const B&amp;)\nprog.cpp:10:8: note:   no known conversion for argument 1 from 'int' to 'const B&amp;'\nprog.cpp:10:8: note: constexpr B::B(B&amp;&amp;)\nprog.cpp:10:8: note:   no known conversion for argument 1 from 'int' to 'B&amp;&amp;'\n</code></pre>\n<p>What is the difference, concept-wise?\nMany thanks!</p>\n", "AcceptedAnswerId": "29401520", "Title": "Uniform and Value-initialization", "CreationDate": "2015-04-01T20:10:30.137", "Id": "29399870", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-04-01T23:49:42.240", "LastEditorUserId": "2756719", "LastActivityDate": "2015-04-01T23:49:42.240", "ClosedDate": "2015-04-01T23:48:50.940", "Score": "6", "OwnerUserId": "4739674", "Tags": "<c++><c++11><initialization><c++14>", "AnswerCount": "1"}});