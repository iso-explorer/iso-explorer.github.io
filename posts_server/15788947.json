post_cb({"34006668": {"Id": "34006668", "PostTypeId": "2", "Body": "<p>You cannot apply an alignment to a <code>typedef</code>. In the C++ model of alignment specifiers, the alignment is an inseparable part of the type itself, and a <code>typedef</code> does not create a new type (it only provides a new name for an existing type) so it is not meaningful to apply an alignment specifier in a <code>typedef</code> declaration.</p>\n<p>From <strong>[dcl.align] (7.6.2)p1</strong>:</p>\n<blockquote>\n<p id=\"so_15788947_34006668_0\">An <em>alignment-specifier</em> may be applied to a variable or to a class data member [...]. An <em>alignment-specifier</em> may also be applied to the declaration or definition of a class (in an <em>elaborated-type-specifier</em> (7.1.6.3) or <em>class-head</em> (Clause 9), respectively) and to the declaration or definition of an enumeration (in an <em>opaque-enum-declaration</em>\n  or <em>enum-head</em>, respectively (7.2)).</p>\n</blockquote>\n<p>These are the only places where the standard says an <em>alignment-specifier</em> (<code>alignas(...)</code>) may be applied. Note that this <strong>does not</strong> include <code>typedef</code> declarations nor <em>alias-declaration</em>s.</p>\n<p>Per <strong>[dcl.attr.grammar] (7.6.1)p4</strong>:</p>\n<blockquote>\n<p id=\"so_15788947_34006668_1\">If an <em>attribute-specifier-seq</em> that appertains to some entity or statement contains an <em>attribute</em> that is not allowed to apply to that entity or statement, the program is ill-formed.</p>\n</blockquote>\n<p>This wording was intended to apply to <code>alignas</code> as well as the other forms of attribute that may appear within an <em>attribute-specifier-seq</em>, but was not correctly updated when alignment switched from being a \"real\" attribute to being a different kind of <em>attribute-specifier-seq</em>.</p>\n<p>So: your example code using <code>alignas</code> is <em>supposed</em> to be ill-formed. The C++ standard does not currently explicitly say this, but it also does not permit the usage, so instead it currently would result in undefined behavior (because the standard does not define any behavior for it).</p>\n", "LastActivityDate": "2015-11-30T19:44:27.863", "Score": "8", "CreationDate": "2015-11-30T19:44:27.863", "ParentId": "15788947", "CommentCount": "7", "OwnerUserId": "1041090"}, "15792876": {"Id": "15792876", "PostTypeId": "2", "Body": "<p>Try:</p>\n<pre><code>typedef float alignas(16) aligned_block[4];\n</code></pre>\n", "LastActivityDate": "2013-04-03T16:27:43.183", "Score": "-1", "CreationDate": "2013-04-03T16:27:43.183", "ParentId": "15788947", "CommentCount": "0", "OwnerUserId": "339249"}, "bq_ids": {"n4140": {"so_15788947_15788947_0": {"length": 29, "quality": 0.8055555555555556, "section_id": 5532}, "so_15788947_15912208_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 5408}, "so_15788947_34006668_1": {"length": 12, "quality": 1.0, "section_id": 5529}, "so_15788947_15912208_1": {"length": 7, "quality": 0.875, "section_id": 3208}, "so_15788947_15912208_2": {"length": 40, "quality": 0.9090909090909091, "section_id": 5532}, "so_15788947_15791742_1": {"length": 24, "quality": 0.6857142857142857, "section_id": 5532}, "so_15788947_34006668_0": {"length": 24, "quality": 0.96, "section_id": 5532}}, "n3337": {"so_15788947_15788947_0": {"length": 34, "quality": 0.9444444444444444, "section_id": 5318}, "so_15788947_15912208_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 5203}, "so_15788947_34006668_0": {"length": 14, "quality": 0.56, "section_id": 5318}, "so_15788947_15912208_1": {"length": 7, "quality": 0.875, "section_id": 3082}, "so_15788947_15912208_2": {"length": 29, "quality": 0.6590909090909091, "section_id": 5318}, "so_15788947_34006668_1": {"length": 12, "quality": 1.0, "section_id": 5315}, "so_15788947_15791742_1": {"length": 29, "quality": 0.8285714285714286, "section_id": 5318}}, "n4659": {"so_15788947_15788947_0": {"length": 23, "quality": 0.6388888888888888, "section_id": 6968}, "so_15788947_15912208_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 6830}, "so_15788947_34006668_0": {"length": 24, "quality": 0.96, "section_id": 6968}, "so_15788947_15912208_1": {"length": 7, "quality": 0.875, "section_id": 3965}, "so_15788947_15912208_2": {"length": 34, "quality": 0.7727272727272727, "section_id": 6968}, "so_15788947_34006668_1": {"length": 12, "quality": 1.0, "section_id": 6965}, "so_15788947_15791742_1": {"length": 19, "quality": 0.5428571428571428, "section_id": 6968}}}, "15791742": {"Id": "15791742", "PostTypeId": "2", "Body": "<p>Draft C++11 standard <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf</a> says about it (Alignment-speci\ufb01er is of the form <code>alignas</code> ( assignment-expression )):</p>\n<blockquote>\n<p id=\"so_15788947_15791742_0\">7.6.2 Alignment speci\ufb01er [dcl.align]</p>\n<p id=\"so_15788947_15791742_1\">1 An alignment-speci\ufb01er may be applied to a variable or to a class data member, but it shall not be applied\n  to a bit-\ufb01eld, a function parameter, the formal parameter of a catch clause (15.3), or a variable declared\n  with the register storage class speci\ufb01er. An alignment-speci\ufb01er may also be applied to the declaration of\n  a class or enumeration type. An alignment-speci\ufb01er with an ellipsis is a pack expansion.</p>\n</blockquote>\n<p>I found this original proposal <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1877.pdf\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1877.pdf</a> , it says:</p>\n<blockquote>\n<p id=\"so_15788947_15791742_2\">The alignment-specifier does not become part of the type, but it is possible to create a class type\n  with aligned member variable(s).</p>\n</blockquote>\n<p>with this example:</p>\n<pre><code>// Wrong attempt: Listing 6)\ntypedef double align_by&lt;0x10000&gt; hwDoubleVector; // Error!\nVoid clear(hwDoubleVector &amp;toClear, unsigned size);\n</code></pre>\n<p>Looks like it's illegal to use it with <code>typedef</code>.</p>\n", "LastActivityDate": "2013-04-03T15:35:00.223", "Score": "6", "CreationDate": "2013-04-03T15:35:00.223", "ParentId": "15788947", "CommentCount": "2", "OwnerUserId": "1697800"}, "15912208": {"Id": "15912208", "PostTypeId": "2", "Body": "<p>I think you just placed the <code>alignas</code> in the wrong position. If you move it directly <em>after</em> the identifier, both GCC and Clang are happy and apply the alignment:</p>\n<pre><code>typedef float aligned_block alignas(16) [4];\ntypedef float aligned_block [4] alignas(16);\n</code></pre>\n<p>this is also true if you use <code>using</code>, where the difference also becomes more apparent. Here are two versions that are <em>not</em> accepted by GCC (warning, alignment ignored):</p>\n<pre><code>using aligned_block = float alignas(16)[4];\nusing aligned_block = float[4] alignas(16);\n</code></pre>\n<p>and here's the accepted one:</p>\n<pre><code>using aligned_block alignas(16) = float[4];\n</code></pre>\n<p>I think that GCC applies</p>\n<blockquote>\n<h3>7.1.3 The typedef specifier [dcl.typedef]</h3>\n<p id=\"so_15788947_15912208_0\"><sup>2</sup> A <em>typedef-name</em> can also be introduced by an <em>alias-declaration</em>. The <em>identifier</em> following the <code>using</code> keyword becomes a <em>typedef-name</em> and the <strong>optional <em>attribute-specifier-seq</em> following the <em>identifier</em></strong> appertains to that <em>typedef-name</em>. It has the same semantics as if it were introduced by the <code>typedef</code> specifier. [...]</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>The above is quite clear for <code>using</code>, the rules for <code>typedef</code> are spread through several paragraphs, including at the end of \u00a78.3/1, where you find:</p>\n<blockquote>\n<h3>8.3 Meaning of declarators [dcl.meaning]</h3>\n<p id=\"so_15788947_15912208_1\"><sup>1</sup> [...] The optional <em>attribute-specifier-seq</em> <strong>following a <em>declarator-id</em></strong> appertains to the entity that is declared.</p>\n</blockquote>\n<p>(again, emphasis mine)</p>\n<hr>\n<p>Update: The above answer concentrated on <strong>where</strong> the <code>alignas</code> has to be placed, not on its exact meaning. After thinking about it some more, I still think that the above should be valid. Consider:</p>\n<blockquote>\n<h3>7.6.2 Alignment Specifier [dcl.align]</h3>\n<p id=\"so_15788947_15912208_2\"><sup>1</sup>An <em>alignment-specifier</em> may be applied to a variable or to a class data member, but it shall not be applied to a bit-field, a function parameter, an <em>exception-declaration</em> (15.3), or a variable declared with the <code>register</code> storage class specifier. An <em>alignment-specifier</em> may also be applied to the declaration or definition of a class (in an <em>elaborated-type-specifier</em> (7.1.6.3) or <em>class-head</em> (Clause 9), respectively) and to the declaration or definition of an enumeration (in an <em>opaque-enum-declaration</em> or <em>enum-head</em>, respectively (7.2)). An <em>alignment-specifier</em> with an ellipsis is a pack expansion (14.5.3).</p>\n</blockquote>\n<p>It lists cases where it can be clearly applied and it lists cases where it clearly can <em>not</em> be applied. The above question's example is neither.</p>\n<p>One could also argue that the type alias created by <code>typedef</code> or <code>using</code> is carrying the alignment specification as part of the aliased type. This alias can than be used to create a variable, etc. as allowed by 7.6.2p1 but not to create a variable with <code>register</code>, etc.</p>\n<p>In that sense I think that the attribute specifier is applied (in the sense of 7.6.2) in a deferred way and thus OPs example should still be valid when the alignment specification is put in the syntactically correct place.</p>\n</hr>", "LastEditorUserId": "2073257", "LastActivityDate": "2015-12-03T15:26:51.140", "Score": "25", "CreationDate": "2013-04-09T20:48:33.720", "ParentId": "15788947", "CommentCount": "8", "LastEditDate": "2015-12-03T15:26:51.140", "OwnerUserId": "2073257"}, "15788947": {"ViewCount": "9929", "Body": "<p>In an effort to standardize my code and make it more portable, I replaced</p>\n<pre><code>#ifdef __GNUC__\ntypedef __attribute__((aligned(16))) float aligned_block[4];\n#else\ntypedef __declspec(align(16)) float aligned_block[4];\n#endif\n</code></pre>\n<p>with</p>\n<pre><code>typedef float alignas(16) aligned_block[4];\n</code></pre>\n<p>in C++11. However, gnu (4.8) doesn't like that but complains</p>\n<pre><code>test.cc:3:9: warning: attribute ignored [-Wattributes]\n  typedef float alignas(16) aligned_block[4];\n                ^\ntest.cc:3:9: note: an attribute that appertains to a type-specifier is ignored\n</code></pre>\n<p>whereas clang 3.2 creates no warning (even with <code>-Weverything -Wno-c++98-compat -pedantic</code>).\nSo I wonder whether my code above is correct and, more generally, where <code>alignas()</code> can and cannot be placed.</p>\n<p><strong><em>EDIT (Apr 2013)</em></strong>:</p>\n<p>The relevant article from the standard is 7.6.2, in particular 7.6.2.1</p>\n<blockquote>\n<p id=\"so_15788947_15788947_0\">An alignment-specifier may be applied to a variable or to a class data member, but it shall not be applied to a bit-field, a function parameter, the formal parameter of a catch clause (15.3), or a variable declared with the register storage class specifier. An alignment-specifier may also be applied to the declaration of a class or enumeration type. An alignment-specifier with an ellipsis is a pack expansion (14.5.3).</p>\n</blockquote>\n<p>as already dug out by Red XIII. However, I'm not expert enough to know what this means for my test above.</p>\n<p>If the fact that clang accepts my attribute means anything, it's perhaps worth mentioning that when trying to use a <code>using</code> directive instead of a <code>typedef</code>, clang also complains. Also, contrary to a statement in an earlier version of this question, gcc does not only warn, but indeed ignores my wish for alignment.</p>\n", "AcceptedAnswerId": "34006668", "Title": "Where can I use alignas() in C++11?", "CreationDate": "2013-04-03T13:39:06.317", "Id": "15788947", "CommentCount": "2", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2016-06-09T02:54:27.323", "LastEditorUserId": "608639", "LastActivityDate": "2016-06-09T02:54:27.323", "Score": "29", "OwnerUserId": "1023390", "Tags": "<c++><c++11><alignment><alignas>", "AnswerCount": "4"}});