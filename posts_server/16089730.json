post_cb({"bq_ids": {"n4140": {"so_16089730_16112511_0": {"length": 10, "quality": 1.0, "section_id": 479}}, "n3337": {"so_16089730_16112511_0": {"length": 10, "quality": 1.0, "section_id": 470}}, "n4659": {"so_16089730_16112511_0": {"length": 10, "quality": 1.0, "section_id": 473}}}, "16089730": {"ViewCount": "802", "Body": "<pre><code>struct STest : public boost::noncopyable {\n    STest(STest &amp;&amp; test) : m_n( std::move(test.m_n) ) {}\n    explicit STest(int n) : m_n(n) {}\n    int m_n;\n};\n\nSTest FuncUsingConst(int n) {\n    STest const a(n);\n    return a;\n}\n\nSTest FuncWithoutConst(int n) {\n    STest a(n);\n    return a;\n}\n\nvoid Caller() {\n    // 1. compiles just fine and uses move ctor\n    STest s1( FuncWithoutConst(17) );\n\n    // 2. does not compile (cannot use move ctor, tries to use copy ctor)\n    STest s2( FuncUsingConst(17) );\n}\n</code></pre>\n<p>The above example illustrates how in C++11, as implemented in Microsoft Visual C++ 2012, the internal details of a function can modify its return type. Up until today, it was my understanding that the declaration of the return type is all a programmer needs to know to understand how the return value will be treated, e.g., when passed as a parameter to a subsequent function call. <strong>Not so.</strong></p>\n<p>I like making local variables <code>const</code> where appropriate. It helps me clean up my train of thought and clearly structure an algorithm. But beware of returning a variable that was declared <code>const</code>! Even though the variable will no longer be accessed (a <code>return</code> statement was executed, after all), and even though the variable that was declared <code>const</code> has long gone out of scope (evaluation of the parameter expression is complete), it cannot be moved and thus will be copied (or fail to compile if copying is not possible).</p>\n<p>This question is related to another question, <a href=\"https://stackoverflow.com/questions/7138780/move-semantics-returning-const-values\">Move semantics &amp; returning const values</a>. The difference is that in the latter, the function is declared to return a <code>const</code> value. In my example, <code>FuncUsingConst</code> is declared to return a volatile temporary. Yet, the implementational details of the function body affect the type of the return value, and determine whether or not the returned value can be used as a parameter to other functions.</p>\n<p><strong>Is this behavior intended by the standard?</strong><br>\n<strong>How can this be regarded useful?</strong></br></p>\n<p>Bonus question: How can the compiler know the difference at compile time, given that the call and the implementation may be in different translation units?</p>\n<hr>\n<p>EDIT: An attempt to rephrase the question.</p>\n<p>How is it possible that there is more to the result of a function than the declared return type? How does it even seem acceptable at all that the function declaration is not sufficient to determine the behavior of the function's returned value? To me that seems to be a case of FUBAR and I'm just not sure whether to blame the standard or Microsoft's implementation thereof.</p>\n<p>As the implementer of the called function, I cannot be expected to even know all callers, let alone monitor every little change in the calling code. On the other hand, as the implementer of the calling function, I cannot rely on the called function to not return a variable that happens to be declared const within the scope of the function implementation.</p>\n<p>A function declaration is a contract. What is it worth now? We are not talking about a semantically equivalent compiler optimization here, like copy elision, which is nice to have but does not change the meaning of code. Whether or not the copy ctor is called <em>does</em> change the meaning of code (and can even break the code to a degree that it cannot be compiled, as illustrated above). To appreciate the awkwardness of what I am discussing here, consider the \"bonus question\" above.</p>\n</hr>", "AcceptedAnswerId": "16112511", "Title": "Why would const-ness of a local variable inhibit move semantics for the returned value?", "CreationDate": "2013-04-18T17:41:28.763", "Id": "16089730", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:34:56.783", "LastEditorUserId": "-1", "LastActivityDate": "2013-04-19T20:26:26.220", "Score": "14", "OwnerUserId": "234619", "Tags": "<c++11><return><const><move-semantics><rvalue-reference>", "AnswerCount": "2"}, "16090390": {"Id": "16090390", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_16089730_16090390_0\">I like making local variables const where appropriate. It helps me clean up my train of thought and clearly structure an algorithm.</p>\n</blockquote>\n<p>That is indeed a good practice. Use <code>const</code> wherever you can. Here, however, you cannot (if you expect your <code>const</code> object to be moved from).</p>\n<p>The fact that you declare a <code>const</code> object inside your function is a promise that <em>your object's state won't ever be altered</em> as long as the object is alive - in other words, never before its destructor is invoked. Not even <em>immediately before</em> its destructor is invoked. As long as it is alive, the state of a <code>const</code> object shall not change.</p>\n<p>However, here you are somehow expecting this object to be <em>moved from</em> right before it gets destroyed by falling out of scope, and <strong>moving is altering state</strong>. You cannot move from a <code>const</code> object - not even if you are not going to use that object anymore.</p>\n<p>What you <em>can</em> do, however, is to create a non-<code>const</code> object and access it in your function only through a reference to <code>const</code> bound to that object:</p>\n<pre><code>STest FuncUsingConst(int n) {\n    STest object_not_to_be_touched_if_not_through_reference(n);\n    STest const&amp; a = object_not_to_be_touched_if_not_through_reference;\n\n    // Now work only with a\n\n    return object_not_to_be_touched_if_not_through_reference;\n}\n</code></pre>\n<p>With a bit of discipline, you can easily enforce the semantics that the function should not modify that object after its creation - except for being allowed to move from it when returning.</p>\n<p><strong>UPDATE:</strong></p>\n<p>As suggested by <a href=\"https://stackoverflow.com/users/463758/balki\">balki</a> in the comments, another possibility would be to bind a constant reference to a non-const temporary object (whose lifetime would be prolonged as per \u00a7 12.2/5), and perform a <code>const_cast</code> when returning it:</p>\n<pre><code>STest FuncUsingConst(int n) {\n    STest const&amp; a = STest();\n\n    // Now work only with a\n\n    return const_cast&lt;STest&amp;&amp;&gt;(std::move(a));\n}\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-04-18T19:12:30.783", "Score": "15", "CreationDate": "2013-04-18T18:20:37.343", "ParentId": "16089730", "CommentCount": "7", "OwnerUserId": "1932150", "LastEditDate": "2017-05-23T10:34:11.417"}, "16112511": {"Id": "16112511", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_16089730_16112511_0\">A program is ill-formed if the copy/move constructor [...] for an object is implicitly odr-used and the special member function is not accessible</p>\n</blockquote>\n<p>-- n3485 C++ draft standard [class.copy]/30</p>\n<p>I suspect your problem is with MSVC 2012, and not with C++11.</p>\n<p>This code, even without calling it, is not legal C++11:</p>\n<pre><code>struct STest {\n  STest(STest const&amp;) = delete\n  STest(STest &amp;&amp; test) : m_n( std::move(test.m_n) ) {}\n  explicit STest(int n) : m_n(n) {}\n  int m_n;\n};\n\nSTest FuncUsingConst(int n) {\n  STest const a(n);\n  return a;\n}\n</code></pre>\n<p>because there is no legal way to turn <code>a</code> into a return value.  While the return can be elided, eliding the return value does not remove the requirement that the copy constructor exist.</p>\n<p>If MSVC2012 is allowing <code>FuncUsingConst</code> to compile, it is doing so in violation of the C++11 standard.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2013-04-19T20:26:26.220", "Score": "2", "CreationDate": "2013-04-19T19:51:27.343", "ParentId": "16089730", "CommentCount": "10", "OwnerUserId": "1774667", "LastEditDate": "2013-04-19T20:26:26.220"}});