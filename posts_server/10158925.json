post_cb({"10159182": {"Id": "10159182", "PostTypeId": "2", "Body": "<p>If I am not mistaken, <strong>you don't need any explicit cast</strong> at all, because <code>SomeInterface</code> is the base class of <code>_PublicClass_impl</code>, and you can always implicitly cast to a base class.</p>\n<p>I actually tried compiling your code <strong>without the <code>dynamic_cast</code></strong> in GCC (4.5.1), and indeed there is no error or warning (I defined <code>SomeInterface</code> as an empty class).</p>\n<p>One related question intrigued me, though: Why does the compiler take into account the fact that <code>SomeInterface</code> is indeed the base class of <code>_PublicClass_impl</code>, although the latter is opaque at the point in question?</p>\n<p>The closest I found to an explanation for this is \u00a711.2, clause 5 of the C++ Standard:</p>\n<blockquote>\n<p id=\"so_10158925_10159182_0\">If a base class is accessible, one can implicitly convert a pointer to a derived class to a pointer to that base\n  class (4.10, 4.11).</p>\n</blockquote>\n<p><strong>If for some reason you want to use an explicit cast</strong> nevertheless, a simple static one should be fine:</p>\n<pre><code>SomeInterface *interface = static_cast&lt;SomeInterface *&gt;(_impl);\n</code></pre>\n", "LastEditorUserId": "777186", "LastActivityDate": "2012-04-15T10:34:55.850", "Score": "1", "CreationDate": "2012-04-15T02:58:32.683", "ParentId": "10158925", "CommentCount": "2", "OwnerUserId": "777186", "LastEditDate": "2012-04-15T10:34:55.850"}, "bq_ids": {"n4140": {"so_10158925_10159182_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 6682}}, "n3337": {"so_10158925_10159182_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 6437}}, "n4659": {"so_10158925_10159182_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 8157}}}, "10159330": {"Id": "10159330", "PostTypeId": "2", "Body": "<p>As far as I can tell, there isn't a gaurenteed way to do what you want.  A reinterpret_cast or c-style cast might work (the behavior is unspecified), but the others are all undefined behavior when it lets you compile it at all.</p>\n<p>5.2.7.2 of n3242 (I know it's not the official standard, but it should be close) says about dynamic_cast(v),</p>\n<p>If T is a pointer type, v shall be a prvalue of a pointer to complete class type, and the result is a prvalue of type T. If T is an lvalue reference type, v shall be an lvalue of a complete class type, and the result is an lvalue of the type referred to by T. If T is an rvalue reference type, v shall be an expression having a complete class type, and the result is an xvalue of the type referred to by T.</p>\n<p>So dynamic_cast doesn't work.</p>\n<p>static_cast doesn't work since there aren't any valid conversion defined between the two types.</p>\n<p>5.2.10.7 says about reinterpret_cast(v),</p>\n<p>A pointer to an object can be explicitly converted to a pointer to a different object type.69 When a prvalue v of type \u201cpointer to T1\u201d is converted to the type \u201cpointer to cv T2\u201d, the result is static_cast(static_cast(v)) if both T1 and T2 are standard-layout types (3.9) and the alignment requirements of T2 are no stricter than those of T1. Converting a prvalue of type \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than those of T1) and back to its original type yields the original pointer value. The result of any other such pointer conversion is unspecified.</p>\n<p>so a reinterpret_cast might work.  </p>\n<p>And finally, not using a cast doesn't work because the compiler doesn't know about the relationship between the types.</p>\n", "LastEditorUserId": "895350", "LastActivityDate": "2012-04-15T04:34:59.950", "Score": "1", "CreationDate": "2012-04-15T03:44:39.850", "ParentId": "10158925", "CommentCount": "2", "OwnerUserId": "895350", "LastEditDate": "2012-04-15T04:34:59.950"}, "10158925": {"ViewCount": "342", "Body": "<p>I'm trying to use pimpl idiom. In particular, the implementation class would implement another interface:</p>\n<pre><code>// public_class.h\nclass PublicClass\n{\npublic:\n    /* public interfaces here */\nprivate:\n    class _PublicClass_impl;\n    friend class _PublicClass_impl;\nprotected:\n    _PublicClass_impl * const _impl;\n};\n\n// public_class.cpp\nclass PublicClass::_PublicClass_impl : public SomeInterface\n{\n    friend class PublicClass;\n    /* all sort of stuff ... */\n};\n</code></pre>\n<p>My question is, what casts can be used in the following situation?</p>\n<pre><code>// some_other_class.h\nclass SomeOtherClass : private PublicClass\n{\n    void some_function()\n    {\n        // definition of _PublicClass_impl is unknown\n        // thus, _impl is opaque\n\n        SomeInterface * interface = dynamic_cast&lt;SomeInterface *&gt;(_impl); //??\n        /* more code ... */\n     }\n};\n</code></pre>\n<p>Would dynamic_cast work fine in this case? Are there any other types of cast that can be used in this case?</p>\n", "AcceptedAnswerId": "10159330", "Title": "Upcasting opaque pointer", "CreationDate": "2012-04-15T01:47:14.360", "Id": "10158925", "CommentCount": "0", "LastEditDate": "2012-04-15T03:55:07.260", "PostTypeId": "1", "LastEditorUserId": "1333992", "LastActivityDate": "2012-04-15T10:34:55.850", "Score": "0", "OwnerUserId": "1333992", "Tags": "<c++><casting><opaque-pointers>", "AnswerCount": "2"}});