post_cb({"17619015": {"CommentCount": "11", "ViewCount": "775", "PostTypeId": "1", "LastEditorUserId": "611560", "CreationDate": "2013-07-12T15:56:20.520", "LastActivityDate": "2013-07-12T17:07:11.473", "Title": "Why one should not hide a structure implementation that way?", "FavoriteCount": "1", "LastEditDate": "2013-07-12T17:07:11.473", "Id": "17619015", "Score": "3", "Body": "<p>I've seen some C/C++ code using a trick to hide structure implementation using an opaque (shadow) structure of the same size:</p>\n<p>In <code>private.h</code>, the exact implementation of the structure is declared:</p>\n<pre><code>typedef struct private_struct\n{\n    private_foo_t f1;\n    private_bar_t b[2];\n    private_baz_t *bz;\n    int val;\n} private_t;\n\n#define PRIVATE_SIZE (sizeof(private_t))\n</code></pre>\n<p>In <code>public.h</code>, the public structure is declared to hold an opaque array of bytes:</p>\n<pre><code>#include \"private.h\"\n\ntypedef struct public_struct\n{\n    char opaque[PRIVATE_SIZE];\n} public_t;\n</code></pre>\n<p><code>public_t</code> and <code>private_t</code> share the same size.</p>\n<p>Users can allocate themself storage for private implementation using the public structure:</p>\n<pre><code>#include &lt;public.h&gt;\n\nint main(void)\n{\n    public_t pub;\n\n    return public_api(&amp;pub);\n}\n</code></pre>\n<p>Implementation can access the hidden implementation:</p>\n<pre><code>#include \"private.h\"\n\nint public_api(public_t *pub)\n{\n    private_t *priv = (private_t *) pub;\n\n    return priv-&gt;val;\n}\n</code></pre>\n<p>This seems a pretty neat trick to allow users to allocate storage for variables (eg. declare static variables).</p>\n<p>I'm porting proprietary source code using this trick on various embedded system, but I'm not feeling confident in the way structure <code>pub_t</code> is declared.</p>\n<p>What can be wrong with this trick ?</p>\n", "Tags": "<c++><c>", "OwnerUserId": "611560", "AnswerCount": "3"}, "17619016": {"ParentId": "17619015", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2013-07-12T15:56:20.520", "Score": "9", "LastEditorUserId": "611560", "LastEditDate": "2013-07-12T16:50:54.273", "Id": "17619016", "OwnerUserId": "611560", "Body": "<p><strong>Beware of Alignment !</strong></p>\n<p><code>public_t</code> native alignment is 1 since <code>char</code> are aligned to 1 byte.\n<code>private_t</code> alignment is set to the highest alignment requirement of its members, which is certainly not 1. It's probably aligned on the size of a pointer (<code>void *</code>), but there's a <code>double</code> inside a substructure which might require an alignment on 8 bytes. You may seen various kind of alignment depending on the ABI.</p>\n<p>Let's try a example program, compiled and tested on i386/i686 with gcc (code source follow):</p>\n<pre><code>     kind         name       address   size   alignment   required\n\n     type |      foo_t |         N/A |   48 |       N/A |        4 \n     type |     priv_t |         N/A |   56 |       N/A |        4 \n     type |      pub_t |         N/A |   56 |       N/A |        1 \n\n   object |       u8_0 |  0xfff72caf |    1 |         1 |        1\n   object |       u8_1 |  0xfff72cae |    1 |         2 |        1\n   object |       u8_2 |  0xfff72cad |    1 |         1 |        1\n   object |       pub0 |  0xfff72c75 |   56 |         1 |        1\n   object |       u8_3 |  0xfff72c74 |    1 |         4 |        1\n   object |       pub1 |  0xfff72c3c |   56 |         4 |        1\n   object |       u8_4 |  0xfff72c3b |    1 |         1 |        1\n   object |      priv0 |  0xfff72c00 |   56 |      1024 |        4\n   object |       u8_5 |  0xfff72bff |    1 |         1 |        1\n   object |      priv1 |  0xfff72bc4 |   56 |         4 |        4\n   object |       u8_6 |  0xfff72bc3 |    1 |         1 |        1\n\n  pointer |       pubp |  0xfff72c75 |   56 |         1 |        1\n  pointer |      privp |  0xfff72c75 |   56 |         1 |        4  **UNALIGNED**\n   object | privp-&gt;val |  0xfff72c75 |    4 |         1 |        4  **UNALIGNED**\n   object | privp-&gt;ptr |  0xfff72c79 |    4 |         1 |        4  **UNALIGNED**\n   object |   privp-&gt;f |  0xfff72c7d |   48 |         1 |        4  **UNALIGNED**\n</code></pre>\n<p>Source code of the test:</p>\n<pre><code>#include &lt;stdalign.h&gt;\n#ifdef __cplusplus\n/* you will need to pass -std=gnu++11 to g++ */\n#include &lt;cstdint&gt;\n#endif\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;inttypes.h&gt;\n\n#ifdef __cplusplus\n#define alignof __alignof__\n#endif\n\n#define PRINTHEADER() printheader()\n#define PRINTSPACE() printspace()\n#define PRINTALIGN(obj) printobjalign(\"object\", #obj, &amp;obj, sizeof(obj), alignof(obj))\n#define PRINTALIGNP(ptr) printobjalign(\"pointer\", #ptr, ptr, sizeof(*ptr), alignof(*ptr))\n#define PRINTALIGNT(type) printtypealign(#type, sizeof(type), alignof(type))\n\nstatic void\nprintheader(void)\n{\n    printf(\" %8s   %10s   %18s   %4s   %9s   %8s\\n\", \"kind\", \"name\", \"address\", \"size\", \"alignment\", \"required\");\n}\n\nstatic void\nprintspace(void)\n{\n    printf(\" %8s   %10s   %18s   %4s   %9s   %8s\\n\", \"\", \"\", \"\", \"\", \"\", \"\");\n}\n\nstatic void\nprinttypealign(const char *name, size_t szof, size_t alof)\n{\n    printf(\" %8s | %10s | %18s | %4zu | %9s | %8zu \\n\", \"type\", name, \"N/A\", szof, \"N/A\", alof);\n}\n\nstatic void\nprintobjalign(const char *tag, const char *name, const void * ptr, size_t szof, size_t alof)\n{\n    const uintptr_t uintptr = (uintptr_t)ptr;\n    uintptr_t mask = 1;\n    size_t align = 0;\n\n    /* get current alignment of the pointer */\n    while(mask != UINTPTR_MAX) {\n\n        if ((uintptr &amp; mask) != 0) {\n            align = (mask + 1) / 2;\n            break;\n        }\n\n        mask &lt;&lt;= 1;\n        mask |= 1;\n    }\n\n    printf(\" %8s | %10s | %18p | %4zu | %9zu | %8zu%s\\n\",\n           tag, name, ptr, szof, align, alof, (align &lt; alof) ? \"  **UNALIGNED**\" : \"\");\n}\n\n/* a foo struct with various fields */\ntypedef struct foo\n{\n    uint8_t f8_0;\n    uint16_t f16;\n    uint8_t f8_1;\n    uint32_t f32;\n    uint8_t f8_2;\n    uint64_t f64;\n    uint8_t f8_3;\n    double d;\n    uint8_t f8_4;\n    void *p;\n    uint8_t f8_5;\n} foo_t;\n\n/* the implementation struct */\ntypedef struct priv\n{\n    uint32_t val;\n    void *ptr;\n    struct foo f;\n} priv_t;\n\n/* the opaque struct */\ntypedef struct pub\n{\n    uint8_t padding[sizeof(priv_t)];\n} pub_t;\n\nstatic int\ntest(pub_t *pubp)\n{\n    priv_t *privp = (priv_t *)pubp;\n\n    PRINTALIGNP(pubp);\n    PRINTALIGNP(privp);\n    PRINTALIGN(privp-&gt;val);\n    PRINTALIGN(privp-&gt;ptr);\n    PRINTALIGN(privp-&gt;f);\n    PRINTSPACE();\n\n    return privp-&gt;val;\n}\n\nint\nmain(void)\n{\n    uint8_t u8_0;\n    uint8_t u8_1;\n    uint8_t u8_2;\n    pub_t pub0;\n    uint8_t u8_3;\n    pub_t pub1;\n    uint8_t u8_4;\n    priv_t priv0;\n    uint8_t u8_5;\n    priv_t priv1;\n    uint8_t u8_6;\n\n    PRINTHEADER();\n    PRINTSPACE();\n\n    PRINTALIGNT(foo_t);\n    PRINTALIGNT(priv_t);\n    PRINTALIGNT(pub_t);\n    PRINTSPACE();\n\n    PRINTALIGN(u8_0);\n    PRINTALIGN(u8_1);\n    PRINTALIGN(u8_2);\n    PRINTALIGN(pub0);\n    PRINTALIGN(u8_3);\n    PRINTALIGN(pub1);\n    PRINTALIGN(u8_4);\n    PRINTALIGN(priv0);\n    PRINTALIGN(u8_5);\n    PRINTALIGN(priv1);\n    PRINTALIGN(u8_6);\n    PRINTSPACE();\n\n    return test(&amp;pub0);\n}\n</code></pre>\n<p><strong>Analysis</strong>:</p>\n<p><code>pub0</code> is allocated on the stack and is passed as argument to function <code>test</code>. It is aligned on 1 byte, so that, when cast'ed as a <code>priv_t</code> pointer, <code>priv_t</code> structure members are not aligned.</p>\n<p>And that can be bad:</p>\n<ul>\n<li>bad for correctness: some architectures/CPUs will silently corrupt read/write operations to unaligned memory address, some others will generate a fault. The latter is better.</li>\n<li>bad for performance: if supported, unaligned access/load/store are still known to be poorly handled: you're likely asking the CPUs to read/write twice the memory size of the object ... you might hit the cache badly this way.</li>\n</ul>\n<p>So, if you really want to hide structure content, you should take care of the alignment of the underlying structure: don't use <code>char</code>.</p>\n<p>By default, use <code>void *</code>, or if there can be <code>double</code> in any members of the structure, use <code>double</code>. This will works until someone use a <code>#prama</code> or <code>__attribute__(())</code> to choose an higher alignment for (a member of) the hidden structure.</p>\n<p>Let's define correctly <code>pub_t</code>:</p>\n<pre><code>typedef struct pub\n{\n    double opaque[(sizeof(priv_t) + (sizeof(double) - 1)) / sizeof(double)];\n} pub_t;\n</code></pre>\n<p>It might sound complex, and it is ! This way the <code>pub_t</code> structure will have correct alignment and be at least as big as underlying <code>priv_t</code>.</p>\n<p>If <code>priv_t</code> was packed (with <code>#pragma</code> or <code>__attribute__(())</code>), using <code>sizeof(priv_t)/sizeof(double)</code>, <code>pub_t</code> could be smaller than <code>priv_t</code> ... which will be even worst than the problem we were trying to solve initially. But if the structure was packed, who care of the alignment.</p>\n<p><strong>malloc()</strong></p>\n<p>If <code>pub_t</code> structure was allocated by <code>malloc()</code> instead of being allocated on stack, the alignment would not be a problem since <code>malloc()</code> is defined to return a memory block aligned to the greatest memory alignments of the C native types, eg. <code>double</code>. In modern <code>malloc()</code> implementations alignment could be up to 32 bytes.</p>\n", "LastActivityDate": "2013-07-12T16:50:54.273"}, "17619192": {"ParentId": "17619015", "CommentCount": "0", "Body": "<p>In most cases the nature of a internal structure is hidden from public because you want to be free to change int without having to recompile all the code that is using it. And exactly that is what you loose if you use the trick vou have mentioned and the size of <code>private_t</code> changes. So to be free, it's better to provide either a function like <code>alloc_struct()</code> that allocates a structure and returns a <code>void *</code> or a function that returns <code>sizeof(private_t)</code> so that can be used for allocating\u2026</p>\n", "OwnerUserId": "2470782", "PostTypeId": "2", "Id": "17619192", "Score": "2", "CreationDate": "2013-07-12T16:06:29.067", "LastActivityDate": "2013-07-12T16:06:29.067"}, "bq_ids": {"n4140": {"so_17619015_17620232_1": {"section_id": 7192, "quality": 0.9142857142857143, "length": 32}, "so_17619015_17620232_0": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_17619015_17620232_1": {"section_id": 6936, "quality": 0.9142857142857143, "length": 32}, "so_17619015_17620232_0": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_17619015_17620232_1": {"section_id": 8701, "quality": 0.9142857142857143, "length": 32}, "so_17619015_17620232_0": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}}}, "17620232": {"ParentId": "17619015", "CommentCount": "1", "Body": "<p>Here's what is wrong with it in C++.  From 3.8 <code>[basic.life]</code>:</p>\n<blockquote>\n<p id=\"so_17619015_17620232_0\">The lifetime of an object of type <code>T</code> begins when:</p>\n<ul>\n<li>storage with the proper alignment and size for type <code>T</code> is obtained, and</li>\n<li>if the object has non-trivial initialization, its initialization is complete.</li>\n</ul>\n</blockquote>\n<p>and later</p>\n<blockquote>\n<p id=\"so_17619015_17620232_1\">For an object of a class type with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage which the object occupies is reused or released; however, if there is no explicit call to the destructor or if a delete-expression (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and any program that depends on the side effects produced by the destructor has unde\ufb01ned behavior.</p>\n</blockquote>\n<p>Others have already pointed out the potential alignment issues, which also exist in C.  But in C++ initialization is a special problem.   The public user isn't performing any, so you can only cast the pointer to the private type and use it if the private type has no initialization.  There's a parallel problem with destruction -- you force the private object to have trivial destruction.</p>\n<p>Which clearly is why you've written <code>private_baz_t *bz;</code> when you should be using a smart pointer.</p>\n<p>The only \"benefits\" this trick buys you are memory leaks and lack of exception safety -- all the things RAII is designed to protect against.  Use the p/impl pattern instead, which actually provides a compilation firewall and improves build times.</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "17620232", "Score": "2", "CreationDate": "2013-07-12T17:02:40.527", "LastActivityDate": "2013-07-12T17:02:40.527"}});