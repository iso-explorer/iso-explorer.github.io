post_cb({"21265462": {"ViewCount": "3140", "Body": "<p>My question is pretty simple: as <code>std::intmax_t</code> is defined as the <code>maximum width integer type</code> according to <a href=\"http://en.cppreference.com/w/cpp/types/integer\">cppreference</a>, why it does not correspond to <code>__int128_t</code> in GCC?</p>\n", "AcceptedAnswerId": "21267714", "Title": "Why in g++ std::intmax_t is not a __int128_t?", "CreationDate": "2014-01-21T17:47:06.820", "Id": "21265462", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-08-03T22:06:02.880", "Score": "10", "OwnerUserId": "882932", "Tags": "<c++><c><gcc><integer><standards>", "AnswerCount": "3"}, "25109568": {"Id": "25109568", "PostTypeId": "2", "Body": "<p>__int128 is not sufficiently functional to be used as an intmax_t</p>\n<p>The stdint.h header must include a define INTMAX_C(9999999999999999999999)\nThis define lets you enter a constant into the C source for any value up to the maximum size of the type. </p>\n<p>The GCC documentation says \"There is no support in GCC for expressing an integer constant of type __int128 for targets with  long long integer less than 128 bits wide.\"</p>\n<p>Therefore, it cannot be used for intmax_t.</p>\n", "LastActivityDate": "2014-08-03T22:06:02.880", "CommentCount": "2", "CreationDate": "2014-08-03T22:06:02.880", "ParentId": "21265462", "Score": "4", "OwnerUserId": "3710044"}, "bq_ids": {"n4140": {"so_21265462_21267714_2": {"length": 7, "quality": 0.875, "section_id": 7211}, "so_21265462_21267714_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 5776}}, "n3337": {"so_21265462_21267714_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 5549}, "so_21265462_21267714_2": {"length": 7, "quality": 0.875, "section_id": 6955}}, "n4659": {"so_21265462_21267714_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 7233}, "so_21265462_21267714_2": {"length": 7, "quality": 0.875, "section_id": 8720}}}, "21267714": {"Id": "21267714", "PostTypeId": "2", "Body": "<p>I believe this is a violation of the C and C++ standards -- either that, or gcc doesn't consider <code>__int128_t</code> to be an integer type.</p>\n<p>The C standard (both the 1999 and 2011 editions) doesn't require <code>intmax_t</code> to be one of the standard types; it's required to be \"a signed integer type capable of representing any value of any signed integer type\". In particular, it can be an <em>extended integer type</em> -- and if there is a 128-bit extended integer type, then <code>intmax_t</code> must be at least 128 bits wide.</p>\n<p>The C standard even suggests using implementation-defined keywords that \"have the form of an identifier reserved for any use\" as the names of extended integer types -- such as <code>__int128_t</code>.</p>\n<p>The 2011 C++ standard adopts C99's extended integer types feature, and defers to the 1999 C standard for the definition of <code>intmax_t</code> and <code>&lt;stdint.h&gt;</code>.</p>\n<p>So if <code>__int128_t</code> is an <em>integer type</em> within the meaning defined by the standard (which it certainly <em>can</em> be), and is, as the name implies, 128 bits wide, then <code>intmax_t</code> must be at least 128 bits wide.</p>\n<p>As <a href=\"https://stackoverflow.com/a/21265561/827263\">Stephen Canon's answer</a>, changing <code>intmax_t</code> does require some work. The C and C++ standards do not recognize that as a justification for defining <code>intmax_t</code> incorrectly.</p>\n<p>Of course all of this applies equally to <code>uintmax_t</code>.</p>\n<pre class=\"lang-c prettyprint-override\"><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\nint main(void) {\n    __uint128_t huge = UINTMAX_MAX;\n    huge ++;\n    if (huge &gt; UINTMAX_MAX) {\n        puts(\"This should not happen\");\n    }\n}\n</code></pre>\n<p>On my system (Linux x86_64, gcc 4.7.2), the above program prints:</p>\n<pre class=\"lang-none prettyprint-override\"><code>This should not happen\n</code></pre>\n<p>If gcc conforms to the standard, then that should be possible only if <code>__int128_t</code> is not an integer type -- but quoting the <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.8.2/gcc/_005f_005fint128.html\" rel=\"nofollow noreferrer\">gcc 4.8.2 manual</a> (emphasis added):</p>\n<blockquote>\n<p id=\"so_21265462_21267714_0\">As an extension the <strong>integer scalar type</strong> <code>__int128</code> is supported for\n  targets which have an integer mode wide enough to hold 128 bits.\n  Simply write <code>__int128</code> for a signed 128-bit integer, or <code>unsigned __int128</code>\n  for an unsigned 128-bit integer. There is no support in GCC for expressing an integer\n  constant of type <code>__int128</code> for targets with\n  <code>long long</code> integer less than 128 bits wide.</p>\n</blockquote>\n<p>I suppose one could argue that the \"as an extension\" phrase lets gcc off the hook here, justifying the existence of <code>__int128_t</code> under section 4 paragraph 6 of the standard:</p>\n<blockquote>\n<p id=\"so_21265462_21267714_1\">A conforming implementation may have extensions (including additional\n  library functions), provided they do not alter the behavior of any\n  strictly conforming program.</p>\n</blockquote>\n<p>rather than under section 6.2.6 paragraph 4:</p>\n<blockquote>\n<p id=\"so_21265462_21267714_2\">There may also be implementation-defined <em>extended signed integer\n  types</em>.</p>\n</blockquote>\n<p>(I personally think that making <code>intmax_t</code> at least as wide as <code>__int128_t</code>, if it exists, would be more in keeping with the <em>intent</em> of the standard, even if it's (barely) possible to argue that it doesn't violate the <em>letter</em> of the standard.)</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-01-21T20:46:53.093", "Score": "12", "CreationDate": "2014-01-21T19:52:01.677", "ParentId": "21265462", "CommentCount": "6", "OwnerUserId": "827263", "LastEditDate": "2017-05-23T12:16:59.013"}, "21265561": {"Id": "21265561", "PostTypeId": "2", "Body": "<p>Changing <code>intmax_t</code> requires not only changes to a compiler but also to numerous standard library functions that need to accept <code>intmax_t</code> arguments (and platform ABIs may define <code>intmax_t</code> as well).  A compiler can unilaterally provide <code>__int128_t</code> as an extension, but it cannot unilaterally change the type <code>intmax_t</code>.  That requires support from all of the standard library implementations that the compiler targets.</p>\n", "LastActivityDate": "2014-01-21T17:51:45.500", "CommentCount": "2", "CreationDate": "2014-01-21T17:51:45.500", "ParentId": "21265462", "Score": "12", "OwnerUserId": "142434"}});