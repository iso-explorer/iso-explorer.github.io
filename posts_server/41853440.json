post_cb({"bq_ids": {"n4140": {"so_41853440_41853668_2": {"length": 6, "quality": 1.0, "section_id": 438}, "so_41853440_41853668_3": {"length": 29, "quality": 1.0, "section_id": 438}, "so_41853440_41853668_0": {"length": 39, "quality": 0.9069767441860465, "section_id": 441}, "so_41853440_41853668_4": {"length": 13, "quality": 1.0, "section_id": 438}, "so_41853440_41853668_7": {"length": 11, "quality": 0.7333333333333333, "section_id": 438}, "so_41853440_41853668_6": {"length": 5, "quality": 1.0, "section_id": 438}, "so_41853440_41853668_5": {"length": 15, "quality": 1.0, "section_id": 438}}, "n3337": {"so_41853440_41853668_2": {"length": 6, "quality": 1.0, "section_id": 429}, "so_41853440_41853668_3": {"length": 29, "quality": 1.0, "section_id": 429}, "so_41853440_41853668_0": {"length": 39, "quality": 0.9069767441860465, "section_id": 432}, "so_41853440_41853668_4": {"length": 13, "quality": 1.0, "section_id": 429}, "so_41853440_41853668_7": {"length": 11, "quality": 0.7333333333333333, "section_id": 429}, "so_41853440_41853668_6": {"length": 5, "quality": 1.0, "section_id": 429}, "so_41853440_41853668_5": {"length": 15, "quality": 1.0, "section_id": 429}}, "n4659": {"so_41853440_41853668_0": {"length": 37, "quality": 0.8604651162790697, "section_id": 461}, "so_41853440_41853668_3": {"length": 29, "quality": 1.0, "section_id": 458}, "so_41853440_41853668_2": {"length": 6, "quality": 1.0, "section_id": 458}, "so_41853440_41853668_4": {"length": 13, "quality": 1.0, "section_id": 458}, "so_41853440_41853668_7": {"length": 11, "quality": 0.7333333333333333, "section_id": 458}, "so_41853440_41853668_6": {"length": 5, "quality": 1.0, "section_id": 458}, "so_41853440_41853668_5": {"length": 15, "quality": 1.0, "section_id": 458}}}, "41853440": {"ViewCount": "783", "Body": "<p>I don't understand why the output of this program is as follows. Why isn't there a compilation error? I thought when trying to construct B, the compiler would find no function called foo() and report an error.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct A{\n    int a;\n    A(int i=0) : a(i) { cout &lt;&lt; \"A\" &lt;&lt; endl; }\n    ~A() { cout &lt;&lt; \"Bye A\" &lt;&lt; endl; }\n    int foo() { return a; }\n};\nstruct B{\n    int b;\n    B(int i=0) : b(i) { cout &lt;&lt; \"B\" &lt;&lt; endl; }\n    ~B() { cout &lt;&lt; \"Bye B\" &lt;&lt; endl; }\n    int bar() { return b; }\n};\nstruct C : B, A {\n    C(int i=0) : B(foo()), A(i) {}\n};\n\nint main() {\n    cout &lt;&lt; C(10).bar() &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>The output:</p>\n<pre><code>B\nA\n0\nBye A\nBye B\n</code></pre>\n<p>In general, I would like to know when there is multiple inheritance, what is the order in which the parent structs are constructed and initialized? Can I expect a similar behavior in classes too?</p>\n<p>Any explanation regarding the order of constructor and destructor calls is much appreciated.</p>\n<p><strong>Note:</strong> This is not homework. And, I have researched similar topics but nothing came up regarding this issue.</p>\n", "AcceptedAnswerId": "41853668", "Title": "Concerning Struct Constructor and Destructor behavior - C++", "CreationDate": "2017-01-25T13:55:31.850", "Id": "41853440", "CommentCount": "9", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-01-25T15:21:30.857", "Score": "9", "OwnerUserId": "5550579", "Tags": "<c++><struct><constructor><destructor><multiple-inheritance>", "AnswerCount": "2"}, "41853671": {"Id": "41853671", "PostTypeId": "2", "Body": "<p>This is just another case of undefined behavior. For example, my system gives the following results.</p>\n<pre><code>B\nA\n-858993460\nBye A\nBye B\n</code></pre>\n<p>Try this <a href=\"http://coliru.stacked-crooked.com/a/bcaf677e5fb96e71\" rel=\"nofollow noreferrer\">live demo</a> which produces yet another distinct result (<code>C(10).bar()</code> produced 32764).</p>\n<p><code>foo()</code> can be called in this context, but it will be called <em>before</em> <code>A</code>'s constructor. This means <code>a</code> is initialized, which leads to reading an uninitialized variable, which leads to undefined behavior. This is similar to accessing a member before it's initialized. Consider the following example. <code>a</code> is initialized to <code>b</code>'s value, then <code>b</code> is initialized. The problem is obvious, <code>b</code> is uninitialized at the point where it's read to initialize <code>a</code>.</p>\n<pre><code>struct foo\n{\n    foo(int x) : a(b), b(x) {}\n    int a;\n    int b;\n};\n\nint main()\n{\n    foo bar(10);\n}\n</code></pre>\n", "LastEditorUserId": "7359094", "LastActivityDate": "2017-01-25T14:11:24.330", "Score": "5", "CreationDate": "2017-01-25T14:06:06.810", "ParentId": "41853440", "CommentCount": "0", "OwnerUserId": "7359094", "LastEditDate": "2017-01-25T14:11:24.330"}, "41853668": {"Id": "41853668", "PostTypeId": "2", "Body": "<h2>Undefined behavior</h2>\n<p>You're invoking undefined behavior by calling <code>foo</code> before the object is fully initialized. Quote from 12.6.2 in the C++ standard :</p>\n<blockquote>\n<p id=\"so_41853440_41853668_0\">Member functions (including virtual member functions, 10.3) can be called for an object under construction.\n  Similarly, an object under construction can be the operand of the <code>typeid</code> operator (5.2.8) or of a <code>dynamic_cast</code> (5.2.7). However, if these operations are performed in a <em>ctor-initializer</em> (or in a function called directly\n  or indirectly from a <em>ctor-initializer</em>) before all the <em>mem-initializers</em> for base classes have completed, the result\n  of the operation is undefined. <em>[ Example:</em></p>\n</blockquote>\n<pre><code>class A {\npublic:\n  A(int);\n};\n\nclass B : public A {\n  int j;\npublic:\n  int f();\n  B() : A(f()),       // undefined: calls member function\n                      // but base A not yet initialized\n          j(f()) { }  // well-defined: bases are all initialized\n};\n\nclass C {\npublic:\n  C(int);\n};\n\nclass D : public B, C {\n  int i;\npublic:\n  D() : C(f()),       // undefined: calls member function\n                      // but base C not yet initialized\n          i(f()) { }  // well-defined: bases are all initialized\n};\n</code></pre>\n<blockquote>\n<p id=\"so_41853440_41853668_1\"><em>\u2014 end example ]</em></p>\n</blockquote>\n<p>In other words, this would be ok according to the standard :</p>\n<pre><code>C(int i=0) : B(), A(i) {\n    B::b = foo();\n}\n</code></pre>\n<p>And this will print <code>10</code> instead of the <code>0</code> that you got (which could have been anything else, since that was undefined behavior).</p>\n<h2>Initialization order</h2>\n<p>Setting aside this matter of undefined behavior, and to address your question, the order in which initialization happens is well-defined :</p>\n<blockquote>\n<p id=\"so_41853440_41853668_2\">In a non-delegating constructor, initialization proceeds in the following order:</p>\n<p id=\"so_41853440_41853668_3\">\u2014 First, and only for the constructor of the most derived class (1.8), virtual base classes are initialized in\n  the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes,\n  where \u201cleft-to-right\u201d is the order of appearance of the base classes in the derived class <em>base-specifier-list</em>.</p>\n<p id=\"so_41853440_41853668_4\">\u2014 Then, direct base classes are initialized in declaration order as they appear in the <em>base-specifier-list</em>\n  (regardless of the order of the <em>mem-initializers</em>).</p>\n<p id=\"so_41853440_41853668_5\">\u2014 Then, non-static data members are initialized in the order they were declared in the class definition\n  (again regardless of the order of the <em>mem-initializers</em>).</p>\n<p id=\"so_41853440_41853668_6\">\u2014 Finally, the <em>compound-statement</em> of the constructor body is executed.</p>\n<p id=\"so_41853440_41853668_7\"><em>[ Note:</em> The declaration order is mandated to ensure that base and member subobjects are destroyed in\n  the reverse order of initialization. <em>\u2014 end note ]</em></p>\n</blockquote>\n<p>So, in your code, the initialization order is : <code>B</code> (<code>B::b</code>), <code>A</code> (<code>A::a</code>), <code>C</code> ().</p>\n<p>As noted in the comments below though, changing this initialization order (by eg. using <code>struct C : A, B</code> instead of <code>struct C : B, A</code>) would not however get rid of the undefined behavior. Calling <code>A::foo</code> before the <code>B</code> part is initialized remains undefined, even if the <code>A</code> part is initialized.</p>\n", "LastEditorUserId": "822669", "LastActivityDate": "2017-01-25T15:21:30.857", "Score": "16", "CreationDate": "2017-01-25T14:05:59.533", "ParentId": "41853440", "CommentCount": "10", "OwnerUserId": "822669", "LastEditDate": "2017-01-25T15:21:30.857"}});