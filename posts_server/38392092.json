post_cb({"38392524": {"ParentId": "38392092", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>No, there is no support in <code>tuple</code> or <code>pair</code> for passing no-move types to their constructors, and as you've observed there cannot be, since the constructor argument and tuple (or pair) member <strong>can be observed to be different objects</strong>:</p>\n<pre><code>// exposition only\ntemplate&lt;class... Us&gt;\ntuple(Us&amp;&amp;... us) : values{std::forward&lt;Us&gt;(us)...} {}\n              ^^ these\n                    ^^^^^^ are different objects to these\n</code></pre>\n<p>You would have to use piecewise construction:</p>\n<pre><code>return std::pair&lt;std::string, nocopy&gt;(std::piecewise_construct,\n    std::forward_as_tuple(), std::forward_as_tuple());\n</code></pre>\n<p>Matt Calabrese made an <a href=\"https://isocpp.org/forums/iso-c-standard-future-proposals?place=msg%2Fstd-proposals%2FJ62lsMB6Egc%2F38M9WKYvCQAJ\" rel=\"noreferrer\">interesting point</a> on the std-proposals list that now we have guaranteed RVO it should be possible to write components that accept factories to construct their members effectively inplace:</p>\n<pre><code>// hypothetical factory constructor\nreturn std::pair(std::factory_construct,\n    [] { return std::string{}; }, [] { return nocopy{}; });\n</code></pre>\n<p>Another possible direction would be to remove the constructors from <code>tuple</code> and <code>pair</code> (or, more realistically, to write workalike components without constructors) and rely on the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0017r0.html\" rel=\"noreferrer\">new extensions to aggregate initialization</a> that should permit aggregate initialization of <code>tuple</code> and <code>pair</code> implemented via multiple-inheritance. <a href=\"http://melpon.org/wandbox/permlink/63SPQHgu1myz3Twi\" rel=\"noreferrer\">Example</a>.</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2016-07-15T09:56:06.643", "Id": "38392524", "Score": "6", "CreationDate": "2016-07-15T09:25:58.403", "LastActivityDate": "2016-07-15T09:56:06.643"}, "bq_ids": {"n4140": {"so_38392092_38392092_2": {"section_id": 4019, "quality": 0.5555555555555556, "length": 5}}, "n3337": {"so_38392092_38392092_2": {"section_id": 3869, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_38392092_38392092_2": {"section_id": 4925, "quality": 0.5555555555555556, "length": 5}}}, "38392092": {"CommentCount": "4", "ViewCount": "328", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-07-15T09:02:53.123", "LastActivityDate": "2016-07-15T09:56:06.643", "Title": "Do std::tuple and std::pair support aggregate initialization?", "AcceptedAnswerId": "38392524", "LastEditDate": "2017-05-23T12:32:02.037", "Id": "38392092", "Score": "7", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/language/aggregate_initialization\" rel=\"nofollow noreferrer\">Aggregate initialization</a> requires among other things <em>no user-provided constructors</em>. But <code>std::tuple</code> and <code>std::pair</code> pair have a large set of <a href=\"http://en.cppreference.com/w/cpp/utility/tuple/tuple\" rel=\"nofollow noreferrer\">overloaded constructors</a>. From the point of the core language, are these constructors <em>user-provided</em> or even <em>user-declared</em> ?</p>\n<p>With C++17 it will be possible to write (update/clarification: where nocopy is a class that can not be copied or moved, such as <code>std::mutex</code>)</p>\n<pre><code>auto get_ensured_rvo_str(){\n   return std::pair(std::string(),nocopy());\n}\n</code></pre>\n<p><strong><em>edit: no, it's not possible as explained in the linked to answers and the answer below.</em></strong></p>\n<p>which requires aggregate initialization (for context: <a href=\"https://stackoverflow.com/questions/38385451/multiple-return-values-structured-bindings-with-unmovable-types-or-guaranteed\">Multiple return values (structured bindings) with unmovable types and guaranteed RVO in C++17</a>).</p>\n<p>Are <code>tuple</code> and <code>pair</code> backed by special standard language to allow this (in presence of constructors) ? :</p>\n<blockquote>\n<p id=\"so_38392092_38392092_0\">20.5.2.1 Construction</p>\n<p id=\"so_38392092_38392092_1\">... \n  EXPLICIT constexpr tuple(const Types&amp;...); </p>\n<p id=\"so_38392092_38392092_2\">6 \n  Effects: The\n  constructor initializes each element with the value of the\n  corresponding parameter.</p>\n</blockquote>\n<p>or can we in principle write our own <code>tuple</code> or <code>pair</code>?</p>\n", "Tags": "<c++><tuples><aggregate><std-pair><c++1z>", "OwnerUserId": "1149664", "AnswerCount": "1"}});