post_cb({"bq_ids": {"n4140": {"so_42361656_42367505_3": {"length": 26, "quality": 0.6666666666666666, "section_id": 5913}, "so_42361656_42367505_2": {"length": 14, "quality": 0.875, "section_id": 3285}, "so_42361656_42367505_1": {"length": 26, "quality": 0.8125, "section_id": 5913}, "so_42361656_42367505_0": {"length": 20, "quality": 0.5128205128205128, "section_id": 7189}}, "n3337": {"so_42361656_42367505_2": {"length": 14, "quality": 0.875, "section_id": 3155}, "so_42361656_42367505_1": {"length": 26, "quality": 0.8125, "section_id": 5685}, "so_42361656_42367505_0": {"length": 20, "quality": 0.5128205128205128, "section_id": 6933}}, "n4659": {"so_42361656_42367505_3": {"length": 35, "quality": 0.8974358974358975, "section_id": 7405}, "so_42361656_42367505_2": {"length": 14, "quality": 0.875, "section_id": 4047}, "so_42361656_42367505_1": {"length": 30, "quality": 0.9375, "section_id": 7404}, "so_42361656_42367505_0": {"length": 35, "quality": 0.8974358974358975, "section_id": 8697}}}, "42382218": {"Id": "42382218", "PostTypeId": "2", "Body": "<p>I just share an idear, maybe we can use metaprograming like this:</p>\n<pre><code>template&lt;typename T1, typename T2&gt;\nstruct Bigger\n{\n  typedef typename std::conditional&lt;sizeof(T1) &gt;= sizeof(T2), T1, T2&gt;::type Type;\n};\n\n// Recursion helper\ntemplate&lt;typename...&gt;\nstruct BiggestHelper;\n\n// 2 or more types\ntemplate&lt;typename T1, typename T2, typename... TArgs&gt;\nstruct BiggestHelper&lt;T1, T2, TArgs...&gt;\n{\n    typedef typename Bigger&lt;T1, typename BiggestHelper&lt;T2, TArgs...&gt;::Type&gt;::Type Type;\n};\n\n// Exactly 2 types\ntemplate&lt;typename T1, typename T2&gt;\nstruct BiggestHelper&lt;T1, T2&gt;\n{\n    typedef typename Bigger&lt;T1, T2&gt;::Type Type;\n};\n\n// Exactly one type\ntemplate&lt;typename T&gt;\nstruct BiggestHelper&lt;T&gt;\n{\n    typedef T Type;\n};\n\ntemplate&lt;typename... TArgs&gt;\nstruct Biggest\n{\n    typedef typename BiggestHelper&lt;TArgs...&gt;::Type Type;\n};\n</code></pre>\n<p>So in the main fucntion we can do like this:</p>\n<pre><code>std::memset(&amp;b, 0, sizeof(Biggest&lt;int,s,char&gt;::Type));\n</code></pre>\n", "LastEditorUserId": "2593814", "LastActivityDate": "2017-02-22T10:06:46.023", "Score": "1", "CreationDate": "2017-02-22T03:33:58.353", "ParentId": "42361656", "CommentCount": "0", "OwnerUserId": "2593814", "LastEditDate": "2017-02-22T10:06:46.023"}, "42362939": {"Id": "42362939", "PostTypeId": "2", "Body": "<p>Just <code>memset</code> every member, and count on the optimizer to eliminate redundant writes.</p>\n", "LastActivityDate": "2017-02-21T09:07:15.220", "CommentCount": "1", "CreationDate": "2017-02-21T09:07:15.220", "ParentId": "42361656", "Score": "4", "OwnerUserId": "15416"}, "42367505": {"Id": "42367505", "PostTypeId": "2", "Body": "<p>If you really want to respect the standard, you should know that the code you have written is <em>undefined behaviour</em>:C++ standard \u00a73.8 [basic.life]:</p>\n<blockquote>\n<p id=\"so_42361656_42367505_0\">...\n  except that if the object is a union member or subobject thereof, its lifetime only begins if that union member\n  is the initialized member in the union (8.6.1, 12.6.2), or as described in 9.3. The lifetime of an object o of\n  type T ends when:\n  (1.3) \u2014 if T is a class type with a non-trivial destructor (12.4), the destructor call starts, or\n  (1.4) \u2014 the storage which the object occupies is released, or is reused by an object that is not nested within\n  o (1.8).</p>\n</blockquote>\n<p>In \u00a79.3 it is explained that you can activate a member of a standard-layout union by assigning to it. It also explains that you can explore the value of a member of a union which is not activated only when certain criteria are respected:</p>\n<blockquote>\n<p id=\"so_42361656_42367505_1\">If a standard-layout union\n  contains several standard-layout structs that share a common initial sequence (9.2), and if a non-static data\n  member of an object of this standard-layout union type is active and is one of the standard-layout structs, it is permitted to inspect the common initial sequence of any of the standard-layout struct members; see 9.2.\n  \u2014 end note ]</p>\n</blockquote>\n<p>So when you write <code>std::cout&lt;&lt; a &lt;&lt; \"\\n\"</code> you have not initialized <code>a</code>, or activated it by an assignment, and no member have been initialized so you are in <strong>Undefined Behavior</strong> (Nota: but the compilers I know support it, at least on PC, as an extension to the standard.)</p>\n<p>So before using <code>a</code> you will have to write <code>a=0</code>, or make <code>a</code> the initialized member of the union, because <code>a</code> does not share a common initialization sequence with neither <code>b</code> nor <code>c</code>.</p>\n<p>So <strong>if you use <code>memset</code></strong> as also proposed in the answer of <em>MSalters</em> whatever you do, <strong>you will have to assign something to a member of the union before using it</strong>. If want to stay in <em>defined behavior</em>, do not use <code>memset</code>. Notice that <code>memset</code> can safely be used with standard-layout object which are not member of union since their life-time begin when storage is obtained for them.</p>\n<hr>\n<p><strong>In conclusion to stay in defined behaviour you must at least initialize one member</strong>, then you can inspect other members of the union who share a common initialization sequence with the initialized member.</p>\n<ol>\n<li><p>If your intent is to use an anonymous union in the main function,\nyou can declare the union static: all static objects are zero initialized. (But are not reinitialized when you recall the function which will not happen with <code>main()</code>):</p>\n<pre><code>int main(){\n static union {\n  s b;\n  int a;\n  char c;\n  };\n //...\n }\n</code></pre>\n<p>As described in C++ standard \u00a78.6 article (6.3) [dcl.init]:</p>\n<blockquote>\n<p id=\"so_42361656_42367505_2\">if T is a (possibly cv-qualified) union type, the object\u2019s first non-static named data member is zero-\n  initialized and padding is initialized to zero bits;</p>\n</blockquote></li>\n<li><p>Otherwise if there are no padding between member of the structures (<code>s</code>), you can aggregate initialize with an empty list the larger member (<code>s</code>):</p>\n<pre><code>//...\nint main(){\n  union {\n   int a;\n   s b{};\n   char c;\n   };\n  //...\n  }\n</code></pre>\n<p>This work because all members of unions are aligned. So if there are no padding between members of <code>s</code>, every byte of memory of the union will be zero initialized, C++ standard \u00a79.3 [class.union] article 2:</p>\n<blockquote>\n<p id=\"so_42361656_42367505_3\">The size of a union is sufficient to contain the largest of its non-static data members. Each non-static data\n  member is allocated as if it were the sole member of a struct. [ Note: A union object and its non-static data\n  members are pointer-interconvertible (3.9.2, 5.2.9). As a consequence, all non-static data members of a union\n  object have the same address.</p>\n</blockquote></li>\n<li><p>If there is padding inside S, then just declare an array of char for initialization purpose:</p>\n<pre><code>//...\nint main(){\n  union {\n   char _initialization[sizeof(s)]{};\n   int a;\n   s b;\n   char c;\n   };\n  //...\n  }\n</code></pre></li>\n</ol>\n<hr>\n<p>Nota: Using your example, or the two last code exemples, and the code using <code>memset</code> produces the exact same set of instructions for initialization (clang -&gt; x86_64):</p>\n<pre><code>    pushq   %r14\n    pushq   %rbx\n    subq    $120, %rsp\n    xorps   %xmm0, %xmm0\n    movaps  %xmm0, 96(%rsp)\n    movaps  %xmm0, 80(%rsp)\n    movaps  %xmm0, 64(%rsp)\n    movaps  %xmm0, 48(%rsp)\n    movaps  %xmm0, 32(%rsp)\n    movaps  %xmm0, 16(%rsp)\n    movq    $0, 109(%rsp)\n</code></pre>\n</hr></hr>", "LastEditorUserId": "5632316", "LastActivityDate": "2017-03-02T10:07:29.387", "Score": "4", "CreationDate": "2017-02-21T12:34:41.047", "ParentId": "42361656", "CommentCount": "3", "OwnerUserId": "5632316", "LastEditDate": "2017-03-02T10:07:29.387"}, "42361656": {"ViewCount": "552", "Body": "<p>How should I zero out an anonymous union? I couldn't find anything on <a href=\"http://en.cppreference.com/w/cpp/language/union\" rel=\"noreferrer\">cppreference</a> page about it. Would <code>memset</code>ing it's largest member with <code>0</code> work here?</p>\n<p>For example -</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nstruct s{\n    char a;\n    char b[100];\n};\n\nint main(){\n union {\n   int a;\n   s b;\n   char c;\n };\n\n  // b.a = 'a'; (1)\n\n  std::memset(&amp;b, 0, sizeof(b));\n\n  std::cout &lt;&lt; a &lt;&lt; \"\\n\";\n  std::cout &lt;&lt; b.a &lt;&lt; \" \" &lt;&lt; b.b &lt;&lt; \"\\n\";\n  std::cout &lt;&lt; c &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Also if this would work, should I uncomment (1) before using <code>memset()</code> to activate the largest member?</p>\n", "AcceptedAnswerId": "42367505", "Title": "How to memset an anonymous union with 0", "CreationDate": "2017-02-21T07:59:23.020", "Id": "42361656", "CommentCount": "18", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-02-21T08:07:15.500", "LastEditorUserId": "2648679", "LastActivityDate": "2017-03-02T10:07:29.387", "Score": "11", "OwnerUserId": "2648679", "Tags": "<c++><initialization><c++14><unions><memset>", "AnswerCount": "3"}});