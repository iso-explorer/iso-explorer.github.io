post_cb({"6640936": {"ParentId": "3029412", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_3029412_6640936_0\">But I think C++ must provide it.</p>\n</blockquote>\n<p>Why? You think that C++ must provide the ability to make non-negative numbers negative? That's silly.</p>\n<p>Unsigned values in C++ are defined to always be non-negative. They even wrap around \u2014 rather than underflowing \u2014 at zero! (And the same at the other end of the range)</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "6640936", "Score": "0", "CreationDate": "2011-07-10T11:54:52.257", "LastActivityDate": "2011-07-10T11:54:52.257"}, "3029941": {"ParentId": "3029412", "CommentCount": "4", "Body": "<p>Don't be fooled by the name: unsigned is often misunderstood as non-negative, but the rules for the language are different... probably a better name would have been \"bitmask\" or \"modulo_integer\".</p>\n<p>If you think that unsigned is non-negative then for example implicit conversion rules are total nonsense (why a difference between two non-negative should be a non-negative ? why the addition of a non-negative and an integer should be non-negative ?).</p>\n<p>It's very unfortunate that C++ standard library itself fell in that misunderstanding because for example vector.size() is unsigned (absurd if you mean it as the language itself does in terms of bitmask or modulo_integer). This choice for sizes has more to do with the old 16-bit times than with unsigned-ness and it was in my opinion a terrible choice that we're still paying as bugs.</p>\n", "OwnerUserId": "320726", "PostTypeId": "2", "Id": "3029941", "Score": "0", "CreationDate": "2010-06-12T20:05:38.633", "LastActivityDate": "2010-06-12T20:05:38.633"}, "3029453": {"ParentId": "3029412", "CommentCount": "0", "Body": "<p>I think you are thinking it the wrong way.</p>\n<p>If you want a negative number, then you must not declare the variable as unsigned.</p>\n<p>If your problem is the value range, and you want that one more bit, then you could use a \"bigger\" data type (int 64 for example...). </p>\n<p>Then if you are using legacy code, creating a new struct can solve your problem, but this is that way because of your specific situation, C++ shouldn't handle it.</p>\n", "OwnerUserId": "295096", "PostTypeId": "2", "Id": "3029453", "Score": "0", "CreationDate": "2010-06-12T17:10:09.737", "LastActivityDate": "2010-06-12T17:10:09.737"}, "3029412": {"CommentCount": "5", "AcceptedAnswerId": "3029415", "PostTypeId": "1", "LastEditorUserId": "11343", "CreationDate": "2010-06-12T16:56:40.673", "LastActivityDate": "2012-05-04T23:21:01.267", "LastEditDate": "2012-05-04T23:21:01.267", "ViewCount": "698", "FavoriteCount": "1", "Title": "Unsigned negative primitives?", "Id": "3029412", "Score": "7", "Body": "<p>In C++ we can make primitives <code>unsigned</code>. But they are always positive. Is there also a way to make unsigned negative variables? I know the word unsigned means \"without sign\", so also not a minus (-) sign. But I think C++ must provide it.</p>\n", "Tags": "<c++><unsigned><primitive><negative-number>", "OwnerUserId": "155137", "AnswerCount": "5"}, "3029415": {"ParentId": "3029412", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>No. <code>unsigned</code> can only contain nonnegative numbers.</p>\n<p>If you need a type that only represent negative numbers, you need to write a class yourself, or just interpret the value as negative in your program.</p>\n<p>(But why do you need such a type?)</p>\n", "OwnerUserId": "224671", "LastEditorUserId": "224671", "LastEditDate": "2010-06-12T17:04:25.740", "Id": "3029415", "Score": "4", "CreationDate": "2010-06-12T16:58:04.630", "LastActivityDate": "2010-06-12T17:04:25.740"}, "bq_ids": {"n4140": {"so_3029412_3029439_0": {"section_id": 7212, "quality": 0.8421052631578947, "length": 16}, "so_3029412_3029439_1": {"section_id": 7213, "quality": 0.875, "length": 14}}, "n3337": {"so_3029412_3029439_0": {"section_id": 6956, "quality": 0.8421052631578947, "length": 16}, "so_3029412_3029439_1": {"section_id": 6957, "quality": 1.0, "length": 16}}, "n4659": {"so_3029412_3029439_0": {"section_id": 8721, "quality": 0.9473684210526315, "length": 18}, "so_3029412_3029439_1": {"section_id": 8722, "quality": 0.875, "length": 14}}}, "3029439": {"ParentId": "3029412", "CommentCount": "0", "Body": "<p><code>unsigned</code> integers are only positive. From 3.9.1 paragraph 3 of the 2003 C++ standard:</p>\n<blockquote>\n<p id=\"so_3029412_3029439_0\">The range of nonnegative values of a\n  signed integer type is a subrange of\n  the corresponding unsigned integer\n  type, and the value representation of\n  each corresponding signed/unsigned\n  type shall be the same.</p>\n</blockquote>\n<p>The main purpose of the unsigned integer types is to support modulo arithmetic. From 3.9.1 paragraph 4:</p>\n<blockquote>\n<p id=\"so_3029412_3029439_1\">Unsigned integers, declared unsigned,\n  shall obey the laws of arithmetic\n  modulo 2<sup>n</sup> where n is the\n  number of bits in the value\n  representation of that particular size\n  of integer.</p>\n</blockquote>\n<p>You are free, of course, to treat them as negative if you wish, you'll just have to keep track of that yourself somehow (perhaps with a Boolean flag).</p>\n", "OwnerUserId": "63485", "PostTypeId": "2", "Id": "3029439", "Score": "2", "CreationDate": "2010-06-12T17:06:42.390", "LastActivityDate": "2010-06-12T17:06:42.390"}});