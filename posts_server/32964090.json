post_cb({"32964293": {"ParentId": "32964090", "PostTypeId": "2", "CommentCount": "12", "Body": "<h2>Why it doesn't work</h2>\n<p>In your example both overloads are considered by the compiler matches. Here comes overload resolution to the rescue to eliminate one and keep the best match. According to the draft standard <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf\" rel=\"nofollow\">N4527</a> <em>13.3.3/1.6 Best viable function [over.match.best]:</em></p>\n<blockquote>\n<p id=\"so_32964090_32964293_0\">F1 is not a function template specialization and F2 is a function\n  template specialization</p>\n</blockquote>\n<p>In our case F1 is <code>void foo(const int *)</code> and <code>F2</code> is <code>template&lt;int N&gt;\nvoid foo(const int (&amp;)[N])</code>. Thus, F1 will be prefered over F2 because F1 is not a template specialization while F2 is.</p>\n<h2>Solution</h2>\n<p>Pass the pointer by reference in the second overload:</p>\n<pre><code>void foo(const int *&amp;) {\n    std::cout &lt;&lt; \"foo(const int *)\\n\";\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/ee52367f8e5a3bd5\" rel=\"nofollow\">LIVE DEMO</a></p>\n<h2>Why the suggested solution works</h2>\n<p>Now as dyp already mentioned in the comments, if you pass the pointer by reference as shown earlier above, this match is broken because <code>const int *&amp;</code> cannot match to <code>int*</code> neither to <code>int[N]</code>.</p>\n", "OwnerUserId": "2352671", "LastEditorUserId": "2352671", "LastEditDate": "2015-10-06T08:36:12.790", "Id": "32964293", "Score": "2", "CreationDate": "2015-10-06T07:38:00.130", "LastActivityDate": "2015-10-06T08:36:12.790"}, "32964090": {"CommentCount": "1", "ViewCount": "151", "CreationDate": "2015-10-06T07:25:23.593", "LastActivityDate": "2015-10-06T08:36:12.790", "Title": "Overload function for both arrays-of-const and pointers-to-const", "FavoriteCount": "2", "PostTypeId": "1", "Id": "32964090", "Score": "9", "Body": "<p>I can capture an array along with its (compile-time) size using a template function like so:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>template&lt;int N&gt;\nvoid foo(const int (&amp;)[N]) {\n    std::cout &lt;&lt; \"foo(const int (&amp;)[N])\\n\";\n}\n</code></pre>\n<p>However, I'd like to overload <code>foo</code> to also allow pointers-to-const, so that the first overload is used when the function is called on an array type, and the second one when it's called on a pointer directly.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>void foo(const int *) {\n    std::cout &lt;&lt; \"foo(const int *)\\n\";\n}\n\nint main() {\n    int a[1] = { 0 };\n    foo(a);\n    const int b[1] = { 0 };\n    foo(b);\n}\n</code></pre>\n<p><kbd><a href=\"http://ideone.com/FkqUNC\">Try it on ideone</a></kbd></p>\n<p>Here, the first overload is called for <code>a</code>, the second one for <code>b</code>.</p>\n<p>My guess is that for <code>a</code>, the compiler must perform a conversion-to-const which means that <code>foo(const int *)</code> is not a perfect match, but I'm lost to why this is not even an ambigous function call.</p>\n<p><strong>How can I change the code so that the first overload is called in both cases?</strong></p>\n", "Tags": "<c++><arrays><templates><pointers><overloading>", "OwnerUserId": "1522056", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_32964090_32964293_0": {"section_id": 126, "quality": 1.0, "length": 6}}, "n3337": {"so_32964090_32964293_0": {"section_id": 120, "quality": 1.0, "length": 6}}, "n4659": {"so_32964090_32964293_0": {"section_id": 131, "quality": 1.0, "length": 6}}}});