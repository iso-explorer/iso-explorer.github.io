post_cb({"4644753": {"CommentCount": "0", "AcceptedAnswerId": "4644783", "PostTypeId": "1", "LastEditorUserId": "451980", "CreationDate": "2011-01-10T08:03:26.790", "LastActivityDate": "2016-03-04T06:02:45.880", "LastEditDate": "2011-01-10T17:09:11.033", "ViewCount": "11962", "FavoriteCount": "3", "Title": "C++ dynamic_cast - polymorphic requirement and downcasting", "Id": "4644753", "Score": "7", "Body": "<p>In the following code, while construction of <code>obj</code> in <code>case 1</code> we would any how construct <code>derived</code> class too but it's member functions are just inaccessible to <code>obj</code>. So while down-\ncasting ( i.e., in case 2 ) , using <code>obj</code> as source, we any how has the constructed <code>derived</code> in it. Why would it require <code>obj</code> needs to be polymorphic?</p>\n<p>If I confused you with my above description, Why in upcast <code>obj</code> need not to be polymorphic but while downcast it needs to be while using <code>dynamic_cast</code> ?     </p>\n<pre><code>class base\n{\n    public:\n    base()\n    {\n        cout&lt;&lt; \" \\n base constructor \\n\";\n    }\n};\n\nclass derived:public base\n{\n    public:\n    derived()\n    {\n         cout &lt;&lt;\" \\n derived constructor \\n\";\n    }\n};\n\nbase *obj = dynamic_cast&lt;base*&gt; (new derived) ; // case 1: explicitly upcasting\nderived *OBJ = dynamic_cast&lt;derived*&gt; (obj) ;   // case 2: error\n</code></pre>\n<p>Thanks.</p>\n", "Tags": "<c++><downcasting>", "OwnerUserId": "528724", "AnswerCount": "5"}, "4644854": {"ParentId": "4644753", "CommentCount": "1", "Body": "<p>Think of it this way: when you downcast, you are telling compiler that you want to point to a polymorphic class pointer. But when you are doing upcasting using dynamic_cast, it says \"you already got me when you derived from me, why do you want to back to me explicitly using dynamic_cast?\" and hence compiler gives an error. That is, compiler sees that in Derived class, their is a sub-part of type Base and hence it knows their is no need for programmers to explicitly put a pointer to it (and possibly create havoc).</p>\n<p>I hope that explanation helps. </p>\n", "OwnerUserId": "568471", "PostTypeId": "2", "Id": "4644854", "Score": "0", "CreationDate": "2011-01-10T08:24:16.843", "LastActivityDate": "2011-01-10T08:24:16.843"}, "35788973": {"ParentId": "4644753", "PostTypeId": "2", "CommentCount": "0", "Body": "<pre><code>B* b = new D();\nD* d = dynamic_cast&lt;D*&gt;(b);\n</code></pre>\n<p>In the above example most compilers would implement dynamic cast by checking whether the vtable pointer of b points to the vtable of the derived class D or not.\nIf yes, it simply returns the address of b as the return value otherwise it returns a nullptr.\nThis is what possibly goes on behind the scenes when a dynamic cast executes :-</p>\n<pre><code>class car\n{\n    public:\n    virtual void drive()\n    {\n         std::cout &lt;&lt;\"car\"&lt;&lt;std::endl;\n    }\n};\nclass toyota: public car\n{\n    public:\n    virtual void drive()\n    {\n        std::cout &lt;&lt;\"toyota\"&lt;&lt;std::endl;\n    }\n};\n\nclass honda: public car\n{\n    public:\n        virtual void drive()\n    {\n        std::cout &lt;&lt;\"honda\"&lt;&lt;std::endl;\n    }\n};\n\ntemplate &lt;typename Tderived&gt;\nTderived* dynamicCast(void* pBase)\n{\n    //compare the vptr of the class pointed by pBase with a temporary Tderived class. \n    //If vptr of pBase and vptr of Tderived() are pointing to the same vtable \n    //then it can be safely deduced that pBase is indeed pointing to an instance of Tderived\n    if (*(int**)pBase == *(int**)&amp;Tderived())\n    {\n        return (Tderived*)pBase;\n    }\n    else\n    {\n        return nullptr;\n    }\n}\n\n\nint main()\n{\n    car* pCar;\n    honda hondaCar;\n    toyota toyotaCar;\n\n    pCar = &amp;toyotaCar;\n\n    honda* pHonda = dynamicCast&lt;honda&gt;(pCar);\n    if (nullptr != pHonda)\n    {\n        pHonda-&gt;drive();\n    }\n    else\n    {\n        toyota* pToyota = dynamicCast&lt;toyota&gt;(pCar);\n        if (nullptr != pToyota)\n        {\n            pToyota-&gt;drive();\n        }\n    }\n}\n</code></pre>\n<p>Now, if the class is not polymorphic, there is no way for the compiler to find whether pCar is pointing to honda or toyota car. Note that this is just one of the ways to implement dynamic_cast as the C++ standard does not talk anything about vtables.</p>\n", "OwnerUserId": "4599686", "LastEditorUserId": "4599686", "LastEditDate": "2016-03-04T06:02:45.880", "Id": "35788973", "Score": "0", "CreationDate": "2016-03-04T05:56:53.540", "LastActivityDate": "2016-03-04T06:02:45.880"}, "4645219": {"ParentId": "4644753", "CommentCount": "0", "Body": "<p>Dynamic_cast</p>\n<ul>\n<li>It is used to cast a base pointer\ninto a derived pointer. If the base\npointer doesn't point to an object of\nthe type of the derived, it returns</li>\n<li>It is used to cast a base reference\ninto a derived reference. If the\nreference isn't pointing to an object\nof the derived, it throws\nstd::bad_cast.</li>\n<li>It can be considered the checked cast\nequivalent to static_cast, in that it\nchecks whether the object pointed to\nreally is of the derived type.</li>\n</ul>\n<p>You must read more about Dynamic_cast (with example) <a href=\"http://www.cplusplus.com/doc/tutorial/typecasting/\" rel=\"nofollow\">there</a>.</p>\n", "OwnerUserId": "490908", "PostTypeId": "2", "Id": "4645219", "Score": "0", "CreationDate": "2011-01-10T09:21:00.777", "LastActivityDate": "2011-01-10T09:21:00.777"}, "4644783": {"ParentId": "4644753", "CommentCount": "0", "Body": "<p>From 5.2.7/1 [expr.dynamic.cast] :</p>\n<blockquote>\n<p id=\"so_4644753_4644783_0\">The result of the expression <code>dynamic_cast&lt;T&gt;(v)</code> is the result of converting the expression v to type\n  T.</p>\n<p id=\"so_4644753_4644783_1\">[...]</p>\n<p id=\"so_4644753_4644783_2\">If T is \"pointer to <em>cv1</em> B\" and v has type \"pointer to <em>cv2</em> D\" such that B is a base class of D, the result is a\n  pointer to the unique B sub-object of the D object pointed to by v.</p>\n<p id=\"so_4644753_4644783_3\">[...]</p>\n<p id=\"so_4644753_4644783_4\"><strong>Otherwise</strong>, v shall be a pointer to or an lvalue of a polymorphic type.</p>\n</blockquote>\n<p>The standard even provides the following example which illustrates that the polymorphic type requirement does not stand for derived to base conversion :</p>\n<pre><code>struct B {};\nstruct D : B {};\nvoid foo(D* dp)\n{\n    B* bp = dynamic_cast&lt;B*&gt;(dp); // equivalent to B* bp = dp;\n}\n</code></pre>\n", "OwnerUserId": "451980", "PostTypeId": "2", "Id": "4644783", "Score": "6", "CreationDate": "2011-01-10T08:10:10.650", "LastActivityDate": "2011-01-10T08:10:10.650"}, "bq_ids": {"n4140": {"so_4644753_4644783_0": {"section_id": 6011, "quality": 0.875, "length": 7}, "so_4644753_4644783_2": {"section_id": 6015, "quality": 0.8571428571428571, "length": 12}, "so_4644753_4644783_4": {"section_id": 6016, "quality": 0.8, "length": 4}}, "n3337": {"so_4644753_4644783_0": {"section_id": 5779, "quality": 0.875, "length": 7}, "so_4644753_4644783_2": {"section_id": 5783, "quality": 0.8571428571428571, "length": 12}, "so_4644753_4644783_4": {"section_id": 5784, "quality": 1.0, "length": 5}}, "n4659": {"so_4644753_4644783_4": {"section_id": 7515, "quality": 0.8, "length": 4}, "so_4644753_4644783_2": {"section_id": 7514, "quality": 0.8571428571428571, "length": 12}, "so_4644753_4644783_0": {"section_id": 7510, "quality": 0.875, "length": 7}}}, "4644856": {"ParentId": "4644753", "CommentCount": "1", "Body": "<p>In order for <strong>dynamic_cast</strong> to work the object needs to be polymorphic. The reason for this is that <strong>dynamic_cast</strong> needs somewhere to store the type information that is will use to perform the cast, and it does this by storing the information alongside the vtable for the class. In order for there to be a vtable you need to make at least one of your methods virtual.</p>\n<p>The easiest way around this is to flag the base class destructor as virtual.</p>\n<p>Upcasting (ie derived to base) doesn't needs a cast as the compiler is able to check that the cast would work at compile time. However, the same isn't true when downcasting.</p>\n", "OwnerUserId": "26095", "PostTypeId": "2", "Id": "4644856", "Score": "14", "CreationDate": "2011-01-10T08:25:26.507", "LastActivityDate": "2011-01-10T08:25:26.507"}});