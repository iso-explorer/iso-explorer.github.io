post_cb({"15578298": {"CommentCount": "8", "ViewCount": "778", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-03-22T19:22:40.930", "LastActivityDate": "2013-03-23T18:37:17.773", "Title": "Can a \"const T*\" match a pointer to free function?", "AcceptedAnswerId": "15580072", "LastEditDate": "2017-05-23T11:49:55.717", "Id": "15578298", "Score": "18", "Body": "<p>In a <a href=\"https://stackoverflow.com/questions/10145693/what-is-meaning-of-a-pointer-to-a-constant-function\">related question</a> it's said that there's no such thing as a pointer to non-member const function. In addition, C++11 8.3.5/6 says</p>\n<blockquote>\n<p id=\"so_15578298_15578298_0\">The effect of a cv-qualifier-seq in a function declarator is not the same as adding cv-qualification on top of the function type. In the latter case, the cv-qualifiers are\n  ignored. [ Note: a function type that has a cv-qualifier-seq is not a cv-qualified type; <strong>there are no cv-qualified function types</strong>. \u2014end note ]</p>\n</blockquote>\n<p>If I understand it correctly, this means that there's no such thing as a non-member const function. (Although such functions are not const, they cannot be modified as per 3.10/6). In particular, pointers to const function are meaningless.</p>\n<p>However, it seems that some compilers do create pointers to const function in type deduction contexts. For instance, consider the code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid f() {}\n\ntemplate &lt;typename T&gt; void g(      T*) { std::cout &lt;&lt; \"non const\" &lt;&lt; std::endl; }\ntemplate &lt;typename T&gt; void g(const T*) { std::cout &lt;&lt; \"const    \" &lt;&lt; std::endl; }\n\nint main() {\n     g(f);\n}\n</code></pre>\n<p>When compiled with GCC and Intel the code outputs \"non const\" as I would expect from the quote above. However, the output is \"const\" when compiled with Clang and Visual Studio.</p>\n<p>Is my interpretation correct?</p>\n<p><strong>Update:</strong></p>\n<p>Following the comments, I'm trying to clarify that I'm <strong>not</strong> talking about const member functions. I'm interested in non-member functions (but the same arguments probably apply to non-static member functions as well). I've also changed the question title to make it more precise.</p>\n<p>Consistent with the resolution of <code>g(f)</code> mentioned above, the line below is ilegal for GCC and Intel but not for Clang and Visual Studio</p>\n<pre><code>const auto* ptr = &amp;f;\n</code></pre>\n<p><strong>Update 2:</strong></p>\n<p>I agree with Andy Prowl's interpretation and have selected his answer. However, after that, I was made aware that this question is a CWG <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1584\" rel=\"nofollow noreferrer\">open issue</a>.</p>\n", "Tags": "<c++><c++11><const><function-pointers>", "OwnerUserId": "1137388", "AnswerCount": "1"}, "15580072": {"ParentId": "15578298", "PostTypeId": "2", "CommentCount": "23", "Body": "<blockquote>\n<p id=\"so_15578298_15580072_0\">If I understand it correctly, this means that there's no such thing as a non-member const function. (Although such functions are not const, they cannot be modified as per 3.10/6). In particular, pointers to const function are meaningless.</p>\n</blockquote>\n<p>Yes, there is no such a thing as a <code>const</code> function, and attempts to create one are <em>ignored</em>, because of the very same Paragraph you quoted. This is important, because a program that anyhow creates a <code>const</code> function type is <strong>not</strong> ill-formed (<a href=\"https://stackoverflow.com/questions/1117873/pointer-to-const-vs-usual-pointer-for-functions\">as was the case in C++03</a>); simply, its attempt is disregarded, and a non-<code>const</code> function type is considered instead.</p>\n<p>This is probably what GCC and ICC fail to apply, because when the non-<code>const</code> overload is removed, <a href=\"http://liveworkspace.org/code/N6QE5$43\" rel=\"nofollow noreferrer\">the program does not compile</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid f() {}\n\ntemplate &lt;typename T&gt; void g( T const*) \n{ \n   std::cout &lt;&lt; \"const    \" &lt;&lt; std::endl; \n}\n\nint main() {\n     g(f); // ERROR with GCC and ICC, compiles with Clang\n}\n</code></pre>\n<p>Concerning your interpretation:</p>\n<blockquote>\n<p id=\"so_15578298_15580072_1\">When compiled with GCC and Intel the code outputs \"non const\" as I would expect from the quote above. However, the output is \"const\" when compiled with Clang and Visual Studio. Is my interpretation correct?</p>\n</blockquote>\n<p>I don't believe so. As far as I can tell, <strong>Clang is right.</strong></p>\n<p>This conclusion is based on the fact that both function templates are viable, because <code>const</code> qualifiers are ignored on function types, and one is more specialized than the other. </p>\n<p>Per Paragraph 8.3.5/7 of the C++11 Standard, in fact:</p>\n<blockquote>\n<p id=\"so_15578298_15580072_2\">[...] The effect of a cv-qualifier-seq in a function declarator is not the same as adding cv-qualification on top\n  of the function type. <strong>In the latter case, the cv-qualifiers are ignored</strong>. [...]</p>\n</blockquote>\n<p>This effectively makes the second function template viable for resolving the call (the first one obviously is). But since <em>both</em> function templates are viable, Paragraph 13.3.3.1 about overload resolution comes into play:</p>\n<blockquote>\n<p id=\"so_15578298_15580072_3\">Given these definitions, <strong>a viable function F1 is defined to be a better function than another viable function F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</strong></p>\n<p id=\"so_15578298_15580072_4\">\u2014 for some argument j, ICSj(F1) is a better conversion sequence than ICSj(F2), or, if not that,</p>\n<p id=\"so_15578298_15580072_5\">\u2014 the context is an initialization by user-defined conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the\n  standard conversion sequence from the return type of F1 to the destination type (i.e., the type of the\n  entity being initialized) is a better conversion sequence than the standard conversion sequence from\n  the return type of F2 to the destination type. [ ... ] or, if not that,</p>\n<p id=\"so_15578298_15580072_6\">\u2014 F1 is a non-template function and F2 is a function template specialization, or, if not that,</p>\n<p id=\"so_15578298_15580072_7\">\u2014 <strong>F1 and F2 are function template specializations, and the function template for F1 is more specialized than the template for F2 according to the partial ordering rules described in 14.5.6.2.</strong></p>\n</blockquote>\n<p>Since the second function template is more specialized than the first one, the second function template should be picked by overload resolution. Therefore, <strong>Clang is right</strong>.</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:32:04.783", "Id": "15580072", "Score": "10", "CreationDate": "2013-03-22T21:22:07.667", "LastActivityDate": "2013-03-22T22:16:11.343"}, "bq_ids": {"n4140": {"so_15578298_15580072_3": {"section_id": 603, "quality": 0.85, "length": 17}, "so_15578298_15580072_4": {"section_id": 603, "quality": 0.75, "length": 6}, "so_15578298_15580072_7": {"section_id": 603, "quality": 0.9333333333333333, "length": 14}, "so_15578298_15580072_6": {"section_id": 111, "quality": 1.0, "length": 5}, "so_15578298_15580072_5": {"section_id": 603, "quality": 0.9259259259259259, "length": 25}, "so_15578298_15578298_0": {"section_id": 3242, "quality": 0.8518518518518519, "length": 23}, "so_15578298_15580072_2": {"section_id": 3242, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_15578298_15580072_3": {"section_id": 593, "quality": 0.85, "length": 17}, "so_15578298_15580072_4": {"section_id": 593, "quality": 0.75, "length": 6}, "so_15578298_15580072_7": {"section_id": 593, "quality": 0.9333333333333333, "length": 14}, "so_15578298_15580072_6": {"section_id": 106, "quality": 1.0, "length": 5}, "so_15578298_15580072_5": {"section_id": 593, "quality": 0.9259259259259259, "length": 25}, "so_15578298_15578298_0": {"section_id": 3115, "quality": 0.8518518518518519, "length": 23}, "so_15578298_15580072_2": {"section_id": 3115, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_15578298_15580072_3": {"section_id": 629, "quality": 0.85, "length": 17}, "so_15578298_15580072_4": {"section_id": 629, "quality": 0.75, "length": 6}, "so_15578298_15580072_7": {"section_id": 629, "quality": 0.9333333333333333, "length": 14}, "so_15578298_15580072_6": {"section_id": 115, "quality": 1.0, "length": 5}, "so_15578298_15580072_5": {"section_id": 629, "quality": 0.9259259259259259, "length": 25}, "so_15578298_15578298_0": {"section_id": 3999, "quality": 0.8518518518518519, "length": 23}, "so_15578298_15580072_2": {"section_id": 3999, "quality": 0.9333333333333333, "length": 14}}}});