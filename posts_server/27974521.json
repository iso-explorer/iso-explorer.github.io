post_cb({"bq_ids": {"n4140": {"so_27974521_27974902_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 5485}, "so_27974521_27974902_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 5485}}, "n3337": {"so_27974521_27974902_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 5271}, "so_27974521_27974902_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 5271}, "so_27974521_27974902_0": {"length": 53, "quality": 1.0, "section_id": 3082}}, "n4659": {"so_27974521_27974902_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 6920}, "so_27974521_27974902_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 6920}}}, "27974521": {"ViewCount": "90", "Body": "<p>The following code produces a compile error (on a recent version of gcc at least):</p>\n<pre><code>namespace a {\n\nclass X { friend void ::foo(); };\n\n}\n</code></pre>\n<p>The error is:</p>\n<pre><code>'void foo()' should have been declared inside '::'\n</code></pre>\n<p>If we remove <code>::</code> from the declaration, according to the standard, <code>foo</code> will be introduced into the namespace <code>a</code> (although it won't be visible). Predeclaring foo inside of <code>a</code> is not required.</p>\n<p>My question is, given the above, why is predeclaring within the global namespace a requirement? Why doesn't the name <code>foo</code> become a member of the global namespace? I couldn't find any paragraph in the standard that would explicitly forbid that either, so I'm curious to know.</p>\n", "AcceptedAnswerId": "27974902", "Title": "What are the rules for using qualified names in friend declarations?", "CreationDate": "2015-01-15T22:54:20.897", "Id": "27974521", "CommentCount": "0", "LastEditDate": "2015-01-15T23:02:36.167", "PostTypeId": "1", "LastEditorUserId": "4413741", "LastActivityDate": "2015-01-15T23:28:49.160", "Score": "2", "OwnerUserId": "4413741", "Tags": "<c++><namespaces><friend>", "AnswerCount": "1"}, "27974902": {"Id": "27974902", "PostTypeId": "2", "Body": "<p>The paragraph you're looking for is [dcl.meaning] (8.3 (1) in C++11):</p>\n<blockquote>\n<p id=\"so_27974521_27974902_0\">(...) A <em>declarator-id</em> shall not be qualified except for the definition of a member function or static data member outside of its class, the definition or explicit instantiation of a function or variable of a namespace outside of its namespace, or the definition of an explicit specialization outside of its namespace, or the declaration of a friend function that is a member of another class or namespace. <strong>When the <em>declarator-id</em> is qualified, the declaration shall refer to a previously declared member of the class or namespace to which the qualifier refers</strong> (or, in the case of a namespace, of an element of the inline namespace set of that namespace).</p>\n</blockquote>\n<p>(emphasis mine) What this means is that you cannot write</p>\n<pre><code>namespace a { }\n\nvoid a::foo() { }\n</code></pre>\n<p>unless <code>a::foo</code> is already declared with an unqualified declarator inside the namespace. And since there is no exception for friends, you cannot do this for friends either.</p>\n<p>A footnote in [namespace.memdef] (7.3.1.2 (3) in C++11) mentions this even more explicitly for the special case of friends:</p>\n<blockquote>\n<p id=\"so_27974521_27974902_1\">(...) If a friend declaration in a non-local class first declares a class or function<sup>95</sup> the friend class or function is a member of the innermost enclosing namespace. (...)</p>\n<p id=\"so_27974521_27974902_2\"><sup>95)</sup> This implies that the name of the class or function is unqualified.</p>\n</blockquote>\n", "LastActivityDate": "2015-01-15T23:28:49.160", "Score": "2", "CreationDate": "2015-01-15T23:28:49.160", "ParentId": "27974521", "CommentCount": "0", "OwnerUserId": "4301306"}});