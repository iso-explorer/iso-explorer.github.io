post_cb({"bq_ids": {"n4140": {"so_19606492_19607079_0": {"length": 32, "quality": 0.8888888888888888, "section_id": 369}, "so_19606492_19607079_4": {"length": 24, "quality": 0.8888888888888888, "section_id": 458}, "so_19606492_19607079_6": {"length": 23, "quality": 0.8518518518518519, "section_id": 469}, "so_19606492_19607079_3": {"length": 27, "quality": 0.9642857142857143, "section_id": 456}, "so_19606492_19607079_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 401}, "so_19606492_19607079_1": {"length": 14, "quality": 1.0, "section_id": 400}, "so_19606492_19607079_5": {"length": 38, "quality": 0.9743589743589743, "section_id": 467}}, "n3337": {"so_19606492_19607079_0": {"length": 32, "quality": 0.8888888888888888, "section_id": 359}, "so_19606492_19607079_4": {"length": 27, "quality": 1.0, "section_id": 449}, "so_19606492_19607079_6": {"length": 27, "quality": 1.0, "section_id": 460}, "so_19606492_19607079_1": {"length": 14, "quality": 1.0, "section_id": 391}, "so_19606492_19607079_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 392}, "so_19606492_19607079_5": {"length": 38, "quality": 0.9743589743589743, "section_id": 458}, "so_19606492_19607079_3": {"length": 27, "quality": 0.9642857142857143, "section_id": 447}}, "n4659": {"so_19606492_19607079_1": {"length": 14, "quality": 1.0, "section_id": 417}, "so_19606492_19607079_4": {"length": 24, "quality": 0.8888888888888888, "section_id": 481}, "so_19606492_19607079_6": {"length": 23, "quality": 0.8518518518518519, "section_id": 492}, "so_19606492_19607079_3": {"length": 27, "quality": 0.9642857142857143, "section_id": 479}, "so_19606492_19607079_0": {"length": 24, "quality": 0.6666666666666666, "section_id": 381}, "so_19606492_19607079_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 418}, "so_19606492_19607079_5": {"length": 38, "quality": 0.9743589743589743, "section_id": 490}}}, "19607079": {"Id": "19607079", "PostTypeId": "2", "Body": "<p>I'll leave out some irrelevant points here, e.g. about <code>union</code>s, base classes, <em>brace-or-equal-initializers</em> etc. If your classes have any members, base classes, ... then the answer will differ. For example, if you have a <code>const</code> member, an implicitly declared assignment operator would be defined as deleted.</p>\n<h2>default constructor</h2>\n<p>[class.ctor]/5</p>\n<blockquote>\n<p id=\"so_19606492_19607079_0\">A default constructor for a class <code>X</code> is a constructor of class <code>X</code> that can be called without an argument. If there is no user-declared constructor for class <code>X</code>, a constructor having no parameters is implicitly declared as defaulted. An implicitly-declared default constructor is an <code>inline public</code> member of its class. A defaulted default constructor for class <code>X</code> is defined as deleted if [... lots of points irrelevant here].</p>\n</blockquote>\n<p>So in cases a) and e) [without any user-declared ctor], a default ctor is declared as defaulted.</p>\n<h2>default destructor</h2>\n<p>[class.dtor]</p>\n<blockquote>\n<p id=\"so_19606492_19607079_1\">4 If a class has no user-declared destructor, a destructor is implicitly declared as defaulted. An implicitly-declared destructor is an <code>inline public</code> member of its class.</p>\n<p id=\"so_19606492_19607079_2\">5 A defaulted destructor for a class <code>X</code> is defined as deleted if [... lots of points irrelevant here]</p>\n</blockquote>\n<p>So in all cases but a) [with a user-declared dtor], a default dtor is implicitly declared and implicitly defined if odr-used.</p>\n<hr>\n<p>As per [class.copy]/2+3, a copy-ctor and move-ctor may have additional parameters, if those have default arguments.</p>\n<h2>copy-constructor</h2>\n<p>A copy-ctor is declared implicitly if there's no user-defined copy-ctor (a ctor template is never a copy-ctor). [class.copy]/7</p>\n<blockquote>\n<p id=\"so_19606492_19607079_3\">If the class definition declares a move constructor or move assignment operator, the implicitly declared copy constructor is defined as deleted; otherwise, it is defined as defaulted. The latter case is deprecated if the class has a user-declared copy assignment operator or a user-declared destructor.</p>\n</blockquote>\n<p>That is, in all cases but d) [with a user-declared copy-ctor], a copy-ctor is declared implicitly. In cases b) and c) [with a user-provided move ctor], the copy-ctor is defined as deleted. For a) [user-declared dtor] and e) [user-declared copy-assignment op], it may be defined as defaulted, but that's deprecated.</p>\n<h2>move-constructor</h2>\n<p>The move-ctor won't even be declared in these cases [class.copy]/9</p>\n<blockquote id=\"so_19606492_19607079_4\">\n<ul>\n<li><code>X</code> does not have a user-declared copy constructor,</li>\n<li><code>X</code> does not have a user-declared copy assignment operator,</li>\n<li><code>X</code> does not have a user-declared move assignment operator,</li>\n<li><code>X</code> does not have a user-declared destructor, and</li>\n<li>the move constructor would not be implicitly defined as deleted.</li>\n</ul>\n</blockquote>\n<p>There are again quite some cases where it would be defined as deleted, but they don't apply here.</p>\n<p>Therefore, the move-ctor is <strong>not</strong> declared in any of the cases.</p>\n<hr>\n<h2>copy-assignment operator</h2>\n<p>In [class.copy]/18:</p>\n<blockquote>\n<p id=\"so_19606492_19607079_5\">If the class definition does not explicitly declare a copy assignment operator, one is declared implicitly. If the class definition declares a move constructor or move assignment operator, the implicitly declared copy assignment operator is defined as deleted; otherwise, it is defined as defaulted. The latter case is deprecated if the class has a user-declared copy constructor or a user-declared destructor.</p>\n</blockquote>\n<p>It is defined as deleted in some cases, see [class.copy]/23, but they don't apply here.</p>\n<p>The copy-assignment op is declared in all cases but e) [user-declared copy-assignment op]. It is defined as deleted in b) and c) [both: user-declared move ctor]; and it may be defined as defaulted in a) [user-declared dtor] and d) [user-declared copy-ctor]. Note the parallel to the copy-ctor.</p>\n<h2>move-assignment operator</h2>\n<p>Similar to the move-ctor, the move-assignment op is not even declared if either [class.copy]/20:</p>\n<blockquote id=\"so_19606492_19607079_6\">\n<ul>\n<li><code>X</code> does not have a user-declared copy constructor,</li>\n<li><code>X</code> does not have a user-declared move constructor,</li>\n<li><code>X</code> does not have a user-declared copy assignment operator,</li>\n<li><code>X</code> does not have a user-declared destructor, and</li>\n<li>the move assignment operator would not be implicitly defined as deleted.</li>\n</ul>\n</blockquote>\n<p>It is defined as deleted in some cases, see [class.copy]/23 (same paragraph as for the copy-ctor), but they don't apply here.</p>\n<p>A move-assignment-op is declared implicitly and defined as defaulted in <strong>none</strong> of the cases.</p>\n</hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2013-10-26T13:12:44.583", "Score": "5", "CreationDate": "2013-10-26T13:07:38.437", "ParentId": "19606492", "CommentCount": "3", "LastEditDate": "2013-10-26T13:12:44.583", "OwnerUserId": "420683"}, "19606492": {"ViewCount": "3519", "Body": "<p>Say a class </p>\n<p><code>class Piece {} ;</code></p>\n<p>If I'm correct that should be equivalent to :</p>\n<pre><code>class Piece {\n   //C++ 03\n    Piece ();                          //default constructor\n    Piece( const Piece&amp;);              //copy constructor\n    Piece&amp; operator=(const Piece&amp;);    //copy assignment operator\n    ~Piece();                          //destructor\n\n    //Since C++ 11\n    Piece(Piece&amp;&amp;);                   //move constructor\n    Piece&amp; operator=(Piece&amp;&amp;);        //move assignment operator\n};\n</code></pre>\n<p>So what can I say about these ?</p>\n<p>a)</p>\n<pre><code>class Pawn{\n    ~Pawn() {}// Only destructor\n};\n</code></pre>\n<p>b)</p>\n<pre><code>class Bishop{\n    Bishop(Bishop&amp;&amp; ) {}// Only move constructor\n};\n</code></pre>\n<p>c)</p>\n<pre><code>class Knight{\n    Knight(Knight&amp;&amp;, int =0) {} // move constructor, when no second arg present\n};\n</code></pre>\n<p>d) </p>\n<pre><code>class Rook {\n    Rook(const Rook&amp; ) {}// Only copy constructor\n};\n</code></pre>\n<p>e)</p>\n<pre><code>class King{\n        King&amp; operator=(const King&amp;) = delete;\n    };\n</code></pre>\n<p>My per my understanding compiler will generate for :</p>\n<ul>\n<li>a) Default Constructor, Copy Constructor, Copy Assignment operator , ( move constructor/assignment operator ? )</li>\n<li>b) Destructor</li>\n<li>c) Destructor</li>\n<li>d) Copy Assignment operator and Destructor ( move constructor/assignment operator ? )</li>\n<li>e) Default Constructor, Copy Constructor, Destructor, ( move constructor/assignment operator ? )</li>\n</ul>\n<p>Am I correct or missing something here ?</p>\n<p>Basically is <code>C++11</code> has any new rules for generating functions, when not provided by user ?</p>\n", "Title": "C++11 compiler generated functions", "CreationDate": "2013-10-26T12:06:03.877", "LastActivityDate": "2013-10-26T13:59:12.343", "CommentCount": "8", "FavoriteCount": "6", "PostTypeId": "1", "Id": "19606492", "Score": "6", "OwnerUserId": "1870232", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "19607469": {"Id": "19607469", "PostTypeId": "2", "Body": "<p>So looking at some post and online tutorials, I concluded this :</p>\n<p>Generated functions :- </p>\n<ul>\n<li><p>C++ 03:</p>\n<p>1) Default Constructor (generated only if no constructor is declared by user)</p>\n<p>2) Copy Constructor (generated only if No. 5,6 declared by user)</p>\n<p>3) Copy Assignment operator (generated only if 5,6 not declared by user)</p>\n<p>4) Destructor</p></li>\n<li><p>Since C++ 11:</p>\n<p>5) Move Constructor (generated only if 2,3,4,6 not declared by user)</p>\n<p>6) Move Assignment Operator (generated only if 2,3,4,5 not declared by user)</p></li>\n</ul>\n<hr>\n<p>So, for </p>\n<p>a)</p>\n<pre><code>class Pawn{ //1, 2, 3\n    ~Pawn() {}// Only destructor\n};\n</code></pre>\n<p>b)</p>\n<pre><code>class Bishop{ //4\n    Bishop(Bishop&amp;&amp; ) {}\n};\n</code></pre>\n<p>c)</p>\n<pre><code>class Knight{ //4\n    Knight(Knight&amp;&amp;, int =0) {} \n};\n</code></pre>\n<p>d)</p>\n<pre><code>class Rook { //3, 4\n    Rook(const Rook&amp; ) {}\n};\n</code></pre>\n<p>e)</p>\n<pre><code>class King{ //1, 2, 4\n        King&amp; operator=(const King&amp;) = delete;\n    };\n</code></pre>\n<p><strong>Edit</strong> : As per DyP comment :-</p>\n<p>In C++11, </p>\n<p>For case a), 2 and 3 are deprecated.</p>\n<p>For case d), 3 is deprecated.</p>\n<p>For case e), 2 is deprecated.</p>\n</hr>", "LastEditorUserId": "1870232", "LastActivityDate": "2013-10-26T13:59:12.343", "Score": "3", "CreationDate": "2013-10-26T13:47:46.563", "ParentId": "19606492", "CommentCount": "0", "LastEditDate": "2013-10-26T13:59:12.343", "OwnerUserId": "1870232"}});