post_cb({"bq_ids": {"n4140": {"so_24095071_24095071_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 7107}, "so_24095071_24290421_2": {"length": 12, "quality": 1.0, "section_id": 7054}, "so_24095071_24290421_1": {"length": 12, "quality": 1.0, "section_id": 7054}}, "n3337": {"so_24095071_24095071_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6851}, "so_24095071_24290421_2": {"length": 12, "quality": 1.0, "section_id": 6798}, "so_24095071_24290421_1": {"length": 12, "quality": 1.0, "section_id": 6798}}, "n4659": {"so_24095071_24095071_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 8608}, "so_24095071_24290421_2": {"length": 12, "quality": 1.0, "section_id": 8551}, "so_24095071_24290421_1": {"length": 12, "quality": 1.0, "section_id": 8551}}}, "24095071": {"ViewCount": "29962", "Body": "<p>I tried to use incomplete type in nested name specifier as the following:</p>\n<pre><code>class A;\n\nint b= A::c; // error: incomplete type \u2018A\u2019 used in nested name specifier\n\nclass A {\n    static const int c=5;\n};\n</code></pre>\n<p>There is says nothing about it in the 3.4.3/1 of N3797 working draft:</p>\n<blockquote>\n<p id=\"so_24095071_24095071_0\">The name of a class or namespace member or enumerator can be referred\n  to after the :: scope resolution operator (5.1) applied to a\n  nested-name-specifier that denotes its class, namespace, or\n  enumeration</p>\n</blockquote>\n<p>So is that behavior implementation dependent?</p>\n", "AcceptedAnswerId": "24290421", "Title": "Incomplete type in nested name specifier", "CreationDate": "2014-06-07T07:53:05.827", "LastActivityDate": "2014-06-18T16:14:56.830", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-06-18T16:14:56.830", "OwnerDisplayName": "user2953119", "LastEditorUserId": "1090079", "Id": "24095071", "Score": "20", "Tags": "<c++><language-lawyer>", "AnswerCount": "1"}, "24290421": {"Id": "24290421", "PostTypeId": "2", "Body": "<h3>Introduction</h3>\n<p>There are several places in the standard that implicitly implies that your code is ill-formed, but the below quotation speaks for itself:</p>\n<blockquote>\n<p id=\"so_24095071_24290421_0\"><code>3.3.2p6</code> <strong>Point of declaration</strong> <code>[basic.scope.pdecl]</code></p>\n<blockquote>\n<p id=\"so_24095071_24290421_2\">After the point of declaration of a class member, the member name can be looked up in the scope of its class.</p>\n</blockquote>\n</blockquote>\n<p>The problem with your code isn't that you try to reach inside the body of an incomplete type, the problem is that you can only refer to a class member name <strong>after</strong> it has been declared.</p>\n<p>Since your forward-declaration (of course) doesn't introduce any member named <em>c</em>, it is ill-formed to refer to such name.</p>\n<hr>\n<h3>The misleading diagnostic...</h3>\n<p>The diagnostic issued by both <em>gcc</em> and <em>clang</em> when being fed your code is somewhat misleading, and honestly I feel a bug report is in order.</p>\n<pre class=\"lang-none prettyprint-override\"><code>foo.cpp:3:8: error: incomplete type 'A' named in nested name specifier\n</code></pre>\n<p><br/></p>\n<p>We <strong>are</strong> allowed to name an incomplete type in a <em>nested-name-specifier</em>, but as said; we are not allowed to refer to a member that has not yet been declared.</p>\n<p><em>ill-formed:</em></p>\n<pre><code>class X {\n  static int a[X::x];        // ill-formed, `X::x` has not yet been declared\n  static int const x = 123;\n};\n</code></pre>\n<p><em>legal:</em></p>\n<pre><code>class X {\n  int const x = 123;\n  int a[X::x]; // legal, `X` is incomplete (since we are still defining it)\n               //        but we can still refer to a _declared_ member of it\n};\n</code></pre>\n</hr>", "LastActivityDate": "2014-06-18T16:13:02.813", "CommentCount": "0", "CreationDate": "2014-06-18T16:13:02.813", "ParentId": "24095071", "Score": "26", "OwnerUserId": "1090079"}});