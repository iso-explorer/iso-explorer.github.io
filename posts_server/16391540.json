post_cb({"16391540": {"CommentCount": "0", "ViewCount": "444", "PostTypeId": "1", "LastEditorUserId": "2353218", "CreationDate": "2013-05-06T03:20:28.797", "LastActivityDate": "2013-05-07T00:42:24.860", "Title": "Do C++ conditional statements carry a dependency from the condition expression to the statement?", "FavoriteCount": "1", "LastEditDate": "2013-05-07T00:42:24.860", "Id": "16391540", "Score": "5", "Body": "<p>I'm asking specifically in the memory-model sense. <a href=\"http://en.cppreference.com/w/cpp/atomic/memory_order\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/atomic/memory_order</a></p>\n<p>I'm asking because I want to know if I can use a <code>std::memory_order_consume</code> in the below:</p>\n<p>mLocalMemPtr1 and 2 and mAtomicMemPtr are pointers into a shared buffer.</p>\n<p>In a producer thread I'm doing:</p>\n<pre><code>for (int x = 0; x &lt; 10; ++x)\n{\n    ++mLocalMemPtr1\n    *mLocalMemPtr1 = x;       // &lt;========= A\n    mAtomicMemPtr.store(mLocalMemPtr1, std::memory_order_release);\n}\n</code></pre>\n<p>And in the consumer:</p>\n<pre><code>tempMemPtr = mAtomicMemPtr.load(std::memory_order_consume);\nwhile (tempMemPtr != mLocalMemPtr2)\n{\n    ++mLocalMemPtr2;\n    int test = *mLocalMemPtr2;   // &lt;======== B\n    doSomeLongRunningThing(test);\n    tempMemPtr = mAtomicMemPtr.load(std::memory_order_consume);\n}\n</code></pre>\n<p>So does the dependency chain go tempMemPtr -&gt; mLocalMemPtr2 -&gt; test -&gt; doSomeLongRunningThing?</p>\n<p>I'm specifically worried that <code>B</code> may be executed before <code>A</code>. I know I can use a <code>std::memory_order_acquire</code>, but I can use consume (which is more lightweight) if the conditional statement causes a memory order dependency.</p>\n", "Tags": "<c++><c++11><memory-model>", "OwnerUserId": "2353218", "AnswerCount": "2"}, "16397575": {"ParentId": "16391540", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-05-06T11:14:59.450", "Score": "2", "LastEditorUserId": "339249", "LastEditDate": "2013-05-06T11:56:44.363", "Id": "16397575", "OwnerUserId": "339249", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/atomic/memory_order\" rel=\"nofollow\">CppReference</a>:</p>\n<blockquote>\n<p id=\"so_16391540_16397575_0\">Release-Consume ordering</p>\n<p id=\"so_16391540_16397575_1\">If an atomic store in thread A is tagged std::memory_order_release and an atomic load in thread B from the same variable is tagged std::memory_order_consume, all memory writes (non-atomic and relaxed atomic) that are <strong>dependency-ordered-before</strong> the atomic store from the point of view of thread A, become visible side-effects in thread B, that is, once the atomic load is completed, thread B is guaranteed to see everything that thread A wrote to memory if it <strong>carries a data dependency</strong> into the atomic load.</p>\n</blockquote>\n<p>1.10.10:</p>\n<blockquote>\n<p id=\"so_16391540_16397575_2\">An evaluation A is dependency-ordered before an evaluation B if</p>\n<p id=\"so_16391540_16397575_3\">\u2014 A performs a release operation on an atomic object M, and, in another thread, B performs a consume operation on M and <strong>reads a value written by any side effect</strong> in the release sequence headed by A (...)</p>\n</blockquote>\n<p>1.10.9:</p>\n<blockquote>\n<p id=\"so_16391540_16397575_4\">An evaluation A carries a dependency to an evaluation B if - the value of A is used as an operand of B, unless:</p>\n<p id=\"so_16391540_16397575_5\">\u2014 B is an invocation of any specialization of std::kill_dependency (29.3), or</p>\n<p id=\"so_16391540_16397575_6\">\u2014 A is the left operand of a built-in logical AND (&amp;&amp;, see 5.14) or logical OR (||, see 5.15) operator, or</p>\n<p id=\"so_16391540_16397575_7\">\u2014 A is the left operand of a conditional (?:, see 5.16) operator, or</p>\n<p id=\"so_16391540_16397575_8\">\u2014 A is the left operand of the built-in comma (,) operator (5.18); (...)</p>\n</blockquote>\n<p>Basing on these facts I say that <code>mLocalMemPtr2</code> should be synchronized. However there is still a question of the order of evaluation.</p>\n<pre><code>if (atomic.load(std::consume) &lt; x)\n</code></pre>\n<p>Which one is evaluated first is unspecified. There is <em>no guarantee</em> (as I couldn't find it in the standard) that the compiler will first perform consume operation, refresh shared buffer and then load <code>atomic</code> <strong>and then</strong> <code>x</code>.</p>\n<p>Having not found a proof that operands are evaluated in the \"wished\" way, I say that without explicit decomposition of the atomic load <code>mLocalMemPtr2</code> it won't work and CPU might read stale value of memory pointed by <code>mLocalMemPtr2</code>. <code>memory_order_acquire</code> would not change much here, as <code>mLocalMemPtr2</code> carries a data dependency.</p>\n", "LastActivityDate": "2013-05-06T11:56:44.363"}, "bq_ids": {"n4140": {"so_16391540_16397575_3": {"section_id": 5823, "quality": 1.0, "length": 18}, "so_16391540_16397575_6": {"section_id": 5822, "quality": 0.7272727272727273, "length": 8}, "so_16391540_16397575_4": {"section_id": 5822, "quality": 0.8333333333333334, "length": 5}, "so_16391540_16397575_8": {"section_id": 5822, "quality": 0.8333333333333334, "length": 5}, "so_16391540_16397575_7": {"section_id": 5822, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_16391540_16397575_3": {"section_id": 5594, "quality": 1.0, "length": 18}, "so_16391540_16397575_6": {"section_id": 5593, "quality": 0.7272727272727273, "length": 8}, "so_16391540_16397575_4": {"section_id": 5593, "quality": 0.8333333333333334, "length": 5}, "so_16391540_16397575_8": {"section_id": 5593, "quality": 0.8333333333333334, "length": 5}, "so_16391540_16397575_7": {"section_id": 5593, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_16391540_16397575_3": {"section_id": 7284, "quality": 1.0, "length": 18}, "so_16391540_16397575_8": {"section_id": 7283, "quality": 0.8333333333333334, "length": 5}, "so_16391540_16397575_4": {"section_id": 7283, "quality": 0.8333333333333334, "length": 5}, "so_16391540_16397575_6": {"section_id": 7283, "quality": 0.7272727272727273, "length": 8}, "so_16391540_16397575_7": {"section_id": 7283, "quality": 0.8333333333333334, "length": 5}}}, "16391615": {"ParentId": "16391540", "CommentCount": "0", "CreationDate": "2013-05-06T03:32:58.920", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "16391615", "Score": "0", "Body": "<p>I believe that with <code>consume</code> ordering, the compiler could actually make a copy of the entire <code>mSharedBuffer</code> in advance.  You need <code>acquire</code> semantics to invalidate previously cached copies of variables other than <code>mAtomicMemLocPtr</code>\n.</p>\n", "LastActivityDate": "2013-05-06T03:32:58.920"}});