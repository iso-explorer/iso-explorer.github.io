post_cb({"18667552": {"ParentId": "18667318", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>In your second code snippet:</p>\n<pre><code>{\n    int asInt = 3; // the object '3' is now alive, trivial constructor + assignment\n    short* asShort = (short*)&amp;asInt; // just creating a pointer\n    *asShort = 4; \n    // Violation of strict aliasing. Undefined behavior. End of.\n}\n</code></pre>\n<p>The same applies to your first code snippet. It is not \"safe\", but it will generally work because (a) there's no particular reason for a compiler to be implemented such that it doesn't work, and (b) in practice compilers have to support at least a few violations of strict aliasing or else it would be impossible to implement the memory allocator using the compiler.</p>\n<p>The thing that I know can and does provoke compilers to break this kind of code is if you read <code>asInt</code> afterwards, the DFA is allowed to \"detect\" that <code>asInt</code> is not modified (since it's modified only by the strict-alias violation, which is UB), and move the initialization of <code>asInt</code> after the write to <code>*asShort</code>. That's UB by either of our interpretations of the standard though -- in my interpretation because of the strict aliasing violation and in your interpretation because <code>asInt</code> is read after the end of its lifetime. So we're both happy for that not to work.</p>\n<p>However I don't agree with your interpretation. If you consider that assigning to <em>part</em> of the storage of <code>asInt</code> ends the lifetime of <code>asInt</code>, then that's a direct contradiction of the statement that the lifetime of an automatic object is its scope. OK, so we might accept that this is an exception to the general rule. But that would mean that the following is not valid:</p>\n<pre><code>{\n    int asInt = 0;\n    unsigned char *asChar = (unsigned char*)&amp;asInt;\n    *asChar = 0; // I've assigned the storage, so I've ended the lifetime, right?\n    std::cout &lt;&lt; asInt; // using an object after end of lifetime, undefined behavior!\n}\n</code></pre>\n<p>Except that the whole point of allowing <code>unsigned char</code> as an aliasing type (and of defining that all-bits-0 means \"0\" for integer types) is to make code like this work. So I'm very reluctant to make an interpretation of any part of the standard, which implies that this doesn't work.</p>\n<p>Ben gives another interpretation in comments below, that the <code>*asShort</code> assignment simply doesn't end the lifetime of <code>asInt</code>.</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2013-09-06T23:12:16.623", "Id": "18667552", "Score": "2", "CreationDate": "2013-09-06T22:32:08.123", "LastActivityDate": "2013-09-06T23:12:16.623"}, "18667318": {"CommentCount": "17", "AcceptedAnswerId": "18667552", "PostTypeId": "1", "LastEditorUserId": "2728148", "CreationDate": "2013-09-06T22:09:15.000", "LastActivityDate": "2013-09-07T04:41:28.280", "LastEditDate": "2013-09-07T00:36:02.570", "ViewCount": "289", "FavoriteCount": "3", "Title": "Do trivial destructors cause aliasing", "Id": "18667318", "Score": "5", "Body": "<p>C++11 \u00a73.8.1 declares that, for an object with a trivial destructor, I can end its lifespan by assigning to its storage.  I am wondering if trivial destructors can prolong the object's lifespan and cause aliasing woes by \"destroying an object\" that I ended the lifespan of much earlier.</p>\n<p>To start, something which I know is safe and alias-free</p>\n<pre><code>void* mem = malloc(sizeof(int));\nint*  asInt = (int*)mem;\n*asInt = 1; // the object '1' is now alive, trivial constructor + assignment\nshort*  asShort = (short*)mem;\n*asShort = 2; // the object '1' ends its life, because I reassigned to its storage\n              // the object '2' is now alive, trivial constructor + assignment\nfree(mem);    // the object '2' ends its life because its storage was released\n</code></pre>\n<p>Now, for something which is not so clear:</p>\n<pre><code>{\n    int asInt = 3; // the object '3' is now alive, trivial constructor + assignment\n    short* asShort = (short*)&amp;asInt; // just creating a pointer\n    *asShort = 4; // the object '3' ends its life, because I reassigned to its storage\n                  // the object '4' is now alive, trivial constructor + assignment\n    // implicitly, asInt-&gt;~int() gets called here, as a trivial destructor\n}   // 'the object '4' ends its life, because its storage was released\n</code></pre>\n<p>\u00a76.7.2 states that objects of automatic storage duration are destroyed at the end of the scope, indicating that the destructor gets called.  <strong>If there is an int to destroy, <code>*asShort = 2</code> is an aliasing violation because I am dereferencing a pointer of unrelated type.  But if the integer's lifespan ended before <code>*asShort = 2</code>, then I am calling an int destructor on a short.</strong></p>\n<p>I see several competing sections regarding this:</p>\n<p>\u00a73.8.8 reads</p>\n<blockquote>\n<p id=\"so_18667318_18667318_0\">If a program ends the lifetime of an object of type T with static (3.7.1), thread (3.7.2), or automatic (3.7.3)\n  storage duration and if T has a non-trivial destructor,39 the program must ensure that an object of the\n  original type occupies that same storage location when the implicit destructor call takes place; otherwise the\n  behavior of the program is undefined.</p>\n</blockquote>\n<p>The fact that they call out types T with non-trivial destructor as yielding undefined behavior seems, to me, to indicate that having a different type in that storage location with a trivial destructor <em>is</em> defined, but I couldn't find anywhere in the spec that defined that.</p>\n<p>Such a definition would be easy if a trivial destructor was defined to be a noop, but there's remarkably little in the spec about them.</p>\n<p>\u00a76.7.3 indicates that goto's are allowed to jump into and out of scopes whose variables have trivial constructors and trivial destructors.  This seems to suggest a pattern where trivial destructors are allowed to be skipped, but the earlier section from the spec on destroying objects at the end of the scope mentions none of this.</p>\n<p>Finally, there's the sassy reading:</p>\n<p>\u00a73.8.1 indicates that I am allowed to start an object's lifespan any time I want, if its constructor is trivial.  This seems to indicate that I could do something like</p>\n<pre><code>{\n    int asInt = 3;\n    short* asShort = (short*)&amp;asInt;\n    *asShort = 4; // the object '4' is now alive, trivial constructor + assignment\n    // I declare that an object in the storage of &amp;asInt of type int is\n    // created with an undefined value.  Doing so reuses the space of\n    // the object '4', ending its life.\n\n    // implicitly, asInt-&gt;~int() gets called here, as a trivial destructor\n}\n</code></pre>\n<p>The only one of these reading that seems to suggest any aliasing issues is \u00a76.7.2 on its own.  It seems like, when read as part of a whole spec, the trivial destructor should not affect the program in any way (though for various reasons).  Does anyone know what happens in this situation?</p>\n", "Tags": "<c++><memory><c++11><destructor>", "OwnerUserId": "2728148", "AnswerCount": "2"}, "18669481": {"ParentId": "18667318", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>I cannot say I have all the answers, as this is a part of the standard that I have tried hard to digest and it is non-trivial (euphemism for really complicated). Still, since I disagree with the answer by Steve Jessop, here is my take.</p>\n<pre><code>void f() {\n   alignas(alignof(int)) char buffer[sizeof(int)];\n   int *ip = new (buffer) int(1);                 // 1\n   std::cout &lt;&lt; *ip &lt;&lt; '\\n';                      // 2\n   short *sp = new (buffer) short(2);             // 3\n   std::cout &lt;&lt; *sp &lt;&lt; '\\n';                      // 4\n}\n</code></pre>\n<p>The behavior of that function is well defined and guaranteed by the standard. There is no problem with the strict aliasing rules at all. The rules determine when it is safe to <em>read</em> the value <em>written</em> to a variable. In the code above, the read in [2] extracts the value written in [1] through an object of the same type. The assignment <em>reuses</em> the memory of the <code>char</code>s and terminates their lifetime, so an object of type <code>int</code> <em>becomes</em> over the space previously taken by the <code>char</code>s. The strict aliasing rules don't have a problem with that since the read is with a pointer of the same type. In [3], a <code>short</code> is written over the memory previously ocupied by the <code>int</code>, <em>reusing</em> the storage. The <code>int</code> is gone and a <code>short</code> starts its lifetime. Again the read in [4] is through a pointer of the same type that was used to store the value, and is perfectly fine by the aliasing rules.</p>\n<p>The key at this point is the first sentence of the aliasing rules: 3.10/10 <em>If a program attempts to <strong>access the stored value</strong> of an object through a glvalue of other than one of the following types the behavior is undefined:</em></p>\n<p>Regarding the lifetime of objects, and in particular when the lifetime of an object ends, the quote you provide is not complete. It is perfectly fine for a destructor <em>not</em> to run as long as the program does not depend on the destructor being run. This only matters to some extent, but I think it is important to make it clear. <strike>While not explicitly stated as such, the fact is that a trivial destructor is a no-op (this can be derived from the definition of a what a trivial destructor is).</strike>[See edit below]. The quote in 3.8/8 means that if you have an object with trivial destructor for example any of the fundamental types with static storage you can reuse the memory as shown above and this won't cause undefined behavior (by itself). The premise is that since the destructor for the type is trivial, it is a no-op and what is currently <em>living</em> on that location is not important for the program. (At this point, if what was stored over that location is trivial or if the program does not depend on its destructor being run the program will be well defined; if the program behavior depends on the destructor of the overwriting type to run, well, tough luck: UB)</p>\n<hr>\n<p><em>Trivial destructor</em></p>\n<p>The standard (C++11) defines a destructor as trivial in 12.4/5:</p>\n<blockquote>\n<p id=\"so_18667318_18669481_0\">A destructor is trivial if it is not user-provided and if:</p>\n<p id=\"so_18667318_18669481_1\">\u2014 the destructor is not virtual,</p>\n<p id=\"so_18667318_18669481_2\">\u2014 all of the direct base classes of its class have trivial destructors, and</p>\n<p id=\"so_18667318_18669481_3\">\u2014 for all of the non-static data members of its class that are of class type (or array thereof), each such class has a trivial destructor.</p>\n</blockquote>\n<p>The requirements can be rewritten as: the destructor is implicitly defined and not virtual, none of the subobjects has a non-trivial destructor. The first requirement means that dynamic dispatch is not needed for the destructor call, and that makes the value of the <code>vptr</code> not needed to start the destruction chain.</p>\n<p>An implicitly defined destructor won't do anything at all for any non-class type (fundamental types, enums), but will call the destructors of the class members and bases. This means that none of the <em>data</em> stored in the complete object will be touched by the destructors, since after all everything is composed of members of fundamental types. From this description it could seem that a <em>trival destructor</em> is a no-op since no data is touched. But that is not the case.</p>\n<p>The detail that I misremembered is that the requirement is <em>not</em> that there are no virtual functions at all, but rather that the destructor is not virtual. So a type can have a virtual function and also a trivial destructor. The implication is that, at least <em>conceptually</em>, the destructor is not a no-op, since the <code>vptr</code> (or <code>vptr</code>s) present in the complete objects are updated during the chain of destruction as the type changes. Now, while a <em>trivial destructor</em> may conceptually not be a no-op, the only side effects of the evaluation of the destructor would be the modification of the <code>vptr</code>s, which is not <em>visible</em>, and thus following the <em>as-if</em> rule, the compiler can effectively make the trivial destructor a no-op (i.e. it can not generate any code at all), and that is what compilers actually do, that is, a <em>trivial destructor</em> won't have any generated code.</p>\n</hr>", "OwnerUserId": "36565", "LastEditorUserId": "36565", "LastEditDate": "2013-09-07T04:41:28.280", "Id": "18669481", "Score": "1", "CreationDate": "2013-09-07T03:46:38.617", "LastActivityDate": "2013-09-07T04:41:28.280"}, "bq_ids": {"n4140": {"so_18667318_18669481_2": {"section_id": 401, "quality": 1.0, "length": 9}, "so_18667318_18669481_3": {"section_id": 401, "quality": 1.0, "length": 15}, "so_18667318_18667318_0": {"section_id": 7196, "quality": 0.875, "length": 28}}, "n3337": {"so_18667318_18669481_2": {"section_id": 392, "quality": 1.0, "length": 9}, "so_18667318_18669481_3": {"section_id": 392, "quality": 1.0, "length": 15}, "so_18667318_18667318_0": {"section_id": 6940, "quality": 0.875, "length": 28}}, "n4659": {"so_18667318_18669481_2": {"section_id": 419, "quality": 1.0, "length": 9}, "so_18667318_18669481_3": {"section_id": 419, "quality": 1.0, "length": 15}, "so_18667318_18667318_0": {"section_id": 8705, "quality": 0.875, "length": 28}}}});