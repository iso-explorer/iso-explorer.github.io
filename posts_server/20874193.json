post_cb({"bq_ids": {"n4140": {"so_20874193_20874207_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 480}}, "n3337": {"so_20874193_20874207_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 471}}, "n4659": {"so_20874193_20874207_0": {"length": 17, "quality": 0.6296296296296297, "section_id": 502}}}, "20874206": {"Id": "20874206", "PostTypeId": "2", "Body": "<p>The call to a.test() returns by value and this value is then assigned to b \"copying\" the return value.  This invokes the copy constructor.</p>\n", "LastActivityDate": "2014-01-01T23:05:16.873", "CommentCount": "2", "CreationDate": "2014-01-01T23:05:16.873", "ParentId": "20874193", "Score": "-2", "OwnerUserId": "1778167"}, "20874193": {"ViewCount": "149", "Body": "<p>There is a part of C++ code I don't really understand.\nAlso I don't know where should I go to search information about it, so I decided to ask a question.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nclass Test\n{\n    public:\n        Test();\n        Test(Test const &amp; src);\n        Test&amp; operator=(const Test&amp; rhs);\n        Test test();\n        int x;\n};\n\nTest::Test()\n{\n    cout &lt;&lt; \"Constructor has been called\" &lt;&lt; endl;\n}\n\nTest::Test(Test const &amp; src)\n{\n    cout &lt;&lt; \"Copy constructor has been called\" &lt;&lt; endl;\n}\n\nTest&amp; Test::operator=(const Test&amp; rhs)\n{\n    cout &lt;&lt; \"Assignment operator\" &lt;&lt; endl;\n}\n\nTest Test::test()\n{\n    return Test();\n}\n\nint main()\n{\n    Test a;\n    Test b = a.test();\n\n    return 0;\n}\n</code></pre>\n<p>Why the input I get is</p>\n<pre><code>Constructor has been called\nConstructor has been called\n</code></pre>\n<p>?\na.test() creates a new instance by calling \"Test()\" so that's why the second message is displayed. But why no copy constructor or assignment called?\nAnd if I change \"return Test()\" to \"return *(new Test())\" then the copy constructor is called.</p>\n<p>So why isn't it called the first time?</p>\n", "AcceptedAnswerId": "20874207", "Title": "C++ copy constructor behaviour", "CreationDate": "2014-01-01T23:02:32.503", "Id": "20874193", "CommentCount": "3", "PostTypeId": "1", "ClosedDate": "2014-03-03T13:36:01.990", "LastActivityDate": "2014-01-01T23:05:39.040", "Score": "1", "OwnerUserId": "2452103", "Tags": "<c++><constructor><copy><variable-assignment>", "AnswerCount": "2"}, "20874207": {"Id": "20874207", "PostTypeId": "2", "Body": "<p>Compilers are very smart. Both copies - returning from <code>test</code> and initialising <code>b</code> (not this is not an assignment) - are elided according to the following rule (C++11 \u00a712.8):</p>\n<blockquote>\n<p id=\"so_20874193_20874207_0\">when a temporary class object that has not been bound to a reference (12.2) would be copied/moved to a class object with the same cv-unqualified type, the copy/move operation can be omitted by constructing the temporary object directly into the target of the omitted copy/move</p>\n</blockquote>\n<p>Compilers are allowed to do this even if it would change the behaviour of your program (like removing your output messages). It's expected that you do not write copy/move constructors and assignment operators that have other side effects.</p>\n<p>Note that is only one of four cases in which copy elision can occur (not counting the as-if rule).</p>\n", "LastActivityDate": "2014-01-01T23:05:39.040", "CommentCount": "1", "CreationDate": "2014-01-01T23:05:39.040", "ParentId": "20874193", "Score": "3", "OwnerUserId": "150634"}});