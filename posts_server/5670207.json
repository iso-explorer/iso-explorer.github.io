post_cb({"5671283": {"Id": "5671283", "PostTypeId": "2", "Body": "<p>The C standard does put some limitations on how floating point values are represented.  In <em>\u00a75.2.4.2.2 Characteristics of floating types</em>, floating point numbers must exhibit characteristics as if they were defined by the model:</p>\n<blockquote>\n<p id=\"so_5670207_5671283_0\">x = sb<sup>e</sup> \u03a3<sub>k=1..p</sub> f<sub>k</sub> b<sup>-k</sup></p>\n</blockquote>\n<p>Where:</p>\n<ul>\n<li><strong>s</strong> is the sign, and must be \u00b11;</li>\n<li><strong>b</strong> is the base, and must be an integer &gt; 1;</li>\n<li><strong>e</strong> is the exponent and must be an integer between e<sub>min</sub> and e<sub>max</sub>;</li>\n<li><strong>p</strong> is the precision; and</li>\n<li><strong>f<sub>k</sub></strong> are non-negative integers &lt; <strong>b</strong> - the digits of the significand.</li>\n</ul>\n<p>Under this model, zero is <em>always</em> able to be exactly represented - it simply requires all the significand digits <strong>f<sub>k</sub></strong> to be zero.</p>\n<p>Given the following restriction in \u00a76.3.1.4:</p>\n<blockquote>\n<p id=\"so_5670207_5671283_1\">When a value of integer type is\n  converted to a real floating type, if\n  the value being converted can be\n  represented exactly in the new type,\n  it is unchanged.</p>\n</blockquote>\n<p>It follows that zero must always be unchanged when converted from the integer 0 to a floating point type.  Therefore the assertion must always hold.</p>\n", "LastActivityDate": "2011-04-15T00:43:50.413", "CommentCount": "5", "CreationDate": "2011-04-15T00:43:50.413", "ParentId": "5670207", "Score": "5", "OwnerUserId": "134633"}, "bq_ids": {"n4140": {"so_5670207_5671283_1": {"length": 12, "quality": 0.7058823529411765, "section_id": 38}}, "n3337": {"so_5670207_5671283_1": {"length": 12, "quality": 0.7058823529411765, "section_id": 35}}, "n4659": {"so_5670207_5671283_1": {"length": 11, "quality": 0.6470588235294118, "section_id": 38}}}, "5670246": {"Id": "5670246", "PostTypeId": "2", "Body": "<p>C99 does not mandate IEEE754, only recommends it. There is a symbol that IEEE 754 compliant compilation platforms can define (Annex F).\nIf the compiler defines this symbol, then yes, the assertion would be guaranteed to hold. When the literal constant is representable exactly as a floating-point number, then this floating-point number is what you must get in the compiled program.</p>\n<p>I cannot think of any non-IEEE 754 floating-point system that wouldn't have a zero, or a reason not to map the literal <code>0</code> in the source code to it.</p>\n", "LastActivityDate": "2011-04-14T22:02:35.160", "CommentCount": "0", "CreationDate": "2011-04-14T22:02:35.160", "ParentId": "5670207", "Score": "1", "OwnerUserId": "139746"}, "5670207": {"ViewCount": "1509", "Body": "<p>Can the following code be expected to work in <em>all</em> environments that have an ANSI-compliant C compiler?</p>\n<pre><code>double n = 0;\nassert(n == 0);\n</code></pre>\n<p>What about C++?</p>\n", "AcceptedAnswerId": "5670262", "Title": "Is the double 0.0 always represented exactly in portable C?", "CreationDate": "2011-04-14T21:57:53.100", "Id": "5670207", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-04-15T00:43:50.413", "Score": "1", "OwnerUserId": "2063015", "Tags": "<c++><c><bit-representation><inexact-arithmetic>", "AnswerCount": "4"}, "5670291": {"Id": "5670291", "PostTypeId": "2", "Body": "<p>The comparison will promote the integer to a double. What you're asking is if the compiler is guaranteed to do identical conversions each time it converts identical integers to double. I believe it is.</p>\n<p>Not only that, any small enough integer can be exactly represented by a double. I can't imagine any compiler that would do a conversion in that case that wasn't precise.</p>\n", "LastActivityDate": "2011-04-14T22:08:24.730", "CommentCount": "1", "CreationDate": "2011-04-14T22:08:24.730", "ParentId": "5670207", "Score": "2", "OwnerUserId": "5987"}, "5670262": {"Id": "5670262", "PostTypeId": "2", "Body": "<p>You're not asking if <code>0.0</code> is always represented exactly.</p>\n<p>In the statement <code>assert(n == 0)</code>, <code>0</code> is converted to <code>double</code> before the comparison occurs.  Thus, the assert can only be triggered if converting <code>0</code> from <code>int</code> to <code>double</code> is not reproducible.  This is a much weaker restriction than what you're asking about, and will almost certainly hold (though I can't think of a standards reference to guarantee it off the top of my head).</p>\n<p>To the question you intended to ask:</p>\n<p>As others mentioned, the C standard does not require that floating-point types map to IEEE-754, but I am not aware of any floating-point representation used with any C compiler that does not have an exact representation of zero.  That said, it would be \"legal\" for a C implementation to use a format for <code>double</code> that did not have an exact zero.</p>\n", "LastActivityDate": "2011-04-14T22:04:36.943", "CommentCount": "7", "CreationDate": "2011-04-14T22:04:36.943", "ParentId": "5670207", "Score": "5", "OwnerUserId": "142434"}});