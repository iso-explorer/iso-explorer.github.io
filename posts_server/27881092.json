post_cb({"27881136": {"CommentCount": "1", "Body": "<p>As others have said, this is undefined behavior, but I thought a bit more info might help. <code>myTestArray</code> is not an \"Array\" in the sense of a type, with special operators, etc. It is just a pointer to a location in memory. The expression <code>myTestArray[4]</code> is just short-hand for <code>*(myTestArray+4)</code> - it is returning a reference to the memory location that is <code>4 * sizeof(int)</code> past <code>myTestArray</code>. If you want bounds checking, you'll have to use <code>std::vector&lt;int&gt;::at()</code>.</p>\n", "CreationDate": "2015-01-10T20:57:03.050", "ParentId": "27881092", "Id": "27881136", "LastActivityDate": "2015-01-10T20:57:03.050", "PostTypeId": "2", "Score": "1", "OwnerUserId": "2587908"}, "27881245": {"CommentCount": "0", "Body": "<p>Knowing what's going on here <em>for sure</em> is very hard to do. But I can give you a rough idea.</p>\n<p>Most operating systems have a minimum size for memory allocations. In Unix it is the native page size. On x86 and amd64 systems this is 4 kB. In Windows it is 64 kB (I think).</p>\n<p>The memory allocator used by <code>malloc</code> and <code>new</code> gets memory from the operating system in chunks of this size. It sets up data structures (often a linked list, sometimes a bitmap, or a tree) and hands out small pieces of the requested sizes.</p>\n<p>One other confusing thing is that before your program even starts running <code>main()</code> it has run quite a bit of other code and allocated memory. For <code>std::cout</code> and other static and global objects, and for shared library linking.</p>\n<p>But assume that when you call <code>new</code> your program first gets a chunk of 4 kB and gives you a pointer to 8 bytes of it (two integers). Your program has the entire 4 kB allocated and you can write there without crashing. However, what happens if you call <code>new</code> again? It is very likely that the memory allocator wrote some important tracking information somewhere into that 4 kB. The next bytes might be the size of the following block. Writing 54 into it might make it think it has more or less memory than it does. Or those bytes might be a pointer to the next block of free memory, and your 54 will cause the next memory allocation to crash the program.</p>\n", "CreationDate": "2015-01-10T21:09:35.447", "ParentId": "27881092", "Id": "27881245", "LastActivityDate": "2015-01-10T21:09:35.447", "PostTypeId": "2", "Score": "1", "OwnerUserId": "13422"}, "27881098": {"CommentCount": "2", "Body": "<p>Accessing unallocated memory is not guaranteed to throw exceptions.</p>\n<p>It's actually not guaranteed to do anything, since that's undefined behavior. Anything could happen. Beware of nasal demons.</p>\n<p>It prints 55 because you just stored 54, fetched it back and then printed 54+1. It's not at all guaranteed to print 55, although that's often what will happen in practice. This time it worked.</p>\n", "CreationDate": "2015-01-10T20:52:59.773", "ParentId": "27881092", "Id": "27881098", "LastActivityDate": "2015-01-10T20:52:59.773", "PostTypeId": "2", "Score": "8", "OwnerUserId": "1401962"}, "27881092": {"CreationDate": "2015-01-10T20:51:41.540", "ViewCount": "859", "Id": "27881092", "AcceptedAnswerId": "27881098", "Score": "3", "Title": "Accessing unallocated memory C++", "CommentCount": "3", "Body": "<p>I am having this piece of code:</p>\n<pre><code>try\n{\n    int* myTestArray = new int[2];\n\n    myTestArray[4] = 54;\n\n    cout &lt;&lt; \"Should throw ex \"  &lt;&lt; myTestArray[4] + 1 &lt;&lt; endl;\n}\ncatch (exception&amp; exception)\n{ \n    cout &lt;&lt; \"Exception content: \" &lt;&lt; exception.what() &lt;&lt; endl;\n}\n</code></pre>\n<p>What is really curios for me, is that why the exception is not thrown here, since it was accessed an index which was not allocated... and why 55 is print ? Is that C++ automatically increased the size of the array ?</p>\n", "Tags": "<c++><arrays><pointers><memory>", "LastActivityDate": "2015-01-14T04:00:45.807", "PostTypeId": "1", "AnswerCount": "6", "OwnerUserId": "2418835"}, "bq_ids": {"n4140": {"so_27881092_27881102_0": {"length": 106, "quality": 0.9814814814814815, "section_id": 6142}}, "n3337": {"so_27881092_27881102_0": {"length": 106, "quality": 0.9814814814814815, "section_id": 5906}}}, "27881119": {"CommentCount": "0", "Body": "<p>You can write out of array range, but it is not guaranteed to work, and the data is not guaranteed to be persistent there, as something else can overwrite it.</p>\n<p>It's simply not a good idea, and since there's no exception, potentially hard to find bug.</p>\n<p>When reading that memory, you will be pulling some random garbage that was there left over from some other program or whatever used the memory before, so it can really be anything.</p>\n", "CreationDate": "2015-01-10T20:54:55.087", "ParentId": "27881092", "Id": "27881119", "LastActivityDate": "2015-01-10T20:54:55.087", "PostTypeId": "2", "Score": "0", "OwnerUserId": "2180189"}, "27881227": {"LastActivityDate": "2015-01-14T04:00:45.807", "CommentCount": "0", "Body": "<p>There is an unstated, and incorrect, assumptions here.  That assumption is that C++ actually gives a damn about what you do with memory. C++, like its C ancestor, has a completely unchecked model of memory. What you have here is classically called a buffer overflow, and is a source of innumerable bugs including some horrible security flaws.</p>\n<p>Here's what your code really says:</p>\n<ul>\n<li><p><code>myTestArray</code> is the name of a location in memory big enough to hold the address of an <code>int</code>.</p></li>\n<li><p>Two <code>int</code>s worth of memory have been allocated on the heap for it. <em>[And that addreress is put into the location <code>myTestArray</code>. Doesn't matter, but that probably makes it clearer.]</em> (Along with probably 16 bytes of overhead, but we don't care about that now.)</p></li>\n<li><p>you then are sticking the value <code>54</code> into the memory location 4 <code>int</code>s from the address contained in <code>myTestArray</code>.</p></li>\n<li><p>looking at that location, adding 1 and printing the result.</p></li>\n</ul>\n<p>You are demonstrating that C(++) indeed just doesn't care.</p>\n<p>Now, under most conditions the underlying memory management and run time system won't let you get away with it; you will violate <em>it's</em> assumptions and get a segmentation error or something similar. But in this case, you are not hitting a boundary yet, most likely because you're piddling on the data structure that malloc is using under the covers to manage the heap.  You're getting away with it because nothing is happening with the heap for the rest of the program.  But for a real good time, write a little loop that does this code, freeing <code>myTestArray</code> and reallocating it.  I'd lay long odds it won't run for more than 10 iterations before the program blows up, and might not make two.</p>\n", "CreationDate": "2015-01-10T21:08:07.520", "LastEditDate": "2015-01-14T04:00:45.807", "ParentId": "27881092", "Id": "27881227", "LastEditorUserId": "35092", "PostTypeId": "2", "Score": "9", "OwnerUserId": "35092"}, "27881102": {"LastActivityDate": "2015-01-10T20:59:02.860", "CommentCount": "0", "Body": "<p>Accessing array out of range is undefined behavior. Thus 55 is one of many possible results and there is nothing surprising here.</p>\n<p>C++ Standard n3337 <strong>\u00a7</strong> 5.7 Additive operators</p>\n<blockquote>\n<p id=\"so_27881092_27881102_0\">5) When an expression that has integral type is added to or subtracted\n  from a pointer, the result has the type of the pointer operand. If the\n  pointer operand points to an element of an array object, and the array\n  is large enough, the result points to an element offset from the\n  original element such that the difference of the subscripts of the\n  resulting and original array elements equals the integral expression.\n  In other words, if the expression P points to the i-th element of an\n  array object, the expressions (P)+N (equivalently, N+(P)) and (P)-N\n  (where N has the value n) point to, respectively, the i + n-th and i \u2212\n  n-th elements of the array object, provided they exist. Moreover, if\n  the expression P points to the last element of an array object, the\n  expression (P)+1 points one past the last element of the array object,\n  and if the expression Q points one past the last element of an array\n  object, the expression (Q)-1 points to the last element of the array\n  object. If both the pointer operand and the result point to elements\n  of the same array object, or one past the last element of the array\n  object, the evaluation shall not produce an overflow; <strong>otherwise, the\n  behavior is undefined</strong>.</p>\n</blockquote>\n", "CreationDate": "2015-01-10T20:53:21.600", "LastEditDate": "2015-01-10T20:59:02.860", "ParentId": "27881092", "Id": "27881102", "LastEditorUserId": "1141471", "PostTypeId": "2", "Score": "0", "OwnerUserId": "1141471"}});