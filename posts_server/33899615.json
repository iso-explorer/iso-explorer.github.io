post_cb({"33899615": {"CommentCount": "8", "ViewCount": "577", "PostTypeId": "1", "LastEditorUserId": "2093142", "CreationDate": "2015-11-24T17:02:29.670", "LastActivityDate": "2015-11-25T15:47:18.067", "Title": "std::future still valid after calling get() (which throws an exception)", "AcceptedAnswerId": "33900775", "LastEditDate": "2015-11-25T15:47:18.067", "Id": "33899615", "Score": "8", "Body": "<p>According to <a href=\"http://en.cppreference.com/w/cpp/thread/future/get\" rel=\"nofollow\">cppreference</a>, after calling <code>std::future::get</code>:</p>\n<blockquote>\n<p id=\"so_33899615_33899615_0\">valid() is false after a call to this method.</p>\n</blockquote>\n<p>Additionally, from <a href=\"http://www.cplusplus.com/reference/future/future/get/\" rel=\"nofollow\">cplusplus.com</a>:</p>\n<blockquote>\n<p id=\"so_33899615_33899615_1\">Once the shared state is ready, the function unblocks and returns (or throws) releasing its shared state. This makes the future object no longer valid: this member function shall be called once at most for every future shared state.</p>\n</blockquote>\n<p>And under <strong>Exception safety</strong>:</p>\n<blockquote>\n<p id=\"so_33899615_33899615_2\">The function throws the exception stored in the shared state when the provider makes it ready by setting it to an exception. Note that in this case a basic guarantee is offered, with the future object being modified to no longer be a valid future (which is itself a valid state for object of this type, despite its name).</p>\n</blockquote>\n<p>Neither description makes a distinction between a call to <code>get</code> which returns a value versus one that throws an exception regarding the invalidation of the future object.</p>\n<p>However, the described behavior is not what I'm seeing with this example code:</p>\n<pre><code>#include &lt;chrono&gt;\n#include &lt;future&gt;\n#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n\n\nint foo()\n{\n    throw std::runtime_error(\"foo exception\");\n}\n\n\nint main()\n{\n    std::future&lt;int&gt; futInt;\n\n    futInt = std::async(std::launch::async, []() { return foo(); });\n\n    while( !(futInt.valid() &amp;&amp; futInt.wait_for(std::chrono::milliseconds(0)) == std::future_status::ready) )\n        ;\n\n    if( futInt.valid() )\n    {\n        int val;\n        try\n        {\n            val = futInt.get();\n        }\n        catch( const std::exception&amp; e )\n        {\n            std::cout &lt;&lt; e.what() &lt;&lt; std::endl;\n        }\n    }\n\n    if( futInt.valid() )\n    {\n        std::cout &lt;&lt; \"This is TOTALLY UNEXPECTED!!!\" &lt;&lt; std::endl;\n    }\n    else\n    {\n        std::cout &lt;&lt; \"This is expected.\" &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>\n<p>The output I see is:</p>\n<pre><code>foo exception\nThis is TOTALLY UNEXPECTED!!!\n</code></pre>\n<p>I'm using Visual Studio Premium 2013, Version 12.0.30501.00 Update 2. Is this a bug with the compiler or, in fact, correct behavior in the case of an exception? I've been unable to find any bug reports concerning this, so wasn't sure if it was expected behavior.</p>\n<p><strong>Edit - &lt;future&gt; implementation investigation</strong></p>\n<p>Digging into the <code>std::future</code> implementation a bit, the <code>_Associated_state</code> object is marked <code>_Retrieved = true;</code> <strong>AFTER</strong> checking and throwing the associated exception (if any):</p>\n<pre><code>virtual _Ty&amp; _Get_value(bool _Get_only_once)\n    {   // return the stored result or throw stored exception\n    unique_lock&lt;mutex&gt; _Lock(_Mtx);\n    if (_Get_only_once &amp;&amp; _Retrieved)\n        _Throw_future_error(\n            make_error_code(future_errc::future_already_retrieved));\n    if (_Exception)\n        _Rethrow_future_exception(_Exception);\n    _Retrieved = true;\n    _Maybe_run_deferred_function(_Lock);\n    while (!_Ready)\n        _Cond.wait(_Lock);\n    if (_Exception)\n        _Rethrow_future_exception(_Exception);\n    return (_Result);\n    }\n</code></pre>\n<p>My guess is that the exception check and <code>_Retrieved = true;</code> should be swapped - the object should immediately be set as retrieved (after the <code>_Get_only_once</code> check) and then all other logic should follow. Ergo, compiler bug.</p>\n<p><strong>Edit - workaround</strong></p>\n<p>I think the following should suffice in lieu of directly calling <code>get</code> until a fix is implemented:</p>\n<pre><code>template&lt;typename T&gt;\nT getFromFuture(std::future&lt;T&gt;&amp; fut)\n{\n    try\n    {\n        return fut.get();\n    }\n    catch( ... )\n    {\n        fut = {};\n        throw;\n    }\n}\n</code></pre>\n", "Tags": "<c++><c++11><exception><stl><future>", "OwnerUserId": "2093142", "AnswerCount": "1"}, "33900775": {"ParentId": "33899615", "CommentCount": "2", "CreationDate": "2015-11-24T18:05:59.547", "OwnerUserId": "3893186", "PostTypeId": "2", "Id": "33900775", "Score": "3", "Body": "<p>I compiled on Linux with gcc 5.2.0 and clang 3.7.0 -- both times with 64 Bit.\nRunning the program always results in</p>\n<pre><code>foo exception\nThis is expected.\n</code></pre>\n<p>It looks to me like Visual 2013 handles this incorrectly.\nSee also:</p>\n<p><strong>C++ \u00a730.6.6/16-17</strong></p>\n<blockquote>\n<p id=\"so_33899615_33900775_0\"><em>Throws:</em> the stored exception, if an exception was stored in the shared state.</p>\n<p id=\"so_33899615_33900775_1\"><em>Postcondition:</em> <code>valid() == false</code>.</p>\n</blockquote>\n<p>The postcondition is mentioned after the throws and thus has to always hold, even if an exception is thrown. At least that is my interpretation, though I do not speak standardese.</p>\n<p>I guess you should probably try also with Visual Studio 2015 and report a bug if that shows the same handling.</p>\n", "LastActivityDate": "2015-11-24T18:05:59.547"}, "bq_ids": {"n4140": {"so_33899615_33900775_0": {"section_id": 3121, "quality": 0.875, "length": 7}}, "n3337": {"so_33899615_33900775_0": {"section_id": 2998, "quality": 0.875, "length": 7}}, "n4659": {"so_33899615_33900775_0": {"section_id": 3883, "quality": 0.875, "length": 7}}}});