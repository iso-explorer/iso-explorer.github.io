post_cb({"3063401": {"ParentId": "3063341", "CommentCount": "8", "CreationDate": "2010-06-17T16:01:50.443", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "3063401", "Score": "58", "Body": "<p>The answer is no, because of the definition of \"lifetime\" in \u00a73.8/1:</p>\n<blockquote>\n<p id=\"so_3063341_3063401_0\">The lifetime of an object of type <code>T</code> ends when:</p>\n<p id=\"so_3063341_3063401_1\">\u2014 if <code>T</code> is a class type with a non-trivial destructor (12.4), the destructor call starts, or</p>\n<p id=\"so_3063341_3063401_2\">\u2014 the storage which the object occupies is reused or released.</p>\n</blockquote>\n<p>As soon as the destructor is called (the first time), the lifetime of the object has ended.  Thus, if you call the destructor for the object from within the destructor, the behavior is undefined, per \u00a712.4/6:</p>\n<blockquote>\n<p id=\"so_3063341_3063401_3\">the behavior is undefined if the destructor is invoked for an object whose lifetime has ended</p>\n</blockquote>\n", "LastActivityDate": "2010-06-17T16:01:50.443"}, "3063861": {"ParentId": "3063341", "CommentCount": "4", "CreationDate": "2010-06-17T17:06:09.067", "OwnerUserId": "103206", "PostTypeId": "2", "Id": "3063861", "Score": "5", "Body": "<p>It comes back to the compiler's definition of the lifetime of an object. As in, when is the memory really de-allocated. I would think it could not be until after the destructor has completed, as the destructor has access to the object's data. Therefore, I would expect recursive calls to the destructor to work.</p>\n<p>But ... there are surely many ways to implement a destructor and the freeing of memory. Even if it worked as I wanted on the compiler I'm using today, I would be very cautious about relying on such behavior. There are lots of things where the documentation says it won't work or the results are unpredictable that in fact work just fine if you understand what is really happening inside. But it's bad practice to rely on them unless you really have to, because if the specs say that this doesn't work, then even if it really does work, you have no assurance that it will continue to work in the next version of the compiler.</p>\n<p>That said, if you really want to call your destructor recursively and this isn't just a hypothetical question, why not just rip the entire body of the destructor into another function, let the destructor call that, and then let that call itself recursively? That should be safe.</p>\n", "LastActivityDate": "2010-06-17T17:06:09.067"}, "3063564": {"ParentId": "3063341", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2010-06-17T16:28:01.093", "Score": "9", "LastEditorUserId": "283676", "LastEditDate": "2010-06-21T09:57:58.840", "Id": "3063564", "OwnerUserId": "283676", "Body": "<p>Okay, we understood that behavior is not defined. But let's do small journey into what really happends. I use VS 2008. </p>\n<p>Here is my code:</p>\n<pre><code>class Test\n{\nint i;\n\npublic:\n    Test() : i(3) { }\n\n    ~Test()\n    {\n        if (!i)\n            return;     \n        printf(\"%d\", i);\n        i--;\n        Test::~Test();\n    }\n};\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    delete new Test();\n    return 0;\n}\n</code></pre>\n<p>Let's run it and set a breakpoint inside destructor and let the miracle of recursion happen. </p>\n<p>Here is stack trace:</p>\n<p><a href=\"http://img638.imageshack.us/img638/8508/dest.png\" rel=\"nofollow noreferrer\">alt text http://img638.imageshack.us/img638/8508/dest.png</a></p>\n<p>What is that <code>scalar deleting destructor</code>? It is something that compiler inserts between delete and our actual code. Destructor itself is just a method, there is nothing special about it. It doesn't really release the memory. It is released somewhere inside that <code>scalar deleting destructor</code>. </p>\n<p>Let's go to <code>scalar deleting destructor</code> and take a look at the disassembly:</p>\n<pre><code>01341580  mov         dword ptr [ebp-8],ecx \n01341583  mov         ecx,dword ptr [this] \n01341586  call        Test::~Test (134105Fh) \n0134158B  mov         eax,dword ptr [ebp+8] \n0134158E  and         eax,1 \n01341591  je          Test::`scalar deleting destructor'+3Fh (134159Fh) \n01341593  mov         eax,dword ptr [this] \n01341596  push        eax  \n01341597  call        operator delete (1341096h) \n0134159C  add         esp,4 \n</code></pre>\n<p>while doing our recursion we are stuck at address <code>01341586</code>, and memory is actually released only at address <code>01341597</code>. </p>\n<p>Conclusion: In VS 2008, since destructor is just a method and all memory release code are injected into middle function (<code>scalar deleting destructor</code>) it is safe to call destructor recursively. But still it is not good idea, IMO.</p>\n<p><strong>Edit</strong>: Ok, ok. The only idea of this answer was to take a look at what is going on when you call destructor recursively. But don't do it, it is not safe generally.</p>\n", "LastActivityDate": "2010-06-21T09:57:58.840"}, "3063391": {"ParentId": "3063341", "CommentCount": "0", "CreationDate": "2010-06-17T16:00:32.233", "OwnerUserId": "369345", "PostTypeId": "2", "Id": "3063391", "Score": "1", "Body": "<p>Yeah, that sounds about right. I would think once the destructor is finished calling, the memory would be dumped back into the allocatable pool, allowing something to write over it, thus potentially causing issues with follow-up destructor calls (the 'this' pointer would be invalid).</p>\n<p>However, if the destructor doesn't finish until the recursive loop is unwound.. it should theoretically be fine.</p>\n<p>Interesting question :)</p>\n", "LastActivityDate": "2010-06-17T16:00:32.233"}, "3063341": {"CommentCount": "8", "AcceptedAnswerId": "3063401", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-06-17T15:55:04.987", "LastActivityDate": "2017-08-05T23:57:16.243", "LastEditDate": "2017-05-23T12:32:26.887", "ViewCount": "5939", "FavoriteCount": "7", "Title": "Can a destructor be recursive?", "Id": "3063341", "Score": "50", "Body": "<p>Is this program well-defined, and if not, why exactly?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;new&gt;\nstruct X {\n    int cnt;\n    X (int i) : cnt(i) {}\n    ~X() {  \n            std::cout &lt;&lt; \"destructor called, cnt=\" &lt;&lt; cnt &lt;&lt; std::endl;\n            if ( cnt-- &gt; 0 )\n                this-&gt;X::~X(); // explicit recursive call to dtor\n    }\n};\nint main()\n{   \n    char* buf = new char[sizeof(X)];\n    X* p = new(buf) X(7);\n    p-&gt;X::~X();  // explicit call to dtor\n    delete[] buf;\n}\n</code></pre>\n<p>My reasoning: although <a href=\"https://stackoverflow.com/questions/2771567/why-exactly-is-calling-the-destructor-for-the-second-time-undefined-behavior-in-c\">invoking a destructor twice is undefined behavior</a>, per 12.4/14, what it says exactly is this:</p>\n<blockquote>\n<p id=\"so_3063341_3063341_0\">the behavior is undefined if the\n  destructor is invoked for an object\n  whose lifetime has ended</p>\n</blockquote>\n<p>Which does not seem to prohibit recursive calls. While the destructor for an object is executing, the object's lifetime has not yet ended, thus it's not UB to invoke the destructor again. On the other hand, 12.4/6 says:</p>\n<blockquote>\n<p id=\"so_3063341_3063341_1\">After executing the body [...] a\n  destructor for class X calls the\n  destructors for X's direct members,\n  the destructors for X's direct base\n  classes [...]</p>\n</blockquote>\n<p>which means that after the return from a recursive invocation of a destructor, all member and base class destructors will have been called, and calling them again when returning to the previous level of recursion would be UB. Therefore, a class with no base and only POD members can have a recursive destructor without UB. Am I right?</p>\n", "Tags": "<c++><destructor><standards-compliance>", "OwnerUserId": "273767", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_3063341_3063401_3": {"section_id": 411, "quality": 1.0, "length": 8}, "so_3063341_3063341_1": {"section_id": 404, "quality": 1.0, "length": 13}, "so_3063341_3063401_0": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}, "so_3063341_3063341_0": {"section_id": 411, "quality": 1.0, "length": 8}, "so_3063341_3063401_2": {"section_id": 7189, "quality": 1.0, "length": 5}, "so_3063341_3063401_1": {"section_id": 7189, "quality": 0.875, "length": 7}}, "n3337": {"so_3063341_3063401_3": {"section_id": 402, "quality": 1.0, "length": 8}, "so_3063341_3063341_1": {"section_id": 395, "quality": 1.0, "length": 13}, "so_3063341_3063401_0": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_3063341_3063341_0": {"section_id": 402, "quality": 1.0, "length": 8}, "so_3063341_3063401_2": {"section_id": 6933, "quality": 1.0, "length": 5}, "so_3063341_3063401_1": {"section_id": 6933, "quality": 0.875, "length": 7}}, "n4659": {"so_3063341_3063401_3": {"section_id": 429, "quality": 1.0, "length": 8}, "so_3063341_3063341_1": {"section_id": 422, "quality": 1.0, "length": 13}, "so_3063341_3063401_0": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_3063341_3063341_0": {"section_id": 429, "quality": 1.0, "length": 8}, "so_3063341_3063401_2": {"section_id": 8701, "quality": 1.0, "length": 5}, "so_3063341_3063401_1": {"section_id": 8697, "quality": 0.875, "length": 7}}}, "45527379": {"ParentId": "3063341", "CommentCount": "0", "CreationDate": "2017-08-05T23:57:16.243", "OwnerUserId": "5212725", "PostTypeId": "2", "Id": "45527379", "Score": "0", "Body": "<p>Why would anyone ever want to call the destructor recursively in this way ? Once you have called the destructor, it should destroy the object. If you call it again, you would be trying to initiate the destruction of an already partly destroyed object when you were still actually part way through actually destroying it at the same time.</p>\n<p>All of the examples have some sort of decremental / incremental end condition, \nto essentially count down in calls, which is suggestive of some sort of failed implementation of a nested classs which contains members of the same type as itself. </p>\n<p>For such a nested matryoshka class, calling the destructor on the members, recursively, ie the destructor calls the destructor on member A, which in turn calls the destructor on its own member A, which in turn calls the detructor ... and so on is perfectly fine and works exactly as one might expect. This is a recursive use of the destructor, but it is <em>not</em> recursively calling the destructor on itself which is insane, and would make almost no sense.</p>\n", "LastActivityDate": "2017-08-05T23:57:16.243"}});