post_cb({"35805837": {"ViewCount": "317", "Body": "<p>According to <a href=\"http://www.complang.tuwien.ac.at/kps2015/proceedings/KPS_2015_submission_29.pdf\" rel=\"nofollow\">this interesting paper about undefined behavior optimization in c</a>, the expression <code>(x&lt;&lt;n)|(x&gt;&gt;32-n)</code> \"performs undefined behavior in C when n = 0\". <a href=\"https://stackoverflow.com/questions/3784996/why-does-left-shift-operation-invoke-undefined-behaviour-when-the-left-side-oper\">This stackoverflow discussion</a> confirms that the behavior is undefined for negative integers, and discusses some other potential pitfalls with left-shifting values.</p>\n<p>Consider the following code:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\nuint32_t rotl(uint32_t x, uint32_t n)\n{\n    return (x &lt;&lt; n) | (x &gt;&gt; (32 - n));\n}\n\nint main()\n{\n    uint32_t y = rotl(10, 0);\n    printf(\"%u\\n\", y);\n    return 0;\n}\n</code></pre>\n<p>Compile using the following parameters: <code>-O3 -std=c11 -pedantic -Wall -Wextra</code></p>\n<ul>\n<li>In gcc &gt;5.1.0 the output of the program is <code>10</code>.</li>\n<li>In clang &gt;3.7.0 the output is <code>4294967295</code>.</li>\n</ul>\n<p>Interestingly, this is still true when compiling with c++: <a href=\"https://ideone.com/rhJI51\" rel=\"nofollow\">gcc results</a>, <a href=\"https://ideone.com/n2IdfH\" rel=\"nofollow\">clang results</a>.</p>\n<p>Therefore, my questions are as follows:</p>\n<ol>\n<li>It is my understanding from the language in the standard that this should <strong>not</strong> invoke undefined / implementation defined behavior since both of the parameters are unsigned integers and none of the values are negative. Is this correct? If not, what is the relevant section of the standard for c11 and c++11?</li>\n<li>If the previous statement is true, which compiler is producing the correct output according to the c/c++ standard? Intuitively, left shifting by no digits should give you back the value, i.e. what gcc outputs.</li>\n<li>If the above is not the case, why are there no warnings that this code may invoke undefined behavior due to left-shift overflow?</li>\n</ol>\n", "AcceptedAnswerId": "35805912", "Title": "gcc and clang produce different outputs while left-shifting with unsigned values", "CreationDate": "2016-03-04T20:53:42.417", "Id": "35805837", "CommentCount": "0", "LastEditDate": "2016-03-04T21:08:05.703", "PostTypeId": "1", "LastEditorUserId": "4866991", "LastActivityDate": "2016-10-11T16:38:59.230", "Score": "3", "OwnerUserId": "4866991", "Tags": "<c++><c><language-lawyer><undefined-behavior>", "AnswerCount": "5"}, "39982331": {"Id": "39982331", "PostTypeId": "2", "Body": "<p>When the C Standard was written, some implementations would behave weirdly when trying to perform a shift by extremely large or negative amounts, e.g. left-shifting by -1 might tie up a CPU with interrupts disabled while its microcode shifts a value four billion times, and disabling interrupts for that long might cause other system faults.  Further, while few if any implementations would do anything particularly weird when shifting by exactly the word size, implementations weren't consistent about the value returned.  Some would treat it as a shift by zero, while others would yield the same result as shifting by one, word-size times, and some would sometimes do one and sometimes the other.</p>\n<p>If the authors of the Standard had specified that shifting by precisely the word size may select in Unspecified fashion between those two possible behaviors, that would have been useful, but the authors of the Standard weren't interested in specifying all the things that compilers would naturally do <em>with or without a mandate</em>.  I don't think they considered the idea that implementations for commonplace platforms wouldn't naturally yield the commonplace behavior for expressions like the \"rotate\" given above, and didn't want to clutter the Standard with such details.</p>\n<p>Today, however, some compiler writers think it's more important to exploit all forms of UB for \"optimization\" than to support useful natural behaviors which had previously been supported by essentially all commonplace implementations.  Whether or not making the \"rotate\" expression malfunction when y==0 would allow a compiler to generate a useful program which is smaller than would otherwise be possible is irrelevant.</p>\n", "LastActivityDate": "2016-10-11T16:38:59.230", "CommentCount": "0", "CreationDate": "2016-10-11T16:38:59.230", "ParentId": "35805837", "Score": "1", "OwnerUserId": "363751"}, "35805890": {"Id": "35805890", "PostTypeId": "2", "Body": "<p>Your <code>n</code> is <code>0</code>, so  performing <code>x &lt;&lt; 32</code> <em>is</em> an undefined behavior as shifting <code>uint32_t</code> 32 bits or more is undefined.</p>\n", "LastActivityDate": "2016-03-04T20:57:13.423", "CommentCount": "0", "CreationDate": "2016-03-04T20:57:13.423", "ParentId": "35805837", "Score": "2", "OwnerUserId": "4253229"}, "35807423": {"Id": "35807423", "PostTypeId": "2", "Body": "<p>A part of the post not fully answered.</p>\n<blockquote>\n<p id=\"so_35805837_35807423_0\">why are there no warnings that this code may invoke undefined behavior due to left-shift overflow?</p>\n</blockquote>\n<p>Looking at the <code>add()</code> code, what should the compiler warn about?   Is it UB if the sum is outside the range of <code>INT_MIN ... INT_MAX</code>.  Because the following code does not take precautions to prevent overflow, <a href=\"https://codereview.stackexchange.com/a/93699/29485\">like here</a>, should it warn?  Should you think so, then so much code would be waning about potential this and that, that programmers would quickly turn that warning off.</p>\n<pre><code>int add(int a, int b) {\n  return a + b;\n}\n</code></pre>\n<p>The situation is not much different here.  If <code>n &gt; 0 &amp;&amp; n &lt; 32</code>, there is no problem.</p>\n<pre><code>uint32_t rotl(uint32_t x, uint32_t n) {\n  return (x &lt;&lt; n) | (x &gt;&gt; (32 - n));\n}\n</code></pre>\n<p>C creates fast code primarily because it lacks lots of run-time error checking and compliers are able to perform very nice optimized code.  If one needs lots of run-time checks, there are other languages suitable for those programmers.</p>\n<p>C is coding without a net.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-03-04T22:43:17.763", "Score": "1", "CreationDate": "2016-03-04T22:43:17.763", "ParentId": "35805837", "CommentCount": "0", "OwnerUserId": "2410359", "LastEditDate": "2017-04-13T12:40:36.833"}, "35805882": {"Id": "35805882", "PostTypeId": "2", "Body": "<p>If <code>n</code> is 0, <code>32-n</code> is 32, and since <code>x</code> has 32 bits, <code>x&gt;&gt;(32-n)</code> is UB.</p>\n<p>The issue in the linked SO post is different. This one has nothing to do with signedness.</p>\n", "LastEditorUserId": "1566221", "LastActivityDate": "2016-03-04T21:00:46.347", "Score": "1", "CreationDate": "2016-03-04T20:56:36.123", "ParentId": "35805837", "CommentCount": "5", "OwnerUserId": "1566221", "LastEditDate": "2016-03-04T21:00:46.347"}, "bq_ids": {"n4140": {"so_35805837_35805912_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6146}}, "n3337": {"so_35805837_35805912_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 5909}}, "n4659": {"so_35805837_35805912_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7642}}}, "35805912": {"Id": "35805912", "PostTypeId": "2", "Body": "<p>From [expr.shift], emphasis mine:</p>\n<blockquote>\n<p id=\"so_35805837_35805912_0\">The behavior is undefined if the right operand\n  is negative, or <strong>greater than or equal to the length in bits of the promoted left operand</strong>.</p>\n</blockquote>\n<p>You are doing:</p>\n<pre><code>(x &gt;&gt; (32 - n))\n</code></pre>\n<p>with <code>n == 0</code>, so you're right-shifting a 32-bit number by 32. Hence, UB. </p>\n", "LastActivityDate": "2016-03-04T20:58:49.850", "CommentCount": "9", "CreationDate": "2016-03-04T20:58:49.850", "ParentId": "35805837", "Score": "7", "OwnerUserId": "2069064"}});