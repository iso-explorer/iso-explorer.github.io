post_cb({"8287197": {"ParentId": "8287010", "CommentCount": "0", "Body": "<p>If the compiler is optimizing away a visible effect of the constructor/destructor call, it is buggy. If it has no visible effect, then you shouldn't notice it anyway.</p>\n<p>However let's assume that somehow your constructor or destructor does have a visible effect (so construction and subsequent destruction of that object isn't effectively a no-op) in such a way that the compiler could legitimately think it wouldn't (not that I can think of such a situation, but then, it might be just a lack of imagination on my side). Then any of the following strategies should work:</p>\n<ul>\n<li><p>Make sure that the compiler cannot see the definition of the constructor and/or destructor. If the compiler doesn't know what the constructor/destructor does, it cannot assume it does not have an effect. Note, however, that this also disables inlining. If your compiler does not do cross-module optimization, just putting the constructor/destructor into a different file should suffice.</p></li>\n<li><p>Make sure that your constructor/destructor actually <em>does</em> have observable behaviour, e.g. through use of volatile variables (every read or write of a volatile variable is considered observable behaviour in C++).</p></li>\n</ul>\n<p>However let me stress again that it's very unlikely that you have to do anything, unless your compiler is horribly buggy (in which case I'd strongly advice you to change the compiler :-)).</p>\n", "OwnerUserId": "1032073", "PostTypeId": "2", "Id": "8287197", "Score": "0", "CreationDate": "2011-11-27T16:49:53.290", "LastActivityDate": "2011-11-27T16:49:53.290"}, "8287110": {"ParentId": "8287010", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_8287010_8287110_0\">However, according to an IRC channel that constructor/destructor call may be optimized away if the compiler <strong>thinks there's no side effect</strong> to the SomeClass constructors/destructors.</p>\n</blockquote>\n<p>The bolded part is <strong>wrong</strong>. That should be: <strong>knows</strong> there is <strong>no <em>observable behaviour</em></strong></p>\n<p>E.g. from \u00a7 1.9 of the latest standard (<em>there are more relevant quotes</em>):</p>\n<blockquote>\n<p id=\"so_8287010_8287110_1\">A conforming implementation executing a well-formed program shall produce the same observable behavior\n  as one of the possible executions of the corresponding instance of the abstract machine with the same program\n  and the same input. However, if any such execution contains an undefined operation, this International\n  Standard places no requirement on the implementation executing that program with that input (not even\n  with regard to operations preceding the first undefined operation).</p>\n</blockquote>\n<p>As a matter of fact, this whole mechanism underpins the sinlge most ubiquitous C++ language idiom: <strong><a href=\"http://en.wikibooks.org/wiki/C++_Programming/RAII\" rel=\"nofollow\">Resource Acquisition Is Initialization</a></strong></p>\n<p><strong><em>Backgrounder</em></strong></p>\n<p>Having the compiler optimize away the trivial case-constructors is <em>extremely</em> helpful. It is what allows iterators to compile down to exactly the same performance code as using raw pointer/indexers. </p>\n<p>It is also what allows a function object to compile down to the exact same code as inlining the function body.</p>\n<p>It is what makes C++11 lambdas <em>perfectly</em> optimal for simple use cases:</p>\n<pre><code>factorial = std::accumulate(begin, end, [] (int a,int b) { return a*b; });\n</code></pre>\n<p>The lambda compiles down to a functor object similar to</p>\n<pre><code>struct lambda_1\n{\n     int operator()(int a, int b) const \n     { return a*b; }\n};\n</code></pre>\n<p>The compiler sees that the constructor/destructor can be elided and the function body get's inlined. The end result is optimal <sup>1</sup></p>\n<hr>\n<h2>More (un)observable behaviour</h2>\n<p>The standard contains a very entertaining example to the contrary, to spark your imagination. </p>\n<blockquote>\n<p id=\"so_8287010_8287110_2\"><strong>\u00a7 20.7.2.2.3</strong></p>\n<p id=\"so_8287010_8287110_3\"><code>[ Note:</code> The use count updates caused by the temporary object construction and destruction are not\n  observable side effects, so the implementation may meet the effects (and the implied guarantees) via\n  different means, without creating a temporary. In particular, in the example:</p>\n<pre><code>shared_ptr&lt;int&gt; p(new int);\nshared_ptr&lt;void&gt; q(p);\np = p;\nq = p;\n</code></pre>\n<p id=\"so_8287010_8287110_4\">both assignments may be no-ops. <code>\u2014end note ]</code></p>\n</blockquote>\n<p>IOW: Don't underestimate the power of optimizing compilers. This in no way means that language guarantees are to be thrown out of the window!</p>\n<p><sup>1</sup> Though there could be faster <em>algorithms</em> to get a factorial, depending on the problem domain :)</p>\n</hr>", "OwnerUserId": "85371", "LastEditorUserId": "85371", "LastEditDate": "2011-11-27T17:50:05.160", "Id": "8287110", "Score": "7", "CreationDate": "2011-11-27T16:37:44.450", "LastActivityDate": "2011-11-27T17:50:05.160"}, "8287137": {"ParentId": "8287010", "CommentCount": "1", "Body": "<p>I'm sure is 'SomeClass::SomeClass()' is not implemented as 'inline', the compiler has no way of knowing that the constructor/destructor has no side effects, and it will call the constructor/destructor always. </p>\n", "OwnerUserId": "837803", "PostTypeId": "2", "Id": "8287137", "Score": "0", "CreationDate": "2011-11-27T16:42:33.853", "LastActivityDate": "2011-11-27T16:42:33.853"}, "bq_ids": {"n4140": {"so_8287010_8287110_1": {"section_id": 5801, "quality": 0.9736842105263158, "length": 37}, "so_8287010_8287110_4": {"section_id": 4416, "quality": 0.6666666666666666, "length": 4}, "so_8287010_8287110_3": {"section_id": 4416, "quality": 0.9230769230769231, "length": 24}}, "n3337": {"so_8287010_8287110_1": {"section_id": 5574, "quality": 0.9736842105263158, "length": 37}, "so_8287010_8287110_4": {"section_id": 4253, "quality": 0.6666666666666666, "length": 4}, "so_8287010_8287110_3": {"section_id": 4253, "quality": 0.9230769230769231, "length": 24}}, "n4659": {"so_8287010_8287110_1": {"section_id": 7260, "quality": 0.9736842105263158, "length": 37}, "so_8287010_8287110_3": {"section_id": 5675, "quality": 0.9230769230769231, "length": 24}, "so_8287010_8287110_4": {"section_id": 5675, "quality": 0.6666666666666666, "length": 4}}}, "8287010": {"CommentCount": "7", "ViewCount": "674", "CreationDate": "2011-11-27T16:23:53.433", "LastActivityDate": "2011-11-27T17:50:05.160", "Title": "C++: Calling a constructor to a temporary object", "AcceptedAnswerId": "8287110", "PostTypeId": "1", "Id": "8287010", "Score": "4", "Body": "<p>Suppose I have the following:</p>\n<pre><code>int main() {\n    SomeClass();\n    return 0;\n}\n</code></pre>\n<p>Without optimization, the SomeClass() constructor will be called, and then its destructor will be called, and the object will be no more.</p>\n<p>However, according to an IRC channel that constructor/destructor call may be optimized away if the compiler thinks there's no side effect to the SomeClass constructors/destructors.</p>\n<p>I suppose the obvious way to go about this is not to use some constructor/destructor function (e.g use a function, or a static method or so), but is there a way to ensure the calling of the constructors/destructors?</p>\n", "Tags": "<c++><optimization>", "OwnerUserId": "277941", "AnswerCount": "3"}});