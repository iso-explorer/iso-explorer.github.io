post_cb({"15385263": {"ParentId": "15385083", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2013-03-13T12:24:19.053", "Score": "3", "LastEditorUserId": "150634", "LastEditDate": "2013-03-13T12:41:35.657", "Id": "15385263", "OwnerUserId": "150634", "Body": "<p>In a typical C++ project, you compile each of the implementation (or <code>.cpp</code>) files separately - you generally never pass a header (or <code>.h</code>) file to the compiler directly. After all preprocessing and inclusions are performed, each of these files becomes a <em>translation unit</em>. So in the example you've given, there are two translation units that look like this:</p>\n<ul>\n<li><p><code>main.cpp</code> translation unit:</p>\n<pre><code>// Contents of &lt;iostream&gt; header here\n\nint myCoolFunction();\n\nint myAwesomeFunction() // Note implementing function in header\n{\n    return 3;\n}\n\nint main()\n{\n    std::cout &lt;&lt; myAwesomeFunction() &lt;&lt; std::endl;\n}\n</code></pre></li>\n<li><p><code>something.cpp</code> translation unit:</p>\n<pre><code>int myCoolFunction();\n\nint myAwesomeFunction() // Note implementing function in header\n{\n    return 3;\n}\n\nint myCoolFunction()\n{\n    return 4;\n}\n</code></pre></li>\n</ul>\n<p>Notice that both of these translation units contain duplicate content because they both included <code>something.h</code>. As you can see, only one of the above translation units contains a definition of <code>myCoolFunction</code>. That's good! However, they <em>both</em> contain a definition of <code>myAwesomeFunction</code>. That's bad!</p>\n<p>After the translation units are compiled separately, they are then linked to form the final program. There are certain rules about multiple declarations across translation units. One of those rules is (\u00a73.2/4):</p>\n<blockquote>\n<p id=\"so_15385083_15385263_0\">Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program; no diagnostic required.</p>\n</blockquote>\n<p>You have more than one definition of <code>myAwesomeFunction</code> across your program and so you are breaking the rules. That's why your code doesn't link correctly.</p>\n<p>You can think of it from the linker's perspective. After these two translation units are compiled, you have two object files. The linker's job is to connect the object files together to form the final executable. So it sees the call to <code>myAwesomeFunction</code> in <code>main</code> and tries to find a corresponding function definition in one of the object files. However, there are <em>two</em> definitions. The linker doesn't know which one to use so it just gives up.</p>\n<p>Now let's see what the translation units look like if you define <code>myAwesomeFunction</code> in <code>something.cpp</code>:</p>\n<ul>\n<li><p>Fixed <code>main.cpp</code> translation unit:</p>\n<pre><code>// Contents of &lt;iostream&gt; header here\n\nint myCoolFunction();\n\nint myAwesomeFunction();\n\nint main()\n{\n    std::cout &lt;&lt; myAwesomeFunction() &lt;&lt; std::endl;\n}\n</code></pre></li>\n<li><p>Fixed <code>something.cpp</code> translation unit:</p>\n<pre><code>int myCoolFunction();\n\nint myAwesomeFunction();\n\nint myCoolFunction()\n{\n    return 4;\n}\n\nint myAwesomeFunction()\n{\n    return 3;\n}\n</code></pre></li>\n</ul>\n<p>Now it's perfect. There is only one definition of <code>myAwesomeFunction</code> across the whole program now. When the linker sees the call to <code>myAwesomeFunction</code> in <code>main</code>, it knows <em>exactly</em> which function definition it should link it to.</p>\n", "LastActivityDate": "2013-03-13T12:41:35.657"}, "15385083": {"CommentCount": "3", "ViewCount": "108", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-03-13T12:16:59.207", "LastActivityDate": "2013-03-13T12:41:35.657", "Title": "How do I explain this LNK2005?", "AcceptedAnswerId": "15385263", "LastEditDate": "2017-05-23T12:21:05.887", "Id": "15385083", "Score": "4", "Body": "<p>So, someone came to me with a project that failed linking with the error LNK2005: symbol already defined in object (using Visual Studio 2010). In this case, I know <em>what</em> is wrong (and hence could point them to the correct solution), but I don't know <em>why</em> this is wrong on a level to give a good explanation about it (to prevent it happening again).</p>\n<pre><code>// something.h\n#ifndef _SOMETHING_H\n#define _SOMETHING_H\nint myCoolFunction();\n\nint myAwesomeFunction() // Note implementing function in header\n{\n    return 3;\n}\n#endif\n</code></pre>\n<p>-</p>\n<pre><code>// something.cpp\n#include \"something.h\"\nint myCoolFunction()\n{\n    return 4;\n}\n</code></pre>\n<p>-</p>\n<pre><code>// main.cpp\n#include &lt;iostream&gt;\n#include \"something.h\"\n\nint main()\n{\n    std::cout &lt;&lt; myAwesomeFunction() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This fails linking, and is fixed by putting myAwesomeFunction() into the .cpp and leaving a declaration in the .h.</p>\n<p>My understanding of how the linker works comes pretty much from <a href=\"http://blogs.msdn.com/b/oldnewthing/archive/2013/01/07/10382714.aspx\" rel=\"nofollow noreferrer\">here</a>. To my understanding, we are providing a symbol that is required in one place.</p>\n<p>I looked up the <a href=\"http://msdn.microsoft.com/en-us/library/72zdcz6f%28v=vs.80%29.aspx\" rel=\"nofollow noreferrer\">MSDN article on LNK2005</a>, which matches how I expect linkers to behave (provide a symbol more than once -&gt; linker is confused), but doesn't seem to cover this case (which means I'm not understanding something obvious about linking).</p>\n<p>Google and StackOverflow yield issues with people not including an <code>#ifndef</code> or <code>#pragma once</code> (which leads to multiple declarations of provided symbols)</p>\n<p><a href=\"https://stackoverflow.com/questions/10140973/lnk2005-already-defined-error\">A related question I found on this site</a> has the same problem, but the answer doesn't explain <em>why</em> we're getting this problem adequately to my level of understanding.</p>\n<p><strong>I have a problem, I know the solution, but I don't know why my solution works</strong></p>\n", "Tags": "<c++><linker><linker-errors>", "OwnerUserId": "1791084", "AnswerCount": "3"}, "15385161": {"ParentId": "15385083", "CommentCount": "0", "CreationDate": "2013-03-13T12:20:17.180", "OwnerUserId": "673730", "PostTypeId": "2", "Id": "15385161", "Score": "1", "Body": "<p>The linker is merely letting you know that you broke the <strong>one definition rule</strong>. This is a basic, well-documented rule of C++ - it isn't solved by using include guards or <code>#pragma once</code> directives, but, in case of a free function, by marking it <code>inline</code> or moving the implementation to a source file.</p>\n<p>When a non-inline method is implemented in a header, all translation units that include that header will <em>define</em> it. When the corresponding <code>.obj</code> files are linked together, the linker detects the same symbol is exported (and defined) multiple times, and complains.</p>\n<p>Moving the implementation to a <code>cpp</code> file effectively transforms your initial <em>definition</em> into a <em>declaration</em>.</p>\n", "LastActivityDate": "2013-03-13T12:20:17.180"}, "bq_ids": {"n4140": {"so_15385083_15385263_0": {"section_id": 7041, "quality": 1.0, "length": 12}}, "n3337": {"so_15385083_15385263_0": {"section_id": 6786, "quality": 1.0, "length": 12}}, "n4659": {"so_15385083_15385263_0": {"section_id": 8538, "quality": 1.0, "length": 12}}}, "15385212": {"ParentId": "15385083", "CommentCount": "1", "CreationDate": "2013-03-13T12:22:08.777", "OwnerUserId": "279313", "PostTypeId": "2", "Id": "15385212", "Score": "-2", "Body": "<p><code>myAwesomeFunction</code> is defined in two source files: <code>something.cpp</code> and <code>main.cpp</code>. Move its implementation to one of source files, or declare this function as static.</p>\n", "LastActivityDate": "2013-03-13T12:22:08.777"}});