post_cb({"bq_ids": {"n4140": {"so_21526752_39453523_6": {"length": 113, "quality": 0.6042780748663101, "section_id": 5348}}, "n3337": {"so_21526752_39453523_6": {"length": 97, "quality": 0.5187165775401069, "section_id": 5145}}, "n4659": {"so_21526752_39453523_6": {"length": 165, "quality": 0.8823529411764706, "section_id": 6773}}}, "39453523": {"Id": "39453523", "PostTypeId": "2", "Body": "<p>The Technical Specification <a href=\"http://wg21.link/p0245\" rel=\"nofollow noreferrer\">P0245 <em>Hexadecimal floating literals for C++</em></a> has been voted into C++17 at the ISO C++ Standards Committee in Jacksonville, Florida on February 2016.</p>\n<p>The language C99 also has this feature, and the C++ feature is compatible.</p>\n<p>However, as pointed by the <a href=\"https://stackoverflow.com/users/995714/l%c6%b0u-v%c4%a9nh-ph%c3%bac\">L\u01b0u V\u0129nh Ph\u00fac</a>'s comment, the syntax <code>0x011.1</code> is not part of the standard. The binary exponent is mandatory for hexadecimal floating-point literals. One reason is to avoid ambiguity of the trailing <code>F</code> within <code>0x011.1F</code>. Is it the hex digit <code>F</code> of the fractional part or the floating-suffix meaning <code>float</code>?<br>\nTherefore append <code>p</code> followed by a positive or negative decimal number, for example: <code>0x011.1p0</code>.</br></p>\n<p>See the more readable page <a href=\"http://en.cppreference.com/w/cpp/language/floating_literal\" rel=\"nofollow noreferrer\">floating literal page on cppreference.com</a>.</p>\n<blockquote>\n<p id=\"so_21526752_39453523_0\"><code>0x | 0X hex-digit-sequence</code><br>\n<code>0x | 0X hex-digit-sequence .</code><br>\n<code>0x | 0X hex-digit-sequence(optional) . hex-digit-sequence</code> </br></br></p>\n<p id=\"so_21526752_39453523_1\">Hexadecimal digit-sequence representing a whole number without a radix separator. The exponent is never optional for hexadecimal floating-point literals: <code>0x1ffp10</code>, <code>0X0p-1</code>, <code>0x1.p0</code>, <code>0xf.p-1</code>, <code>0x0.123p-1</code>, <code>0xa.bp10l</code></p>\n<p id=\"so_21526752_39453523_2\">The exponent syntax for hexadecimal floating-point literal has the form<br>\n<code>p | P exponent-sign(optional) digit-sequence</code></br></p>\n<p id=\"so_21526752_39453523_3\">exponent-sign, if present, is either + or -</p>\n<p id=\"so_21526752_39453523_4\">suffix, if present, is one of <code>f</code>, <code>F</code>, <code>l</code>, or <code>L</code>. The suffix determines the type of the floating-point literal:</p>\n<ul>\n<li>(no suffix) defines double</li>\n<li><code>f F</code> defines float</li>\n<li><code>l L</code> defines long double</li>\n</ul>\n</blockquote>\n<p>See also the current working draft C++17, chapter <strong>\u00a7 2.13.4 Floating literals</strong> on GitHub: <a href=\"https://github.com/cplusplus/draft/raw/master/papers/n4604.pdf\" rel=\"nofollow noreferrer\">https://github.com/cplusplus/draft/raw/master/papers/n4604.pdf</a></p>\n<blockquote>\n<p id=\"so_21526752_39453523_5\"><em>floating-literal:</em><br>\n    \u2003 <em>decimal-floating-literal</em><br>\n    \u2003 <em>hexadecimal-floating-literal</em><br>\n<em>decimal-floating-literal:</em><br>\n    \u2003 <em>fractional-constant exponent-part<sub>opt</sub> floating-suffix<sub>opt</sub></em><br>\n    \u2003 <em>digit-sequence exponent-part floating-suffix<sub>opt</sub></em><br>\n<em>hexadecimal-floating-literal:</em><br>\n    \u2003 <em>hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part floating-suffix<sub>opt</sub></em><br>\n    \u2003 <em>hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part floating-suffix<sub>opt</sub></em><br>\n<em>fractional-constant:</em><br>\n    \u2003 <em>digit-sequence<sub>opt</sub> . digit-sequence</em><br>\n    \u2003 <em>digit-sequence .</em><br>\n<em>hexadecimal-fractional-constant:</em><br>\n    \u2003 <em>hexadecimal-digit-sequence<sub>opt</sub> . hexadecimal-digit-sequence</em><br>\n    \u2003 <em>hexadecimal-digit-sequence .</em><br>\n<em>exponent-part:</em><br>\n    \u2003 <code>e</code> <em>sign<sub>opt</sub> digit-sequence</em><br>\n    \u2003 <code>E</code> <em>sign<sub>opt</sub> digit-sequence</em><br>\n<em>binary-exponent-part:</em><br>\n    \u2003 <code>p</code> <em>sign<sub>opt</sub> digit-sequence</em><br>\n    \u2003 <code>P</code> <em>sign<sub>opt</sub> digit-sequence</em><br>\n<em>sign:</em> one of<br>\n    \u2003 <code>+</code> <code>-</code><br>\n<em>digit-sequence:</em><br>\n    \u2003 <em>digit</em><br>\n    \u2003 <em>digit-sequence \u2019<sub>opt</sub> digit</em><br>\n<em>floating-suffix:</em> one of<br>\n    \u2003 <code>f</code> <code>l</code> <code>F</code> <code>L</code></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></p>\n<p id=\"so_21526752_39453523_6\"><sup>1</sup> A floating literal consists of an optional prefix specifying a base, an integer part, a radix point, a fraction part, an <code>e</code>, <code>E</code>, <code>p</code> or <code>P</code>, an optionally signed integer exponent, and an optional type suffix. The integer and fraction parts both consist of a sequence of decimal (base ten) digits if there is no prefix, or hexadecimal (base sixteen) digits if the prefix is <code>0x</code> or <code>0X</code>. The literal is a <em>decimal floating literal</em> in the former case and a <em>hexadecimal floating literal</em> in the latter case. Optional separating single quotes in a <em>digit-sequence</em> or <em>hexadecimal-\n  digit-sequence</em> are ignored when determining its value. [ <em>Example:</em> The literals <code>1.602\u2019176\u2019565e-19</code> and <code>1.602176565e-19</code> have the same value. \u2014 <em>end example</em> ] Either the integer part or the fraction part (not both) can be omitted. Either the radix point or the letter e or E and the exponent (not both) can be omitted from a decimal floating literal. The radix point (but not the exponent) can be omitted from a hexadecimal floating literal. The integer part, the optional radix point, and the optional fraction part, form the <em>significand</em> of the floating literal. In a decimal floating literal, the exponent, if present, indicates the power of 10 by which the significand is to be scaled. In a hexadecimal floating literal, the exponent indicates the power of 2 by which the significand is to be scaled. [ <em>Example:</em> The literals <code>49.625</code> and <code>0xC.68p+2</code> have the same value. \u2014 <em>end example</em> ] If the scaled value is in the range of representable values for its type, the result is the scaled value if representable, else the larger or smaller representable value nearest the scaled value, chosen in an implementation-defined manner.\n  The type of a floating literal is <code>double</code> unless explicitly specified by a suffix. The suffixes <code>f</code> and <code>F</code> specify <code>float</code>, the suffixes <code>l</code> and <code>L</code> specify <code>long double</code>. If the scaled value is not in the range of representable values for its type, the program is ill-formed.</p>\n</blockquote>\n<p>As <a href=\"https://stackoverflow.com/a/21526849/938111\">unwind</a> has advised, you can use <a href=\"http://en.cppreference.com/w/cpp/string/byte/strtof\" rel=\"nofollow noreferrer\"><code>strtof()</code></a>. The following snippet decodes Hexadecimal floating literals (without C++17):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n\nint main(int argc, char *argv[])\n{\n  if (argc != 2)\n  {\n    std::cout &lt;&lt;\"Usage: \"&lt;&lt; argv[0] &lt;&lt;\" 0xA.Bp-1  =&gt; Decode hexfloat\" \"\\n\";\n    return 1;\n  }\n\n  long double l;\n  double      d;\n  float       f;\n\n  std::cout &lt;&lt;\"Decode floating point hexadecimal = \"&lt;&lt; argv[1];\n  //std::istringstream(argv[1]) &gt;&gt; std::hexfloat &gt;&gt; d;\n  l = std::strtold(argv[1],NULL); if(errno == ERANGE) std::cout &lt;&lt; \"\\n\" \"std::strtold() range error\";\n  d = std::strtod (argv[1],NULL); if(errno == ERANGE) std::cout &lt;&lt; \"\\n\" \"std::strtod() range error\";\n  f = std::strtof (argv[1],NULL); if(errno == ERANGE) std::cout &lt;&lt; \"\\n\" \"std::strtod() range error\";\n\n  std::cout &lt;&lt;\"\\n\"  \"long double = \"&lt;&lt; std::defaultfloat &lt;&lt; l &lt;&lt;'\\t'&lt;&lt; std::hexfloat &lt;&lt; l\n            &lt;&lt;\"\\n\"  \"double      = \"&lt;&lt; std::defaultfloat &lt;&lt; d &lt;&lt;'\\t'&lt;&lt; std::hexfloat &lt;&lt; d\n            &lt;&lt;\"\\n\"  \"float       = \"&lt;&lt; std::defaultfloat &lt;&lt; f &lt;&lt;'\\t'&lt;&lt; std::hexfloat &lt;&lt; f &lt;&lt;'\\n';\n}\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-09-12T20:19:29.283", "Score": "5", "CreationDate": "2016-09-12T15:10:51.830", "ParentId": "21526752", "CommentCount": "0", "OwnerUserId": "938111", "LastEditDate": "2017-05-23T12:32:20.873"}, "21526849": {"Id": "21526849", "PostTypeId": "2", "Body": "<p>No, C++ doesn't support that for literals, it's not part of the standard.</p>\n<p>A non-portable solution is to use a compiler that adds this as an extension (<a href=\"http://gcc.gnu.org/onlinedocs/gcc/Hex-Floats.html\" rel=\"nofollow\">GCC does this</a>).</p>\n<p>A portable workaround is to parse them from string literals at runtime using e.g. <a href=\"http://en.cppreference.com/w/cpp/string/byte/strtof\" rel=\"nofollow\"><code>strtof()</code></a> or <code>strtod()</code> for <code>double</code>.</p>\n<p>As pointed out in a comment, you can also opt to store the constants in a C file. Doing so requires that you have access to a C99 compiler though, since hex float literals is a C99-level feature. Since environments with a new C++ compiler but without a C99 compiler (read: Visual Studio) are quite common, that might not be a workable solution.</p>\n", "LastEditorUserId": "28169", "LastActivityDate": "2015-01-22T06:49:18.293", "Score": "1", "CreationDate": "2014-02-03T11:58:57.603", "ParentId": "21526752", "CommentCount": "7", "OwnerUserId": "28169", "LastEditDate": "2015-01-22T06:49:18.293"}, "21526752": {"ViewCount": "1922", "Body": "<p>(C++) Is it possible to initialize a float variable with a hexademical float point value?</p>\n<p>something like so:</p>\n<p>'0x011.1' // wrong!</p>\n", "AcceptedAnswerId": "21526849", "Title": "Hexadecimal floating point literals in c++", "CreationDate": "2014-02-03T11:54:33.010", "Id": "21526752", "CommentCount": "2", "LastEditDate": "2014-02-03T17:14:04.443", "PostTypeId": "1", "LastEditorUserId": "139746", "LastActivityDate": "2016-09-12T20:19:29.283", "Score": "2", "OwnerUserId": "916140", "Tags": "<c++><floating-point><hex>", "AnswerCount": "2"}});