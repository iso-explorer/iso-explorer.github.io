post_cb({"bq_ids": {"n4140": {"so_48895505_48895604_1": {"length": 25, "quality": 0.8928571428571429, "section_id": 6100}, "so_48895505_48895604_3": {"length": 7, "quality": 0.875, "section_id": 6101}, "so_48895505_48895604_2": {"length": 53, "quality": 0.9137931034482759, "section_id": 6101}}, "n3337": {"so_48895505_48895604_3": {"length": 7, "quality": 0.875, "section_id": 5867}, "so_48895505_48895604_1": {"length": 22, "quality": 0.7857142857142857, "section_id": 5866}, "so_48895505_48895604_2": {"length": 53, "quality": 0.9137931034482759, "section_id": 5867}}, "n4659": {"so_48895505_48895604_3": {"length": 7, "quality": 0.875, "section_id": 7598}, "so_48895505_48895604_1": {"length": 25, "quality": 0.8928571428571429, "section_id": 7597}, "so_48895505_48895604_2": {"length": 53, "quality": 0.9137931034482759, "section_id": 7598}}}, "48895505": {"ViewCount": "65", "Body": "<p>According to <code>valgrind</code> the following code does <em>not</em> contain memory leaks:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;stdexcept&gt;\n\nnamespace {\n\nclass Foo {\n public:\n  Foo();\n};\n\nFoo::Foo() { throw std::runtime_error(\"This is an error\"); }\n\n}  // anonymous namespace\n\nint main(int argc, char* argv[]) {\n  try {\n    new Foo();\n  } catch (const std::exception&amp; aError) {\n    return -1;\n  }\n\n  return 0;\n}\n</code></pre>\n<p>Indeed. the result of <code>valgrind --leak-check=full</code> is:</p>\n<pre><code>==25913== Memcheck, a memory error detector\n==25913== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\n==25913== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info\n==25913== Command: ./test\n==25913== \n==25913== \n==25913== HEAP SUMMARY:\n==25913==     in use at exit: 0 bytes in 0 blocks\n==25913==   total heap usage: 4 allocs, 4 frees, 72,890 bytes allocated\n==25913== \n==25913== All heap blocks were freed -- no leaks are possible\n==25913== \n==25913== For counts of detected and suppressed errors, rerun with: -v\n==25913== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n</code></pre>\n<p>The program is compiled with <code>g++ (GCC) 7.3.0</code>.</p>\n<p><strong>Note:</strong> there is no leak even with <code>clang 5.0.1</code>.</p>\n<p><strong>Note:</strong> I checked the disassembly code and there is <code>delete</code> call.</p>\n<hr>\n<p><strong>My question:</strong> why this code does not produce memory leak? Is it really something specified in the standard (can you link?) or just autonomous compiler enhancement?</p>\n<hr>\n<p><strong>What I expect</strong>:</p>\n<pre><code>...\ncall operator new(unsigned long)\nmov rbx, rax\nmov rdi, rbx\ncall (anonymous namespace)::Foo::Foo()\n</code></pre>\n<p>The dynamic allocation happens, after the call to the constructor which throws producing leak.</p>\n</hr></hr>", "AcceptedAnswerId": "48895604", "Title": "No leak on thrown constructor", "CreationDate": "2018-02-20T22:51:14.997", "LastActivityDate": "2018-02-20T23:56:21.453", "CommentCount": "9", "LastEditDate": "2018-02-20T23:09:53.040", "PostTypeId": "1", "LastEditorUserId": "6040181", "Id": "48895505", "Tags": "<c++><memory-leaks>", "Score": "1", "OwnerUserId": "6040181", "ClosedDate": "2018-02-20T23:11:49.370", "AnswerCount": "1"}, "48895604": {"Id": "48895604", "PostTypeId": "2", "Body": "<p>In case the constructor throws an exception, the memory will not leak, because an allocator must deallocate the memory before passing the exception, if there is a appropriate deallocation function.</p>\n<p>According to the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf\" rel=\"nofollow noreferrer\">March 2017 Working Draft</a>:</p>\n<blockquote>\n<p id=\"so_48895505_48895604_0\"><strong>8.3.4 New [expr.new]</strong></p>\n<p id=\"so_48895505_48895604_1\">20 If the <em>new-expression</em> creates an object or an array of objects of class type, access and ambiguity control\n  are done for the allocation function, the deallocation function (15.5), and the constructor (15.1). If the\n  <em>new-expression</em> creates an array of objects of class type, the destructor is potentially invoked (15.4).</p>\n<p id=\"so_48895505_48895604_2\">21 If any part of the object initialization described above<sup>80</sup> terminates by throwing an exception and a suitable\n  deallocation function can be found, <strong>the deallocation function is called to free the memory</strong> in which the object\n  was being constructed, after which the exception continues to propagate in the context of the new-expression.\n  <strong>If no unambiguous matching deallocation function can be found, propagating the exception does not cause\n  the object\u2019s memory to be freed.</strong> [ Note: This is appropriate when the called allocation function does not\n  allocate memory; otherwise, it is likely to result in a memory leak. \u2014 end note ]</p>\n<p id=\"so_48895505_48895604_3\"><sup>80)</sup> This may include evaluating a <em>new-initializer</em> and/or calling a constructor</p>\n</blockquote>\n<p>Also, according to the <a href=\"https://isocpp.org/wiki/faq/exceptions#why-exceptions\" rel=\"nofollow noreferrer\">Exceptions FAQ in the C++ wiki</a>:</p>\n<blockquote>\n<p id=\"so_48895505_48895604_4\"><em>\u201cBut throwing an exception from a constructor invoked by <code>new</code> causes a memory leak!\u201d</em> Nonsense! That\u2019s an old-wives\u2019 tale caused by a bug in one compiler \u2013 and that bug was immediately fixed over a decade ago.</p>\n</blockquote>\n", "LastEditorUserId": "2909011", "LastActivityDate": "2018-02-20T23:56:21.453", "Score": "6", "CreationDate": "2018-02-20T23:00:55.480", "ParentId": "48895505", "CommentCount": "7", "OwnerUserId": "2909011", "LastEditDate": "2018-02-20T23:56:21.453"}});