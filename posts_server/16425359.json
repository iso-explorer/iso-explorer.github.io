post_cb({"16425359": {"CommentCount": "1", "AcceptedAnswerId": "16429114", "PostTypeId": "1", "LastEditorUserId": "1023390", "CreationDate": "2013-05-07T17:46:24.660", "LastActivityDate": "2013-05-07T22:00:30.280", "LastEditDate": "2013-05-07T18:19:44.980", "ViewCount": "882", "FavoriteCount": "1", "Title": "should std::vector honour alignof(value_type)?", "Id": "16425359", "Score": "7", "Body": "<p>If I define a simple type with a certain alignment requirement, shouldn't a <code>std::vector&lt;t&gt;</code> of said type honour the alignment <em>for every single element</em>?</p>\n<p>Consider the following example</p>\n<pre><code>typedef std::array&lt;double,3&gt; alignas(32) avx_point;\nstd::vector&lt;avx_point&gt; x(10);\nassert(!(std::ptrdiff_t(&amp;(x[0]))&amp;31) &amp;&amp;   // assert that x[0] is 32-byte aligned\n       !(std::ptrdiff_t(&amp;(x[1]))&amp;31));    // assert that x[1] is 32-byte aligned\n</code></pre>\n<p>I found that the alignment requirement is silently (without any warning) violated by clang 3.2 (with or without <code>-stdlib=libc++</code>), while gcc 4.8.0 issues a warning that it ignores the attributes on the template argument to <code>std::vector</code> (the intel compiler is too daft to understand <code>alignas</code>, but if I use <code>__declspec(align(32))</code> instead, it behaves like clang). Both create code that triggers the assert.</p>\n<p>So, is this correct behaviour or a bug of clang (and icpc) and an issue with gcc?</p>\n<p><strong>edit</strong>\nto answer a question raised in the comments: if I define </p>\n<pre><code>typedef typename std::aligned_storage&lt;sizeof (avx_point),\n                                      alignof(avx_point)&gt;::type avx_storage;\n</code></pre>\n<p>I get</p>\n<pre><code>sizeof (avx_storage) == 32;\nalignof(avx_storage) == 32;\n</code></pre>\n<p>but <code>std::vector&lt;avx_storage&gt;</code> still fails to align the first element (and hence all the others too) for clang and gcc (without warning this time). So there are apparently two issues with the implementations: first, that <code>std::allocator&lt;type&gt;</code> ignores any alignment requirements even for the first element (illegal?) and second, that no padding is applied to ensure alignment of subsequent elements.</p>\n", "Tags": "<c++><c++11><alignment><containers>", "OwnerUserId": "1023390", "AnswerCount": "1"}, "16429114": {"ParentId": "16425359", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2013-05-07T21:48:17.430", "Score": "3", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:32:09.900", "Id": "16429114", "OwnerUserId": "1137388", "Body": "<blockquote>\n<p id=\"so_16425359_16429114_0\">first, that std::allocator ignores any alignment requirements even for the first element (illegal?)</p>\n</blockquote>\n<p>I'm far from being an expert on allocators but it seems to me that, unfortunately, this is legal behaviour. More precisely, an allocator might ignore the requested alignment. Indeed, [allocator.requirements], 17.6.3.5/6 states:</p>\n<blockquote>\n<p id=\"so_16425359_16429114_1\">If the alignment associated with a specific over-aligned type is not supported by an allocator, instantiation\n  of the allocator for that type may fail. <strong>The allocator also may silently ignore the requested alignment</strong>.</p>\n</blockquote>\n<p>You can write your own allocator to give you aligned memory. I've done that before at my work but, unfortunately, for copyright reasons, I cannot disclose the code :-( All I can say, is the obvious thing: it was based on <code>_aligned_malloc</code> and <code>_aligned_free</code> (which are Microsoft extensions). Or you can Google for \"aligned allocator\" and a few options will come up, one of which is</p>\n<p><a href=\"https://gist.github.com/donny-dont/1471329\" rel=\"nofollow noreferrer\">https://gist.github.com/donny-dont/1471329</a></p>\n<p>I emphasize that I'm not the author of this aligned allocator and I've never used it.</p>\n<p><strong>Update</strong></p>\n<p>The aligned allocator above is for Visual Studio/Windows but it can be used as a base for implementing aligned allocators on other platforms. You can use the posix <a href=\"http://man7.org/linux/man-pages/man3/posix_memalign.3.html\" rel=\"nofollow noreferrer\"><code>memalign</code></a> family of functions or the C11 function <code>aligned_alloc</code>.</p>\n<p>See <a href=\"https://stackoverflow.com/questions/3839922/aligned-malloc-in-gcc\">this</a> post.</p>\n", "LastActivityDate": "2013-05-07T22:00:30.280"}, "bq_ids": {"n4140": {"so_16425359_16429114_1": {"section_id": 6297, "quality": 0.95, "length": 19}}, "n3337": {"so_16425359_16429114_1": {"section_id": 6054, "quality": 0.95, "length": 19}}, "n4659": {"so_16425359_16429114_1": {"section_id": 7805, "quality": 0.95, "length": 19}}}});