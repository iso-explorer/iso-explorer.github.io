post_cb({"9971774": {"ParentId": "9971559", "CommentCount": "0", "Body": "<p>Your question does not make sense.</p>\n<blockquote>\n<p id=\"so_9971559_9971774_0\">Why wouldn't the side effects be skipped (since the destructor is not called) and the program run normally just without side effects applied?</p>\n</blockquote>\n<p>They are skipped, because they would have been triggered by the destructor and it has not been called.</p>\n<p>My reading of:</p>\n<blockquote>\n<p id=\"so_9971559_9971774_1\">and any program that depends on the side e\ufb00ects produced by the destructor has unde\ufb01ned behavior.</p>\n</blockquote>\n<p>is simple, I view it in light of RAII. Example:</p>\n<pre><code>#include \"Object.hpp\"\n\nstruct Manager: private boost::noncopyable {\n  union Raw {\n    char _[sizeof(Object)];\n    Object o;\n  };\n  static Raw raw;\n\n  Manager() { new (raw.o) Object(); }\n  ~Manager() { raw.o.~Object(); }\n};\n</code></pre>\n<p>Now, if I allocate a <code>Manager</code>, forgets to destroy it, and allocates a new one, I am in a pinch for I am overwriting the storage of the first created <code>Object</code> with a second one even though it is still \"alive\". This is undefined behavior.</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "9971774", "Score": "1", "CreationDate": "2012-04-02T06:31:37.993", "LastActivityDate": "2012-04-02T06:31:37.993"}, "9972004": {"ParentId": "9971559", "CommentCount": "0", "Body": "<p>I believe this is put into the standard to allow for garbage collection. And to point out that C++ behaves differently that some other languages, by not calling destructors while collecting.</p>\n<p>It specifically says that storage can be reused without calling the destructors of the objects in that memory area. If the program <em>depends</em> on the destructors being run, it will not work as expected. </p>\n<p>If it <em>doesn't</em> depend on the destructors, all is fine.</p>\n", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "9972004", "Score": "1", "CreationDate": "2012-04-02T06:52:02.397", "LastActivityDate": "2012-04-02T06:52:02.397"}, "9971608": {"ParentId": "9971559", "CommentCount": "3", "Body": "<p>The important part is the first part of that paragraph (emphasis mine):</p>\n<blockquote>\n<p id=\"so_9971559_9971608_0\">A program may end the lifetime of any object by <strong>reusing the storage which the object occupies</strong> ...</p>\n</blockquote>\n<p>If you simply reuse the storage for an object whose destructor has <em>not</em> been called, then you get undefined behaviour. For example, the object could have started a thread, or registered a callback, or some other action where an external component might expect the object to still exist.</p>\n", "OwnerUserId": "893", "PostTypeId": "2", "Id": "9971608", "Score": "5", "CreationDate": "2012-04-02T06:09:40.607", "LastActivityDate": "2012-04-02T06:09:40.607"}, "9971559": {"CommentCount": "4", "ViewCount": "308", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-04-02T06:04:15.137", "LastActivityDate": "2012-04-02T07:57:23.240", "Title": "Why is not deleting an object that has a destructor with a side effect undefined behavior in C++11?", "FavoriteCount": "1", "LastEditDate": "2017-05-23T12:20:15.003", "Id": "9971559", "Score": "9", "Body": "<p><a href=\"https://stackoverflow.com/a/9921320/57428\">This answer</a> quotes C++11 Standard 3.8:</p>\n<blockquote>\n<p id=\"so_9971559_9971559_0\">if there is no explicit call to the destructor or if a delete-expression (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and any program that depends on the side e\ufb00ects produced by the destructor has unde\ufb01ned behavior.</p>\n</blockquote>\n<p>The part about the destructor not being called is clear. Now suppose the skipped destructor had a side effect that should have affected the program behavior.</p>\n<p>Why is the program behavior undefined now? Why wouldn't the side effects be skipped (since the destructor is not called) and the program run normally just without side effects applied?</p>\n", "Tags": "<c++><memory-leaks><c++11><destructor><undefined-behavior>", "OwnerUserId": "57428", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_9971559_9971774_1": {"section_id": 7192, "quality": 0.7142857142857143, "length": 5}, "so_9971559_9971559_0": {"section_id": 7192, "quality": 0.8333333333333334, "length": 15}, "so_9971559_9971608_0": {"section_id": 7192, "quality": 1.0, "length": 8}}, "n3337": {"so_9971559_9971774_1": {"section_id": 6936, "quality": 0.7142857142857143, "length": 5}, "so_9971559_9971559_0": {"section_id": 6936, "quality": 0.8333333333333334, "length": 15}, "so_9971559_9971608_0": {"section_id": 6936, "quality": 1.0, "length": 8}}, "n4659": {"so_9971559_9971774_1": {"section_id": 8701, "quality": 0.7142857142857143, "length": 5}, "so_9971559_9971559_0": {"section_id": 8701, "quality": 0.8333333333333334, "length": 15}, "so_9971559_9971608_0": {"section_id": 8701, "quality": 1.0, "length": 8}}}, "9972727": {"ParentId": "9971559", "CommentCount": "0", "Body": "<p>In this case, we do have a precise answer. The specific line was introduced to resolve <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1116\" rel=\"nofollow\">CWG 1116</a>, \"Aliasing of union members\".</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "9972727", "Score": "3", "CreationDate": "2012-04-02T07:57:23.240", "LastActivityDate": "2012-04-02T07:57:23.240"}});