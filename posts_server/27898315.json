post_cb({"27898511": {"ParentId": "27898315", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>According to the standard, copy constructors taking pointers don't exist:</p>\n<blockquote>\n<p id=\"so_27898315_27898511_0\"><code>[C++11: 12.8/2]</code>: A non-template constructor for class <code>X</code> is a copy constructor if its first parameter is of type <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code> or <code>const volatile X&amp;</code>, and either there are no other parameters or else all other parameters have default arguments (8.3.6). <em>[..]</em></p>\n</blockquote>\n<p>Pointers are not included because the whole point of references is to \"be\" aliases for objects, whereas pointers represent indirection. Without delving too far into esoteric details about language design, <a href=\"https://stackoverflow.com/a/26636769/560648\">it's a semantic distinction that makes a lot of sense when you consider the syntactic differences between them</a>.</p>\n<p>You can write any constructor you want, and it can take a pointer if you want it to, but it won't be a \"copy constructor\". It will be probably be really unclear and vague as to ownership semantics, and be unconventional, and be kind of weird, and that's why we don't do it.</p>\n<p>It's not unheard of, though; consider this constructor that was the only way to instantiate a file stream in C++ until just three and a bit years ago:</p>\n<pre><code> explicit basic_ifstream(const char* s, ios_base::openmode mode = ios_base::in);\n</code></pre>\n", "OwnerUserId": "560648", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:51:29.143", "Id": "27898511", "Score": "6", "CreationDate": "2015-01-12T09:11:30.157", "LastActivityDate": "2015-01-12T23:38:03.353"}, "27898486": {"ParentId": "27898315", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Technically, you could write a constructor that takes a pointer (although it's technically not a copy constructor in that case, based on the wording of the spec). However, this prevents you from using non-addressable results. Consider we have a big math class (multiprecision): </p>\n<pre><code>bigmath a = 14;\n\nbigmath answer(a * 3);\n</code></pre>\n<p>You can't take the address of the expression <code>a * 3</code>, so you still need a <code>const bigmath &amp;</code> version of the object.</p>\n<p>(As Bart says, it also ensures that the object is a \"proper object\", which isn't going to hurt either - but to me, the above is a stronger argument).</p>\n<p>I should perhaps add that the type(s) of constructors you choose to have for your object really depends on what the class does and represents. There are objects where a copy is definitely not \"good\", and there are other cases, like a <code>bigmath</code> class, where copy constructors are definitely a good thing. For a <code>bigmath</code> class, you'd probably also want a constructor that takes a long integer, a double and a string. In some cases, having a reference doesn't make sense. In some cases, having a const reference doesn't make sense. And in some cases, like I said, having a copy constructor doesn't make sense. </p>\n<p>Typically, you can convert a pointer <code>ptr</code> to a reference by adding a dereference <code>*ptr</code> operation. Since the compiler will take the address of that (so that it can pass the reference), it won't add any extra code to use that. But for convenience, if you have a class that you often have pointers to and that you want to make copies of, then it may indeed make sense to have a constructor that takes a pointer. I'm not entirely sure where that would be, of the top of my head.</p>\n", "OwnerUserId": "1919155", "LastEditorUserId": "1919155", "LastEditDate": "2015-01-12T09:27:31.073", "Id": "27898486", "Score": "4", "CreationDate": "2015-01-12T09:09:59.410", "LastActivityDate": "2015-01-12T09:27:31.073"}, "27898451": {"ParentId": "27898315", "CommentCount": "0", "Body": "<p>Passing by references ensures an actual object is passed to the copy constructor, whilst a pointer can have NULL value, and make the constructor fail.</p>\n", "OwnerUserId": "4228410", "PostTypeId": "2", "Id": "27898451", "Score": "3", "CreationDate": "2015-01-12T09:08:01.887", "LastActivityDate": "2015-01-12T09:08:01.887"}, "bq_ids": {"n4140": {"so_27898315_27898511_0": {"section_id": 451, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_27898315_27898511_0": {"section_id": 442, "quality": 0.8888888888888888, "length": 24}}, "n4659": {"so_27898315_27898511_0": {"section_id": 474, "quality": 0.8888888888888888, "length": 24}}}, "27898315": {"CommentCount": "2", "ViewCount": "3676", "CreationDate": "2015-01-12T08:59:47.850", "LastActivityDate": "2015-01-12T23:38:03.353", "Title": "Why can't we use pass by pointer in copy constructor in c++?", "FavoriteCount": "2", "PostTypeId": "1", "Id": "27898315", "Score": "0", "Body": "<p>I know the general syntax of copy constructor in c++ would take reference. \n   But, my doubt is what happens if we use pointer type instead of reference? Why don't we use pass by pointer mechanism in Copy constructor?\n   What are the major disadvantages in it?</p>\n", "Tags": "<c++><c++11><constructor><copy-constructor>", "OwnerUserId": "3956609", "AnswerCount": "3"}});