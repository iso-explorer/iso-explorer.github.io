post_cb({"15572705": {"CommentCount": "5", "ViewCount": "1023", "PostTypeId": "1", "LastEditorUserId": "636019", "LastActivityDate": "2013-03-22T20:45:15.220", "Body": "<p>I have some example code that is behaving differently under Visual C++ 2012 with the new C++11  headers than it used to under VC++ 2010.\nIt concerns what happens when you call the std::fmod function that you get when you include cmath, and when the arguments you pass are not doubles, but are rather classes that have an implicit conversion to double operator:</p>\n<pre><code>#include &lt;cmath&gt;\n\nclass Num {\ndouble d_;\npublic:\nNum(double d) : d_(d) {}\n\noperator double() const { return d_; }\n};\n\nint main(int argc, char* argv[]) {\nNum n1(3.14159265358979323846264338327950288419716939937510);\nNum n2(2.0);\n\ndouble result1 = fmod((double)n1, (double)n2);\ndouble result2 = fmod((float)n1, (float)n2);\ndouble result3 = fmod(n1, n2);\n\nif (result2==result1) std::cout &lt;&lt; \"fmod(double, double) returns the same as fmod(float,float)\" &lt;&lt; std::endl;\nif (result3==result1) std::cout &lt;&lt; \"fmod(Num, Num) returns the same as fmod(double,double)\" &lt;&lt; std::endl;\nif (result3==result2) std::cout &lt;&lt; \"fmod(Num, Num) returns the same as fmod(float,float)\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Rather to my surprise this calls the version of fmod that takes two floats, rather than the version of fmod that takes two doubles.</p>\n<p>So my question is, is this the correct behaviour given the C++ 11 standard? The only information I can find on the behaviour is in the cppreference.com documentation <a href=\"http://en.cppreference.com/w/cpp/numeric/math/fmod\" rel=\"nofollow\" title=\"here\">here</a>, which says (emphasis mine):</p>\n<blockquote>\n<p id=\"so_15572705_15572705_0\">If any argument has integral type, it is cast to double. If any other argument is long double, then the return type is long double, <strong>otherwise it is double</strong>.</p>\n</blockquote>\n<p>However the implementation in the Visual Studio header files would appear to implement \"otherwise it's a float\".</p>\n<p>Any one know what the intention is :-) ?</p>\n<p>Having run the example through an online c++11 version of GCC ( I don't have simple access to a recent copy of GCC otherwise) it would appear to be calling the \"double\" version of fmod, which is what I naively expect.</p>\n<p>For clarity, I am using </p>\n<blockquote>\n<p id=\"so_15572705_15572705_1\">Microsoft (R) C/C++ Optimizing Compiler Version 17.00.51106.1 for x86</p>\n</blockquote>\n<p>which is what comes with </p>\n<blockquote>\n<p id=\"so_15572705_15572705_2\">Microsoft Visual Studio Express 2012 for Windows Desktop Version 11.0.51106.01 Update 1</p>\n</blockquote>\n", "Title": "Different behaviour of fmod (and others) under c++11, in Visual Studio at least", "FavoriteCount": "1", "LastEditDate": "2013-03-22T20:45:15.220", "Id": "15572705", "Score": "10", "CreationDate": "2013-03-22T14:22:59.603", "Tags": "<c++><visual-c++><c++11><visual-studio-2012>", "OwnerUserId": "518627", "AnswerCount": "2"}, "15573599": {"ParentId": "15572705", "CommentCount": "0", "Body": "<p>As Christian has pointed out in his linked question and answer, this is the behavior a strict reading of the Standard calls for.</p>\n<p>However you can work around this for all versions quite easily:</p>\n<pre><code>Num fmod(const Num a, const Num b)\n{\n    const double cvt_a = a;\n    const double cvt_b = b;\n    return Num(fmod(cvt_a, cvt_b));\n}\n</code></pre>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "15573599", "Score": "0", "CreationDate": "2013-03-22T15:04:32.107", "LastActivityDate": "2013-03-22T15:04:32.107"}, "15573448": {"ParentId": "15572705", "LastEditDate": "2017-05-23T11:49:55.717", "CommentCount": "8", "CreationDate": "2013-03-22T14:57:01.627", "OwnerUserId": "743214", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "15573448", "Score": "5", "Body": "<p>This is related to <a href=\"https://stackoverflow.com/q/14295217/743214\">this question of mine</a>. The reason is, that in order to provide the additional overloads demanded by the standard (and quoted in your question) VS 2012 defines general function templates for all the 2-argument math functions. So you don't actually call <code>fmod(float, float)</code> but <code>fmod&lt;Num&gt;(Num, Num)</code> in the first place.</p>\n<p>The reason this templated function is preferred over the plain <code>double</code> version is, because the double version would require a user-defined conversion from <code>Num</code> to <code>double</code>, whereas the template version is directly instantiatable.</p>\n<p>But the actual fundamental type to call the <code>fmod</code> function for is then determined by this type trait from <code>&lt;xtgmath.h&gt;</code>:</p>\n<pre><code>template&lt;class _Ty&gt;\n    struct _Promote_to_float\n    {   // promote integral to double\n    typedef typename conditional&lt;is_integral&lt;_Ty&gt;::value,\n        double, _Ty&gt;::type type;\n    };\n\ntemplate&lt;class _Ty1,\n    class _Ty2&gt;\n    struct _Common_float_type\n    {   // find type for two-argument math function\n    typedef typename _Promote_to_float&lt;_Ty1&gt;::type _Ty1f;\n    typedef typename _Promote_to_float&lt;_Ty2&gt;::type _Ty2f;\n    typedef typename conditional&lt;is_same&lt;_Ty1f, long double&gt;::value\n        || is_same&lt;_Ty2f, long double&gt;::value, long double,\n        typename conditional&lt;is_same&lt;_Ty1f, double&gt;::value\n            || is_same&lt;_Ty2f, double&gt;::value, double,\n            float&gt;::type&gt;::type type;\n    };\n</code></pre>\n<p>What this does is check the promoted type <code>_Promote_to_float</code> (which in your case is again <code>Num</code>, because it only checks if its integral, which <code>Num</code> clearly isn't) to all the floating point types until it matches, which it doesn't and thus results in the else case of <code>float</code>.</p>\n<p>The reason for this erroneous behaviour is, that those additional math overloads were never meant to be provided for each and every type, but only for the builtin arithmetic types (and the ambigous standard wording is about to be fixed, as stated in my answer to the linked question). So in all this type deduction mechanic explained above VS 2012 assumes that the passed in types are either builtin integral types or, if not, then builtin floating point types, which of course fails for <code>Num</code>. So the actual problem is that VS provides too generic math functions whereas they should only provide overloads for builtin types (like properly done for the 1-argument functions already). As stated in the linked answer, I already filed a bug for this.</p>\n<p><strong>EDIT:</strong> <s>In fact (as you also realized) even if they would follow the currently ambigous standard wording and providing generic function templates was required, they should still have defined the actual promoted type of those generic arguments as <code>double</code> instead of <code>float</code>. But I think the actual problem here is that they completely ignore the possible presence of non-builtin types in this whole type conversion process (since for builtin types their logic works perfectly fine).</s></p>\n<p>But according to the current ambiguous standard wording (which is already planned for changing, though) in section <strong>26.8 [c.math]</strong> they are indeed correctly deducing the promoted type as <code>float</code> (per the 3rd case):</p>\n<blockquote>\n<p id=\"so_15572705_15573448_0\">there shall be additional overloads sufficient to ensure:</p>\n<ol>\n<li>If any argument corresponding to a double parameter has type long double, then all arguments corresponding to double parameters are\n  effectively cast to long double.</li>\n<li>Otherwise, if any argument corresponding to a double parameter has type double or an integer type, then all arguments corresponding to\n  double parameters are effectively cast to double.</li>\n<li>Otherwise, all arguments corresponding to double parameters are effectively cast to float.</li>\n</ol>\n</blockquote>\n", "LastActivityDate": "2013-03-22T15:20:51.143"}, "bq_ids": {"n4140": {"so_15572705_15573448_0": {"section_id": 3876, "quality": 1.0, "length": 5}, "so_15572705_15572705_0": {"section_id": 3876, "quality": 0.5625, "length": 9}}, "n3337": {"so_15572705_15573448_0": {"section_id": 3736, "quality": 1.0, "length": 5}, "so_15572705_15572705_0": {"section_id": 3736, "quality": 0.5625, "length": 9}}, "n4659": {"so_15572705_15572705_0": {"section_id": 4690, "quality": 0.625, "length": 10}, "so_15572705_15573448_0": {"section_id": 4690, "quality": 1.0, "length": 5}}}});