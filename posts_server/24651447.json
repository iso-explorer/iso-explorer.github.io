post_cb({"bq_ids": {"n4140": {"so_24651447_24651710_1": {"length": 10, "quality": 0.625, "section_id": 3291}}, "n3337": {"so_24651447_24651710_1": {"length": 10, "quality": 0.625, "section_id": 6895}}, "n4659": {"so_24651447_24651710_1": {"length": 10, "quality": 0.625, "section_id": 4053}}}, "24651447": {"ViewCount": "80", "Body": "<p>I have an old C code that I am rewriting in C++11. In the older C code (which is a console application) has a <code>struct</code> that is a global variable in the file TC.C; the struct in question is</p>\n<pre><code>typedef struct \n{\n   char* m_szTabName;         \n   char* m_szCWName;          \n   FILE* m_fpCWFile;          \n   double* m_dNatCost;        \n   double* m_dStateCost;      \n   double* m_dLocalCost;      \n   short m_nDateRanges;       \n   short m_sNumCodes;         \n   GTIME* m_gStart;           \n   GTIME* m_gEnd;             \n   short* m_sIcdVsn;          \n   short* m_sIcdEdn;          \n   MapRecord** m_tIcdMap;     \n   FileHeader m_tHdr;         \n   CodeHeader m_tDxTab;       \n   CodeHeader m_tPrTab;       \n   CCMatrixHeader m_tCCMatTab;\n   NeoHeader m_tNeoTab;       \n   DRGHeader m_tDRGTab;       \n   CCHeader m_tCCTab;         \n   CCExclHeader m_tCCExclTab; \n   LogicHeader m_tLogic;        \n   CodeRecord* m_tCodeRec;    \n   char* m_szLabStore;        \n} Grouper;\n</code></pre>\n<p>In the C code this <code>struct</code> is <em>not</em> initialised and is used as follows</p>\n<pre><code>#include \"tabcomp.h\"\n#include \"OtherHeaderFiles\"\n...\nGrouper tgLoc;\n...\nvoid main(int argc, char *argv[])\n{\n    FILE *fpOut, *fpIn;\n    ...\n    CreateCodeTable(fpIn, &amp;tgLoc.m_tDxTab, (int)DX_LAB);   \n    ...\n}\n</code></pre>\n<p>So the <code>Grouper tgLoc</code> does not get initialised and upon the call to <code>CreateCodeTable</code> the values in <code>tgLoc</code> are </p>\n<pre><code>tgLoc  Grouper:\n+       m_szTabName     0x00000000 &lt;NULL&gt; char *\n+       m_szCWName      0x00000000 &lt;NULL&gt; char *\n+       m_fpCWFile      0x00000000 &lt;NULL&gt; _iobuf *\n+       m_dNatCost      0x00000000 {???} double *\n+       m_dStateCost    0x00000000 {???} double *\n+       m_dLocalCost    0x00000000 {???} double *\n+       m_nDateRanges   0 short\n+       m_sNumCodes     0 short\n+       m_gStart        0x00000000 {???} long *\n+       m_gEnd          0x00000000 {???} long *\n+       m_sIcdVsn       0x00000000 {???} short *\n+       m_sIcdEdn       0x00000000 {???} short *\n+       m_tIcdMap       0x00000000 {???} TMapRec * *\n+       m_tHdr          {m_sCreateDate=0x00e80150 \"\" m_usRefID=0 m_cHiByte=0 '\\0' ...} FileHeader\n+       m_tDxTab        {m_ucCodeLen=0 '\\0' m_usNumHdr=0 m_usNumCodes=0 ...} CodeHeader\n+       m_tPrTab        {m_ucCodeLen=0 '\\0' m_usNumHdr=0 m_usNumCodes=0 ...} CodeHeader\n+       m_tCCMatTab     {m_ucNRow=0 '\\0' m_ucNCol=0 '\\0' m_cpCCMatrix=0x00000000 &lt;NULL&gt; } CCMatrixHeader\n+       m_tNeoTab       {m_usNumCodes=0 m_ucNeoVal=0x00000000 &lt;NULL&gt; } TNeoHdr\n+       m_tDRGTab       {m_usNumDRG=0 m_usNumBits=0 m_bBitVals=0x00000000 {???} ...} DRGHeader\n+       m_tCCTab        {m_usNumCodes=0 m_ucSep=0x00000000 &lt;NULL&gt; m_useCCRow=0x00000000 {???} } CCHeader\n+       m_tCCExclTab    {m_usNumCCHdr=0 m_usNumCCTail=0 m_usLowPDX=0x00000000 {???} ...} CCExclHeader\n+       m_tLogic        {wFldErr=0 wDefLen=0 wFldLen=0 ...} LogicHeader\n+       m_tCodeRec      0x00000000 &lt;NULL&gt; CodeRecord *\n+       m_szLabStore    0x00000000 &lt;NULL&gt; char *\n</code></pre>\n<p>Now, I have moved the code from the C application to a C++11 application. The code runs fine, but the value of <code>tgLoc</code> upon the call to <code>CreateCodeTable</code> is now </p>\n<pre><code>tgLoc Grouper:\n+       m_szTabName     0xcdcdcdcd &lt;Error reading characters of string.&gt; char *\n+       m_szCWName      0xcdcdcdcd &lt;Error reading characters of string.&gt; char *\n+       m_fpCWFile      0xcdcdcdcd {_ptr=??? _cnt=??? _base=??? ...} _iobuf *\n+       m_dNatCost      0xcdcdcdcd {???} double *\n+       m_dStateCost    0xcdcdcdcd {???} double *\n+       m_dLocalCost    0xcdcdcdcd {???} double *\n        m_nDateRanges   -12851 short\n        m_sNumCodes     -12851 short\n+       m_gStart        0xcdcdcdcd {???} long *\n+       m_gEnd          0xcdcdcdcd {???} long *\n+       m_sIcdVsn       0xcdcdcdcd {???} short *\n+       m_sIcdEdn       0xcdcdcdcd {???} short *\n+       m_tIcdMap       0xcdcdcdcd {???} MapRecord * *\n+       m_tHdr          {m_sCreateDate=0x27570cc0 \"\u00cd\u00cd\u00cd\u00cd\u00cd\u00cd... m_usRefID=52685 m_cHiByte=-51 '\u00cd' ...} FileHeader\n+       m_tDxTab        {m_ucCodeLen=205 '\u00cd' m_usNumHdr=52685 m_usNumCodes=52685 ...} CodeHeader\n+       m_tPrTab        {m_ucCodeLen=205 '\u00cd' m_usNumHdr=52685 m_usNumCodes=52685 ...} CodeHeader\n+       m_tCCMatTab     {m_ucNRow=205 '\u00cd' m_ucNCol=205 '\u00cd' m_cpCCMatrix=0xcdcdcdcd &lt;Error reading characters of string.&gt; } CCMatrixHeader\n+       m_tNeoTab       {m_usNumCodes=52685 m_ucNeoVal=0xcdcdcdcd &lt;Error reading characters of string.&gt; } NeoHeader\n+       m_tDRGTab       {m_usNumDRG=52685 m_usNumBits=52685 m_bBitVals=0xcdcdcdcd {???} ...} DRGHeader\n+       m_tCCTab        {m_usNumCodes=52685 m_ucSep=0xcdcdcdcd &lt;Error reading characters of string.&gt; m_useCCRow=0xcdcdcdcd {...} } CCHeader\n+       m_tCCExclTab    {m_usNumCCHdr=52685 m_usNumCCTail=52685 m_usLowPDX=0xcdcdcdcd {???} ...} CCExclHeader\n+       m_tLogic        {wFldErr=52685 wDefLen=52685 wFldLen=52685 ...} LogicHeader\n+       m_tCodeRec      0xcdcdcdcd {szCode=0xcdcdcdcd &lt;Error reading characters of string.&gt; ucFldNum=??? ucFldType=??? ...} CodeRecord *\n+       m_szLabStore    0xcdcdcdcd &lt;Error reading characters of string.&gt; char *\n</code></pre>\n<p>There is only a small amound of code before the call to <code>CreateCodeTable</code> and this does <em>not</em> initialise <code>tgLoc</code>, so my question is, why is the new code compiled under C++11 initialising differently to the older C code and how can I initialise the new code so that <code>tgLoc</code> contains the same values as the old code for it first use?</p>\n<p><em>I am aware that <code>0xCDCDCDCD</code> is a debugging value that comes from the bowels of the C runtime library. When you allocate a block of memory in a debug build, it's initialized to this spurious value in the hope of catching bugs. <code>0xCDCDCDCD</code> is non-NULL and is never a valid memory pointer. But this seems to be affecting the output of the <code>CreateCodeTable</code> method. i also don't understand why this value is being initialised like C when it is being compiled as C++11?</em> <a href=\"http://www.microsoft.com/msj/1198/c/c1198.aspx\" rel=\"nofollow\">Reference</a></p>\n<p>Thanks for your time.</p>\n", "AcceptedAnswerId": "24651710", "Title": "C Code and it C++ Translation Initializing Differently", "CreationDate": "2014-07-09T10:37:57.410", "Id": "24651447", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2014-07-10T08:06:46.423", "Score": "2", "OwnerUserId": "626442", "Tags": "<c><c++11><initialization>", "AnswerCount": "1"}, "24651710": {"Id": "24651710", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24651447_24651710_0\">So the Grouper tgLoc does not get initialised</p>\n</blockquote>\n<p><strong>Yes it is.</strong>  It's a a global and as such is initialized to 0, which is what you can see.  From 6.7.8 of the C 99 Draft Standard:</p>\n<blockquote>\n<p id=\"so_24651447_24651710_1\">10) If an object that has automatic storage duration is not initialized explicitly, its value is\n  indeterminate. If an object that has <em>static storage duration</em> is not initialized explicitly,\n  then:</p>\n<ul>\n<li>if it has pointer type, it is initialized to a null pointer;</li>\n<li>if it has arithmetic type, it is initialized to (positive or unsigned) zero;</li>\n<li>if it is an aggregate, every member is initialized (recursively) according to these rules;</li>\n<li>if it is a union, the first named member is initialized (recursively) according to these\n  rules.</li>\n</ul>\n</blockquote>\n<p>The rules determining what \"static storage duration\" are are spelled out in section 6.2, in this case 6.2.4.3, \"An object whose identifier is <em>declared with external or internal linkage</em> or with the\nstorage-class specifier static <em>has static storage duration</em>\".</p>\n<p>A file scope identifier <em>without</em> the keyword <code>static</code> (aka., a global) has <em>external</em> linkage.</p>\n<blockquote>\n<p id=\"so_24651447_24651710_2\">I have moved the code from the C application to a C++11 application. The code runs fine, but the value of tgLoc upon the call to CreateCodeTable is now</p>\n</blockquote>\n<p>Most likely because now it's really <em>not</em> initialized, and so contains pseudo-junk provided by the OS (or real junk, provided from RAM, or the debugging value you refer to).  This implies it is no longer a global (local variables have no linkage and thus \"automatic storage duration\", so are not implicitly initialized -- this applies in both C and C++). In any case, you can initialize to 0 with:</p>\n<pre><code>Grouper tgLoc = { 0 };\n</code></pre>\n<p>This applies to all members, not just the first one.  In C++, just <code>= { }</code> is fine.</p>\n<p>In case this is not clear: if you want a struct full of zeros, it must be initialized that way, either explicitly or <em>implicitly</em> as in the first case.</p>\n", "LastEditorUserId": "1151724", "LastActivityDate": "2014-07-10T08:06:46.423", "Score": "5", "CreationDate": "2014-07-09T10:51:16.793", "ParentId": "24651447", "CommentCount": "3", "OwnerUserId": "1151724", "LastEditDate": "2014-07-10T08:06:46.423"}});