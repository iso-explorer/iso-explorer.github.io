post_cb({"bq_ids": {"n4140": {"so_21294831_28722054_1": {"length": 33, "quality": 0.9428571428571428, "section_id": 3326}, "so_21294831_28722054_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 3299}}, "n3337": {"so_21294831_28722054_1": {"length": 33, "quality": 0.9428571428571428, "section_id": 3196}, "so_21294831_28722054_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 3169}}, "n4659": {"so_21294831_28722054_1": {"length": 33, "quality": 0.9428571428571428, "section_id": 4092}, "so_21294831_28722054_0": {"length": 17, "quality": 0.7391304347826086, "section_id": 4065}}}, "28722054": {"Id": "28722054", "PostTypeId": "2", "Body": "<p>Yes, because aggregate member initialization is sequenced.</p>\n<p><strong>[dcl.init.aggr]</strong>/2 has:</p>\n<blockquote>\n<p id=\"so_21294831_28722054_0\">When an aggregate is initialized by an <em>initializer list</em>, as specified in 8.5.4, the elements of the initializer list\n  are taken as initializers for the members of the aggregate, in increasing subscript or member order. Each\n  member is copy-initialized from the corresponding <em>initializer-clause</em>.</p>\n</blockquote>\n<p><strong>[dcl.init.list]</strong>/4 has:</p>\n<blockquote>\n<p id=\"so_21294831_28722054_1\">Within the <em>initializer-list</em> of a <em>braced-init-list</em>, the <em>initializer-clauses</em>, including any that result from pack\n  expansions (14.5.3), are evaluated in the order in which they appear. That is, every value computation and\n  side effect associated with a given <em>initializer-clause</em> is sequenced before every value computation and side\n  effect associated with any <em>initializer-clause</em> that follows it in the comma-separated list of the <em>initializer-list</em>.</p>\n</blockquote>\n<p>The copy-initialization of an aggregate member is certainly a side effect (<strong>[intro.execution]</strong>/12), and must be \"associated with\" the corresponding <em>initializer-clause</em>, because that is its <em>full-expression</em> (since an <em>initializer-list</em> is not an expression).</p>\n<p>Every up-to-date compiler I have tried (MSVC, Clang, g++) compiles this correctly. It may be possible that some older compilers get it wrong (older versions of g++ were known for getting the sequencing of aggregate initializers wrong).</p>\n", "LastActivityDate": "2015-02-25T14:48:48.070", "CommentCount": "2", "CreationDate": "2015-02-25T14:48:48.070", "ParentId": "21294831", "Score": "3", "OwnerUserId": "567292"}, "21294831": {"ViewCount": "91", "Body": "<pre><code>struct\n{\n    int a,b;\n} s = {5, s.a+1};\n</code></pre>\n<p>According to the standard, is it safe to read \"s.a\" in the above example, so that s is initialized to a=5 and b=6?  If so, do most compilers obey this rule?</p>\n<p>(The above compiles in VC10.)</p>\n", "AcceptedAnswerId": "28722054", "Title": "In a given place in an aggregate initialization list, are values passed into previous places safe to read from the corresponding members?", "CreationDate": "2014-01-22T21:56:25.387", "LastActivityDate": "2015-02-25T14:48:48.070", "CommentCount": "0", "LastEditDate": "2014-01-23T18:58:10.930", "PostTypeId": "1", "Tags": "<c++><aggregate-initialization>", "Id": "21294831", "AnswerCount": "1", "Score": "4", "OwnerUserId": "3225396", "ClosedDate": "2015-10-09T20:19:11.090", "LastEditorUserId": "3225396"}});