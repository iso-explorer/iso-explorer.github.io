post_cb({"bq_ids": {"n4140": {"so_48681552_48681552_1": {"length": 15, "quality": 0.625, "section_id": 3296}, "so_48681552_48696012_2": {"length": 42, "quality": 0.875, "section_id": 3296}, "so_48681552_48696012_5": {"length": 42, "quality": 0.875, "section_id": 3296}, "so_48681552_48681552_2": {"length": 42, "quality": 0.9130434782608695, "section_id": 3296}, "so_48681552_48681552_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 480}}, "n3337": {"so_48681552_48681552_1": {"length": 15, "quality": 0.625, "section_id": 3166}, "so_48681552_48681552_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 471}, "so_48681552_48681552_2": {"length": 42, "quality": 0.9130434782608695, "section_id": 3166}, "so_48681552_48696012_5": {"length": 42, "quality": 0.875, "section_id": 3166}, "so_48681552_48696012_2": {"length": 42, "quality": 0.875, "section_id": 3166}}, "n4659": {"so_48681552_48681552_1": {"length": 21, "quality": 0.875, "section_id": 4058}, "so_48681552_48696012_5": {"length": 42, "quality": 0.875, "section_id": 4058}, "so_48681552_48681552_2": {"length": 42, "quality": 0.9130434782608695, "section_id": 4058}, "so_48681552_48696012_2": {"length": 42, "quality": 0.875, "section_id": 4058}}}, "48696012": {"Id": "48696012", "PostTypeId": "2", "Body": "<p>As T.C. points out, this is in a similar vein to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2327\" rel=\"nofollow noreferrer\">CWG 2327</a>:</p>\n<blockquote>\n<p id=\"so_48681552_48696012_0\">Consider an example like:</p>\n<pre><code>struct Cat {};\nstruct Dog { operator Cat(); };\n\nDog d;\nCat c(d);\n</code></pre>\n<p id=\"so_48681552_48696012_1\">This goes to 11.6 [dcl.init] bullet 17.6.2:</p>\n<blockquote>\n<p id=\"so_48681552_48696012_5\">Otherwise, if the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified version of the source type is the same class as, or a derived class of, the class of the destination, constructors are considered. The applicable constructors are enumerated (16.3.1.3 [over.match.ctor]), and the best one is chosen through overload resolution (16.3 [over.match]). The constructor so selected is called to initialize the object, with the initializer expression or <em>expression-list</em> as its argument(s). If no constructor applies, or the overload resolution is ambiguous, the initialization is ill-formed.</p>\n</blockquote>\n<p id=\"so_48681552_48696012_3\">Overload resolution selects the move constructor of Cat. Initializing the <code>Cat&amp;&amp;</code> parameter of the constructor results in a temporary, per 11.6.3 [dcl.init.ref] bullet 5.2.1.2. This precludes the possitiblity of copy elision for this case.</p>\n<p id=\"so_48681552_48696012_4\">This seems to be an oversight in the wording change for guaranteed copy elision. We should presumably be simultaneously considering both constructors and conversion functions in this case, as we would for copy-initialization, but we'll need to make sure that doesn't introduce any novel problems or ambiguities.</p>\n</blockquote>\n<p>What makes this the same underlying problem is that we have an initializer (in OP, <code>{}</code>, in this example, <code>d</code>) that's the wrong type - we need to convert it to the right type (<code>X</code> or <code>Cat</code>), but to figure out how to do that, we need to perform overload resolution. This <em>already</em> gets us to the move constructor - where we're binding that rvalue reference parameter to a new object that we just created to make this happen. At this point, it's too late to elide the move. We're already there. We can't... back up, ctrl-z, abort abort, okay start over.</p>\n<p>As I mentioned in the comments, I'm not sure this was different in C++14 either. In order to evaluate <code>X x({})</code>, we have to construct an <code>X</code> that we're binding to the rvalue reference parameter of the move constructor - we can't elide the move at that point, the reference binding happens before we even know we're doing a move. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2018-03-01T19:15:16.877", "Score": "5", "CreationDate": "2018-02-08T22:45:08.020", "ParentId": "48681552", "CommentCount": "4", "OwnerUserId": "2069064", "LastEditDate": "2018-03-01T19:15:16.877"}, "48681552": {"ViewCount": "323", "Body": "<p>Consider the following:</p>\n<pre><code>struct X {\n    X() {}\n    X(X&amp;&amp;) { puts(\"move\"); }\n};\nX x = X();\n</code></pre>\n<p>In C++14, the move could be elided despite the fact that the move constructor has side effects thanks to [class.copy]/31,</p>\n<blockquote>\n<p id=\"so_48681552_48681552_0\">This elision of copy/move operations ... is permitted in the following circumstances ... when a temporary class object that has not been bound to a reference (12.2) would be copied/moved\n  to a class object with the same cv-unqualified type</p>\n</blockquote>\n<p>In C++17 this bullet was removed. Instead the move is guaranteed to be elided thanks to [dcl.init]/17.6.1:</p>\n<blockquote>\n<p id=\"so_48681552_48681552_1\">If the initializer expression is a prvalue and the cv-unqualified version of the source type is the same\n  class as the class of the destination, the initializer expression is used to initialize the destination\n  object. [ <em>Example:</em> <code>T x = T(T(T()));</code> calls the <code>T</code> default constructor to initialize <code>x</code>. \u2014 <em>end\n  example</em> ]</p>\n</blockquote>\n<p>Thus far the facts I've stated are well-known. But now let's change the code so that it reads:</p>\n<pre><code>X x({});\n</code></pre>\n<p>In C++14, overload resolution is performed and <code>{}</code> is converted to a temporary of type <code>X</code> using the default constructor, then moved into <code>x</code>. The copy elision rules allow this move to be elided.</p>\n<p>In C++17, the overload resolution is the same, but now [dcl.init]/17.6.1 doesn't apply and the bullet from C++14 isn't there anymore. There is no initializer expression, since the initializer is a braced-init-list. Instead it appears that [dcl.init]/(17.6.2) applies:</p>\n<blockquote>\n<p id=\"so_48681552_48681552_2\">Otherwise, if the initialization is direct-initialization, or if it is copy-initialization where the\n  cv-unqualified version of the source type is the same class as, or a derived class of, the class of the\n  destination, constructors are considered. The applicable constructors are enumerated (16.3.1.3),\n  and the best one is chosen through overload resolution (16.3). The constructor so selected is called\n  to initialize the object, with the initializer expression or expression-list as its argument(s). If no\n  constructor applies, or the overload resolution is ambiguous, the initialization is ill-formed.</p>\n</blockquote>\n<p>This appears to require the move constructor to be called, and if there's a rule elsewhere in the standard that says it's ok to elide it, I don't know where it is.</p>\n", "AcceptedAnswerId": "48696012", "Title": "Does C++17 forbid copy elision in a case where C++14 allowed it?", "CreationDate": "2018-02-08T09:07:53.840", "LastActivityDate": "2018-03-01T19:15:16.877", "CommentCount": "7", "LastEditDate": "2018-02-08T15:17:52.347", "PostTypeId": "1", "LastEditorUserId": "2069064", "Id": "48681552", "Score": "11", "OwnerUserId": "481267", "Tags": "<c++><language-lawyer><copy-elision><c++17>", "AnswerCount": "1"}});