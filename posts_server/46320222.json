post_cb({"46321012": {"ParentId": "46320222", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-09-20T11:36:51.827", "Score": "5", "LastEditorUserId": "6022656", "LastEditDate": "2017-09-20T12:06:42.617", "Id": "46321012", "OwnerUserId": "6022656", "Body": "<blockquote>\n<p id=\"so_46320222_46321012_0\">can i 'tell' the compiler they all can go to the same function(the one accepts A)?</p>\n</blockquote>\n<p>Yes, using SFINAE and <code>std::is_base_of</code></p>\n<pre><code>template &lt;typename T&gt;\ntypename std::enable_if&lt;std::is_base_of&lt;A, T&gt;::value, std::string&gt;::type\n      to_str (T const &amp; t)\n { return t.chr; }\n</code></pre>\n<p>The following is a full working example</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct A     { char const * chr; A() : chr{\"aaa\"} {} };\nstruct B : A { char const * chr; B() : chr{\"bbb\"} {} };\nstruct C     { char const * chr; C() : chr{\"ccc\"} {} };    \n\ntemplate &lt;typename T&gt;\ntypename std::enable_if&lt;std::is_base_of&lt;A, T&gt;::value, std::string&gt;::type\n      to_str (T const &amp; t)\n { return t.chr; }\n\nint main()\n {\n   A a;\n   B b;\n   C c;\n\n   std::cout &lt;&lt; to_str(a) &lt;&lt; std::endl;    // print aaa\n   std::cout &lt;&lt; to_str(b) &lt;&lt; std::endl;    // print bbb\n   // std::cout &lt;&lt; to_str(c) &lt;&lt; std::endl; // compilation error\n }\n</code></pre>\n", "LastActivityDate": "2017-09-20T12:06:42.617"}, "46320222": {"CommentCount": "5", "ViewCount": "78", "PostTypeId": "1", "LastEditorUserId": "6022656", "CreationDate": "2017-09-20T10:58:07.493", "LastActivityDate": "2017-09-20T12:35:43.727", "Title": "template specialization sub class", "LastEditDate": "2017-09-20T11:43:36.407", "Id": "46320222", "Score": "1", "Body": "<p>I have a problem that can be minimized to the following example</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n\nclass A{\n  public:\n    const char* chr;\n    A(){chr = \"aaa\";}\n};\n\nclass B : A{\n  public:\n    const char* chr;\n    B(){chr = \"bbb\";}\n};\n\ntemplate &lt;class T&gt;\nstd::string to_str(T) = delete;\n\ntemplate&lt;&gt;\ninline std::string\nto_str&lt;A&gt;(A object) {\n    std::string str;\n    return str.assign((object.chr));\n}\n\nint main() {\n  A a;\n  B b;\n  std::cout &lt;&lt; to_str(b) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>when changing it to <code>std::cout &lt;&lt; to_str(a) &lt;&lt; std::endl;</code> the code runs and prints '<code>aaa</code>', but like this, it stops at compilation and outputs </p>\n<pre><code>main.cpp: In function 'int main()':\nmain.cpp:30:24: error: use of deleted function 'std::__cxx11::string to_str(T) [with T = B; std::__cxx11::string = std::__cxx11::basic_string&lt;char&gt;]'\n   std::cout &lt;&lt; to_str(b) &lt;&lt; std::endl;\n                        ^\nmain.cpp:18:13: note: declared here\n std::string to_str(T) = delete;\n             ^~~~~~\n\nexit status 1\n</code></pre>\n<p>now lets say i have a lot of classes that inherit <code>A</code>, can i 'tell' the compiler they all can go to the same function (the one accepts <code>A</code>)?</p>\n<p>Thanks.</p>\n", "Tags": "<c++><c++11><templates><inheritance>", "OwnerUserId": "7034613", "AnswerCount": "4"}, "46321766": {"ParentId": "46320222", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2017-09-20T12:11:41.593", "Score": "1", "LastEditorUserId": "1774667", "LastEditDate": "2017-09-20T12:35:43.727", "Id": "46321766", "OwnerUserId": "1774667", "Body": "<p>Template function specialization does not work that way.  There is no overload resolution; it merely permits replacing a specific function body with specific template arguments with your specialized one.  It is rarely useful.</p>\n<p>What you want is overload resolution, possibly with tag dispatch.</p>\n<p>First remove this completely:</p>\n<pre><code>template &lt;class T&gt;\nstd::string to_str(T) = delete;\n</code></pre>\n<p>next, write an overload:</p>\n<pre><code>inline std::string to_str(A object) {\n  std::string str;\n  return str.assign((object.chr));\n}\n</code></pre>\n<p>and done.  Overload resolution dispatches <code>B</code> to the <code>A</code> overload.</p>\n<p>Your next problem is slicing.  <code>B</code> has <em>two</em> members named <code>chr</code>:  <code>A::chr</code> and <code>B::chr</code>.  For no good reason.  In addition you are needlessly copying <code>A</code> (or the <code>A</code> subobject of <code>B</code>).</p>\n<pre><code>inline std::string to_str(A const&amp; object) {\n  std::string str;\n  return str.assign((object.chr));\n}\n</code></pre>\n<p>this avoids a needless copy of <code>A</code>.</p>\n<pre><code>class A{\n  public:\n    const char* chr;\n    A(){chr = \"aaa\";}\n};\n\nclass B : public A{ // public, not private\n  public:\n    // const char* chr; // no need for this\n    B(){chr = \"bbb\";}\n};\n</code></pre>\n", "LastActivityDate": "2017-09-20T12:35:43.727"}, "46321263": {"ParentId": "46320222", "CommentCount": "2", "CreationDate": "2017-09-20T11:49:42.310", "OwnerUserId": "6864400", "PostTypeId": "2", "Id": "46321263", "Score": "-3", "Body": "<blockquote>\n<p id=\"so_46320222_46321263_0\">According to 14.7.3 [temp.expl.spec] paragraph 1, only non-deleted function templates may be explicitly specialized</p>\n</blockquote>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#941\" rel=\"nofollow noreferrer\">C++ Standard Core Language Defect Reports and Accepted Issues, Revision 97</a></p>\n<p>So, if you change </p>\n<pre><code>template &lt;class T&gt;\nstd::string to_str(T) = delete;\n</code></pre>\n<p>in, for example,</p>\n<pre><code>template &lt;class T&gt;\nstd::string to_str(T) { return \"\"; }\n</code></pre>\n<p>everything should work</p>\n", "LastActivityDate": "2017-09-20T11:49:42.310"}, "46321739": {"ParentId": "46320222", "CommentCount": "0", "CreationDate": "2017-09-20T12:10:37.367", "OwnerUserId": "27678", "PostTypeId": "2", "Id": "46321739", "Score": "1", "Body": "<p>I question if this really is a minimized example of your problem. I think that what's happened is that some important details got lost in the translation, because the code you've shown us here has a number of issues.</p>\n<ol>\n<li><code>B</code> inherits privately from <code>A</code>. There is no way we can really treat a <code>B</code> like an <code>A</code> in this case. </li>\n</ol>\n<p>If you changed inheritance to <code>public</code>, then we could attempt to force a <code>B</code> in like so:</p>\n<pre><code>class B : public A{/*...*/};\n// ...\nstd::cout &lt;&lt; to_str(*static_cast&lt;A*&gt;(&amp;b)) &lt;&lt; std::endl;\n</code></pre>\n<p>But the output will remain \"aaa\", which leads me to my next points</p>\n<ol start=\"2\">\n<li><p>Your <code>to_str</code> specialization for <code>A</code> accepts by <em>value</em>. This is important because even if we wanted to force a <code>B</code> in, we end up <em>slicing</em> the object, this matters because</p></li>\n<li><p><code>B</code> redefines the <code>const char* chr</code> effectively <em>hiding</em> <code>A::chr</code>, and since we've sliced, there's no way to recover <code>B</code>'s <code>chr</code>.</p></li>\n</ol>\n<p>We could start fixing things but first fixing the <em>slicing</em> by accepting <code>A</code> by <em>reference</em> instead (or <code>const</code> reference), and <em>always</em> preferring an overload instead of a template specialization for a function:</p>\n<pre><code>std::string to_str(A&amp; object) {/*...*/}\n</code></pre>\n<ol start=\"4\">\n<li>The next problem is that there is no way direct to recover <code>B</code>'s <code>chr</code> from an instance of <code>A</code>. We could go one of two ways here.\n\n<ol>\n<li>Use a <code>std::string</code> member in <code>A</code> and <em>do not redeclare it in any derived class</em>, then derived classes can set it on initialization.</li>\n</ol></li>\n</ol>\n<p>Example:</p>\n<pre><code>class A{\n  public:\n    std::string chr;\n    A():chr{\"aaa\"}{}\n};\n\nclass B : public A{\n  public:\n    B(){chr = \"bbb\";}\n};  \n</code></pre>\n<ol start=\"2\">\n<li>We write a <code>virtual const char* get_char()</code> method in <code>A</code> that derived classes can override.</li>\n</ol>\n<p>Example:</p>\n<pre><code>class A{\n  public:\n    const char* chr;\n    A(){chr = \"aaa\";}\n    virtual const char* get_chr() const{return chr;}\n};\n\nclass B : public A{\n  public:\n    const char* chr;\n    B(){chr = \"bbb\";}\n    const char* get_chr() const override {return chr;}\n};\n\ntemplate &lt;class T&gt;\nstd::string to_str(T) = delete;\n\nstd::string to_str(A&amp; object) {\n    std::string str;\n    return str.assign((object.get_chr()));\n// ...\nstd::cout &lt;&lt; to_str(*static_cast&lt;A*&gt;(&amp;b)) &lt;&lt; std::endl;\n</code></pre>\n<p>Note that at this point we're still forcing each <code>B</code> to be an <code>A</code>, which leads me to my next point</p>\n<ol start=\"5\">\n<li><p><code>template &lt;class T&gt; std::string to_str(T) = delete;</code> will always exactly match every type you don't explicitly specialize for, being preferred in the worst case and causing ambiguity in the best case.</p>\n<p>If you don't have any control over this function, then we're stuck with what we've got. However, if we <em>do</em>, then we can achieve what we need using <code>type_traits</code> to accept anything that is derived from <code>A</code>.</p></li>\n</ol>\n<p>In this way we can keep your private inheritance, and also keep your redeclared <code>chr</code> member, while simultaneously disabling <code>to_str</code> for everything else <em>and</em> not requiring we <code>static_cast</code> our <code>b</code>.</p>\n<p>Example:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nclass A{\n  public:\n    const char* chr;\n    A(){chr = \"aaa\";}\n};\n\nclass B : A{\n  public:\n    const char* chr;\n    B(){chr = \"bbb\";}\n};\n\ntemplate&lt;class T, class = std::enable_if_t&lt;std::is_base_of&lt;A, T&gt;::value, int&gt;&gt;\ninline std::string to_str(T&amp; object) {\n    std::string str;\n    return str.assign((object.chr));\n}\n\nint main() {\n  A a;\n  B b;\n  std::cout &lt;&lt; to_str(b) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Overall, I think that the best approach would be to give <code>A</code> a <code>protected std::string chr</code> that each derived class sets on initialization, and then have your <code>to_string</code> function that is specialized for <code>A&amp;</code> (as an <strong>overload</strong>) print that member.</p>\n<hr>\n<p>Edit: I forgot one last note. Issue #6: There are no <code>virtual</code> members in <code>A</code>. Therefore you will never be able to <code>dynamic_cast</code> a pointer to <code>A</code> to any derived class.</p>\n</hr>", "LastActivityDate": "2017-09-20T12:10:37.367"}, "bq_ids": {"n4140": {"so_46320222_46321012_0": {"section_id": 7210, "quality": 0.6, "length": 6}}, "n3337": {"so_46320222_46321012_0": {"section_id": 6954, "quality": 0.6, "length": 6}}, "n4659": {"so_46320222_46321012_0": {"section_id": 8719, "quality": 0.6, "length": 6}}}});