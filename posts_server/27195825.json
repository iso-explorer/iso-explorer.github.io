post_cb({"27205094": {"Id": "27205094", "PostTypeId": "2", "Body": "<p>What you are expecting to see is:</p>\n<pre><code>Construct 0x7fffa42d97ff         //  Creation of temporary object\nCopy construct 0xAAAAAAAAAA      //  copy constuction of parameter\nInside f\nDestruct 0xAAAAAAAAAA            // destruction of parameter.\nConstruct 0x7fffa42d97fe\nCopy construct 0xBBBBBBBBB\nInside f\nDestruct 0xBBBBBBBBB\nConstruct 0x7fffa42d97fd\nCopy construct 0xCCCCCCCCC\nInside f\nDestruct 0xCCCCCCCCC\nDestruct 0x7fffa42d97fd\nDestruct 0x7fffa42d97fe\nDestruct 0x7fffa42d97ff          // destruction of temporary\n</code></pre>\n<p>But the compiler is allowed to elide (remove) the copy construction of parameters (and their destructors) and inline the function. If you do this the only remaining objects that are constructed are the temporaries that are passed to the functions.</p>\n<p>So if you take my result set remove the copy construction (caused by aggressive compiler optimization) you are left with the output you see in your answer.</p>\n<p>If you want to see the output above. Then prevent the compiler from inlining the functions: See <a href=\"https://stackoverflow.com/a/1474050/14065\">https://stackoverflow.com/a/1474050/14065</a></p>\n<p>Note: In-lining is just one reason for the eliding the copy. The compiler can use a couple of others. I use the example on in-lining because it is the most easy to visualize the removal of the parameter being copied into the function.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-29T17:56:13.570", "Score": "2", "CreationDate": "2014-11-29T17:44:02.843", "ParentId": "27195825", "CommentCount": "9", "OwnerUserId": "14065", "LastEditDate": "2017-05-23T12:23:56.040"}, "27206105": {"Id": "27206105", "PostTypeId": "2", "Body": "<p>To elaborate from what by now can already be found in the comments:</p>\n<p>Given <code>int f(Logger);</code>, when you write:</p>\n<pre><code>f(10);\n</code></pre>\n<p>this (conceptually) constructs a temporary <code>Logger</code> object, constructs the function parameter from that temporary object, calls the function, destroys the function parameter, and finally destroys the temporary object.</p>\n<p>When you write:</p>\n<pre><code>f(f(10));\n</code></pre>\n<p>this (conceptually) constructs a temporary <code>Logger</code> object, constructs the function parameter from that temporary object, calls the function, destroys the function parameter, constructs a new temporary <code>Logger</code> object using the first function call's result, constructs the function parameter from <em>that</em> temporary object, calls the function, destroys the function parameter, and finally destroys the two temporary objects.</p>\n<p>I'll avoid writing it out for <code>f(f(f(10)));</code> case.</p>\n<p>Now, those two temporary objects can be omitted:</p>\n<blockquote>\n<p id=\"so_27195825_27206105_0\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the copy/move constructor and/or destructor for the object have side effects. In such cases, the implementation treats the source and target of the omitted copy/move operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization. This elision of copy/move\n  operations, called <em>copy elision</em>, is permitted in the following circumstances (which may be combined to eliminate multiple copies):</p>\n<ul>\n<li><p id=\"so_27195825_27206105_1\">...</p></li>\n<li><p id=\"so_27195825_27206105_2\">when a temporary class object that has not been bound to a reference (12.2) would be copied/moved to a class object with the same cv-unqualified type, the copy/move operation can be omitted by constructing the temporary object directly into the target of the omitted copy/move</p></li>\n<li><p id=\"so_27195825_27206105_3\">...</p></li>\n</ul>\n</blockquote>\n<p>Since the function parameter and the temporary object have the same type, a compiler is allowed to treat them as the same object. The temporary object would be destroyed at the final stage, so the lifetime of the parameter does not come into play.</p>\n<p>However, when copy elision <em>isn't</em> performed, for example because you configure the compiler not to, or because there is no copy to elide in the first place (see below), then the function parameters must indeed be destroyed when you say they should be, and you must see \"Destruct (...)\" before the second function invocation starts in all conforming C++11 implementations.</p>\n<p>A parameter can be constructed without a temporary by using braces: you could re-work the call as</p>\n<pre><code>f({f({f({10})})});\n</code></pre>\n<p>Here, each parameter is list-initialised, which in this case does not involve temporary objects, and there are no copies to elide. This <em>must</em> destroy the function parameters as soon as the function <code>f</code> returns, before <code>f</code> is called again, in all C++11-conforming implementations, regardless of any <code>-felide-constructors</code> command-line options, and the fact that compilers do not do this is an area in which they fail to conform to C++11.</p>\n<p>It's not <em>quite</em> as simple as that, though: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1880\" rel=\"nofollow\">CWG issue 1880</a> reads:</p>\n<blockquote>\n<p id=\"so_27195825_27206105_4\">WG decided to make it unspecified whether parameter objects are destroyed immediately following the call or at the end of the full-expression to which the call belongs.</p>\n</blockquote>\n<p>This would allow exactly what compilers do now: the parameters can be destroyed after the end of the full-expression, after the last <code>f</code> has returned. The exact literal text of C++11 isn't what current compilers implement.</p>\n", "LastEditorUserId": "743382", "LastActivityDate": "2014-11-29T22:23:17.073", "Score": "4", "CreationDate": "2014-11-29T19:23:54.690", "ParentId": "27195825", "CommentCount": "5", "OwnerUserId": "743382", "LastEditDate": "2014-11-29T22:23:17.073"}, "27195948": {"Id": "27195948", "PostTypeId": "2", "Body": "<p>It's correct behavior. It follows the First in, Last out method of destructing resources. If you had invoked the function in sequence you would get a different result.</p>\n<pre><code>f(10)\nf(10)\nf(10)\n</code></pre>\n<p>Would destruct like this:</p>\n<pre><code>Construct 0x7fffa42d97ff\nInside f\nDestruct 0x7fffa42d97ff\nConstruct 0x7fffa42d97fe\nInside f\nDestruct 0x7fffa42d97fe\nConstruct 0x7fffa42d97fd\nInside f\nDestruct 0x7fffa42d97fd\n</code></pre>\n", "LastActivityDate": "2014-11-28T21:12:03.543", "CommentCount": "1", "CreationDate": "2014-11-28T21:12:03.543", "ParentId": "27195825", "Score": "2", "OwnerUserId": "4019710"}, "bq_ids": {"n4140": {"so_27195825_27206105_0": {"length": 62, "quality": 0.96875, "section_id": 480}, "so_27195825_27206105_2": {"length": 26, "quality": 0.9629629629629629, "section_id": 480}, "so_27195825_27195825_0": {"length": 7, "quality": 0.875, "section_id": 5991}, "so_27195825_27195973_0": {"length": 14, "quality": 1.0, "section_id": 380}}, "n3337": {"so_27195825_27206105_0": {"length": 63, "quality": 0.984375, "section_id": 471}, "so_27195825_27206105_2": {"length": 26, "quality": 0.9629629629629629, "section_id": 471}, "so_27195825_27195825_0": {"length": 7, "quality": 0.875, "section_id": 5759}, "so_27195825_27195973_0": {"length": 14, "quality": 1.0, "section_id": 371}}, "n4659": {"so_27195825_27206105_0": {"length": 62, "quality": 0.96875, "section_id": 502}, "so_27195825_27206105_2": {"length": 17, "quality": 0.6296296296296297, "section_id": 502}, "so_27195825_27195825_0": {"length": 7, "quality": 0.875, "section_id": 7491}, "so_27195825_27195973_0": {"length": 14, "quality": 1.0, "section_id": 395}}}, "27195973": {"Id": "27195973", "PostTypeId": "2", "Body": "<p>See the C++11 Standard, \u00a712.2/3, saying</p>\n<blockquote>\n<p id=\"so_27195825_27195973_0\">Temporary objects are destroyed as the last step in evaluating the\n  <strong>full-expression</strong> (1.9) that (lexically) contains the point where they\n  were created.</p>\n</blockquote>\n", "LastEditorUserId": "36565", "LastActivityDate": "2014-11-28T21:23:58.867", "Score": "6", "CreationDate": "2014-11-28T21:14:33.967", "ParentId": "27195825", "CommentCount": "7", "OwnerUserId": "842658", "LastEditDate": "2014-11-28T21:23:58.867"}, "27195825": {"ViewCount": "680", "Body": "<p>I was pretty sure, that destructors for function's parameters should be called at the exit of corresponding function. Consider 5.2.2p4 of C++11 Standard:</p>\n<blockquote>\n<p id=\"so_27195825_27195825_0\">[...] The lifetime of a parameter ends when the function in which it is defined returns. [...]</p>\n</blockquote>\n<p>However, let's try this code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Logger {\n    Logger(int) { cout &lt;&lt; \"Construct \" &lt;&lt; this &lt;&lt; '\\n'; }\n    Logger(const Logger&amp;) { cout &lt;&lt; \"Copy construct \" &lt;&lt; this &lt;&lt; '\\n'; }\n    ~Logger() { cout &lt;&lt; \"Destruct \" &lt;&lt; this &lt;&lt; '\\n'; }\n};\n\nint f(Logger)\n{\n    cout &lt;&lt; \"Inside f\\n\";\n    return 0;\n}\n\nint main()\n{\n    f(f(f(10)));\n}\n</code></pre>\n<p>After compilation with gcc or clang, the output will be like this:</p>\n<pre class=\"lang-none prettyprint-override\"><code>Construct 0x7fffa42d97ff\nInside f\nConstruct 0x7fffa42d97fe\nInside f\nConstruct 0x7fffa42d97fd\nInside f\nDestruct 0x7fffa42d97fd\nDestruct 0x7fffa42d97fe\nDestruct 0x7fffa42d97ff\n</code></pre>\n<p>As we can see, all three parameters were destroyed only after the last function call was finished. Is this correct behaviour?</p>\n", "AcceptedAnswerId": "27206105", "Title": "Function parameters are not destroyed at that function's exit", "CreationDate": "2014-11-28T20:59:42.703", "Id": "27195825", "CommentCount": "24", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-11-28T21:19:55.020", "LastEditorDisplayName": "user3920237", "LastActivityDate": "2014-11-29T22:23:17.073", "Score": "14", "OwnerUserId": "4140624", "Tags": "<c++>", "AnswerCount": "4"}});