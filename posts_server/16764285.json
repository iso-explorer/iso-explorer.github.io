post_cb({"bq_ids": {"n4140": {"so_16764285_16764306_5": {"length": 42, "quality": 0.9767441860465116, "section_id": 161}, "so_16764285_16764306_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 603}, "so_16764285_16764306_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 603}, "so_16764285_16764306_3": {"length": 5, "quality": 1.0, "section_id": 111}, "so_16764285_16764306_2": {"length": 25, "quality": 0.9259259259259259, "section_id": 603}, "so_16764285_16764306_1": {"length": 6, "quality": 0.75, "section_id": 603}}, "n3337": {"so_16764285_16764306_5": {"length": 42, "quality": 0.9767441860465116, "section_id": 155}, "so_16764285_16764306_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 593}, "so_16764285_16764306_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 593}, "so_16764285_16764306_3": {"length": 5, "quality": 1.0, "section_id": 106}, "so_16764285_16764306_2": {"length": 25, "quality": 0.9259259259259259, "section_id": 593}, "so_16764285_16764306_1": {"length": 6, "quality": 0.75, "section_id": 593}}, "n4659": {"so_16764285_16764306_5": {"length": 42, "quality": 0.9767441860465116, "section_id": 165}, "so_16764285_16764306_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 629}, "so_16764285_16764306_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 629}, "so_16764285_16764306_3": {"length": 5, "quality": 1.0, "section_id": 115}, "so_16764285_16764306_2": {"length": 25, "quality": 0.9259259259259259, "section_id": 629}, "so_16764285_16764306_1": {"length": 6, "quality": 0.75, "section_id": 629}}}, "16764285": {"ViewCount": "187", "Body": "<p>The following code compiles fine with gcc and clang.</p>\n<pre><code>template &lt;typename T&gt;\nstruct identity\n{\n    typedef T type;\n};\n\ntemplate &lt;typename T&gt;\nvoid foo(typename identity&lt;T&gt;::type);\n\ntemplate &lt;typename T&gt;\nvoid foo(T);\n\nint main()\n{\n    foo&lt;int&gt;(0);\n}\n</code></pre>\n<p>It looks like overload resolution is choosing the first overload (the <code>identity&lt;T&gt;::type</code> one).</p>\n<p>Could someone explain why the overloads aren't ambiguous? As far as I can tell, the only difference between them is that the argument of the first one is a non-deduced context and the argument of the second one isn't, but since I'm providing the template argument explicitly, I don't see why that should matter.</p>\n", "AcceptedAnswerId": "16764306", "Title": "Why aren't these overloads ambiguous?", "CreationDate": "2013-05-26T22:29:18.783", "Id": "16764285", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-05-26T22:32:47.563", "Score": "7", "OwnerUserId": "141719", "Tags": "<c++><templates><overload-resolution><ambiguous-call>", "AnswerCount": "1"}, "16764306": {"Id": "16764306", "PostTypeId": "2", "Body": "<p>Both overloads are viable, but the former is <em>more specialized</em> than the latter, and therefore it gets picked by overload resolution.</p>\n<p>Per paragraph 13.3.3/1 of the C++11 Standard on overload resolution:</p>\n<blockquote>\n<p id=\"so_16764285_16764306_0\">[...] a viable function <code>F1</code> is defined to be a better function than another viable function\n  <code>F2</code> if for all arguments <code>i</code>, <code>ICSi(F1)</code> is not a worse conversion sequence than <code>ICSi(F2)</code>, and then</p>\n<p id=\"so_16764285_16764306_1\">\u2014 for some argument j, <code>ICSj(F1)</code> is a better conversion sequence than <code>ICSj(F2)</code>, or, if not that,</p>\n<p id=\"so_16764285_16764306_2\">\u2014 the context is an initialization by user-defined conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the\n  standard conversion sequence from the return type of F1 to the destination type (i.e., the type of the\n  entity being initialized) is a better conversion sequence than the standard conversion sequence from\n  the return type of <code>F2</code> to the destination type. [ ... ] or, if not that,</p>\n<p id=\"so_16764285_16764306_3\">\u2014 <code>F1</code> is a non-template function and <code>F2</code> is a function template specialization, or, if not that,</p>\n<p id=\"so_16764285_16764306_4\">\u2014 <strong><code>F1</code> and <code>F2</code> are function template specializations, and the function template for <code>F1</code> is more specialized\n  than the template for <code>F2</code> according to the partial ordering rules described in 14.5.6.2.</strong></p>\n</blockquote>\n<p>The process of determining which of two function templates is more specialized than the other is outlined in paragraph 14.5.6.2/2:</p>\n<blockquote>\n<p id=\"so_16764285_16764306_5\">Partial ordering selects which of two function templates is more specialized than the other by transforming\n  each template in turn (see next paragraph) and performing template argument deduction using the function\n  type. The deduction process determines whether one of the templates is more specialized than the other. If\n  so, the more specialized template is the one chosen by the partial ordering process.</p>\n</blockquote>\n", "LastActivityDate": "2013-05-26T22:32:47.563", "CommentCount": "2", "CreationDate": "2013-05-26T22:32:47.563", "ParentId": "16764285", "Score": "7", "OwnerUserId": "1932150"}});