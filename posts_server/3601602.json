post_cb({"38559710": {"Id": "38559710", "PostTypeId": "2", "Body": "<p>One addendum to the excellent answers above, on a point that confused me even after I had read Stroustrup and thought I understood the rvalue/lvalue distinction. When you see </p>\n<p><code>int&amp;&amp; a = 3</code>,</p>\n<p>it's very tempting to read the <code>int&amp;&amp;</code> as a type and conclude that <code>a</code> is an rvalue. It's not: </p>\n<pre><code>int&amp;&amp; a = 3;\nint&amp;&amp; c = a; //error: cannot bind 'int' lvalue to 'int&amp;&amp;'\nint&amp; b = a; //compiles\n</code></pre>\n<p><strong><code>a</code> has a name and is ipso facto an lvalue.</strong> Don't think of the <code>&amp;&amp;</code> as part of the type of <code>a</code>; it's just something telling you what <code>a</code> is allowed to bind to. </p>\n<p>This matters particularly for <code>T&amp;&amp;</code> type arguments in constructors. If you write </p>\n<p><code>Foo::Foo(T&amp;&amp; _t) : t{_t} {}</code></p>\n<p>you will copy <code>_t</code> into <code>t</code>. You need </p>\n<p><code>Foo::Foo(T&amp;&amp; _t) : t{std::move(_t)} {}</code> if you want to move. Would that my compiler warned me when I left out the <code>move</code>!</p>\n", "LastActivityDate": "2016-07-25T04:26:13.860", "CommentCount": "1", "CreationDate": "2016-07-25T04:26:13.860", "ParentId": "3601602", "Score": "9", "OwnerUserId": "1908650"}, "3601748": {"Body": "<blockquote>\n<p id=\"so_3601602_3601748_0\">What are these new categories of expressions?</p>\n</blockquote>\n<p>The <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2010/n3092.pdf\" rel=\"noreferrer\">FCD (n3092)</a> has an excellent description:</p>\n<blockquote>\n<p id=\"so_3601602_3601748_1\">\u2014 An lvalue (so called, historically, because lvalues could appear on the\n  left-hand side of an assignment\n  expression) designates a function or\n  an object. [ Example: If E is an\n  expression of pointer type, then\n  *E is an lvalue expression referring to the object or function to which E\n  points. As another example, the result\n  of calling a function whose return\n  type is an lvalue reference is an\n  lvalue. \u2014end example ] </p>\n<p id=\"so_3601602_3601748_2\">\u2014 An xvalue (an\n  \u201ceXpiring\u201d value) also refers to an\n  object, usually near the end of its\n  lifetime (so that its resources may be\n  moved, for example). An xvalue is the\n  result of certain kinds of expressions\n  involving rvalue references (8.3.2). [\n  Example: The result of calling a\n  function whose return type is an\n  rvalue reference is an xvalue. \u2014end\n  example ] </p>\n<p id=\"so_3601602_3601748_3\">\u2014 A glvalue (\u201cgeneralized\u201d\n  lvalue) is an lvalue or an xvalue.</p>\n<p id=\"so_3601602_3601748_4\">\u2014\n  An rvalue (so called, historically,\n  because rvalues could appear on the\n  right-hand side of an assignment\n  expressions) is an xvalue, a temporary\n  object (12.2) or subobject thereof, or\n  a value that is not associated with an\n  object.</p>\n<p id=\"so_3601602_3601748_5\">\u2014 A prvalue (\u201cpure\u201d rvalue) is\n  an rvalue that is not an xvalue. [\n  Example: The result of calling a\n  function whose return type is not a\n  reference is a prvalue. The value of a\n  literal such as 12, 7.3e5, or true is\n  also a prvalue. \u2014end example ]</p>\n<p id=\"so_3601602_3601748_6\">Every\n  expression belongs to exactly one of\n  the fundamental classifications in\n  this taxonomy: lvalue, xvalue, or\n  prvalue. This property of an\n  expression is called its value\n  category. [ Note: The discussion of\n  each built-in operator in Clause 5\n  indicates the category of the value it\n  yields and the value categories of the\n  operands it expects. For example, the\n  built-in assignment operators expect\n  that the left operand is an lvalue and\n  that the right operand is a prvalue\n  and yield an lvalue as the result.\n  User-defined operators are functions,\n  and the categories of values they\n  expect and yield are determined by\n  their parameter and return types. \u2014end\n  note</p>\n</blockquote>\n<p>I suggest you read the entire section <strong>3.10 Lvalues and rvalues</strong> though.</p>\n<blockquote>\n<p id=\"so_3601602_3601748_7\">How do these new categories relate to the existing rvalue and lvalue categories? </p>\n</blockquote>\n<p>Again: </p>\n<p><img alt=\"Taxonomy\" src=\"https://i.stack.imgur.com/GNhBF.png\"/></p>\n<blockquote>\n<p id=\"so_3601602_3601748_8\">Are the rvalue and lvalue categories in C++0x the same as they are in C++03?</p>\n</blockquote>\n<p>The semantics of rvalues has evolved particularly with the introduction of move semantics.</p>\n<blockquote>\n<p id=\"so_3601602_3601748_9\">Why are these new categories needed?</p>\n</blockquote>\n<p>So that move construction/assignment could be defined and supported.</p>\n", "CreationDate": "2010-08-30T15:18:36.363", "ParentId": "3601602", "CommentCount": "1", "LastEditDate": "2015-04-21T00:05:16.763", "Id": "3601748", "PostTypeId": "2", "LastActivityDate": "2015-04-21T00:05:16.763", "LastEditorUserId": "3109210", "CommunityOwnedDate": "2012-07-20T15:13:07.297", "Score": "280", "OwnerUserId": "66692"}, "bq_ids": {"n4140": {"so_3601602_3601748_3": {"length": 4, "quality": 0.8, "section_id": 7230}, "so_3601602_34901787_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 7230}, "so_3601602_3601748_1": {"length": 36, "quality": 0.9473684210526315, "section_id": 7230}, "so_3601602_3601748_2": {"length": 33, "quality": 0.868421052631579, "section_id": 7230}, "so_3601602_3601748_6": {"length": 56, "quality": 0.8888888888888888, "section_id": 7230}, "so_3601602_3601748_4": {"length": 18, "quality": 0.9, "section_id": 7230}, "so_3601602_3601748_5": {"length": 20, "quality": 0.8, "section_id": 7230}, "so_3601602_34901787_1": {"length": 5, "quality": 1.0, "section_id": 7230}}, "n3337": {"so_3601602_3601748_3": {"length": 4, "quality": 0.8, "section_id": 6974}, "so_3601602_34901787_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 6974}, "so_3601602_34901787_1": {"length": 5, "quality": 1.0, "section_id": 6974}, "so_3601602_3601748_2": {"length": 33, "quality": 0.868421052631579, "section_id": 6974}, "so_3601602_3601748_6": {"length": 56, "quality": 0.8888888888888888, "section_id": 6974}, "so_3601602_3601748_4": {"length": 18, "quality": 0.9, "section_id": 6974}, "so_3601602_3601748_5": {"length": 20, "quality": 0.8, "section_id": 6974}, "so_3601602_3601748_1": {"length": 36, "quality": 0.9473684210526315, "section_id": 6974}}, "n4659": {"so_3601602_3601748_6": {"length": 56, "quality": 0.8888888888888888, "section_id": 8741}, "so_3601602_3601748_3": {"length": 4, "quality": 0.8, "section_id": 7486}, "so_3601602_37872116_4": {"length": 5, "quality": 0.625, "section_id": 4053}, "so_3601602_34901787_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 8741}, "so_3601602_34901787_1": {"length": 5, "quality": 1.0, "section_id": 8741}}}, "3601964": {"Id": "3601964", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3601602_3601964_0\">How do these new categories relate to the existing rvalue and lvalue categories?</p>\n</blockquote>\n<p>A C++03 lvalue is still a C++11 lvalue, whereas a C++03 rvalue is called a prvalue in C++11.</p>\n", "LastEditorUserId": "5771029", "LastActivityDate": "2017-07-31T12:55:30.433", "Score": "14", "CreationDate": "2010-08-30T15:45:59.547", "ParentId": "3601602", "CommentCount": "0", "OwnerUserId": "252000", "LastEditDate": "2017-07-31T12:55:30.433"}, "37872116": {"Id": "37872116", "PostTypeId": "2", "Body": "<p>I have struggled with this for a long time, until I came across the cppreference.com explanation of the <a href=\"http://en.cppreference.com/w/cpp/language/value_category\">value categories</a>.</p>\n<p>It is actually rather simple, but I find that it is often explained in a way that's hard to memorize. Here it is explained very schematically. I'll quote some parts of the page:</p>\n<blockquote>\n<h3>Primary categories</h3>\n<p id=\"so_3601602_37872116_0\">The primary value categories correspond to two properties of expressions:</p>\n<ul>\n<li><p id=\"so_3601602_37872116_1\"><em>has identity</em>: it's possible to determine whether the expression refers to the same entity as another expression, such as by comparing addresses of the objects or the functions they identify (obtained directly or indirectly);</p></li>\n<li><p id=\"so_3601602_37872116_2\"><em>can be moved from</em>: move constructor, move assignment operator, or another function overload that implements move semantics can bind to the expression.</p></li>\n</ul>\n<p id=\"so_3601602_37872116_3\">Expressions that:</p>\n<ul>\n<li>have identity and cannot be moved from are called <em>lvalue expressions</em>;</li>\n<li>have identity and can be moved from are called <em>xvalue expressions</em>;</li>\n<li>do not have identity and can be moved from are called <em>prvalue expressions</em>;</li>\n<li>do not have identity and cannot be moved from are not used.</li>\n</ul>\n<h3>lvalue</h3>\n<p id=\"so_3601602_37872116_4\">An lvalue (\"left value\") expression is an expression that <em>has identity</em> and <em>cannot be moved from</em>. </p>\n<h3>rvalue (until C++11), prvalue (since C++11)</h3>\n<p id=\"so_3601602_37872116_5\">A prvalue (\"pure rvalue\") expression is an expression that <em>does not have identity</em> and <em>can be moved from</em>.</p>\n<h3>xvalue</h3>\n<p id=\"so_3601602_37872116_6\">An xvalue (\"expiring value\") expression is an expression that <em>has identity</em> and <em>can be moved from</em>.</p>\n<h3>glvalue</h3>\n<p id=\"so_3601602_37872116_7\">A glvalue (\"generalized lvalue\") expression is an expression that is either an lvalue or an xvalue. It <em>has identity</em>. It may or may not be moved from.</p>\n<h3>rvalue (since C++11)</h3>\n<p id=\"so_3601602_37872116_8\">An rvalue (\"right value\") expression is an expression that is either a prvalue or an xvalue. It <em>can be moved from</em>. It may or may not have identity.</p>\n</blockquote>\n", "LastActivityDate": "2016-06-17T02:20:32.997", "CommentCount": "1", "CreationDate": "2016-06-17T02:20:32.997", "ParentId": "3601602", "Score": "15", "OwnerUserId": "481061"}, "9552880": {"Id": "9552880", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3601602_9552880_0\">Why are these new categories needed? Are the WG21 gods just trying to confuse us mere mortals?</p>\n</blockquote>\n<p>I don't feel that the other answers (good though many of them are) really capture the answer to this particular question. Yes, these categories and such exist to allow move semantics, but the complexity exists for one reason. This is the one inviolate rule of moving stuff in C++11:</p>\n<p><strong>Thou shalt move only when it is unquestionably safe to do so.</strong></p>\n<p>That is why these categories exist: to be able to talk about values where it is safe to move from them, and to talk about values where it is not.</p>\n<p>In the earliest version of r-value references, movement happened easily. <em>Too</em> easily. Easily enough that there was a lot of potential for implicitly moving things when the user didn't really mean to.</p>\n<p>Here are the circumstances under which it is safe to move something:</p>\n<ol>\n<li>When it's a temporary or subobject thereof. (prvalue)</li>\n<li>When the user has <em>explicitly said to move it</em>.</li>\n</ol>\n<p>If you do this:</p>\n<pre><code>SomeType &amp;&amp;Func() { ... }\n\nSomeType &amp;&amp;val = Func();\nSomeType otherVal{val};\n</code></pre>\n<p>What does this do? In older versions of the spec, before the 5 values came in, this would provoke a move. Of course it does. You passed an rvalue reference to the constructor, and thus it binds to the constructor that takes an rvalue reference. That's obvious.</p>\n<p>There's just one problem with this; you didn't <em>ask</em> to move it. Oh, you might say that the <code>&amp;&amp;</code> should have been a clue, but that doesn't change the fact that it broke the rule. <code>val</code> isn't a temporary because temporaries don't have names. You may have extended the lifetime of the temporary, but that means it isn't <em>temporary</em>; it's just like any other stack variable.</p>\n<p>If it's not a temporary, and you didn't ask to move it, then moving is <em>wrong.</em></p>\n<p>The obvious solution is to make <code>val</code> an lvalue. This means that you can't move from it. OK, fine; it's named, so its an lvalue.</p>\n<p>Once you do that, you can no longer say that <code>SomeType&amp;&amp;</code> means the same thing everwhere. You've now made a distinction between named rvalue references and unnamed rvalue references. Well, named rvalue references are lvalues; that was our solution above. So what do we call unnamed rvalue references (the return value from <code>Func</code> above)?</p>\n<p>It's not an lvalue, because you can't move from an lvalue. And we <em>need</em> to be able to move by returning a <code>&amp;&amp;</code>; how else could you explicitly say to move something? That is what <code>std::move</code> returns, after all. It's not an rvalue (old-style), because it can be on the left side of an equation (things are actually a bit more complicated, see <a href=\"https://stackoverflow.com/questions/15482508/what-is-an-example-of-a-difference-in-allowed-usage-or-behavior-between-an-xvalu\">this question</a> and the comments below). It is neither an lvalue nor an rvalue; it's a new kind of thing.</p>\n<p>What we have is <strong>a value that you can treat as an lvalue, <em>except</em> that it is implicitly moveable from</strong>. We call it an <em><strong>xvalue</strong></em>.</p>\n<p>Note that xvalues are what makes us gain the other two categories of values: </p>\n<ul>\n<li><p>A <strong>prvalue</strong> is really just the new name for the previous type of rvalue, i.e. they're <strong>the rvalues that <em>aren't</em> xvalues</strong>. </p></li>\n<li><p>The <strong>glvalues is the union of xvalues and lvalues in one group</strong>, because they do share a lot of properties in common.</p></li>\n</ul>\n<p>So really, it all comes down to xvalues and the need to restrict movement to exactly and only certain places. Those places are defined by the rvalue category; prvalues are the implicit moves, and xvalues are the explicit moves (<code>std::move</code> returns an xvalue).</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-03-20T22:25:46.770", "Score": "117", "CreationDate": "2012-03-04T06:32:42.690", "ParentId": "3601602", "CommentCount": "9", "OwnerUserId": "734069", "LastEditDate": "2017-05-23T12:26:33.380"}, "34901787": {"Id": "34901787", "PostTypeId": "2", "Body": "<h2><strong>INTRODUCTION</strong></h2>\n<p>ISOC++11 (officially ISO/IEC 14882:2011) is the most recent version of the standard of the C++ programming language. It contains some new features, and concepts, for example:</p>\n<ul>\n<li>rvalue references</li>\n<li>xvalue, glvalue, prvalue expression value categories</li>\n<li>move semantics</li>\n</ul>\n<p>If we would like to understand the concepts of the new expression value categories we have to be aware of that there are rvalue and lvalue references.\nIt is better to know rvalues can be passed to non-const rvalue references.</p>\n<pre><code>int&amp; r_i=7; // compile error\nint&amp;&amp; rr_i=7; // OK\n</code></pre>\n<p>We can gain some intuition of the concepts of value categories if we quote the subsection titled Lvalues and rvalues from the working draft N3337 (the most similar draft to the published ISOC++11 standard).</p>\n<blockquote>\n<p id=\"so_3601602_34901787_0\"><strong>3.10 Lvalues and rvalues [basic.lval]</strong></p>\n<p id=\"so_3601602_34901787_1\">1 Expressions are categorized according to the taxonomy in Figure 1.</p>\n<ul>\n<li>An lvalue (so called, historically, because lvalues could appear on the left-hand side of an assignment expression) designates a function\n  or an object. [ Example: If E is an expression of pointer type, then\n  *E is an lvalue expression referring to the object or function to which E points. As another example, the result of calling a function\n  whose return type is an lvalue reference is an lvalue. \u2014end example ]</li>\n<li>An xvalue (an \u201ceXpiring\u201d value) also refers to an object, usually near the end of its lifetime (so that its resources may be moved, for\n  example). An xvalue is the result of certain kinds of expressions\n  involving rvalue references (8.3.2). [ Example: The result of calling\n  a function whose return type is an rvalue reference is an xvalue. \u2014end\n  example ]</li>\n<li>A glvalue (\u201cgeneralized\u201d lvalue) is an lvalue or an xvalue.</li>\n<li>An rvalue (so called, historically, because rvalues could appear on    the right-hand side of an assignment expression) is an xvalue, a<br>\n  temporary object (12.2) or subobject thereof, or a value that is not<br>\n  associated with an object.</br></br></li>\n<li>A prvalue (\u201cpure\u201d rvalue) is an rvalue that is not an xvalue. [    Example: The result of calling a function whose return type is not a<br>\n  reference is a prvalue. The value of a literal such as 12, 7.3e5, or<br>\n  true is also a prvalue. \u2014end example ]</br></br></li>\n</ul>\n<p id=\"so_3601602_34901787_2\">Every expression belongs to exactly one of the fundamental\n  classifications in this taxonomy: lvalue, xvalue, or prvalue. This\n  property of an expression is called its value category.</p>\n</blockquote>\n<p>But I am not quite sure about that this subsection is enough to understand the concepts clearly, because \"usually\" is not really general, \"near the end of its lifetime\" is not really concrete, \"involving rvalue references\" is not really clear, and \"Example: The result of calling a function whose return type is an rvalue reference is an xvalue.\" sounds like a snake is biting its tail.</p>\n<h2><strong>PRIMARY VALUE CATEGORIES</strong></h2>\n<p>Every expression belongs to exactly one primary value category. These value categories are lvalue, xvalue and prvalue categories.</p>\n<h2><strong>lvalues</strong></h2>\n<p><em>The expression E belongs to the lvalue category if and only if E refers to an entity that ALREADY has had an identity (address, name or alias) that makes it accessible outside of E.</em></p>\n<pre><code>#include &lt;iostream&gt;\n\nint i=7;\n\nconst int&amp; f(){\n    return i;\n}\n\nint main()\n{\n    std::cout&lt;&lt;&amp;\"www\"&lt;&lt;std::endl; // This address ...\n    std::cout&lt;&lt;&amp;\"www\"&lt;&lt;std::endl; // ... and this address are the same.\n    \"www\"; // The expression \"www\" in this row is an lvalue expression, because it refers to the same entity ...\n    \"www\"; // ... as the entity the expression \"www\" in this row refers to.\n\n    i; // The expression i in this row is an lvalue expression, because it refers to the same entity ...\n    i; // ... as the entity the expression i in this row refers to.\n\n    int* p_i=new int(7);\n    *p_i; // The expression *p_i in this row is an lvalue expression, because it refers to the same entity ...\n    *p_i; // ... as the entity the expression *p_i in this row refers to.\n\n    const int&amp; r_I=7;\n    r_I; // The expression r_I in this row is an lvalue expression, because it refers to the same entity ...\n    r_I; // ... as the entity the expression r_I in this row refers to.\n\n    f(); // The expression f() in this row is an lvalue expression, because it refers to the same entity ...\n    i; // ... as the entity the expression f() in this row refers to.\n\n    return 0;\n}\n</code></pre>\n<h2><strong>xvalues</strong></h2>\n<p><em>The expression E belongs to the xvalue category if and only if it is</em></p>\n<p><em>\u2014 the result of calling a function, whether implicitly or explicitly, whose return type is an rvalue reference to the type of object being returned, or</em></p>\n<pre><code>int&amp;&amp; f(){\n    return 3;\n}\n\nint main()\n{\n    f(); // The expression f() belongs to the xvalue category, because f() return type is an rvalue reference to object type.\n\n    return 0;\n}\n</code></pre>\n<p><em>\u2014 a cast to an rvalue reference to object type, or</em></p>\n<pre><code>int main()\n{\n    static_cast&lt;int&amp;&amp;&gt;(7); // The expression static_cast&lt;int&amp;&amp;&gt;(7) belongs to the xvalue category, because it is a cast to an rvalue reference to object type.\n    std::move(7); // std::move(7) is equivalent to static_cast&lt;int&amp;&amp;&gt;(7).\n\n    return 0;\n}\n</code></pre>\n<p><em>\u2014 a class member access expression designating a non-static data member of non-reference type in which the object expression is an xvalue, or</em></p>\n<pre><code>struct As\n{\n    int i;\n};\n\nAs&amp;&amp; f(){\n    return As();\n}\n\nint main()\n{\n    f().i; // The expression f().i belongs to the xvalue category, because As::i is a non-static data member of non-reference type, and the subexpression f() belongs to the xvlaue category.\n\n    return 0;\n}\n</code></pre>\n<p><em>\u2014 a pointer-to-member expression in which the first operand is an xvalue and the second operand is a pointer to data member.</em></p>\n<p>Note that the effect of the rules above is that named rvalue references to objects are treated as lvalues and unnamed rvalue references to objects are treated as xvalues; rvalue references to functions are treated as lvalues whether named or not.</p>\n<pre><code>#include &lt;functional&gt;\n\nstruct As\n{\n    int i;\n};\n\nAs&amp;&amp; f(){\n    return As();\n}\n\nint main()\n{\n    f(); // The expression f() belongs to the xvalue category, because it refers to an unnamed rvalue reference to object.\n    As&amp;&amp; rr_a=As();\n    rr_a; // The expression rr_a belongs to the lvalue category, because it refers to a named rvalue reference to object.\n    std::ref(f); // The expression std::ref(f) belongs to the lvalue category, because it refers to an rvalue reference to function.\n\n    return 0;\n}\n</code></pre>\n<h2><strong>prvalues</strong></h2>\n<p><em>The expression E belongs to the prvalue category if and only if E belongs neither to the lvalue nor to the xvalue category.</em></p>\n<pre><code>struct As\n{\n    void f(){\n        this; // The expression this is a prvalue expression. Note, that the expression this is not a variable.\n    }\n};\n\nAs f(){\n    return As();\n}\n\nint main()\n{\n    f(); // The expression f() belongs to the prvalue category, because it belongs neither to the lvalue nor to the xvalue category.\n\n    return 0;\n}\n</code></pre>\n<h2><strong>MIXED VALUE CATEGORIES</strong></h2>\n<p>There are two further important mixed value categories. These value categories are rvalue and glvalue categories.</p>\n<h2><strong>rvalues</strong></h2>\n<p><em>The expression E belongs to the rvalue category if and only if E belongs to the xvalue category, or to the prvalue category.</em></p>\n<p>Note that this definition means that the expression E belongs to the rvalue category if and only if E refers to an entity that has not had any identity that makes it accessible outside of E YET.</p>\n<h2><strong>glvalues</strong></h2>\n<p><em>The expression E belongs to the glvalue category if and only if E belongs to the lvalue category, or to the xvalue category.</em></p>\n<h2><strong>A PRACTICAL RULE</strong></h2>\n<p>Scott Meyer has <a href=\"https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers\">published</a> a very useful rule of thumb to distinguish rvalues from lvalues.</p>\n<blockquote id=\"so_3601602_34901787_3\">\n<ul>\n<li>If you can take the address of an expression, the expression is an lvalue.</li>\n<li>If the type of an expression is an lvalue reference (e.g., T&amp; or const T&amp;, etc.), that expression is an lvalue.</li>\n<li>Otherwise, the expression is an rvalue.  Conceptually (and typically also in fact), rvalues correspond to temporary objects, such\n  as those returned from functions or created through implicit type\n  conversions. Most literal values (e.g., 10 and 5.3) are also rvalues.</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "1505939", "LastActivityDate": "2016-03-07T11:26:10.260", "Score": "25", "CreationDate": "2016-01-20T13:46:20.917", "ParentId": "3601602", "CommentCount": "6", "OwnerUserId": "5137315", "LastEditDate": "2016-03-07T11:26:10.260"}, "3601661": {"Id": "3601661", "PostTypeId": "2", "Body": "<p>I guess this document might serve as a not so short introduction : <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf\" rel=\"noreferrer\">n3055</a></p>\n<p>The whole massacre began with the move semantics. Once we have expressions that can be moved and not copied, suddenly easy to grasp rules demanded distinction between expressions that can be moved, and in which direction.</p>\n<p>From what I guess based on the draft, the r/l value distinction stays the same, only in the context of moving things get messy. </p>\n<p>Are they needed? Probably not if we wish to forfeit the new features. But to allow better optimization we should probably embrace them.</p>\n<p><strong>Quoting <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf\" rel=\"noreferrer\">n3055</a>:</strong></p>\n<ul>\n<li>An <strong>lvalue</strong> (so-called, historically,\nbecause lvalues could appear on the\nleft-hand side  of an assignment\nexpression) designates a function or\nan object.  <em>[Example: If <code>E</code> is  an\nexpression of pointer type, then <code>*E</code>\nis an lvalue expression referring to\nthe object  or function to which <code>E</code>\npoints.  As another example, the\nresult of calling a function  whose\nreturn type is an lvalue reference is\nan lvalue.]</em> </li>\n<li>An <strong>xvalue</strong> (an\n\u201ceXpiring\u201d value) also refers to an\nobject, usually near the end of its \nlifetime (so that its resources may\nbe moved, for example).  An xvalue is\nthe result  of certain kinds of\nexpressions involving rvalue\nreferences.  <em>[Example: The \nresult of calling a function whose\nreturn type is an rvalue reference is\nan xvalue.]</em></li>\n<li>A <strong>glvalue</strong>   (\u201cgeneralized\u201d lvalue) is an <strong>lvalue</strong>\nor an <strong>xvalue</strong>. </li>\n<li>An <strong>rvalue</strong> (so-called,\nhistorically, because rvalues could\nappear on the right-hand  side of an\nassignment expression) is an xvalue,\na temporary object or\nsubobject thereof, or a value that is\nnot associated with an object. </li>\n<li>A\n<strong>prvalue</strong> (\u201cpure\u201d rvalue) is an rvalue\nthat is not an xvalue.  <em>[Example: The\nresult  of calling a function whose\nreturn type is not a reference is a\nprvalue]</em></li>\n</ul>\n<p>The document in question is a great reference for this question, because it shows the exact changes in the standard that have happened as a result of the introduction of the new nomenclature.</p>\n", "LastEditorUserId": "233522", "LastActivityDate": "2010-08-30T15:26:10.180", "Score": "489", "CreationDate": "2010-08-30T15:09:16.103", "ParentId": "3601602", "CommentCount": "7", "OwnerUserId": "233522", "LastEditDate": "2010-08-30T15:26:10.180"}, "3601602": {"ViewCount": "111800", "Body": "<p>In C++03, an expression is either an <strong>rvalue</strong> or an <strong>lvalue</strong>.</p>\n<p>In C++11, an expression can be an:     </p>\n<ol>\n<li><strong>rvalue</strong></li>\n<li><strong>lvalue</strong></li>\n<li><strong>xvalue</strong></li>\n<li><strong>glvalue</strong></li>\n<li><strong>prvalue</strong></li>\n</ol>\n<p>Two categories have become five categories.</p>\n<ul>\n<li>What are these new categories of expressions?</li>\n<li>How do these new categories relate to the existing rvalue and lvalue categories?  </li>\n<li>Are the rvalue and lvalue categories in C++0x the same as they are in C++03?</li>\n<li>Why are these new categories needed?  Are the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/\" rel=\"noreferrer\">WG21</a> gods just trying to confuse us mere mortals?</li>\n</ul>\n", "Title": "What are rvalues, lvalues, xvalues, glvalues, and prvalues?", "CreationDate": "2010-08-30T15:02:41.630", "LastActivityDate": "2017-11-18T06:06:21.000", "CommentCount": "17", "FavoriteCount": "648", "PostTypeId": "1", "LastEditDate": "2015-07-27T16:49:39.117", "LastEditorUserId": "151292", "Id": "3601602", "Score": "990", "OwnerUserId": "151292", "Tags": "<c++><expression><c++-faq><c++11>", "AnswerCount": "10"}, "3602424": {"Id": "3602424", "PostTypeId": "2", "Body": "<p>C++03's categories are too restricted to capture the introduction of rvalue references correctly into expression attributes. </p>\n<p>With the introduction of them, it was said that an unnamed rvalue reference evaluates to an rvalue, such that overload resolution would prefer rvalue reference bindings, which would make it select move constructors over copy constructors. But it was found that this causes problems all around, for example with <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#690\" rel=\"noreferrer\">Dynamic Types</a> and with qualifications. </p>\n<p>To show this, consider</p>\n<pre><code>int const&amp;&amp; f();\n\nint main() {\n  int &amp;&amp;i = f(); // disgusting!\n}\n</code></pre>\n<p>On pre-xvalue drafts, this was allowed, because in C++03, rvalues of non-class types are never cv-qualified. But it is intended that <code>const</code> applies in the rvalue-reference case, because here we <em>do</em> refer to objects (= memory!), and dropping const from non-class rvalues is mainly for the reason that there is no object around. </p>\n<p>The issue for dynamic types is of similar nature. In C++03, rvalues of class type have a known dynamic type - it's the static type of that expression. Because to have it another way, you need references or dereferences, which evaluate to an lvalue. That isn't true with unnamed rvalue references, yet they can show polymorphic behavior. So to solve it, </p>\n<ul>\n<li><p>unnamed rvalue references become <strong>xvalues</strong>. They can be qualified and potentially have their dynamic type different. They do, like intended, prefer rvalue references during overloading, and won't bind to non-const lvalue references. </p></li>\n<li><p>What previously was an rvalue (literals, objects created by casts to non-reference types) now becomes an <strong>prvalue</strong>. They have the same preference as xvalues during overloading. </p></li>\n<li><p>What previously was an lvalue stays an lvalue. </p></li>\n</ul>\n<p>And two groupings are done to capture those that can be qualified and can have different dynamic types (<strong>glvalues</strong>) and those where overloading prefers rvalue reference binding (<strong>rvalues</strong>). </p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2010-08-30T17:04:01.357", "Score": "32", "CreationDate": "2010-08-30T16:46:28.920", "ParentId": "3601602", "CommentCount": "1", "OwnerUserId": "34509", "LastEditDate": "2010-08-30T17:04:01.357"}, "38169963": {"Id": "38169963", "PostTypeId": "2", "Body": "<p>IMHO, the best explanation about its meaning gave us <a href=\"http://www.stroustrup.com/terminology.pdf\" rel=\"noreferrer\">Stroustrup</a> + take into account examples of <a href=\"https://stackoverflow.com/a/34901787/1433373\">D\u00e1niel S\u00e1ndor</a> and <a href=\"https://stackoverflow.com/a/38559710/1433373\">Mohan</a>:</p>\n<p><strong>Stroustrup:</strong></p>\n<blockquote>\n<p id=\"so_3601602_38169963_0\">Now I was seriously worried. Clearly we were headed for an impasse or\n  a mess or both. I spent the lunchtime doing an analysis to see which\n  of the properties (of values) were independent. There were only two\n  independent properties:</p>\n<ul>\n<li><code>has identity</code> \u2013 i.e. and address, a pointer, the user can    determine whether two copies are identical, etc. </li>\n<li><code>can be moved from</code> \u2013 i.e. we are allowed to leave to source of a \"copy\" in some indeterminate, but valid state</li>\n</ul>\n<p id=\"so_3601602_38169963_1\">This led me to the conclusion that there are exactly three kinds of\n  values (using the regex notational trick of using a capital letter to\n  indicate a negative \u2013 I was in a hurry):</p>\n<ul>\n<li><code>iM</code>: has identity and cannot be moved from</li>\n<li><code>im</code>: has identity and can be moved from (e.g. the result of casting an lvalue to a rvalue reference)</li>\n<li><code>Im</code>: does not have identity and can be moved from The fourth possibility (<code>IM</code>: doesn\u2019t have identity and cannot be moved) is not\n  useful in <code>C++</code> (or, I think) in any other language.</li>\n</ul>\n<p id=\"so_3601602_38169963_2\">In addition to these three fundamental classifications of values, we\n  have two obvious generalizations that correspond to the two\n  independent properties:</p>\n<ul>\n<li><code>i</code>: has identity</li>\n<li><code>m</code>: can be moved from</li>\n</ul>\n<p id=\"so_3601602_38169963_3\">This led me to put this diagram on the board:\n  <a href=\"https://i.stack.imgur.com/yY4zK.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/yY4zK.png\"/></a></p>\n<h2>Naming</h2>\n<p id=\"so_3601602_38169963_4\">I observed that we had only limited freedom to name: The two points to\n  the left (labeled <code>iM</code> and <code>i</code>) are what people with more or less\n  formality have called <code>lvalues</code> and the two points on the right\n  (labeled  <code>m</code> and <code>Im</code>) are what people with more or less formality\n  have called <code>rvalues</code>. This must be reflected in our naming. That is,\n  the left \"leg\" of the <code>W</code> should have names related to <code>lvalue</code> and the\n  right \"leg\" of the <code>W</code> should have names related to <code>rvalue.</code> I note\n  that this whole discussion/problem arise from the  introduction of\n  rvalue references and move semantics. These notions simply don\u2019t exist\n  in Strachey\u2019s world consisting of just <code>rvalues</code> and <code>lvalues</code>. Someone\n  observed that the ideas that</p>\n<ul>\n<li>Every <code>value</code> is either an <code>lvalue</code> or an <code>rvalue</code></li>\n<li>An <code>lvalue</code> is not an <code>rvalue</code> and an <code>rvalue</code> is not an <code>lvalue</code> </li>\n</ul>\n<p id=\"so_3601602_38169963_5\">are deeply embedded in our consciousness, very useful properties, and\n  traces of this dichotomy can be found all over the draft standard. We\n  all agreed that we ought to preserve those properties (and make them\n  precise). This further constrained our naming choices. I observed that\n  the standard library wording uses <code>rvalue</code> to mean <code>m</code> (the\n  generalization), so that to preserve the expectation and text of the\n  standard library the right-hand bottom point of the <code>W</code> should be named\n  <code>rvalue.</code></p>\n<p id=\"so_3601602_38169963_6\">This led to a focused discussion of naming. First, we needed to decide\n  on <code>lvalue.</code> Should <code>lvalue</code> mean <code>iM</code> or the generalization <code>i</code>? Led\n  by Doug Gregor, we listed the places in the core language wording\n  where the word <code>lvalue</code> was qualified to mean the one or the other. A\n  list was made and in most cases  and in the most tricky/brittle text\n  <code>lvalue</code> currently means <code>iM</code>. This is the classical meaning of lvalue\n  because \"in the old days\" nothing was moved; <code>move</code> is a novel notion\n  in <code>C++0x</code>. Also, naming the topleft point of the <code>W</code> <code>lvalue</code> gives us\n  the property that every value is an <code>lvalue</code> or an <code>rvalue</code>, but not both.</p>\n<p id=\"so_3601602_38169963_7\">So, the top left point of the <code>W</code> is <code>lvalue</code> and the bottom right point\n  is <code>rvalue.</code> What does that make the bottom left and top right points?\n  The bottom left point is a generalization of the classical lvalue,\n  allowing for move. So it is a <code>generalized lvalue.</code> We named it\n  <code>glvalue.</code> You can quibble about the abbreviation, but (I think) not\n  with the logic. We assumed that in serious use <code>generalized lvalue</code>\n  would somehow be abbreviated anyway, so we had better do it\n  immediately (or risk confusion). The top right point of the W is less\n  general than the bottom right (now, as ever, called <code>rvalue</code>). That\n  point represent the original pure notion of an object you can move\n  from because it cannot be referred to again (except by a destructor).\n  I liked the phrase <code>specialized rvalue</code> in contrast to <code>generalized\n  lvalue</code> but <code>pure rvalue</code> abbreviated to <code>prvalue</code> won out (and\n  probably rightly so). So, the left leg of the W is <code>lvalue</code> and\n  <code>glvalue</code> and the right leg is <code>prvalue</code> and <code>rvalue.</code> Incidentally,\n  every value is either a glvalue or a prvalue, but not both.</p>\n<p id=\"so_3601602_38169963_8\">This leaves the top middle of the <code>W</code>: <code>im</code>; that is, values that have\n  identity and can be moved. We really don\u2019t have anything that guides\n  us to a good name for those esoteric beasts. They are important to\n  people working with the (draft) standard text, but are unlikely to\n  become a household name. We didn\u2019t find any  real constraints on the\n  naming to guide us, so we picked \u2018x\u2019 for the center, the unknown, the\n  strange, the xpert only, or even x-rated.</p>\n<p id=\"so_3601602_38169963_9\"><a href=\"https://i.stack.imgur.com/zxsYZ.png\" rel=\"noreferrer\"><img alt=\"Steve showing off the final product\" src=\"https://i.stack.imgur.com/zxsYZ.png\"/></a></p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-03-08T08:08:21.147", "Score": "78", "CreationDate": "2016-07-03T12:30:23.583", "ParentId": "3601602", "CommentCount": "3", "OwnerUserId": "1433373", "LastEditDate": "2017-05-23T12:26:33.380"}, "3607179": {"Id": "3607179", "PostTypeId": "2", "Body": "<p>I'll start with your last question:</p>\n<blockquote>\n<p id=\"so_3601602_3607179_0\">Why are these new categories needed? </p>\n</blockquote>\n<p>The C++ standard contains many rules that deal with the value category of an expression. Some rules make a distinction between lvalue and rvalue. For example, when it comes to overload resolution. Other rules make a distinction between glvalue and prvalue. For example, you can have a glvalue with an incomplete or abstract type but there is no prvalue with an incomplete or abstract type. Before we had this terminology the rules that actually need to distinguish between glvalue/prvalue referred to lvalue/rvalue and they were either unintentionally wrong or contained lots of explaining and exceptions to the rule a la \"...unless the rvalue is due to unnamed rvalue reference...\". So, it seems like a good idea to just give the concepts of glvalues and prvalues their own name.</p>\n<blockquote>\n<p id=\"so_3601602_3607179_1\">What are these new categories of expressions?\n  How do these new categories relate to the existing rvalue and lvalue categories?</p>\n</blockquote>\n<p>We still have the terms lvalue and rvalue that are compatible with C++98. We just divided the rvalues into two subgroups, xvalues and prvalues, and we refer to lvalues and xvalues as glvalues. Xvalues are a new kind of value category for unnamed rvalue references. Every expression is one of these three: lvalue, xvalue, prvalue. A Venn diagram would look like this:</p>\n<pre><code>    ______ ______\n   /      X      \\\n  /      / \\      \\\n |   l  | x |  pr  |\n  \\      \\ /      /\n   \\______X______/\n       gl    r\n</code></pre>\n<p>Examples with functions:</p>\n<pre><code>int   prvalue();\nint&amp;  lvalue();\nint&amp;&amp; xvalue();\n</code></pre>\n<p>But also don't forget that named rvalue references are lvalues:</p>\n<pre><code>void foo(int&amp;&amp; t) {\n  // t is initialized with an rvalue expression\n  // but is actually an lvalue expression itself\n}\n</code></pre>\n", "LastEditorUserId": "153285", "LastActivityDate": "2015-09-07T01:03:02.590", "Score": "144", "CreationDate": "2010-08-31T08:08:28.323", "ParentId": "3601602", "CommentCount": "0", "OwnerUserId": "172531", "LastEditDate": "2015-09-07T01:03:02.590"}});