post_cb({"10488285": {"ParentId": "10488176", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Normally virtual functions can't be eliminated by the linker as dead-code, because their addresses have to appear in the vtable.  However, if the vtable for <code>struct C</code> was determined to be dead code (which could happen if all constructors are also dead code), then that last remaining reference can be eliminated too.</p>\n<p>Because the function is declared <code>inline</code>, this dead code removal optimization doesn't have to wait until link time; it can be done by the compiler.  The Standard says (see section 7.1.2):</p>\n<blockquote>\n<p id=\"so_10488176_10488285_0\"><strong>An inline function shall be defined in every translation unit in which it is odr-used</strong> and shall have exactly the same definition in every case (3.2).  [ Note:  A call to the inline function may be encountered before its definition appears in the translation unit.  \u2014 end note ] If the definition of a function appears in a translation unit before its first declaration as inline, the program is ill-formed.  If a function with external linkage is\n  declared inline in one translation unit, it shall be declared inline in all translation units in which it appears; no diagnostic is required.   An <code>inline</code> function with external linkage shall have the same address in all translation units.  A <code>static</code> local variable in an <code>extern inline</code> function always refers to the same object. A string literal in the body of an <code>extern inline</code> function is the same object in different translation units. [ Note:  A string literal appearing in a default argument is not in the body of an inline function merely because the expression is used in a function call from that inline function.   \u2014 end note ] A type defined within the body of an <code>extern inline</code> function is the same type in every translation unit.</p>\n</blockquote>\n<p>If the compiler can determine the function is never used in <em>this</em> translation unit, it knows that any translation unit that does use the function must contain its own identical definition, and will generate the code.  So it can skip code generation just as if it didn't have external linkage at all.</p>\n<p>Generating a warning is completely pointless, however, since there will be a high number of false positives (when the <code>inline</code> function IS odr-used and code generated in some other compilation unit).</p>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2012-05-07T20:04:51.457", "Id": "10488285", "Score": "1", "CreationDate": "2012-05-07T19:58:22.510", "LastActivityDate": "2012-05-07T20:04:51.457"}, "10488242": {"ParentId": "10488176", "CommentCount": "0", "Body": "<p>The code is well-formed.  <code>C::func</code> overrides <code>A::func</code>.  <code>B::func</code> is an unrelated function.  The spec reads (10.3/2):</p>\n<blockquote>\n<p id=\"so_10488176_10488242_0\">If a virtual member function <code>vf</code> is declared in a class <code>Base</code> and in a class <code>Derived</code>, derived directly or indirectly from <code>Base</code>, a member function <code>vf</code> with the same name, parameter-type-list, cv-qualification, and ref-qualifier (or absence of same) as <code>Base::vf</code> is declared, then <code>Derived::vf</code> is also virtual (whether or not it is so declared) and it overrides111 <code>Base::vf</code>.</p>\n</blockquote>\n<p><code>C::func</code> has the same name as <code>A::func</code> and <code>A::func</code> is virtual, therefore <code>C::func</code> overrides <code>A::func</code>.  <code>B::func</code> has no relation to <code>A::func</code>; I don't know that there is any language in the spec that expressly addresses that scenario.</p>\n<p>The Visual C++ 11 Beta compiler does not emit any warnings or errors for this code.</p>\n", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "10488242", "Score": "3", "CreationDate": "2012-05-07T19:54:00.617", "LastActivityDate": "2012-05-07T19:54:00.617"}, "10488269": {"ParentId": "10488176", "CommentCount": "4", "Body": "<p><a href=\"http://msdn.microsoft.com/en-us/library/z85eyax0%28v=vs.71%29.aspx\" rel=\"nofollow\">Let me google it for you.</a></p>\n<blockquote>\n<p id=\"so_10488176_10488269_0\"><strong><code>function</code> : unreferenced local function has been removed</strong></p>\n<p id=\"so_10488176_10488269_1\">The given function is local and not referenced in the body of the module; therefore, the function is dead code.</p>\n<p id=\"so_10488176_10488269_2\">The compiler did not generate code for this dead function.</p>\n</blockquote>\n<p>The compiler statically determined that the function was unused, so it did not generate code for that function and warns you that you have useless code. A bit more involved than the usual <em>unused variable</em> warning, but about the same effect: dead code smells.</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "10488269", "Score": "0", "CreationDate": "2012-05-07T19:56:09.427", "LastActivityDate": "2012-05-07T19:56:09.427"}, "bq_ids": {"n4140": {"so_10488176_10488285_0": {"section_id": 5404, "quality": 0.9478260869565217, "length": 109}, "so_10488176_10488242_0": {"section_id": 7003, "quality": 0.967741935483871, "length": 30}, "so_10488176_10488269_0": {"section_id": 6536, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_10488176_10488285_0": {"section_id": 5199, "quality": 0.9478260869565217, "length": 109}, "so_10488176_10488242_0": {"section_id": 6749, "quality": 0.967741935483871, "length": 30}, "so_10488176_10488269_0": {"section_id": 6291, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_10488176_10488285_0": {"section_id": 6853, "quality": 0.7043478260869566, "length": 81}, "so_10488176_10488242_0": {"section_id": 8500, "quality": 0.967741935483871, "length": 30}, "so_10488176_10488269_0": {"section_id": 8018, "quality": 0.6666666666666666, "length": 4}}}, "10488176": {"CommentCount": "8", "ViewCount": "468", "PostTypeId": "1", "LastEditorUserId": "369872", "CreationDate": "2012-05-07T19:48:57.047", "LastActivityDate": "2012-05-07T21:48:39.827", "Title": "Does a virtual function override a non-virtual function of the same name in a base class?", "AcceptedAnswerId": "10488242", "LastEditDate": "2012-05-07T21:48:39.827", "Id": "10488176", "Score": "6", "Body": "<p>Is the following standard conforming? Can you cite the section?</p>\n<pre><code>struct A\n{\n    virtual void func() = 0;\n};\n\nstruct B\n{\n    void func(){}\n};\n\nstruct C : public A, public B\n{\n    virtual void func(){ B::func(); }\n};\n</code></pre>\n<p>I'm getting a strange compiler warning in VS2010 in equivalent but more complicated code pointing to <code>func</code>'s declaration in the derived-most class: <code>warning C4505: unreferenced local function has been removed</code>. I have no idea why the compiler thinks a virtual function declared in a class is a local; however I can't repro that warning in a simpler example.</p>\n<h1>Edit:</h1>\n<p>I figured out a small repro case for the warning. I think I was going down the wrong path assuming it was related to function hiding. Here's the repro case:</p>\n<pre><code>template&lt;typename T&gt;\nstruct C\n{\n    int GetType() const;\n    virtual int func() const;   // {return 4;}  //  Doing this inline removes the warning &lt;--------------\n};\n\ntemplate&lt;typename T&gt;\nint C&lt;T&gt;::GetType() const\n{\n    return 0;\n}\n\ntemplate&lt;&gt;\nint C&lt;int&gt;::GetType() const\n{\n    return 12;\n}\n\ntemplate&lt;typename T&gt; \nint C&lt;T&gt;::func() const\n{\n    return 3; \n}\n\n//  Adding the following removes the warning &lt;--------------------\n//  template&lt;&gt;\n//  int C&lt;int&gt;::func() const\n//  {\n//      return 4;\n//  }\n</code></pre>\n<p>I'm fairly sure this is just a VS2010 bug.</p>\n", "Tags": "<c++>", "OwnerUserId": "369872", "AnswerCount": "3"}});