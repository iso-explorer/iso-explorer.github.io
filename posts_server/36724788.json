post_cb({"36724864": {"ParentId": "36724788", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You are dealing with implementation defined behavior.  Per the standard <strong>[except.handle]</strong></p>\n<blockquote>\n<p id=\"so_36724788_36724864_0\">If no matching handler is found, the function <code>std::terminate()</code> is called; whether or not the stack is unwound before this call to <code>std::terminate()</code> is implementation-defined</p>\n</blockquote>\n<p>So <code>g</code> may or may not be destroyed based on what implementation you are using.  You will not be able to rely on this always being handled the same way.</p>\n", "OwnerUserId": "4342498", "LastEditorUserId": "4342498", "LastEditDate": "2016-04-19T17:13:52.453", "Id": "36724864", "Score": "0", "CreationDate": "2016-04-19T17:00:45.033", "LastActivityDate": "2016-04-19T17:13:52.453"}, "bq_ids": {"n4140": {"so_36724788_36724864_0": {"section_id": 3354, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_36724788_36724864_0": {"section_id": 3224, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_36724788_36724864_0": {"section_id": 4121, "quality": 0.9230769230769231, "length": 12}}}, "36724788": {"CommentCount": "0", "ViewCount": "34", "CreationDate": "2016-04-19T16:56:19.277", "LastActivityDate": "2016-04-19T17:13:52.453", "Title": "Guard in c++, destructor not called when the exception is not treated in main", "PostTypeId": "1", "Id": "36724788", "Score": "0", "Body": "<p>If we consider the following code with g++ or clang, the destructor of the Guard class is not called when the exception is not catched at least in the main function. I made a thew googling, and did not find any usefull information.</p>\n<p>I use guard class at lot to implement RAII. Thus, I found this to be quite disapointing, in particular when dealing with ressources such as semaphore.</p>\n<p>I though that C++ requires the destructor to be called when an exception is thrown. Is this behaviour standard or is this du to the libstdc++ implementation ?</p>\n<p>Thank you for any help or advice in this matter. </p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;memory&gt;\n\nstruct Guard\n{\n  Guard()\n    : v(new int)\n  {\n    std::cout &lt;&lt; \"Guard()\" &lt;&lt; std::endl;\n  }\n  ~Guard(){\n    std::cout &lt;&lt; \"~Guard()\" &lt;&lt; std::endl;\n    delete v;\n  }\nprivate:\n  int *v;\n};\n\nvoid test(){\n  auto g = std::make_shared&lt;Guard&gt;();\n  throw(\"youch\");\n}\n\nvoid test2(){\n  test();\n}\n\n\nint main(void){\n  // try{\n    test2(); \n  // } catch(...){\n\n  // }\n  return 0;\n}\n</code></pre>\n<p>P.S. : I do not wish to add a try/catch block in the main function as I appreciate to be able to trace back an exception to the point where it is emitted in the debugger.</p>\n", "Tags": "<c++><exception><guard><raii>", "OwnerUserId": "6225954", "AnswerCount": "1"}});