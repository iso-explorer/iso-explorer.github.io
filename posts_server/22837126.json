post_cb({"22837313": {"ParentId": "22837126", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>As I discuss in <a href=\"https://stackoverflow.com/q/5905155/560648\">this answer</a>, regardless of the presence of the <code>inline</code> keyword, the behaviour of your code is certainly undefined since you call this function:</p>\n<blockquote>\n<p id=\"so_22837126_22837313_0\"><code>[C++11: 1.10/24]:</code> The implementation may assume that any thread will eventually do one of the following:</p>\n<ul>\n<li>terminate,</li>\n<li>make a call to a library I/O function,</li>\n<li>access or modify a volatile object, or</li>\n<li>perform a synchronization operation or an atomic operation.</li>\n</ul>\n</blockquote>\n<p>Clang is permitted to elide the entire thing, just as GCC is permitted to run it without inlining and reach a stack overflow. A compiler would also be free to attempt actual inlining, and it is even permitted to crash during compilation in such a case.</p>\n<p>Crucially, there is no rule in the standard that makes the semantics for an infinite recursion differ just because a function is marked <code>inline</code> or even actually inlined (<code>[C++11: 7.1.2]</code>).</p>\n<p>Of course, I reckon that if you were to never invoke this function, by the as-if rule a compiler can elide it entirely and then you have no problem.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:49:53.243", "Id": "22837313", "Score": "3", "CreationDate": "2014-04-03T12:09:31.747", "LastActivityDate": "2014-04-03T12:15:02.913"}, "22837126": {"CommentCount": "12", "ViewCount": "123", "PostTypeId": "1", "LastEditorUserId": "1804599", "CreationDate": "2014-04-03T12:03:00.203", "LastActivityDate": "2014-04-03T12:15:02.913", "Title": "Inlining infinite recursion", "LastEditDate": "2014-04-03T12:12:45.753", "Id": "22837126", "Score": "0", "Body": "<p>Is this code defined behavior? </p>\n<pre><code>inline int a() { return 0 + a(); }\n\nint main() { a(); }\n</code></pre>\n<p>If optimizations are enabled then Clang optimizes it out but GCC doesn't. So the code is not portable in practice. Does the C++ spec say anything about this?</p>\n", "Tags": "<c++>", "OwnerUserId": "75889", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_22837126_22837313_0": {"section_id": 5838, "quality": 0.7272727272727273, "length": 8}}, "n3337": {"so_22837126_22837313_0": {"section_id": 5608, "quality": 0.7272727272727273, "length": 8}}, "n4659": {"so_22837126_22837313_0": {"section_id": 7300, "quality": 0.7272727272727273, "length": 8}}}});