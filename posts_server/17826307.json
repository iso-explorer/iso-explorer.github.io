post_cb({"17826307": {"CommentCount": "2", "AcceptedAnswerId": "17826781", "PostTypeId": "1", "LastEditorUserId": "76722", "CreationDate": "2013-07-24T06:01:32.063", "LastActivityDate": "2013-09-27T16:55:38.637", "LastEditDate": "2013-07-24T06:45:59.537", "ViewCount": "262", "FavoriteCount": "1", "Title": "ADL in case of equal-named member function", "Id": "17826307", "Score": "5", "Body": "<p>The situation is that some member function <code>bar::Bar::frobnicate</code> wants to utilize ADL to find a function from some unknown namespace, within a function that has an identical name. However, it only finds its own name.</p>\n<h2>Testcase</h2>\n<p>(<em>Note</em> that in reality, <code>Bar</code> is a <code>Foo</code>-agnostic template; this is just the reproducible, minimal testcase)</p>\n<pre><code>namespace foo {\n    struct Foo {};\n    void frobnicate(Foo const &amp;) {}\n}\n\nnamespace bar {\n    struct Bar {\n        void frobnicate() {\n            foo::Foo foo;\n            frobnicate(foo); // &lt;-- error\n        }\n    };\n}\n\nint main () {\n    bar::Bar x;\n    x.frobnicate();\n    frobnicate(foo::Foo());\n}\n</code></pre>\n<p>Results in:</p>\n<pre><code>test.cc: In member function \u2018void bar::Bar::frobnicate()\u2019:\ntest.cc:10:31: error: no matching function for call to \u2018bar::Bar::frobnicate(foo::Foo&amp;)\u2019\ntest.cc:10:31: note: candidate is:\ntest.cc:8:18: note: void bar::Bar::frobnicate()\ntest.cc:8:18: note:   candidate expects 0 arguments, 1 provided\n</code></pre>\n<h2>Standard</h2>\n<p>I understand that this is correct compiler behaviour:</p>\n<blockquote>\n<h3>3.4.1 Unqualified name lookup <em>[basic.lookup.unqual]</em></h3>\n<p id=\"so_17826307_17826307_0\">(...) name lookup ends as soon as a declaration is found for the name (...)</p>\n</blockquote>\n<p>and only <em>after</em> unqualified lookup failed, argument dependent lookup comes into play:</p>\n<blockquote>\n<h3>3.4.2 Argument-dependent name lookup <em>[basic.lookup.argdep]</em></h3>\n<p id=\"so_17826307_17826307_1\">When the postfix-expression in a function call (5.2.2) is an unqualified-id, other namespaces not considered\n  during the usual unqualified lookup (3.4.1) may be searched</p>\n</blockquote>\n<h2>Workaround</h2>\n<p>My current workaround is to introduce a special traits class that does not define the clashing name itself:</p>\n<pre><code>    struct BarTraits {\n        void frobnicate_(foo::Foo const &amp;b) {\n            frobnicate(b);\n        }\n    };\n</code></pre>\n<p>or this ligher version:</p>\n<pre><code>    void frobnicate_(foo::Foo const &amp;c) { frobnicate(c); }\n</code></pre>\n<h2>Question</h2>\n<p>Are there better alternatives than introducing such traits classes?</p>\n<p>Explicitly qualifying the call as <code>foo::frobnicate(foo)</code> is not an option here, because (as mentioned) the <code>Bar</code> class is a template upon <code>Foo</code> in reality and should not only work for types in the <code>foo</code> namespace.</p>\n", "Tags": "<c++><interface><argument-dependent-lookup><non-member-functions>", "OwnerUserId": "76722", "AnswerCount": "2"}, "17826781": {"ParentId": "17826307", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>As you found out yourself, adding a member function <code>frobnicate</code> to the class interface of <code>Bar</code> (or <code>Bar&lt;T&gt;</code> in the template case), will prevent ADL from finding <code>foo::frobnicate</code>. </p>\n<p>The easiest -<a href=\"http://www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197\" rel=\"nofollow\"><strong>and in this case idiomatic</strong></a>- way to add <code>frobnicate</code> functionality to a class <code>Bar</code> (or to a class template <code>Bar&lt;T&gt;</code>) is to add a non-member function <code>frobnicate(Bar)</code>  (or function template <code>frobnicate(Bar&lt;T&gt;)</code>) to the namespace <code>bar</code></p>\n<pre><code>namespace foo {\n    struct Foo {};\n    void frobnicate(Foo const &amp;)  {}\n}\n\nnamespace bar {\n    template&lt;class T&gt;\n    struct Bar {    \n       T t;    \n    }; \n\n    template&lt;class T&gt;\n    void frobnicate(Bar&lt;T&gt; const&amp; b)\n    {\n        frobnicate(b.t);    \n    }\n}\n\nint main () {\n    bar::Bar&lt;foo::Foo&gt; x;\n    frobnicate(x);\n    frobnicate(foo::Foo());\n}\n</code></pre>\n<p>If you insist on having a member function, you will have to rename it to something like <code>do_frobnicate()</code>. I would not use type traits tricks to get the same behavior as it is an indirect approach, and makes the class interfaces much harder to understand (remember Stroustrup's motto: \"represent your ideas directly in code\").</p>\n", "OwnerUserId": "819272", "LastEditorUserId": "183120", "LastEditDate": "2013-07-24T07:02:27.643", "Id": "17826781", "Score": "2", "CreationDate": "2013-07-24T06:32:28.617", "LastActivityDate": "2013-07-24T07:02:27.643"}, "19047845": {"ParentId": "17826307", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>you can use this trick</p>\n<pre><code>namespace dummy { void your_func(may be some parameteres); }\nstruct bar { \n   void member() {\n      using dummy::your_func; // now your call will find that and ADL will kick in\n</code></pre>\n", "OwnerUserId": "1708247", "LastEditorUserId": "1708247", "LastEditDate": "2013-09-27T16:55:38.637", "Id": "19047845", "Score": "0", "CreationDate": "2013-09-27T09:53:55.410", "LastActivityDate": "2013-09-27T16:55:38.637"}, "bq_ids": {"n4140": {"so_17826307_17826307_0": {"section_id": 7087, "quality": 1.0, "length": 7}, "so_17826307_17826307_1": {"section_id": 7103, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_17826307_17826307_0": {"section_id": 6831, "quality": 1.0, "length": 7}, "so_17826307_17826307_1": {"section_id": 6847, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_17826307_17826307_0": {"section_id": 8588, "quality": 1.0, "length": 7}, "so_17826307_17826307_1": {"section_id": 8604, "quality": 0.8666666666666667, "length": 13}}}});