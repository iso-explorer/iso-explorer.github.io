post_cb({"bq_ids": {"n4140": {"so_18456450_18456594_0": {"length": 71, "quality": 0.9594594594594594, "section_id": 447}, "so_18456450_18456594_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 7023}}, "n3337": {"so_18456450_18456594_0": {"length": 71, "quality": 0.9594594594594594, "section_id": 438}, "so_18456450_18456594_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 6769}}, "n4659": {"so_18456450_18456594_0": {"length": 71, "quality": 0.9594594594594594, "section_id": 469}, "so_18456450_18456594_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 8520}}}, "18456503": {"Id": "18456503", "PostTypeId": "2", "Body": "<p>No, that is not safe. While the <code>A</code> constructor (or destructor) is executing the object is of type <code>A</code>, not yet (not anymore) a <code>B</code> object. The call to <code>f()</code> will attempt to dispatch to the (still) pure virtual function and cause undefined behavior. Most implementations will catch this and terminate the application with an error message that indicates that a pure virtual function was called.</p>\n<hr>\n<p>After the edit:</p>\n<p>The fact that there is a definition for the pure virtual function means that it is legal to call it <em>without going through virtual dispatch</em>. It is still illegal to call a pure virtual function using dynamic dispatch. But you could rewrite the constructor as:</p>\n<pre><code>A::~A() { A::f(); }  // qualification disables dynamic dispatch\n</code></pre>\n<p>Without dynamic dispatch, the code becomes valid.</p>\n</hr>", "LastEditorUserId": "36565", "LastActivityDate": "2013-08-27T04:04:35.290", "Score": "7", "CreationDate": "2013-08-27T03:38:18.477", "ParentId": "18456450", "CommentCount": "20", "OwnerUserId": "36565", "LastEditDate": "2013-08-27T04:04:35.290"}, "18456450": {"ViewCount": "179", "Body": "<p>Without the line marked BODY, I know this is not safe. But with it, is this safe?</p>\n<pre><code>struct A\n{\n    virtual ~A() { f(); }\n\n    virtual void f() = 0;\n};\n\nvoid A::f() {} // BODY\n\nstruct B : A\n{\n    void f() {}\n};\n\nint main()\n{\n    delete new B;\n}\n</code></pre>\n<p>Working example:\n<a href=\"http://ideone.com/9bRZ3i\" rel=\"nofollow\">http://ideone.com/9bRZ3i</a></p>\n", "AcceptedAnswerId": "18456594", "Title": "Is it safe to call a pure virtual function in an abstract constructor/destructor, IF it has a body?", "CreationDate": "2013-08-27T03:28:22.590", "Id": "18456450", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-08-27T03:50:01.203", "LastEditorUserId": "2068573", "LastActivityDate": "2013-08-27T04:14:58.000", "Score": "3", "OwnerUserId": "2068573", "Tags": "<c++>", "AnswerCount": "2"}, "18456594": {"Id": "18456594", "PostTypeId": "2", "Body": "<p>If you want to bypass virtual dispatch and call the function body you have defined, you must qualify the function name: </p>\n<pre><code>virtual ~A() { A::f(); } // OK.\n</code></pre>\n<p>Otherwise, the call will initiate virtual dispatch, but only to the base class, because the object of derived type has already been destroyed before its bases.</p>\n<p>C++11 \u00a712.7/4 directly addresses your question:</p>\n<blockquote>\n<p id=\"so_18456450_18456594_0\">Member functions, including virtual functions (10.3), can be called during construction or destruction (12.6.2). When a virtual function is called directly or indirectly from a constructor or from a destructor, including during the construction or destruction of the class\u2019s non-static data members, and the object to which the call applies is the object (call it x) under construction or destruction, <strong>the function called is the final overrider in the constructor\u2019s or destructor\u2019s class and not one overriding it in a more-derived class.</strong> If the virtual function call uses an explicit class member access (5.2.5) and the object expression refers to the complete object of x or one of that object\u2019s base class subobjects but not x or one of its base class subobjects, the behavior is undefined.</p>\n</blockquote>\n<p>However, \u00a710.4/6 forbids doing this with a pure virtual function:</p>\n<blockquote>\n<p id=\"so_18456450_18456594_1\">Member functions can be called from a constructor (or destructor) of an abstract class; the effect of making a virtual call (10.3) to a pure virtual function directly or indirectly for the object being created (or destroyed) from such a constructor (or destructor) is undefined.</p>\n</blockquote>\n<p>So, it's UB.</p>\n<p>The effect of \"pure virtual\" is to hide the function definition from virtual lookup. You will never reach the definition of a pure virtual function from a dynamic dispatch function call, except perhaps as an effect of undefined behavior.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2013-08-27T04:14:58.000", "Score": "4", "CreationDate": "2013-08-27T03:49:50.227", "ParentId": "18456450", "CommentCount": "5", "OwnerUserId": "153285", "LastEditDate": "2013-08-27T04:14:58.000"}});