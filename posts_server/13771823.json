post_cb({"13771838": {"Id": "13771838", "PostTypeId": "2", "Body": "<p>Yes, deleting <code>myfoo</code> will destroy all of its members too, which includes the <code>std::vector</code>. It's important to note that if you had pointers inside <code>foo</code>, only the pointers would be destroyed, not the objects they point to (unless of course you defined a destructor that did that job for you - which you should!).</p>\n<p>It is mandated by the standard that after execution of the destructor, any non-static data members are destroyed also (\u00a712.4/8):</p>\n<blockquote>\n<p id=\"so_13771823_13771838_0\">After executing the body of the destructor and destroying any automatic objects allocated within the body, a destructor for class <code>X</code> calls the destructors for <code>X</code>'s direct non-variant non-static data members, the destructors for <code>X</code>\u2019s direct base classes and, if <code>X</code> is the type of the most derived class (12.6.2), its destructor calls the destructors for <code>X</code>'s virtual base classes.</p>\n</blockquote>\n<p>The class <code>foo</code> has a defaulted destructor because no user-declared destructor is defined (\u00a712.4/4):</p>\n<blockquote>\n<p id=\"so_13771823_13771838_1\">If a class has no user-declared destructor, a destructor is implicitly declared as defaulted (8.4).</p>\n</blockquote>\n<p>The destructor of <code>myfoo</code> is called when it is <code>delete</code>d (\u00a75.3.5/6):</p>\n<blockquote>\n<p id=\"so_13771823_13771838_2\">If the value of the operand of the <em>delete-expression</em> is not a null pointer value, the <em>delete-expression</em> will invoke the destructor (if any) for the object or the elements of the array being deleted.</p>\n</blockquote>\n<p>A <em>delete-expression</em> is an expression of the form:</p>\n<blockquote>\n<p id=\"so_13771823_13771838_3\"><code>::</code><sub>opt</sub> <code>delete</code> <em>cast-expression</em></p>\n</blockquote>\n", "LastEditorUserId": "150634", "LastActivityDate": "2012-12-07T22:42:18.550", "Score": "7", "CreationDate": "2012-12-07T22:11:36.067", "ParentId": "13771823", "CommentCount": "2", "OwnerUserId": "150634", "LastEditDate": "2012-12-07T22:42:18.550"}, "13771857": {"Id": "13771857", "PostTypeId": "2", "Body": "<p>The struct foo just holds the container of a vector. The items of the vector are allocated separately (usually on the heap) anyway.</p>\n<p>The vector's destructor deletes the actual vector on the heap, and the vector is destroyed when the object is deleted.</p>\n", "LastEditorUserId": "536086", "LastActivityDate": "2012-12-07T22:23:36.053", "Score": "3", "CreationDate": "2012-12-07T22:13:25.457", "ParentId": "13771823", "CommentCount": "7", "OwnerUserId": "536086", "LastEditDate": "2012-12-07T22:23:36.053"}, "13772262": {"Id": "13772262", "PostTypeId": "2", "Body": "<p>Here is code example that answers your question.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct bar {\n    ~bar() {std::cout &lt;&lt; \"deleted bar\" &lt;&lt; std::endl;}\n};\n\nstruct foo {\n  bar b[10];  \n};\n\nint main() {\n    foo* f = new foo();\n    delete f;\n}\n</code></pre>\n<p>The program will print \"deleted bar\" 10 times.</p>\n", "LastActivityDate": "2012-12-07T22:50:25.450", "CommentCount": "0", "CreationDate": "2012-12-07T22:50:25.450", "ParentId": "13771823", "Score": "2", "OwnerUserId": "942596"}, "bq_ids": {"n4140": {"so_13771823_13771838_1": {"length": 7, "quality": 1.0, "section_id": 400}, "so_13771823_13771838_2": {"length": 15, "quality": 1.0, "section_id": 6110}, "so_13771823_13771838_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 404}}, "n3337": {"so_13771823_13771838_1": {"length": 7, "quality": 1.0, "section_id": 391}, "so_13771823_13771838_2": {"length": 15, "quality": 1.0, "section_id": 5876}, "so_13771823_13771838_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 395}}, "n4659": {"so_13771823_13771838_1": {"length": 7, "quality": 1.0, "section_id": 417}, "so_13771823_13771838_2": {"length": 15, "quality": 1.0, "section_id": 7607}, "so_13771823_13771838_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 422}}}, "13771851": {"Id": "13771851", "PostTypeId": "2", "Body": "<p>Calling <code>delete foo</code> will deallocate and call destructors (if applicable) on all members of <code>foo</code>, so yes.  If it didn't work this way the language would be much more difficult to use.</p>\n", "LastActivityDate": "2012-12-07T22:13:06.487", "CommentCount": "0", "CreationDate": "2012-12-07T22:13:06.487", "ParentId": "13771823", "Score": "4", "OwnerUserId": "1053"}, "13771823": {"ViewCount": "452", "Body": "<blockquote>\n<p id=\"so_13771823_13771823_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/2670558/deleting-dynamically-allocated-object-that-contains-vector-in-c-stl\">deleting dynamically allocated object that contains vector in C++ STL</a> </br></p>\n</blockquote>\n<p>I have a struct like this</p>\n<pre><code>struct foo {\n  vector&lt;int&gt; myvector;\n};\n</code></pre>\n<p>Now, I create a pointer to foo, resize and insert some elements into the vector.</p>\n<pre><code>foo *myfoo = new foo;\nmyfoo-&gt;myvector.resize(100);\nmyfoo-&gt;myvector.push_back(0);\nmyfoo-&gt;myvector.push_back(1);\n... // and so on\n</code></pre>\n<p>Now, before myfoo goes out of scope, I would have to deallocate the memory allocated to it with</p>\n<pre><code>delete myfoo;\n</code></pre>\n<p>My question is whether this would take care freeing myvector also? I have this particular query because now that myvector is resized, the STL library would presumably allocated the container in the heap. So, when I free up myfoo, I wouldn't want the memory allocated to myvector leaking.</p>\n", "Title": "Deallocation of a vector in C++", "CreationDate": "2012-12-07T22:10:05.890", "Id": "13771823", "CommentCount": "2", "LastEditDate": "2017-05-23T11:55:58.173", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2012-12-07T22:50:25.450", "Tags": "<c++><stl><vector>", "Score": "2", "OwnerUserId": "697957", "ClosedDate": "2012-12-08T14:41:26.420", "AnswerCount": "4"}});