post_cb({"27230131": {"ViewCount": "155", "Body": "<p>I tried the following code but it gives:</p>\n<p>main.cpp:29:22: error: aggregate <code>'pop&lt;std::tuple&lt;int, char, float&gt; &gt; p'</code> has incomplete type and cannot be defined</p>\n<p>What am I missing?</p>\n<pre><code>template &lt;typename T&gt;\nstruct pop;\n\ntemplate &lt;typename E, typename... Ts&gt;\nstruct pop&lt;tuple&lt;Ts..., E&gt;&gt; {\n    using result = tuple&lt;Ts...&gt;;\n};\n\ntuple&lt;int, char, float&gt; t;\ntypename pop&lt;decltype(t)&gt;::result p;\n</code></pre>\n<p>If Ts... must be at the end in a type list, why does it work in this example from <a href=\"http://en.cppreference.com/w/cpp/language/parameter_pack\">http://en.cppreference.com/w/cpp/language/parameter_pack</a>:</p>\n<pre><code>template&lt;class A, class B, class...C&gt; void func(A arg1, B arg2, C...arg3)\n{\n    container&lt;A,B,C...&gt; t1;  // expands to container&lt;A,B,E1,E2,E3&gt; \n    container&lt;C...,A,B&gt; t2;  // expands to container&lt;E1,E2,E3,A,B&gt; \n    container&lt;A,C...,B&gt; t3;  // expands to container&lt;A,E1,E2,E3,B&gt; \n}\n</code></pre>\n", "AcceptedAnswerId": "27230507", "Title": "Creating a new tuple class by popping the last type", "CreationDate": "2014-12-01T14:06:59.923", "Id": "27230131", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-12-01T15:35:24.263", "LastEditorUserId": "85371", "LastActivityDate": "2014-12-03T13:50:56.147", "Score": "8", "OwnerUserId": "92318", "Tags": "<c++11><variadic-templates>", "AnswerCount": "4"}, "27236760": {"Id": "27236760", "PostTypeId": "2", "Body": "<p>Another C++11 way to skin this cat:</p>\n<pre><code>#include &lt;tuple&gt;\n\ntemplate&lt;class Tuple&gt;\nstruct pop;\n\ntemplate&lt;&gt;\nstruct pop&lt;std::tuple&lt;&gt;&gt;\n{\n    using type = std::tuple&lt;&gt;;\n};\n\ntemplate&lt;typename T1&gt;\nstruct pop&lt;std::tuple&lt;T1&gt;&gt;\n{\n    using type = std::tuple&lt;&gt;;\n};\n\ntemplate&lt;typename First, typename... Rest&gt;\nstruct pop&lt;std::tuple&lt;First,Rest...&gt;&gt;\n{\n    using type = \n    decltype(std::tuple_cat(\n                std::declval&lt;std::tuple&lt;First&gt;&gt;(),\n                std::declval&lt;typename pop&lt;std::tuple&lt;Rest...&gt;&gt;::type&gt;()));\n};\n\n// Test...\n\nstatic_assert(std::is_same&lt;pop&lt;std::tuple&lt;&gt;&gt;::type,std::tuple&lt;&gt;&gt;::value,\"\");\nstatic_assert(std::is_same&lt;pop&lt;std::tuple&lt;int&gt;&gt;::type,std::tuple&lt;&gt;&gt;::value,\"\");\nstatic_assert(\n    std::is_same&lt;pop&lt;std::tuple&lt;int,char&gt;&gt;::type,std::tuple&lt;int&gt;&gt;::value,\"\");\nstatic_assert(\n    std::is_same&lt;pop&lt;std::tuple&lt;int,char,float&gt;&gt;::type,\n        std::tuple&lt;int,char&gt;&gt;::value,\"\");\nstatic_assert(\n    std::is_same&lt;pop&lt;std::tuple&lt;int,char,float,double&gt;&gt;::type,\n        std::tuple&lt;int,char,float&gt;&gt;::value,\"\");\n</code></pre>\n", "LastEditorUserId": "1362568", "LastActivityDate": "2014-12-03T13:50:56.147", "Score": "1", "CreationDate": "2014-12-01T20:32:21.893", "ParentId": "27230131", "CommentCount": "2", "OwnerUserId": "1362568", "LastEditDate": "2014-12-03T13:50:56.147"}, "bq_ids": {"n4140": {"so_27230131_27230507_0": {"length": 31, "quality": 1.0, "section_id": 340}}, "n3337": {"so_27230131_27230507_0": {"length": 31, "quality": 1.0, "section_id": 330}}, "n4659": {"so_27230131_27230507_0": {"length": 31, "quality": 1.0, "section_id": 349}}}, "27230507": {"Id": "27230507", "PostTypeId": "2", "Body": "<p><code>tuple&lt;Ts..., E&gt;</code> is a non-deduced context. [temp.deduct.type]/9:</p>\n<blockquote>\n<p id=\"so_27230131_27230507_0\">If <code>P</code> has a form that contains <code>&lt;T&gt;</code> or <code>&lt;i&gt;</code>, then each argument <code>P</code><sub>i</sub> of the respective template argument list <code>P</code> is compared with the corresponding argument <code>A</code><sub>i</sub> of the corresponding template argument list of <code>A</code>. <strong>If the template argument list of <code>P</code> contains a pack expansion that is not the last template argument, the entire template argument list is a non-deduced context.</strong></p>\n</blockquote>\n<p>That means that your partial specialization is <strong>never</strong> matched.</p>\n<p>With C++14, one could use</p>\n<pre><code>template &lt;class T, class=std::make_index_sequence&lt;std::tuple_size&lt;T&gt;::value-1&gt;&gt;\nstruct pop;\n\ntemplate &lt;typename Tuple, std::size_t... indices&gt;\nstruct pop&lt;Tuple, std::index_sequence&lt;indices...&gt;&gt;\n{\n    using type = std::tuple&lt;std::tuple_element_t&lt;indices, Tuple&gt;...&gt;;\n};\n\ntemplate &lt;typename T&gt;\nusing pop_t = typename pop&lt;T&gt;::type;\n</code></pre>\n<p>Such that </p>\n<pre><code>using t = std::tuple&lt;int, char, float&gt;;\nstatic_assert( std::is_same&lt;pop_t&lt;t&gt;, std::tuple&lt;int, char&gt;&gt;{}, \"\" );\n</code></pre>\n<p>Compiles.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/3a6ce8f72dde8dcc\" rel=\"noreferrer\"><strong>Demo</strong></a>.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-12-01T15:20:53.953", "Score": "5", "CreationDate": "2014-12-01T14:27:49.357", "ParentId": "27230131", "CommentCount": "5", "OwnerUserId": "3647361", "LastEditDate": "2014-12-01T15:20:53.953"}, "27230347": {"Id": "27230347", "PostTypeId": "2", "Body": "<p><code>Ts...</code> must be the last element of a type list if you want it to be deduced.  <code>tuple&lt;Ts...,E&gt;</code> will not deduce <code>Ts...</code> to be all but the last, but rather never match anything.</p>\n<p>Getting rid of the last argument is a bit tricker.  <a href=\"http://ideone.com/hMiN6x\" rel=\"nofollow\">live example</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;tuple&gt;\n#include &lt;iostream&gt;\n\nnamespace details {\n  template&lt;class Lhs, class Rhs&gt;\n  struct pop_helper;\n\n  template&lt;template&lt;class...&gt;class Tup, class L0, class...Lhs, class...Rhs&gt;\n  struct pop_helper&lt;Tup&lt;L0,Lhs...&gt;, Tup&lt;Rhs...&gt;&gt;:\n    pop_helper&lt;Tup&lt;Lhs...&gt;, Tup&lt;Rhs...,L0&gt;&gt;\n  {};\n  template&lt;template&lt;class...&gt;class Tup, class L0, class...Rhs&gt;\n  struct pop_helper&lt;Tup&lt;L0&gt;, Tup&lt;Rhs...&gt;&gt; {\n    using type=Tup&lt;Rhs...&gt;;\n  };\n}\n\ntemplate &lt;typename T&gt;\nstruct pop;\n\ntemplate&lt;template&lt;class...&gt;class Tup, class...Ts&gt;\nstruct pop&lt;Tup&lt;Ts...&gt;&gt;:\n  details::pop_helper&lt;Tup&lt;Ts...&gt;,Tup&lt;&gt;&gt;\n{};\n\ntemplate&lt;typename T&gt;\nusing pop_t=typename pop&lt;T&gt;::type;\n\nstd::tuple&lt;int, char, float&gt; t;\ntypedef pop_t&lt;decltype(t)&gt; p;\n\nint main() {\n  p x = std::make_tuple( 7, 'x' );\n  std::cout &lt;&lt; std::get&lt;0&gt;(x) &lt;&lt; std::get&lt;1&gt;(x) &lt;&lt; std::tuple_size&lt;p&gt;{} &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p><code>pop_helper</code> moves the types over one at a time to the right hand side, until there is only one type left on the left hand side.  Then it returns the right hand side type.</p>\n<p><code>pop</code> just passes the tuples over.</p>\n<p>I used <code>template&lt;class...&gt;class Tup</code> instead of <code>std::tuple</code>, because why not support almost every <code>template</code> instead of just <code>std::tuple</code>?</p>\n<p><code>pop_t</code> gets rid of the annoying <code>typename</code> spam at point of use.</p>\n<p>I use the inhertance-as-type-map-forwarding pattern, which saves on typing.  With a type-map, the structure:</p>\n<pre><code>template&lt;class X&gt;\nstruct bob: foo&lt;X&gt; {};\n</code></pre>\n<p>can be read as <code>bob&lt;X&gt;</code> is <code>foo&lt;X&gt;</code>.  The alternative is the more verbose</p>\n<pre><code>template&lt;class X&gt;\nstruct bob {\n  using type = typename foo&lt;X&gt;::type;\n};\n</code></pre>\n<p>expanding variardic type lists is different than matching them.  When it was designed, matching was kept simple in order to make compiler vendors be able to implement the feature.  There may even be thorny issues beyond \"it is tricky\" down that path.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2014-12-01T14:26:57.540", "Score": "3", "CreationDate": "2014-12-01T14:18:38.050", "ParentId": "27230131", "CommentCount": "1", "OwnerUserId": "1774667", "LastEditDate": "2014-12-01T14:26:57.540"}, "27230759": {"Id": "27230759", "PostTypeId": "2", "Body": "<p>This is the solution I had come up with:</p>\n<pre><code>template &lt;typename T&gt;\nstruct pop;\n\ntemplate &lt;typename E, typename... Ts&gt;\nstruct pop&lt;std::tuple&lt;E, Ts...&gt;&gt; {\n    using type = decltype(tuple_cat(\n        declval&lt;tuple&lt;E&gt;&gt;(),\n        declval&lt;typename pop&lt;tuple&lt;Ts...&gt;&gt;::type&gt;()\n    ));\n};\n\ntemplate &lt;typename E&gt;\nstruct pop&lt;std::tuple&lt;E&gt;&gt; {\n    using type = std::tuple&lt;&gt;;\n};\n</code></pre>\n", "LastEditorUserId": "92318", "LastActivityDate": "2014-12-02T11:49:36.357", "Score": "0", "CreationDate": "2014-12-01T14:39:47.677", "ParentId": "27230131", "CommentCount": "7", "OwnerUserId": "92318", "LastEditDate": "2014-12-02T11:49:36.357"}});