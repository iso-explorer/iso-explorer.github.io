post_cb({"47072619": {"ParentId": "47072261", "CommentCount": "5", "Body": "<p>As the comments note, <code>operator new</code> can be replaced. This can happen in any Translation Unit. Optimizing a program for the case it's not replaced therefore requires Whole-Program Analysis. And if it <em>is</em> replaced, you have to call it of course.</p>\n<p>Whether the default <code>operator new</code> is a library <strong>I/O</strong> call is unspecified. That matters, because library I/O calls are observable and therefore they can't be optimized out either.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "47072619", "Score": "7", "CreationDate": "2017-11-02T10:11:18.327", "LastActivityDate": "2017-11-02T10:11:18.327"}, "47072261": {"CommentCount": "16", "AcceptedAnswerId": "47072594", "CreationDate": "2017-11-02T09:53:55.467", "LastActivityDate": "2017-11-03T20:35:45.420", "PostTypeId": "1", "ViewCount": "2875", "FavoriteCount": "4", "Title": "Why isn't this unused variable optimised away?", "Id": "47072261", "Score": "38", "Body": "<p>I played around with Godbolt's CompilerExplorer. I wanted to see how good certain optimizations are. My minimum working example is:</p>\n<pre><code>#include &lt;vector&gt;\n\nint foo() {\n    std::vector&lt;int&gt; v {1, 2, 3, 4, 5};\n    return v[4];\n}\n</code></pre>\n<p>The generated assembler (by clang 5.0.0, -O2 -std=c++14):</p>\n<pre><code>foo(): # @foo()\n  push rax\n  mov edi, 20\n  call operator new(unsigned long)\n  mov rdi, rax\n  call operator delete(void*)\n  mov eax, 5\n  pop rcx\n  ret\n</code></pre>\n<p>As one can see, clang knows the answer, but does quite a lot of stuff before returning. It seems to my that even the vector is created, because of \"operator new/delete\".</p>\n<p>Can anyone explain to me what happens here and why it does not just return?</p>\n<p>The code generated by GCC (not copied here) seems to construct the vector explicitly. Does anyone know GCC is not capable to deduce the result?</p>\n", "Tags": "<c++><gcc><clang><compiler-optimization>", "OwnerUserId": "8831116", "AnswerCount": "3"}, "47072594": {"ParentId": "47072261", "PostTypeId": "2", "CommentCount": "4", "Body": "<p><code>std::vector&lt;T&gt;</code> is a fairly complicated class that involves dynamic allocation. While <code>clang++</code> <a href=\"https://godbolt.org/g/84bWMt\" rel=\"noreferrer\">is sometimes able to elide heap allocations</a>, it is a fairly tricky optimization and you should not rely on it. Example:</p>\n<pre><code>int foo() {\n    int* p = new int{5};\n    return *p;\n}\n</code></pre>\n<blockquote id=\"so_47072261_47072594_0\">\n<pre><code>foo():                                # @foo()\n        mov     eax, 5\n        ret\n</code></pre>\n</blockquote>\n<hr>\n<p>As an example, using <code>std::array&lt;T&gt;</code> <em>(which does not dynamically allocate)</em> <a href=\"https://godbolt.org/g/8HHMTK\" rel=\"noreferrer\">produces fully-inlined code</a>:</p>\n<pre><code>#include &lt;array&gt;\n\nint foo() {\n    std::array v{1, 2, 3, 4, 5};\n    return v[4];\n}\n</code></pre>\n<blockquote id=\"so_47072261_47072594_1\">\n<pre><code>foo():                                # @foo()\n        mov     eax, 5\n        ret\n</code></pre>\n</blockquote>\n<hr>\n<p>As <a href=\"https://stackoverflow.com/users/1918193/marc-glisse\">Marc Glisse</a> noted in the other answer's comments, this is what the Standard says in <a href=\"http://eel.is/c++draft/expr.new#10\" rel=\"noreferrer\">[expr.new] #10</a>:</p>\n<blockquote>\n<p id=\"so_47072261_47072594_2\">An implementation is allowed to omit a call to a replaceable global allocation function ([new.delete.single], [new.delete.array]). When it does so, the storage is instead provided by the implementation or provided by extending the allocation of another new-expression. The implementation may extend the allocation of a new-expression e1 to provide storage for a new-expression e2 if the following would be true were the allocation not extended: [...]</p>\n</blockquote>\n</hr></hr>", "OwnerUserId": "598696", "LastEditorUserId": "598696", "LastEditDate": "2017-11-02T11:37:42.177", "Id": "47072594", "Score": "29", "CreationDate": "2017-11-02T10:10:02.547", "LastActivityDate": "2017-11-02T11:37:42.177"}, "bq_ids": {"n4140": {"so_47072261_47072594_2": {"section_id": 6091, "quality": 0.9166666666666666, "length": 33}, "so_47072261_47104045_0": {"section_id": 4240, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_47072261_47104045_0": {"section_id": 4081, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_47072261_47072594_2": {"section_id": 7587, "quality": 0.9166666666666666, "length": 33}, "so_47072261_47104045_0": {"section_id": 5499, "quality": 0.9230769230769231, "length": 12}}}, "47104045": {"ParentId": "47072261", "CommentCount": "3", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html\" rel=\"nofollow noreferrer\">N3664</a>'s change to [expr.new], cited in one answer and one comment, permits <em>new-expression</em>s to not call a replaceable global allocation function. But <code>vector</code> allocates memory using <code>std::allocator&lt;T&gt;::allocate</code>, which calls <code>::operator new</code> directly, not via a <em>new-expression</em>. So that special permission doesn't apply, and generally compilers cannot elide such direct calls to <code>::operator new</code>.</p>\n<p>All hope is not lost, however, for <code>std::allocator&lt;T&gt;::allocate</code>'s specification has <a href=\"https://timsong-cpp.github.io/cppwp/allocator.members#3\" rel=\"nofollow noreferrer\">this</a> to say:</p>\n<blockquote>\n<p id=\"so_47072261_47104045_0\"><em>Remarks:</em> the storage is obtained by calling <code>\u200b::\u200boperator new</code>, but it is unspecified when or how often this function is called.</p>\n</blockquote>\n<p>Leveraging this permission, libc++'s <code>std::allocator</code> <a href=\"https://github.com/llvm-mirror/libcxx/blob/d8b62dceb22903184109eeadb90612bcc17ac367/include/new#L211-L217\" rel=\"nofollow noreferrer\">uses special clang built-ins</a> to indicate to the compiler that elision is permitted. With <code>-stdlib=libc++</code>, <a href=\"https://godbolt.org/g/pefHMb\" rel=\"nofollow noreferrer\">clang compiles your code down to</a></p>\n<pre><code>foo():                                # @foo()\n        mov     eax, 5\n        ret\n</code></pre>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "47104045", "Score": "4", "CreationDate": "2017-11-03T20:35:45.420", "LastActivityDate": "2017-11-03T20:35:45.420"}});