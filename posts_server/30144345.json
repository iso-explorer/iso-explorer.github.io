post_cb({"bq_ids": {"n4140": {"so_30144345_30144441_0": {"length": 42, "quality": 1.0, "section_id": 438}, "so_30144345_30144949_0": {"length": 39, "quality": 0.9069767441860465, "section_id": 441}}, "n3337": {"so_30144345_30144441_0": {"length": 42, "quality": 1.0, "section_id": 429}, "so_30144345_30144949_0": {"length": 39, "quality": 0.9069767441860465, "section_id": 432}}, "n4659": {"so_30144345_30144441_0": {"length": 42, "quality": 1.0, "section_id": 458}, "so_30144345_30144949_0": {"length": 37, "quality": 0.8604651162790697, "section_id": 461}}}, "30144949": {"Id": "30144949", "PostTypeId": "2", "Body": "<p>In either case, calling a member function before base classes are initialized invokes undefined behavior. \u00a712.6.2/16:</p>\n<blockquote>\n<p id=\"so_30144345_30144949_0\">Member functions (including virtual member functions, 10.3) can be\n  called for an object under construction. Similarly, an object under\n  construction can be the operand of the <code>typeid</code> operator (5.2.8) or of a\n  <code>dynamic_cast</code> (5.2.7). <strong>However, if these operations are performed in a\n  <em>ctor-initializer</em> (or in a function called directly or indirectly from a <em>ctor-initializer</em>) before all the <em>mem-initializers</em> for\n  base classes have completed, the result of the operation is\n  undefined.</strong> [ Example:</p>\n<pre><code>class A {\npublic:\n  A(int);\n};\n\nclass B : public A {\n  int j;\npublic:\n  int f();\n  B() : A(f()),  // undefined: calls member function\n                 // but base A not yet initialized\n\n  j(f()) { }    // well-defined: bases are all initialized\n};\n</code></pre>\n</blockquote>\n<p>However, the access of and assignment to <code>b</code> itself is fine, since it has vacuous initialization and its lifetime starts as soon as storage is acquired for it (which happened long before the constructor call started). Hence </p>\n<pre><code>class B : public A {\nprivate:\n  int b;\n\npublic:\n  B() : A(b=0) {}\n};\n</code></pre>\n<p>is well-defined.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-05-09T21:08:48.293", "Score": "6", "CreationDate": "2015-05-09T20:58:09.513", "ParentId": "30144345", "CommentCount": "4", "OwnerUserId": "3647361", "LastEditDate": "2015-05-09T21:08:48.293"}, "30144345": {"ViewCount": "255", "Body": "<p>Consider the following code:</p>\n<pre><code>class A {\nprivate:\n  int a;\n\npublic:\n  A(int a) : a(a) { }\n};\n\nclass B : public A {\nprivate:\n  int b;\n\n  bool init() {\n    b = 0;\n    return true;\n  }\n\npublic:\n  // init() is a hack to initialize b before A()\n  // B() : b(0), A(b) {} yields -Wreorder\n  // B() : A((b = 0)) {} no warning (but this one doesn't work so well with non-pod (pointer) types)\n  B() : A(init() ? b : 0) {}\n};\n</code></pre>\n<p>Now trying to compile this code with clang...</p>\n<pre><code>$ clang++ test.cpp -fsyntax-only\ntest.cpp:19:20: warning: field 'b' is uninitialized when used here [-Wuninitialized]\nB() : A(init() ? b : 0) {}\n                 ^\n1 warning generated.\n</code></pre>\n<p>GCC does not print any warnings, not even with <code>-Wall -Wextra</code> and <code>-pedantic</code>.</p>\n", "AcceptedAnswerId": "30144441", "Title": "Is this undefined behavior or a false positive warning?", "CreationDate": "2015-05-09T19:50:40.480", "Id": "30144345", "CommentCount": "4", "LastEditDate": "2015-05-09T20:11:41.517", "PostTypeId": "1", "LastEditorUserId": "2069064", "LastActivityDate": "2015-05-09T21:08:48.293", "Score": "8", "OwnerUserId": "1392778", "Tags": "<c++><constructor><undefined-behavior><clang++>", "AnswerCount": "2"}, "30144441": {"Id": "30144441", "PostTypeId": "2", "Body": "<p>It's undefined behavior. According to [class.base.init]:</p>\n<blockquote>\n<p id=\"so_30144345_30144441_0\">In a non-delegating constructor, initialization proceeds in the following order:<br>\n  \u2014 First, and only for the constructor of the most derived class (1.8), virtual base classes ...<br>\n  \u2014 Then, <strong>direct base classes are initialized</strong> in declaration order as they appear in the base-specifier-list\n  (regardless of the order of the mem-initializers).<br>\n  \u2014 Then, <strong>non-static data members are initialized</strong> in the order they were declared in the class definition\n  (again regardless of the order of the mem-initializers).</br></br></br></p>\n</blockquote>\n<p><code>b</code> won't have been initialized by the time that the <code>A</code> base class is initialized. The assignment <code>b = 0</code> is itself undefined behavior for the same reason - <code>b</code> hadn't been initialized yet when that is called. Its default constructor would still be called after <code>A</code>'s constructor. </p>\n<p>If you want ensure that <code>b</code> is initialized first, the typical approach is the <a href=\"http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Base-from-Member\" rel=\"noreferrer\">base-from-member idiom</a>:</p>\n<pre><code>struct B_member {\n    int b;\n    B_member() : b(0) { }\n};\n\nclass B : public B_member, public A \n{\npublic:\n    B() : A(b)  // B_member gets initialized first, which initializes b\n                // then A gets initialized using 'b'. No UB here.\n    { };\n};\n</code></pre>\n", "LastActivityDate": "2015-05-09T20:01:52.650", "CommentCount": "12", "CreationDate": "2015-05-09T20:01:52.650", "ParentId": "30144345", "Score": "7", "OwnerUserId": "2069064"}});