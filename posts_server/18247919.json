post_cb({"18247930": {"Id": "18247930", "PostTypeId": "2", "Body": "<p>The problem is in your comparison:</p>\n<pre><code>    if ((-1) &lt; SIZE)\n</code></pre>\n<p><code>sizeof</code> typically returns an <code>unsigned long</code>, so <code>SIZE</code> will be <code>unsigned long</code>, whereas <code>-1</code> is just an <code>int</code>. The rules for promotion in C and related languages mean that -1 will be converted to <code>size_t</code> before the comparison, so <code>-1</code> will become a very large positive value (the maximum value of an <code>unsigned long</code>).</p>\n<p>One way to fix this is to change the comparison to:</p>\n<pre><code>    if (-1 &lt; (long long)SIZE)\n</code></pre>\n<p>although it's actually a pointless comparison, since an unsigned value will always be &gt;= 0 by definition, and the compiler may well warn you about this.</p>\n<p>As subsequently noted by @Nobilis, you should always enable compiler warnings and take notice of them: if you had compiled with e.g. <code>gcc -Wall ...</code> the compiler would have warned you of your bug.</p>\n", "LastEditorUserId": "253056", "LastActivityDate": "2013-08-15T09:07:26.797", "Score": "17", "CreationDate": "2013-08-15T07:15:29.323", "ParentId": "18247919", "CommentCount": "20", "OwnerUserId": "253056", "LastEditDate": "2013-08-15T09:07:26.797"}, "18247972": {"Id": "18247972", "PostTypeId": "2", "Body": "<p>well, i'm not going to repeat the strong words Paul R said, but when you are comparing unsigned and integers you are going to experience dome bad things.</p>\n<p>do <code>if ((-1) &lt; (int)SIZE)</code></p>\n<p>instead of your if condition</p>\n", "LastActivityDate": "2013-08-15T07:18:34.113", "CommentCount": "0", "CreationDate": "2013-08-15T07:18:34.113", "ParentId": "18247919", "Score": "2", "OwnerUserId": "2492977"}, "18247944": {"Id": "18247944", "PostTypeId": "2", "Body": "<p>When you do comparison between <code>signed</code> and <code>unsigned</code> where <code>unsigned</code> has at least an equal rank to that of the <code>signed</code> type (see TemplateRex's answer for the exact rules), the <code>signed</code> is converted to the type of the <code>unsigned</code>. </p>\n<p>With regards to your case, on a 32bit machine the binary representation of <code>-1</code> as <code>unsigned</code> is 4294967295. So in effect you are comparing if 4294967295 is smaller than 8 (it isn't).</p>\n<p>If you had enabled warnings, you would have been warned by the compiler that something fishy is going on:</p>\n<p><code>warning: comparison between signed and unsigned integer expressions [-Wsign-compare]</code></p>\n<p>Since the discussion has shifted a bit on how appropriate the use of <code>unsigned</code> is, let me put a quote by James Gosling with regards to the lack of <code>unsigned</code> types in Java (and I will shamelessly <a href=\"https://stackoverflow.com/questions/17312545/type-conversion-unsigned-to-signed-int-char/17312760#17312760\">link</a> to another post of mine on the subject):</p>\n<blockquote>\n<p id=\"so_18247919_18247944_0\">Gosling: For me as a language designer, which I don't really count\n  myself as these days, what \"simple\" really ended up meaning was could\n  I expect J. Random Developer to hold the spec in his head. That\n  definition says that, for instance, Java isn't -- and in fact a lot of\n  these languages end up with a lot of corner cases, things that nobody\n  really understands. Quiz any C developer about unsigned, and pretty\n  soon you discover that almost no C developers actually understand what\n  goes on with unsigned, what unsigned arithmetic is. Things like that\n  made C complex. The language part of Java is, I think, pretty simple.\n  The libraries you have to look up.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-08-15T10:31:19.453", "Score": "7", "CreationDate": "2013-08-15T07:16:26.790", "ParentId": "18247919", "CommentCount": "5", "OwnerUserId": "1006955", "LastEditDate": "2017-05-23T12:07:25.653"}, "18248537": {"Id": "18248537", "PostTypeId": "2", "Body": "<p>This is an historical design bug of C that was also repeated in C++.</p>\n<p>It dates back to 16-bit computers and the error was deciding to use all 16 bits to represent sizes up to 65536 giving up the possibility to represent negative sizes.</p>\n<p>This in se wouldn't have been an error if <code>unsigned</code> meaning was \"non-negative integer\" (a size cannot logically be negative) but it's a problem with the conversion rules of the language.</p>\n<p>Given the conversion rules of the language the <code>unsigned</code> type in C doesn't represent a non-negative number, but it's instead more like a bitmask (the mathematical term is actually \"<a href=\"http://en.wikipedia.org/wiki/Modular_arithmetic\" rel=\"nofollow noreferrer\">a member of the <code>\u2124/n</code> ring</a>\"). To see why consider that for the C and C++ language</p>\n<ul>\n<li><code>unsigned - unsigned</code> gives an <code>unsigned</code> result</li>\n<li><code>signed + unsigned</code> gives and <code>unsigned</code> result</li>\n</ul>\n<p>both of them clearly make no sense at all if you read <code>unsigned</code> as \"non-negative number\".</p>\n<p>Of course saying that the size of an object is a member of <code>\u2124/n</code> ring doesn't make any sense at all and here it's where the error resides.</p>\n<h1>Practical implications:</h1>\n<p>Every time you deal with the size of an object <strong>be careful</strong> because the value is <code>unsigned</code> and that type in C/C++ has a lot of properties that are illogical for a number. Please always remember that <code>unsigned</code> doesn't mean \"non-negative integer\" but \"member of <code>\u2124/n</code> algebraic ring\" and that, most dangerous, in case of a mixed operation an <code>int</code> is converted to <code>unsigned int</code> and not the opposite.</p>\n<p>For example:</p>\n<pre><code>void drawPolyline(const std::vector&lt;P2d&gt;&amp; pts) {\n    for (int i=0; i&lt;pts.size()-1; i++) {\n        drawLine(pts[i], pts[i+1]);\n    }\n}\n</code></pre>\n<p>is buggy, because if passed an empty vector of points it will do illegal (UB) operations. The reason is that <code>pts.size()</code> is an <code>unsigned</code>.</p>\n<p>The rules of the language will convert <code>1</code> (an integer) to <code>1{mod n}</code>, will perform the subtraction in <code>\u2124/n</code> resulting in <code>(size-1){mod n}</code>, will convert <code>i</code> also to a <code>{mod n}</code> representation and will do the comparison in <code>\u2124/n</code>.</p>\n<p>C/C++ actually defines a <code>&lt;</code> operator in <code>\u2124/n</code> (rarely done in math) and you will end up accessing <code>pts[0]</code>, <code>pts[1]</code> ... and so on until huge numbers even if the input vector was empty.</p>\n<p>A correct loop could be</p>\n<pre><code>void drawPolyline(const std::vector&lt;P2d&gt;&amp; pts) {\n    for (int i=1; i&lt;pts.size(); i++) {\n        drawLine(pts[i-1], pts[i]);\n    }\n}\n</code></pre>\n<p>but I normally prefer</p>\n<pre><code>void drawPolyline(const std::vector&lt;P2d&gt;&amp; pts) {\n    for (int i=0,n=pts.size(); i&lt;n-1; i++) {\n        drawLine(pts[i], pts[i+1]);\n    }\n}\n</code></pre>\n<p>in other words getting rid of <code>unsigned</code> as soon as possible, and just working with regular ints.</p>\n<p>Never use <code>unsigned</code> to represent size of containers or counters because <code>unsigned</code> means \"member of <code>\u2124/n</code>\" and the size of a container is not one of those things. Unsigned types are useful, but <strong>NOT</strong> to represent size of objects.</p>\n<p>The standard C/C++ library unfortunately made this wrong choice, and it's too late to fix it. You are not forced to do the same mistake however.</p>\n<p><a href=\"https://stackoverflow.com/q/10168079/320726\">In the words of Bjarne Stroustrup</a>:</p>\n<blockquote>\n<p id=\"so_18247919_18248537_0\">Using an unsigned instead of an int to gain one more bit to represent\n  positive integers is almost never a good idea. Attempts to ensure that\n  some values are positive by declaring variables unsigned will\n  typically be defeated by the implicit conversion rules</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-09-24T13:46:03.140", "Score": "6", "CreationDate": "2013-08-15T08:02:37.147", "ParentId": "18247919", "CommentCount": "1", "OwnerUserId": "320726", "LastEditDate": "2017-05-23T11:59:08.747"}, "18249553": {"Id": "18249553", "PostTypeId": "2", "Body": "<h2>TL;DR</h2>\n<p>Be careful with mixed signed/unsigned operations (use <code>-Wall</code> compiler warnings). The Standard has a long section about it. In particular, it is often but not always true that signed is value-converted to unsigned (although it does in your particular example). See this explanation below (taken from <a href=\"https://stackoverflow.com/q/17832815/819272\"><strong>this Q&amp;A</strong></a>)</p>\n<h2>Relevant quote from the C++ Standard:</h2>\n<p><strong>5 Expressions [expr]</strong></p>\n<blockquote>\n<p id=\"so_18247919_18249553_0\">10 Many binary operators that expect operands of arithmetic or\n  enumeration type cause conversions and yield result types in a similar\n  way. The purpose is to yield a common type, which is also the type of\n  the result. This pattern is called the usual arithmetic conversions,\n  which are de\ufb01ned as follows:</p>\n</blockquote>\n<p>[2 clauses about equal types or types of equal sign omitted]</p>\n<blockquote>\n<p id=\"so_18247919_18249553_1\">\u2014 Otherwise, if the operand that has unsigned integer type has rank\n  greater than or equal to the rank of the type of the other operand,\n  the operand with signed integer type shall be converted to the type of\n  the operand with unsigned integer type.</p>\n<p id=\"so_18247919_18249553_2\">\u2014 Otherwise, if the type of\n  the operand with signed integer type can represent all of the values\n  of the type of the operand with unsigned integer type, the operand\n  with unsigned integer type shall be converted to the type of the\n  operand with signed integer type. </p>\n<p id=\"so_18247919_18249553_3\">\u2014 Otherwise, both operands shall be\n  converted to the unsigned integer type corresponding to the type of\n  the operand with signed integer type.</p>\n</blockquote>\n<h2>Your actual example</h2>\n<p>To see into which of the 3 cases your program falls, modify it slightly to this</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint arr[] = {1,2,3,4,5,6,7,8};\n#define SIZE (sizeof(arr)/sizeof(int))\n\nint main()\n{\n        printf(\"SIZE = %zu, sizeof(-1) = %zu,  sizeof(SIZE) = %zu \\n\", SIZE, sizeof(-1), sizeof(SIZE));\n        if ((-1) &lt; SIZE)\n                printf(\"less\");\n        else\n                printf(\"more\");\n}\n</code></pre>\n<p>On the Coliru online compiler, this prints 4 and 8 for the <code>sizeof()</code> of <code>-1</code> and <code>SIZE</code>, respectively, and selects the \"more\" branch (<a href=\"http://coliru.stacked-crooked.com/view?id=8e8978cb0b8eebfed533f267141b6338-c96156d6cc95286981b0e9deef2eefae\" rel=\"nofollow noreferrer\"><strong>live example</strong></a>). </p>\n<p>The reason is that the unsigned type is of greater rank than the signed type. Hence, clause 1 applies and the signed type is value-converted to the unsigned type (on most implementation, typically by preserving the bit-representation, so wrapping around to a very large unsigned number), and the comparison then proceeds to select the \"more\" branch.</p>\n<h2>Variations on a theme</h2>\n<p>Rewriting the condition to <code>if ((long long)(-1) &lt; (unsigned)SIZE)</code> would take the \"less\" branch (<a href=\"http://coliru.stacked-crooked.com/view?id=78f8b0d6478dfd05ac503f04cd49e480-c96156d6cc95286981b0e9deef2eefae\" rel=\"nofollow noreferrer\"><strong>live example</strong></a>). </p>\n<p>The reason is that the signed type is of greater rank than the unsigned type and can also accomodate all the unsigned values. Hence, clause 2 applies and the unsigned type is converted to the signed type, and the comparison then proceeds to select the \"less\" branch.</p>\n<p>Of course, you would never write such a contrived <code>if()</code> statement with explicit casts, but the same effect could happen if you compare variables with types <code>long long</code> and <code>unsigned</code>. So it illustrates the point that mixed signed/unsigned arithmetic is very subtle and depends on the relative sizes (\"ranking\" in the words of the Standard). In particular, <strong>there is no fixed rules saying that signed will always be converted to unsigned</strong>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-08-15T09:07:45.007", "Score": "11", "CreationDate": "2013-08-15T09:07:45.007", "ParentId": "18247919", "CommentCount": "1", "OwnerUserId": "819272", "LastEditDate": "2017-05-23T11:52:19.697"}, "18247919": {"ViewCount": "4434", "Body": "<pre><code>#include &lt;stdio.h&gt;\n\nint arr[] = {1,2,3,4,5,6,7,8};\n#define SIZE (sizeof(arr)/sizeof(int))\n\nint main()\n{\n        printf(\"SIZE = %d\\n\", SIZE);\n        if ((-1) &lt; SIZE)\n                printf(\"less\");\n        else\n                printf(\"more\");\n}\n</code></pre>\n<p>The output after compiling with <code>gcc</code> is <code>\"more\"</code>. Why the <code>if</code> condition fails even when <code>-1 &lt; 8</code>?</p>\n", "AcceptedAnswerId": "18247930", "Title": "Why does this if condition fail for comparison of negative and positive integers", "CreationDate": "2013-08-15T07:14:01.457", "Id": "18247919", "CommentCount": "7", "LastEditDate": "2014-09-24T05:29:01.367", "PostTypeId": "1", "LastEditorUserId": "241631", "LastActivityDate": "2014-09-24T13:46:03.140", "Score": "8", "OwnerUserId": "220386", "Tags": "<c++><c><if-statement><comparison><signed>", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_18247919_18249553_0": {"length": 28, "quality": 0.9032258064516129, "section_id": 5943}, "so_18247919_18249553_2": {"length": 25, "quality": 1.0, "section_id": 5943}, "so_18247919_18249553_3": {"length": 13, "quality": 1.0, "section_id": 5943}, "so_18247919_18249553_1": {"length": 23, "quality": 1.0, "section_id": 5943}}, "n3337": {"so_18247919_18249553_0": {"length": 28, "quality": 0.9032258064516129, "section_id": 5714}, "so_18247919_18249553_2": {"length": 25, "quality": 1.0, "section_id": 5714}, "so_18247919_18249553_3": {"length": 13, "quality": 1.0, "section_id": 5714}, "so_18247919_18249553_1": {"length": 23, "quality": 1.0, "section_id": 5714}}, "n4659": {"so_18247919_18249553_0": {"length": 28, "quality": 0.9032258064516129, "section_id": 7428}, "so_18247919_18249553_2": {"length": 25, "quality": 1.0, "section_id": 7428}, "so_18247919_18249553_3": {"length": 13, "quality": 1.0, "section_id": 7428}, "so_18247919_18249553_1": {"length": 23, "quality": 1.0, "section_id": 7428}}}, "18248009": {"Id": "18248009", "PostTypeId": "2", "Body": "<p>Convert the unsigned type returned from sizeof operator  to signed</p>\n<p>when you compare two unsigned and signed number compiler implicitly converts signed to unsigned.<br>\n-1 signed representation in 4 byte int is 11111111 11111111 11111111 11111111 when converted to unsigned this representation would refer to 2^16-1<br>\nSo basically your are comparing that 2^16-1&gt;SIZE, which would be true.<br>\nYou have to override that by explicitly casting the unsigned value to signed.\nSince sizeof operator returns unsigned long long you should cast it to signed long long</br></br></br></p>\n<pre><code>if((-1)&lt;(signed long long)SIZE)\n</code></pre>\n<p>use this if condition in your code</p>\n", "LastEditorUserId": "2669708", "LastActivityDate": "2013-08-15T07:34:50.083", "Score": "-1", "CreationDate": "2013-08-15T07:21:29.740", "ParentId": "18247919", "CommentCount": "0", "OwnerUserId": "2669708", "LastEditDate": "2013-08-15T07:34:50.083"}});