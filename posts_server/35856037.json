post_cb({"35856037": {"CommentCount": "0", "ViewCount": "186", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-03-07T23:15:25.787", "LastActivityDate": "2016-06-13T07:42:19.600", "Title": "Why isn't the noexcept specifier scoped within the declared method?", "FavoriteCount": "0", "LastEditDate": "2017-05-23T11:55:16.547", "Id": "35856037", "Score": "5", "Body": "<p>Trying to design some exception-free classes, I have an inheritance structure similar to this, but I have found the <strong>noexcept</strong> specifier to be of little to no help when working with member functions as the specifier is not scoped as being within the function.</p>\n<pre><code>class Base\n{\nprotected:\n    Base() noexcept {}\n};\n\nclass Derived : public Base\n{\npublic:\n    // error: 'Base::Base()' is protected\n    Derived() noexcept(noexcept(Base{})) : Base{} {}\n\n    // error: 'foo' was not declared in this scope\n    Derived(int) noexcept(noexcept(foo())) {}\n\n    // error: invalid use of 'this' at top level\n    Derived(float) noexcept(noexcept(this-&gt;foo())) {}\n\n    void foo() noexcept {}\n};\n</code></pre>\n<p><a href=\"http://ideone.com/wMoJNf\" rel=\"nofollow noreferrer\">Demo</a></p>\n<p>Is this perhaps something that is being improved in C++17? Trying to search for this has yielded no relevant results. For now I've resigned to some very ugly (and possibly incorrect) attempts such as <code>noexcept(noexcept(static_cast&lt;Derived*&gt;(nullptr)-&gt;foo()))</code>, but this doesn't assist in the case of the base class constructor, which is protected.</p>\n<p>Is it even currently possible to declare a noexcept specifier which references a protected base class method like this? <a href=\"https://stackoverflow.com/questions/30456801/is-there-an-automatic-noexcept-specifier\">noexcept(auto)</a> <em>might</em> be relevant, but of course isn't possible yet. Have I overlooked anything else that would allow me to include this specifier, or do I simply have to omit it in that case?</p>\n", "Tags": "<c++><c++11><noexcept>", "OwnerUserId": "1136311", "AnswerCount": "2"}, "35856870": {"ParentId": "35856037", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>This is really multiple questions in one.</p>\n<h1>About <code>this</code>...</h1>\n<p>From my understanding, the use of <code>this</code> is <em>supposed</em> to be completely superfluous but compiler support for C++11 is not entirely universal.  This should work, according to the C++11 standard:</p>\n<pre><code>struct Base {\n    void func() noexcept;\n};\nstruct Derived() {\n    void func() noexcept(noexcept(Base::func())) {}\n};\n</code></pre>\n<p>Note that <code>base_func()</code> is a non-static member function, but because it appears in an \"unevaluated operand\" it is okay.  From n3337 sec 4.1.1:</p>\n<blockquote>\n<p id=\"so_35856037_35856870_0\">An <em>id-expression</em> that denotes a non-static data member or non-static member function of a class can only be used:</p>\n<p id=\"so_35856037_35856870_1\">...</p>\n<ul>\n<li>if that <em>id-expression</em> denotes a non-static data member and it appears in an unevaluated operand.</li>\n</ul>\n</blockquote>\n<p>However, some compilers do not support this.  You are then forced to use <code>std::declval</code>:</p>\n<pre><code>#include &lt;utility&gt;\nstruct Base {\n    void func() noexcept;\n};\nstruct Derived() {\n    void func() noexcept(noexcept(std::declval&lt;Base&gt;().func())) {}\n};\n</code></pre>\n<h1>About accessibility...</h1>\n<p>I read through the relevant parts of the standard about \"unevaluated operands\" and \"member access control\" and I have come to the conclusion that the standard is a bit ambiguous.  It mentions that a <code>protected</code> name can be <em>used</em> only by members, friends, and derived classes.  The question is whether unevaluated operands \"use\" the member names which appear in them.  They certainly don't <em>odr-use</em> the member names, and can even use member names if no definition is provided, and this kind of ambiguity is exactly why the term \"odr-use\" even exists!  For example,</p>\n<pre><code>int f(); // No definition anywhere in program\nint x = sizeof(f()); // Completely valid, even without definition of f\n\nstruct X {\n    X() = delete; // Cannot use this constructor\n};\nint xsize = sizeof(X{}); // Completely valid\n</code></pre>\n<p>Even though it is somewhat unclear, I have a hard time imagining that the C++ committee could have intended to let you use <em>deleted</em> member functions in unevaluated operands but not inaccessible member functions.  However, I am not certain.</p>\n<p>Note that the above code compiles without error both with GCC and Clang.  However, the following code is does not:</p>\n<pre><code>class X {\n    X(){}\n};\nclass Y {\n    Y() = delete;\n};\nbool xokay = noexcept(X{}); // Error!\nbool yokay = noexcept(Y{}); // Ok\n</code></pre>\n<p>Both GCC and Clang accept Y but not X, which seems a bit <em>weird</em> to say the least.  The following code is accepted by Clang but not GCC, and using <code>std::declval</code> does not help:</p>\n<pre><code>class Base {\nprotected:\n    void func();\n};\nclass Derived : public Base {\n    // Clang accepts this, GCC does not.\n    void func2() noexcept(noexcept(Base::func())) {}\n};\n</code></pre>\n<p>What a mess.</p>\n<h2>Conclusions</h2>\n<p>The conclusion here is that it seems that there is plenty of inconsistency to go around, and plenty of gaps between current compilers and the C++11 specs.</p>\n", "OwnerUserId": "82294", "LastEditorUserId": "82294", "LastEditDate": "2016-06-13T07:42:19.600", "Id": "35856870", "Score": "1", "CreationDate": "2016-03-08T00:38:27.743", "LastActivityDate": "2016-06-13T07:42:19.600"}, "35856448": {"ParentId": "35856037", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You can work around it by using an expression where the Base constructor is in scope like this:</p>\n<pre><code>struct test_base : public Base {};\n\nDerived() noexcept(noexcept(test_base())) : Base() {}\n</code></pre>\n<p>I believe the reason you cannot use <code>Base()</code> directly is <a href=\"https://stackoverflow.com/a/2393495/459615\">related to this question</a>. </p>\n<blockquote>\n<p id=\"so_35856037_35856448_0\">The way protected access specifier works, it allows the derived class\n  B to access the contents of an object of base class A only when that\n  object of class A is a subobject of class B. That means that the only\n  thing you can do in your code is to access the contents of A through\n  B: you can access the members of A through a pointer of type B * (or a\n  reference of type B &amp;). But you cannot access the same members through\n  a pointer of type A * (or reference A &amp;).</p>\n</blockquote>\n<p>It's the same as if you had a member function like this:</p>\n<pre><code>void badfunc()\n{\n    B b;\n}\n</code></pre>\n<p>You're trying to use <code>Base</code>'s constructor directly instead of going <em>through</em> <code>Derived</code>. When you initialize the base in the constructor initialization list, that is a special context that allows you to call the constructor because you're doing it as part of initializing <code>Derived</code>.</p>\n", "OwnerUserId": "459615", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:29:06.880", "Id": "35856448", "Score": "2", "CreationDate": "2016-03-07T23:50:59.697", "LastActivityDate": "2016-03-08T00:39:06.647"}, "bq_ids": {"n4140": {"so_35856037_35856870_0": {"section_id": 5959, "quality": 1.0, "length": 10}}, "n3337": {"so_35856037_35856870_0": {"section_id": 5728, "quality": 1.0, "length": 10}}, "n4659": {"so_35856037_35856870_0": {"section_id": 7440, "quality": 1.0, "length": 10}}}});