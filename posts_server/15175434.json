post_cb({"bq_ids": {"n4140": {"so_15175434_15175495_4": {"length": 40, "quality": 0.975609756097561, "section_id": 87}, "so_15175434_15175495_1": {"length": 5, "quality": 1.0, "section_id": 87}, "so_15175434_15175495_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 87}}, "n3337": {"so_15175434_15175495_4": {"length": 40, "quality": 0.975609756097561, "section_id": 82}, "so_15175434_15175495_1": {"length": 5, "quality": 1.0, "section_id": 82}, "so_15175434_15175495_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 82}}, "n4659": {"so_15175434_15175495_2": {"length": 7, "quality": 0.6363636363636364, "section_id": 90}}}, "15175495": {"Id": "15175495", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15175434_15175495_0\">I can't add a pointer variable (neither constant or static) like</p>\n</blockquote>\n<pre><code>template &lt;&gt; struct s&lt;MyClass *obj &gt; // ERROR\n[...]\n</code></pre>\n<p>You probably have a misconception here. If you are concerned with use cases where you want to provide a pointer to an instance of a user-defined class as a non-type template parameter, then this has nothing to do with template <em>specialization</em>. </p>\n<p>In particular, consider that you <em>can</em> specify a pointer to a <strong>global</strong> instance of your class as a template argument, as per Paragraph 14.3.2/1 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15175434_15175495_1\">A template-argument for a non-type, non-template template-parameter shall be one of:</p>\n<p id=\"so_15175434_15175495_2\">\u2014 for a non-type template-parameter of integral or enumeration type, a converted constant expression\n  (5.19) of the type of the template-parameter; or</p>\n<p id=\"so_15175434_15175495_3\">\u2014 the name of a non-type template-parameter; or</p>\n<p id=\"so_15175434_15175495_4\">\u2014 a constant expression (5.19) that designates <strong>the address of an object with static storage duration and\n  external or internal linkage</strong> or a function with external or internal linkage, including function templates\n  and function template-ids but excluding non-static class members, expressed (ignoring parentheses) as\n  &amp; id-expression, except that the &amp; may be omitted if the name refers to a function or array and shall\n  be omitted if the corresponding template-parameter is a reference; or</p>\n<p id=\"so_15175434_15175495_5\">[...]</p>\n</blockquote>\n<p>This is probably what you were trying to to achieve:</p>\n<pre><code>struct MyClass { };\n\nMyClass c;\n\ntemplate&lt;MyClass* p&gt;\n//       ^^^^^^^^ Non-type template argument \nstruct s\n{\n    // Possibly work with p\n};\n\nint main()\n{\n    s&lt;&amp;c&gt; obj;\n}\n</code></pre>\n<hr>\n<p><strong>ABOUT TEMPLATE SPECIALIZATION</strong>:</p>\n<p>Concerning the code you wrote, your primary template handles <em>any</em> type:</p>\n<pre><code>template &lt;typename T&gt; struct s\n{\n    // Definition...\n};\n</code></pre>\n<p>And this <em>explicit</em> specialization (this is the technical name, not \"total\" specialization) allows you to re-define the content of the primary template when the argument used to instantiate the primary template is <code>MyClass*</code>:</p>\n<pre><code>template &lt;&gt; struct s&lt;MyClass *&gt;\n{\n     // Definition when the template argument is `MyClass*`\n};\n</code></pre>\n<p>For instance, you could do this:</p>\n<pre><code>struct MyClass { };\n\ntemplate &lt;typename T&gt; struct s\n{\n    void print() { cout &lt;&lt; \"Primary template!\" &lt;&lt; endl; }\n};\n\ntemplate &lt;&gt; struct s&lt;MyClass *&gt;\n{\n    void print() { cout &lt;&lt; \"Specialization for MyClass*!\" &lt;&lt; endl; }\n};\n\nint main()\n{\n    s&lt;int&gt; obj;\n    obj.print(); // Will print \"Primary template!\"\n\n    s&lt;MyClass*&gt; obj;\n    obj.print(); // Will print \"Specialization for MyClass*!\"\n}\n</code></pre>\n<p>Also notice, that the definition of the specialized template could be <em>completely different</em> from the definition of the primary template:</p>\n<pre><code>template &lt;typename T&gt; struct s\n{\n    void print() { cout &lt;&lt; \"Primary template!\" &lt;&lt; endl; }\n};\n\ntemplate &lt;&gt; struct s&lt;MyClass *&gt;\n{\n    void greet() { cout &lt;&lt; \"Specialization for MyClass*!\" &lt;&lt; endl; }\n};\n\nint main()\n{\n    s&lt;int&gt; obj;\n    obj.print(); // Will print \"Primary template!\"\n\n    s&lt;MyClass*&gt; obj;\n    obj.greet(); // Will print \"Specialization for MyClass*!\"\n    obj.print(); // ERROR! s&lt;MyClass*&gt; has no `print()` member function\n}\n</code></pre>\n<p>Of course, this is just an example of how class template specialization works. There is nothing useful in differentiating the definition of the primary and the specialized templates the way I've done it.</p>\n<p>However, many real-world use cases for this exist. For instance, a generic algorithm may be optimize and rewritten in a completely different way for some particular type.</p>\n<p>Another important application of template specialization is to define <em>traits</em>, about which you may want to read.</p>\n</hr>", "LastEditorUserId": "1932150", "LastActivityDate": "2013-03-02T14:27:36.173", "Score": "1", "CreationDate": "2013-03-02T14:17:57.760", "ParentId": "15175434", "CommentCount": "0", "OwnerUserId": "1932150", "LastEditDate": "2013-03-02T14:27:36.173"}, "15175434": {"ViewCount": "55", "Body": "<pre><code>template &lt;typename T&gt; struct s\n{\n\n};\n\ntemplate &lt;&gt; struct s&lt;MyClass *&gt;\n{\n\n};\n\n... in main function\nstruct s&lt;MyClass*&gt; obj;\n</code></pre>\n<p>The above code compiles but I really can't see what one could do with the total specialization</p>\n<pre><code>template &lt;&gt; struct s&lt;MyClass *&gt;\n{\n\n};\n</code></pre>\n<p>I can't add a pointer variable (neither constant or static) like</p>\n<pre><code>template &lt;&gt; struct s&lt;MyClass *obj &gt; // ERROR\n{\n\n};\n</code></pre>\n<p>so what's the point in the specialization above? I can't use the MyClass * \"anonymous\" pointer</p>\n", "AcceptedAnswerId": "15175495", "Title": "Class pointer in template parameter - what is this useful to?", "CreationDate": "2013-03-02T14:10:47.810", "Id": "15175434", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-03-02T14:27:36.173", "Score": "0", "OwnerUserId": "1494037", "Tags": "<c++><templates>", "AnswerCount": "2"}, "15175468": {"Id": "15175468", "PostTypeId": "2", "Body": "<p>When you instantiate the template (either implicitly or explicitly), you provide a type:</p>\n<pre><code>s&lt;int&gt; s1;\ns&lt;float&gt; s2;\ns&lt;MyClass&gt; s3;\n</code></pre>\n<p>These objects will each be instantiations of the template <code>s</code> with <code>T</code> deduced to <code>int</code>, <code>float</code>, and <code>MyClass</code> respectively. For example, if <code>s</code> were actually defined like so:</p>\n<pre><code>template &lt;typename T&gt; struct s {\n  T x;\n};\n</code></pre>\n<p>Then the object <code>s1</code> has a member called <code>x</code> of type <code>int</code>, <code>s2</code> has a member called <code>x</code> of type <code>float</code>, and <code>s3</code> has a member called <code>x</code> of type <code>MyClass</code>.</p>\n<p>The point of an explicit specialization as you have given is to provide a different implementation of <code>s</code> when the type passed to the template parameter is a <code>MyClass*</code>, as in:</p>\n<pre><code>s&lt;MyClass*&gt; s4;\n</code></pre>\n<p>For example, consider an explicit specialization that looks like:</p>\n<pre><code>template &lt;&gt; struct s&lt;MyClass*&gt;\n{\n  int x;\n};\n</code></pre>\n<p>The object <code>s4</code> will, despite its template argument being <code>MyClass*</code>, have a member called <code>x</code> of type <code>int</code>. We have specifically said \"When the template argument type is <code>MyClass*</code>, the struct will have a member <code>int x</code>.\"</p>\n<p>This <code>s4</code> object will use the explicit specialization of <code>s</code>, rather than the more general version. Perhaps you can implement your class more efficiently when you know the template argument is a <code>MyClass*</code>.</p>\n", "LastEditorUserId": "150634", "LastActivityDate": "2013-03-02T14:21:44.753", "Score": "0", "CreationDate": "2013-03-02T14:13:58.023", "ParentId": "15175434", "CommentCount": "0", "OwnerUserId": "150634", "LastEditDate": "2013-03-02T14:21:44.753"}});