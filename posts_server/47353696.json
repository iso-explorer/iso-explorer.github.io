post_cb({"47354104": {"ParentId": "47353696", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>The standard says ([expr.delete]/5):</p>\n<blockquote>\n<p id=\"so_47353696_47354104_0\">If the object being deleted has incomplete class type at the point of deletion and the complete class has a non-trivial destructor or a deallocation function, the behavior is undefined.</p>\n</blockquote>\n<p>So if <code>T</code> has a non-trivial destructor or has an <code>operator delete</code> overload, you get UB. Nothing is said about the UB being based on the <em>value</em> of the pointer (ie: whether it's a null pointer or not).</p>\n<hr>\n<h3>On what \"object being deleted\" mean?</h3>\n<p>One could consider that \"object being deleted\" means that this clause only applies to <code>delete</code> calls on actual objects. And therefore, if you pass a null pointer, it does not apply.</p>\n<p>First, the rest of the standard discussion about the behavior of <code>delete</code> explicitly calls out that its behavior does not apply to null pointers. [expr.delete]/6&amp;7 both start with \"If the value of the operand of the delete-expression is not a null pointer value\". Paragraph 5 <em>explicitly</em> does not contain these words. Therefore, we must assume it does apply to null pointers.</p>\n<p>Second, what would the meaning of \"object being deleted\" be if it were passed a null pointer? After all, there is no \"object\" there.</p>\n<p>Well, consider what it means to interpret this text if \"object being deleted\" talks specifically about the object at the end of that pointer. Well, what happens if you're deleting an array of incomplete classes with non-trivial destructors?</p>\n<p>By that logic, this clause <em>does not apply</em>, whether the pointer is null or not. Why? Because the \"object being deleted\" is of an <em>array</em> type, not a class type. And therefore, this clause cannot apply. Which means that a compiler must be able to invoke <code>delete[]</code> on an array of incomplete classes.</p>\n<p>But that's <em>impossible</em> to implement; it would require the compiler to be able to track down code that doesn't exist yet.</p>\n<p>So either the \"object being deleted\" is <em>intended</em> to refer to <code>std::remove_pointer_t&lt;std::decay_t&lt;decltype(expr)&gt;&gt;</code>, or the standard requires behavior that is impossible to implement. The standard wording could probably be cleaned up a bit, replacing \"If the object being deleted has incomplete class type at the point of deletion\" with \"If <code>T</code> is a pointer to <code>U</code> or an array of <code>U</code>, and <code>U</code> has incomplete class type at the point of deletion, ...\" </p>\n</hr>", "OwnerUserId": "734069", "LastEditorUserId": "734069", "LastEditDate": "2017-11-17T17:40:07.460", "Id": "47354104", "Score": "16", "CreationDate": "2017-11-17T15:29:51.343", "LastActivityDate": "2017-11-17T17:40:07.460"}, "47353696": {"CommentCount": "13", "AcceptedAnswerId": "47354104", "PostTypeId": "1", "LastEditorUserId": "63550", "CreationDate": "2017-11-17T15:07:16.700", "LastActivityDate": "2017-11-21T14:53:10.677", "LastEditDate": "2017-11-17T18:20:25.507", "ViewCount": "1311", "FavoriteCount": "3", "Title": "Is it legal to call delete on a null pointer of an incomplete type?", "Id": "47353696", "Score": "16", "Body": "<p>And if so, why does the following code give me the warning</p>\n<blockquote>\n<p id=\"so_47353696_47353696_0\">note: neither the destructor nor the class-specific operator delete will be called, even if they are declared when the class is defined</p>\n</blockquote>\n<p>?</p>\n<pre><code>struct C;\n\nint main()\n{\n    C *c = nullptr;\n\n    delete c;\n\n    return 0;\n}\n</code></pre>\n<p>I <em>understand</em> why it <em>might</em> be undefined behavior in the general case if <code>C</code> has non-trivial/virtual destructors, but doesn't the standard guarantee/define that <code>delete</code> on <code>nullptr</code> is always a <code>noop</code> no matter the situation?</p>\n<p>To reiterate: I'm asking specifically about the case where the pointer to incomplete type is <code>nullptr</code>!</p>\n", "Tags": "<c++><language-lawyer><delete-operator><incomplete-type><nullptr>", "OwnerUserId": "4114447", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_47353696_47354104_0": {"section_id": 6109, "quality": 1.0, "length": 16}}, "n3337": {"so_47353696_47354104_0": {"section_id": 5875, "quality": 1.0, "length": 16}}, "n4659": {"so_47353696_47354104_0": {"section_id": 7606, "quality": 1.0, "length": 16}}}});