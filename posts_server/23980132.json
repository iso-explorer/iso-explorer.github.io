post_cb({"23980152": {"Id": "23980152", "PostTypeId": "2", "Body": "<p>Yes. In general, you need to delete the memory allocated by <code>new</code>.  </p>\n<p><a href=\"http://en.wikipedia.org/wiki/Delete_%28C%2B%2B%29\" rel=\"nofollow\">Wiki</a> says:  </p>\n<blockquote>\n<p id=\"so_23980132_23980152_0\">In the C++ programming language, the <code>delete</code> operator calls the destructor of the given argument, and returns memory allocated by <code>new</code> back to the heap.[1] A call to <code>delete</code> must be made for every call to <code>new</code> to avoid a memory leak.  </p>\n</blockquote>\n<h3>C++11: 3.8 Object lifetime (p4):</h3>\n<blockquote>\n<p id=\"so_23980132_23980152_1\">..... if there is no explicit call to the destructor or if a <em>delete-expression</em> (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and any program that depends on the side effects produced by the destructor has undefined behavior.  </p>\n</blockquote>\n<hr>\n<p><strong>EDIT</strong>: As per the OP's edit, as your destructor is deallocating the memory, <strong>in this case no need to delete the <code>ptr</code> explicitly</strong>. But still need to delete <code>tmpPtr</code> using <code>delete[]</code> operator.</p>\n</hr>", "LastEditorUserId": "2455888", "LastActivityDate": "2014-06-01T13:33:42.110", "Score": "1", "CreationDate": "2014-06-01T13:00:12.180", "ParentId": "23980132", "CommentCount": "6", "OwnerUserId": "2455888", "LastEditDate": "2014-06-01T13:33:42.110"}, "bq_ids": {"n4140": {"so_23980132_23980152_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 7192}}, "n3337": {"so_23980132_23980152_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 6936}}, "n4659": {"so_23980132_23980152_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 8701}}}, "23980132": {"ViewCount": "71", "Body": "<p>In my own string class(just for learning) i have overload of operator +\nDo I need to clean the memory pointed by <code>tmpPtr</code>?</p>\n<pre><code>String String::operator+(const String&amp; rv) const\n{\n    size_t newLength = length + rv.length;\n    char* tmpPtr = new char[newLength + 1];\n    strcpy(tmpPtr, ptr);\n    strcpy(tmpPtr + length, rv.ptr);\n    String S(tmpPtr);\n    delete[] tmpPtr;\n    return S;\n}\n</code></pre>\n<p>Can i change this method this way?</p>\n<pre><code>String String::operator+(const String&amp; rv) const\n{\n    size_t newLength = length + rv.length;\n    char* tmpPtr = new char[newLength + 1];\n    strcpy(tmpPtr, ptr);\n    strcpy(tmpPtr + length, rv.ptr);\n    return S(tmpPtr);\n}\n</code></pre>\n<p>If someone needs a constructor and a destructor:</p>\n<pre><code>String::String(const char* str)\n{\n    setString(str, strlen(str));\n}\n\nString::String(const String&amp; str)\n{\n    setString(str.ptr, str.length);\n}\nvoid String::setString(const char* str, size_t size)\n{\n    ptr = new char[size + 1];\n    strcpy(ptr, str);\n    length = size;\n}\nString::~String()\n{\n    delete[] ptr;\n}\n</code></pre>\n", "Title": "Should I delete the pointer in this case?", "CreationDate": "2014-06-01T12:58:02.710", "LastActivityDate": "2014-06-01T13:33:42.110", "CommentCount": "7", "LastEditDate": "2014-06-01T13:20:57.540", "PostTypeId": "1", "LastEditorUserId": "3225132", "Id": "23980132", "Score": "0", "OwnerUserId": "3225132", "Tags": "<c++>", "AnswerCount": "3"}, "23980381": {"Id": "23980381", "PostTypeId": "2", "Body": "<p>Since your <code>String::setString</code> member function which is invoked by the constructor <code>String::String</code> creates its own char array in dynamic memory and copies the contents of the passed string there:</p>\n<pre><code>void String::setString(const char* str, size_t size)\n{\n    ptr = new char[size + 1];\n    strcpy(ptr, str);\n    length = size;\n}\n</code></pre>\n<p>The originally created memory in <code>String::operator+</code> is no longer required, is stored nowhere and will therefore leak if not deleted. So, yes, you have to <code>delete[]</code> it.</p>\n", "LastActivityDate": "2014-06-01T13:29:20.220", "CommentCount": "0", "CreationDate": "2014-06-01T13:29:20.220", "ParentId": "23980132", "Score": "1", "OwnerUserId": "430766"}, "23980261": {"Id": "23980261", "PostTypeId": "2", "Body": "<p>As Vlad says, it depends on how you implement the constructor.</p>\n<p>If your constructor simply takes ownership of the pointer and then deletes it in the destructor, you do not need a <code>delete[]</code> here.  However, this is problematic, as it means that you cannot safely construct a <code>String</code> instance directly from a string literal.</p>\n<p>Usually, a better way to write the constructor is to copy the contents of the passed-in pointer to a new block of memory and then store a pointer to that.  This means that the memory usage of <code>String</code> is symmetric: it deallocates everything it allocates, and nothing else.  This means that if you <code>new[]</code> something and then pass that pointer to your <code>String</code>'s constructor, you still need to <code>delete[]</code> it. </p>\n<p>However, whichever way it is, neither option is a particularly good fit here.  Instead, you should do something like this:</p>\n<pre><code>String String::operator+(const String&amp; rv) const\n{\n    size_t newLength = length + rv.length;\n    // Create a string with enough backing storage\n    String S(newLength + 1);\n    strcpy(S.ptr, ptr);\n    strcpy(S.Ptr + length, rv.ptr);\n    return S;\n}\n</code></pre>\n<p>This makes sure that it is the <code>String</code> instance managing the memory involved, so you get all the clean-up guarantees you normally get from a constructor/destructor pair.</p>\n<p><strong>Edit</strong>: With the body of the constructor available we can conclude that you took the second approach.  Therefore, if you keep using this approach, you <strong>do</strong> need to <code>delete[]</code> the memory.</p>\n", "LastEditorUserId": "559931", "LastActivityDate": "2014-06-01T13:33:29.767", "Score": "2", "CreationDate": "2014-06-01T13:14:35.943", "ParentId": "23980132", "CommentCount": "3", "OwnerUserId": "559931", "LastEditDate": "2014-06-01T13:33:29.767"}});