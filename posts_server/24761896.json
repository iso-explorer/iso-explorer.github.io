post_cb({"24763545": {"ParentId": "24761896", "CommentCount": "4", "Body": "<p>I may be considered a heathen here but as long as you work on a <code>const reference</code> to the actual <code>string</code> then I don't see any reason not to use <code>const char*</code> into the string's data <em>(as long as you're using c++11)</em>.</p>\n<p>According to <strong>the c++11 standard</strong> the internal data of a <code>std::string</code> must be contiguous and no pointers can be invalidated unless the string is subjected to processes on a non-const reference.</p>\n<blockquote>\n<p id=\"so_24761896_24763545_0\"><strong>21.4.1 basic_string general requirements</strong></p>\n<p id=\"so_24761896_24763545_1\"><strong>5</strong> The char-like objects in a basic_string object shall be stored\n  contiguously. That is, for any basic_string object s, the identity\n  &amp;*(s.begin() + n) == &amp;*s.begin() + n shall hold for all values of n\n  such that 0 &lt;= n &lt; s.size().</p>\n<p id=\"so_24761896_24763545_2\"><strong>6</strong> References, pointers, and iterators referring to the elements of a\n  basic_string sequence may be invalidated by the following uses of that\n  basic_string object:</p>\n<p id=\"so_24761896_24763545_3\"><strong>\u2014</strong> as an argument to any standard library function taking a reference\n  to non-const basic_string as an argument.</p>\n<p id=\"so_24761896_24763545_4\"><strong>\u2014</strong> Calling non-const member functions, except operator[], at, front,\n  back, begin, rbegin, end, and rend.</p>\n</blockquote>\n<p>So rather than use s.data() use &amp;s.begin() to get at the actual internal buffer.</p>\n<p><strong>NOTE:</strong> I am pretty sure these guarantees do not hold for previous versions of the standard.</p>\n", "OwnerUserId": "3807729", "PostTypeId": "2", "Id": "24763545", "Score": "0", "CreationDate": "2014-07-15T16:33:04.327", "LastActivityDate": "2014-07-15T16:33:04.327"}, "24761896": {"CommentCount": "5", "AcceptedAnswerId": "24762613", "PostTypeId": "1", "LastEditorUserId": "4834", "CreationDate": "2014-07-15T15:14:32.563", "LastActivityDate": "2014-07-16T12:39:24.237", "LastEditDate": "2014-07-15T15:55:08.140", "ViewCount": "593", "FavoriteCount": "3", "Title": "In C++11 what is the most performant way to return a reference/pointer to a position in a std::string?", "Id": "24761896", "Score": "7", "Body": "<p>I'm building a text parser that uses <code>std::string</code> as the core storage for strings. </p>\n<p>I know this is not optimal and that parsers inside compilers use optimzed approaches for this. In my project I don't mind losing some performance in exchange for more clarity and easier maintenance.</p>\n<p>At the beginning I read a huge text into memory and then I scan each character to build a ordered set of tokens, its a simple lexer. Currently I'm using <code>std::string</code> to represent the text of a token but I would like to improve this a bit by using a reference/pointer into the original text.</p>\n<p>From what I have read it is a bad practice to return and hold to iterators and it is also a bad practice to refer to the <code>std::string</code> internal buffer. </p>\n<p>Any suggestions on how to accomplish this in a \"clean\" way?</p>\n", "Tags": "<c++><c++11><stdstring>", "OwnerUserId": "1639254", "AnswerCount": "4"}, "24762613": {"ParentId": "24761896", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>There are proposals to add <code>string_view</code> to C++ in an upcoming standard.</p>\n<p>A <code>string_view</code> is a non-owning iterable range over characters with many of the utilities and properties you'd expect of a string class, except you cannot insert/delete characters (and editing characters is often blocked in some subtypes).</p>\n<p>I would advise trying that approach -- write your own (in your own utility namespace).  (You should have your own utility namespace for reusable code snippets anyhow).</p>\n<p>The core data is a pair of <code>char*</code> pr <code>std::string::iterator</code>s (or <code>const</code> versions).  If the user needs a null terminated buffer, a <code>to_string</code> method allocates one.  I would start with non-mutable (<code>const</code>) character data.  Do not forget <code>begin</code> and <code>end</code>: that makes your view iterable with <code>for(:)</code> loops.</p>\n<p>This design has the danger that the original <code>std::string</code> has to persist long enough to outlast all of the views.</p>\n<p>If you are willing to give up some performance for safety, have the view own a <code>std::shared_ptr&lt;const std::string&gt;</code> that it can move a <code>std::string</code> into, and as a first step move the entire buffer into it, and then start chopping/parsing it down.  (child views make a new shared pointer to same data).  Then your view class is more like a non-mutable string with shared storage.</p>\n<p>The upsides to the <code>shared_ptr&lt;const&gt;</code> version include safety, longer lifetime of the views (there is no more lifetime dependency), and you can easily forward your <code>const</code> \"substring\" type methods to the <code>std::string</code> so you can write less code.</p>\n<p>Downsides include possible incompatibility with incoming standard one<sup>1</sup>, and lower performance because you are dragging a <code>shared_ptr</code> around.</p>\n<p>I suspect views and ranges are going to be increasingly important in modern C++ with the upcoming and recent improvements to the language.</p>\n<p><a href=\"http://www.boost.org/doc/libs/1_55_0/libs/utility/doc/html/string_ref.html\" rel=\"noreferrer\"><code>boost::string_ref</code></a> is apparently an implementation of a proposal to the C++1y standard.</p>\n<hr>\n<p><sup>1</sup> however, given how simple it is to add capabilities in template metaprogramming, having a \"resource owner\" template argument to a view type might be a good design decision.  Then you can have owning and non-owning <code>string_view</code>s with otherwise identical semantics...</p>\n</hr>", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2014-07-16T12:39:24.237", "Id": "24762613", "Score": "10", "CreationDate": "2014-07-15T15:47:01.580", "LastActivityDate": "2014-07-16T12:39:24.237"}, "24761969": {"ParentId": "24761896", "CommentCount": "0", "Body": "<p>Returning and using iterators is not a bad practice. Of course assuming that you are not modifying the input buffer, but it does not look like you are.</p>\n", "OwnerUserId": "2382136", "PostTypeId": "2", "Id": "24761969", "Score": "4", "CreationDate": "2014-07-15T15:17:38.517", "LastActivityDate": "2014-07-15T15:17:38.517"}, "bq_ids": {"n4140": {"so_24761896_24763545_2": {"section_id": 1567, "quality": 1.0, "length": 13}, "so_24761896_24763545_3": {"section_id": 1567, "quality": 1.0, "length": 8}, "so_24761896_24763545_4": {"section_id": 1567, "quality": 1.0, "length": 12}, "so_24761896_24763545_1": {"section_id": 1566, "quality": 0.7777777777777778, "length": 14}}, "n3337": {"so_24761896_24763545_2": {"section_id": 1562, "quality": 1.0, "length": 13}, "so_24761896_24763545_3": {"section_id": 1562, "quality": 1.0, "length": 8}, "so_24761896_24763545_4": {"section_id": 1562, "quality": 1.0, "length": 12}, "so_24761896_24763545_1": {"section_id": 1561, "quality": 0.7777777777777778, "length": 14}}, "n4659": {"so_24761896_24763545_3": {"section_id": 1716, "quality": 1.0, "length": 8}, "so_24761896_24763545_2": {"section_id": 1716, "quality": 1.0, "length": 13}, "so_24761896_24763545_4": {"section_id": 1716, "quality": 1.0, "length": 12}}}, "24762947": {"ParentId": "24761896", "CommentCount": "0", "Body": "<p>Some through here:</p>\n<p>-Internal representation of the string live the same time that the string himself, if you save pointer or iterators to the string to use latter (ex: print reports, postprocessing etc...) to the scope of the string your would face invalid memory access. Normally in this type of processing the text live all the time of the process.<br>\n-Iterators is a good choices (for extreme performance and generality I suggest use of const raw pointer <code>const char*</code>, because the origin could be almost anything, string, buffer, mapped buffer, readed data from stream, etc...)<br>\n-A good practice is instead of copying the tokens, save a pair (token begin iterator, token end iterator) in a collection of tokens.<br>\n-It is imperative for performance trying not to make a lot of allocations (alloc is one of the most expensive operation in any language)</br></br></br></p>\n<p>You could check lexertl (for more ideas or for use it): <a href=\"http://www.benhanson.net/lexertl.html\">http://www.benhanson.net/lexertl.html</a> and spirit (more complete): <a href=\"http://www.boost.org/doc/libs/release/libs/spirit/\">http://www.boost.org/doc/libs/release/libs/spirit/</a></p>\n", "OwnerUserId": "3837231", "PostTypeId": "2", "Id": "24762947", "Score": "6", "CreationDate": "2014-07-15T16:01:56.507", "LastActivityDate": "2014-07-15T16:01:56.507"}});