post_cb({"46142373": {"ParentId": "46088363", "CommentCount": "0", "Body": "<p>You need a <code>std::unique_lock</code> when using <code>std::condition_variable</code> for the same reason you need a <code>std::FILE*</code> when using <code>std::fwrite</code> and for the same reason a <code>BasicLockable</code> is necessary when using <code>std::unique_lock</code> itself.</p>\n<p>The feature <code>std::fwrite</code> gives you, entire the reason it exists, is to write to files. So you have to give it a file. The feature <code>std::unique_lock</code> provides you is RAII locking and unlocking of a mutex (or another <code>BasicLockable</code>, like <code>std::shared_mutex</code>, etc.) so you have to give it something to lock and unlock.</p>\n<p>The feature <code>std::condition_variable</code> provides, <em>the entire reason it exists</em>, is the atomically waiting and unlocking a lock (and completing a wait and locking). So you have to give it something to lock.</p>\n<hr>\n<p><em>Why</em> would someone want that is a separate question that has been discussed already. For example:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/12551341/when-is-a-condition-variable-needed-isnt-a-mutex-enough\">When is a condition variable needed, isn't a mutex enough?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/3513045/conditional-variable-vs-semaphore\">Conditional Variable vs Semaphore</a></li>\n<li><a href=\"https://stackoverflow.com/questions/4742196/advantages-of-using-condition-variables-over-mutex\">Advantages of using condition variables over mutex</a></li>\n</ul>\n<p>And so on.</p>\n<hr>\n<p>As has been explained, the <code>pred</code> parameter is optional, but having some sort of a predicate and testing it isn't. Or, in other words, not having a predicate doesn't make any sense inn a manner similar to how having a condition variable without a lock doesn't making any sense.</p>\n<p>The reason you have a lock is because you have shared state you need to protect from simultaneous access. Some function of that shared state <em>is</em> the predicate.</p>\n<p>If you don't have a predicate and you don't have a lock you really don't need a condition variable just like if you don't have a file you really don't need <code>fwrite</code>.</p>\n<hr>\n<p>A final point is that the second code snippet you wrote is very broken. Obviously it won't compile as you define the lock after you try to pass it as an argument to <code>condition_variable::wait()</code>. You probably meant something like:</p>\n<pre><code>std::mutex mtx_cv;\nstd::condition_variable cv;\n\n...\n\n{\n    std::unique_lock&lt;std::mutex&gt; lk(mtx_cv);\n    cv.wait(lk);\n    lk.lock();    // throws std::system_error with an error code of std::errc::resource_deadlock_would_occur\n}\n</code></pre>\n<p>The reason this is wrong is very simple. <code>condition_variable::wait</code>'s effects are (from <a href=\"http://eel.is/c++draft/thread.condition.condvar\" rel=\"nofollow noreferrer\">[thread.condition.condvar]</a>):</p>\n<blockquote>\n<p id=\"so_46088363_46142373_0\"><em>Effects:</em><br>\n  \u2014 Atomically calls lock.unlock() and blocks on *this.<br>\n  \u2014 When unblocked, <strong>calls lock.lock()</strong> (possibly blocking on the lock), <strong>then returns</strong>.<br>\n  \u2014 The function will unblock when signaled by a call to notify_one() or a call to notify_all(), or spuriously</br></br></br></p>\n</blockquote>\n<p>After the return from <code>wait()</code> the lock is locked, and <code>unique_lock::lock()</code> throws an exception if it has already locked the mutex it wraps (<a href=\"http://eel.is/c++draft/thread.lock.unique.locking\" rel=\"nofollow noreferrer\">[thread.lock.unique.locking]</a>).</p>\n<p>Again, <em>why</em> would someone want coupling waiting and locking the way <code>std::condition_variable</code> does is a separate question, but given that it does - you cannot, <em>by definition</em>, lock a <code>std::condition_variable</code>'s <code>std::unique_lock</code> after <code>std::condition_variable::wait</code> has returned.</p>\n</hr></hr></hr>", "OwnerUserId": "306930", "PostTypeId": "2", "Id": "46142373", "Score": "0", "CreationDate": "2017-09-10T15:26:41.417", "LastActivityDate": "2017-09-10T15:26:41.417"}, "46090494": {"ParentId": "46088363", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It's not stated in the documentation (and could be implemented differently) but conceptually you can imagine the condition variable has another mutex to both protect its own data but also coordinate the condition, waiting and notification with modification of the consumer code data (e.g. <code>queue.size()</code>) affecting the test.</p>\n<p>So when you call <code>wait(...)</code> the following (logically) happens.</p>\n<ol>\n<li>Precondition: The consumer code holds the lock (CCL) controlling the consumer condition data (CCD).</li>\n<li>The condition is checked, if true, execution in the consumer code continues still holding the lock.</li>\n<li>If false, it first acquires its own lock (CVL), adds the current thread to the waiting thread collection releases the consumer lock and puts itself to waiting and releases its own lock (CVL). </li>\n</ol>\n<p>That final step is tricky because it needs to sleep the thread and release the CVL at the same time or in that order or in a way that threads notified just before going to wait are able to (somehow) not go to wait.  </p>\n<p>The step of acquiring the CVL before releasing the CCD is key. Any parallel thread trying to update the CCD and notify will be blocked <strong>either</strong> by the CCL or CVL. If the CCL was released before acquiring the CVL a parallel thread could acquire the CCL, change the data and then notify before the the to-be-waiting thread is added to the waiters.</p>\n<p>A parallel thread acquires the CCL, modifies the data to make the condition true (or at least worth testing) and then notifies. Notification acquires the the CVL and identifies a blocked thread (or threads) if any to unwait. The unwaited threads then seek to acquire the CCL and may block there but won't leave wait and re-perform the test until they've acquired it.</p>\n<p>Notification must acquire the CVL to make sure threads that have found the test false have been added to the waiters.</p>\n<p>It's OK (possibly preferable for performance) to notify without holding the CCL because the hand-off between the CCL and CVL in the wait code is ensuring the ordering.\nIt may be preferrable because notifying when holding the CCL may mean all the unwaited threads just unwait to block (on the CCL) while the thread modifying the data is still holding the lock. </p>\n<p>Notice that even if the CCD is atomic you must modify it holding the CCL or that Lock CVL, unlock CCL step won't ensure the total ordering required to make sure notifications aren't sent when threads are in the process of going to wait.</p>\n<p>The standard only talks about atomicity of operations and another implementation may have a way of blocking notification before completing the 'add to waiters' step has completed following a failed test. The C++ Standard is careful to not dictate an implementation.</p>\n<p>In all that, to answer some of the specific questions.</p>\n<p><strong>Must the state be shared?</strong> Sort of. There could be an external condition like a file being in a directory and the wait is timed to re-try after a time-period. You can decide for yourself whether you consider the file system or even just the wall-clock to be shared state.</p>\n<p><strong>Must there be any state?</strong> Not necessarily. A thread can wait on notification.\nThat could be tricky to coordinate because there has to be enough sequencing to stop the other thread notifying out of turn. The commonest solution is to have some boolean flag set by the notifying thread so the notified thread knows if it missed it. The normal use of <code>void wait(std::unique_lock&lt;std::mutex&gt;&amp; lk)</code> is when the predicate is checked outside:</p>\n<pre><code>std::unique_lock&lt;std::mutex&gt; ulk(ccd_mutex)\nwhile(!condition){\n    cv.wait(ulk);\n}\n</code></pre>\n<p>Where the notifying thread uses:</p>\n<pre><code>{\n    std::lock_guard&lt;std::mutex&gt; guard(ccd_mutex);\n    condition=true;\n}\ncv.notify();\n</code></pre>\n", "OwnerUserId": "4213662", "LastEditorUserId": "4213662", "LastEditDate": "2017-09-07T13:16:38.320", "Id": "46090494", "Score": "0", "CreationDate": "2017-09-07T07:33:25.113", "LastActivityDate": "2017-09-07T13:16:38.320"}, "46088363": {"CommentCount": "7", "ViewCount": "122", "CreationDate": "2017-09-07T05:18:41.527", "LastActivityDate": "2017-09-10T15:26:41.417", "Title": "why does std::condition_variable::wait need mutex?", "PostTypeId": "1", "Id": "46088363", "Score": "2", "Body": "<h3>TL;DR</h3>\n<p>Why does <a href=\"http://en.cppreference.com/w/cpp/thread/condition_variable/wait\" rel=\"nofollow noreferrer\">std::condition_variable::wait</a> needs a mutex as one of its variables?</p>\n<hr>\n<h3>Answer 1</h3>\n<p>You may look a the documentation and quote that:</p>\n<pre><code> wait... Atomically releases lock\n</code></pre>\n<p>But that's not a real reason. That's just validate my question even more: why does it need it in the first place?</p>\n<h3>Answer 2</h3>\n<p>predicate is most likely query the state of a shared resource and it must be lock guarded.</p>\n<p>OK. fair. \nTwo questions here</p>\n<ol>\n<li>Is it always true that <em>predicate query the state of a shared resource</em>? I assume yes. I t doesn't make sense to me to implement it otherwise</li>\n<li>What if I do not pass any predicate (it is optional)?</li>\n</ol>\n<h3>Using predicate - lock makes sense</h3>\n<pre><code>int i = 0;\nvoid waits()\n{\n    std::unique_lock&lt;std::mutex&gt; lk(cv_m);\n    cv.wait(lk, []{return i == 1;});\n    std::cout &lt;&lt; i;\n}\n</code></pre>\n<h3>Not Using predicate - why can't we lock after the wait?</h3>\n<pre><code>int i = 0;\nvoid waits()\n{\n    cv.wait(lk);\n    std::unique_lock&lt;std::mutex&gt; lk(cv_m);\n    std::cout &lt;&lt; i;\n}\n</code></pre>\n<h3>Notes</h3>\n<p>I know that there are no harmful implications to this practice. I just don't know how to explain to my self why it was design this way?</p>\n<h3>Question</h3>\n<p>If predicate is optional and is not passed to <code>wait</code>, why do we need the lock?</p>\n</hr>", "Tags": "<multithreading><c++11><mutex><wait><condition-variable>", "OwnerUserId": "1798187", "AnswerCount": "3"}, "46088977": {"ParentId": "46088363", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>When using a condition variable to wait for a condition, a thread performs the following sequence of steps:</p>\n<ol>\n<li>It determines that the condition is not currently true.</li>\n<li>It starts waiting for some other thread to make the condition true. This is the <code>wait</code> call.</li>\n</ol>\n<p>For example, the condition might be that a queue has elements in it, and a thread might see that the queue is empty and wait for another thread to put things in the queue.</p>\n<p>If another thread were to intercede between these two steps, it could make the condition true and notify on the condition variable before the first thread actually starts waiting. In this case, the waiting thread would not receive the notification, and it might never stop waiting.</p>\n<p>The purpose of requiring the lock to be held is to prevent other threads from interceding like this. Additionally, the lock must be unlocked to allow other threads to do whatever we're waiting for, but it can't happen before the <code>wait</code> call because of the notify-before-wait problem, and it can't happen after the <code>wait</code> call because we can't do anything while we're waiting. It has to be part of the <code>wait</code> call, so <code>wait</code> has to know about the lock.</p>\n<p>Now, you might look at the <code>notify_*</code> methods and notice that <em>those</em> methods don't require the lock to be held, so there's nothing actually stopping another thread from notifying between steps 1 and 2. However, a thread calling <code>notify_*</code> is supposed to hold the lock while performing whatever action it does to make the condition true, which is usually enough protection.</p>\n", "OwnerUserId": "2357112", "LastEditorUserId": "2357112", "LastEditDate": "2017-09-07T06:24:17.097", "Id": "46088977", "Score": "0", "CreationDate": "2017-09-07T06:09:39.840", "LastActivityDate": "2017-09-07T06:24:17.097"}, "bq_ids": {"n4140": {"so_46088363_46142373_0": {"section_id": 2996, "quality": 0.92, "length": 23}}, "n3337": {"so_46088363_46142373_0": {"section_id": 2866, "quality": 0.92, "length": 23}}, "n4659": {"so_46088363_46142373_0": {"section_id": 3755, "quality": 0.92, "length": 23}}}});