post_cb({"15863664": {"Id": "15863664", "PostTypeId": "2", "Body": "<p>You already know that gcc can optimize a tail-recursive function into a loop. The other thing that gcc can do (and is mentioned in your link) is try to optimize a non-tail-recursive function into a tail-recursive function.</p>\n<p>Your factorial function is here:</p>\n<pre><code>int factorial(int x) {\n   if (x &gt; 1) return x * factorial(x-1);\n   else return 1;\n}\n</code></pre>\n<p>Now I'm going to try to make as few changes as possible and rewrite this as tail-recursive. First, I'll flip the if test:</p>\n<pre><code>int factorial(int x) {\n   if (!(x &gt; 1)) return 1;\n   else return x * factorial(x-1);\n}\n</code></pre>\n<p>Next, I'll remove the unneeded <code>else</code>:</p>\n<pre><code>int factorial(int x) {\n   if (!(x &gt; 1)) return 1;\n   return x * factorial(x-1);\n}\n</code></pre>\n<p>This is almost tail-recursive, but it is returning <code>x * factorial()</code> and not just <code>factorial()</code>. The typical way to make this tail recursive is to include a second parameter, which is an accumulator.</p>\n<pre><code>int factorial(int x, int accumulator = 1) {\n   if (!(x &gt; 1)) return accumulator;\n   return factorial(x - 1, x * accumulator);\n}\n</code></pre>\n<p>Now this is a tail-recursive function, and it can be optimized into a loop.</p>\n", "LastEditorUserId": "240313", "LastActivityDate": "2013-04-07T21:33:09.950", "Score": "4", "CreationDate": "2013-04-07T14:46:52.780", "ParentId": "15863421", "CommentCount": "4", "LastEditDate": "2013-04-07T21:33:09.950", "OwnerUserId": "240313"}, "15863504": {"Id": "15863504", "PostTypeId": "2", "Body": "<p>The compiler could transform that code into something tail-call optimisable by putting the multiplication before the recursive function call:</p>\n<pre><code>int factorial(int x) {\n    return factorial_tail_call(x, 1);\n}\n\nint factorial_tail_call(int x, int result) {\n    if (x &gt; 1) return factorial_tail_call(x-1, result*x);\n    return result;\n}\n</code></pre>\n<p>By performing the evaluation of <code>result*x</code> before <code>factorial_tail_call</code> is called recursively, the compiler can determine that <code>x</code> and <code>result</code> are no longer needed. Hence, it can pop them from the stack. This forms proof that the stack <em>doesn't</em> need to grow.</p>\n<p>Can you see any resemblance between the transformed-to code? The <code>1</code> is in the same place, the condition <code>x &gt; 1</code> is in the same place and <code>return result;</code> is in the same place. It's all just a different way of expressing the same algorithm, providing the compiler implements tail call optimisation. By moving the multiplication expression into an argument and putting in comments the code from your post to the right, you might be able to see some resemblance of functionality, and how the compiler managed to make the remainder of the transformation:</p>\n<pre><code>int factorial(int x) {\n    return factorial_tail_call(x, 1);                     // int result = 1;\n}\n\nint factorial_tail_call(int x, int result) {\n    if (x &gt; 1) return factorial_tail_call(x-1, result*x); // while (x &gt; 1) result *= x--;\n    return result;                                        // return result;\n}\n</code></pre>\n<p><strong>\u00a75.1.2.3p4 of n1570.pdf</strong></p>\n<blockquote>\n<p id=\"so_15863421_15863504_0\">In the abstract machine, all expressions are evaluated as specified by\n  the semantics. An actual implementation need not evaluate part of an\n  expression if it can deduce that its value is not used and that no\n  needed side effects are produced (including any caused by calling a\n  function or accessing a volatile object).</p>\n</blockquote>\n<p>Compilers are smart things, written by far better programmers than most of us. If the compiler can figure out that two pieces of code are equivalent, then it can choose whichever of the two it wishes (with some restrictions, described in the quotation below). For example, it could replace a loop that calculates and prints the first thousand primes with a single <code>printf</code> expression. </p>\n<p><strong>\u00a75.1.2.3p6 of n1570.pdf</strong></p>\n<blockquote>\n<p id=\"so_15863421_15863504_1\">The least requirements on a conforming implementation are:</p>\n<p id=\"so_15863421_15863504_2\">\u2014 Accesses to volatile objects are evaluated strictly according to the\n  rules of the abstract machine.</p>\n<p id=\"so_15863421_15863504_3\">\u2014 At program termination, all data written into files shall be\n  identical to the result that execution of the program according to the\n  abstract semantics would have produced.</p>\n<p id=\"so_15863421_15863504_4\">\u2014 The input and output dynamics of interactive devices shall take\n  place as specified in 7.21.3. The intent of these requirements is that\n  unbuffered or line-buffered output appear as soon as possible, to\n  ensure that prompting messages actually appear prior to a program\n  waiting for input.</p>\n<p id=\"so_15863421_15863504_5\">This is the observable behavior of the program.</p>\n</blockquote>\n<p>That's one reason why micro-optimisation is futile.</p>\n<p>If another thread modifyies a string that strlen is processing, that's a race condition. Race conditions are undefined behaviour. You need to guard the string with a mutex to ensure this doesn't happen, or learn better multi-threading paradigms. Which book are you reading?</p>\n<p><strong>\u00a75.1.2.4p25 of n1570.pdf</strong></p>\n<blockquote>\n<p id=\"so_15863421_15863504_6\">The execution of a program contains a data race if it contains two\n  conflicting actions in different threads, at least one of which is not\n  atomic, and neither happens before the other. Any such data race\n  results in undefined behavior.</p>\n</blockquote>\n", "LastEditorUserId": "1989425", "LastActivityDate": "2013-04-07T15:08:58.090", "Score": "4", "CreationDate": "2013-04-07T14:31:26.697", "ParentId": "15863421", "CommentCount": "5", "LastEditDate": "2013-04-07T15:08:58.090", "OwnerUserId": "1989425"}, "bq_ids": {"n4140": {"so_15863421_15863504_6": {"length": 20, "quality": 0.8, "section_id": 5834}, "so_15863421_15863504_1": {"length": 4, "quality": 0.8, "section_id": 5804}, "so_15863421_15863504_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 5804}, "so_15863421_15863504_0": {"length": 15, "quality": 0.5357142857142857, "section_id": 5797}, "so_15863421_15863504_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 5804}}, "n3337": {"so_15863421_15863504_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 5577}, "so_15863421_15863504_6": {"length": 22, "quality": 0.88, "section_id": 5605}, "so_15863421_15863504_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 5577}, "so_15863421_15863504_0": {"length": 15, "quality": 0.5357142857142857, "section_id": 5570}, "so_15863421_15863504_1": {"length": 4, "quality": 0.8, "section_id": 5577}}, "n4659": {"so_15863421_15863504_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 7262}, "so_15863421_15863504_6": {"length": 20, "quality": 0.8, "section_id": 7296}, "so_15863421_15863504_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 7262}, "so_15863421_15863504_0": {"length": 15, "quality": 0.5357142857142857, "section_id": 7256}, "so_15863421_15863504_1": {"length": 4, "quality": 0.8, "section_id": 7262}}}, "15863421": {"ViewCount": "1193", "Body": "<p>I found a interesting quize today about gcc <a href=\"http://ridiculousfish.com/blog/posts/will-it-optimize.html\" rel=\"nofollow\">http://ridiculousfish.com/blog/posts/will-it-optimize.html</a></p>\n<p>How come this code</p>\n<pre><code>int factorial(int x) {\n   if (x &gt; 1) return x * factorial(x-1);\n   else return 1;\n}\n</code></pre>\n<p>can be translated by compiler into</p>\n<pre><code>int factorial(int x) {\n   int result = 1;\n   while (x &gt; 1) result *= x--;\n   return result;\n}\n</code></pre>\n<p>Also optimizing strlen() by default is really bizarre for me. What if other thread modifies the string?</p>\n", "Title": "gcc optimization of recursive functions", "CreationDate": "2013-04-07T14:21:09.030", "LastActivityDate": "2013-04-07T21:33:09.950", "CommentCount": "4", "PostTypeId": "1", "ClosedDate": "2013-04-07T21:36:20.560", "Id": "15863421", "Score": "3", "OwnerUserId": "336186", "Tags": "<c++><c><optimization><gcc><recursion>", "AnswerCount": "2"}});