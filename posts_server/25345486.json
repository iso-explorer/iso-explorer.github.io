post_cb({"bq_ids": {"n4140": {"so_25345486_25345871_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 4701}, "so_25345486_25345486_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 4695}}, "n3337": {"so_25345486_25345871_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 4510}, "so_25345486_25345486_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 4504}}, "n4659": {"so_25345486_25345871_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 6097}, "so_25345486_25345486_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 6090}}}, "25345871": {"Id": "25345871", "PostTypeId": "2", "Body": "<p>For the primary type categories, which <code>is_floating_point</code> is one, there is a design invariant:</p>\n<blockquote>\n<p id=\"so_25345486_25345871_0\">For any given type <code>T</code>, exactly one of the primary type categories has\n  a value member that evaluates to <code>true</code>.</p>\n</blockquote>\n<p>Reference: (20.10.4.1 Primary type categories [meta.unary.cat])</p>\n<p>Programmers can rely on this invariant in generic code when inspecting some unknown generic type <code>T</code>:  I.e. if <code>is_class&lt;T&gt;::value</code> is <code>true</code>, then we don't need to check <code>is_floating_point&lt;T&gt;::value</code>.  We are guaranteed the latter is <code>false</code>.</p>\n<p>Here is a diagram\nrepresenting the primary and composite type traits (the leaves at the top of this diagram are the primary categories).</p>\n<p><a href=\"http://howardhinnant.github.io/TypeHiearchy.pdf\" rel=\"nofollow\">http://howardhinnant.github.io/TypeHiearchy.pdf</a></p>\n<p>If it was allowed to have (for example) <code>std::complex&lt;double&gt;</code> answer true to both <code>is_class</code> and <code>is_floating_point</code>, this useful invariant would be broken.  Programmers would no longer be able to rely on the fact that if <code>is_floating_point&lt;T&gt;::value == true</code>, then <code>T</code> must be one of <code>float</code>, <code>double</code>, or <code>long double</code>.</p>\n<p>Now there are some traits, where the standard does \"say otherwise\", and specializations on user-defined types are allowed.  <code>common_type&lt;T, U&gt;</code> is such a trait.</p>\n<p>For the primary and composite type traits, there are no plans to relax the restriction of specializing these traits.  Doing so would compromise the ability of these traits to precisely and uniquely classify every single type that can be generated in C++.</p>\n", "LastEditorUserId": "576911", "LastActivityDate": "2014-09-21T20:13:37.713", "Score": "10", "CreationDate": "2014-08-17T02:41:28.157", "ParentId": "25345486", "CommentCount": "3", "OwnerUserId": "576911", "LastEditDate": "2014-09-21T20:13:37.713"}, "25345486": {"ViewCount": "264", "Body": "<h2>Discussion</h2>\n<p>According to the standard <em>\u00a720.10.2/1 Header <code>&lt;type_traits&gt;</code> synopsis [meta.type.synop]:</em></p>\n<blockquote>\n<p id=\"so_25345486_25345486_0\"><code>1</code> The behavior of a program that adds specializations for any of the class templates defined in this subclause is undefined unless otherwise specified.</p>\n</blockquote>\n<p>This specific clause contradicts to the general notion that STL should be expandible and prevents us from expanding type traits as in the example below:</p>\n<pre><code>namespace std {\ntemplate&lt; class T &gt;\nstruct is_floating_point&lt;std::complex&lt;T&gt;&gt; : std::integral_constant\n         &lt;\n         bool,\n         std::is_same&lt;float, typename std::remove_cv&lt;T&gt;::type&gt;::value  ||\n         std::is_same&lt;double, typename std::remove_cv&lt;T&gt;::type&gt;::value ||\n         std::is_same&lt;long double, typename std::remove_cv&lt;T&gt;::type&gt;::value\n         &gt; {};\n}\n</code></pre>\n<p><a href=\"http://ideone.com/uNdZ2R\" rel=\"nofollow\"><kbd><strong>LIVE DEMO</strong></kbd></a></p>\n<p>where <code>std::is_floating_point</code> is expanded to handle <code>complex</code> number with underlying floating point type as well.</p>\n<h2>Questions</h2>\n<ol>\n<li>What are the reasons that made the standardization committee decide that type-traits should not be specialized.</li>\n<li>Are there any future plans for this restriction to be retracted.</li>\n</ol>\n", "AcceptedAnswerId": "25345871", "Title": "Why specializing a type_trait could result in undefined behaviour?", "CreationDate": "2014-08-17T01:19:29.907", "Id": "25345486", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-08-17T01:37:45.807", "LastEditorUserId": "2756719", "LastActivityDate": "2014-09-21T20:13:37.713", "Score": "5", "OwnerUserId": "2352671", "Tags": "<c++><c++11><language-lawyer><undefined-behavior><c++14>", "AnswerCount": "2"}, "25351825": {"Id": "25351825", "PostTypeId": "2", "Body": "<p>Adding to Howard's answer (with an example).</p>\n<p>If users were allowed to specialize type traits they could lie (intentionally or by mistake) and the Standard Library could no longer assure that its behavior is correct.</p>\n<p>For instance, when an object of type <code>std::vector&lt;T&gt;</code> is copied an optimization that popular implementations do is calling <code>std::memcpy</code> to copy all elements <em>provided that <code>T</code> is trivially copy constructible</em>. They might use <code>std::is_trivially_copy_constructible&lt;T&gt;</code> to detect whether the optimization is safe or not. If not, then the implementation falls back to the safe but slower method which is looping through the elements and call <code>T</code>'s copy constructor. </p>\n<p>Now, if one specializes <code>std::is_trivially_copy_constructible</code> for <code>T = std::shared_ptr&lt;my_type&gt;</code> like this:</p>\n<pre><code>namespace std {\n    template &lt;&gt;\n    class is_trivially_copy_constructible&lt;std::shared_ptr&lt;my_type&gt;&gt; : std::true_type {\n    };\n}\n</code></pre>\n<p>Then copying a <code>std::vector&lt;std::shared_ptr&lt;my_type&gt;&gt;</code> would be disastrous.</p>\n<p>This would not be the Standard Library implementation's fault but rather the specialization writer's. To some extend, that's what the quote provided by the OP says: \"It's your fault, not mine.\"</p>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2014-08-17T18:36:03.167", "Score": "2", "CreationDate": "2014-08-17T17:35:47.993", "ParentId": "25345486", "CommentCount": "1", "OwnerUserId": "1137388", "LastEditDate": "2014-08-17T18:36:03.167"}});