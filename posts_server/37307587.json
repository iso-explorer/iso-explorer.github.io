post_cb({"37307924": {"Id": "37307924", "PostTypeId": "2", "Body": "<p>In multiple inheritance, dynamic_cast will shift the pointer as necessary and is a must. Therefore, getting rid of it is dangerous. If your system extends to a point where it uses MI somewhere down, you might get all sorts of strange behaviour.</p>\n", "LastActivityDate": "2016-05-18T18:52:52.247", "CommentCount": "9", "CreationDate": "2016-05-18T18:52:52.247", "ParentId": "37307587", "Score": "2", "OwnerUserId": "173347"}, "37308508": {"Id": "37308508", "PostTypeId": "2", "Body": "<p>Maybe you could use <code>typeid</code> operator. Because:</p>\n<p>N3337 5.2.8/2 says:</p>\n<blockquote>\n<p id=\"so_37307587_37308508_0\">When typeid is applied to a glvalue expression <strong>whose type is a polymorphic class type</strong> (10.3), the result refers\n  to a std::type_info object representing the type of the <strong>most derived object (1.8) (that is, the dynamic\n  type) to which the glvalue refers</strong> ....</p>\n</blockquote>\n<p>Example:</p>\n<pre><code>struct Base\n{\n    virtual void f(){} //to ensure that Base is polymorphic object\n};\n\nstruct Derived: Base{};\n\nstruct AnotherDerived: Base{};\n\n\n\nint main()\n{\n    Base *ptr = new AnotherDerived;\n\n    if(typeid(*ptr) == typeid(Derived)) //Do not forget to dereference pointer, otherwise typeid() will return type_info for pointer itself\n    {\n         cout &lt;&lt; \"ptr is pointing to object of type Derived\" &lt;&lt; endl;\n    }\n\n    if (typeid(*ptr) == typeid(AnotherDerived))\n    {\n        cout &lt;&lt; \"ptr is pointing to object of type AnotherDerived\" &lt;&lt; endl;\n    }\n\n}\n</code></pre>\n<p>However if you have to distinguish between them in your code why are you using pointer to Base? What about separating code where you are using only <code>Base</code> properties and code where are you using specific properties of your child classes? That's the whole point of polymorphism.</p>\n<p>EDIT: \nAs davmac pointed out. It will work only if these subclasses will be most derived classes.</p>\n", "LastEditorUserId": "1478537", "LastActivityDate": "2017-06-14T21:05:07.687", "Score": "0", "CreationDate": "2016-05-18T19:27:17.547", "ParentId": "37307587", "CommentCount": "5", "OwnerUserId": "4932834", "LastEditDate": "2017-06-14T21:05:07.687"}, "bq_ids": {"n4140": {"so_37307587_37308508_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 6021}}, "n3337": {"so_37307587_37308508_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 5789}}, "n4659": {"so_37307587_37308508_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 7520}}}, "37317655": {"Id": "37317655", "PostTypeId": "2", "Body": "<p>I generally prefer to be able to get a handle to the desired type without using a cast. This means adding methods to the Base class:</p>\n<pre><code>virtual Kid1 *asKid1()\n{\n    return null;\n}\n\nvirtual Kid2 *asKid2()\n{\n    return null;\n}\n</code></pre>\n<p>The subclasses then override these as appropriate:</p>\n<pre><code>// (in Kid1)\nvirtual Kid1 *asKid1() override\n{\n    return this;\n}\n</code></pre>\n<p>Although your <code>Base</code> class is still being \"polluted\" with extra methods, only these two methods are required, even if the subclasses are expanded in the future.</p>\n<p>(You can have them return references rather than pointers, in which case they should throw an exception by default).</p>\n", "LastActivityDate": "2016-05-19T08:19:36.430", "CommentCount": "5", "CreationDate": "2016-05-19T08:19:36.430", "ParentId": "37307587", "Score": "0", "OwnerUserId": "388661"}, "37336399": {"Id": "37336399", "PostTypeId": "2", "Body": "<p>You could try the <a href=\"https://en.wikipedia.org/wiki/Visitor_pattern\" rel=\"nofollow noreferrer\">Visitor pattern</a>.</p>\n<p><a href=\"https://stackoverflow.com/questions/255214/when-should-i-use-the-visitor-design-pattern\">When should I use the Visitor Design Pattern?</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-05-20T01:09:16.397", "Score": "0", "CreationDate": "2016-05-20T01:09:16.397", "ParentId": "37307587", "CommentCount": "0", "OwnerUserId": "3325279", "LastEditDate": "2017-05-23T10:29:04.993"}, "37307845": {"Id": "37307845", "PostTypeId": "2", "Body": "<p>You don't need <code>dynamic_cast</code>, <code>dynamic_cast</code> already use internal runtime type information to determine if it's able to cast the passed pointer/reference to the desired type but you are already checking it through the <code>type()</code> method. A <code>static_cast</code> is enough in your situation, as you are already providing RTTI by yourself.</p>\n<p>Or alternatively you could just remove the type() method and use directly <code>dynamic_cast</code>, which yields <code>nullptr</code> if it's not able to cast the object to your desired type.</p>\n<p>If you really want to avoid such things then you are forced to encapsulate the behavior desired into <code>virtual</code> methods such that wherever you need to use a <code>Kid1</code> or <code>Kid2</code>, you will have different implementation without the need to really distinguishing between the two, just by letting polymorphism do its work.</p>\n", "LastActivityDate": "2016-05-18T18:48:33.687", "CommentCount": "2", "CreationDate": "2016-05-18T18:48:33.687", "ParentId": "37307587", "Score": "1", "OwnerUserId": "121747"}, "37307587": {"ViewCount": "433", "Body": "<p>I have a class structure with loads of different child classes all inheriting from the same abstract base class. This base class is there because all these classes self register at compile time to a factory from which they are built. This is really neat and keeps me from the burden of maintaining a huge switch or any other flow mechanism somewhere down stream. </p>\n<pre><code>              +---------------+\n              |     Base      |\n              +--+---------+--+\n                 |         |\n         +-------+-+     +-+-------+\n         |  Kid1   |     |  Kid2   |\n         +----+----+     +----+----+\n              |               |\n  +---+---+---+               +---+---+---+\n  |   |   |   | ...           |   |   |   | ....\n</code></pre>\n<p>However, these <code>Kid1</code> and <code>Kid2</code> classes are different and the issue is that I have to distinguish between them somewhere in my code and the only thing I have is a <code>Base</code> pointer. I did not want to bother the factory with this and keep that as simple as possible.</p>\n<p>The way I solved this right now is by having <code>Base</code> being somewhat aware of the two siblings. It has a virtual method <code>type()</code> which returns an enum type distinguishing between <code>Kid1</code> and <code>Kid2</code>. Both kids override this <em>(basically saying I am KidX)</em> such that I know with whom I am dealing. This type is then used to <code>dynamic_cast</code> <code>Base</code> to either of the kids and the program proceeds.</p>\n<p>However, is this the right approach? </p>\n<p>I could for example add some more <code>virtual</code> methods to base, on the one hand polluting it with methods only one part of the hierarchy uses but on the other hand saving me the <code>dynamic_cast</code>. </p>\n<p>Any thoughts?</p>\n", "AcceptedAnswerId": "37307924", "Title": "Alternatives to dynamic_cast in class hierarchy", "CreationDate": "2016-05-18T18:33:49.767", "Id": "37307587", "CommentCount": "2", "LastEditDate": "2017-06-15T09:49:55.830", "PostTypeId": "1", "LastEditorUserId": "1478537", "LastActivityDate": "2017-06-15T09:49:55.830", "Score": "3", "OwnerUserId": "2506915", "Tags": "<c++><inheritance><dynamic-cast><virtual-method>", "AnswerCount": "5"}});