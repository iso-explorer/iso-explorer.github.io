post_cb({"44191920": {"CommentCount": "13", "ViewCount": "79", "CreationDate": "2017-05-26T00:51:18.373", "LastActivityDate": "2017-05-26T01:59:28.737", "Title": "Legal legacy code using pointers suddenly becomes UB", "AcceptedAnswerId": "44192442", "PostTypeId": "1", "Id": "44191920", "Score": "1", "Body": "<p>Let's say we have this legacy code from C++98:</p>\n<pre><code>bool expensiveCheck();\n\nstruct Foo;\n\nbool someFunc()\n{\n    Foo *ptr = 0;\n    if( expesiveCheck() )\n        ptr = new Foo;\n\n    // doing something irrelevant here\n    ...\n    if( ptr ) {\n        // using foo\n    }\n    delete ptr;\n    return ptr; // here we have UB in C++11\n}\n</code></pre>\n<p>So basically pointer here is used to keep dynamically allocated data and use it as a flag at the same time. For me it is readable code and I believe it is legal C++98 code. Now according to this questions:</p>\n<p><a href=\"https://stackoverflow.com/questions/44182049/pointers-in-c-after-delete/44182329?noredirect=1#comment75396720_44182329\">Pointers in c++ after delete</a></p>\n<p><a href=\"https://stackoverflow.com/questions/23621677/what-happens-to-the-pointer-itself-after-delete\">What happens to the pointer itself after delete?</a></p>\n<p>this code has UB in C++11. Is it true?</p>\n<p>If yes another question comes in mind, I heard that committee puts significant effort not to break existing code in new standard. If I am not mistaken in this case this not true. What is the reason? Is such code considered harmfull already so nobody cares it would be broken? They did not think about consequences? This optimization is so important? Something else?</p>\n", "Tags": "<c++><c++11><language-lawyer><c++98>", "OwnerUserId": "432358", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_44191920_44192442_0": {"section_id": 7183, "quality": 0.8055555555555556, "length": 29}, "so_44191920_44192442_1": {"section_id": 7183, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_44191920_44192442_0": {"section_id": 6927, "quality": 0.8611111111111112, "length": 31}, "so_44191920_44192442_1": {"section_id": 6927, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_44191920_44192442_1": {"section_id": 8671, "quality": 0.7142857142857143, "length": 5}}}, "44192442": {"ParentId": "44191920", "CommentCount": "10", "CreationDate": "2017-05-26T01:59:28.737", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "44192442", "Score": "5", "Body": "<p>Your example exhibits undefined behavior under C++98, too. From the C++98 standard:</p>\n<blockquote>\n<p id=\"so_44191920_44192442_0\"><strong>[basic.stc.dynamic.deallocation]/4</strong> If the argument given to a deallocation function in the standard library is a pointer that is not the null pointer value (4.10), the deallocation function shall deallocate the storage referenced by the pointer, rendering invalid all pointers referring to any part of the <em>deallocated storage</em>. The effect of using an invalid pointer value (including passing it to a deallocation function) is undefined.33)</p>\n<p id=\"so_44191920_44192442_1\">Footnote 33) On some implementations, it causes a system-generated runtime fault.</p>\n</blockquote>\n", "LastActivityDate": "2017-05-26T01:59:28.737"}});