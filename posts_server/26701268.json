post_cb({"bq_ids": {"n4140": {"so_26701268_26701456_0": {"length": 24, "quality": 0.96, "section_id": 1906}}, "n3337": {"so_26701268_26701456_0": {"length": 25, "quality": 1.0, "section_id": 1895}}, "n4659": {"so_26701268_26701456_0": {"length": 23, "quality": 0.92, "section_id": 2176}}}, "26701582": {"Id": "26701582", "PostTypeId": "2", "Body": "<p>Intantiating <code>std::char_traits</code> for anything but <code>char</code> or <code>wchar_t</code> is\nundefined behavior (And I suspect that your <code>charT</code> is <code>unsigned char</code>,\nnot <code>char</code>.)  If you want to use a different type for characters, you'll\nhave to define a new traits class; for <code>std::istream</code> anf\n<code>std::ostream</code>, you'll also have to define a number of facets for the\ntype as well.</p>\n<p>The question is what you want to do.  In your example, you only call\n<code>std::istream::read</code>.  If this is the case, the simplest solution is\nprobably to just drop down to the system level functions.  These\nprobably want a <code>char*</code> for there buffer as well, but a\n<code>reinterpret_cast</code> from <code>unsigned char*</code> will work.  You can do this for\n<code>std::istream&lt;char&gt;::read</code> as well, but if you have an <code>std::istream</code>,\nthere's a definite possibility that some formatted input will creap in,\nand that will interpret the characters before you can get your\n<code>reinterpret_cast</code> in.</p>\n", "LastActivityDate": "2014-11-02T16:27:15.100", "CommentCount": "1", "CreationDate": "2014-11-02T16:27:15.100", "ParentId": "26701268", "Score": "2", "OwnerUserId": "649665"}, "26701456": {"Id": "26701456", "PostTypeId": "2", "Body": "<p>The stream libraries are designed to be used with the character types such as <code>char</code> and <code>wchar_t</code>, not integers:</p>\n<p><strong>C++11 standard: 27.2.2</strong></p>\n<blockquote id=\"so_26701268_26701456_0\">\n<ol start=\"2\">\n<li>In the classes of Clause 27, a template formal parameter with name\n  charT represents a member of the set of types containing char,\n  wchar_t, and any other implementation-defined character types that\n  satisfy the requirements for a character on which any of the iostream\n  components can be instantiated.</li>\n</ol>\n</blockquote>\n<p>Maybe start from this:</p>\n<pre><code>int main()\n{\n    std::ifstream ifs(\"/proc/cpuinfo\", std::ios::binary);\n    std::cout &lt;&lt; ifs.rdbuf();\n}\n</code></pre>\n", "LastEditorUserId": "3807729", "LastActivityDate": "2014-11-02T16:22:24.727", "Score": "2", "CreationDate": "2014-11-02T16:15:24.903", "ParentId": "26701268", "CommentCount": "0", "OwnerUserId": "3807729", "LastEditDate": "2014-11-02T16:22:24.727"}, "26701268": {"ViewCount": "115", "Body": "<p>The program built from this code:</p>\n<pre><code>#include &lt;fstream&gt;\nusing std::basic_ifstream;\n\n#include &lt;ios&gt;\nusing std::streamsize;\n\n#include &lt;ZenLib/Conf.h&gt;\nusing ZenLib::int8u;\n\nint main() {\n#define charT int8u\n#define T basic_ifstream&lt;charT&gt;\n    T ifs (\"/proc/cpuinfo\", T::in | T::binary);\n#undef T\n    streamsize const bufsize (4096);\n    charT buf[bufsize];\n#undef charT\n    return !ifs.read(buf, bufsize).gcount();\n}\n</code></pre>\n<p>... returns 1.</p>\n<p>So <code>std::basic_ifstream&lt;ZenLib::int8u&gt;::read()</code> could not extract any byte from <code>/proc/cpuinfo</code>.</p>\n<p>Am I doing anything wrong?</p>\n", "AcceptedAnswerId": "26701582", "Title": "basic_ifstream<...>::read() doesn't read anything", "CreationDate": "2014-11-02T15:59:36.920", "Id": "26701268", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-11-02T16:27:15.100", "Score": "1", "OwnerUserId": "2175501", "Tags": "<c++><c++11><file-io><stream><gcc4.9>", "AnswerCount": "2"}});