post_cb({"3312210": {"Body": "<p>There isn't a way to stop one and not the other. Anywhere it can be implicitly converted to a pointer for a function call, it can be implicitly converted for a delete expression.</p>\n<p>Your best bet is to remove the conversion function. Your situation is exactly why user-defined conversion operators are dangerous and shouldn't be used often.</p>\n<hr>\n<p><a href=\"https://stackoverflow.com/questions/3312031/c-smart-pointer-template-that-auto-converts-to-bare-pointer-but-cant-be-expl/3312507#3312507\">I'm wrong.</a> :(</p>\n</hr>", "CreationDate": "2010-07-22T18:39:42.083", "ParentId": "3312031", "CommentCount": "9", "LastEditDate": "2017-05-23T12:28:24.020", "Id": "3312210", "PostTypeId": "2", "LastActivityDate": "2010-07-22T20:10:12.567", "LastEditorUserId": "-1", "CommunityOwnedDate": "2010-07-22T20:10:12.567", "Score": "4", "OwnerUserId": "87234"}, "bq_ids": {"n4140": {"so_3312031_3312507_0": {"length": 19, "quality": 0.59375, "section_id": 6169}}, "n3337": {"so_3312031_3312507_0": {"length": 19, "quality": 0.59375, "section_id": 5930}}, "n4659": {"so_3312031_3312507_0": {"length": 19, "quality": 0.59375, "section_id": 7667}}}, "3313002": {"Id": "3313002", "PostTypeId": "2", "Body": "<p>I can see where you do not want to do a massive application of .get()'s.  Have you ever consider a much smaller replacement of delete's?</p>\n<pre><code>struct A\n{\n    friend static void Delete( A* p) { delete p; }\n\nprivate:\n    ~A(){}\n};\n\nstruct B\n{\n};\n\nint main() \n   { \n\n    delete new B();  //ok\n\n    Delete( new A ); //ok\n\n    delete new A; //compiler error\n\n    return (0); \n    } \n</code></pre>\n", "LastActivityDate": "2010-07-22T20:13:18.330", "CommentCount": "1", "CreationDate": "2010-07-22T20:13:18.330", "ParentId": "3312031", "Score": "0", "OwnerUserId": "14841"}, "3312168": {"Id": "3312168", "PostTypeId": "2", "Body": "<p>You can use a technique presented by <a href=\"http://www.boost.org/doc/libs/1_43_0/libs/smart_ptr/sp_techniques.html#preventing_delete\" rel=\"nofollow noreferrer\">Boost</a>, but my concern is that you're allowing implicit conversions from a smart pointer to a raw pointer, which is generally frowned upon on. Besides, users can call <code>delete</code> on a pointer obtained by the <code>-&gt;</code> operator, so there's really nothing you can do to prevent a determined idiot to work around whatever mechanism you come up with.</p>\n<p>You really should just implement a <code>get()</code> method instead of providing <code>operator T*()</code> so that at least calls to <code>delete smartptr</code> will not compile. Non-idiots should be able to figure out that there's probably a reason why that won't work.</p>\n<p>Yes, it's more work to type out <code>LegacyFunc(smartptr.get())</code> than <code>LegacyFunc(smartptr)</code>, but the former is preferred since it makes it explicit and prevents unexpected conversions from happening, like <code>delete smartptr</code>.</p>\n<p>What if you have functions like this:</p>\n<pre><code> void LegacyOwnPointer(SomeType* ptr);\n</code></pre>\n<p>where the function will store the pointer somewhere? This will screw up the smart pointer, because now it's not aware that something else is owning the raw pointer.</p>\n<p>Either way, you have some work to do. Smart pointers are like raw pointers, but they are not the same, so you can't just find-and-replace all instances of <code>T*</code> and replace it with <code>my_scoped_ptr&lt;T&gt;</code> and expect it to work just as well as before.</p>\n", "LastEditorUserId": "308661", "LastActivityDate": "2010-07-22T18:50:20.103", "Score": "1", "CreationDate": "2010-07-22T18:33:45.650", "ParentId": "3312031", "CommentCount": "4", "OwnerUserId": "308661", "LastEditDate": "2010-07-22T18:50:20.103"}, "3312507": {"Id": "3312507", "PostTypeId": "2", "Body": "<p>The Standard says</p>\n<blockquote>\n<p id=\"so_3312031_3312507_0\">The operand shall have a pointer type, or a class type having a single conversion function (12.3.2) to a pointer type. If the operand has a class type, the operand is converted to a pointer type by calling the above-mentioned conversion function, and the converted operand is used in place of the original operand for the remainder of this section. </p>\n</blockquote>\n<p>You can (ab)-use the absence of overload resolution by declaring a const version of the conversion function. On a conforming compiler that's enough to make it not work anymore with <code>delete</code>:</p>\n<pre><code>struct A {\n  operator int*() { return 0; }\n  operator int*() const { return 0; }\n};\n\nint main() {\n  A a;\n  int *p = a; // works\n  delete a; // doesn't work\n}\n</code></pre>\n<p>Results in the following</p>\n<pre><code>[js@HOST2 cpp]$ clang++ main1.cpp\nmain1.cpp:9:3: error: ambiguous conversion of delete expression of type 'A' to a pointer\n  delete a; // doesn't work\n  ^      ~\nmain1.cpp:2:3: note: candidate function            \n  operator int*() { return 0; }\n  ^\nmain1.cpp:3:3: note: candidate function             \n  operator int*() const { return 0; }\n  ^\n1 error generated.\n</code></pre>\n<hr>\n<p>On compilers that are less conforming in that regard (EDG/Comeau, GCC) you can make the conversion function a template. <code>delete</code> does not expect a <em>particular</em> type, so this would work:</p>\n<pre><code>template&lt;typename T&gt;\noperator T*() { return /* ... */ }\n</code></pre>\n<p>However, this has the downside that your smartpointer is now convertible to <em>any</em> pointer-type. Although the actual conversion is still typechecked, but this won't rule out conversions up-front but rather give a compile time error much later. Sadly, SFINAE does not seem to be possible with conversion functions in C++03 :) A different way is to return a private nested type pointer from the other function</p>\n<pre><code>struct A {\n  operator int*() { return 0; }\n\nprivate:\n  struct nested { };\n  operator nested*() { return 0; }\n};\n</code></pre>\n<p>The only problem now is with a conversion to <code>void*</code>, in which case both conversion functions are equally viable. A work-around suggested by @Luther is to return a function pointer type from the other conversion function, which works with both GCC and Comeau and gets rid of the <code>void*</code> problem while having no other problems on the usual conversion paths, unlike the template solution</p>\n<pre><code>struct A {\n  operator int*() { return 0; }\n\nprivate:\n  typedef void fty();\n  operator fty*() { return 0; }\n};\n</code></pre>\n<p>Notice that these workarounds are only needed for compilers that are not conforming, though. </p>\n</hr>", "LastEditorUserId": "34509", "LastActivityDate": "2010-07-22T19:53:17.970", "Score": "7", "CreationDate": "2010-07-22T19:16:04.737", "ParentId": "3312031", "CommentCount": "8", "OwnerUserId": "34509", "LastEditDate": "2010-07-22T19:53:17.970"}, "3312031": {"ViewCount": "1759", "Body": "<p>I am working in a very large legacy C++ code base which shall remain nameless.  Being a legacy code base, it passes raw pointers around all over the place.  But we are gradually trying to modernize it and so there are some smart pointer templates as well.  These smart pointers (unlike, say, Boost's scoped_ptr) have an implicit conversion to the raw pointer, so that you can pass one of them into a routine that takes a raw pointer without having to write <code>.get()</code>.  A big downside of this is that you can also accidentally use one in a <code>delete</code> statement, and then you have a double free bug, which can be a real pain to track down.</p>\n<p>Is there a way to modify the template so that it still has the implicit conversion to the raw pointer, but causes a compile error if used in a delete statement?  Like this:</p>\n<pre><code>#include &lt;my_scoped_ptr&gt;\n\nstruct A {};\nextern void f(A*);\n\nstruct B\n{\n    scoped_ptr&lt;A&gt; a;\n\n    B();\n    ~B();\n};\n\nB::B()\n    : a(new A)\n{\n    f(a); // this should compile\n}\n\nB::~B()\n{\n    delete a; // this should NOT compile\n}\n</code></pre>\n", "AcceptedAnswerId": "3312507", "Title": "C++ \"smart pointer\" template that auto-converts to bare pointer but can't be explicitly deleted", "CreationDate": "2010-07-22T18:21:09.590", "Id": "3312031", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2010-07-22T20:13:18.330", "Score": "5", "OwnerUserId": "388520", "Tags": "<c++><templates><smart-pointers>", "AnswerCount": "5"}, "3312918": {"Id": "3312918", "PostTypeId": "2", "Body": "<p>have not thought much about this but ... Can you provide an overload for operator delete which is strongly-typed for instances of your template class such that when the code is included compilation fails?  if this is in your header file then implicit conversion in calls to delete should be prevented in favour of a call to your overload.  </p>\n<p>operator delete(my_scoped_ptr)\n{\n//... uncompilable code goes here\n}</p>\n<p>Apologies if this turns out to be a stupid idea.</p>\n", "LastActivityDate": "2010-07-22T20:02:45.957", "CommentCount": "1", "CreationDate": "2010-07-22T20:02:45.957", "ParentId": "3312031", "Score": "0", "OwnerUserId": "210102"}});