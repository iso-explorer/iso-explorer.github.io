post_cb({"21479121": {"Id": "21479121", "PostTypeId": "2", "Body": "<p>You have casted y1 as a double before casting it again to a long. the value of x isn't the \"floor\" value but a rounded value for floor. </p>\n<p>Same logic would apply with casting integers and floats. float x = (float)((int) 1.5) will give a different value to float x = 1.5 </p>\n", "LastActivityDate": "2014-01-31T11:35:14.640", "CommentCount": "1", "CreationDate": "2014-01-31T11:35:14.640", "ParentId": "21478945", "Score": "0", "OwnerUserId": "3257139"}, "21479468": {"Id": "21479468", "PostTypeId": "2", "Body": "<p><code>9223372036854775808</code> is <code>0x8000000000000000</code>; that is, it is equal to <code>INT64_MIN</code> cast to <code>uint64_t</code>.</p>\n<p>It looks like your compiler is casting the return value of <code>floor</code> to <code>long long</code> and then casting that result to <code>unsigned long long</code>.</p>\n<p>Note that it is quite usual for overflow in floating-point-to-integral conversion to yield the least representable value (e.g. <code>cvttsd2siq</code> on x86-64):</p>\n<blockquote>\n<p id=\"so_21478945_21479468_0\">When a conversion is inexact, a truncated result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p>\n</blockquote>\n<p>(this is from the doubleword documentation, but the quadword behaviour is the same.)</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2014-01-31T11:58:53.077", "Score": "4", "CreationDate": "2014-01-31T11:53:51.993", "ParentId": "21478945", "CommentCount": "2", "OwnerUserId": "567292", "LastEditDate": "2014-01-31T11:58:53.077"}, "21478945": {"ViewCount": "296", "Body": "<p>When I run the following code in VC++ 2013 (32-bit, no optimizations):</p>\n<pre><code>#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n\ndouble mulpow10(double const value, int const pow10)\n{\n    static double const table[] =\n    {\n        1E+000, 1E+001, 1E+002, 1E+003, 1E+004, 1E+005, 1E+006, 1E+007,\n        1E+008, 1E+009, 1E+010, 1E+011, 1E+012, 1E+013, 1E+014, 1E+015,\n        1E+016, 1E+017, 1E+018, 1E+019,\n    };\n    return pow10 &lt; 0 ? value / table[-pow10] : value * table[+pow10];\n}\n\nint main(void)\n{\n    double d = 9710908999.008999;\n    int j_max = std::numeric_limits&lt;double&gt;::max_digits10;\n    while (j_max &gt; 0 &amp;&amp; (\n        static_cast&lt;double&gt;(\n            static_cast&lt;unsigned long long&gt;(\n                mulpow10(d, j_max))) != mulpow10(d, j_max)))\n    {\n        --j_max;\n    }\n    double x = std::floor(d * 1.0E9);\n    unsigned long long y1 = x;\n    unsigned long long y2 = std::floor(d * 1.0E9);\n    std::cout\n        &lt;&lt; \"x == \" &lt;&lt; x &lt;&lt; std::endl\n        &lt;&lt; \"y1 == \" &lt;&lt; y1 &lt;&lt; std::endl\n        &lt;&lt; \"y2 == \" &lt;&lt; y2 &lt;&lt; std::endl;\n}\n</code></pre>\n<p>I get</p>\n<pre><code>x  == 9.7109089990089994e+018\ny1 == 9710908999008999424\ny2 == 9223372036854775808\n</code></pre>\n<p>in the debugger.</p>\n<p>I'm mindblown. Can someone please explain to me how the heck <code>y1</code> and <code>y2</code> have different values?</p>\n<hr>\n<h3>Update:</h3>\n<p>This only seems to happen under <code>/Arch:SSE2</code> or <code>/Arch:AVX</code>, not <code>/Arch:IA32</code> or <code>/Arch:SSE</code>.</p>\n</hr>", "AcceptedAnswerId": "21488975", "Title": "Bizarre floating-point behavior with vs. without extra variables, why?", "CreationDate": "2014-01-31T11:25:57.943", "Id": "21478945", "CommentCount": "38", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-01-31T17:46:31.753", "LastEditorUserId": "541686", "LastActivityDate": "2014-01-31T21:00:42.013", "Score": "8", "OwnerUserId": "541686", "Tags": "<c++><visual-c++><floating-point><double><unsigned-long-long-int>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_21478945_21488975_1": {"length": 26, "quality": 0.8125, "section_id": 37}}, "n3337": {"so_21478945_21488975_1": {"length": 26, "quality": 0.8125, "section_id": 34}}, "n4659": {"so_21478945_21488975_1": {"length": 24, "quality": 0.75, "section_id": 37}}}, "21479770": {"Id": "21479770", "PostTypeId": "2", "Body": "<p>Hypothesis: It is a bug. The compiler converts <code>double</code> to <code>unsigned long long</code> correctly but converts extended-precision floating-point (possibly <code>long double</code>) to <code>unsigned long long</code> incorrectly. Details:</p>\n<pre><code>double              x = std::floor(9710908999.0089989 * 1.0E9);\n</code></pre>\n<p>This computes the value on the right-hand side and stores it in <code>x</code>. The value on the right-hand side might be computed with extended precision, but it is, as the rules of C++ require, converted to <code>double</code> when stored in <code>x</code>. The exact mathematical value would  be 9710908999008998870, but rounding it to the <code>double</code> format produces 9710908999008999424.</p>\n<pre><code>unsigned long long y1 = x;\n</code></pre>\n<p>This converts the <code>double</code> value in <code>x</code> to <code>unsigned long long</code>, producing the expected 9710908999008999424.</p>\n<pre><code>unsigned long long y2 = std::floor(9710908999.0089989 * 1.0E9);\n</code></pre>\n<p>This computes the value on the right-hand side using extended precision, producing 9710908999008998870. When the extended-precision value is converted to <code>unsigned long long</code>, there is a bug, producing 2<sup>63</sup> (9223372036854775808). This value is likely the \u201cout of range\u201d error value produced by an instruction that converts the extended-precision format to a 64-bit integer. The compiler has used an incorrect instruction sequence to convert its extended-precision format to an <code>unsigned long long</code>.</p>\n", "LastActivityDate": "2014-01-31T12:08:26.940", "CommentCount": "6", "CreationDate": "2014-01-31T12:08:26.940", "ParentId": "21478945", "Score": "3", "OwnerUserId": "298225"}, "21488975": {"Id": "21488975", "PostTypeId": "2", "Body": "<p>You are converting out-of-range <code>double</code> values to <code>unsigned long long</code>. This is not allowed in standard C++, and Visual C++ appears to treat it <em>really</em> badly in SSE2 mode: it leaves a number on the FPU stack, eventually overflowing it and making later code that uses the FPU fail in really interesting ways.</p>\n<p>A reduced sample is</p>\n<pre><code>double d = 1E20;\nunsigned long long ull[] = { d, d, d, d, d, d, d, d };\nif (floor(d) != floor(d)) abort();\n</code></pre>\n<p>This aborts if <code>ull</code> has eight or more elements, but passes if it has up to seven.</p>\n<p>The solution is not to convert floating point values to an integer type unless you know that the value is in range.</p>\n<blockquote>\n<p id=\"so_21478945_21488975_0\"><strong>4.9 Floating-integral conversions [conv.fpint]</strong></p>\n<p id=\"so_21478945_21488975_1\">A prvalue of a floating point type can be converted to a prvalue of an integer type. The conversion truncates; that is, the fractional part is discarded. The behavior is undefined if the truncated value cannot be represented in the destination type. [ <em>Note:</em> If the destination type is <code>bool</code>, see 4.12. -- <em>end note</em> ]</p>\n</blockquote>\n<p>The rule that out-of-range values wrap when converted to an unsigned type only applies if the value as already of some integer type.</p>\n<p>For whatever it's worth, though, this doesn't seem like it's intentional, so even though the standard permits this behaviour, it may still be worth reporting this as a bug.</p>\n", "LastEditorUserId": "743382", "LastActivityDate": "2014-01-31T21:00:42.013", "Score": "4", "CreationDate": "2014-01-31T20:00:06.980", "ParentId": "21478945", "CommentCount": "8", "OwnerUserId": "743382", "LastEditDate": "2014-01-31T21:00:42.013"}});