post_cb({"bq_ids": {"n4140": {"so_34204483_34204707_0": {"length": 39, "quality": 1.0, "section_id": 223}}, "n3337": {"so_34204483_34204707_0": {"length": 39, "quality": 1.0, "section_id": 216}}, "n4659": {"so_34204483_34204707_0": {"length": 39, "quality": 1.0, "section_id": 231}}}, "34204483": {"ViewCount": "125", "Body": "<p>When compiling C++, gcc and clang seems to postpone the type-checking of template instantiations until after all declarations of the program have been processed. Is this guaranteed in the language?</p>\n<p>To elaborate, I can keep a type incomplete at the point where a template is defined or a template instantiation is needed, as long as I complete the type somewhere later in the program:</p>\n<pre><code>class A;\nclass B;\n\nextern A* pa;\n\n// 1. template definition\ntemplate&lt;typename T&gt;\nT* f() { return static_cast&lt;T*&gt;(pa); }\n\n// 2. template instantiation\nB* test() { return f&lt;B&gt;(); }\n\n// 3. completing types\nclass A { };\nclass B : public A { };\n</code></pre>\n<p>Note that the definitions of A and B are required to type check the template instantiation (to make the static_cast valid). If you leave out step 3, step 2 will no longer compile.</p>\n<p>In the organisation of my headers, can I rely that this order will be accepted by any standard C++ compiler?</p>\n", "Title": "When is a C++ template instantiation type checked?", "CreationDate": "2015-12-10T14:32:10.823", "LastActivityDate": "2015-12-10T15:08:57.163", "CommentCount": "3", "PostTypeId": "1", "Id": "34204483", "Score": "5", "OwnerUserId": "6918", "Tags": "<c++><templates>", "AnswerCount": "1"}, "34204707": {"Id": "34204707", "PostTypeId": "2", "Body": "<p>The rule is called \"two-phase name lookup\". </p>\n<p>The names, which are not dependant on the template parameters, are looked up and checked at definition, and the <em>dependent names</em> are checked at  the point of instantiation. </p>\n<p>For your example, there is one important detail: the end of translation unit is also considered a point of instantiation for function templates:</p>\n<p>C++14 N4140 14.6.4.1 [temp.point] P8:</p>\n<blockquote>\n<p id=\"so_34204483_34204707_0\">A specialization for a function template, a member function template, or of a member function or static\n  data member of a class template may have multiple points of instantiations within a translation unit, and\n  in addition to the points of instantiation described above, for any such specialization that has a point\n  of instantiation within the translation unit, the end of the translation unit is also considered a point of\n  instantiation.</p>\n</blockquote>\n<p>Thus, although the type is incomplete at point \"2\", where explicit instantiation happens, it is complete at the end of file, which makes the template instantiation legitimate.</p>\n<p><strong>Note</strong>: Microsoft compiler does not implement this rule in full, violating the standard. In Microsoft compiler, all the lookup happens at the point of instantiation (thus the example should also work, but I don't have access to MSVC to check). Other major compilers do implement this rule correctly. </p>\n", "LastEditorUserId": "4451432", "LastActivityDate": "2015-12-10T15:08:57.163", "Score": "5", "CreationDate": "2015-12-10T14:41:06.893", "ParentId": "34204483", "CommentCount": "1", "OwnerUserId": "4451432", "LastEditDate": "2015-12-10T15:08:57.163"}});