post_cb({"31062892": {"ViewCount": "129", "Body": "<p>I tried compiling the following program in Visual Studio 2013 and got the <code>C2686: cannot overload static and non-static member functions</code> error.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nstruct foo\n{\n  template&lt;bool P&gt;\n  static std::enable_if_t&lt;P&gt; bar()\n  {\n    std::cerr &lt;&lt; \"P is true\\n\";\n  }\n\n  template&lt;bool P&gt;\n  std::enable_if_t&lt;!P&gt; bar()\n  {\n    std::cerr &lt;&lt; \"P is false\\n\";\n  }\n};\n\nint main()\n{\n  foo f;\n  f.bar&lt;true&gt;();\n}\n</code></pre>\n<p>I'm familiar with this compiler error\u2014see <a href=\"https://stackoverflow.com/a/5365714/1094609\">this StackOverflow answer</a>, but was surprised to see the error in conjunction with SFINAE, whereby the compiler will always discard one of the two overloads from the overload set.</p>\n<p>Is Visual Studio 2013 correctly following the standard here, or should it be possible to overload on static in conjunction with SFINAE?</p>\n<p><strong>EDIT: Contrast example above with overloading on return type</strong></p>\n<p>Without SFINAE, you can't overload on <code>static</code>, and you also can't overload on return type. However, Visual Studio 2013 supports overloading on return type in conjunction with SFINAE.</p>\n<p>The following program, which is the same as the program above but removes <code>static</code> and changes the return type for the second <code>foo::bar</code> declaration, compiles correctly.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nstruct foo\n{\n  template&lt;bool P&gt;\n  std::enable_if_t&lt;P&gt; bar()\n  {\n    std::cerr &lt;&lt; \"P is true\\n\";\n  }\n\n  template&lt;bool P&gt;\n  std::enable_if_t&lt;!P, int&gt; bar()\n  {\n    std::cerr &lt;&lt; \"P is false\\n\";\n    return 42;\n  }\n};\n\nint main()\n{\n  foo f;\n  f.bar&lt;true&gt;();\n}\n</code></pre>\n<p>It seems to me Visual Studio 2013 is getting one of these two cases wrong, but I'm hoping a language lawyer can provide a definite answer.</p>\n", "AcceptedAnswerId": "31062984", "Title": "Overloading-on-static in conjunction with SFINAE", "CreationDate": "2015-06-26T00:15:22.290", "Id": "31062892", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:08:59.433", "LastEditorUserId": "-1", "LastActivityDate": "2015-06-26T21:17:24.317", "Score": "2", "OwnerUserId": "1094609", "Tags": "<c++><sfinae>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_31062892_31062984_0": {"length": 44, "quality": 0.88, "section_id": 556}, "so_31062892_31062984_1": {"length": 5, "quality": 1.0, "section_id": 557}}, "n3337": {"so_31062892_31062984_0": {"length": 44, "quality": 0.88, "section_id": 547}, "so_31062892_31062984_1": {"length": 5, "quality": 1.0, "section_id": 548}}, "n4659": {"so_31062892_31062984_0": {"length": 44, "quality": 0.88, "section_id": 579}, "so_31062892_31062984_1": {"length": 5, "quality": 1.0, "section_id": 580}}}, "31062984": {"Id": "31062984", "PostTypeId": "2", "Body": "<p>Surprisingly enough, MSVC is correct. (I know, shock.) [over.load]/p1-2:</p>\n<blockquote>\n<p id=\"so_31062892_31062984_0\">1 Not all function declarations can be overloaded. Those that cannot be overloaded are specified here. A\n  program is ill-formed if it contains two such non-overloadable declarations in the same scope. [<em>Note</em>: This\n  restriction applies to explicit declarations in a scope, and between such declarations and declarations made\n  through a <em>using-declaration</em> (7.3.3). It does not apply to sets of functions fabricated as a result of name\n  lookup (e.g., because of <em>using-directives</em>) or overload resolution (e.g., for operator functions). \u2014<em>end note</em>]</p>\n<p id=\"so_31062892_31062984_1\">2 Certain function declarations cannot be overloaded:</p>\n<ul>\n<li>Function declarations that differ only in the return type cannot be overloaded.</li>\n<li>Member function declarations with the same name and the same\n  <em>parameter-type-list</em> cannot be overloaded if any of them is a <code>static</code> member function declaration (9.4). Likewise, member function\n  template declarations with the same name, the same\n  <em>parameter-type-list</em>, and the same template parameter lists cannot be overloaded if any of them is a <code>static</code> member function template\n  declaration. [...]</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>The two <code>bar()</code> declarations have the same name, same <em>parameter-type-list</em>, and same template parameter list, at least one of which is <code>static</code>, and therefore cannot be overloaded.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2015-06-26T21:17:24.317", "Score": "5", "CreationDate": "2015-06-26T00:27:43.357", "ParentId": "31062892", "CommentCount": "5", "OwnerUserId": "2756719", "LastEditDate": "2015-06-26T21:17:24.317"}, "31082134": {"Id": "31082134", "PostTypeId": "2", "Body": "<h1>Background</h1>\n<p>I think Visual Studio is incorrect in this case.</p>\n<p>[1] states compiling a function call happens in two steps, name lookup, followed by overload resolution, if necessary (which we will see in this case is not necessary).</p>\n<p>Name lookup generates a list of candidate functions. Name lookup is composed of two steps, Argument-dependent lookup, followed by template argument deduction.</p>\n<p>If name lookup generates multiple possible function calls, overload resolution occurs to determine the correct function to call. </p>\n<p>SFINAE is a meta-programming technique to manipulate the candidate function set during a sub-step of template argument deduction [2]. SFINAE induces a substitution error during template argument substitution which prevents adding said function to the candidate set [3]. </p>\n<h1>Example</h1>\n<p>Let us manually compile this example.</p>\n<ol>\n<li><p>The compiler needs to resolve the function call for </p>\n<p>f.bar();</p></li>\n<li><p>First, name lookup occurs</p></li>\n</ol>\n<p>2.1. Argument Dependent lookup runs. Since there are no arguments this step doesn't reduce the list of candidates.</p>\n<p>2.2. Template argument deduction runs.</p>\n<p>2.2.1. Template argument substitution runs. This substitutes the P value into each enable_if_t&lt;&gt; expression. enable_if_t&lt;&gt; generates a substitution failure when it's predicate expression (here P) is false. Hence, functions where P induced a substitution failure are removed from the candidate list. After template argument substitution this code can only result in 1 candidate function since the enable_if_t&lt;&gt; expressions are mutually exclusive. </p>\n<h1>Conclusion</h1>\n<p>It appears that Visual Studio is checking overload rules before the template argument substitution step completes. If it had run template argument substitution, then overload resolution would never occur since the candidate list contains a single function. </p>\n<h1>References</h1>\n<ul>\n<li>[1] <a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/overload_resolution</a></li>\n<li>[2] <a href=\"http://en.cppreference.com/w/cpp/language/template_argument_deduction\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/template_argument_deduction</a></li>\n<li>[3] http:// en.cppreference.com /w /cpp /language/sfinae</li>\n</ul>\n", "LastActivityDate": "2015-06-26T21:04:34.060", "CommentCount": "1", "CreationDate": "2015-06-26T21:04:34.060", "ParentId": "31062892", "Score": "1", "OwnerUserId": "1612667"}});