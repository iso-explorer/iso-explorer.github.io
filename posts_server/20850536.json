post_cb({"20989720": {"ParentId": "20850536", "CommentCount": "0", "CreationDate": "2014-01-08T07:44:32.397", "OwnerUserId": "67249", "PostTypeId": "2", "Id": "20989720", "Score": "1", "Body": "<p>On glvalues: A glvalue (\"generalized\" lvalue) is an expression that is either an lvalue or an xvalue.\nA glvalue may be implicitly converted to prvalue with lvalue-to-rvalue, array-to-pointer, or function-to-pointer implicit conversion.</p>\n<p>Lvalue transformations are applied when lvalue argument (e.g. reference to an object) is used in context where rvalue (e.g. a number) is expected.</p>\n<p><strong>Lvalue to rvalue conversion</strong><br>\nA glvalue of any non-function, non-array type T can be implicitly converted to prvalue <strong>of the same type</strong>. If T is a non-class type, this conversion also removes cv-qualifiers. Unless encountered in unevaluated context (in an operand of sizeof, typeid, noexcept, or decltype), this conversion effectively copy-constructs a temporary object of type T using the original glvalue as the constructor argument, and that temporary object is returned as a prvalue. If the glvalue has the type std::nullptr_t, the resulting prvalue is the null pointer constant nullptr.</br></p>\n", "LastActivityDate": "2014-01-08T07:44:32.397"}, "20850536": {"CommentCount": "24", "AcceptedAnswerId": "20999389", "PostTypeId": "1", "LastEditorUserId": "368896", "CreationDate": "2013-12-31T01:52:55.970", "LastActivityDate": "2017-11-21T00:37:12.030", "LastEditDate": "2017-11-21T00:37:12.030", "ViewCount": "7557", "FavoriteCount": "12", "Title": "lvalue to rvalue implicit conversion", "Id": "20850536", "Score": "26", "Body": "<p>I see the term \"lvalue-to-rvalue conversion\" used in many places throughout the C++ standard. This kind of conversion is often done implicitly, as far as I can tell.</p>\n<p>One unexpected (to me) feature of the phrasing from the standard is that they decide to treat lvalue-to-rvalue as a conversion. What if they had said that a glvalue is always acceptable instead of a prvalue. Would that phrase actually have a different meaning? For example, we read that lvalues and xvalues are examples of glvalues. We don't read that lvalues and xvalues are convertible to glvalues. Is there a difference in meaning?</p>\n<p>Before my first encounter with this terminology, I used to model lvalues and rvalues mentally more or less as follows:   \"lvalues are <em>always</em> able to act as rvalues, but in addition can appear on the left side of an <code>=</code>, and to the right of an <code>&amp;</code>\". </p>\n<p>This, to me, is the intuitive behavior that if I have a variable name, then I can put that name everywhere where I would have put a literal. This model seems consistent with lvalue-to-rvalue implicit conversions terminology used in the standard, as long as this implicit conversion is guaranteed to happen.</p>\n<p>But, because they use this terminology, I started wondering whether the implicit lvalue-to-rvalue conversion may fail to happen in some cases. That is, maybe my mental model is wrong here. Here is a relevant part of the standard: (thanks to the commenters). </p>\n<blockquote>\n<p id=\"so_20850536_20850536_0\">Whenever a glvalue appears in a context where a prvalue is expected, the glvalue is converted to a prvalue; see 4.1, 4.2, and 4.3. [Note: An attempt to bind an rvalue reference to an lvalue is not such a context; see 8.5.3 .\u2014end note]</p>\n</blockquote>\n<p>I understand what they describe in the note is the following:</p>\n<pre><code>int x = 1;\nint &amp;&amp; y = x; //in this declaration context, x won't bind to y.\n// but the literal 1 would have bound, so this is one context where the implicit \n// lvalue to rvalue conversion did not happen.  \n// The expression on right is an lvalue. if it had been a prvalue, it would have bound.\n// Therefore, the lvalue to prvalue conversion did not happen (which is good). \n</code></pre>\n<p>So, my question is (are):</p>\n<p>1) Could someone clarify the contexts where this conversion can happen implicitly? Specifically, other than the context of binding to an rvalue reference, are there any other where lvalue-to-rvalue conversions fail to happen implicitly?  </p>\n<p>2) Also, the parenthetical <code>[Note:...]</code> in the clause makes it seem that we could have figured it out from the sentence before.  Which part of the standard would that be?  </p>\n<p>3) Does that mean that rvalue-reference binding is not a context where we expect a prvalue expression (on the right)? </p>\n<p>4) Like other conversions, does the glvalue-to-prvalue conversion involve work at runtime that would allow me to observe it?</p>\n<p>My aim here is not to ask if it is desirable to allow such a conversion. I'm trying to learn to explain to myself the behavior of this code using the standard as starting point. </p>\n<p>A good answer would go through the quote I placed above and explain (based on parsing the text) whether the note in it is also implicit from its text. It would then maybe add any other quotes that let me know the other contexts in which this conversion may fail to happen implicitly, or explain there are no more such contexts.  Perhaps a general discussion of why glvalue to prvalue is considered a conversion. </p>\n", "Tags": "<c++><c++11><implicit-conversion><lvalue-to-rvalue>", "OwnerUserId": "2392147", "AnswerCount": "2"}, "20999389": {"ParentId": "20850536", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2014-01-08T15:11:42.797", "Score": "16", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:54:46.690", "Id": "20999389", "OwnerUserId": "420683", "Body": "<p>I think the lvalue-to-rvalue conversion is more than just <em>use an lvalue where an rvalue is required</em>. It can create a copy of a class, and always yields a <em>value</em>, not an object.</p>\n<p>I'm using n3485 for \"C++11\" and n1256 for \"C99\".</p>\n<hr>\n<h2>Objects and values</h2>\n<p>The most concise description is in C99/3.14:</p>\n<blockquote>\n<p id=\"so_20850536_20999389_0\"><strong>object</strong></p>\n<p id=\"so_20850536_20999389_1\">region of data storage in the execution environment, the contents of which can represent\n  values</p>\n</blockquote>\n<p>There's also a bit in C++11/[intro.object]/1</p>\n<blockquote>\n<p id=\"so_20850536_20999389_2\">Some objects are <em>polymorphic</em>; the implementation generates information associated with\n  each such object that makes it possible to determine that object\u2019s type during program execution. For other objects, the interpretation of the values found therein is determined by the type of the expressions used to access them.</p>\n</blockquote>\n<p>So an object contains a value (can contain).</p>\n<hr>\n<h2>Value categories</h2>\n<p>Despite its name, <em>value categories</em> classify expressions, not values. lvalue-expressions even <em>cannot</em> be considered values.</p>\n<p>The full taxonomy / categorization can be found in [basic.lval]; <a href=\"https://stackoverflow.com/q/3601602/420683\">here's a StackOverflow discussion</a>.</p>\n<p>Here are the parts about objects:</p>\n<blockquote id=\"so_20850536_20999389_3\">\n<ul>\n<li>An <em>lvalue</em> ([...]) designates a function or an object. [...]</li>\n<li>An <em>xvalue</em> (an \u201ceXpiring\u201d value) also refers to an object [...]</li>\n<li>A <em>glvalue</em> (\u201cgeneralized\u201d lvalue) is an lvalue or an xvalue.</li>\n<li>An <em>rvalue</em> ([...]) is an xvalue, a temporary object or subobject thereof, or a value that is not associated with an object.</li>\n<li>A prvalue (\u201cpure\u201d rvalue) is an rvalue that is not an xvalue. [...]</li>\n</ul>\n</blockquote>\n<p>Note the phrase \"a value that is not associated with an object\". Also note that as xvalue-expressions refer to objects, true <em>values</em> must always occur as prvalue-expressions.</p>\n<hr>\n<h2>The lvalue-to-rvalue conversion</h2>\n<p>As footnote 53 indicates, it should now be called \"glvalue-to-prvalue conversion\". First, here's the quote:</p>\n<blockquote>\n<p id=\"so_20850536_20999389_4\">1 \u00a0\u00a0 A glvalue of a non-function, non-array type <code>T</code> can be converted to a prvalue. If <code>T</code> is an incomplete type, a program that necessitates this conversion is ill-formed. If the object to which the glvalue refers is not an object of type <code>T</code> and is not an object of a type derived from <code>T</code>, or if the object is uninitialized, a program\n  that necessitates this conversion has undefined behavior. If <code>T</code> is a non-class type, the type of the prvalue is the cv-unqualified version of <code>T</code>. Otherwise, the type of the prvalue is <code>T</code>.</p>\n</blockquote>\n<p>This first paragraph specifies the requirements and the resulting type of the conversion. It isn't yet concerned with the <em>effects</em> of the conversion (other than Undefined Behaviour).</p>\n<blockquote>\n<p id=\"so_20850536_20999389_5\">2 \u00a0\u00a0 When an lvalue-to-rvalue conversion occurs in an unevaluated operand or a subexpression thereof the value contained in the referenced object is not accessed. Otherwise, if the glvalue has a class type, the conversion copy-initializes a temporary of type <code>T</code> from the glvalue and the result of the conversion is a prvalue for the temporary. Otherwise, if the glvalue has (possibly cv-qualified) type <code>std::nullptr_t</code>, the\n  prvalue result is a null pointer constant. Otherwise, the value contained in the object indicated by the glvalue is the prvalue result.</p>\n</blockquote>\n<p>I'd argue that you'll see the lvalue-to-rvalue conversion most often applied to non-class types. For example,</p>\n<pre><code>struct my_class { int m; };\n\nmy_class x{42};\nmy_class y{0};\n\nx = y;\n</code></pre>\n<p>The expression <code>x = y</code> does <em>not</em> apply the lvalue-to-rvalue conversion to <code>y</code> (that would create a temporary <code>my_class</code>, by the way). The reason is that <code>x = y</code> is interpreted as <code>x.operator=(y)</code>, which takes <code>y</code> per default <em>by reference</em>, not <em>by value</em> (for reference binding, see below; it cannot bind an rvalue, as that would be a temporary object different from <code>y</code>). However, the default definition of <code>my_class::operator=</code> does apply the lvalue-to-rvalue conversion to <code>x.m</code>.</p>\n<p>Therefore, the most important part to me seems to be</p>\n<blockquote>\n<p id=\"so_20850536_20999389_6\">Otherwise, the value contained in the object indicated by the glvalue is the prvalue result.</p>\n</blockquote>\n<p>So typically, an lvalue-to-rvalue conversion will just <em>read the value from an object</em>. It isn't just a no-op conversion between value (expression) categories; it can even create a temporary by calling a copy constructor. And the lvalue-to-rvalue conversion always returns a prvalue <em>value</em>, not a (temporary) <em>object</em>.</p>\n<p>Note that the lvalue-to-rvalue conversion is not the only conversion that converts an lvalue to a prvalue: There's also the array-to-pointer conversion and the function-to-pointer conversion.</p>\n<hr>\n<h2>values and expressions</h2>\n<p>Most expressions don't yield objects<sup>[[citation needed]]</sup>. However, an <em>id-expression</em> can be an <em>identifier</em>, which denotes an <em>entity</em>. An object is an entity, so there are expressions which yield objects:</p>\n<pre><code>int x;\nx = 5;\n</code></pre>\n<p>The left hand side of the <em>assignment-expression</em> <code>x = 5</code> also needs to be an expression. <code>x</code> here is an <em>id-expression</em>, because <code>x</code> is an identifier. The result of this <em>id-expression</em> is <em>the object denoted by <code>x</code></em>.</p>\n<p>Expressions apply implicit conversions: [expr]/9</p>\n<blockquote>\n<p id=\"so_20850536_20999389_7\">Whenever a glvalue expression appears as an operand of an operator that expects a prvalue for that operand, the lvalue-to-rvalue, array-to-pointer, or function-to-pointer standard conversions are applied to convert the expression to a prvalue.</p>\n</blockquote>\n<p>And /10 about <em>usual arithmetic conversions</em> as well as /3 about user-defined conversions.</p>\n<p>I'd love now to quote an operator that \"expects a prvalue for that operand\", but cannot find any but casts. For example, [expr.dynamic.cast]/2 \"If <code>T</code> is a pointer type, <code>v</code> [the operand] shall be a prvalue of a pointer to complete class type\".</p>\n<p>The <em>usual arithmetic conversions</em> required by many arithmetic operators do invoke an lvalue-to-rvalue conversion indirectly via the standard conversion used. All standard conversions but the three that convert from lvalues to rvalues expect prvalues.</p>\n<p>The simple assignment however doesn't invoke the usual arithmetic conversions. It is defined in [expr.ass]/2 as:</p>\n<blockquote>\n<p id=\"so_20850536_20999389_8\">In simple assignment (<code>=</code>), the value of the expression replaces that of the object referred to by the left operand.</p>\n</blockquote>\n<p>So although it doesn't explicitly require a prvalue expression on the right hand side, it does require a <em>value</em>. It is not clear to me if this <em>strictly</em> requires the lvalue-to-rvalue conversion. There's an argument that accessing the value of an uninitialized variable should always invoke undefined behaviour (also see <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#616\" rel=\"nofollow noreferrer\">CWG 616</a>), no matter if it's by assigning its value to an object or by adding its value to another value. But this undefined behaviour is only required for an lvalue-to-rvalue conversion (AFAIK), which then should be the only way to access the value stored in an object.</p>\n<p>If this more conceptual view is valid, that we need the lvalue-to-rvalue conversion to access the value inside an object, then it'd be much easier to understand where it is (and needs to be) applied.</p>\n<hr>\n<h2>Initialization</h2>\n<p>As with simple assignment, there's a <a href=\"https://stackoverflow.com/q/6376580/420683\">discussion</a> whether or not the lvalue-to-rvalue conversion is required to initialize another object:</p>\n<pre><code>int x = 42; // initializer is a non-string literal -&gt; prvalue\nint y = x;  // initializer is an object / lvalue\n</code></pre>\n<p>For fundamental types, [dcl.init]/17 last bullet point says:</p>\n<blockquote>\n<p id=\"so_20850536_20999389_9\">Otherwise, the initial value of the object being initialized is the (possibly converted) value of the initializer expression. Standard conversions will be used, if necessary, to convert the initializer expression to the cv-unqualified version of the destination type; no user-defined conversions are considered. If the conversion cannot be done, the initialization is ill-formed.</p>\n</blockquote>\n<p>However, it also mentioned the <em>value of the initializer expression</em>. Similar to the simple-assignment-expression, we can take this as an indirect invocation of the lvalue-to-rvalue conversion.</p>\n<hr>\n<h2>Reference binding</h2>\n<p>If we see lvalue-to-rvalue conversion as a way to access the value of an object (plus the creation of a temporary for class type operands), we understand that it's <em>not</em> applied generally for binding to a reference: A reference is an lvalue, it always refers to an object. So if we bound values to references, we'd need to create temporary objects holding those values. And this is indeed the case if the initializer-expression of a reference is a prvalue (which is a value or a temporary object):</p>\n<pre><code>int const&amp; lr = 42; // create a temporary object, bind it to `r`\nint&amp;&amp; rv = 42;      // same\n</code></pre>\n<p>Binding a prvalue to an lvalue reference is prohibited, but prvalues of class types with conversion functions that yield lvalue references may be bound to lvalue references of the converted type.</p>\n<p>The complete description of reference binding in [dcl.init.ref] is rather long and rather off-topic. I think the essence of it relating to this question is that references refer to objects, therefore no glvalue-to-prvalue (object-to-value) conversion.</p>\n</hr></hr></hr></hr></hr></hr>", "LastActivityDate": "2014-01-08T15:23:11.343"}, "bq_ids": {"n4140": {"so_20850536_20999389_9": {"section_id": 3296, "quality": 0.9655172413793104, "length": 28}, "so_20850536_20999389_4": {"section_id": 8, "quality": 0.5714285714285714, "length": 20}, "so_20850536_20999389_7": {"section_id": 5942, "quality": 1.0, "length": 17}, "so_20850536_20999389_2": {"section_id": 5790, "quality": 0.9310344827586207, "length": 27}, "so_20850536_20999389_5": {"section_id": 9, "quality": 0.6666666666666666, "length": 30}, "so_20850536_20999389_6": {"section_id": 9, "quality": 1.0, "length": 8}, "so_20850536_20999389_3": {"section_id": 7230, "quality": 0.8275862068965517, "length": 24}, "so_20850536_20850536_0": {"section_id": 7231, "quality": 0.8260869565217391, "length": 19}, "so_20850536_20999389_8": {"section_id": 6174, "quality": 1.0, "length": 9}}, "n3337": {"so_20850536_20999389_9": {"section_id": 3166, "quality": 0.9655172413793104, "length": 28}, "so_20850536_20999389_4": {"section_id": 5, "quality": 1.0, "length": 35}, "so_20850536_20999389_7": {"section_id": 5713, "quality": 1.0, "length": 17}, "so_20850536_20999389_2": {"section_id": 5563, "quality": 0.9310344827586207, "length": 27}, "so_20850536_20999389_5": {"section_id": 6, "quality": 1.0, "length": 45}, "so_20850536_20999389_6": {"section_id": 6, "quality": 1.0, "length": 8}, "so_20850536_20999389_3": {"section_id": 6974, "quality": 0.8275862068965517, "length": 24}, "so_20850536_20850536_0": {"section_id": 6975, "quality": 0.8260869565217391, "length": 19}, "so_20850536_20999389_8": {"section_id": 5935, "quality": 1.0, "length": 9}}, "n4659": {"so_20850536_20999389_9": {"section_id": 4058, "quality": 0.9655172413793104, "length": 28}, "so_20850536_20999389_4": {"section_id": 8, "quality": 0.5714285714285714, "length": 20}, "so_20850536_20999389_8": {"section_id": 7676, "quality": 1.0, "length": 9}, "so_20850536_20999389_2": {"section_id": 7247, "quality": 0.9655172413793104, "length": 28}, "so_20850536_20999389_6": {"section_id": 10, "quality": 1.0, "length": 8}, "so_20850536_20999389_7": {"section_id": 7426, "quality": 1.0, "length": 17}, "so_20850536_20850536_0": {"section_id": 8743, "quality": 0.8260869565217391, "length": 19}}}});