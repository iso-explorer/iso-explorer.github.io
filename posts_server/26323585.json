post_cb({"bq_ids": {"n4140": {"so_26323585_26323722_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 32}}, "n3337": {"so_26323585_26323722_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 29}}, "n4659": {"so_26323585_26323722_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 32}}}, "26323585": {"ViewCount": "480", "Body": "<p>In a code compiled on i386 Linux using g++, I have used <code>static_cast&lt;char&gt;()</code> cast on a value that might exceed the valid range of -128,127 for a <code>char</code>. There were no errors or exceptions and so I used the code in production.</p>\n<p>The problem is now I don't know how this code might behave when a value outside this range is thrown at it. There is no problem if data is modified or truncated, I only need to know how this modification behaves on this particular platform.</p>\n<p>Also what would happen if C-style cast (<code>(char)value</code>) had been used? would it behave differently?</p>\n", "Title": "In C++, what happens when I use static_cast<char> on an integer value outside -128,127 range?", "CreationDate": "2014-10-12T09:16:56.767", "LastActivityDate": "2014-10-14T06:29:03.793", "CommentCount": "4", "LastEditDate": "2014-10-14T06:29:03.793", "PostTypeId": "1", "LastEditorUserId": "1461719", "Id": "26323585", "Score": "4", "OwnerUserId": "1461719", "Tags": "<c++><linux><g++>", "AnswerCount": "3"}, "26328626": {"Id": "26328626", "PostTypeId": "2", "Body": "<p>This is dealt with in \u00a74.7 of the standard (integral conversions).</p>\n<p>The answer depends on whether in the implementation in question char is signed or unsigned.  If it is unsigned, then modulo arithmetic is applied. \u00a74.7/2 of C++11 states: \"If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2 n where n is the number of bits used to represent the unsigned type).\" This means that if the input integer is not negative, the normal bit truncation you expect will arise.  If is is negative, the same will apply if negative numbers are represented by 2's complement, otherwise the conversion will be bit altering.</p>\n<p>If char is signed, \u00a74.7/3 of C++11 applies: \"If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, the value is implementation-defined.\"  So it is up to the documentation for the particular implementation you use.  Having said that, on 2's complement systems (ie all those in normal use) I have not seen a case where anything other than normal bit truncation occurs for char types: apart from anything else, by virtue of \u00a73.9.1/1 of the c++11 standard all character types (char, unsigned char and signed char) must have the same object representation and alignment.</p>\n<p>The effect of a C style case, an explicit static_cast and an implicit narrowing conversion is the same.</p>\n", "LastActivityDate": "2014-10-12T18:42:43.073", "CommentCount": "0", "CreationDate": "2014-10-12T18:42:43.073", "ParentId": "26323585", "Score": "2", "OwnerUserId": "2615801"}, "26323722": {"Id": "26323722", "PostTypeId": "2", "Body": "<p>In your case this would be an explicit type conversion. Or to be more precise an integral conversions.<br>\nThe standard says about this(4.7):</br></p>\n<blockquote>\n<p id=\"so_26323585_26323722_0\">If the destination type is signed, the value is unchanged if it can be represented in the  destination type (and\n  bit-field width); otherwise, the value is implementation-defined.</p>\n</blockquote>\n<p>So your problem is implementation-defined. On the other hand I have not yet seen a compiler that does not just truncate the larger value to the smaller one. And I have never seen any compiler that uses the rule mentioned above.\nSo it should be fairly safe to just cast your <code>integer/short</code> to the char.</p>\n<p>I don't know the rules for an C cast by heart and I really try to avoid them because it is not easy to say which rule will kick in.</p>\n", "LastActivityDate": "2014-10-12T09:34:13.997", "CommentCount": "2", "CreationDate": "2014-10-12T09:34:13.997", "ParentId": "26323585", "Score": "4", "OwnerUserId": "264338"}, "26323856": {"Id": "26323856", "PostTypeId": "2", "Body": "<p>Technically the language specs for unsigned types agree in inposing a plain base-2. And for unsigned plain base-2 its pretty obvious what extension and truncation do.</p>\n<p>When going to unsigned, however, the specs are more \"tolerant\" allowing potentially different kind of processor to use different ways to represent signed numbers. And since a same number may have in different platform different representations is practically not possible to provide a description on what happen to it when adding or removing bits.</p>\n<p>For this reason, language specification remain more vague by saying that \"<em>the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, the value is implementation-defined</em>\"</p>\n<p>In other words, compiler manufacturer are required to do the best as they can to keep the numeric value. But when this cannot be done, they are free to adapt to what is more efficient for them.</p>\n", "LastActivityDate": "2014-10-12T09:52:00.067", "CommentCount": "0", "CreationDate": "2014-10-12T09:52:00.067", "ParentId": "26323585", "Score": "1", "OwnerUserId": "924727"}});