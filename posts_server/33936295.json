post_cb({"bq_ids": {"n4140": {"so_33936295_33937081_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 6185}, "so_33936295_33937081_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 478}, "so_33936295_33937081_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 5916}}, "n3337": {"so_33936295_33937081_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 5946}, "so_33936295_33937081_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 469}, "so_33936295_33937081_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 5688}}, "n4659": {"so_33936295_33937081_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 7687}, "so_33936295_33937081_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 501}, "so_33936295_33937081_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 7687}}}, "33936295": {"ViewCount": "294", "Body": "<p>Playing with <code>constexpr</code> and <code>union</code> I found out, that I can't change active member of an <code>union</code> in <code>constexpr</code>. Just one exception: <code>union</code> of empty classes.</p>\n<pre><code>constexpr bool t()\n{\n    struct A {};\n    struct B {};\n    union U { A a; B b; } u{};\n    u.a = A{};\n    u.b = B{};\n    return true;\n}\nstatic_assert(t());\n\nconstexpr bool f()\n{\n    struct A { char c; };\n    struct B { char c; };\n    union U { A a; B b; } u{};\n    u.a = A{};\n    u.b = B{}; // error originating from here\n    return true;\n}\nstatic_assert(f());\n</code></pre>\n<p>First function may produce constant expression. But the second can't. Hard error says:</p>\n<pre><code>main.cpp:23:15: error: static_assert expression is not an integral constant expression\nstatic_assert(f());\n              ^~~\nmain.cpp:20:11: note: assignment to member 'b' of union with active member 'a' is not allowed in a constant expression\n    u.b = B{};\n          ^\nmain.cpp:20:9: note: in call to '&amp;u.b-&gt;operator=(B{})'\n    u.b = B{};\n        ^\nmain.cpp:23:15: note: in call to 'f()'\nstatic_assert(f());\n              ^\n1 error generated.\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/5e4b498e4a1e4185\" rel=\"nofollow\">LIVE EXAMPLE</a></p>\n<p>1.) Is it possible to change active member of <code>union</code> in constant expressions?</p>\n<p>I tried to destruct active member, but it is not allowed, due to destructors are not <code>constexpr</code> in general. Also I tried to use placement <code>operator new</code> (<code>::new (&amp;u.b) B{2};</code>), but also unusccessfull. <code>reinterpret_cast</code> also not allowed in constant expressions. Altering members of common initial subsequence prohibited too.</p>\n<p>2.) Are there a ways to make mutable (in sense of changing active alternative type) literal <code>boost::variant</code>-like type? How looks like its storage if it possible?</p>\n<p>3.) Is it undefined behaviour to make assignment to non-active members of <code>union</code> of trivially copy-assignable types <strong>at runtime</strong>? Is it undefined behaviour to construct non-active member of <code>union</code> of trivially-copyable types using placement <code>operator new</code> avoiding preliminary destruction of active member <strong>at runtime</strong>?</p>\n<h3>ADDITIONAL:</h3>\n<p>I can change entire literal type <code>union</code>, but not its non-active member:</p>\n<pre><code>constexpr\nbool\nf()\n{\n    struct A { char c; };\n    struct B { char c; };\n    union U \n    {\n        A a; B b; \n        constexpr U(A _a) : a(_a) { ; }  \n        constexpr U(B _b) : b(_b) { ; }  \n    };\n    U a(A{});\n    a.a = A{}; // check active member is A\n    U b(B{});\n    b.b = B{}; // check active member is B\n    a = b;\n    a = B{}; // active member is B!\n    return true;\n}\nstatic_assert(f());\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/6350e38cf7b00180\" rel=\"nofollow\">LIVE EXAMPLE</a></p>\n<p>Therefore for literal type <code>variant</code> of trivially copyable types conversion assignment operator would be <code>template&lt; typename T &gt; constexpr variant &amp; operator = (T &amp;&amp; x) { return *this = variant(std::forward&lt; T &gt;(x)); }</code>.</p>\n", "AcceptedAnswerId": "33937081", "Title": "Changing active member of union in constant expressions", "CreationDate": "2015-11-26T10:32:36.973", "Id": "33936295", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-11-26T11:19:45.007", "LastEditorUserId": "1430927", "LastActivityDate": "2015-11-26T20:41:25.980", "Score": "3", "OwnerUserId": "1430927", "Tags": "<c++><c++14><unions><constexpr><variant>", "AnswerCount": "1"}, "33937081": {"Id": "33937081", "PostTypeId": "2", "Body": "<p><sup>Disclaimer: \"active\" is defined in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0137r0.html\" rel=\"nofollow\">P0137R0</a>.</sup></p>\n<blockquote>\n<p id=\"so_33936295_33937081_0\">Is it possible to change active member of union in constant\n  expressions?</p>\n</blockquote>\n<p>Not directly, since modifying a non-active member is prohibited - [expr.const]/(2.8):</p>\n<blockquote>\n<p id=\"so_33936295_33937081_1\">\u2014 an lvalue-to-rvalue conversion (4.1) or <strong>modification (5.18, 5.2.6,\n  5.3.2)</strong> that is applied to a glvalue that refers to a non-active member of a union or a subobject thereof;</p>\n</blockquote>\n<p>However, this wording seems defective, since it's indeed possible to \"modify\" a non-active member by assignment of another union object as shown in your example. In fact, the copy assignment operator performs a copy of the underlying bytes and the internal information about the active member:</p>\n<blockquote>\n<p id=\"so_33936295_33937081_2\">The implicitly-defined copy assignment operator for a union <code>X</code> copies\n  the object representation (3.9) of <code>X</code>.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_33936295_33937081_3\">Is it undefined behaviour to make assignment to non-active members of\n  union of trivially copy-assignable types at runtime?</p>\n</blockquote>\n<p>That's presumably fine for objects of a trivially copyable class type, since those have trivial destructors and copy constructors/assignment operators. Although underspecified, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1116\" rel=\"nofollow\">CWG #1116</a> seems to imply that it's intended to work:</p>\n<blockquote>\n<p id=\"so_33936295_33937081_4\">We never say what the active member of a union is, how it can be\n  changed, and so on. The Standard doesn't make clear whether the\n  following is valid:</p>\n<pre><code>union U { int a; short b; } u = { 0 };\nint x = u.a; // presumably this is OK, but we never say that a is the active member\nu.b = 0;     // not clear whether this is valid\n</code></pre>\n</blockquote>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2015-11-26T20:41:25.980", "Score": "4", "CreationDate": "2015-11-26T11:09:18.330", "ParentId": "33936295", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2015-11-26T20:41:25.980"}});