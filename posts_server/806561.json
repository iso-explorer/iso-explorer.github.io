post_cb({"807643": {"Id": "807643", "PostTypeId": "2", "Body": "<p>Heh heh, this problem tickles something buried deep in my head somewhere.  I can't quite put my finger on it but I think it's to do with defining an interface heirarchy and then inheriting both an interface and an implementation.  You then avoid having to implement all functions with by forwarding calls to a base class.  I think.</p>\n<p>I think this simple example shows the same thing, but is maybe a bit easier to understand because it uses things that can be easily visualized: (please forgive the struct laziness)</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Vehicle\n{\n    virtual void Drive() = 0;\n};\n\nstruct VehicleImp : virtual public Vehicle\n{\n    virtual void Drive() \n    {\n        cout &lt;&lt; \"VehicleImp::Drive\\n\";\n    }\n};\n\nstruct Tank : virtual public Vehicle\n{ \n    virtual void RotateTurret() = 0;\n};\n\nstruct TankImp : public Tank, public VehicleImp\n{\n    virtual void RotateTurret() \n    {\n        cout &lt;&lt; \"TankImp::RotateTurret\\n\";\n    }\n    // Could override Drive if we wanted\n};\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    TankImp myTank;\n    myTank.Drive();         // VehicleImp::Drive\n    myTank.RotateTurret();  // TankImp::RotateTurret\n    return 0;\n}\n</code></pre>\n<p>TankImp has essentially inherited the Tank interface and the Vehicle implementation.</p>\n<p>Now, I'm pretty sure this is a well known and acceptable thing in OO circles (but I don't know if it has a fancy name), so the dreaded diamond thing is ok in this case, and you can safely suppress the dominance warning because it's what you want to happen in this case.</p>\n<p>Hope that somehow helps point you in the right direction!</p>\n<p>BTW, your code didn't compile because you hadn't implemented the pure virtual \"method\" in Class2.</p>\n<p><strong>EDIT:</strong></p>\n<p>Ok I think I understand your problem better now and I think the mistake is in Interface2.  Try changing it to this:</p>\n<pre><code>// specialized interface\nclass Interface2: public virtual Interface // ADDED VIRTUAL\n{\npublic:\n    //virtual int method() = 0;   COMMENTED THIS OUT\n    // some other methods here\n};\n</code></pre>\n<p>Interface2 should not have the pure virtual defintion of method, since that is already in Interface.</p>\n<p>The inheritance of Interface needs to be virtual otherwise you will have an ambiguity with Base::method when you derive from Interface2 and Base in Class2.</p>\n<p>Now you should find it will compile, possibly with dominance warnings, and when you call c2.method(), you get 27.</p>\n", "LastEditorUserId": "79047", "LastActivityDate": "2009-04-30T20:50:21.630", "Score": "4", "CreationDate": "2009-04-30T15:54:42.340", "ParentId": "806561", "CommentCount": "4", "OwnerUserId": "79047", "LastEditDate": "2009-04-30T20:50:21.630"}, "807093": {"Id": "807093", "PostTypeId": "2", "Body": "<p><a href=\"http://www.velocityreviews.com/forums/showpost.php?p=3783768&amp;postcount=6\" rel=\"nofollow noreferrer\">This answer</a> in a different forum seems to tackle the exact problem you mention.</p>\n", "LastActivityDate": "2009-04-30T14:07:26.683", "CommentCount": "3", "CreationDate": "2009-04-30T14:07:26.683", "ParentId": "806561", "Score": "2", "OwnerUserId": "96780"}, "806604": {"Id": "806604", "PostTypeId": "2", "Body": "<p>Class2 inherits from an abstract class (Interface2) but does not implement the pure virtual method, so it remains as an abstract class.</p>\n", "LastEditorUserId": "63309", "LastActivityDate": "2009-04-30T12:20:11.060", "Score": "5", "CreationDate": "2009-04-30T12:12:48.470", "ParentId": "806561", "CommentCount": "5", "OwnerUserId": "63309", "LastEditDate": "2009-04-30T12:20:11.060"}, "806826": {"Id": "806826", "PostTypeId": "2", "Body": "<p>Based on this comment</p>\n<pre>\nIf the method is not reimplemented in Class2 or Class (it is not in \nthis case) Base::method() will be called. Otherwise the reimplementation \nwill be called. There is an interface hierarchy with a common base \ndumb implementation. \n\n\u2013 danatel 16 mins ago\n</pre>\n<p>That's not what you got, you don't have a common base, you've got </p>\n<pre><code>Interface -&gt; Interface2 -&gt; Class2\nInterface -&gt; Base -&gt; Class2\n</code></pre>\n<p>The interface is not 'merged' in the derivation tree, interface2 does not inherit virtually from interface, so it'll have its own interface super class.\nIt's like the pure virtual <code>method()</code> exists twice in Class2, once implemented via Class, and once not-implemented.</p>\n<p>And even if you had inherited virtually, the common base (Interface) still would not have an implementation</p>\n<p>If Base contains trivial operations that should be usuable in the whole hierarchy, then why not have Base as your startpoint? (even if still pure virtual with an implementation). </p>\n<p>If this was just a very simple example to make the question short, something like the <a href=\"http://en.wikipedia.org/wiki/Bridge_pattern\" rel=\"nofollow noreferrer\">Bridge Pattern</a> might be more usefull. But it's hard to guide you further without knowing more.</p>\n", "LastActivityDate": "2009-04-30T13:10:58.037", "CommentCount": "3", "CreationDate": "2009-04-30T13:10:58.037", "ParentId": "806561", "Score": "4", "OwnerUserId": "5822"}, "806561": {"ViewCount": "1067", "Body": "<p>I would like to use interfaces in c++ like in java or in c#. I decided to use purely abstract classes with multiple inheritance, but something is terribly wrong when I specialize the interface:</p>\n<pre><code>class Interface\n{\npublic:\n  virtual int method() = 0;\n};\n\n// Default implementation.\nclass Base: virtual public Interface\n{\npublic:\n  virtual int method() {return 27;}\n};\n\n// specialized interface\nclass Interface2: public Interface\n{\npublic:\n  virtual int method() = 0;\n// some other methods here\n};\n\n\n// concrete class - not specialised - OK\nclass Class: public virtual Interface, public virtual Base\n{\n};\n\n// concrete class - specialised\nclass Class2: public Interface2, public Base\n{\n};\n\n\n\nint main()\n{\n  Class c;\n  Class2 c2;\nreturn 0;\n}\n</code></pre>\n<p>Warning 1   warning C4250: 'Class' : inherits 'Base::Base::method' via dominance    30  </p>\n<p>Error   2   error C2259: 'Class2' : cannot instantiate abstract class   42  </p>\n<p>What is the proper way to do this?</p>\n", "AcceptedAnswerId": "807643", "Title": "Interfaces in c++", "CreationDate": "2009-04-30T12:02:14.550", "Id": "806561", "CommentCount": "14", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2009-05-01T02:59:09.323", "Score": "5", "OwnerUserId": "19884", "Tags": "<c++>", "AnswerCount": "7"}, "806718": {"Id": "806718", "PostTypeId": "2", "Body": "<p>You should also look at defining a virtual destructor in your Interface if you might be deleting using an Interface or Base pointer.</p>\n<p>Without a virtual destructor you will have problems if you do something like:</p>\n<pre><code>Base *b = new Class2();\ndelete b;\n</code></pre>\n", "LastActivityDate": "2009-04-30T12:45:09.673", "CommentCount": "3", "CreationDate": "2009-04-30T12:45:09.673", "ParentId": "806561", "Score": "3", "OwnerUserId": "93085"}, "bq_ids": {"n4140": {"so_806561_806644_0": {"length": 18, "quality": 0.9, "section_id": 5506}}, "n3337": {"so_806561_806644_0": {"length": 18, "quality": 0.9, "section_id": 5292}}, "n4659": {"so_806561_806644_0": {"length": 16, "quality": 0.8, "section_id": 6941}}}, "806855": {"Id": "806855", "PostTypeId": "2", "Body": "<p>In general, you should avoid the diamond inhertance pattern:</p>\n<pre><code>            Interface\n            /      \\\n          Base   Interface2\n            \\      /\n             Class2\n</code></pre>\n<p>This will cause you call kinds of grief down the road if you're not careful. Ambiguity will bite you.</p>\n<p>In your specific instance there's no need for Interface2 to inherit from Interface. Interface2 doesn't need to specify \"method\" since it's abstract. Remove the inheritance between Interface and Interface2 to break the diamond. Then you're hierarchy looks like:</p>\n<pre><code>        Interface                Interface  Interface2\n           |                          |       |\n          Base                      Base      |\n           |                           \\      /\n         Class                          Class2\n</code></pre>\n<p>And your implementation looks like:</p>\n<pre><code>// concrete class - not specialised - OK\nclass Class: public Base\n{\n};\n\n// concrete class - specialised\nclass Class2: public Base, public Interface2\n{\n    virtual int method() {return 35;}\n\n    virtual void Inteface2Method { ... }\n};\n</code></pre>\n", "LastActivityDate": "2009-04-30T13:19:22.167", "CommentCount": "1", "CreationDate": "2009-04-30T13:19:22.167", "ParentId": "806561", "Score": "1", "OwnerUserId": "48940"}, "806644": {"Id": "806644", "PostTypeId": "2", "Body": "<p><strong>Regarding <code>Class</code>:</strong> All you need to do is derive <code>Class</code> from <code>Base</code> -- the fact that it implements <code>Interface</code> is implied, and in fact, inescapable:</p>\n<pre><code>class Class: public Base  // virtual inheritance is unnecessary here\n{\n};\n</code></pre>\n<p><code>Class</code> will inherit <code>method()</code> from <code>Base</code> as desired.</p>\n<p><strong>Regarding <code>Class2</code>:</strong></p>\n<p><strong>Disclaimer: Negative result ahead</strong></p>\n<p>Based on your comment on <a href=\"https://stackoverflow.com/questions/806561/interfaces-in-c/806604#806604\">Tom's answer</a>, I <strong>thought I had</strong> the answer for <code>Class2</code>:</p>\n<pre><code>// concrete class - specialised\nclass Class2: public Interface2, public Base\n{\npublic:\n    using Base::method;    // \"Imports\" all members named \"method\" from Base\n};\n</code></pre>\n<p>But actually, this doesn't work.  Grovelling through the C++ standard reveals that \nsection 7.3.3, paragraph 14 explains that <code>using</code> can't be used to resolve ambiguous accesses to inherited members:</p>\n<blockquote>\n<p id=\"so_806561_806644_0\">... [Note: because a using-declaration designates a base class member (and not a member subobject or a member function of a base class subobject), a using-declaration cannot be used to resolve inherited member ambiguities. ...]</p>\n</blockquote>\n<p>It seems that the only way to get the desired behaviour in <code>Class2</code> is to manually forward the method:</p>\n<pre><code>// concrete class - specialised\nclass Class2: public Interface2, public Base\n{\npublic:\n     virtual int method() { return Base::method(); }\n};\n</code></pre>\n<p><strong>Regarding <code>virtual</code> inheritance:</strong> You <em>don't</em> need it for <code>Class</code>'s declaration, but you probably <em>do</em> need it for <code>Interface2</code>'s declaration to ensure that <code>Class2</code> only has a single subobject of type <code>Interface</code> -- as it stands, every <code>Class2</code> object has two subobjects of this type.  (Although that won't cause problems if <code>Interface</code> is in fact a pure interface, lacking member variables.)  If it helps, draw a diagram: every time a base class appears without the keyword <code>virtual</code>, it appears as a distinct object; all base classes that appear with the keyword <code>virtual</code> are condensed into one object.</p>\n<p><strong>[UPDATE: <a href=\"https://stackoverflow.com/questions/806561/interfaces-in-c/807643#807643\">markh44's excellent answer</a> shows that the above approach (of making <code>Interface2</code> inherit <em>virtually</em> from <code>Interface</code>) will in fact allow <code>Class2</code> to automatically inherit the implementation of <code>method()</code> from <code>Base</code>!  Problem solved!]</strong></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2009-05-01T02:59:09.323", "Score": "3", "CreationDate": "2009-04-30T12:23:46.450", "ParentId": "806561", "CommentCount": "2", "OwnerUserId": "47984", "LastEditDate": "2017-05-23T12:30:24.823"}});