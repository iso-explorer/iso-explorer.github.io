post_cb({"27492435": {"ViewCount": "171", "Body": "<p>3.10/10</p>\n<blockquote>\n<p id=\"so_27492435_27492435_0\">If a program attempts to access the stored value of an object through\n  a glvalue of other than one of the following types the behavior is\n  undefined:</p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>a type similar (as defined in 4.4) to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including,\n  recursively, an element or non-static data member of a subaggregate or\n  contained union),</li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>\n<li>a char or unsigned char type.</li>\n</ul>\n</blockquote>\n", "Title": "Example on how to access the value of an object through an xvalue, in order to provoke UB, as described in 3.10/10 in the C++11 Standard", "CreationDate": "2014-12-15T20:20:53.993", "LastActivityDate": "2014-12-15T23:47:44.207", "CommentCount": "4", "PostTypeId": "1", "Id": "27492435", "Score": "0", "OwnerUserId": "411165", "Tags": "<c++><c++11><strict-aliasing>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27492435_27492435_0": {"length": 14, "quality": 1.0, "section_id": 7239}}, "n3337": {"so_27492435_27492435_0": {"length": 14, "quality": 1.0, "section_id": 6983}}, "n4659": {"so_27492435_27492435_0": {"length": 14, "quality": 1.0, "section_id": 8748}}}, "27492569": {"Id": "27492569", "PostTypeId": "2", "Body": "<p><sup>Readers should be aware that the paragraph cited by the OP is a religious issue, as the basis of a disputed behavior of the g++ compiler. Any answer sowing doubt on the accuracy or completeness of this paragraph (and it's neither) will generally get downvoted on SO.</sup></p>\n<p>Here's an example of UB according to the paragraph you're citing:</p>\n<pre><code>struct X { int i; };\n\nauto main() -&gt; int\n{\n    X o{ 0 };\n    return reinterpret_cast&lt;int&amp;&gt;( o );\n}\n</code></pre>\n<p>Considering each possibility in C++11 \u00a73.10/10 in order:</p>\n<ul>\n<li><p>Is \u201cthe dynamic type of the object\u201d <code>o</code> an <code>int</code>?<br>\n<strong>No</strong>, the dynamic type is an <code>X</code>.</br></p></li>\n<li><p>Is <code>int</code> perhaps \u201ca <em>cv</em>-qualified version\u201d of the dynamic type X?<br>\n<strong>No</strong>, <code>X</code> is not an <code>int</code>, <em>cv</em>-qualified or not.</br></p></li>\n<li><p>Is <code>int</code> \u201ca type similar (as defined in 4.4) to the dynamic type of the object\u201d?<br>\nAgain, <strong>no</strong>. 4.4 deals with multi-level <em>cv</em>-qualification.</br></p></li>\n<li><p>Well, is <code>int</code> \u201ca type that is the signed or unsigned type corresponding to the dynamic type of the object\u201d?<br>\n<strong>No</strong>, there are no signed or unsigned versions of a class type like <code>X</code>.</br></p></li>\n<li><p>So what about \u201ca type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object\u201d?<br>\n<strong>No</strong>.</br></p></li>\n<li><p>Well, is <code>int</code> perhaps \u201can aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including, recursively, an element or non-static data member of a subaggregate or contained union)\u201d?<br>\n<strong>No</strong>, not that either.</br></p></li>\n<li><p>So maybe <code>int</code> is \u201ca type that is a (possibly cv-qualified) base class type of the dynamic type of the object\u201d?<br>\n<strong>No</strong>, an <code>int</code> can\u2019t be a base class.</br></p></li>\n<li><p>Finally, is <code>int</code> \u201ca <code>char</code> or <code>unsigned char</code> type\u201d?<br>\n<strong>No</strong>.</br></p></li>\n</ul>\n<p>And this exhausts all possibilities, proving that according to <em>that</em> paragraph in isolation, this code has Undefined Behavior.</p>\n<p>However, this code is guaranteed to work by another part of the standard (I guess mainly for C compatibility).</p>\n<p>So, the paragraph you cite isn't 100% good even for the completely platform-independent formal.</p>\n<hr>\n<p><strong>Edit</strong>: \"dyp\" asked in a comment how this relates to use of an xvalue. An xvalue is a glvalue, so one can just substitute an xvalue for the lvalue expression <code>o</code>. An example of such xvalue is an rvalue reference returned from a function, e.g. from <code>std::move</code>:</p>\n<pre><code>#include &lt;utility&gt;\nusing std::move;\n\nstruct X { int i; };\n\ntemplate&lt; class T &gt;\nauto ref( T&amp;&amp; r ) -&gt; T&amp; { return r; }\n\nauto main() -&gt; int\n{\n    X o{ 0 };\n    return reinterpret_cast&lt;int&amp;&gt;( ref( move( o ) ) );\n}\n</code></pre>\n<p>All this does is however to mask the essentials.</p>\n</hr>", "LastEditorUserId": "464581", "LastActivityDate": "2014-12-15T23:47:44.207", "Score": "-5", "CreationDate": "2014-12-15T20:30:56.430", "ParentId": "27492435", "CommentCount": "22", "LastEditDate": "2014-12-15T23:47:44.207", "OwnerUserId": "464581"}});