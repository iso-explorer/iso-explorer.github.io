post_cb({"bq_ids": {"n4659": {"so_37104610_37104610_0": {"section_id": 7797, "quality": 0.6666666666666666, "length": 4}}}, "37104655": {"ParentId": "37104610", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Two problems here:</p>\n<pre><code>for(auto a : args)\n{\n    args_p.push_back(a.c_str());\n}\n</code></pre>\n<p>First, <code>c_str()</code> returns a <code>char const*</code> and <code>args_p</code> is a <code>vector&lt;char*&gt;</code>. Since you need a pointer to non-<code>const</code> <code>char</code>, you'll have to use <code>&amp;a[0]</code>. </p>\n<p>Second, <code>a</code> goes out of scope at the end of each iteration of the loop. So the pointer that you're holding onto will get destroyed out from under you. You need the pointers into the actual strings in <code>args</code> - so you'll need to iterate by reference:</p>\n<pre><code>for(auto&amp; a : args)\n{\n    args_p.push_back(&amp;a[0]);\n}\n</code></pre>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2016-05-08T21:04:29.767", "Id": "37104655", "Score": "2", "CreationDate": "2016-05-08T20:48:00.900", "LastActivityDate": "2016-05-08T21:04:29.767"}, "37104610": {"CommentCount": "5", "AcceptedAnswerId": "37104655", "LastEditDate": "2016-05-08T21:10:20.347", "LastEditorUserId": "212378", "CreationDate": "2016-05-08T20:42:36.683", "LastActivityDate": "2016-05-08T21:10:20.347", "PostTypeId": "1", "ViewCount": "88", "Title": "Did the lifetime of c_str() changed between g++ 4.8.4 and g++ 5.3.1?", "Id": "37104610", "OwnerUserId": "212378", "Body": "<p>I start processes from a daemon which makes sure that said processes run continuously and get started in the proper order, etc.</p>\n<p>At some point, I want to start the process with <code>execv()</code> so I prepare an array of string for the arguments as so:</p>\n<pre><code>std::vector&lt;std::string&gt; args;\nargs.push_back(\"--debug\");\nargs.push_back(\"--connect\");\nargs.push_back(\"10.0.0.5:4040\");\n...\n</code></pre>\n<p>In most cases, I have around 10 such arguments.</p>\n<p>Now, <code>execv()</code> only access an array of bare pointers. So I do the following to create an array of such pointers:</p>\n<pre><code>std::vector&lt;char *&gt; args_p; // sorry, my code actually uses std::vector&lt;char const *&gt; args_p -- so constness is fine here\nfor(auto a : args)\n{\n    args_p.push_back(a.c_str());\n}\nargs_p.push_back(nullptr); // list needs to be null terminated\n</code></pre>\n<p>Then I can call <code>execv()</code> with that last array:</p>\n<pre><code>execv(\n    args_p[0],\n    const_cast&lt;char * const *&gt;(&amp;args_p[0])\n);\n</code></pre>\n<p>That was working perfectly in Ubuntu 14.04 with g++ 4.8.4, but somehow, the <code>c_str()</code> pointers get invalidated when I try to run the same code compiled with g++ 5.3.1.</p>\n<p>From my understanding, this should not be since I do not modify the strings between the first loop which creates the array of bare pointers and the <code>execv()</code> call.</p>\n<p>The <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/c_str\" rel=\"nofollow\">reference</a> says:</p>\n<blockquote>\n<p id=\"so_37104610_37104610_0\">The pointer obtained from c_str() may be invalidated by:</p>\n<ul>\n<li>Passing a non-const reference to the string to any standard library function, or</li>\n<li>Calling non-const member functions on the string, excluding operator[], at(), front(), back(), begin(), rbegin(), end() and rend().</li>\n</ul>\n</blockquote>\n<p><strong>P.S.</strong> I already have a fix, I now do an <code>stdup()</code> of the <code>c_str()</code> and it works just fine that way. Only I was hoping to avoid one extra copy of the string if possible...</p>\n", "Tags": "<c++><string><g++><g++4.8><g++5.1>", "Score": "1", "AnswerCount": "1"}});