post_cb({"bq_ids": {"n4140": {"so_14176320_14176510_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 6155}, "so_14176320_14176320_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 580}}, "n3337": {"so_14176320_14176510_0": {"length": 17, "quality": 1.0, "section_id": 5917}, "so_14176320_14176320_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 570}}, "n4659": {"so_14176320_14176510_0": {"length": 11, "quality": 0.6470588235294118, "section_id": 7652}, "so_14176320_14176320_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 603}}}, "14176320": {"ViewCount": "946", "Body": "<p>I've had a really bizarre problem that I've reduced to the following test case:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n\nstruct Test\n{\n    std::map&lt;std::string, void (Test::*)()&gt; m;\n    Test()\n    {\n        this-&gt;m[\"test1\"] = &amp;Test::test1;\n        this-&gt;m[\"test2\"] = &amp;Test::test2;\n    }\n    void test1() { }\n    void test2() { }\n    void dispatch(std::string s)\n    {\n        if (this-&gt;m.at(s) == &amp;Test::test1)\n        { std::cout &lt;&lt; \"test1 will be called...\" &lt;&lt; std::endl; }\n        else if (this-&gt;m.at(s) == &amp;Test::test2)\n        { std::cout &lt;&lt; \"test2 will be called...\" &lt;&lt; std::endl; }\n        (this-&gt;*this-&gt;m.at(s))();\n    }\n};\n\nint main()\n{\n    Test t;\n    t.dispatch(\"test1\");\n    t.dispatch(\"test2\");\n}\n</code></pre>\n<p>It outputs</p>\n<blockquote>\n<p id=\"so_14176320_14176320_0\">test1 will be called...<br>\n  test1 will be called...</br></p>\n</blockquote>\n<p>when optimizations are enabled, which is really bizarre. What's going on?</p>\n", "AcceptedAnswerId": "14176322", "Title": "Why are (member) function pointers behaving so weirdly in Visual C++?", "CreationDate": "2013-01-05T20:55:39.633", "Id": "14176320", "CommentCount": "23", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2013-01-09T01:53:20.240", "LastEditorUserId": "1380150", "LastActivityDate": "2013-01-09T01:53:20.240", "Score": "27", "OwnerUserId": "541686", "Tags": "<c++><visual-c++><linker>", "AnswerCount": "3"}, "14184695": {"Id": "14184695", "PostTypeId": "2", "Body": "<p>This is a by-product of what Visual C++ refers to as <strong>Identical COMDAT Folding</strong> (ICF).  It merges identical functions into a single instance. You can disable it by adding the following switch to the linker commandline: <code>/OPT:NOICF</code>   (from the Visual Studio UI it is found under <em>Properties-&gt;Linker-&gt;Optimization-&gt;Enable COMDAT Folding</em>)</p>\n<p>You can find details at the MSDN article here: <a href=\"http://msdn.microsoft.com/en-us/library/bxwfs976%28v=vs.110%29.aspx\">/OPT (Optimizations)</a></p>\n<p>The switch is a linker-stage switch, which means you won't be able to enable it just for a specific module or a specific region of code (such as <code>__pragma( optimize() )</code> which is available for compiler-stage optimization).</p>\n<p>In general, however, it is considered poor practice to rely on either function pointers or literal string pointers (<code>const char*</code>) for testing uniqueness.  String folding is widely implemented by almost all C/C++ compilers.  Function folding is only available on Visual C++ at this time, though increased widespread use of template&lt;&gt; meta-programming has increased requests for this feature to be added to gcc and clang toolchains.</p>\n<p>Edit: Starting with binutils 2.19, the included gold linker supposedly also supports ICF, though I have been unable to verify it on my local Ubuntu 12.10 install.</p>\n", "LastEditorUserId": "786437", "LastActivityDate": "2013-01-07T14:16:37.897", "Score": "27", "CreationDate": "2013-01-06T17:22:32.293", "ParentId": "14176320", "CommentCount": "1", "OwnerUserId": "786437", "LastEditDate": "2013-01-07T14:16:37.897"}, "14176510": {"Id": "14176510", "PostTypeId": "2", "Body": "<p>C++11 5.3.1 describes what <code>&amp;</code> does; in this instance, it gives you a pointer to the member function in question, and the passage makes no requirement that this pointer must be unique.</p>\n<p>However, 5.10/1 says about <code>==</code>:</p>\n<blockquote>\n<p id=\"so_14176320_14176510_0\">Two pointers of the same type compare equal if and only if they are both null, both point to the same function, or both represent the same address.</p>\n</blockquote>\n<p>The question then becomes... are <code>test1</code> and <code>test2</code> \"the same function\"?</p>\n<p>Though the optimizer has collapsed them into a single definition, arguably the two names identify two functions and, as such, <strong>this would seem to be an implementation bug</strong>.</p>\n<p>(Note, though, that the VS team don't care and consider it \"valid enough\" to warrant the benefits of the optimisation. That, or <a href=\"http://social.msdn.microsoft.com/Forums/en/vclanguage/thread/dd91dae2-6f9d-4a46-b1dd-753c2b927119\">they don't realise that it's invalid</a>.)</p>\n<p>I'd stick to using the strings as \"handles\" for your function pointers.</p>\n", "LastActivityDate": "2013-01-05T21:19:22.607", "CommentCount": "10", "CreationDate": "2013-01-05T21:19:22.607", "ParentId": "14176320", "Score": "7", "OwnerUserId": "560648"}, "14176322": {"Id": "14176322", "PostTypeId": "2", "Body": "<p>It turns out Visual C++'s linker can merge functions with identical definitions into one.<br>\nWhether that's legal or not according to C++, I have no idea; it affects observable behavior, so it looks like a bug to me. Someone else with more information may want to chime in on that though.</br></p>\n", "LastActivityDate": "2013-01-05T20:55:39.633", "CommentCount": "15", "CreationDate": "2013-01-05T20:55:39.633", "ParentId": "14176320", "Score": "17", "OwnerUserId": "541686"}});