post_cb({"46574697": {"CommentCount": "2", "ViewCount": "149", "PostTypeId": "1", "LastEditorUserId": "1013719", "CreationDate": "2017-10-04T21:46:03.790", "LastActivityDate": "2017-10-04T22:38:54.360", "Title": "Defining a static data member of a templated class within a templated class", "LastEditDate": "2017-10-04T22:29:14.143", "Id": "46574697", "Score": "4", "Body": "<p>I have a class template inside of another class template. The inner class has a static data member. I am struggling to provide a definition for it. The below example works in clang 3.8 but not in gcc-7.1</p>\n<pre><code>template &lt;typename T&gt;\nstruct Out {\n  template &lt;typename U&gt;\n  struct In {\n    static int var;\n  };\n};\n\ntemplate &lt;typename T&gt;\ntemplate &lt;typename U&gt;\nint Out&lt;T&gt;::template In&lt;U&gt;::var;\n</code></pre>\n<p>gcc gives the error:</p>\n<pre><code>error: template definition of non-template \u2018int Out&lt;T&gt;::In&lt;U&gt;::var\u2019\n int Out&lt;T&gt;::template In&lt;U&gt;::var;\n                             ^~~\n</code></pre>\n<p>What do I gotta do to make gcc happy?</p>\n<hr>\n<p>Edit: turns out getting rid of <code>template</code> make this work:</p>\n<pre><code>template &lt;typename T&gt;\ntemplate &lt;typename U&gt;\nint Out&lt;T&gt;::In&lt;U&gt;::var;\n</code></pre>\n<p>Which still leaves the question, is <code>template</code> allowed here?</p>\n</hr>", "Tags": "<c++><templates><c++14>", "OwnerUserId": "1013719", "AnswerCount": "1"}, "46575224": {"ParentId": "46574697", "CommentCount": "2", "Body": "<p>This type of definition would more commonly be seen without the <code>template</code> before <code>In</code>.  The <code>template</code> keyword is not needed here because <code>Out&lt;T&gt;::In</code> is a \"member of the current specialization\".</p>\n<p>For the rule specifying when the <code>template</code> keyword is required before a member name, see [temp.names]/4.  For the definition of the technical term \"member of the current specialization\", see [temp.dep.type]/4.</p>\n<p>But the keyword is in fact allowed there, since the grammar permits it between any <code>::</code> and name, and the semantics require only that the name that follows is either used with template arguments or names a class template ([temp.names]/5), and there are no other rules in the Standard to forbid it.  And as a note in [temp.names]/5 explains:</p>\n<blockquote>\n<p id=\"so_46574697_46575224_0\">[ <em>Note:</em> As is the case with the <code>typename</code> prefix, the <code>template</code> prefix is allowed in cases where it is not strictly necessary; i.e., when the <em>nested-name-specifier</em> or the expression on the left of the <code>-&gt;</code> or <code>.</code> is not dependent on a template parameter, or the use does not appear in the scope of a template. - <em>end note</em>]</p>\n</blockquote>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "46575224", "Score": "0", "CreationDate": "2017-10-04T22:38:54.360", "LastActivityDate": "2017-10-04T22:38:54.360"}, "bq_ids": {"n4140": {"so_46574697_46575224_0": {"section_id": 73, "quality": 0.8, "length": 20}}, "n3337": {"so_46574697_46575224_0": {"section_id": 68, "quality": 0.8, "length": 20}}, "n4659": {"so_46574697_46575224_0": {"section_id": 75, "quality": 0.8, "length": 20}}}});