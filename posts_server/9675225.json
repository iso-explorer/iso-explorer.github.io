post_cb({"9675685": {"ParentId": "9675225", "CommentCount": "1", "Body": "<p>Your <code>operator new</code> implemented for your particular type will only be used on expressions on which elements of your type is <em>dynamically allocated</em> with <code>new</code>, such as <code>Test *p = new Test;</code>. Now <code>make_shared</code> does not <em>dynamically allocate</em> an object of your type, but rather a <em>buffer</em> that holds enough information for the <em>shared count</em> (which includes the counter, deleter and a few extra bits and pieces) and your object. </p>\n<p>It then uses <em>placement-new</em> to call the constructor of your object. Note that <em>placement new</em> in this case is not allocating memory, it is only the funny syntax in C++ to call the constructor on a block of already allocated memory. This might actually be the source of confusion, as the <code>new</code> expression, your <code>operator new</code> and <em>placement-new</em> are three different concepts that happen to share a name.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "9675685", "Score": "3", "CreationDate": "2012-03-12T22:26:37.777", "LastActivityDate": "2012-03-12T22:26:37.777"}, "9675579": {"ParentId": "9675225", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You may not replace placement new (<em>\u00a718.4.\u200b1.3</em>, see e.g. <a href=\"https://stackoverflow.com/q/3675059/168225\">this question</a>), so the output given seems fine.</p>\n<p>As an alternative to modifying the Boost headers, you could look into external tools like Valgrind.</p>\n", "OwnerUserId": "168225", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:59:53.937", "Id": "9675579", "Score": "4", "CreationDate": "2012-03-12T22:14:59.413", "LastActivityDate": "2012-03-12T22:26:38.883"}, "9675588": {"ParentId": "9675225", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Looking as the source of <code>make_shared</code>, it uses the global placement <code>new</code> operator, instead of the new operator supplied by your class.</p>\n<pre><code>::new( pv ) T();\n</code></pre>\n<p>Unfortunately <strike>(as least on OS X)</strike> (<a href=\"https://stackoverflow.com/a/3677129/115478\">according to the standard</a>), you cannot define your own global placement new operator.  It appears that <a href=\"http://www.boost.org/doc/libs/1_49_0/libs/smart_ptr/make_shared.html\" rel=\"nofollow noreferrer\"><code>allocate_shared</code></a> is more along the lines of what you're looking for.</p>\n<p><strong>Edit</strong>:</p>\n<p>An alternative could be to actually write a version of <code>make_shared</code> which uses the class's placement new instead of the global one. It's only about 10 lines of code, and should be fine so long as you honor <a href=\"http://www.boost.org/LICENSE_1_0.txt\" rel=\"nofollow noreferrer\">the license of the original code</a>. </p>\n", "OwnerUserId": "115478", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:59:53.937", "Id": "9675588", "Score": "8", "CreationDate": "2012-03-12T22:16:02.727", "LastActivityDate": "2012-03-12T22:40:10.760"}, "bq_ids": {"n4140": {"so_9675225_9675225_0": {"section_id": 4439, "quality": 0.8695652173913043, "length": 20}}, "n3337": {"so_9675225_9675225_0": {"section_id": 4276, "quality": 0.8695652173913043, "length": 20}}, "n4659": {"so_9675225_9675225_0": {"section_id": 5704, "quality": 0.782608695652174, "length": 18}}}, "9675225": {"CommentCount": "1", "AcceptedAnswerId": "9675588", "CreationDate": "2012-03-12T21:42:19.257", "LastActivityDate": "2012-03-12T22:40:10.760", "PostTypeId": "1", "ViewCount": "1401", "FavoriteCount": "1", "Title": "boost::make_shared is not calling (placement) operator new?", "Id": "9675225", "Score": "6", "Body": "<p>I am using boost::make_shared for the first time to create objects pointed to by shared pointers. Mainly because our code was too slow and the single allocation really helped to improve performance.</p>\n<p>After fixing some memory leaks \"the hard manual way\" I decided to implement a simple memory leak detector by overriding new operators for all relevant classes just for counting which objects are still alive at specific points in our application. I have implemented this several times before and was surprised to find my code no longer detects any objects.</p>\n<p>I figured that all I had to do is override \"placement new\" instead of the \"normal\" operator new's because of the following from the boost website documentation for make_shared:</p>\n<blockquote>\n<p id=\"so_9675225_9675225_0\">\"Effects: Allocates memory suitable for an object of type T <strong><em>and\n  constructs an object in it via the placement new expression new( pv )\n  T() or new( pv ) T( std::forward(args)... )</em></strong>. allocate_shared\n  uses a copy of a to allocate memory. If an exception is thrown, has no\n  effect.\"</p>\n</blockquote>\n<p>My placement new is also not being called however. I have written a small test program to reproduce the behavior:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n#include \"boost/shared_ptr.hpp\"\n#include \"boost/make_shared.hpp\"\n\nclass Test\n{\npublic:\n    Test() { cout &lt;&lt; \"Test::Test()\" &lt;&lt; endl; }\n\n    void* operator new (std::size_t size) throw (std::bad_alloc) {\n        cout &lt;&lt; \"Test new\" &lt;&lt; endl;\n        return malloc(size);\n    }\n\n    void* operator new (std::size_t size, const std::nothrow_t&amp; nothrow_constant) throw() {\n        cout &lt;&lt; \"Test non-throwing new\" &lt;&lt; endl;\n        return malloc(size);\n    }\n\n    void* operator new (std::size_t size, void* ptr) throw() {\n        cout &lt;&lt; \"Test non-throwing placement new\" &lt;&lt; endl;\n        return malloc(size);\n    }\n};\n\nvoid* operator new (std::size_t size) throw (std::bad_alloc) {\n    cout &lt;&lt; \"Global new\" &lt;&lt; endl;\n    return malloc(size);\n}\n\nint main() {\n    cout &lt;&lt; \"...\" &lt;&lt; endl;\n    boost::shared_ptr&lt;Test&gt; t1(boost::make_shared&lt;Test&gt;());\n    cout &lt;&lt; \"...\" &lt;&lt; endl;\n    boost::shared_ptr&lt;Test&gt; t2(new Test());\n    cout &lt;&lt; \"...\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>Which renders the following output:</p>\n<pre><code>...\nGlobal new\nTest::Test()\n...\nTest new\nTest::Test()\nGlobal new\n...\n</code></pre>\n<p>I was expecting \"Test non-throwing placement new\" on the 3rd line of output. What do you think the behavior should be? Do you agree that according to documentation of make_shared it should call the placement new operator of my Test class? Or did I misunderstand it? </p>\n<p>I could copy boosts implementation locally and add a call to the placement new operator of course. But, would that be appropriate, or would it violate the intended semantics of placement new?</p>\n<p>Thanks in advance for your time and your help.</p>\n", "Tags": "<c++><boost><new-operator><make-shared>", "OwnerUserId": "1265099", "AnswerCount": "3"}});