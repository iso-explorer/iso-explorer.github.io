post_cb({"18077898": {"CommentCount": "1", "CreationDate": "2013-08-06T10:40:25.647", "PostTypeId": "1", "AcceptedAnswerId": "18078119", "LastEditorUserId": "64046", "LastActivityDate": "2014-08-21T22:42:14.247", "LastEditDate": "2014-08-21T22:42:14.247", "ViewCount": "1664", "FavoriteCount": "1", "Title": "Destroy vs Deallocate", "Id": "18077898", "Score": "2", "Body": "<p>In chapter 11 of Accelerated C++, the authors present a Vector class emulating the behaviour of std::vector using arrays. They use the allocator class to handle memory management. The role of the <code>uncreate</code> function is to destroy each element of the array and deallocate the space allocated for the array:</p>\n<pre><code>template &lt;class T&gt; void Vec&lt;T&gt;::uncreate() {\n  if (data) {\n\n  // destroy (in reverse order) the elements that were constructed \n  iterator it = avail;\n  while (it != data)\n    alloc.destroy(--it);\n\n  // return all the space that was allocated\n  alloc.deallocate(data, limit - data); \n  }\n\n  // reset pointers to indicate that the Vec is empty again \n  data = limit = avail = 0;\n}\n</code></pre>\n<p>Obviously we need to deallocate allocated space. But it's unclear to me why we need to destroy individual elements as well. What would happen if we only deallocated memory without destroying individual elements? </p>\n", "Tags": "<c++><memory-management>", "OwnerUserId": "2564569", "AnswerCount": "2"}, "18078141": {"ParentId": "18077898", "CommentCount": "0", "Body": "<p>Destroying the individual elements ensures that their destructors are called and therefore they have a chance to free any resources they own.  Simply deallocating the memory would not call the destructor of the object placed in that memory.</p>\n", "OwnerUserId": "2634887", "PostTypeId": "2", "Id": "18078141", "Score": "4", "CreationDate": "2013-08-06T10:51:43.787", "LastActivityDate": "2013-08-06T10:51:43.787"}, "bq_ids": {"n4140": {"so_18077898_18078119_0": {"section_id": 7192, "quality": 0.9411764705882353, "length": 48}}, "n3337": {"so_18077898_18078119_0": {"section_id": 6936, "quality": 0.9411764705882353, "length": 48}}, "n4659": {"so_18077898_18078119_0": {"section_id": 8701, "quality": 0.9411764705882353, "length": 48}}}, "18078119": {"ParentId": "18077898", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The reason is that it'd might get you in trouble. The paragraph 4 from chapter 3.8 (Object lifetime) of C++standard explains why (emphasis mine):</p>\n<blockquote>\n<p id=\"so_18077898_18078119_0\">A program may end the lifetime of any object by reusing the storage which the object occupies or by explicitly\n  calling the destructor for an object of a class type with a non-trivial destructor. For an object of a class type\n  with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage\n  which the object occupies is reused or released; however, <strong>if there is no explicit call to the destructor or if a\n  delete-expression (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and\n  any program that depends on the side effects produced by the destructor has unde\ufb01ned behavior.</strong></p>\n</blockquote>\n<p>It means it's fine to do it on memory that's occupied by objects with trivial destructor(*) or objects that don't have one at all (such as <code>ints</code> and the like). But when the memory contains objects of a class that needs to do some work in the destructor (like closing network connections or files, flushing buffers, releasing memory), you'll leak resources (and formaly by the standard, invoke undefined behaviour).</p>\n<p>(*) A destructor is trivial if it's compiler generated, is not virtual, and all the non-static members and direct base classes of the class it is member of have trivial destructors.</p>\n", "OwnerUserId": "947836", "LastEditorUserId": "947836", "LastEditDate": "2013-08-06T11:03:02.003", "Id": "18078119", "Score": "8", "CreationDate": "2013-08-06T10:50:50.120", "LastActivityDate": "2013-08-06T11:03:02.003"}});