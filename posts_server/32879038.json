post_cb({"32879038": {"CommentCount": "1", "ViewCount": "268", "PostTypeId": "1", "LastEditorUserId": "1348273", "CreationDate": "2015-10-01T03:38:29.060", "LastActivityDate": "2015-10-01T07:58:08.263", "Title": "Identity of function template instantiation in multiple translation units", "AcceptedAnswerId": "32882323", "LastEditDate": "2015-10-01T03:54:40.823", "Id": "32879038", "Score": "2", "Body": "<p>According to <a href=\"http://en.cppreference.com/w/cpp/language/inline\" rel=\"nofollow\">cppref</a>, the identity characteristics of <code>inline</code> functions in multiple translation units are as follows:</p>\n<blockquote>\n<p id=\"so_32879038_32879038_0\">...</p>\n<p id=\"so_32879038_32879038_1\">2) It has the same address in every translation unit.</p>\n<p id=\"so_32879038_32879038_2\">3) Function-local static objects in all function definitions are\n  shared across all translation units (they all refer to the same object\n  defined in one translation unit)</p>\n<p id=\"so_32879038_32879038_3\">...</p>\n</blockquote>\n<p>Simply speaking, a singleton identity is implied.</p>\n<p>I'm wondering whether the same applies to function template instantiations <strong>without</strong> the <code>inline</code> specifier.</p>\n", "Tags": "<c++><templates><inline><language-lawyer><one-definition-rule>", "OwnerUserId": "1348273", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_32879038_32882323_1": {"section_id": 7043, "quality": 0.9052631578947369, "length": 86}, "so_32879038_32879038_1": {"section_id": 5404, "quality": 1.0, "length": 5}}, "n3337": {"so_32879038_32882323_1": {"section_id": 6788, "quality": 0.9157894736842105, "length": 87}, "so_32879038_32879038_1": {"section_id": 5199, "quality": 1.0, "length": 5}}, "n4659": {"so_32879038_32882323_1": {"section_id": 8540, "quality": 0.9052631578947369, "length": 86}, "so_32879038_32879038_1": {"section_id": 6853, "quality": 1.0, "length": 5}, "so_32879038_32879038_2": {"section_id": 8540, "quality": 0.55, "length": 11}}}, "32882323": {"ParentId": "32879038", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_32879038_32882323_0\">I'm wondering whether the same applies to function template instantiations without the inline specifier.</p>\n</blockquote>\n<p>The same applies to templates. See \u00a73.2 One definition rule:</p>\n<blockquote id=\"so_32879038_32882323_1\">\n<ol start=\"6\">\n<li>There can be more than one definition of a class type (Clause 9), enumeration type (7.2), inline function with external linkage (7.1.2), class template (Clause 14), <strong>non-static function template (14.5.6)</strong>, static data member of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for which some template parameters are not specified (14.7, 14.5.5) in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. ... <strong>If D is a template and is defined in more than one translation unit, then the preceding requirements shall apply both to names from the template\u2019s enclosing scope used in the template definition (14.6.3), and also to dependent names at the point of instantiation (14.6.2). If the definitions of D satisfy all these requirements, then the program shall behave as if there were a single definition of D.</strong> If the definitions of D do not satisfy these requirements, then the behavior is undefined.</li>\n</ol>\n</blockquote>\n", "OwnerUserId": "412080", "PostTypeId": "2", "Id": "32882323", "Score": "1", "CreationDate": "2015-10-01T07:58:08.263", "LastActivityDate": "2015-10-01T07:58:08.263"}});