post_cb({"26471420": {"ParentId": "26470912", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2014-10-20T17:27:07.747", "Score": "15", "LastEditorUserId": "950427", "LastEditDate": "2015-03-20T14:12:51.513", "Id": "26471420", "OwnerUserId": "1938163", "Body": "<ol>\n<li><p>Is legal, the second and the latter aren't because of the following reasons:</p></li>\n<li><p>The return type of the main function cannot be deduced since CWG 1669 was accepted and the standard will be reworded as:</p>\n<blockquote>\n<p id=\"so_26470912_26471420_0\">An implementation shall not predefine the main function. This function shall not be overloaded. It shall have a <strong>declared</strong> return type of type int, but otherwise its type is implementation-defined.</p>\n</blockquote>\n<p>This got its way into n4140. More on this: <a href=\"http://wg21.cmeerw.net/cwg/issue1669\" rel=\"nofollow\">http://wg21.cmeerw.net/cwg/issue1669</a></p></li>\n<li><p>The same as above</p></li>\n</ol>\n", "LastActivityDate": "2015-03-20T14:12:51.513"}, "26471113": {"ParentId": "26470912", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-10-20T17:06:56.303", "Score": "1", "LastEditorUserId": "649665", "LastEditDate": "2014-10-20T17:47:57.750", "Id": "26471113", "OwnerUserId": "649665", "Body": "<p>The first is probably legal.  The other two certainly not\n(\u00a77.1.6.4/1): \"The auto type-specifier signifies that the type\nof a variable being declared shall be deduced from its\ninitializer or that a function declarator shall include\na trailing-return-type.\" </p>\n<p>I say probably for the first, because \u00a73.6.1 isn't really clear\nto what degree the definition must match.  A 100% textual match\nisn't required, even if that is what a literal interpretation of\nwhat it says would imply: in the text, the body of <code>main</code> is\ngiven as <code>/* ... */</code>, which isn't very useful, and certainly\nisn't required.  Similarly, tradition has also allowed any name\nfor <code>argc</code> and <code>argv</code>, and declaring <code>argv</code> as <code>char** argv</code>.\nThere's no tradition about defining main with a trailing return\ntype, however.  I think that what was meant in \u00a73.6.1 is that\nall definitions of <code>main</code> which have the same signature would be\nallowed, but this is not what the actual words say.</p>\n<p>Regardless: why would one want such obfuscation?  C/C++ is not\nPascal, and what is natural in one language (like trailing\nreturn types for functions) is obfuscation in another. </p>\n<p>EDIT:</p>\n<p>I've just downloaded a more recent draft (N3797), and it seems\nlike the wording has changed (and is now contradictory).  The\nfirst paragraph still says basically the same thing (but\nincludes addtiional wording for for lambdas): the <code>auto</code> is\nreplaced \"either by deduction from an initializer or by explicit\nspecification with a trailing-return-type.\"  (And of course,\nfucntions don't have initializers, so only the\ntrailing-return-type can apply.)  Later paragraphs, however, do\nspeak about deduction from the return type, even though the\nfirst paragraph requires the trailing return type (and thus\nmakes deduction superfluous).</p>\n", "LastActivityDate": "2014-10-20T17:47:57.750"}, "bq_ids": {"n4140": {"so_26470912_26470912_3": {"section_id": 7149, "quality": 1.0, "length": 9}, "so_26470912_26471420_0": {"section_id": 7146, "quality": 0.8888888888888888, "length": 16}, "so_26470912_26470912_0": {"section_id": 7146, "quality": 0.8095238095238095, "length": 17}, "so_26470912_26470912_2": {"section_id": 7146, "quality": 1.0, "length": 7}}, "n3337": {"so_26470912_26470912_3": {"section_id": 6893, "quality": 1.0, "length": 9}, "so_26470912_26471420_0": {"section_id": 6890, "quality": 0.8333333333333334, "length": 15}, "so_26470912_26470912_0": {"section_id": 6890, "quality": 0.9047619047619048, "length": 19}, "so_26470912_26470912_2": {"section_id": 3073, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_26470912_26471420_0": {"section_id": 8647, "quality": 0.8888888888888888, "length": 16}, "so_26470912_26470912_0": {"section_id": 8647, "quality": 0.8095238095238095, "length": 17}, "so_26470912_26470912_2": {"section_id": 8647, "quality": 1.0, "length": 7}}}, "26470912": {"CommentCount": "9", "AcceptedAnswerId": "26471420", "PostTypeId": "1", "LastEditorUserId": "1938163", "CreationDate": "2014-10-20T16:54:38.867", "LastActivityDate": "2015-03-20T14:12:51.513", "LastEditDate": "2014-10-20T17:29:15.643", "ViewCount": "1219", "FavoriteCount": "3", "Title": "Legal definitions of main() in C++14", "Id": "26470912", "Score": "19", "Body": "<p>The last draft of C++14 that I was able to find says, regarding <code>main()</code> [3.6.1]:</p>\n<blockquote>\n<p id=\"so_26470912_26470912_0\">An implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return type of type int, but otherwise its type is implementation-defined. All implementations shall allow both</p>\n<p id=\"so_26470912_26470912_1\">\u2014 a function of () returning int and</p>\n<p id=\"so_26470912_26470912_2\">\u2014 a function of (int, pointer to pointer to char) returning int</p>\n</blockquote>\n<p>and (paragraph 5)</p>\n<blockquote>\n<p id=\"so_26470912_26470912_3\">If control reaches the end of main without encountering a return statement, the effect is that of executing</p>\n<p id=\"so_26470912_26470912_4\"><code>return 0;</code></p>\n</blockquote>\n<p>Does this mean that all of the following are legal C++14 minimal programs? If any isn't, why not?</p>\n<ol>\n<li><code>auto main() -&gt; int {}</code></li>\n<li><code>auto main() { return 0; }</code></li>\n<li><code>auto main() {}</code></li>\n</ol>\n", "Tags": "<c++><main><language-lawyer><c++14>", "OwnerUserId": "2797826", "AnswerCount": "2"}});