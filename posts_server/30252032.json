post_cb({"30252032": {"CommentCount": "2", "ViewCount": "392", "CreationDate": "2015-05-15T05:22:27.853", "LastActivityDate": "2015-05-15T06:46:03.997", "Title": "Invalid covariant type with CRTP clonable class", "AcceptedAnswerId": "30252370", "PostTypeId": "1", "Id": "30252032", "Score": "6", "Body": "<p>I'm trying to implement a Clonable class with the CRTP. However, I need to have abstract class that have a pure virtual clone method, overridden by child classes. To make this happen, I need the clone function to return a covariant return type. I made this code below, and the compiler shout at me this error:</p>\n<pre><code>main.cpp:12:5: error: return type of virtual function 'clone' is not covariant with the return type of the function it overrides ('B *' is not derived from 'AbstractClonable *')\n</code></pre>\n<p>The class 'B' seems to be a child class of AbstractClonable, and even by two way! How can I solve this? Thank you very much. I tried with both with clang 3.6 and GCC 4.9.2</p>\n<pre><code>struct AbstractClonable {\n    virtual AbstractClonable* clone() const = 0;\n};\n\ntemplate&lt;typename T&gt;\nstruct Clonable : virtual AbstractClonable {\n    T* clone() const override {\n        return new T{*dynamic_cast&lt;const T*&gt;(this)};\n    }\n};\n\nstruct A : virtual AbstractClonable {\n\n};\n\nstruct B : A, Clonable&lt;B&gt; {\n\n};\n</code></pre>\n", "Tags": "<c++><multiple-inheritance><crtp><cloneable><covariant>", "OwnerUserId": "2104697", "AnswerCount": "3"}, "30252280": {"ParentId": "30252032", "CommentCount": "2", "Body": "<p>I think the problem is that</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>T* clone() const override{\n    return new T{*dynamic_cast&lt;const T*&gt;(this)};\n}\n</code></pre>\n<p>returns B* instead of AbstractClonable *.</p>\n", "OwnerUserId": "4376199", "PostTypeId": "2", "Id": "30252280", "Score": "0", "CreationDate": "2015-05-15T05:41:41.350", "LastActivityDate": "2015-05-15T05:41:41.350"}, "30252370": {"ParentId": "30252032", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Even if <code>B</code> is indeed derived from <code>Clonable&lt;B&gt;</code>, the problem here is that <code>Clonable&lt;B&gt;</code> construction is not valid, as it defines </p>\n<pre><code>B* clone() const override\n</code></pre>\n<p>which of course is not an override of <code>AbstractClonable::clone()</code>, since the compiler doesn't see <code>B</code> at this point as a child of <code>AbstractClonable</code>. So I believe the issue lays in the fact that the compiler cannot build the <code>Clonable&lt;B&gt;</code> base of <code>B</code>.</p>\n<p>A workaround (but not really the same as what you want) is to define</p>\n<pre><code>Clonable* clone() const override\n</code></pre>\n<p>in <code>Clonable</code>. As you mentioned in the comment, you can also define a free function </p>\n<pre><code>template&lt;typename T&gt; \nT* clone(const T* object) \n{ \n    return static_cast&lt;T*&gt;(object-&gt;clone()); \n}\n</code></pre>\n<p>Related: <a href=\"https://stackoverflow.com/q/17201268/3093378\">Derived curiously recurring templates and covariance</a></p>\n", "OwnerUserId": "3093378", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:01:45.340", "Id": "30252370", "Score": "3", "CreationDate": "2015-05-15T05:47:36.043", "LastActivityDate": "2015-05-15T06:46:03.997"}, "bq_ids": {"n4140": {"so_30252032_30252692_0": {"section_id": 7009, "quality": 1.0, "length": 15}}, "n3337": {"so_30252032_30252692_0": {"section_id": 6755, "quality": 0.8, "length": 12}}, "n4659": {"so_30252032_30252692_0": {"section_id": 8506, "quality": 1.0, "length": 15}}}, "30252692": {"ParentId": "30252032", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, <code>B</code> is derived from <code>AbstractClonable</code>, but the compiler doesn't know that during the instantiation of <code>Clonable&lt;B&gt;</code> because <code>B</code> is still incomplete at that point.</p>\n<p>C++14 \u00a710.3/8:</p>\n<blockquote>\n<p id=\"so_30252032_30252692_0\">If the class type in the covariant return type of <code>D::f</code> differs from that of <code>B::f</code>, the class type in the return type of <code>D::f</code> <strong>shall be complete at the point of declaration of <code>D::f</code> or shall be the class type <code>D</code></strong>.</p>\n</blockquote>\n<p>A class has special permission to use itself in a covariant return type. Other classes, including CRTP bases, need to wait until the class is complete before declaring a covariant function.</p>\n<p>You can solve the problem using the non-virtual interface idiom (NVI):</p>\n<pre><code>class AbstractClonable {\nprotected:\n    virtual AbstractClonable* do_clone() const = 0;\npublic:\n    AbstractClonable *clone() const {\n        return do_clone();\n    }\n};\n\ntemplate&lt;typename T&gt;\nclass Clonable : public virtual AbstractClonable {\n    Clonable* do_clone() const override { // Avoid using T in this declaration.\n        return new T{*dynamic_cast&lt;const T*&gt;(this)};\n    }\npublic:\n    T *clone() const { // But here, it's OK.\n        return static_cast&lt; T * &gt;( do_clone() );\n    }\n};\n</code></pre>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2015-05-15T06:32:10.827", "Id": "30252692", "Score": "3", "CreationDate": "2015-05-15T06:13:02.310", "LastActivityDate": "2015-05-15T06:32:10.827"}});