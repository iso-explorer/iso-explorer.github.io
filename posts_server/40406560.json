post_cb({"40406880": {"ParentId": "40406560", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The difference is the (lack of) evaluation of context. <code>sizeof</code> is unevaluated.</p>\n<p>As per N3337 (\u2248C++11)</p>\n<blockquote>\n<p id=\"so_40406560_40406880_0\">\u00a75.1 2 [expr.prim.lambda] / 11</p>\n<p id=\"so_40406560_40406880_1\">If a <em>lambda-expression</em> has an associated <em>capture-default</em> and its\n  <em>compound-statement</em> odr-uses <code>this</code> or a variable with automatic storage duration and the odr-used entity is not explicitly captured,\n  then the odr-used entity is said to be <em>implicitly captured</em>;</p>\n</blockquote>\n<p>and </p>\n<blockquote>\n<p id=\"so_40406560_40406880_2\">\u00a75.1.2 [expr.prim.lambda] / 12 </p>\n<p id=\"so_40406560_40406880_3\">If a <em>lambda-expression</em> odr-uses <code>this</code> or a variable with automatic\n  storage duration from its reaching scope, that entity shall be\n  captured by the <code>lambda-expression</code>. If a <em>lambda-expression</em> captures\n  an entity and that entity is not defined or captured in the\n  immediately enclosing lambda expression or function, the program is\n  ill-formed.</p>\n</blockquote>\n<p>ODR use means use in potentially evaluated context:</p>\n<blockquote>\n<p id=\"so_40406560_40406880_4\">\u00a73.2 [basic.def.odr] / 2</p>\n<p id=\"so_40406560_40406880_5\">An expression is <em>potentially evaluated</em> unless it is an unevaluated\n  operand or a subexpression thereof. A variable whose name appears as a\n  potentially-evaluated expression is <em>odr-used</em> unless it is an object\n  that satisfies the requirements for appearing in a constant expression\n  and the lvalue-to-rvalue conversion is immediately applied</p>\n</blockquote>\n<p>Since <code>sizeof</code> isn't, and <code>s</code> is in <em>reaching scope</em> of the lambda expression, it is okay. Returning <code>s</code> means evaluating it, though, and that's why it's ill-formed.</p>\n", "OwnerUserId": "2456565", "LastEditorUserId": "2456565", "LastEditDate": "2016-11-03T16:59:35.830", "Id": "40406880", "Score": "6", "CreationDate": "2016-11-03T16:38:04.117", "LastActivityDate": "2016-11-03T16:59:35.830"}, "40425486": {"ParentId": "40406560", "CommentCount": "0", "Body": "<p>Lambdas can \"see\" a <em>lot</em> of things in their surrounding scope without needing to capture them:</p>\n<p>-- Global variables:</p>\n<pre><code>int x = 42;\nint main() { []{ std::cout &lt;&lt; x; }(); }\n</code></pre>\n<p>-- Static local variables:</p>\n<pre><code>int main() {\n    static int x = 42;\n    constexpr int y = 1337;\n    []{ std::cout &lt;&lt; x &lt;&lt; y; }();\n}\n</code></pre>\n<p>-- Functions:</p>\n<pre><code>int x() { return 42; }\nint main() { []{ std::cout &lt;&lt; x(); }(); }\n</code></pre>\n<p>-- Types:</p>\n<pre><code>using x = std::integral_constant&lt;int, 42&gt;;\nint main() { []{ std::cout &lt;&lt; x::value; }(); }\n</code></pre>\n<p>-- Local variables used in unevaluated contexts:</p>\n<pre><code>int main() {\n    int x = 42;\n    []{ std::cout &lt;&lt; sizeof(x); }();\n}\n</code></pre>\n<p>This just naturally falls out of the language rules. You can do the same thing in C++98 with a hand-written callable object:</p>\n<pre><code>int main() {\n    int x = 42;\n    struct functor {\n        int operator()() const { return sizeof(x); }\n    };\n    std::cout &lt;&lt; functor{}();\n}\n</code></pre>\n<p>It's unsurprising, as <code>sizeof</code> does not evaluate its expression:</p>\n<pre><code>int main() {\n    int x; // uninitialized\n    using y = std::integral_constant&lt;size_t, sizeof(x)&gt;; // x used in a constant expression\n\n    using z = std::integral_constant&lt;size_t, 4&gt;;\n    static_assert(std::is_same&lt;y, z&gt;::value, \"\");\n\n    std::cout &lt;&lt; y::value;\n}\n</code></pre>\n", "OwnerUserId": "1639256", "PostTypeId": "2", "Id": "40425486", "Score": "4", "CreationDate": "2016-11-04T14:43:37.857", "LastActivityDate": "2016-11-04T14:43:37.857"}, "bq_ids": {"n4140": {"so_40406560_40406880_3": {"section_id": 5972, "quality": 1.0, "length": 24}, "so_40406560_40406880_1": {"section_id": 5971, "quality": 0.55, "length": 11}}, "n3337": {"so_40406560_40406880_1": {"section_id": 5739, "quality": 0.95, "length": 19}, "so_40406560_40406880_3": {"section_id": 5740, "quality": 1.0, "length": 24}, "so_40406560_40406880_5": {"section_id": 6785, "quality": 0.9166666666666666, "length": 22}}, "n4659": {"so_40406560_40406880_1": {"section_id": 7470, "quality": 0.55, "length": 11}, "so_40406560_40406880_3": {"section_id": 7471, "quality": 1.0, "length": 24}}}, "40406560": {"CommentCount": "2", "AcceptedAnswerId": "40425486", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-11-03T16:21:13.723", "LastActivityDate": "2016-11-04T14:43:37.857", "LastEditDate": "2017-05-23T12:24:14.883", "ViewCount": "175", "FavoriteCount": "1", "Title": "Can sizeof be applied inside a lambda on a variable that is not captured or is this a compiler bug?", "Id": "40406560", "Score": "7", "Body": "<p>This is a follow up of the discussion <a href=\"https://stackoverflow.com/q/40374191/3876684\">found here</a>.</p>\n<p>The following code compiles both under gcc and clang (<a href=\"http://coliru.stacked-crooked.com/a/2046196d29616a91\" rel=\"nofollow noreferrer\">live demo</a>). This is surprising for the case in line <code>//1</code> since the lambda does not capture anything. For the case of <code>MCR2</code>, where the lambda returns the pointer itself, we get the expected compile time error (line <code>// Will not compile</code>). How is application of operator <code>sizeof</code> different from returning the pointer?</p>\n<pre><code>#include &lt;iostream&gt;\n\n#define MCR1(s) \\\n  ([]() { return sizeof(s); })()\n\n#define MCR2(s) \\\n  ([]() { return s; })()\n\nint main() {\n  auto *s= \"hello world\";\n\n  auto x1 = MCR1( s ); //1\n  auto y1 = MCR1( \"hello world\" );\n//  auto x2= MCR2( s ); // Will not compile\n  auto y2= MCR2( \"hello world\" );\n\n  std::cout &lt;&lt; x1  &lt;&lt; \"  \" &lt;&lt; y1  &lt;&lt; '\\n';\n  std::cout // &lt;&lt; x2 &lt;&lt; \"  \" \n            &lt;&lt; y2 &lt;&lt; '\\n';\n}\n</code></pre>\n<hr>\n<p><strong>EDIT:</strong> Following up on the discussion here is another example. Surprisingly, the line marked <code>//2</code> now compiles under gcc7 (development version) (<a href=\"http://melpon.org/wandbox/permlink/lNHiunRlgH0qVOnu\" rel=\"nofollow noreferrer\">live demo</a>). The difference here is that expressions are marked <code>constexpr</code>, now.</p>\n<pre><code>#include &lt;iostream&gt;\n\n#define MCR1(s) \\\n  ([]() { return sizeof(s); })()\n\n#define MCR2(s) \\\n  ([]() { return s; })()\n\nint main() {\n  auto constexpr *s= \"hello world\";\n\n  auto constexpr x1= MCR1( s );\n  auto constexpr y1= MCR1( \"hello world\" );\n  auto constexpr x2= MCR2( s );             //2\n  auto constexpr y2= MCR2( \"hello world\" );\n\n  std::cout &lt;&lt; x1 &lt;&lt; \"  \" &lt;&lt; y1 &lt;&lt; '\\n';\n  std::cout &lt;&lt; x2 &lt;&lt; \"  \" &lt;&lt; y2 &lt;&lt; '\\n';\n}\n</code></pre>\n</hr>", "Tags": "<c++><c++11>", "OwnerUserId": "3876684", "AnswerCount": "2"}});