post_cb({"5474523": {"Id": "5474523", "PostTypeId": "2", "Body": "<p>(notice: I'm referring to the current C++ standard)</p>\n<p>I'm not really sure about this, but, if my interpretation of the standard is correct, the code should be fine and not UB.</p>\n<p>The first initialization of that variable is the <em>zero-initialization</em> of objects with static storage duration that happens <em>before any other\ninitialization takes place</em> (\u00a73.6.2 \u00b61).</p>\n<p>So, first of all <code>i</code> is set to zero.</p>\n<p>Then, <em>dynamic initialization</em> (i.e. non-zero and non-constant initialization) takes place, so it uses the current value of <code>i</code> (0) to actually initialize it again. At the end it should evaluate to 1.</p>\n<p>This seems confirmed by \u00a78.5 \u00b66, that explicitly says:</p>\n<blockquote>\n<p id=\"so_5474349_5474523_0\">The memory occupied by any object of static storage duration shall be zero-initialized at program startup before any other initialization takes place. <strong><em>[Note: in some cases, additional initialization is done later. ]</em></strong></p>\n</blockquote>\n<p>(If you find some flaw in the analysis please just tell me in the comments and I'll be glad to correct/delete the answer, it's slippery floor and I'm conscious of it :) )</p>\n", "LastEditorUserId": "214671", "LastActivityDate": "2011-03-29T14:58:32.303", "Score": "5", "CreationDate": "2011-03-29T14:52:32.733", "ParentId": "5474349", "CommentCount": "1", "OwnerUserId": "214671", "LastEditDate": "2011-03-29T14:58:32.303"}, "5474430": {"Id": "5474430", "PostTypeId": "2", "Body": "<p>You cannot assign a value to variable using another variable outside any function. The statement <code>i + 1;</code> is evaluated during runtime, while <code>int i = i + 1;</code> is outside any function so it needs to be evaluated in compile time. </p>\n", "LastActivityDate": "2011-03-29T14:45:47.740", "CommentCount": "0", "CreationDate": "2011-03-29T14:45:47.740", "ParentId": "5474349", "Score": "0", "OwnerUserId": "464988"}, "5474486": {"Id": "5474486", "PostTypeId": "2", "Body": "<p>Your code is not legal C.</p>\n<p>If your compiler compiles it without a diagnostic,<br>\n<strong>your compiler is not a C compiler</strong></br></p>\n<p>You must use constants to initialize a variable.</p>\n<p>In your code, the initializer expression ( <code>i + 1</code> ) is not a constant.</p>\n<p>This violates 6.7.8/4:</p>\n<blockquote>\n<p id=\"so_5474349_5474486_0\">All the expressions in an initializer [...] shall be constant expressions or string literals.</p>\n</blockquote>\n", "LastActivityDate": "2011-03-29T14:49:31.710", "CommentCount": "0", "CreationDate": "2011-03-29T14:49:31.710", "ParentId": "5474349", "Score": "1", "OwnerUserId": "25324"}, "5474364": {"Id": "5474364", "PostTypeId": "2", "Body": "<p>The code is illegal in C.</p>\n<p><code>initializer element is not constant</code></p>\n<p><strong>C99 -- 6.7.8 Initialization</strong></p>\n<p><em>All the expressions in an initializer for an object that has static storage duration shall be\nconstant expressions or string literals.</em></p>\n<p>The is valid in C++.</p>\n<p>C++ Standard States in <strong>3.6.2 Initialization of non-local objects</strong>:</p>\n<p><em>Objects with static storage duration (3.7.1) shall be zero-initialized (8.5) before any other initialization takes place.</em></p>\n", "LastEditorUserId": "418729", "LastActivityDate": "2011-03-29T15:03:40.370", "Score": "1", "CreationDate": "2011-03-29T14:42:07.793", "ParentId": "5474349", "CommentCount": "4", "OwnerUserId": "418729", "LastEditDate": "2011-03-29T15:03:40.370"}, "bq_ids": {"n4140": {"so_5474349_5474523_0": {"length": 17, "quality": 0.8095238095238095, "section_id": 3289}, "so_5474349_5475143_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 7049}, "so_5474349_5474446_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 7049}, "so_5474349_5475143_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 7049}, "so_5474349_5474446_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 3289}}, "n3337": {"so_5474349_5474523_0": {"length": 17, "quality": 0.8095238095238095, "section_id": 3159}, "so_5474349_5475143_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 6794}, "so_5474349_5474446_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 3159}, "so_5474349_5475143_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 6794}, "so_5474349_5474446_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 6794}}, "n4659": {"so_5474349_5474523_0": {"length": 17, "quality": 0.8095238095238095, "section_id": 4051}, "so_5474349_5475143_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 8546}, "so_5474349_5474446_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 4051}, "so_5474349_5475143_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 8546}, "so_5474349_5474446_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 8546}}}, "5474349": {"ViewCount": "2372", "Body": "<blockquote>\n<p id=\"so_5474349_5474349_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/3309042/what-does-main-return\">What does main return?</a> </br></p>\n</blockquote>\n<p>For example, the following code compiles without any warning:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint i = i + 1;\n\nint main(int argc, char *argv[])\n{\n\n    fprintf (stderr, \"%d\\n\", i);\n\n    return 0;\n}\n</code></pre>\n<p>I think this is illegal in syntax, because <code>i</code> is used before it's declared, is it right?</p>\n<p>And in my opinion, the appearance of <code>int i = i + 1;</code> is surely a bug, why doesn't the compiler warn about it? I use gcc 4.5.1.</p>\n", "AcceptedAnswerId": "5474523", "Title": "Initialization of Objects with Static Storage Duration in C vs C++", "CreationDate": "2011-03-29T14:41:14.327", "Id": "5474349", "CommentCount": "14", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:43:30.310", "LastEditorUserId": "-1", "LastActivityDate": "2011-05-10T15:28:55.920", "ClosedDate": "2011-03-29T15:41:52.970", "Score": "10", "OwnerUserId": "682252", "Tags": "<c++><c><initialization><definition>", "AnswerCount": "9"}, "5474463": {"Id": "5474463", "PostTypeId": "2", "Body": "<p>Since a compiler takes statements and emits low-level code for the CPU to use, you have to split apart what is really happening here.  It would go something like this:</p>\n<ol>\n<li>Create a memory slot for \"i\".</li>\n<li>Initialize the memory to zero (normal default behavior).</li>\n<li>Read the value of \"i\" (which is zero).</li>\n<li>Add 1.</li>\n<li>Store it in \"i\".</li>\n</ol>\n", "LastActivityDate": "2011-03-29T14:47:57.903", "CommentCount": "0", "CreationDate": "2011-03-29T14:47:57.903", "ParentId": "5474349", "Score": "0", "OwnerUserId": "50358"}, "5475143": {"Id": "5475143", "PostTypeId": "2", "Body": "<p>To address your question about \"<code>i</code> is used before it's declared, right?\"</p>\n<p>Not in C++.  <code>[basic.scope.pdecl]</code> says</p>\n<blockquote>\n<p id=\"so_5474349_5475143_0\">The <em>point of declaration</em> for a name is immediately after its complete declarator (Clause 8) and before its <em>initializer</em> (if any), except as noted below. [ <em>Example:</em></p>\n<pre><code>int  x  =  12;\n{  int  x  =  x;  }\n</code></pre>\n<p id=\"so_5474349_5475143_1\">Here the second <code>x</code> is initialized with its own (indeterminate) value.  \u2014 <em>end example</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2011-03-29T15:37:51.647", "CommentCount": "0", "CreationDate": "2011-03-29T15:37:51.647", "ParentId": "5474349", "Score": "0", "OwnerUserId": "103167"}, "5474458": {"Id": "5474458", "PostTypeId": "2", "Body": "<p>Whether its really syntactically illegal I'm not sure (it would definitly be valid inside the method). However, as you suggest, the is a semantic problem and the compiler should issue a warning as <code>i</code> was used without initialization. IMO the C/C++ compiler does not generally warn of such thing however (Java for instance would give an error), though you might turn on such warning by adding <code>-Wall</code> parameter to gcc.</p>\n", "LastActivityDate": "2011-03-29T14:47:35.490", "CommentCount": "1", "CreationDate": "2011-03-29T14:47:35.490", "ParentId": "5474349", "Score": "0", "OwnerUserId": "369310"}, "5474689": {"Id": "5474689", "PostTypeId": "2", "Body": "<p>I won't repeat the same things: it is undefined behavior, you should not do it... but provide a use case (which is a common idiom) that shows why it is sometimes interesting to allow the use of the variable there (in C):</p>\n<pre><code>int * p = malloc( 10 * sizeof *p );\n</code></pre>\n<p>If usage of <code>p</code> in the right hand side was disallowed that would be a compiler error. You can circumvent it by explicitly stating the type in the rhs:</p>\n<pre><code>int * p = malloc( 10 * sizeof(int) );\n</code></pre>\n<p>But that is prone to subtle errors if at a later time the type is changed, as the compiler will not detect this case:</p>\n<pre><code>double * p = malloc( 10 * sizeof(int) ); // will compile and probably cause havoc later\n</code></pre>\n<p>Now, in C++ I can only assume that it is there for backwards compatibility. Note also, that some compilers will be able to detect that invalid use and trigger a warning from the more general group of <em>uninitialized use of variable</em>:</p>\n<pre><code>int i = i + 1;\n//      ^  uninitialized read\n</code></pre>\n<p>There are other situations, however, in C++ where you can pass a reference/pointer to uninitialized objects and it is perfectly fine. Consider:</p>\n<pre><code>template &lt;typename T&gt;\nstruct NullObjectPattern { // intentionally out of order:\n   T* ptr;\n   T null;\n   NullObjectPattern() : ptr( &amp;null ), null() {}\n\n   T&amp; operator*() { return *ptr; }\n   T* operator-&gt;() { return ptr; }\n};\n</code></pre>\n<p>While <code>null</code> has not yet been initialized, using it in an expression that only takes it's address (but does not dereference it) is well defined: the memory location exists, it has been allocated and is present. The object itself has not been initialized, and as such dereferencing it will cause UB, but the fact that an uninitialized object is used in an expression does not mean that the code is actually wrong.</p>\n", "LastEditorUserId": "36565", "LastActivityDate": "2011-03-29T15:17:06.503", "Score": "0", "CreationDate": "2011-03-29T15:03:46.717", "ParentId": "5474349", "CommentCount": "1", "OwnerUserId": "36565", "LastEditDate": "2011-03-29T15:17:06.503"}, "5474446": {"Id": "5474446", "PostTypeId": "2", "Body": "<p>In C++ it is syntactically correct. In C you can initialize a global variable only with a constant. So your code would not compile in C.</p>\n<p>In C this is legal BTW</p>\n<pre><code>int main()\n{\n   int i = i+1;\n}\n</code></pre>\n<p>3.3.1/1  Point of declaration</p>\n<blockquote>\n<p id=\"so_5474349_5474446_0\">The point of declaration for a name is <strong>immediately after its complete declarator</strong> and before its initializer (if any).  </p>\n</blockquote>\n<p>The behaviour is well defined as per <code>\u00a73.6.2/1</code> which says: </p>\n<blockquote>\n<p id=\"so_5474349_5474446_1\">\"Objects with static storage duration (3.7.1) shall be zero-initialized (8.5) before any other initialization takes place.\"</p>\n</blockquote>\n", "LastEditorUserId": "165520", "LastActivityDate": "2011-05-10T15:28:55.920", "Score": "5", "CreationDate": "2011-03-29T14:46:36.690", "ParentId": "5474349", "CommentCount": "7", "OwnerUserId": "165520", "LastEditDate": "2011-05-10T15:28:55.920"}});