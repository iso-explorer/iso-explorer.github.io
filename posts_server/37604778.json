post_cb({"37604880": {"Id": "37604880", "PostTypeId": "2", "Body": "<p>That's undefined behavior. </p>\n<p>C99 \u00a77.19.6.1/9</p>\n<blockquote>\n<p id=\"so_37604778_37604880_0\">If any argument is not the correct type for the corresponding\n  conversion specification, the behavior is undefined.</p>\n</blockquote>\n<p>That means you are guaranteed to get unportable results/behavior.</p>\n", "LastActivityDate": "2016-06-03T02:11:17.523", "CommentCount": "0", "CreationDate": "2016-06-03T02:11:17.523", "ParentId": "37604778", "Score": "2", "OwnerUserId": "6292850"}, "37604845": {"Id": "37604845", "PostTypeId": "2", "Body": "<p>You need <code>atof</code> to explicit convert from <code>char *</code> pointer to <code>double</code></p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n\nint main( void )\n{\n    const char* tmp = \"882.30\";\n    char buff[32];\n    sprintf(buff, \"%e\", atof( tmp )); \n    printf(\"TEST: %s\\n\", buff);\n    return 0;\n}\n</code></pre>\n<p>BTW, you can't override an existing function because that is violation to the\nOne Definition Rule (ODR.)</p>\n", "LastEditorUserId": "3758879", "LastActivityDate": "2016-06-03T02:08:40.903", "Score": "0", "CreationDate": "2016-06-03T02:06:46.113", "ParentId": "37604778", "CommentCount": "3", "OwnerUserId": "3758879", "LastEditDate": "2016-06-03T02:08:40.903"}, "bq_ids": {"n4140": {"so_37604778_37604880_0": {"length": 5, "quality": 0.625, "section_id": 7043}}, "n3337": {"so_37604778_37604880_0": {"length": 5, "quality": 0.625, "section_id": 6788}}, "n4659": {"so_37604778_37604880_0": {"length": 5, "quality": 0.625, "section_id": 7612}}}, "37604778": {"ViewCount": "46", "Body": "<p>My friend was assigned to work on an existing C++ project of his company. In the source code he saw something like this:</p>\n<pre><code>char* tmp = \"882.30\";\nchar buff[32];\nsprintf(buff, \"%e\", tmp);\nprintf(\"TEST: %s\\n\", buff);\n</code></pre>\n<p>When compiling, a warning was raised: <code>warning: format '%e' expects type 'double', but argument 3 has type 'char*'</code> but the output was amazing: <code>8.823000e+002</code>. He was curious. How could it be?</p>\n<p>To clarify that he created a new small project and he used the same above code snippet and same compiler but it showed very different result: <code>2.647480e-314</code>.</p>\n<p>The environment: Centos 5.x, gcc 4.4.7.</p>\n<p>What could be the reason here? The existing project has overloading function of sprintf or compilers?</p>\n", "AcceptedAnswerId": "37604880", "Title": "Can we overload sprintf in g++ implementation?", "CreationDate": "2016-06-03T01:58:43.927", "Id": "37604778", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-06-03T02:11:17.523", "Score": "-1", "OwnerUserId": "2589553", "Tags": "<c++><g++><printf>", "AnswerCount": "2"}});