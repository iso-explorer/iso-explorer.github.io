post_cb({"bq_ids": {"n4140": {"so_2892087_2892133_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 233}}, "n3337": {"so_2892087_2892133_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 226}}, "n4659": {"so_2892087_2892133_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 243}}}, "2892087": {"ViewCount": "7512", "Body": "<p>In C++0x SFINAE rules have been simplified such that any invalid expression or type that occurs in the \"immediate context\" of deduction does not result in a compiler error but rather in deduction failure (SFINAE).  </p>\n<p>My question is this:<br>\nIf I take the address of an overloaded function and it can not be resolved, is that failure in the immediate-context of deduction?<br>\n(i.e is it a hard error or SFINAE if it can not be resolved)?</br></br></p>\n<p>Here is some sample code:</p>\n<pre><code>struct X\n{\n  // template&lt;class T&gt; T* foo(T,T); // lets not over-complicate things for now\n  void foo(char);\n  void foo(int);\n};\n\n\ntemplate&lt;class U&gt; struct S\n{\n  template&lt;int&gt; struct size_map \n  { typedef int type; };\n\n\n// here is where we take the address of a possibly overloaded function\n  template&lt;class T&gt; void f(T, \n      typename size_map&lt;sizeof(&amp;U::foo)&gt;::type* = 0); \n\n\n  void f(...);\n};\n\nint main()\n{\n  S&lt;X&gt; s;\n\n// should this cause a compiler error because 'auto T = &amp;X::foo' is invalid?\n  s.f(3);  \n\n}\n</code></pre>\n<p>Gcc 4.5 states that this is a compiler error, and clang spits out an assertion violation.</p>\n<p>Here are some more related questions of interest:  </p>\n<p>Does the FCD-C++0x clearly specify what should happen here?<br>\nAre the compilers wrong in rejecting this code?<br>\nDoes the \"immediate-context\" of deduction need to be defined a little better?</br></br></p>\n<p>Thanks!</p>\n", "AcceptedAnswerId": "2892133", "Title": "If the address of a function can not be resolved during deduction, is it SFINAE or a compiler error?", "CreationDate": "2010-05-23T14:24:08.773", "Id": "2892087", "CommentCount": "2", "FavoriteCount": "9", "PostTypeId": "1", "LastEditDate": "2011-10-02T10:29:45.947", "LastEditorUserId": "34509", "LastActivityDate": "2011-10-02T10:29:45.947", "Score": "20", "OwnerUserId": "51103", "Tags": "<c++><templates><c++11><sfinae><overload-resolution>", "AnswerCount": "1"}, "2892133": {"Id": "2892133", "PostTypeId": "2", "Body": "<pre><code>template&lt;class T&gt; void f(T, \n    typename size_map&lt;sizeof(&amp;U::foo)&gt;::type* = 0); \n</code></pre>\n<p>This doesn't work, because <code>U</code> does not participate in deduction. While <code>U</code> is a dependent type, during deduction for <code>f</code> it's treated like a fixed type spelled with a nondependent name. You need to add it to the parameter list of <code>f</code></p>\n<pre><code>/* fortunately, default arguments are allowed for \n * function templates by C++0x */\ntemplate&lt;class T, class U1 = U&gt; void f(T, \n    typename size_map&lt;sizeof(&amp;U1::foo)&gt;::type* = 0); \n</code></pre>\n<p>So in your case because <code>U::foo</code> does not depend on parameters of <code>f</code> itself, you receive an error while implicitly instantiating <code>S&lt;X&gt;</code> (try to comment out the call, and it should still fail). The FCD says at <code>14.7.1/1</code></p>\n<blockquote>\n<p id=\"so_2892087_2892133_0\">The implicit instantiation of a class template specialization causes the implicit instantiation of the declarations, but not of the de\ufb01nitions or default arguments, of the class member functions, member classes, static data members and member templates;</p>\n</blockquote>\n<p>That is, if you implicitly instantiate <code>S&lt;X&gt;</code> the following function template declaration will be instantiated</p>\n<pre><code>template&lt;class T&gt; void S&lt;X&gt;::f(T, \n  typename size_map&lt;sizeof(&amp;X::foo)&gt;::type* = 0); \n</code></pre>\n<p>Analysis on that template declaration will then find that it can't resolve the reference to <code>X::foo</code> and error out. If you add <code>U1</code>, the template declaration will not yet try to resolve the reference to <code>U1::foo</code> (since <code>U1</code> is a parameter of <code>f</code>), and will thus remain valid and SFINAE when <code>f</code> is tried to be called. </p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2010-05-23T14:58:27.563", "Score": "22", "CreationDate": "2010-05-23T14:38:08.283", "ParentId": "2892087", "CommentCount": "5", "OwnerUserId": "34509", "LastEditDate": "2010-05-23T14:58:27.563"}});