post_cb({"bq_ids": {"n4140": {"so_13444626_13444894_0": {"length": 15, "quality": 1.0, "section_id": 7070}}, "n3337": {"so_13444626_13444894_0": {"length": 15, "quality": 1.0, "section_id": 6814}}, "n4659": {"so_13444626_13444894_0": {"length": 15, "quality": 1.0, "section_id": 8568}}}, "13444786": {"Id": "13444786", "PostTypeId": "2", "Body": "<p>In a <code>typedef</code> declaration, the final name is the one being declared, and that is the point of declaration. So the first <code>X</code> comes before the declaration of <code>D2::X</code> and therefore resolves to <code>B::X</code>.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2012-11-18T21:40:59.923", "Score": "2", "CreationDate": "2012-11-18T21:27:13.790", "ParentId": "13444626", "CommentCount": "0", "OwnerUserId": "204847", "LastEditDate": "2012-11-18T21:40:59.923"}, "13444626": {"ViewCount": "166", "Body": "<p>Is the following code valid?</p>\n<pre><code>struct B{ using X=int; };\nstruct D1:B{ using X=X; };   // (1)\nstruct D2:B{ typedef X X; }; // (2)\n</code></pre>\n<p>I would expect the point of declaration of D2::X to be between the two Xs in (2), but it seems both gcc 4.8 and clang 3.2 accept it.\nIs this standard behavior ? References to the working draft/standard will be appreciated.</p>\n", "AcceptedAnswerId": "13444894", "Title": "Point of declaration of typedef/alias declaration", "CreationDate": "2012-11-18T21:12:06.867", "Id": "13444626", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2012-11-18T21:53:11.700", "Score": "2", "OwnerUserId": "1810894", "Tags": "<c++><c++11><typedef><language-lawyer>", "AnswerCount": "2"}, "13444894": {"Id": "13444894", "PostTypeId": "2", "Body": "<p>There was a debate on whether <code>using X = X</code> should pick up the being defined <code>X</code> or the <code>X</code> that potentially already was in scope. To avoid \"unknown types\" and to make it similar to <code>typedef</code>, it was ruled that the being-defined <code>X</code> is not visible in its to-be-assigned type expression (<strong>so rather than being similar to <code>int x = x</code>, it is similar to <code>typedef x x;</code></strong>).</p>\n<p>Recall that <code>typedef</code> is just a normal declaration with the <code>typedef</code> keyword prepended. The first mentioning of <code>X</code> does not declare anything, it just says what type will be aliased. That's the major difference with <code>using X = X</code>  which <em>could</em> declare <code>X</code> earlier, if the committee decided that way.</p>\n<p>Note however your code is has <em>effectively undefined behavior</em>, because it violates a rule that has no required diagnostic. 3.3.7p1b2</p>\n<blockquote>\n<p id=\"so_13444626_13444894_0\">A name N used in a class S shall refer to the same declaration in its context and when re-evaluated in the completed scope of S. No diagnostic is required for a violation of this rule.</p>\n</blockquote>\n", "LastEditorUserId": "34509", "LastActivityDate": "2012-11-18T21:53:11.700", "Score": "4", "CreationDate": "2012-11-18T21:39:14.713", "ParentId": "13444626", "CommentCount": "0", "OwnerUserId": "34509", "LastEditDate": "2012-11-18T21:53:11.700"}});