post_cb({"35962759": {"ParentId": "35962647", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2016-03-12T20:13:17.493", "Score": "0", "LastEditorUserId": "2069064", "LastEditDate": "2016-03-12T20:23:42.523", "Id": "35962759", "OwnerUserId": "2069064", "Body": "<p>The rules for evaluating</p>\n<pre><code>A a1 = B();   // (1) copy-initialization\nA a2 = {B()}; // (2) copy-initialization\nA a3{B()};    // (3) direct-initialization\n</code></pre>\n<p>come from <a href=\"http://eel.is/c++draft/dcl.init#17\" rel=\"nofollow\">[dcl.init]/17</a>:</p>\n<blockquote>\n<p id=\"so_35962647_35962759_0\">\u2014 If the initializer is a (non-parenthesized) <em>braced-init-list</em>, the object or reference is list-initialized (8.5.4).<br>\n  \u2014  [...]<br>\n  \u2014 If the destination type is a (possibly cv-qualified) class type:  </br></br></p>\n<ul>\n<li>If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified\n  version of the source type is the same class as, or a derived class of, the class of the destination,\n  constructors are considered. [...]</li>\n<li>Otherwise (i.e., for the remaining copy-initialization cases), user-defined conversion sequences\n  that can convert from the source type to the destination type or (when a conversion function\n  is used) to a derived class thereof are enumerated as described in 13.3.1.4, and the best one is\n  chosen through overload resolution (13.3). [...] The result of the call (which is the temporary for the constructor case) is then used to direct-initialize, according to the rules above,\n  the object that is the destination of the copy-initialization. In certain cases, an implementation\n  is permitted to eliminate the copying inherent in this direct-initialization by constructing the\n  intermediate result directly into the object being initialized; see 12.2, 12.8.</li>\n</ul>\n</blockquote>\n<p>For both <code>a2</code> and <code>a3</code>, the initializer is a <em>braced-init-list</em>, so we just do list-initialization. This ends up calling the <code>B const&amp;</code> constructor.</p>\n<p>For <code>a1</code>, the first sub-bullet doesn't apply - since the source type (<code>B</code>) is not the same or derived class of the destination type (<code>A</code>). So we go into the second sub-bullet point which involves considering conversion functions. There is one (<code>A(B const&amp;)</code>) so we effectively rewrite the expression</p>\n<pre><code>A a1_new{A{B{}}};\n</code></pre>\n<p>Now typically, this extra copy will be elided. But you're explicitly prohibiting it, so the code cannot compile. </p>\n<hr/>\n<p>As to <strong>why</strong> the differentiation? I don't know. It seems like copy-initialization should simply be syntactic sugar for direct-initialization. In most cases, after all, it is... </p>\n", "LastActivityDate": "2016-03-12T20:23:42.523"}, "bq_ids": {"n4140": {"so_35962647_35962759_0": {"section_id": 3296, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_35962647_35962759_0": {"section_id": 3166, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_35962647_35962759_0": {"section_id": 4058, "quality": 0.9230769230769231, "length": 12}}}, "35962647": {"CommentCount": "5", "ViewCount": "268", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-03-12T20:01:34.300", "LastActivityDate": "2016-03-12T20:23:42.523", "Title": "Confusion in copy initialization and direct initialization", "LastEditDate": "2017-05-23T12:31:26.773", "Id": "35962647", "Score": "4", "Body": "<p>Consider simple statement (Taken from <a href=\"https://stackoverflow.com/questions/1051379/is-there-a-difference-in-c-between-copy-initialization-and-direct-initializati\">Is there a difference in C++ between copy initialization and direct initialization?</a>):</p>\n<pre><code>A c2 = A();\n</code></pre>\n<blockquote>\n<p id=\"so_35962647_35962647_0\">This statement value-initializes a temporary and then copies that\n  value into c2 (Read 5.2.3/2 and 8.5/14). <strong>This of course will require a\n  non-explicit copy constructor (Read 8.5/14 and 12.3.1/3 and\n  13.3.1.3/1)</strong></p>\n</blockquote>\n<p>[Mind the bold sentence in above para] -&gt; My question is why?</p>\n<p>Now consider this code :</p>\n<pre><code>class B {};\nstruct A \n{\n  A(B const&amp;) {}\n  A(A const&amp;) = delete;\n  //A(A const&amp;); //delete above statement and uncomment this statement, \n  //and everything works, even though there in no body of copy constructor Oo\n};\n\nA a2 = B();    //error since there is no copy constructor oO\n</code></pre>\n<p>Why copy-initialization requires presence of copy constructor even though it's not needed sometime as presented in above code</p>\n<p><strong>Please please one more thing</strong> : </p>\n<blockquote>\n<p id=\"so_35962647_35962647_1\">While direct initialization has all constructors available to call,\n  and in addition can do any <strong>implicit conversion</strong> it needs to match up\n  argument types, copy initialization can just set up one <strong>implicit\n  conversion sequence</strong>.</p>\n</blockquote>\n<p>[<strong>Mind the bolding in the following para</strong>]</p>\n<p>Doesn't that means direct initialization have access to all constructors and can perform <strong>implicit conversion sequence</strong> , while copy initialization all can do is perform <strong>implicit conversion sequence</strong>? . What I mean to ask is , implicit conversion in direct initialization is different from implicit conversion sequence in copy initialization ?</p>\n", "Tags": "<c++><initialization><implicit-conversion>", "OwnerUserId": "4882052", "AnswerCount": "1"}});