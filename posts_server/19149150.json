post_cb({"19149751": {"ParentId": "19149150", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>As DyP mentions, lambda functors are guaranteed to have a public <code>operator ()</code>. Note that <code>operator ()</code> cannot be <code>static</code> or non-member.</p>\n<p>(A type can also be callable due to the existence of a conversion operator to function pointer type, and stateless lambdas do have such conversion operators, but they still must provide <code>operator ()</code>.</p>\n<p>You can get the signature of <code>operator ()</code> using <code>decltype( &amp; T::operator() )</code>, provided there is only one overload, which is guaranteed for lambdas. This results in a pointer to member function type. You can use a metafunction to strip the <code>T::</code> part off, or write metafunction queries against the PTMF directly.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n#include &lt;type_traits&gt;\n#include &lt;tuple&gt;\n\ntemplate&lt; typename t, std::size_t n, typename = void &gt;\nstruct function_argument_type;\n\ntemplate&lt; typename r, typename ... a, std::size_t n &gt;\nstruct function_argument_type&lt; r (*)( a ... ), n &gt;\n    { typedef typename std::tuple_element&lt; n, std::tuple&lt; a ... &gt; &gt;::type type; };\n\ntemplate&lt; typename r, typename c, typename ... a, std::size_t n &gt;\nstruct function_argument_type&lt; r (c::*)( a ... ), n &gt;\n    : function_argument_type&lt; r (*)( a ... ), n &gt; {};\n\ntemplate&lt; typename r, typename c, typename ... a, std::size_t n &gt;\nstruct function_argument_type&lt; r (c::*)( a ... ) const, n &gt;\n    : function_argument_type&lt; r (c::*)( a ... ), n &gt; {};\n\ntemplate&lt; typename ftor, std::size_t n &gt;\nstruct function_argument_type&lt; ftor, n,\n    typename std::conditional&lt; false, decltype( &amp; ftor::operator () ), void &gt;::type &gt;\n    : function_argument_type&lt; decltype( &amp; ftor::operator () ), n &gt; {};\n\n\nint main() {\n    auto x = []( int, long, bool ){};\n    std::cout &lt;&lt; typeid( function_argument_type&lt; decltype(x), 0 &gt;::type ).name() &lt;&lt; '\\n';\n    std::cout &lt;&lt; typeid( function_argument_type&lt; decltype(x), 1 &gt;::type ).name() &lt;&lt; '\\n';\n    std::cout &lt;&lt; typeid( function_argument_type&lt; decltype(x), 2 &gt;::type ).name() &lt;&lt; '\\n';\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/57cd7bb76267ffda\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/57cd7bb76267ffda</a></p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2013-10-03T02:31:21.853", "Id": "19149751", "Score": "0", "CreationDate": "2013-10-03T02:19:30.063", "LastActivityDate": "2013-10-03T02:31:21.853"}, "19149568": {"ParentId": "19149150", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Summing up and extending from the comments:</p>\n<p>Per [expr.prim.lambda]/3, the type of a <em>lambda-expression</em> is a class type, just like \"ordinary, named function object types\":</p>\n<blockquote>\n<p id=\"so_19149150_19149568_0\">The type of the <em>lambda-expression</em> (which is also the type of the closure object) is a unique, unnamed non-union class type \u2014 called the <em>closure type</em> [...]</p>\n</blockquote>\n<p>Further down, /5 specifies:</p>\n<blockquote>\n<p id=\"so_19149150_19149568_1\">The closure type for a <em>lambda-expression</em> has a public <code>inline</code> function call operator (13.5.4) whose parameters and return type are described by the <em>lambda-expression</em>\u2019s <em>parameter-declaration-clause</em> and <em>trailing-return-type</em> respectively. This function call operator is declared <code>const</code> (9.3.1) if and only if the <em>lambda-expression</em>\u2019s parameter-declaration-clause is not followed by mutable. It is neither virtual nor declared\n  <code>volatile</code>. [...]</p>\n</blockquote>\n<p>(it then continues by specifying attributes and exception-specifications)</p>\n<p>Which means that the lambda <code>[](int p){ return p/2.0; }</code> behaves in this regard exactly like</p>\n<pre><code>struct named_function_object\n{\n    double operator() (int p) const { return p/2.0; }\n};\n</code></pre>\n<p>Therefore, your first specialization</p>\n<pre><code>template&lt;typename R, typename...As&gt;\nstruct invokable_type&lt;R(As...)&gt;;\n</code></pre>\n<p>should already be able to deal with lambdas. The SSCCE</p>\n<pre><code>#include &lt;utility&gt;\n\ntemplate&lt;class T&gt;\nstruct decompose;\n\ntemplate&lt;class Ret, class T, class... Args&gt;\nstruct decompose&lt;Ret(T::*)(Args...) const&gt;\n{\n    constexpr static int n = sizeof...(Args);\n};\n\ntemplate&lt;class T&gt;\nint deduce(T t)\n{\n    return decompose&lt;decltype(&amp;T::operator())&gt;::n;\n}\n\nstruct test\n{\n    void operator() (int) const {}\n};\n\n#include &lt;iostream&gt;\nint main()\n{\n    std::cout &lt;&lt; deduce(test{}) &lt;&lt; std::endl;\n    std::cout &lt;&lt; deduce([](int){}) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>compiles fine on recent versions of clang++ and g++. It seems the problem is related to g++4.7</p>\n<hr>\n<p>Further research shows that g++-4.7.3 compiles the above example.</p>\n<p>The problem might be related to the misconception that a <em>lambda-expression</em> would yield a function type. If we define <code>do_something</code> as</p>\n<pre><code>template&lt;class C&gt;\nvoid do_something(C&amp;&amp;)\n{\n    std::cout &lt;&lt; invokable_type&lt;C&gt;::n &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Then for a call like <code>do_something( [](int){} )</code>, the template parameter <code>C</code> will be deduced to the closure type (no reference), i.e. a class type. The analogous case for the <code>struct test</code> defined above, would be <code>do_something( test{} )</code>, in which case <code>C</code> would be deduced to <code>test</code>.</p>\n<p>The specialization of <code>invokable_type</code> that is instantiated is therefore the <em>general case</em></p>\n<pre><code>template&lt;class T&gt;\nstruct invokable_type;\n</code></pre>\n<p>as <code>T</code> in both cases is not a \"composite type\" like a pointer or function type. This general case can be used by assuming it only takes a pure class type, and then using the member <code>T::operator()</code> of that class type:</p>\n<pre><code>template&lt;class T&gt;\nstruct invokable_type\n{\n    constexpr static int n = invokable_type&lt;&amp;T::operator()&gt;::n;\n};\n</code></pre>\n<p>or, as <a href=\"https://stackoverflow.com/users/153285/potatoswatter\">Potatoswatter</a> put it, via inheritance</p>\n<pre><code>template&lt;class T&gt;\nstruct invokable_type\n    : invokable_type&lt;&amp;T::operator()&gt;\n{};\n</code></pre>\n<p><a href=\"https://stackoverflow.com/a/19149751/420683\">Potatoswatter's version</a> however is more general and probably better, relying on a SFINAE check for the existance of <code>T::operator()</code>, which can provide a better diagnostic message if the operator cannot be found.</p>\n<p>N.B. If you prefix a lambda-expression that doesn't capture anything with a unary <code>+</code>, it'll be converted to a pointer-to-function. <code>do_something( +[](int){} )</code> will work with a specialization <code>invokable_type&lt;Return(*)(Args...)&gt;</code>.</p>\n</hr>", "OwnerUserId": "420683", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:27:46.330", "Id": "19149568", "Score": "5", "CreationDate": "2013-10-03T01:48:52.897", "LastActivityDate": "2013-10-03T03:09:42.687"}, "bq_ids": {"n4140": {"so_19149150_19149568_1": {"section_id": 5964, "quality": 0.8857142857142857, "length": 31}, "so_19149150_19149568_0": {"section_id": 5962, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_19149150_19149568_1": {"section_id": 5733, "quality": 0.8857142857142857, "length": 31}, "so_19149150_19149568_0": {"section_id": 5731, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_19149150_19149568_1": {"section_id": 7453, "quality": 0.6285714285714286, "length": 22}, "so_19149150_19149568_0": {"section_id": 7451, "quality": 0.8666666666666667, "length": 13}}}, "19149150": {"CommentCount": "14", "AcceptedAnswerId": "19149568", "PostTypeId": "1", "LastEditorUserId": "990597", "CreationDate": "2013-10-03T00:51:55.637", "LastActivityDate": "2013-10-03T03:09:42.687", "LastEditDate": "2013-10-03T01:42:27.813", "ViewCount": "1174", "FavoriteCount": "1", "Title": "Using variadic template arguments to resolve a lambda signature", "Id": "19149150", "Score": "3", "Body": "<p>While there's a lot of stuff floating out there about getting the return type of any templated callback function/method (including lambdas of course), I'm having an extremely hard time finding information about resolving the full call signature of a lambda function. At least in gcc 4.7 it seems to be an edge case where the normal tricks (see below) don't work. Here's what I'm trying to do and have so far (a stripped down version of course)...</p>\n<pre><code>template&lt;typename Sig&gt;\nstruct invokable_type { };\n\ntemplate&lt;typename R, typename...As&gt;\nstruct invokable_type&lt;R(As...)&gt; {\n   static constexpr size_t n = sizeof...(As);\n   typedef R(callable_type)(As...);\n   template&lt;size_t i&gt;\n   struct arg {\n       typedef typename peel_type&lt;i, As...&gt; type;\n   };\n};\n</code></pre>\n<p><code>peel_type&lt;size_t, typename...&gt;</code> is not included here for brevity but it's a simple argument type peeler (I think there's one built in to C++11, but I never bothered to look). It's unimportant for this question.</p>\n<p>Then, of course, specializations (and further properties/typedefs) exist for a myriad of callable types such as <code>R(*)(As...)</code>, <code>R(&amp;)(As...)</code>, <code>(R(T::*)(As...)</code>, <code>std::function&lt;R(As...)&gt;</code>, method cv qualifiers, method lvalue/rvalue qualifiers, etc, etc, etc.</p>\n<p>Then, somewhere down the road we have a lovely function or method (function here, doesn't matter) that looks like...</p>\n<pre><code>template&lt;typename C, typename...As&gt;\nstatic void do_something(C&amp;&amp; callback, As&amp;&amp;...as) {\n    do_something_handler&lt;invokable_type&lt;C&gt;::n, As...&gt;::something(std::forward&lt;C&gt;(callback), std::forward&lt;As&gt;(as)...);\n}\n</code></pre>\n<p>Never mind what <code>do_something_handler</code> does... it's entirely immaterial. The problem lies with lambda functions.</p>\n<p>For all possible generic invokable signatures I've specialized for (which appears to be all but non-STL functors), this works beautifully when <code>do_something()</code> is called with them as the first argument (template deduction fully works). However, lambda functions result in an uncaptured type signature, resulting in <code>invokable_type&lt;Sig&gt;</code> being used, which means things like <code>::n</code> and <code>::args&lt;0&gt;::type</code> simply don't exist.</p>\n<p>Not-a-problem example...</p>\n<pre><code>void something(int x, int y) {\n    return x * y;\n}\n</code></pre>\n<p>... and later...</p>\n<pre><code>do_something(something, 7, 23);\n</code></pre>\n<p>Problem example...</p>\n<pre><code>do_something([](int x, int y) {\n        return x * y;\n    }, 7, 23);\n</code></pre>\n<p>If I understand lambda functions correctly, the compiler is <em>likely</em> to compile this lambda to a static function within the \"namespace\" of the defining scope (gcc certainly seems to). For the life of me I can't figure out what the signature actually is though. It looks like it definitely has one that should be deducible via template specialization (based on error reporting).</p>\n<p>Another tangential question is even if there is a signature I can use, how cross-compiler dangerous this this? Are lambda compilation signatures standardized or is it all across the board?</p>\n", "Tags": "<c++><gcc><c++11><lambda><metaprogramming>", "OwnerUserId": "990597", "AnswerCount": "2"}});