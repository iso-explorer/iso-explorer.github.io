post_cb({"20635269": {"ParentId": "20614282", "CommentCount": "0", "Body": "<p>This is more of the standard C++ rule/feature which tends to be flexible with things and which tends to be more close to C.</p>\n<p>But when we talk of the compilers, GCC or VS, they are more for professional usage and for variety of development purposes and hence put more strict development rules as per your needs. </p>\n<p>That makes sense also, my personal opinion, because the language is all about features and its usage whereas compiler defines the rules for optimal and best way of using it as per your needs.</p>\n<p>As mentioned in above post, compiler sometimes gives the error, sometimes gives warning and also it has the option of skipping these warning etc, indicating the freedom to use the language and its features in a way that suits us best.</p>\n", "OwnerUserId": "2067419", "PostTypeId": "2", "Id": "20635269", "Score": "2", "CreationDate": "2013-12-17T13:19:44.747", "LastActivityDate": "2013-12-17T13:19:44.747"}, "20622422": {"ParentId": "20614282", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Maybe some additional elaboration on the <em>why</em> part of the question.</p>\n<p>C++ was designed so that a very large body of pre-existing body of C code compiles with minimum amount of changes.  Unfortunately, C itself was paying a similar duty to earliest pre-standard C which did not even have the <code>void</code> keyword and instead relied on a default return type of <code>int</code>.  C functions usually did return values, and whenever code superficially similar to Algol/Pascal/Basic procedures was written without any <code>return</code> statements, the function was, under the hood, returning whichever garbage was left on the stack.  Neither the caller nor the callee assigns the value of the garbage in a reliable way.  If the garbage is then ignored by every caller, everything is fine and C++ inherits the moral obligation to compile such code. </p>\n<p>(If the returned value is used by the caller, the code may behave non-deterministically, similar to processing of an uninitialized variable.  Could the difference be reliably identified by a compiler, in a hypothetical successor language to C?  This is hardly possible.  The caller and the callee may be in different compilation units.)</p>\n<p>The implicit <code>int</code> is just a part of the C legacy involved here.  A \"dispatcher\" function might, depending on a parameter, return a variety of types from some code branches, and return no useful value from other code branches.  Such a function would generally be declared to return a type long enough to hold any of the possible types and the caller might need to cast it or extract it from a <code>union</code>.</p>\n<p>So the deepest cause is probably the C language creators' belief that procedures that do not return any value are just an unimportant special case of functions that do; this problem got aggravated by the <a href=\"https://stackoverflow.com/a/8220531/1235565\">lack of focus on type safety of function calls</a> in the oldest C dialects.</p>\n<p>While C++ did break compatibility with some of the worst aspects of C (<a href=\"http://www.drdobbs.com/cpp/the-different-meanings-of-void/231902043?pgno=2\" rel=\"nofollow noreferrer\">example</a>), the willingness to compile a return statement without a value (or the implicit value-less return at the end of a function) was not one of them. </p>\n", "OwnerUserId": "1235565", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:34:14.767", "Id": "20622422", "Score": "21", "CreationDate": "2013-12-16T22:39:16.857", "LastActivityDate": "2013-12-18T08:50:55.710"}, "20614282": {"CommentCount": "20", "AcceptedAnswerId": "20614325", "PostTypeId": "1", "ClosedDate": "2016-05-28T20:27:32.880", "LastEditorUserId": "135769", "CreationDate": "2013-12-16T15:16:54.140", "LastActivityDate": "2017-10-18T08:21:26.780", "LastEditDate": "2014-01-14T02:05:43.073", "ViewCount": "12349", "FavoriteCount": "12", "Title": "Why does this C++ snippet compile (non-void function does not return a value)", "Id": "20614282", "Score": "121", "Body": "<p>I found this in one of my libraries this morning:</p>\n<pre><code>static tvec4 Min(const tvec4&amp; a, const tvec4&amp; b, tvec4&amp; out)\n{\n    tvec3::Min(a,b,out);\n    out.w = min(a.w,b.w);\n}\n</code></pre>\n<p>I'd expect a compiler error because this method doesn't return anything, and the return type is not <code>void</code>.</p>\n<p>The only two things thing that comes to mind are</p>\n<ul>\n<li><p>In the only place where this method is called, the return value isn't being used or stored. (This method was supposed to be <code>void</code> - the <code>tvec4</code> return type is a copy-and-paste error)</p></li>\n<li><p>a default constructed <code>tvec4</code> is being created, which seems a bit unlike, oh, everything else in C++.</p></li>\n</ul>\n<p>I haven't found the part of the C++ spec that addresses this. References (ha) are appreciated.</p>\n<p><strong>Update</strong></p>\n<p>In <em>some</em> circumstances, this generates an error in VS2012. I haven't narrowed down specifics, but it's interesting, nonetheless.</p>\n", "Tags": "<c++><visual-studio-2012><c++11><methods>", "OwnerUserId": "135769", "AnswerCount": "7"}, "20615085": {"ParentId": "20614282", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>Maybe some elaboration on the <em>why</em> part of the question:</p>\n<p>As it turns out, it is actually quite hard\u2020 for a C++ compiler to determine whether a function exits without a return value. In addition to the code paths that end in explicit return statements and the ones that fall off the end of the function, you also have to consider potential exception throws or <code>longjmp</code>s in the function itself, as well as all of its callees.</p>\n<p>While it is quite easy for a compiler to identify a function that looks like it might be missing a return, it is considerably harder to <em>prove</em> that it is missing a return. In order to lift compiler vendors of this burden, the standard does not require this to generate an error.</p>\n<p>So compiler vendors are free to generate a warning if they are quite sure that a function is missing a return and the user is then free to ignore/mask that warning in those rare cases where the compiler was actually wrong.</p>\n<p>\u2020: <em>In the general case, this is equivalent to the <a href=\"https://en.wikipedia.org/wiki/Halting_problem\" rel=\"nofollow noreferrer\">halting problem</a>, so it is actually impossible for a machine to decide this reliably.</em></p>\n", "OwnerUserId": "577603", "LastEditorUserId": "577603", "LastEditDate": "2017-10-18T08:21:26.780", "Id": "20615085", "Score": "58", "CreationDate": "2013-12-16T15:54:55.060", "LastActivityDate": "2017-10-18T08:21:26.780"}, "20614325": {"ParentId": "20614282", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>This is <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\">undefined behavior</a> from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\">C++11 draft standard</a> section <code>6.6.3</code> <em>The return statement</em> paragraph <em>2</em> which says:</p>\n<blockquote>\n<p id=\"so_20614282_20614325_0\">[...] Flowing off the end of a function is equivalent to a return with no value; this results in undefined behavior in a value-returning function. [...]</p>\n</blockquote>\n<p>This means that the compiler is not obligated provide an error nor a warning usually because it can be difficult to diagnose in all cases. We can see this from the definition of <em>undefined behavior</em> in the draft standard in section <code>1.3.24</code> which says:</p>\n<blockquote>\n<p id=\"so_20614282_20614325_1\">[...]Permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).[...]</p>\n</blockquote>\n<p>Although in this case we can get both <code>gcc</code> and <code>clang</code> to generate a wanring using the <code>-Wall</code> flag, which gives me a warning similar to this:</p>\n<blockquote>\n<p id=\"so_20614282_20614325_2\">warning: control reaches end of non-void function [-Wreturn-type]</p>\n</blockquote>\n<p>We can turn this particular warning into an error using the <code>-Werror=return-type</code> flag. I also like to use <code>-Wextra -Wconversion -pedantic</code> for my own personal projects.</p>\n<p>As ComicSansMS mentions in <em>Visual Studio</em> this code would generate <a href=\"http://msdn.microsoft.com/en-us/library/ft5xye74.aspx\">C4716</a> which is an error by default, the message I see is:</p>\n<blockquote>\n<p id=\"so_20614282_20614325_3\">error C4716: 'Min' : must return a value</p>\n</blockquote>\n<p>and in the case where not all code paths would return a value then it would generate <a href=\"http://msdn.microsoft.com/en-us/library/6deaf4k9.aspx\">C4715</a>, which is a warning.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2013-12-17T15:06:10.440", "Id": "20614325", "Score": "146", "CreationDate": "2013-12-16T15:18:56.897", "LastActivityDate": "2013-12-17T15:06:10.440"}, "20614398": {"ParentId": "20614282", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Compile your code with <code>-Wreturn-type</code> option:</p>\n<pre><code>$ g++ -Wreturn-type source.cpp\n</code></pre>\n<p>This will give you <strong>warning</strong>. You can turn the warning into <strong>error</strong> if you use <code>-Werror</code> too:</p>\n<pre><code>$ g++ -Wreturn-type -Werror source.cpp\n</code></pre>\n<p>Note that this will turn <em>all</em> warnings into errors. So if you want error for specific warning, say <code>-Wreturn-type</code>, just type <code>return-type</code> without <code>-W</code> part as:</p>\n<pre><code>$ g++ -Werror=return-type source.cpp\n</code></pre>\n<p>In general you should always use <code>-Wall</code> option which includes most common warnings \u2014 this includes missing return statement also. Along with <code>-Wall</code>, you can use <code>-Wextra</code> also, which includes other warnings not included by <code>-Wall</code>.</p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2013-12-16T15:29:13.023", "Id": "20614398", "Score": "22", "CreationDate": "2013-12-16T15:22:53.623", "LastActivityDate": "2013-12-16T15:29:13.023"}, "32514244": {"ParentId": "20614282", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Along with this there are several other questions mentioning this behaviour of returning a result without having a <code>return</code> statement. One simple example would be: </p>\n<pre><code>int foo(int a, int b){ int c = a+b;}\n\nint main(){\n   int c = 5;\n   int d = 5;\n\n   printf(\"f(%d,%d) is %d\\n\", c, d, foo(c,d)); \n\n   return 0;\n}\n</code></pre>\n<p>Could this anomaly be due stack properties and more specifically:</p>\n<h2>Zero-Address Machines</h2>\n<blockquote>\n<p id=\"so_20614282_32514244_0\">In zero-address machines, locations of <strong>both operands are assumed to be at a default location</strong>.\n  These machines use the stack as the source of the input operands and the result goes back into\n  the stack. Stack is a LIFO (last-in-first-out) data structure that all processors support, whether\n  or not they are zero-address machines. As the name implies, the last item placed on the stack\n  is the first item to be taken out of the stack. <strong>All operations on this type of machine assume that the required input operands are the top\n  two values on the stack. The result of the operation is placed on top of the stack.</strong> </p>\n</blockquote>\n<p>In addition to that, for accessing memory to read and write data same registers are used as data source and destination(DS (data segment) register), that store first the variables needed for the calculation and then the returned result.  </p>\n<h2>Note:</h2>\n<p>with this answer I would like to discuss one possible explanation of the strange behaviour at machine (instruction) level as it has already a context and its covered in adequately wide range.</p>\n", "OwnerUserId": "3313438", "LastEditorUserId": "3313438", "LastEditDate": "2015-09-11T08:20:39.883", "Id": "32514244", "Score": "0", "CreationDate": "2015-09-11T01:42:50.400", "LastActivityDate": "2015-09-11T08:20:39.883"}, "bq_ids": {"n4140": {"so_20614282_20614325_1": {"section_id": 5768, "quality": 1.0, "length": 26}, "so_20614282_20614325_0": {"section_id": 3913, "quality": 1.0, "length": 12}, "so_20614282_20614325_2": {"section_id": 3360, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_20614282_20614325_1": {"section_id": 5541, "quality": 1.0, "length": 26}, "so_20614282_20614325_0": {"section_id": 3773, "quality": 1.0, "length": 12}, "so_20614282_20614325_2": {"section_id": 3230, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_20614282_20614325_0": {"section_id": 4799, "quality": 0.75, "length": 9}, "so_20614282_20614325_1": {"section_id": 7225, "quality": 1.0, "length": 26}, "so_20614282_20614325_2": {"section_id": 4126, "quality": 0.5714285714285714, "length": 4}}}, "20614434": {"ParentId": "20614282", "CommentCount": "0", "Body": "<p>As already mentioned, this is undefined behavior and will give you a compiler warning.  Most places I've worked require you to turn on compiler settings to treat warnings as errors - which enforces that all your code must compile with 0 errors and 0 warnings.  This is a good example of why that is a good idea.</p>\n", "OwnerUserId": "529761", "PostTypeId": "2", "Id": "20614434", "Score": "12", "CreationDate": "2013-12-16T15:24:43.250", "LastActivityDate": "2013-12-16T15:24:43.250"}});