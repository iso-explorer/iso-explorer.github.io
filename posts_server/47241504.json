post_cb({"47241504": {"CommentCount": "0", "ViewCount": "44", "CreationDate": "2017-11-11T18:40:21.450", "LastActivityDate": "2017-11-11T19:09:01.200", "Title": "Initialization of static members of class templates with side effects", "AcceptedAnswerId": "47241678", "PostTypeId": "1", "Id": "47241504", "Score": "0", "Body": "<p>My C++14 application needs to dynamically create and destroy objects of a certain type. Each of these objects is named, and the name is assigned when the object is constructed. Each name is hard-coded as a string literal. The following pseudocode demonstrates the idea:</p>\n<pre><code>int foo()\n{\n    NamedEntity entity1(\"Bar\");\n    NamedEntity entity2(\"Baz\");\n\n    // do some work\n\n    return 42;\n}\n</code></pre>\n<p>My objective is to create a constant list of all <em>object names</em> used in the application, and make it accessible for the application at run time.</p>\n<p>The first naive solution that comes to mind is to grep the sources and autogenerate a header with a hard-coded list of names. Let's put this solution aside as a last resort option.</p>\n<p>Can I create the list of <em>object names</em> at compile time? I am a big admirer of Mr. Alexanderscu's ways, so I thought, \"Sure, why not, I'm going to craft a really clever user-defined string literal and call it a day\".</p>\n<p>The idea was as follows:</p>\n<ol>\n<li>Instantiate a new type for every <em>object name</em> using a user-defined string literal. We're going to call this type an <em>object name type</em>.</li>\n<li>Equip each of the instantiated <em>object name types</em> with a dummy static member. Initialize said static member with the return value of an arbitrary static function. We're going to call this function a <em>registrator function</em>.</li>\n<li>Define a singleton with a list of <em>object names</em>. Use the above mentioned <em>registrator function</em> to append names to the singleton's list.</li>\n</ol>\n<p>The user-defined string literal was supposed to be applied roughly as follows:</p>\n<pre><code>int foo()\n{\n    NamedEntity entity1(\"Bar\"_probe);\n    NamedEntity entity2(\"Baz\"_probe);\n\n    // do some work\n\n    return 42;\n}\n</code></pre>\n<p>See <code>_probe</code>? This was supposed to be the solution.</p>\n<p>Well, it didn't work. It turned out that the compiler defers initialization of the <em>dummy static member</em> up to the point where the user-defined string literal is actually invoked. This means that my list of names will remain incomplete until every single named entity was created at least once.</p>\n<p>Why is it so? Clearly the <em>registrator function</em> has side effects (we need it only for the sake of its side effects), and therefore, according to <a href=\"http://en.cppreference.com/w/cpp/language/initialization\" rel=\"nofollow noreferrer\">cppreference</a>, initialization of the dummy static member cannot be postponed:</p>\n<blockquote>\n<h3>Deferred dynamic initialization</h3>\n<p id=\"so_47241504_47241504_0\">It is implementation-defined whether dynamic initialization happens-before the first statement of the main function (for statics) or the initial function of the thread (for thread-locals), or deferred to happen after.</p>\n<p id=\"so_47241504_47241504_1\">If the initialization of a non-inline variable is deferred to happen after the first statement of main/thread function, it happens before the first odr-use of any variable with static/thread storage duration defined in the same translation unit as the variable to be initialized. If no variable or function is odr-used from a given translation unit, the non-local variables defined in that translation unit may never be initialized (this models the behavior of an on-demand dynamic library). <strong>However, as long as anything from a TU is odr-used, all non-local variables whose initialization or destruction has side effects will be initialized even if they are not used in the program.</strong></p>\n</blockquote>\n<p>Below you will find a somewhat reduced MWE:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint g_foo = 0;\n\ntemplate &lt;typename T, T... Chars&gt;\nclass Registrator\n{\n    static int dummy_;\n\npublic:\n    static int run()\n    {\n        g_foo++;\n        static constexpr char str[sizeof...(Chars) + 1] = { Chars..., '\\0' };\n        std::cout &lt;&lt; \"Registering: \" &lt;&lt; &amp;str[0] &lt;&lt; std::endl;\n        return g_foo;\n    }\n};\n\ntemplate &lt;typename T, T... Chars&gt;\nint Registrator&lt;T, Chars...&gt;::dummy_ = Registrator&lt;T, Chars...&gt;::run();\n\ntemplate &lt;typename T, T... Chars&gt;\ninline int operator\"\"_probe()\n{\n    static constexpr char str[sizeof...(Chars) + 1] = { Chars..., '\\0' };\n    return Registrator&lt;T, Chars...&gt;::run();\n}\n\nint main(int argc, char**)\n{\n    std::cout &lt;&lt; \"g_foo=\" &lt;&lt; g_foo &lt;&lt; std::endl;\n\n    if (argc &gt; 1)\n    {\n        std::cout &lt;&lt; \"Hello\"_probe &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"World\"_probe &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; \"g_foo=\" &lt;&lt; g_foo &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>If it were to work correctly, you would have observed roughly the following output upon running it without arguments:</p>\n<pre><code>Registering: Hello\nRegistering: World\ng_foo=2\n1\n2\ng_foo=2\n</code></pre>\n<p>However, I am observing the following instead:</p>\n<pre><code>g_foo=0\ng_foo=0\n</code></pre>\n<p>Which implies that the compiler <strong>did not initialize the dummy static members at all</strong>.</p>\n<p>Running the program with at least one argument will force it to explicitly use the user-defined literal, and in this case, the dummy statics actually get initialized, but initialization is postponed until the point where the user-defined literal is used:</p>\n<pre><code>g_foo=0\nRegistering: Hello\n1\nRegistering: World\n2\ng_foo=2\n</code></pre>\n<p>I'm using GCC 5.4.0 with <code>-std=c++14</code>. Why doesn't the compiler want to initialize my statics? Is this behavior correct? How do I work around that?</p>\n", "Tags": "<c++><templates><static><c++14><static-initialization>", "OwnerUserId": "1007777", "AnswerCount": "1"}, "47241678": {"ParentId": "47241504", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You need to actually use <code>dummy_</code> somehow, for example by taking its address:</p>\n<pre><code>static int run()\n{\n    &amp;dummy_;\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/aTECYhxDfcxjghIn\" rel=\"nofollow noreferrer\">Run in online compiler</a></p>\n<p>Also note that string literal operator templates are a GNU extension. And self-registration is probably not a good idea in general.</p>\n", "OwnerUserId": "7860670", "LastEditorUserId": "7860670", "LastEditDate": "2017-11-11T19:09:01.200", "Id": "47241678", "Score": "2", "CreationDate": "2017-11-11T18:58:02.583", "LastActivityDate": "2017-11-11T19:09:01.200"}, "bq_ids": {"n4140": {"so_47241504_47241504_0": {"section_id": 7154, "quality": 0.5882352941176471, "length": 10}}, "n3337": {"so_47241504_47241504_0": {"section_id": 6898, "quality": 0.5882352941176471, "length": 10}}, "n4659": {"so_47241504_47241504_0": {"section_id": 8657, "quality": 0.5294117647058824, "length": 9}}}});