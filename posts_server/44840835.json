post_cb({"bq_ids": {"n4140": {"so_44840835_44842528_1": {"length": 9, "quality": 0.5294117647058824, "section_id": 6037}}, "n3337": {"so_44840835_44842528_1": {"length": 9, "quality": 0.5294117647058824, "section_id": 5890}}, "n4659": {"so_44840835_44842528_1": {"length": 9, "quality": 0.5294117647058824, "section_id": 7536}}}, "44842528": {"Id": "44842528", "PostTypeId": "2", "Body": "<p>I think that the code introduces undefined behaviour due to the following two lines that are executed in the course of your program:</p>\n<pre><code>unsigned char *buffer = (unsigned char *)malloc(65536);\n...\nstruct iphdr *iph = (struct iphdr*)buffer;\n</code></pre>\n<p><code>buffer</code> is a pointer to a memory block reserved as <code>unsigned char*</code>, which is then casted to a pointer of type <code>struct iphdr</code>; yet <code>struct iphdr</code> very likely has different alignment restrictions than <code>char*</code>, and this is undefined behaviour (cf, for example, <a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.3.2.3p7\" rel=\"nofollow noreferrer\">this online c11 draft standard</a>):</p>\n<blockquote>\n<p id=\"so_44840835_44842528_0\">6.3.2.3 Pointers</p>\n<p id=\"so_44840835_44842528_1\">(7) A pointer to an object type may be converted to a pointer to a\n  different object type. If the resulting pointer is not correctly\n  aligned for the referenced type, the behavior is undefined. ...</p>\n</blockquote>\n<p>Though it may work (which is still one of the options of UB), it can also be that the program behaves in way that you do not intend.</p>\n<p>I'd suggest to copy the information into a correctly aligned <code>struct iphdr</code>-object instead:</p>\n<pre><code>unsigned char *buffer = (unsigned char *)malloc(65536);\n...\nstruct iphdr iphobj;\nmemcpy(&amp;iphobj,buffer,sizeof(struct iphdr));\n...\n</code></pre>\n<p>Take care of the lifetime of the object then. </p>\n<p>Note that you tagged the code <code>C</code> and <code>C++</code>, and both languages have different rules (e.g. concerning the explicit casting of the result of <code>malloc</code>, which is required in C++ but not encouraged in C).</p>\n<p>But concerning UB, I'm quite sure that the code introduces UB in both languages, C and C++.</p>\n", "LastActivityDate": "2017-06-30T08:57:11.153", "CommentCount": "1", "CreationDate": "2017-06-30T08:57:11.153", "ParentId": "44840835", "Score": "2", "OwnerUserId": "2630032"}, "44841640": {"Id": "44841640", "PostTypeId": "2", "Body": "<p>The first thing to understand is that the bits on memory stay exactly the same irrespective of the cast <code>(struct iphdr *)</code>. Just that you are now saying that <code>buffer</code> is now to be treated as a pointer to <code>struct iphdr</code> instead of what it was before. You are just telling the compiler to look at the bits with a different pair of glasses and hence interpret accordingly. The compiler suddenly sees that <code>buffer</code> has become a <code>struct iphdr *</code>. And says \"OK\" that's all. What's important is you know exactly what <code>buffer</code> is and cast it to the proper type.</p>\n<p>If you wanted, you could have type-casted <code>buffer</code> to <code>int *</code> (or any other pointer type) and the compiler would have said nothing. Although you would have problems later on.</p>\n", "LastActivityDate": "2017-06-30T08:06:47.383", "CommentCount": "1", "CreationDate": "2017-06-30T08:06:47.383", "ParentId": "44840835", "Score": "0", "OwnerUserId": "452414"}, "44841645": {"Id": "44841645", "PostTypeId": "2", "Body": "<p><code>buffer</code> is <strong>not</strong> a <code>string</code>. It is a pointer to <em>raw</em> binary data. <code>recvfrom</code> fills (in this example, see below) <code>buffer</code> with raw IP/TCP frames (aka packets). Thus, the first <code>sizeof(iphdr)</code> bytes of <code>buffer</code> is the <a href=\"https://en.wikipedia.org/wiki/IP_header\" rel=\"nofollow noreferrer\">IP-header</a> struct: <code>iphdr</code>. And that is exactly why the author of the blog use the snippet you presented:</p>\n<pre><code>struct iphdr * iph = (struct iphdr *)buffer;\n</code></pre>\n<p>If there are IP header options included then the actual size of the header is <code>iph-&gt;ihl*4</code>.</p>\n<p>The <em>protocol</em> field (<code>iph-&gt;protocol</code>) of the header is then inspected in <code>ProcessPacket</code> (in the blog), to determine which transport protocol the packet contains.</p>\n<p>If the transport protocol used is <a href=\"https://en.wikipedia.org/wiki/Transmission_Control_Protocol\" rel=\"nofollow noreferrer\">TCP</a> then the TCP header (and later the data) can be extracted using (snippet from blog):</p>\n<pre><code>unsigned short iphdrlen = iph-&gt;ihl*4;\nstruct tcphdr *tcph = (struct tcphdr*)(buffer + iphdrlen);\n</code></pre>\n<p><strong>Raw Frames</strong></p>\n<p>The author of the blog created the socket using:</p>\n<pre><code>sock_raw = socket(AF_INET , SOCK_RAW , IPPROTO_TCP);\n</code></pre>\n<ul>\n<li>The first parameter <code>AF_INET</code> means that you want <a href=\"https://da.wikipedia.org/wiki/IPv4\" rel=\"nofollow noreferrer\">IPv4</a> packet (as oppose to <code>AF_INET6</code> for <a href=\"https://da.wikipedia.org/wiki/IPv6\" rel=\"nofollow noreferrer\">IPv6</a>).</li>\n<li>The second parameter tells <code>socket</code> that you want the raw frames</li>\n<li>The third parameter (<code>IPPROTO_TCP</code>) ensures that you get TCP frames</li>\n</ul>\n<p>Alternatively, if you want <a href=\"https://en.wikipedia.org/wiki/User_Datagram_Protocol\" rel=\"nofollow noreferrer\">UDP</a> frames you could use:</p>\n<pre><code> sock_raw = socket(AF_INET , SOCK_RAW , IPPROTO_UDP);\n</code></pre>\n<p>In case you are <em>greedy</em> and want <strong>every</strong> packet use (please do read up on the frame format before using this!):</p>\n<pre><code>socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));\n</code></pre>\n", "LastEditorUserId": "2378300", "LastActivityDate": "2017-06-30T08:40:33.637", "Score": "5", "CreationDate": "2017-06-30T08:07:01.927", "ParentId": "44840835", "CommentCount": "1", "OwnerUserId": "2378300", "LastEditDate": "2017-06-30T08:40:33.637"}, "44840835": {"ViewCount": "163", "Body": "<p>In the code <a href=\"http://www.binarytides.com/packet-sniffer-code-c-linux/\" rel=\"nofollow noreferrer\">here</a>, there is a line:</p>\n<pre><code>struct iphdr * iph = (struct iphdr *)buffer;\n</code></pre>\n<p>in <code>ProcessPacket</code> function where <code>buffer</code> is of type <code>char*</code>. <code>buffer</code> has been given value by <code>recvfrom</code> in the main function. How is the simple string (<code>buffer</code>) converted to a structure and how is the data safely extracted?</p>\n<p><strong>iphdr:</strong></p>\n<pre><code>struct iphdr {\n    #if defined(__LITTLE_ENDIAN_BITFIELD)\n        __u8    ihl:4,\n                version:4;\n    #elif defined (__BIG_ENDIAN_BITFIELD)\n        __u8    version:4,\n                ihl:4;\n    #else\n        #error  \"Please fix &lt;asm/byteorder.h&gt;\"\n    #endif\n         __u8   tos;\n         __u16  tot_len;\n         __u16  id;\n         __u16  frag_off;\n         __u8   ttl;\n         __u8   protocol;\n         __u16  check;\n         __u32  saddr;\n         __u32  daddr;\n         /*The options start here. */\n};\n</code></pre>\n", "AcceptedAnswerId": "44841640", "Title": "Converting char* to struct", "CreationDate": "2017-06-30T07:22:26.320", "Id": "44840835", "CommentCount": "4", "LastEditDate": "2017-06-30T16:46:19.657", "PostTypeId": "1", "LastEditorUserId": "2612002", "LastActivityDate": "2017-06-30T16:46:19.657", "Score": "3", "OwnerUserId": "7792766", "Tags": "<c++><c><sockets>", "AnswerCount": "3"}});