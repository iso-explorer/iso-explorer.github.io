post_cb({"31050495": {"ParentId": "31049885", "CommentCount": "2", "Body": "<p>VS 2013 <a href=\"https://msdn.microsoft.com/en-us/library/hh567368.aspx#corelanguagetable\">doesn't support C++11 unrestricted unions</a>, that is it implements unions as per C++03: </p>\n<blockquote>\n<p id=\"so_31049885_31050495_0\">An object\n  of a class with a non-trivial constructor (12.1), a non-trivial copy constructor (12.8), a non-trivial destructor\n  (12.4), or a non-trivial copy assignment operator (13.5.3, 12.8) cannot be a member of a union</p>\n</blockquote>\n<p>You successfully fooled the compiler by using unnamed structs, but that doesn't solve the problem: the objects are non-trivial, and VS2013 doesn't support that.</p>\n<p>When you switch to more C++11-compliant compiler, such as VS 2015, you'll have to implement constructor, destructor, copy constructor etc. for the union in a way that it safely constructs/destructs/copies appropriate part of the union. There's an example in the standard (I'm quoting C++14 draft N4140 [class.union]/4):</p>\n<blockquote>\n<p id=\"so_31049885_31050495_1\">Consider an object <code>u</code> of a union type <code>U</code> having non-static data\n  members <code>m</code> of type <code>M</code> and <code>n</code> of type <code>N</code>. If <code>M</code> has a non-trivial destructor and <code>N</code> has a non-trivial constructor\n  (for instance, if they declare or inherit virtual functions), the active member of <code>u</code> can be safely switched\n  from <code>m</code> to <code>n</code> using the destructor and placement new operator as follows:</p>\n<pre><code>u.m.~M();\nnew (&amp;u.n) N;\n</code></pre>\n</blockquote>\n", "OwnerUserId": "3959454", "PostTypeId": "2", "Id": "31050495", "Score": "5", "CreationDate": "2015-06-25T12:32:12.443", "LastActivityDate": "2015-06-25T12:32:12.443"}, "31049885": {"CommentCount": "0", "ViewCount": "106", "PostTypeId": "1", "LastEditorUserId": "3959454", "CreationDate": "2015-06-25T12:04:38.947", "LastActivityDate": "2015-06-25T12:38:32.233", "Title": "VS 2013 exception when using C++11 unrestricted unions", "AcceptedAnswerId": "31050495", "LastEditDate": "2015-06-25T12:38:32.233", "Id": "31049885", "Score": "0", "Body": "<p>Consider this code:</p>\n<pre><code>struct TNumeric {\n    bool    Negative;\n    wstring Integral;\n    wstring Fraction;\n};\nunion TValue {\n    // The unnamed structs are needed because otherwise the compiler does not accept it...\n    bool                Bit;\n    struct{ TNumeric    Numeric; };\n    struct{ wstring     Text; };\n};\n\nTNumeric Numeric;\nTNumeric &amp;rNumeric{ Numeric };\nrNumeric.Integral = L\"\";\nrNumeric.Integral.push_back( L'X' ); //OK, no problem\n\nTValue Value;\nTValue &amp;rValue{ Value };\nrValue.Text = L\"\";\nrValue.Text.push_back( L'X' ); //OK, no problem\n\nrValue.Numeric.Integral = L\"\";\nrValue.Numeric.Integral.push_back( L'X' ); // Exception\n</code></pre>\n<p>In release mode there is no problem. When run in debug mode there is an exception at the last statement in method _Adopt of class _Iterator_base12 in xutility: <code>Access violation reading location 0x0000005C</code>. </p>\n<p>In _Adopt the code is only run when <code>_ITERATOR_DEBUG_LEVEL == 2</code>. I tried with</p>\n<pre><code>#define _ITERATOR_DEBUG_LEVEL 1\n</code></pre>\n<p>added in my main program but it remains defined as 2.\nIs there a way to disable the check?</p>\n", "Tags": "<c++><c++11><visual-studio-2013><unions>", "OwnerUserId": "2703130", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31049885_31050495_1": {"section_id": 5916, "quality": 0.967741935483871, "length": 30}}, "n3337": {"so_31049885_31050495_1": {"section_id": 5688, "quality": 0.967741935483871, "length": 30}}, "n4659": {"so_31049885_31050495_1": {"section_id": 7409, "quality": 0.9032258064516129, "length": 28}}}});