post_cb({"7624942": {"ParentId": "7624714", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>For <code>std::memcpy</code> it is sufficient that the type be trivially copyable. From n3290, 3.9 Types [basic.types] paragraph 2:</p>\n<blockquote>\n<p id=\"so_7624714_7624942_0\">For any object (other than a base-class subobject) of trivially copyable type T, whether or not the object holds a valid value of type T, the underlying bytes (1.7) making up the object can be copied into an array of char or unsigned char.</p>\n</blockquote>\n<p>Following paragraphs also describe other useful properties of trivially copyables types (i.e. not just copying to a <code>char</code> array).</p>\n<p><code>std::is_trivially_copyable</code> is the trait to detect just that. However as of my writing it's not implemented by e.g. GCC, so you may want to use <code>std::is_trivial</code> as a fallback (since in turn it requires a trivial copy constructor).</p>\n<p>I really do not recommend using <code>is_standard_layout</code>, unless you really know what you're doing (e.g. language interoperability on one particular platform) it's not what you want. <a href=\"https://stackoverflow.com/questions/6496545/trivial-vs-standard-layout-vs-pod\">More information</a> on what triviality and standard layout is about to perhaps help you specify the exact requirements you want.</p>\n", "OwnerUserId": "726300", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:27:32.190", "Id": "7624942", "Score": "6", "CreationDate": "2011-10-02T06:24:49.327", "LastActivityDate": "2011-10-02T06:24:49.327"}, "bq_ids": {"n4140": {"so_7624714_7624942_0": {"section_id": 7200, "quality": 0.9615384615384616, "length": 25}, "so_7624714_7624757_0": {"section_id": 5854, "quality": 0.95, "length": 19}}, "n3337": {"so_7624714_7624942_0": {"section_id": 6944, "quality": 0.9615384615384616, "length": 25}, "so_7624714_7624757_0": {"section_id": 5624, "quality": 0.95, "length": 19}}, "n4659": {"so_7624714_7624942_0": {"section_id": 8709, "quality": 0.9615384615384616, "length": 25}, "so_7624714_7624757_0": {"section_id": 7333, "quality": 0.95, "length": 19}}}, "7624757": {"ParentId": "7624714", "CommentCount": "1", "Body": "<p>The definition of POD in C++11 is:</p>\n<blockquote>\n<p id=\"so_7624714_7624757_0\">A POD struct is a non-union class that is both a trivial class and a standard-layout class, and has no non-static data members of type non-POD struct, non-POD union (or array of such types).</p>\n</blockquote>\n<p>So unless you are violating the rules of standard layout or something of that nature, <code>is_pod</code> should be sufficient. And if you're breaking the rules of standard layout, then you can't use <code>memcpy</code> and <code>memset</code> and so forth.</p>\n<p>So I don't know why you need this unless you trying to test triviality specifically.</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "7624757", "Score": "1", "CreationDate": "2011-10-02T05:20:43.113", "LastActivityDate": "2011-10-02T05:20:43.113"}, "7624714": {"CommentCount": "2", "AcceptedAnswerId": "7624942", "PostTypeId": "1", "LastEditorUserId": "975129", "CreationDate": "2011-10-02T05:03:40.273", "LastActivityDate": "2011-10-02T08:51:42.550", "LastEditDate": "2011-10-02T08:51:42.550", "ViewCount": "2240", "FavoriteCount": "3", "Title": "C++ : how do I use type_traits to determine if a class is trivial?", "Id": "7624714", "Score": "8", "Body": "<p>In C++0x, I would like to determine if a class is trivial/has standard layout so I can use memcpy(), memset(), etc...  </p>\n<p>How should I implement the code below, using type_traits, so I can confirm that a type is trivial?</p>\n<pre><code>template&lt; typename T &gt;\nbool isTrivialType()\n{\n  bool isTrivial = ???\n  return isTrivial;\n}\n</code></pre>\n<p>NOTE: is_pod() is too restrictive: I would like my class to have trivial constructors, etc... ...for convenience.</p>\n<p>Added:  I think std::is_standard_layout&lt;&gt; may give me what I'm looking for.\n1. If I add constructors, it still returns true\n2. If I add a virtual method, it returns false\nThis is what I need to determine if I can use memcpy(), memset()</p>\n<p>Edit:  From Luc Danton's explanation and link below (clarification):</p>\n<pre><code>struct N { // neither trivial nor standard-layout\n   int i;\n   int j;\n    virtual ~N();\n};\n\nstruct T { // trivial but not standard-layout\n    int i;\nprivate:\n    int j;\n};\n\nstruct SL { // standard-layout but not trivial\n    int i;\n    int j;\n    ~SL();\n};\n\nstruct POD { // both trivial and standard-layout\n    int i;\n    int j;\n};\n</code></pre>\n<p>For memcpy() to be happy:</p>\n<pre><code>// N -&gt; false\n// T -&gt; true\n// SL -&gt; ??? (if there are pointer members in destructor, we are in trouble)\n// POD -&gt; true\n</code></pre>\n<p>So it does look like is_trivial_class&lt;&gt; is correct: is_standard_layout&lt;&gt; is not necessarily right...</p>\n", "Tags": "<c++><c++11><pod><typetraits>", "OwnerUserId": "975129", "AnswerCount": "2"}});