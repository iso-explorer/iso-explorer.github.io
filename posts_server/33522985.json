post_cb({"33522985": {"ViewCount": "345", "Body": "<p>How to explain the difference, when I compile <code>#if 0</code> and <code>#if 1</code> versions of the following code:</p>\n<pre><code>#include &lt;cstdlib&gt;\n\nstruct A\n{ \n    explicit A() = default; // explicitly defaulted or deleted constructors are allowed for aggregates (since C++11)\n#if 1\nprivate :\n#endif\n    int i;\n};\n\nint\nmain()\n{\n    A a = {};\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<ul>\n<li>for <code>#if 0</code> all is fine, compilation successful.</li>\n<li>for <code>#if 1</code> compilation failed with error message:\n\n<blockquote>\n<p id=\"so_33522985_33522985_0\">error: chosen constructor is explicit in copy-initialization</p>\n</blockquote></li>\n</ul>\n<p>What is the difference for expression <code>A a = {};</code> depending on whether <code>A</code> is aggreagate or not?</p>\n", "AcceptedAnswerId": "33523669", "Title": "Explicit defaulted default constructor and aggregates", "CreationDate": "2015-11-04T13:18:53.923", "Id": "33522985", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2015-11-04T16:13:20.237", "Score": "11", "OwnerUserId": "1430927", "Tags": "<c++><c++11><constructor><c++14><default-constructor>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33522985_33523669_2": {"length": 17, "quality": 0.8947368421052632, "section_id": 3298}, "so_33522985_33523669_0": {"length": 8, "quality": 0.8, "section_id": 592}}, "n3337": {"so_33522985_33523669_2": {"length": 17, "quality": 0.8947368421052632, "section_id": 3168}, "so_33522985_33523669_0": {"length": 8, "quality": 0.8, "section_id": 582}}, "n4659": {"so_33522985_33523669_2": {"length": 12, "quality": 0.631578947368421, "section_id": 4063}, "so_33522985_33523669_0": {"length": 9, "quality": 0.9, "section_id": 615}}}, "33523669": {"Id": "33523669", "PostTypeId": "2", "Body": "<p>TL;DR: Clang and GCC are wrong in rejecting your code. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1518\" rel=\"nofollow noreferrer\"><strong>CWG 1630</strong></a>\u00b4s resolution made default-initialization well-formed regardless of the chosen default constructor being <code>explicit</code> or not.</p>\n<hr>\n<p>In the variation of your code in which <code>i</code> is <code>private</code>, <code>A</code> is not an aggregate, as these cannot have private members. As long as <code>i</code> is <code>public</code>, however, <code>A</code> is an aggregate<sup>1</sup>, and no constructor is invoked since aggregate initialization is performed (see blue box), so your constructor being <code>explicit</code> is irrelevant.</p>\n<p><a href=\"https://i.stack.imgur.com/zdfwR.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/zdfwR.png\"/></a> </p>\n<p>However, as soon as you introduce the private member, you necessitate value-initialization as per the red box. Hence [dcl.init]/(8.2) applies:</p>\n<p><a href=\"https://i.stack.imgur.com/iXBFj.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/iXBFj.png\"/></a></p>\n<p>[dcl.init]/(7.1) defines default-initialization for this case:</p>\n<p><a href=\"https://i.stack.imgur.com/T5CU6.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/T5CU6.png\"/></a></p>\n<p>And \u00a713.3.1.3 gives</p>\n<blockquote>\n<p id=\"so_33522985_33523669_0\">For [\u2026] default-initialization, the candidate\n  functions are all the constructors of the class of the object being\n  initialized.</p>\n</blockquote>\n<p>At no point is the original context - copy- or direct-initialization - considered. (\u00a713.3.1.7 doesn't apply either.) In fact, this is intended; see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1518\" rel=\"nofollow noreferrer\"><strong>CWG #1518</strong></a>:</p>\n<blockquote>\n<p id=\"so_33522985_33523669_1\">This issue is resolved by the resolution of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1630\" rel=\"nofollow noreferrer\">issue 1630</a>: <strong>default initialization now uses 13.3.1.3 [over.match.ctor], which now permits explicit constructors for default-initialization.</strong></p>\n</blockquote>\n<p>Clang and GCC (and VC++) haven't implemented the corresponding DR yet and are thus incorrect in rejecting the code in C++14 mode.</p>\n<hr>\n<p><sup>1)</sup>\n Your class has a user-declared constructor, but it isn't user-<em>provided</em>, i.e. not impeding your class from being an aggregate. Recall the definition in  [dcl.init.aggr]/1:</p>\n<blockquote>\n<p id=\"so_33522985_33523669_2\">An <em>aggregate</em> is an array or a class (Clause 9) with no user-provided\n  constructors (12.1), no private or protected non-static data members\n  (Clause 11), no base classes (Clause 10), and no virtual functions\n  (10.3).</p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2015-11-04T16:13:20.237", "Score": "7", "CreationDate": "2015-11-04T13:55:18.307", "ParentId": "33522985", "CommentCount": "11", "OwnerUserId": "3647361", "LastEditDate": "2015-11-04T16:13:20.237"}});