post_cb({"31758068": {"ParentId": "31758025", "CommentCount": "2", "Body": "<p>What you are seeing is undefined behavior.</p>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/container/vector/erase\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/container/vector/erase</a> (emphasis mine)</p>\n<blockquote>\n<p id=\"so_31758025_31758068_0\">Removes specified elements from the container.<br>\n  1) Removes the element at pos.<br>\n  2) Removes the elements in the range <code>[first; last)</code>.  </br></br></p>\n<p id=\"so_31758025_31758068_1\"><strong>Invalidates iterators and references at or after the point of the erase</strong>, including the end() iterator. </p>\n</blockquote>\n<p>By using</p>\n<pre><code>a.erase(iter);\ncontinue;\n</code></pre>\n<p>You are accessing an invalid iterator. </p>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "31758068", "Score": "3", "CreationDate": "2015-08-01T03:59:14.587", "LastActivityDate": "2015-08-01T03:59:14.587"}, "31758082": {"ParentId": "31758025", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your code relies on element reduction of your vector to <em>not</em> perform a reserve reduction to eliminate unneeded capacity. To be frank, nearly all standard library implementations I've used do this (reduce the size value and shift the elements to the \"left\"), but it is <em>not</em> guaranteed by the standard to behave this way. Rather, the exact opposite is the case. Once you erase the current iterator position, that iterator and any others past are invalid. Thus your code exhibits <em>undefined behavior</em>. </p>\n<p>Regarding where the standard specifically says your iterator becomes invalid:</p>\n<blockquote>\n<p id=\"so_31758025_31758082_0\">C++11 \u00a7 23.3.6.5 [vector.modifiers]</p>\n<p id=\"so_31758025_31758082_1\">....</p>\n<p id=\"so_31758025_31758082_2\"><code>iterator erase(const_iterator position);</code></p>\n<p id=\"so_31758025_31758082_3\"><code>iterator erase(const_iterator first, const_iterator last);</code></p>\n<ul>\n<li>Effects: <strong>Invalidates iterators and references at or after the point of the erase.</strong></li>\n<li>Complexity: The destructor of T is called the number of times equal to the number of the elements erased, but the move assignment operator of T is called the number of times equal to the number of elements in the vector after the erased elements.</li>\n<li>Throws: Nothing unless an exception is thrown by the copy constructor, move constructor, assignment operator, or move assignment operator of T.</li>\n</ul>\n</blockquote>\n<p>But I'm curious: Why aren't you just using the <a href=\"https://stackoverflow.com/questions/347441/erasing-elements-from-a-vector\">remove/erase idiom</a>?:</p>\n<pre><code>a.erase(std::remove(a.begin(), a.end(), 2), a.end());\n</code></pre>\n", "OwnerUserId": "1322972", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:43:54.217", "Id": "31758082", "Score": "2", "CreationDate": "2015-08-01T04:03:30.953", "LastActivityDate": "2015-08-01T04:42:16.817"}, "bq_ids": {"n4140": {"so_31758025_31758082_3": {"section_id": 819, "quality": 1.0, "length": 5}, "so_31758025_31758068_1": {"section_id": 988, "quality": 0.6666666666666666, "length": 6}}, "n3337": {"so_31758025_31758082_3": {"section_id": 808, "quality": 1.0, "length": 5}, "so_31758025_31758068_1": {"section_id": 973, "quality": 0.6666666666666666, "length": 6}}, "n4659": {"so_31758025_31758082_3": {"section_id": 878, "quality": 1.0, "length": 5}, "so_31758025_31758068_1": {"section_id": 1051, "quality": 0.6666666666666666, "length": 6}, "so_31758025_31758068_0": {"section_id": 823, "quality": 0.6666666666666666, "length": 8}}}, "31758025": {"CommentCount": "4", "ViewCount": "54", "CreationDate": "2015-08-01T03:52:41.040", "LastActivityDate": "2015-08-01T04:42:16.817", "Title": "vector erase works without setting iter return value", "PostTypeId": "1", "Id": "31758025", "Score": "0", "Body": "<p>we all know when use erase in for , we must reset iter, like iter = vector.erase(iter), since erase option will invalidate iteraor. however i found that, not reset also works, the code belows:</p>\n<pre><code>int main() {\n    vector&lt;int&gt; a;\n    a.push_back(1);\n    a.push_back(2);\n    a.push_back(3);\n    a.push_back(2);\n    a.push_back(10);\n    a.push_back(11);\n    for (vector&lt;int&gt;::iterator iter = a.begin(); iter != a.end();) {\n        if (*iter == 2) {\n            // iter = a.erase(iter); the same \n            a.erase(iter);\n            continue;\n        } else {\n            iter++;\n        }\n    }\n    for (vector&lt;int&gt;::iterator iter = a.begin(); iter != a.end(); iter++) {\n        cout &lt;&lt; *iter &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>the code run successfully, with the output: 1 3 10 11.</p>\n<p>so my question is while \"a.erase(iter)\" got the same result with \"iter = a.earse(iter)\" in this code?</p>\n", "Tags": "<c++>", "OwnerUserId": "1872690", "AnswerCount": "2"}});