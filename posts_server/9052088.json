post_cb({"bq_ids": {"n4140": {"so_9052088_9053207_2": {"length": 22, "quality": 0.7586206896551724, "section_id": 7213}, "so_9052088_9053207_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 5937}}, "n3337": {"so_9052088_9053207_2": {"length": 22, "quality": 0.7586206896551724, "section_id": 6957}, "so_9052088_9053207_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 5709}}, "n4659": {"so_9052088_9053207_2": {"length": 22, "quality": 0.7586206896551724, "section_id": 8722}, "so_9052088_9053207_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 7421}}}, "9053207": {"Id": "9053207", "PostTypeId": "2", "Body": "<p>The first thing you have to know is, in C, <strong>integer overflows</strong> are undefined behavior.</p>\n<blockquote>\n<p id=\"so_9052088_9053207_0\">(C99, 6.5.5p5) \"If an exceptional condition occurs during the evaluation of an expression (that is, if the result is not mathematically defined or not in the range of representable values for its type), the behavior is undefined.\"</p>\n</blockquote>\n<p>C says it very clear and repeats it here:</p>\n<blockquote>\n<p id=\"so_9052088_9053207_1\">(C99, 3.4.3p3) \"EXAMPLE An example of undefined behavior is the behavior on integer overflow.\"</p>\n</blockquote>\n<p>Note that integer overflows only regard signed integer as unsigned integer never overflow:</p>\n<blockquote>\n<p id=\"so_9052088_9053207_2\">(C99, 6.2.5p9) \"A computation involving unsigned operands can never overflow, because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting type.\"</p>\n</blockquote>\n<p>Your declaration is this one:</p>\n<pre><code>int i = 400 * 400 / 400;\n</code></pre>\n<p>Assuming <code>int</code> is 16-bit in your platform and the signed representation is two's complement,  <code>400 * 400</code> is equal to <code>160000</code> which is not representable as an <code>int</code>, <code>INT_MAX</code> value being <code>32767</code>. We are in presence of an integer overflow and the implementation can do <strong>whatever</strong> it wants. </p>\n<p>Usually, in this specific example, the compiler will do one of the two solutions below:</p>\n<ol>\n<li>Consider the overflow wraps around modulo the word size like with unsigned integers then the result of the  <code>400 * 400 / 400</code> is <code>72</code>.</li>\n<li>Take advantage of the undefined behavior to reduce the expression <code>400 * 400 / 400</code> to <code>400</code>. This is done by good compilers usually when the optimization options are enabled.</li>\n</ol>\n<p>Note that that integer overflows are undefined behavior is specific to C language. In most languages (Java for instance) they wrap around modulo the word size like unsigned integers in C.</p>\n<p>In <code>gcc</code> to have overflow always wrap, there is the <code>-fno-strict-overflow</code> option that can be enabled (disabled by default). This is for example the choice of the Linux kernel; they compile with this option to avoid bad surprises. But this also constraints the compiler to not perform all optimizations it can do.</p>\n", "LastEditorUserId": "1119701", "LastActivityDate": "2012-01-29T12:59:02.520", "Score": "4", "CreationDate": "2012-01-29T12:37:45.027", "ParentId": "9052088", "CommentCount": "0", "OwnerUserId": "1119701", "LastEditDate": "2012-01-29T12:59:02.520"}, "9052088": {"ViewCount": "2527", "Body": "<p>I think first 400*400=160000 is converted to 28928 by starting from 0 and going 160000 time in a circular fashion for int type (say sizeof(int) = 2 bytes) assuming it like:</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/mdpND.jpg\"> </img></p>\n<p>And then 28928 is divided by 400, floor of which gives 72 and the result varies with the type of variable. Is my assumption correct or there is any other explanation?</p>\n", "AcceptedAnswerId": "9052112", "Title": "Why int i=400*400/400 gives result 72, is datatype circular?", "CreationDate": "2012-01-29T09:08:53.680", "Id": "9052088", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-10-08T05:57:04.187", "LastEditorUserId": "1141537", "LastActivityDate": "2015-10-08T05:57:04.187", "Score": "25", "OwnerUserId": "1141537", "Tags": "<c++><c><types>", "AnswerCount": "3"}, "9052116": {"Id": "9052116", "PostTypeId": "2", "Body": "<p>It certainly seems like you guessed correctly.</p>\n<p>If int is a 16-bit type, then it'll behave exactly as you described.  Your operation happens sequentially and 400 * 400 produces 160000, which is 10 0111 0001 0000 0000</p>\n<p>when you store this in 16-bit register, top \"10\" will get chopped off and you end up with 0111 0001 0000 0000 (28,928).... and you guessed the rest.</p>\n<p>Which compiler/platform are you building this on?  Typical desktop would be at least 32-bit so you wouldn't see this issue.</p>\n<p><strong>UPDATE #1</strong></p>\n<p><strong>NOTE:</strong> This is what explain your behavior with YOUR specific compiler.  As so many others were quick to point out, <strong>DO NOT</strong> take this answer to assume all compilers behave this way. But YOUR specific one certainly does.</p>\n<p>To complete the answer from the comments below, the reason you are seeing this behavior is that most major compilers optimize for speed in these cases and do not add safety checks after simple arithmetic operations.  So as I outlined above, the hardware simply doesn't have room to store those extra bits and that's why you are seeing \"circular\" behavior.</p>\n", "LastEditorUserId": "459146", "LastActivityDate": "2012-01-29T09:50:19.673", "Score": "5", "CreationDate": "2012-01-29T09:14:35.720", "ParentId": "9052088", "CommentCount": "12", "OwnerUserId": "459146", "LastEditDate": "2012-01-29T09:50:19.673"}, "9052112": {"Id": "9052112", "PostTypeId": "2", "Body": "<p>Assuming you're using a horrifically old enough compiler for where <code>int</code> is only 16 bits. Then yes, your analysis is correct.*</p>\n<pre><code>400 * 400 = 160000 \n\n//  Integer overflow wrap-around.\n160000 % 2^16 = 28928\n\n//  Integer Division\n28928 / 400 = 72 (rounded down)\n</code></pre>\n<p>Of course, for larger datatypes, this overflow won't happen so you'll get back <code>400</code>.</p>\n<p>*This wrap-around behavior is guaranteed <strong>only for <em>unsigned</em> integer types</strong>. For signed integers, it is technically <strong>undefined behavior</strong> in C and C++.</p>\n<p>In many cases, signed integers will still exhibit the same wrap-around behavior. <strong>But you just can't count on it.</strong> (So your example with a signed 16-bit integer isn't guaranteed to hold.)</p>\n<hr>\n<p>Although rare, here are some examples of where signed integer overflow does not wrap around as expected:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/7682477/922184\">Why does integer overflow on x86 with GCC cause an infinite loop?</a></li>\n<li><a href=\"https://stackoverflow.com/q/7124058/922184\">Compiler optimization causing program to run slower</a></li>\n</ul>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2012-01-29T11:29:34.800", "Score": "41", "CreationDate": "2012-01-29T09:12:40.883", "ParentId": "9052088", "CommentCount": "11", "OwnerUserId": "922184", "LastEditDate": "2017-05-23T12:34:48.327"}});