post_cb({"24544525": {"CommentCount": "7", "AcceptedAnswerId": "24544722", "PostTypeId": "1", "LastEditorUserId": "2912665", "CreationDate": "2014-07-03T03:38:50.537", "LastActivityDate": "2014-07-03T05:09:58.250", "LastEditDate": "2014-07-03T04:07:46.660", "ViewCount": "90", "FavoriteCount": "2", "Title": "List all the situations when an array is not converted to a pointer to a single element?", "Id": "24544525", "Score": "2", "Body": "<p>So far I have encountered 3 situations where array stays as an array:\n(assume <code>int arr[3][4];</code>)</p>\n<ol>\n<li>sizeof(arr) : gives the total size (not one element's)</li>\n<li>&amp;arr + 1: advances the address by total size </li>\n<li>binding a reference to interior array in range for:</li>\n</ol>\n<p>// </p>\n<pre><code>   for(const auto &amp;row : arr)\n       for(auto col : row)\n           cout &lt;&lt; col &lt;&lt; endl;\n</code></pre>\n<p>Question: \nDoes this exhaust all the situations where array is not converted to a pointer to a single element?\nIf not, is there a systematic way of deciding it?</p>\n", "Tags": "<c++><arrays><pointers>", "OwnerUserId": "3791991", "AnswerCount": "1"}, "24544722": {"ParentId": "24544525", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Most of the cases where this conversion happens are covered by [expr]#8:</p>\n<blockquote>\n<p id=\"so_24544525_24544722_0\">Whenever a glvalue expression appears as an operand of an operator that expects a prvalue for that operand, the lvalue-to-rvalue (4.1), array-to-pointer (4.2), or function-to-pointer (4.3) standard conversions are applied to convert the expression to a prvalue.</p>\n</blockquote>\n<p>All of the operators which can take <code>arr</code> expect a prvalue (or otherwise explicitly request this conversion), except for:</p>\n<ul>\n<li>unary <code>&amp;</code></li>\n<li><code>sizeof</code></li>\n<li><code>++</code></li>\n<li><code>--</code></li>\n<li><code>alignof</code></li>\n<li><code>typeid</code></li>\n</ul>\n<p>(Note: this list might not be exhaustive, I will update it if someone points out other cases!)</p>\n<p>Now, There are various possible cases where we can use <code>arr</code> and it is not the operand of any operator. Some of those cases perform the conversion and some don't. The ones that do perform the conversion are:</p>\n<ul>\n<li>using <code>arr</code> as a function argument but not matching a prototype parameter</li>\n<li>some cases of template type deduction</li>\n<li>deducing the return type of a lambda</li>\n</ul>\n<p>Notably, the conversion is not performed by binding <code>arr</code> to a reference (this is what happens in the range-based for-loop).  This is covered by [dcl.init.ref]#5.   In the line <code>T &amp;ref = arr;</code>, the <code>=</code> is not the assignment operator; it's part of the syntax for declarations.</p>\n", "OwnerUserId": "1505939", "LastEditorUserId": "1505939", "LastEditDate": "2014-07-03T05:09:58.250", "Id": "24544722", "Score": "6", "CreationDate": "2014-07-03T04:04:34.667", "LastActivityDate": "2014-07-03T05:09:58.250"}, "bq_ids": {"n4140": {"so_24544525_24544722_0": {"section_id": 5942, "quality": 1.0, "length": 17}}, "n3337": {"so_24544525_24544722_0": {"section_id": 5713, "quality": 1.0, "length": 17}}, "n4659": {"so_24544525_24544722_0": {"section_id": 7426, "quality": 1.0, "length": 17}}}});