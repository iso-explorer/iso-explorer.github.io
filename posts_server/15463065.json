post_cb({"bq_ids": {"n4140": {"so_15463065_15544004_0": {"length": 20, "quality": 0.7407407407407407, "section_id": 5873}}, "n3337": {"so_15463065_15544004_0": {"length": 20, "quality": 0.7407407407407407, "section_id": 5644}}, "n4659": {"so_15463065_15544004_0": {"length": 20, "quality": 0.7407407407407407, "section_id": 7356}}}, "15463065": {"ViewCount": "156", "Body": "<p>Many questions talks about POD; But all questions talks about full object copy. Can I apply the same concept on the plain old data part of a class. Example: </p>\n<pre class=\"lang-c++ prettyprint-override\"><code>struct Parent1\n{\n    int x;\n    float y;\n};\n\nstruct Parent2\n{\n    int k;\n    float l;\n};\n\nstruct NotPod : public Parent1, public Parent2\n{\n    char z;\n    short w;\n};\n\nNotPod a, b;\n\nvoid func()\n{\n    a.z = '4';\n    a.w = 345;\n    memcpy((char*)&amp;b.z, (char*)&amp;a.z, (char*)(&amp;a.w)-(&amp;a.z) + sizeof(a.w));\n}\n</code></pre>\n<p>I am asking about old c++ (not C++11).</p>\n", "AcceptedAnswerId": "15544004", "Title": "Partial plain old data", "CreationDate": "2013-03-17T16:17:13.730", "Id": "15463065", "CommentCount": "7", "LastEditDate": "2013-03-20T16:07:45.570", "PostTypeId": "1", "LastEditorUserId": "231388", "LastActivityDate": "2013-03-21T13:39:33.377", "Score": "1", "OwnerUserId": "231388", "Tags": "<c++><pod>", "AnswerCount": "3"}, "15544004": {"Id": "15544004", "PostTypeId": "2", "Body": "<p>As I understand from your sample code, your question isn't about PODs. What you need is a guarantee that members of your most derived class are aggregates and they have continuous memory layout. </p>\n<p>See 9.2.12 (ISO 14882:2003) </p>\n<blockquote>\n<p id=\"so_15463065_15544004_0\">Nonstatic data members of a (non-union) class declared without an intervening access-specifier are allocated\n  so that later members have higher addresses within a class object. The order of allocation of nonstatic\n  data members separated by an access-specifier is unspecified (11.1).</p>\n</blockquote>\n<p>Simply speaking, don't put <code>public</code>/<code>protected</code>/<code>private</code> access specifiers in between of your sequence of aggregates and you'll get such a guarantee.</p>\n", "LastEditorUserId": "1254352", "LastActivityDate": "2013-03-21T13:39:33.377", "Score": "2", "CreationDate": "2013-03-21T09:45:35.627", "ParentId": "15463065", "CommentCount": "0", "OwnerUserId": "2160347", "LastEditDate": "2013-03-21T13:39:33.377"}, "15467637": {"Id": "15467637", "PostTypeId": "2", "Body": "<p>So you only want to copy the members of the Parent part in the struct. \nIf yes, why not implementing like in func3()?</p>\n<pre><code>void func2()\n{\n    a.z = '7';\n    a.w = 444;\n    a.x = 4;\n    a.y = 2.1;\n    memcpy(&amp;b, &amp;a, sizeof(NotPod)); // copies all the members\n}\n\nvoid func3()\n{  \n    a.z = '7';\n    a.w = 444;\n    a.x = 4;\n    a.y = 2.1;\n    memcpy(&amp;b, &amp;a, sizeof(Parent)); // copies only the members of the Parent\n}\n</code></pre>\n", "LastActivityDate": "2013-03-17T23:37:58.457", "CommentCount": "1", "CreationDate": "2013-03-17T23:37:58.457", "ParentId": "15463065", "Score": "0", "OwnerUserId": "1468898"}, "15542773": {"Id": "15542773", "PostTypeId": "2", "Body": "<p>As you said yourself its not a POD in C++03. Parts of it are (Parent1 and Parent2), but you want to treat the rest as a POD. Well, just make the rest a POD. Either by defining a local struct </p>\n<pre><code>struct NotPod : public Parent1, public Parent2\n{\n    struct InternalPod\n    {\n       char z;\n       short w;\n    };\n    InternalPod i; \n};\n</code></pre>\n<p>or by inheriting from a third struct:</p>\n<pre><code>struct InternalPod\n{\n   char z;\n   short w;\n};\n\nstruct NotPod : public Parent1, public Parent2, public InternalPod\n{\n};\n</code></pre>\n", "LastActivityDate": "2013-03-21T08:42:37.833", "CommentCount": "2", "CreationDate": "2013-03-21T08:42:37.833", "ParentId": "15463065", "Score": "0", "OwnerUserId": "2173029"}});