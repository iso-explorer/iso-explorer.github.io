post_cb({"43455191": {"ParentId": "43455035", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The line</p>\n<pre><code>Test test1;\n</code></pre>\n<p>is equivalent to an initialization with a default constructor which, in the absence of a hand-written one with an explicit initialization list and with no <code>Test() = deleted;</code> would end up setting the two members to their specified initial values <code>1</code> and <code>2</code>.</p>\n<p>A \u201cdefault constructor\u201d is a constructor that can be called with no arguments, which is exactly the case with the above statement.</p>\n<p>You can read up on the rules for default constructors in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf\" rel=\"noreferrer\">standard</a> - go to \u00a7 12.1 section 4:</p>\n<blockquote>\n<p id=\"so_43455035_43455191_0\">A default constructor for a class X is a constructor of class X that can be called without an argument...</p>\n</blockquote>\n<p>And further in section 5:</p>\n<blockquote>\n<p id=\"so_43455035_43455191_1\">A default constructor that is defaulted and not defined as deleted is implicitly defined when it is odrused (3.2) to create an object of its class type (1.8)...</p>\n</blockquote>\n", "OwnerUserId": "1482455", "LastEditorUserId": "1482455", "LastEditDate": "2017-04-17T16:23:27.090", "Id": "43455191", "Score": "7", "CreationDate": "2017-04-17T16:16:16.303", "LastActivityDate": "2017-04-17T16:23:27.090"}, "43455035": {"CommentCount": "4", "ViewCount": "255", "PostTypeId": "1", "LastEditorUserId": "3980929", "CreationDate": "2017-04-17T16:05:53.903", "LastActivityDate": "2017-04-17T16:38:41.047", "Title": "POD members default initialization without braces", "FavoriteCount": "0", "LastEditDate": "2017-04-17T16:10:35.430", "Id": "43455035", "Score": "6", "Body": "<p>Given code:</p>\n<pre><code>struct Test {\n    int a = 1;\n    int b = 2;\n};\n\nTest test1;\nTest test2{};\n</code></pre>\n<p>For <code>test2</code> I am sure, that <code>test2.a == 1</code> and <code>test2.b == 2</code>. Is it guaranteed (or not) the same for <code>test1</code> (without <code>{}</code>)?</p>\n", "Tags": "<c++><c++14><brace-initialization>", "OwnerUserId": "1555823", "AnswerCount": "3"}, "43455071": {"ParentId": "43455035", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><code>test1</code> is also guaranteed to have its member <code>a</code> initialized to <code>1</code> and its member <code>b</code> to be initialized to <code>2</code>.</p>\n<p>From <a href=\"http://www.stroustrup.com/C++11FAQ.html#member-init\" rel=\"nofollow noreferrer\">C++11 FAQ, In-class member initializers</a>:</p>\n<blockquote>\n<p id=\"so_43455035_43455071_0\">The basic idea for C++11 is to allow a non-static data member to be initialized where it is declared (in its class). A constructor can then use the initializer when run-time initialization is needed. Consider:</p>\n<pre><code>class A {\n  public:\n    int a = 7;\n};\n</code></pre>\n<p id=\"so_43455035_43455071_1\">This is equivalent to:</p>\n<pre><code>class A {\n  public:\n    int a;\n    A() : a(7) {}\n};\n</code></pre>\n</blockquote>\n", "OwnerUserId": "434551", "LastEditorUserId": "434551", "LastEditDate": "2017-04-17T16:16:17.993", "Id": "43455071", "Score": "4", "CreationDate": "2017-04-17T16:07:48.187", "LastActivityDate": "2017-04-17T16:16:17.993"}, "bq_ids": {"n4140": {"so_43455035_43455191_0": {"section_id": 369, "quality": 0.875, "length": 7}, "so_43455035_43455191_1": {"section_id": 370, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_43455035_43455191_0": {"section_id": 359, "quality": 0.875, "length": 7}, "so_43455035_43455191_1": {"section_id": 360, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_43455035_43455191_0": {"section_id": 4058, "quality": 0.75, "length": 6}, "so_43455035_43455191_1": {"section_id": 384, "quality": 0.9285714285714286, "length": 13}, "so_43455035_43455270_0": {"section_id": 4058, "quality": 0.5454545454545454, "length": 12}}}, "43455270": {"ParentId": "43455035", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Yes, they have the same effect here.</p>\n<p>For the 1st case, it's <a href=\"http://en.cppreference.com/w/cpp/language/default_initialization\" rel=\"nofollow noreferrer\">default initialization</a>, </p>\n<blockquote>\n<p id=\"so_43455035_43455270_0\">if T is a class type, the constructors are considered and subjected to overload resolution against the empty argument list. The constructor selected (which is one of the default constructors) is called to provide the initial value for the new object;</p>\n</blockquote>\n<p>That means the implicitly-defined default constructor will be invoked; it doesn't use any member initializer list and then <a href=\"http://en.cppreference.com/w/cpp/language/data_members#Member_initialization\" rel=\"nofollow noreferrer\">default member initializer</a> would take effect to initialize the data members.</p>\n<p>For the 2nd case, it's <a href=\"http://en.cppreference.com/w/cpp/language/aggregate_initialization\" rel=\"nofollow noreferrer\">aggregate initialization</a>,</p>\n<blockquote>\n<p id=\"so_43455035_43455270_1\">If the number of initializer clauses is less than the number of members <code>and bases (since C++17)</code> or initializer list is completely empty, the remaining members <code>and bases (since C++17)</code> are initialized <code>by their default initializers, if provided in the class definition, and otherwise (since C++14)</code> ...</p>\n</blockquote>\n<p>So the default member initializer would take effect to initialize the data members, too.</p>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2017-04-17T16:38:41.047", "Id": "43455270", "Score": "6", "CreationDate": "2017-04-17T16:21:28.087", "LastActivityDate": "2017-04-17T16:38:41.047"}});