post_cb({"46725795": {"Id": "46725795", "PostTypeId": "2", "Body": "<p><strong>C++14 draft N4140 5.1.2.12 [expr.prim.lambda] :</strong></p>\n<blockquote>\n<p id=\"so_46724260_46725795_0\"><strong>A lambda-expression with an associated capture-default that does not\n  explicitly capture this or a variable with automatic storage duration\n  (this excludes any id-expression that has been found to refer to an\n  init-capture\u2019s associated non-static data member), is said to\n  implicitly capture the entity</strong> (i.e., this or a variable) if the\n  compound-statement:</p>\n<p id=\"so_46724260_46725795_1\"><strong>odr-uses (3.2) the entity</strong>, or</p>\n<p id=\"so_46724260_46725795_2\">names the entity in a potentially-evaluated expression (3.2) where the\n  enclosing full-expression depends on a generic lambda parameter\n  declared within the reaching scope of the lambda-expression.</p>\n</blockquote>\n<p>Also, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1826\" rel=\"noreferrer\">.open-std.org</a> : </p>\n<blockquote>\n<p id=\"so_46724260_46725795_3\">A const integer initialized with a constant can be used in constant\n  expressions, but a const floating point variable initialized with a\n  constant cannot. This was intentional, to be compatible with C++03\n  while encouraging the consistent use of constexpr. Some people have\n  found this distinction to be surprising, however.</p>\n<p id=\"so_46724260_46725795_4\"><strong>It was also observed that allowing const floating point variables as\n  constant expressions would be an ABI-breaking change, since it would\n  affect lambda capture.</strong></p>\n</blockquote>\n", "LastEditorUserId": "6935629", "LastActivityDate": "2017-10-13T08:53:03.587", "Score": "9", "CreationDate": "2017-10-13T08:37:28.963", "ParentId": "46724260", "CommentCount": "0", "OwnerUserId": "6935629", "LastEditDate": "2017-10-13T08:53:03.587"}, "bq_ids": {"n4140": {"so_46724260_46725055_5": {"length": 14, "quality": 1.0, "section_id": 6185}, "so_46724260_46725795_0": {"length": 26, "quality": 1.0, "section_id": 5971}, "so_46724260_46725055_3": {"length": 10, "quality": 1.0, "section_id": 6185}, "so_46724260_46725795_2": {"length": 16, "quality": 1.0, "section_id": 5971}, "so_46724260_46725055_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 5971}, "so_46724260_46725055_0": {"length": 16, "quality": 1.0, "section_id": 5971}}, "n3337": {"so_46724260_46725055_5": {"length": 13, "quality": 0.9285714285714286, "section_id": 5946}, "so_46724260_46725055_0": {"length": 9, "quality": 0.5625, "section_id": 5739}, "so_46724260_46725055_3": {"length": 7, "quality": 0.7, "section_id": 5946}}, "n4659": {"so_46724260_46725795_2": {"length": 16, "quality": 1.0, "section_id": 7470}, "so_46724260_46725795_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 7470}, "so_46724260_46725055_3": {"length": 7, "quality": 0.7, "section_id": 7687}, "so_46724260_46725055_5": {"length": 14, "quality": 1.0, "section_id": 7687}, "so_46724260_46725055_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 7470}, "so_46724260_46725055_0": {"length": 14, "quality": 0.875, "section_id": 7470}}}, "46724260": {"ViewCount": "1484", "Body": "<p>This compiles:</p>\n<pre><code>int main() {\n    const int x = 123;\n    auto g = []() { std::cout &lt;&lt; x &lt;&lt; \"\\n\"; };\n    g();\n}\n</code></pre>\n<p>But this:</p>\n<pre><code>int main(){\n    const float x = 123;\n    auto g = []() { std::cout &lt;&lt; x &lt;&lt; \"\\n\"; };\n    g();\n}\n</code></pre>\n<p>produces:</p>\n<blockquote>\n<p id=\"so_46724260_46724260_0\">\"error: 'x' is not captured\"</p>\n</blockquote>\n<p>Why?</p>\n<p>I've tested it on both GCC (various versions from 5.0.0 to 8.0.0) and Clang (various versions from 4.0.0 to 6.0.0). It behaves the same in all cases. </p>\n", "AcceptedAnswerId": "46725055", "Title": "Why are const ints (or shorts) captured implicitly in lambdas?", "CreationDate": "2017-10-13T07:03:24.443", "Id": "46724260", "CommentCount": "7", "FavoriteCount": "9", "PostTypeId": "1", "LastEditDate": "2017-10-16T09:21:57.890", "LastEditorUserId": "2411320", "LastActivityDate": "2017-11-28T09:03:01.013", "ClosedDate": "2017-11-28T09:34:49.460", "Score": "44", "OwnerUserId": "1601719", "Tags": "<c++><lambda><scope><language-lawyer><one-definition-rule>", "AnswerCount": "2"}, "46725055": {"Id": "46725055", "PostTypeId": "2", "Body": "<p>Lambda's scope can implicitly capture variables within its reaching scope.</p>\n<p>Your variables are in the reaching scope, since they are local to the (main) function that defines the lambda.</p>\n<p>However, there are certain criteria in which variables can be captured via this mechanism, as mentioned in <a href=\"https://timsong-cpp.github.io/cppwp/n4140/expr.prim#lambda-12\" rel=\"noreferrer\">[expr.prim.lambda]/12</a>:</p>\n<blockquote>\n<p id=\"so_46724260_46725055_0\">A lambda-expression with an associated capture-default that does not\n  explicitly capture this or a variable <em>with automatic storage</em> duration\n  [..], is said to\n  <strong>implicitly capture the entity</strong> (i.e., this or a <strong>variable</strong>) if the\n  compound-statement:</p>\n<p id=\"so_46724260_46725055_1\">-odr-uses ([basic.def.odr]) the entity, or</p>\n<p id=\"so_46724260_46725055_2\">-<em>names the entity</em> in a potentially-evaluated expression ([basic.def.odr]) where the enclosing full-expression depends on a\n  generic <strong>lambda parameter declared within the reaching scope of the\n  lambda-expression</strong>.</p>\n</blockquote>\n<p>The most important part is in <a href=\"https://timsong-cpp.github.io/cppwp/n4140/expr.const#2.7\" rel=\"noreferrer\">[expr.const]/2.7</a>:</p>\n<blockquote>\n<p id=\"so_46724260_46725055_3\">A conditional-expression <code>e</code> is a <strong>core constant expression</strong> unless the\n  evaluation of <code>e</code>, [..] would evaluate one of the following expressions:</p>\n<p id=\"so_46724260_46725055_4\">an lvalue-to-rvalue conversion ([conv.lval]) unless it is applied to:</p>\n<p id=\"so_46724260_46725055_5\">a non-volatile glvalue of <strong>integral</strong> or enumeration <strong>type</strong> that refers to a non-volatile const object with a preceding initialization,\n  initialized with a constant expression.</p>\n</blockquote>\n<p>So <code>const int</code> is a <em>core constant expression</em> while <code>const float</code> is not.</p>\n<p>Moreover <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1826\" rel=\"noreferrer\">[expr.const]1826</a> mentions:</p>\n<blockquote>\n<p id=\"so_46724260_46725055_6\">A const integer initialized with a constant can be used in constant expressions, <em>but a const floating point variable initialized with a constant cannot</em>.</p>\n</blockquote>\n<p>Read more in <a href=\"https://stackoverflow.com/questions/43467095/why-is-a-const-variable-sometimes-not-required-to-be-captured-in-a-lambda\">Why is a const variable sometimes not required to be captured in a lambda?</a></p>\n", "LastEditorUserId": "2411320", "LastActivityDate": "2017-10-13T09:33:25.147", "Score": "37", "CreationDate": "2017-10-13T07:50:05.163", "ParentId": "46724260", "CommentCount": "10", "OwnerUserId": "2411320", "LastEditDate": "2017-10-13T09:33:25.147"}});