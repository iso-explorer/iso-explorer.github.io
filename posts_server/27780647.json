post_cb({"27780739": {"Id": "27780739", "PostTypeId": "2", "Body": "<p>The synopsis is (\u00a730.4 [thread.mutex])</p>\n<pre><code>struct once_flag {\n    constexpr once_flag() noexcept;\n    once_flag(const once_flag&amp;) = delete;\n    once_flag&amp; operator=(const once_flag&amp;) = delete;\n};\n</code></pre>\n<p>Since the copy constructor and copy assignment operator are user-declared (and explicitly deleted), the move constructor and move assignment operator are not implicitly declared (\u00a712.8 [class.copy]/p9, 20):</p>\n<blockquote>\n<p id=\"so_27780647_27780739_0\">9 If the definition of a class <code>X</code> does not explicitly declare a move\n  constructor, one will be implicitly declared as defaulted if and only\n  if</p>\n<ul>\n<li><code>X</code> does not have a user-declared copy constructor,</li>\n<li><code>X</code> does not have a user-declared copy assignment operator,</li>\n<li><code>X</code> does not have a user-declared move assignment operator, and</li>\n<li><code>X</code> does not have a user-declared destructor.</li>\n</ul>\n<p id=\"so_27780647_27780739_1\">20 If the definition of a class <code>X</code> does not explicitly declare a move\n  assignment operator, one will be implicitly declared as defaulted if\n  and only if</p>\n<ul>\n<li><code>X</code> does not have a user-declared copy constructor,</li>\n<li><code>X</code> does not have a user-declared move constructor,</li>\n<li><code>X</code> does not have a user-declared copy assignment operator, and</li>\n<li><code>X</code> does not have a user-declared destructor.</li>\n</ul>\n</blockquote>\n<p>Hence, <code>once_flag</code> cannot be moved.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2015-01-05T13:45:24.560", "Score": "4", "CreationDate": "2015-01-05T13:39:05.510", "ParentId": "27780647", "CommentCount": "2", "OwnerUserId": "2756719", "LastEditDate": "2015-01-05T13:45:24.560"}, "bq_ids": {"n4140": {"so_27780647_27780739_0": {"length": 12, "quality": 1.0, "section_id": 458}, "so_27780647_27780739_1": {"length": 13, "quality": 1.0, "section_id": 469}}, "n3337": {"so_27780647_27780739_0": {"length": 12, "quality": 1.0, "section_id": 449}, "so_27780647_27780739_1": {"length": 13, "quality": 1.0, "section_id": 460}}, "n4659": {"so_27780647_27780739_0": {"length": 12, "quality": 1.0, "section_id": 481}, "so_27780647_27780739_1": {"length": 13, "quality": 1.0, "section_id": 492}}}, "27780647": {"ViewCount": "119", "Body": "<p>How does it come, the standard says nothing about the movable'ity of once_flag? I would expect the same arguments to apply as for std::mutex. At least for gcc (version 4.8) moving seems to be disabled. If a certain compiler would allow moving, one could end up with non-portable code.</p>\n", "AcceptedAnswerId": "27780739", "Title": "Could once_flag be movable?", "CreationDate": "2015-01-05T13:33:06.847", "Id": "27780647", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-01-05T13:45:24.560", "Score": "2", "OwnerUserId": "3876684", "Tags": "<c++><c++11>", "AnswerCount": "1"}});