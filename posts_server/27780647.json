post_cb({"27780739": {"ParentId": "27780647", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The synopsis is (\u00a730.4 [thread.mutex])</p>\n<pre><code>struct once_flag {\n    constexpr once_flag() noexcept;\n    once_flag(const once_flag&amp;) = delete;\n    once_flag&amp; operator=(const once_flag&amp;) = delete;\n};\n</code></pre>\n<p>Since the copy constructor and copy assignment operator are user-declared (and explicitly deleted), the move constructor and move assignment operator are not implicitly declared (\u00a712.8 [class.copy]/p9, 20):</p>\n<blockquote>\n<p id=\"so_27780647_27780739_0\">9 If the definition of a class <code>X</code> does not explicitly declare a move\n  constructor, one will be implicitly declared as defaulted if and only\n  if</p>\n<ul>\n<li><code>X</code> does not have a user-declared copy constructor,</li>\n<li><code>X</code> does not have a user-declared copy assignment operator,</li>\n<li><code>X</code> does not have a user-declared move assignment operator, and</li>\n<li><code>X</code> does not have a user-declared destructor.</li>\n</ul>\n<p id=\"so_27780647_27780739_1\">20 If the definition of a class <code>X</code> does not explicitly declare a move\n  assignment operator, one will be implicitly declared as defaulted if\n  and only if</p>\n<ul>\n<li><code>X</code> does not have a user-declared copy constructor,</li>\n<li><code>X</code> does not have a user-declared move constructor,</li>\n<li><code>X</code> does not have a user-declared copy assignment operator, and</li>\n<li><code>X</code> does not have a user-declared destructor.</li>\n</ul>\n</blockquote>\n<p>Hence, <code>once_flag</code> cannot be moved.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2015-01-05T13:45:24.560", "Id": "27780739", "Score": "4", "CreationDate": "2015-01-05T13:39:05.510", "LastActivityDate": "2015-01-05T13:45:24.560"}, "bq_ids": {"n4140": {"so_27780647_27780739_1": {"section_id": 469, "quality": 1.0, "length": 13}, "so_27780647_27780739_0": {"section_id": 458, "quality": 1.0, "length": 12}}, "n3337": {"so_27780647_27780739_1": {"section_id": 460, "quality": 1.0, "length": 13}, "so_27780647_27780739_0": {"section_id": 449, "quality": 1.0, "length": 12}}, "n4659": {"so_27780647_27780739_1": {"section_id": 492, "quality": 1.0, "length": 13}, "so_27780647_27780739_0": {"section_id": 481, "quality": 1.0, "length": 12}}}, "27780647": {"CommentCount": "0", "ViewCount": "119", "CreationDate": "2015-01-05T13:33:06.847", "LastActivityDate": "2015-01-05T13:45:24.560", "Title": "Could once_flag be movable?", "AcceptedAnswerId": "27780739", "PostTypeId": "1", "Id": "27780647", "Score": "2", "Body": "<p>How does it come, the standard says nothing about the movable'ity of once_flag? I would expect the same arguments to apply as for std::mutex. At least for gcc (version 4.8) moving seems to be disabled. If a certain compiler would allow moving, one could end up with non-portable code.</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "3876684", "AnswerCount": "1"}});