post_cb({"4557009": {"CommentCount": "8", "ViewCount": "5483", "CreationDate": "2010-12-29T19:08:04.553", "LastActivityDate": "2016-02-22T15:52:19.040", "Title": "Vector vs string", "FavoriteCount": "2", "PostTypeId": "1", "Id": "4557009", "Score": "13", "Body": "<p>What is the fundamental difference, if any, between a C++ std::vector and std::basic_string?</p>\n", "Tags": "<c++><string><vector>", "OwnerUserId": "518287", "AnswerCount": "7"}, "bq_ids": {"n4140": {"so_4557009_4557156_0": {"section_id": 1566, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_4557009_4557156_0": {"section_id": 1561, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_4557009_4557156_0": {"section_id": 1708, "quality": 0.5714285714285714, "length": 4}}}, "4557062": {"ParentId": "4557009", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>The key difference is that <code>std::vector</code> should keep its data in continuous memory, when <code>std::basic_string</code> could not to. As a result:</p>\n<pre><code>std::vector&lt;char&gt; v( 'a', 3 );\nchar* x = &amp;v[0]; // valid\n\nstd::basic_string&lt;char&gt; s( \"aaa\" );\nchar* x2 = &amp;s[0];     // doesn't point to continuous buffer\n//For example, the behavior of \nstd::cout &lt;&lt; *(x2+1);\n//is undefined.\nconst char* x3 = s.c_str(); // valid\n</code></pre>\n<p><a href=\"http://herbsutter.com/2008/04/07/cringe-not-vectors-are-guaranteed-to-be-contiguous/#comment-483\" rel=\"nofollow\">On practice this difference is not so important.</a></p>\n", "OwnerUserId": "123111", "LastEditorUserId": "123111", "LastEditDate": "2010-12-30T05:34:54.760", "Id": "4557062", "Score": "5", "CreationDate": "2010-12-29T19:14:11.507", "LastActivityDate": "2010-12-30T05:34:54.760"}, "4557028": {"ParentId": "4557009", "CommentCount": "3", "Body": "<p>The basic_string provides many string-specific comparison options. You are right in that the underlying memory management interface is very similar, but string contains many additional members, like c_str(), that would make no sense for a vector.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "4557028", "Score": "0", "CreationDate": "2010-12-29T19:10:22.120", "LastActivityDate": "2010-12-29T19:10:22.120"}, "4557026": {"ParentId": "4557009", "CommentCount": "6", "Body": "<p>A vector is a data structure which simulates an array. Deep inside it is actually a (dynamic) Array.</p>\n<p>The basic_string class represents a Sequence of characters. It contains all the usual operations of a Sequence, and, additionally, it contains standard string operations such as search and concatenation. </p>\n<p>You can use vector to keep whatever data type you want <code>std::vector&lt;int&gt; or &lt;float&gt; or even std::vector&lt; std::vector&lt;T&gt; &gt;</code> but a <code>basic_string</code> can only be used for representing \"text\".</p>\n", "OwnerUserId": "418748", "PostTypeId": "2", "Id": "4557026", "Score": "0", "CreationDate": "2010-12-29T19:10:12.700", "LastActivityDate": "2010-12-29T19:10:12.700"}, "4557156": {"ParentId": "4557009", "PostTypeId": "2", "CommentCount": "6", "Body": "<ul>\n<li><p>basic_string doesn't call constructors and destructors of its elements. vector does.</p></li>\n<li><p>swapping basic_string invalidates iterators (enabling small string optimization), swapping vectors doesn't.</p></li>\n<li><p>basic_string memory may not be allocated continuously in C++03. vector is always continuous. This difference is removed in C++0x [string.require]:</p>\n<blockquote>\n<p id=\"so_4557009_4557156_0\">The char-like objects in a basic_string object shall be stored contiguously</p>\n</blockquote></li>\n<li><p>basic_string has interface for string operations. vector doesn't.</p></li>\n<li><p>basic_string may use copy on write strategy (in pre C++11). vector can't.</p></li>\n</ul>\n<p>Relevant quotes for non-believers:</p>\n<p>[basic.string]:</p>\n<blockquote>\n<p id=\"so_4557009_4557156_1\">The class template basic_string conforms to the requirements for a Sequence Container (23.2.3), for a\n  Reversible Container (23.2), and for an Allocator-aware container (Table 99), except that basic_string\n  does not construct or destroy its elements using allocator_traits::construct and allocator_-\n  traits::destroy and that swap() for basic_string invalidates iterators. The iterators supported\n  by basic_string are random access iterators (24.2.7).</p>\n</blockquote>\n", "OwnerUserId": "277176", "LastEditorUserId": "277176", "LastEditDate": "2012-09-24T21:43:32.470", "Id": "4557156", "Score": "15", "CreationDate": "2010-12-29T19:26:06.750", "LastActivityDate": "2012-09-24T21:43:32.470"}, "4557081": {"ParentId": "4557009", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><code>basic_string</code> gives compiler and standard library implementations, a few freedoms over vector:</p>\n<ol>\n<li><p>The \"small string optimization\" is valid on strings, which allows implementations to store the actual string, rather than a pointer to the string, in the string object when the string is short. Something along the lines of:</p>\n<pre><code>class string\n{\n    size_t length;\n    union\n    {\n        char * usedWhenStringIsLong;\n        char usedWhenStringIsShort[sizeof(char*)];\n    };\n};\n</code></pre></li>\n<li><p>In C++03, the underlying array need not be contiguous. Implementing <code>basic_string</code> in terms of something like a \"rope\" would be possible under the current standard. (Though nobody does this because that would make the members <code>std::basic_string::c_str()</code> and <code>std::basic_string::data()</code> too expensive to implement.)<br>\nC++11 now bans this behavior though.</br></p></li>\n<li><p>In C++03, <code>basic_string</code> allows the compiler/library vendor to use copy-on-write for the data (which can save on copies), which is not allowed for <code>std::vector</code>. In practice, this used to be a lot more common, but it's less common nowadays because of the impact it has upon multithreading. Either way though, your code cannot rely on whether or not <code>std::basic_string</code> is implemented using COW.<br>\nC++11 again now bans this behavior.</br></p></li>\n</ol>\n<p>There are a few helper methods tacked on to <code>basic_string</code> as well, but most are simple and of course could easily be implemented on top of <code>vector</code>.</p>\n", "OwnerUserId": "82320", "LastEditorUserId": "82320", "LastEditDate": "2014-09-24T23:46:04.167", "Id": "4557081", "Score": "11", "CreationDate": "2010-12-29T19:15:42.760", "LastActivityDate": "2014-09-24T23:46:04.167"}, "35558008": {"ParentId": "4557009", "PostTypeId": "2", "CommentCount": "0", "Body": "<h1>TLDR: <code>string</code>s are optimized to only contain character primitives, <code>vector</code>s can contain primitives <em>or</em> objects</h1>\n<p>The preeminent difference between <code>vector</code> and <code>string</code> is that <code>vector</code> can correctly contain objects, <code>string</code> works only on primitives. So <code>vector</code> provides these methods that would be useless for a <code>string</code> working with primitives:</p>\n<ol>\n<li><a href=\"http://en.cppreference.com/w/cpp/container/vector/emplace\" rel=\"nofollow noreferrer\">vector::emplace</a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/container/vector/emplace_back\" rel=\"nofollow noreferrer\">vector::emplace_back</a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/container/vector/~vector\" rel=\"nofollow noreferrer\">vector::~vector</a></li>\n</ol>\n<p>Even extending <code>string</code> will not allow it to correctly handle objects, because it lacks a destructor. This should not be viewed as a drawback, it allows significant optimization over <code>vector</code> in that <code>string</code> can:</p>\n<ol>\n<li>Do <a href=\"https://stackoverflow.com/questions/10315041/meaning-of-acronym-sso-in-the-context-of-stdstring?lq=1\">short string optimization</a>, potentially avoiding heap allocation, with <a href=\"https://stackoverflow.com/a/28003328/2642059\">little</a> to <a href=\"https://stackoverflow.com/q/21694302/2642059\">no increased storage overhead</a></li>\n<li>Use <code>char_traits</code>, one of <code>string</code>'s template arguments, to define how operations should be implemented on the contained primitives (of which only <code>char</code>, <code>wchar_t</code>, <code>char16_t</code>, and <code>char32_t</code> are implemented: <a href=\"http://en.cppreference.com/w/cpp/string/char_traits\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/string/char_traits</a>)</li>\n</ol>\n<p>Particularly relevant are <a href=\"http://en.cppreference.com/w/cpp/string/char_traits/copy\" rel=\"nofollow noreferrer\"><code>char_traits::copy</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/char_traits/move\" rel=\"nofollow noreferrer\"><code>char_traits::move</code></a>, and <a href=\"http://en.cppreference.com/w/cpp/string/char_traits/assign\" rel=\"nofollow noreferrer\"><code>char_traits::assign</code></a> obviously implying that direct assignment, rather than construction or destruction will be used which is again, preferable for primitives. All this specialization has the additional drawbacks to <code>string</code> that:</p>\n<ol>\n<li>Only <code>char</code>, <code>wchar_t</code>, <code>char16_t</code>, or <code>char32_t</code> primitives types will be used. Obviously, primitives of sizes up to 32-bit, <em>could</em> use their equivalently sized <code>char_type</code>: <a href=\"https://stackoverflow.com/a/35555016/2642059\">https://stackoverflow.com/a/35555016/2642059</a>, but for primitives such as <code>long long</code> a new specialization of <code>char_traits</code> would need to be written, and the idea of specializing <a href=\"http://en.cppreference.com/w/cpp/string/char_traits/eof\" rel=\"nofollow noreferrer\"><code>char_traits::eof</code></a> and <a href=\"http://en.cppreference.com/w/cpp/string/char_traits/not_eof\" rel=\"nofollow noreferrer\"><code>char_traits::not_eof</code></a> instead of just using <code>vector&lt;long long&gt;</code> doesn't seem like the best use of time.</li>\n<li>Because of short string optimization, iterators are invalidated by all the operations that would invalidate a <code>vector</code> iterator, but <code>string</code> iterators are additionally invalidated by <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/swap\" rel=\"nofollow noreferrer\"><code>string::swap</code></a> and <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/operator%3D\" rel=\"nofollow noreferrer\"><code>string::operator=</code></a></li>\n</ol>\n<p>Additional differences in the interfaces of <code>vector</code> and <code>string</code>:</p>\n<ol>\n<li>There is no mutable <code>string::data</code>: <a href=\"https://stackoverflow.com/q/34155390/2642059\">Why Doesn't std::string.data() provide a mutable char*?</a></li>\n<li><code>string</code> provides functionality for working with words unavailable in <code>vector</code>: <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/c_str\" rel=\"nofollow noreferrer\"><code>string::c_str</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/size\" rel=\"nofollow noreferrer\"><code>string::length</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/append\" rel=\"nofollow noreferrer\"><code>string::append</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/operator%2B%3D\" rel=\"nofollow noreferrer\"><code>string::operator+=</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/compare\" rel=\"nofollow noreferrer\"><code>string::compare</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/replace\" rel=\"nofollow noreferrer\"><code>string::replace</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/substr\" rel=\"nofollow noreferrer\"><code>string::substr</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/copy\" rel=\"nofollow noreferrer\"><code>string::copy</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/find\" rel=\"nofollow noreferrer\"><code>string::find</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/rfind\" rel=\"nofollow noreferrer\"><code>string::rfind</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/find_first_of\" rel=\"nofollow noreferrer\"><code>string::find_first_of</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/find_first_not_of\" rel=\"nofollow noreferrer\"><code>string::find_first_not_of</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/find_last_of\" rel=\"nofollow noreferrer\"><code>string::flind_last_of</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/find_last_not_of\" rel=\"nofollow noreferrer\"><code>string::find_last_not_of</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/operator%2B\" rel=\"nofollow noreferrer\"><code>string::operator+</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/operator_ltltgtgt\" rel=\"nofollow noreferrer\"><code>string::operator&gt;&gt;</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/operator_ltltgtgt\" rel=\"nofollow noreferrer\"><code>string::operator&lt;&lt;</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/stol\" rel=\"nofollow noreferrer\"><code>string::stoi</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/stol\" rel=\"nofollow noreferrer\"><code>string::stol</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/stol\" rel=\"nofollow noreferrer\"><code>string::stoll</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/stoul\" rel=\"nofollow noreferrer\"><code>string::stoul</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/stoul\" rel=\"nofollow noreferrer\"><code>string::stoull</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/stof\" rel=\"nofollow noreferrer\"><code>string::stof</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/stof\" rel=\"nofollow noreferrer\"><code>string::stod</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/stof\" rel=\"nofollow noreferrer\"><code>string::stold</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/to_string\" rel=\"nofollow noreferrer\"><code>stirng::to_string</code></a>, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/to_wstring\" rel=\"nofollow noreferrer\"><code>string::to_wstring</code></a></li>\n<li>Finally everywhere <code>vector</code> accepts arguments of another <code>vector</code>, <code>string</code> accepts a <code>string</code> <em>or</em> a <code>char*</code></li>\n</ol>\n<p>Note this answer is written against C++11, so <code>string</code>s are required to be allocated contiguously.</p>\n", "OwnerUserId": "2642059", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:47:30.917", "Id": "35558008", "Score": "0", "CreationDate": "2016-02-22T15:52:19.040", "LastActivityDate": "2016-02-22T15:52:19.040"}, "24619373": {"ParentId": "4557009", "CommentCount": "0", "Body": "<p>One difference between <code>std::string</code> and <code>std::vector</code> is that programs may construct a string from a null-terminated string, whereas with vectors they cannot.</p>\n<pre><code>std::string a = \"hello\";          // okay\nstd::vector&lt;char&gt; b = \"goodbye\";  // compiler error\n</code></pre>\n<p>This often makes strings easier to work with.</p>\n", "OwnerUserId": "1094609", "PostTypeId": "2", "Id": "24619373", "Score": "0", "CreationDate": "2014-07-07T20:34:21.260", "LastActivityDate": "2014-07-07T20:34:21.260"}});