post_cb({"bq_ids": {"n4140": {"so_14591203_14591372_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 2171}, "so_14591203_14591203_0": {"length": 6, "quality": 1.0, "section_id": 1855}, "so_14591203_14591203_2": {"length": 8, "quality": 1.0, "section_id": 2182}, "so_14591203_14591372_1": {"length": 35, "quality": 1.0, "section_id": 2170}}, "n3337": {"so_14591203_14591372_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 2159}, "so_14591203_14591203_0": {"length": 6, "quality": 1.0, "section_id": 1849}, "so_14591203_14591203_2": {"length": 8, "quality": 1.0, "section_id": 2170}, "so_14591203_14591372_1": {"length": 35, "quality": 1.0, "section_id": 2158}}, "n4659": {"so_14591203_14591372_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 2444}, "so_14591203_14591203_0": {"length": 6, "quality": 1.0, "section_id": 2028}, "so_14591203_14591203_2": {"length": 8, "quality": 1.0, "section_id": 2455}, "so_14591203_14591372_1": {"length": 35, "quality": 1.0, "section_id": 2443}}}, "14591323": {"Id": "14591323", "PostTypeId": "2", "Body": "<p>Intuitively speaking, the EOF bit is set because during the read operation to extract the string, the stream did indeed hit the end of the file.  Specifically, it continuously read characters out of the input stream, stopping because it hit the end of the stream before encountering a whitespace character.  Accordingly, the stream set the EOF bit to mark that the end of stream was reached.  Note that this is <em>not</em> the same as reporting failure - the operation was completed successfully - but the point of the EOF bit is not to report failure.  It's to mark that the end of the stream was encountered.</p>\n<p>I don't have a specific part of the spec to back this up, though I'll try to look for one when I get the chance.</p>\n<p>Hope this helps!</p>\n", "LastActivityDate": "2013-01-29T20:08:51.090", "CommentCount": "1", "CreationDate": "2013-01-29T20:08:51.090", "ParentId": "14591203", "Score": "3", "OwnerUserId": "501557"}, "14591203": {"ViewCount": "979", "Body": "<p>Let's say we have a stream containing simply:</p>\n<pre><code>hello\n</code></pre>\n<p>Note that there's no extra <code>\\n</code> at the end like there often is in a text file. Now, the following simple code shows that the <code>eof</code> bit is set on the stream after extracting a single <code>std::string</code>.</p>\n<pre><code>int main(int argc, const char* argv[])\n{\n  std::stringstream ss(\"hello\");\n  std::string result;\n  ss &gt;&gt; result;\n  std::cout &lt;&lt; ss.eof() &lt;&lt; std::endl; // Outputs 1\n  return 0;\n}\n</code></pre>\n<p>However, I can't see why this would happen according to the standard (I'm reading C++11 - <em>ISO/IEC 14882:2011(E)</em>). <code>operator&gt;&gt;(basic_stream&lt;...&gt;&amp;, basic_string&lt;...&gt;&amp;)</code> is defined as behaving like a <em>formatted input function</em>. This means it constructs a <code>sentry</code> object which proceeds to eat away whitespace characters. In this example, there are none, so the <code>sentry</code> construction completes with no problems. When converted to a <code>bool</code>, the <code>sentry</code> object gives <code>true</code>, so the extractor continues to get on with the actual extraction of the string.</p>\n<p>The extraction is then defined as:</p>\n<blockquote>\n<p id=\"so_14591203_14591203_0\">Characters are extracted and appended until any of the following occurs:</p>\n<ul>\n<li><code>n</code> characters are stored;</li>\n<li>end-of-file occurs on the input sequence;</li>\n<li><code>isspace(c,is.getloc())</code> is true for the next available input character <em>c</em>.</li>\n</ul>\n<p id=\"so_14591203_14591203_1\">After the last character (if any) is extracted, is.width(0) is called and the sentry object k is destroyed.\n  If the function extracts no characters, it calls <code>is.setstate(ios::failbit)</code>, which may throw <code>ios_base::failure</code> (27.5.5.4).</p>\n</blockquote>\n<p>Nothing here actually causes the <code>eof</code> bit to be set. Yes, extraction stops if it hits the end-of-file, but it doesn't set the bit. In fact, the <code>eof</code> bit should only be set if we do another <code>ss &gt;&gt; result;</code>, because when the <code>sentry</code> attempts to gobble up whitespace, the following situation will occur:</p>\n<blockquote>\n<p id=\"so_14591203_14591203_2\">If <code>is.rdbuf()-&gt;sbumpc()</code> or <code>is.rdbuf()-&gt;sgetc()</code> returns <code>traits::eof()</code>, the function calls <code>setstate(failbit | eofbit)</code></p>\n</blockquote>\n<p>However, this is definitely not happening yet because the <code>failbit</code> isn't being set.</p>\n<p>The consequence of the <code>eof</code> bit being set is that the only reason the evil-idiom <code>while (!stream.eof())</code> doesn't work when reading files is because of the extra <code>\\n</code> at the end and <em>not</em> because the <code>eof</code> bit isn't yet set. My compiler is happily setting the <code>eof</code> bit when the extraction stops at the end of file.</p>\n<p>So should this be happening? Or did the standard mean to say that <code>setstate(eofbit)</code> should occur?</p>\n<hr>\n<p>To make it easier, the relevant sections of the standard are:</p>\n<ul>\n<li>21.4.8.9 Inserters and extractors [string.io]</li>\n<li>27.7.2.2 Formatted input functions [istream.formatted]</li>\n<li>27.7.2.1.3 Class <code>basic_istream::sentry</code> [istream::sentry]</li>\n</ul>\n</hr>", "AcceptedAnswerId": "14591372", "Title": "Why does string extraction from a stream set the eof bit?", "CreationDate": "2013-01-29T20:01:37.967", "Id": "14591203", "CommentCount": "2", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2013-01-29T20:16:48.693", "Score": "9", "OwnerUserId": "150634", "Tags": "<c++><string><iostream><language-lawyer>", "AnswerCount": "2"}, "14591372": {"Id": "14591372", "PostTypeId": "2", "Body": "<p><code>std::stringstream</code> is a <code>basic_istream</code> and the <code>operator&gt;&gt;</code> of <code>std::string</code> \"extracts\" characters from it (as you found out).</p>\n<p>27.7.2.1 Class template <code>basic_istream</code></p>\n<blockquote>\n<p id=\"so_14591203_14591372_0\">2 If rdbuf()-&gt;sbumpc() or rdbuf()-&gt;sgetc() returns traits::eof(), then the input function, except as\n  explicitly noted otherwise, completes its actions and does setstate(eofbit), which may throw ios_-\n  base::failure (27.5.5.4), before returning.</p>\n</blockquote>\n<p>Also, \"extracting\" means calling these two functions.</p>\n<blockquote>\n<p id=\"so_14591203_14591372_1\">3 Two groups of member function signatures share common properties: the formatted input functions (or\n  extractors) and the unformatted input functions. Both groups of input functions are described as if they\n  obtain (or extract) input characters by calling rdbuf()-&gt;sbumpc() or rdbuf()-&gt;sgetc(). They may use\n  other public members of istream.</p>\n</blockquote>\n<p>So eof must be set.</p>\n", "LastEditorUserId": "1176973", "LastActivityDate": "2013-01-29T20:16:48.693", "Score": "8", "CreationDate": "2013-01-29T20:11:45.637", "ParentId": "14591203", "CommentCount": "1", "OwnerUserId": "1176973", "LastEditDate": "2013-01-29T20:16:48.693"}});