post_cb({"bq_ids": {"n4140": {"so_31809141_31809585_1": {"length": 28, "quality": 1.0, "section_id": 5362}, "so_31809141_31809585_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 5362}}, "n3337": {"so_31809141_31809585_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 5158}, "so_31809141_31809585_1": {"length": 28, "quality": 1.0, "section_id": 5158}}, "n4659": {"so_31809141_31809585_1": {"length": 20, "quality": 0.7142857142857143, "section_id": 6786}, "so_31809141_31809585_0": {"length": 19, "quality": 0.6785714285714286, "section_id": 6786}}}, "31809585": {"Id": "31809585", "PostTypeId": "2", "Body": "<p>In C++03 this behaviour would be undefined.</p>\n<p>ISO 14882-2003: 2.13.4.3 states that</p>\n<blockquote>\n<p id=\"so_31809141_31809585_0\">In translation phase 6 (2.1), adjacent narrow string literals are\n  concatenated and adjacent wide string literals are concatenated. If a\n  narrow string literal token is adjacent to a wide string literal\n  token, the behavior is undefined. Characters in concatenated strings\n  are kept distinct.</p>\n</blockquote>\n<p>Not sure exactly when the change was introduced but the behaviour is at least well defined in the draft N3242 of the standard.</p>\n<p>ISO 14882-2011: 2.14.5.13 states that</p>\n<blockquote>\n<p id=\"so_31809141_31809585_1\">In translation phase 6 (2.2), adjacent string literals are concatenated. If both string literals have the same encoding-prefix, the resulting concatenated string literal has that encoding-prefix. If one string literal has no encoding-prefix, it is treated as a string literal of the same encoding-prefix as the other operand.</p>\n</blockquote>\n<p>Therefore, in your case, <code>auto</code> is correctly deduced as a wide string literal.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2015-08-04T13:38:35.537", "Score": "8", "CreationDate": "2015-08-04T12:39:33.403", "ParentId": "31809141", "CommentCount": "0", "OwnerUserId": "862396", "LastEditDate": "2015-08-04T13:38:35.537"}, "31809141": {"ViewCount": "1012", "Body": "<p>When we have either of these:</p>\n<pre><code>auto city1 = \"New \"  L\"Delhi\";\nauto city2 = L\"New \" \"York\";\n</code></pre>\n<p>Any pre-VS2015 compiler would raise error:  </p>\n<blockquote>\n<p id=\"so_31809141_31809141_0\">error C2308: concatenating mismatched strings</p>\n</blockquote>\n<p>But with VC2015 compiler, it compiles well and the resultant type (<code>auto</code> deduction) is a wide-char string. </p>\n<p>My question is: When and How this is made possible - any standard specification?</p>\n", "AcceptedAnswerId": "31809585", "Title": "Concatenating mismatched string WORKS in VC2015 - How?", "CreationDate": "2015-08-04T12:17:19.560", "Id": "31809141", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-08-05T08:35:39.547", "LastEditorUserId": "916299", "LastActivityDate": "2015-08-05T08:35:39.547", "Score": "5", "OwnerUserId": "264325", "Tags": "<c++><c++11><visual-studio-2015><c++14>", "AnswerCount": "1"}});