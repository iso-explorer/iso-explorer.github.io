post_cb({"11090052": {"ParentId": "11089986", "CommentCount": "0", "CreationDate": "2012-06-18T19:53:12.363", "OwnerUserId": "501557", "PostTypeId": "2", "Id": "11090052", "Score": "2", "Body": "<p>If an exception is thrown, then the pointer will not be assigned a new value.  If your pointer is scoped inside of the <code>try</code> block where you do the allocation, or is not scoped in any <code>try</code> block, then the exception will cause the scope to change such that you can't access the pointer any more.  Consequently, there's no need to test the pointer.</p>\n<p>If, on the other hand, the pointer is declared in a way where it persists after the allocation fails, then you would need to check the value.  For example:</p>\n<pre><code>T* ptr = NULL;\ntry {\n    ptr = new T();\n} catch (std::bad_alloc&amp; ) {\n    /* ... handle error */\n}\n// Have to test ptr here, since it could still be NULL.\n</code></pre>\n<p>Hope this helps!</p>\n", "LastActivityDate": "2012-06-18T19:53:12.363"}, "11090063": {"ParentId": "11089986", "CommentCount": "0", "CreationDate": "2012-06-18T19:53:47.270", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "11090063", "Score": "3", "Body": "<p>When an exception is thrown out of a function the function does not complete and does not return anything, at the same time control flow jumps to the exception handler and even if the function returned, the assignment to the receiving pointer would not be executed.</p>\n<p>The same goes for the throwing version of <code>new</code>, if it throws, then the pointer would maintain the same value it had before the expression, which might be NULL or any other value.</p>\n<p>On the other hand, if you use <code>new (std::nothrow) X;</code> then the call to <code>new</code> will not throw, and failure will be indicated by a NULL value being returned (and assumingly assigned to a pointer)</p>\n", "LastActivityDate": "2012-06-18T19:53:47.270"}, "11090022": {"ParentId": "11089986", "CommentCount": "0", "CreationDate": "2012-06-18T19:51:27.163", "OwnerUserId": "20322", "PostTypeId": "2", "Id": "11090022", "Score": "1", "Body": "<p>If <code>new</code> fails it throws a <code>std::bad_alloc</code> exception, unless you use the <code>nothrow</code> version.  This means that the value of the variable to store the returned pointer will be unchanged.</p>\n<p>If you catch the exception the value of <code>pFile</code> remains uninitialized, otherwise your application terminates (as <code>main</code> is exited)</p>\n", "LastActivityDate": "2012-06-18T19:51:27.163"}, "11089986": {"CommentCount": "3", "AcceptedAnswerId": "11090063", "PostTypeId": "1", "LastEditorUserId": "1139697", "CreationDate": "2012-06-18T19:48:59.860", "LastActivityDate": "2012-06-18T20:09:18.713", "LastEditDate": "2012-06-18T19:51:44.417", "ViewCount": "173", "FavoriteCount": "1", "Title": "Is it required to check a pointer validity if new fails?", "Id": "11089986", "Score": "1", "Body": "<p>As title says, i know that new throws an exception which can be caught, but what exactly happens to the pointer? it turns NULL? I checked some answers on SO but none explained it.\nCheck example below, the pointer keeps on the heap? please give full info on this pattern</p>\n<pre><code>#include &lt;windows.h&gt;\n#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nenum eReadMode\n{\n //    READ_ONLY,\n     READ_WRITE,\n    // CREATE_FILE,\n   //  CREATE_WRITE_FILE,\n};\n\nclass CFileStatic\n{\nprivate:\n    FILE *m_File;\npublic:\n    CFileStatic( LPCTSTR szFileName, eReadMode eMode );\n    virtual ~CFileStatic() {};\n\n    bool IsValidFile() const { return( m_File != NULL ); };\n    void PrintFile( unsigned int uLine = 0 );\n};\n\nCFileStatic::CFileStatic( LPCTSTR szFileName, eReadMode eMode )\n{\n    if( szFileName )\n    {\n        if( eMode == READ_WRITE )\n            m_File = fopen( szFileName, \"r+\" );\n        else\n            printf( \"Valid usage of: READ_WRITE only\" );\n    }\n    else\n        m_File = NULL;\n}     \n\nvoid CFileStatic::PrintFile( unsigned int uLine )\n{\n    static unsigned uFindNumber;\n    if( uLine == 0 )\n    {\n        char szBuffer[1024];\n        while( fgets( szBuffer, 1024, m_File ) )\n        {\n               std::cout &lt;&lt; szBuffer;\n        }\n    }\n    else\n    {\n        char szBuffer[1024];\n        while( fgets( szBuffer, 1024, m_File ) )\n        {\n               uFindNumber++;\n               if( uFindNumber == uLine )\n               {\n                   std::cout &lt;&lt; szBuffer;\n               }\n        }\n    }\n\n}     \n\n\nint main( int argc, char *argv[] )\n{\n    //if new fails, what 'pFile' turns out to be? and do I need to delete\n    //it later?\n    CFileStatic *pFile = new CFileStatic( \"Console.h\", READ_WRITE );\n    if( pFile-&gt;IsValidFile() )\n    {\n        pFile-&gt;PrintFile(2);\n    }\n\n    CFileStatic *pConsoleCpp = new CFileStatic( \"Console.cpp\", READ_WRITE );\n    if( pConsoleCpp-&gt;IsValidFile() )\n    {\n        pConsoleCpp-&gt;PrintFile();\n    }\n\n\n    system(\"pause&gt;nul\");\n    return EXIT_SUCCESS;\n}\n</code></pre>\n", "Tags": "<c++><pointers>", "OwnerUserId": "1452014", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_11089986_11090033_0": {"section_id": 6009, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_11089986_11090033_0": {"section_id": 5777, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_11089986_11090033_0": {"section_id": 7508, "quality": 0.7142857142857143, "length": 5}}}, "11090033": {"ParentId": "11089986", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-06-18T19:52:07.183", "Score": "6", "LastEditorUserId": "241536", "LastEditDate": "2012-06-18T20:09:18.713", "Id": "11090033", "OwnerUserId": "241536", "Body": "<p>Assuming you are using the default global <code>new</code> operator, and have not used the <code>nothrow</code> version of <code>new</code>:</p>\n<pre><code>int main( int argc, char *argv[] )\n{\n  //if new fails, what 'pFile' turns out to be? and do I need to delete\n  //it later?\n  CFileStatic *pFile = new CFileStatic( \"Console.h\", READ_WRITE );\n  /* ... */\n}\n</code></pre>\n<p>There is no \"later\".  In this code, if <code>new</code> fails, it will throw an <code>std::bad_alloc</code> exception, and your program will terminate immediately.</p>\n<p>Now, if you were to try to handle this situation, you would need to catch that exception.  Perhaps like this:</p>\n<pre><code>int main( int argc, char *argv[] )\n{\n  //if new fails, what 'pFile' turns out to be? and do I need to delete\n  //it later?\n  try\n  {\n    CFileStatic *pFile = new CFileStatic( \"Console.h\", READ_WRITE );\n  }\n  catch( const std::bad_alloc&amp; ex )\n  {\n    cout &lt;&lt; \"whoops! out of memory.\" &lt;&lt; ex.what() &lt;&lt;  endl;\n  }\n  /* ... */\n}\n</code></pre>\n<p><code>pFile</code> exists within the scope enclosed by the <code>try</code> block, so it no longer exists.  Moving out one level:</p>\n<pre><code>  CFileStatic * pFile = 0;\n  try\n  {\n    pFile = new CFileStatic( \"Console.h\", READ_WRITE );\n  }\n  catch( const std::bad_alloc&amp; ex )\n  {\n    cout &lt;&lt; \"whoops! out of memory.\" &lt;&lt; ex.what() &lt;&lt;  endl;\n  }\n\n  // pFile is still 0\n</code></pre>\n<p><code>pFile</code> is never modified, so the value is unchanged.</p>\n<hr>\n<p>Regarding the question of <code>delete</code>ing the pointer.  The Standard says (C++03 5.3.5/2):</p>\n<blockquote>\n<p id=\"so_11089986_11090033_0\">[...] if the value of the operand of delete is the null pointer the\n  operation has no effect.</p>\n</blockquote>\n<p>You do not have to delete a NULL pointer, because there is nothing to <code>delete</code>, but doing so will have no effect.  You could safely do this:</p>\n<pre><code>CFileStatic * pFile = 0;\ntry\n{\n  pFile = new CFileStatic( \"Console.h\", READ_WRITE );\n}\ncatch( const std::bad_alloc&amp; ex )\n{\n  cout &lt;&lt; \"whoops! out of memory.\" &lt;&lt; ex.what() &lt;&lt;  endl;\n}\n\ndelete pFile;  // regardless of the success of new, this is OK\n</code></pre>\n<p>Note that when doing this, it is especially important that you initialize <code>pFile</code> to the null pointer, as I've done here.  If you don't:</p>\n<pre><code>CFileStatic* pFile; // NO INIT\n/* ... */\ndelete pFile; // if new threw, this is undefined behavior\n</code></pre>\n<p><code>pFile</code> will still be a garbage pointer.  It's not the null pointer, so <code>delete</code> will try to delete it, resulting in Undefined Behavior.</p>\n</hr>", "LastActivityDate": "2012-06-18T20:09:18.713"}});