post_cb({"39384577": {"ParentId": "39384399", "PostTypeId": "2", "CommentCount": "8", "Body": "<p><code>D</code> is a <code>B</code> when public inheritance is used. So accessing <code>b_var</code> is still perfectly legal.<br>\nYou would get an error, however, if you attempt to access <code>d_var</code>, since the friendship itself is not inherited, as you seem to be aware.  </br></p>\n<p>Inheritance always makes all members of the base be members of the derived. Access specifiers only affect where an identifier is visible. That's why accessing a private member illegally produces a different error to accessing an identifier that doesn't exist.</p>\n", "OwnerUserId": "817643", "LastEditorUserId": "817643", "LastEditDate": "2016-09-08T07:40:36.833", "Id": "39384577", "Score": "5", "CreationDate": "2016-09-08T07:08:05.227", "LastActivityDate": "2016-09-08T07:40:36.833"}, "39384399": {"CommentCount": "3", "AcceptedAnswerId": "39386702", "PostTypeId": "1", "LastEditorUserId": "1025391", "CreationDate": "2016-09-08T06:56:38.820", "LastActivityDate": "2016-09-09T06:05:28.047", "LastEditDate": "2016-09-08T11:29:32.230", "ViewCount": "1354", "FavoriteCount": "1", "Title": "Can a friend class object access base class private members on a derived class object?", "Id": "39384399", "Score": "10", "Body": "<p>I'm surprised that the code below compiles.</p>\n<p>It seems that a class befriended to the (publicly inherited) base class can access a member of the base class provided an instance of the derived class.</p>\n<p>If the inheritance is changed to <code>private</code> then compilation fails.</p>\n<p>In short, how is <code>d.b_var</code> valid within <code>F::func(D&amp; d)</code>?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nclass B{\n    int b_var;\n    friend class F;\n};\n\nclass D: public B{\n    int d_var;\n};\n\nclass F{\n    public:\n        void func(D &amp;d){\n            d.b_var = 5; \n        }\n};\n\nint main()\n{\n    cout&lt;&lt;\"fine\";\n}\n</code></pre>\n", "Tags": "<c++><inheritance><private><friend>", "OwnerUserId": "6807755", "AnswerCount": "5"}, "39384918": {"ParentId": "39384399", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>You write:</p>\n<blockquote>\n<p id=\"so_39384399_39384918_0\">It seems that somehow friendship is inherited and a friend class can access a member of the derived class.</p>\n</blockquote>\n<p>But it rather should be:</p>\n<p><em>It seems that a class befriended to the (publicly inherited) base class can access a private member of the base class provided an instance of the derived class.</em></p>\n<p>Or:</p>\n<p><em>It seems that a class befriended to another class can access the private members of its instances.</em></p>\n<p>This relates to your question: </p>\n<blockquote>\n<p id=\"so_39384399_39384918_1\">In short, how is <code>d.b_var</code> valid within <code>F::func(D&amp; d)</code> ?</p>\n</blockquote>\n<p>Because <code>d.b_var</code> is a member of an instance of class B (via polymorphism) to which instances of class F have access (via friend-status).</p>\n<p>This doesn't work with <code>d.d_var</code>, because the friendship to the base class is not inherited and instances of class F therefore don't have access to private members of d.</p>\n<p>This doesn't work with private (or protected) inheritance, because thereby another \"layer of access restriction\" is added. In addition, you then need to grant access to the derived class' privately inherited members as well (which <code>d.b_var</code> then is). For example by making also D a friend to F.</p>\n<p>For reference:</p>\n<ul>\n<li><a href=\"http://en.cppreference.com/w/cpp/language/friend\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/friend</a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/language/derived_class\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/derived_class</a></li>\n</ul>\n", "OwnerUserId": "1025391", "LastEditorUserId": "1025391", "LastEditDate": "2016-09-09T06:05:28.047", "Id": "39384918", "Score": "1", "CreationDate": "2016-09-08T07:26:11.773", "LastActivityDate": "2016-09-09T06:05:28.047"}, "39385325": {"ParentId": "39384399", "CommentCount": "3", "Body": "<p>While there already are good answers I think some images would help here a bit too.</p>\n<p><a href=\"https://i.stack.imgur.com/TYG3F.png\" rel=\"nofollow noreferrer\"><img alt=\"B-class\" src=\"https://i.stack.imgur.com/TYG3F.png\"/></a></p>\n<p>This is an abstraction of your <code>B</code> class. <code>F</code> has access to all its members.</p>\n<p>When you now instantiate a <code>D</code> object it looks like this</p>\n<p><a href=\"https://i.stack.imgur.com/8TjSp.png\" rel=\"nofollow noreferrer\"><img alt=\"D-class\" src=\"https://i.stack.imgur.com/8TjSp.png\"/></a></p>\n<p>It still is a B object but also a D object. It extends <code>B</code> so to speak. <code>F</code> can still access the part from B because it's still there but not from <code>D</code>.</p>\n<p><em>Please note that these abstractions do not really display the layout in memory and explain overriding etc. But they are just for the sake of this question.</em></p>\n", "OwnerUserId": "152359", "PostTypeId": "2", "Id": "39385325", "Score": "3", "CreationDate": "2016-09-08T07:47:23.997", "LastActivityDate": "2016-09-08T07:47:23.997"}, "39386702": {"ParentId": "39384399", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Object of <code>class D</code> is composed of 2 separate parts :</p>\n<pre><code>part containing members of B \npart containing members of D\n</code></pre>\n<p>That why the concept of object slicing works when we do:</p>\n<pre><code>D objD;\nB objB = objD;\n</code></pre>\n<p>Now we can access from inside <code>object of class D</code>, the <code>part containing members of B</code> via <code>objB</code>. Compiler remembers or can distinguish between the two parts inside <code>class D</code>. So compiler know what is being accessed via what.</p>\n<p>The statement <code>friend class F;</code> inside <code>class B</code> simply tells that <code>member functions of class F</code> can accesses the <code>private, protected and public</code> members of <code>class B</code>. That is, for <code>member functions of class F</code> all the members of <code>class B</code> are <code>public</code>. </p>\n<p>Actually, inside every class there are three sections w.r.t accessibility:</p>\n<pre><code>public\nprotected\nprivate \n</code></pre>\n<p>So when we declare some <code>class B</code>:</p>\n<pre><code>class B\n{\n    public:\n        int a;\n    protected:\n        int b;\n    public:\n        int c;\n};\n</code></pre>\n<p>then following 3 sections get created inside class <code>B</code> as shown above.</p>\n<p>Now when we declare some <code>class F</code> to be a <code>friend</code> of <code>class B</code>:</p>\n<pre><code>class B\n{\n    friend class F;\n    private:\n        int a;\n    protected:\n        int b;\n    public:\n        int c;            \n};\n</code></pre>\n<p>then the compiler creates the sections as follows:</p>\n<pre><code>class B\n{\n    friend class F;\n    private:\n        int a;\n    protected:\n        int b;\n    public:\n        int c;\n        //int a;  only for member functions of class F\n        //int b;  only for member functions of class F             \n};\n</code></pre>\n<p>Note that <code>int a;</code> and <code>int b;</code> are now public for <code>member functions</code> of <code>class F</code>.</p>\n<p>Now when <code>class D</code> is derived <code>publicly</code> from <code>class B</code> then the <code>public</code> section of <code>class B</code> becomes <code>public</code> section of <code>class D</code>. Similary, the <code>protected</code> section of  <code>class B</code> becomes <code>protected</code> section of <code>class D</code>. Therefore, the <code>public</code> section part of <code>class B</code> can be accessed via object of <code>class D</code>. And since <code>B::a;</code> and <code>B::b;</code> are in public section for <code>members functions of class F</code>, therefore <code>B::a</code> and <code>B::b</code> can be accessed via object of <code>class D</code>. Also note that although after derivation <code>int a;</code> and <code>int b;</code> become members of <code>class D</code>, still compiler is able to distinguish them and considers them a <code>part of class B</code>.</p>\n<p>Now when <code>class D</code> is derived <code>privately</code> from <code>class B</code> then the <code>public</code> section of <code>class B</code> becomes <code>private</code> section of <code>class D</code>. Similary, the <code>protected</code> section of  <code>class B</code> becomes protected section of <code>class D</code>. Therefore, now the <code>public</code> section part inside of <code>class B</code> <strong>cannot</strong> be accessed via object of <code>class D</code>. Recall that in <code>class B</code>, <code>B::a;</code> and <code>B::b;</code> are originally in public section for <code>members functions of class F</code> but after <code>private</code> derivation, the members of <code>class B</code> i.e <code>B::a</code> and <code>B::b</code> are now in private section of <code>class D</code>. Therefore, <code>B::a</code> and <code>B::b</code> <strong>cannot</strong> be accessed via object of <code>class D</code>. Also note that although after derivation <code>int a;</code> and <code>int b;</code> become members of <code>class D</code>, still compiler is able to distinguish them and considers them a <code>part of class B</code>. After derivation the accessibility and rules of some members of <code>class B</code> have changed.</p>\n<p>Since this question somewhat relates to effect of <code>public, protected and private</code> derivation, therefore for completeness please see:\n<a href=\"https://stackoverflow.com/questions/38717447/why-can-a-derived-class-not-access-a-protected-member-of-its-base-class-through/38719990#38719990\">Why can a derived class not access a protected member of its base class through a pointer to base?</a></p>\n", "OwnerUserId": "4635537", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:00:53.023", "Id": "39386702", "Score": "4", "CreationDate": "2016-09-08T08:59:48.400", "LastActivityDate": "2016-09-08T10:07:10.370"}, "39385357": {"ParentId": "39384399", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote id=\"so_39384399_39385357_0\">\n<ol>\n<li>It seems that somehow friendship is inherited and a friend class can access a member of the derived class.<br>\n  In short, how is <code>d.b_var</code> valid within <code>F::func(D&amp; d)</code>?</br></li>\n</ol>\n</blockquote>\n<p><code>d.b_var</code> might be misleading. To be more precise (another way to see it), <code>b_var</code> is not (direct) member of derived class <code>D</code>. Instead, the object of <code>D</code> contains a subobject of base class <code>B</code>, which has member <code>b_var</code>, and could be accessed by the friend <code>F</code>. (As we can also write <code>d.b_var</code> as <code>d.B::b_var</code>.)</p>\n<p><a href=\"http://eel.is/c++draft/class.derived#3\" rel=\"nofollow\">$10/3 Derived classes\n[class.derived]</a>:</p>\n<blockquote>\n<p id=\"so_39384399_39385357_1\">The base-specifier-list specifies the type of the base class\n  subobjects contained in an object of the derived class type. [\n  Example:</p>\n<pre><code>struct Base {\n  int a, b, c;\n};\n\nstruct Derived : Base {\n  int b;\n};\n\nstruct Derived2 : Derived {\n  int c;\n};\n</code></pre>\n<p id=\"so_39384399_39385357_2\">Here, an object of class <code>Derived2</code> will have a subobject of class\n  <code>Derived</code> which in turn will have a subobject of class <code>Base</code>.  \u2014 end\n  example ]</p>\n</blockquote>\n<p>And </p>\n<blockquote id=\"so_39384399_39385357_3\">\n<ol start=\"2\">\n<li>If the inheritance is changed to <code>private</code> then compilation fails.</li>\n</ol>\n</blockquote>\n<p>Because</p>\n<pre><code>class B {\n    int b_var;\n    friend class F;\n};\n\nclass D: private B {\n    int d_var;\n};\n\nclass F{\npublic:\n    void func(D &amp;d) {\n        d.b_var = 5;  // Fail. Can't access subobject of B\n        d.d_var = 5;  // Fail. Can't access member of D\n    }\n};\n</code></pre>\n<p>Then</p>\n<pre><code>class B {\n    int b_var;\n};\n\nclass D: private B {\n    friend class F;\n    int d_var;\n};\n\nclass F{\npublic:\n    void func(D &amp;d) {\n        d.b_var = 5;  // Fail. Can't access b_var of subobject of B\n        d.d_var = 5;  // Fine.\n    }\n};\n</code></pre>\n<p>Note that in last case, even <code>F</code> is friend of class <code>D</code>, it could access all the private/protected members of <code>D</code>, but not including members in subobject <code>B</code>, because they're not (direct) members of class <code>D</code>.</p>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2016-09-08T08:31:19.440", "Id": "39385357", "Score": "4", "CreationDate": "2016-09-08T07:49:15.260", "LastActivityDate": "2016-09-08T08:31:19.440"}, "bq_ids": {"n4140": {"so_39384399_39385357_2": {"section_id": 6976, "quality": 0.8823529411764706, "length": 15}, "so_39384399_39384918_0": {"section_id": 6682, "quality": 0.5454545454545454, "length": 6}, "so_39384399_39385357_1": {"section_id": 6976, "quality": 0.7692307692307693, "length": 10}}, "n3337": {"so_39384399_39385357_2": {"section_id": 6722, "quality": 0.8823529411764706, "length": 15}, "so_39384399_39384918_0": {"section_id": 5728, "quality": 0.5454545454545454, "length": 6}, "so_39384399_39385357_1": {"section_id": 6722, "quality": 0.7692307692307693, "length": 10}}, "n4659": {"so_39384399_39385357_2": {"section_id": 8475, "quality": 0.8823529411764706, "length": 15}, "so_39384399_39384918_0": {"section_id": 8157, "quality": 0.5454545454545454, "length": 6}, "so_39384399_39385357_1": {"section_id": 8475, "quality": 0.7692307692307693, "length": 10}}}});