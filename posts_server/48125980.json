post_cb({"48125980": {"ViewCount": "58", "Body": "<p>I just discovered that gcc and clang++, would let me use a <code>const int</code> for the underlying type of an enum. I wonder if that has any utility of if for all purposes it is the same as having an enum based on <code>int</code>.</p>\n<p>I thought that may be it would make the enum instance not assignable, but it was not the case. (And to be honest, I thought it would not compile in the same way that you <em>can't</em> make a class derived from a const base type <code>class C2 : const C1{}</code>)</p>\n<p><strong>Is there any use or subtle difference between <code>enum : int</code> and <code>enum : const int</code>?</strong> <strong>If no, why would the compiler allow it?</strong></p>\n<p>Example:</p>\n<pre><code>#include&lt;iostream&gt;\nenum A : const int{ // is this the same as enum A : int ?\n   no = 0,\n   si\n};\n\nint main(){ \n   A a; \n   a = si; // is asignable\n   a = no; // twice\n   std::cout &lt;&lt; (int)a &lt;&lt; std::endl; // prints '0'\n   return 0;\n}\n</code></pre>\n<hr>\n<p>Funny that I can do this <code>enum A : volatile int</code> as well.\n(Fortunately, I can't do this <code>enum A : int&amp;</code> or <code>enum A : int*</code>.)</p>\n</hr>", "AcceptedAnswerId": "48126424", "Title": "Is there any difference between enum : int and enum : const int", "CreationDate": "2018-01-06T09:28:30.550", "LastActivityDate": "2018-01-06T22:12:57.367", "CommentCount": "1", "LastEditDate": "2018-01-06T22:12:57.367", "PostTypeId": "1", "LastEditorUserId": "225186", "Id": "48125980", "Score": "2", "OwnerUserId": "225186", "Tags": "<c++11><enums><constants>", "AnswerCount": "2"}, "48128428": {"Id": "48128428", "PostTypeId": "2", "Body": "<p>For completeness sake, here is the relevant standard quote (from C++11 up to latest draft):</p>\n<blockquote>\n<p id=\"so_48125980_48128428_0\"><strong>[dcl.enum]#2</strong> The enumeration type [...] The type-specifier-seq of an enum-base shall name an integral type; <strong>any cv-qualification is ignored</strong>. </p>\n</blockquote>\n<p>where <em>type-specifier-seq</em> is the underlying type specification in the corresponding grammar production.</p>\n", "LastEditorUserId": "8631381", "LastActivityDate": "2018-01-06T14:46:52.263", "Score": "2", "CreationDate": "2018-01-06T14:38:24.110", "ParentId": "48125980", "CommentCount": "0", "OwnerUserId": "8631381", "LastEditDate": "2018-01-06T14:46:52.263"}, "48126424": {"Id": "48126424", "PostTypeId": "2", "Body": "<p>There seems to be no difference - the underlaying type for both is int. Here some example test program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nenum e1 : int {};\nenum e2: const int {};\n\nint main() {\n    bool e1_type = std::is_same&lt;\n        const int\n       ,typename std::underlying_type&lt;e1&gt;::type\n    &gt;::value; \n\n    bool e2_type = std::is_same&lt;\n        const int\n       ,typename std::underlying_type&lt;e2&gt;::type\n    &gt;::value;\n\n    std::cout\n    &lt;&lt; \"underlying type for 'e1' is \" &lt;&lt; (e1_type?\"const\":\"non-const\") &lt;&lt; '\\n'\n    &lt;&lt; \"underlying type for 'e2' is \" &lt;&lt; (e2_type?\"const\":\"non-const\") &lt;&lt; '\\n';\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/dXLDe80zKhSxglcl\" rel=\"nofollow noreferrer\">https://wandbox.org/permlink/dXLDe80zKhSxglcl</a></p>\n", "LastActivityDate": "2018-01-06T10:27:14.213", "Score": "1", "CreationDate": "2018-01-06T10:27:14.213", "ParentId": "48125980", "CommentCount": "0", "OwnerUserId": "1201701"}, "bq_ids": {"n4140": {"so_48125980_48128428_0": {"length": 9, "quality": 0.75, "section_id": 5461}}, "n3337": {"so_48125980_48128428_0": {"length": 9, "quality": 0.75, "section_id": 5248}}, "n4659": {"so_48125980_48128428_0": {"length": 9, "quality": 0.75, "section_id": 6895}}}});