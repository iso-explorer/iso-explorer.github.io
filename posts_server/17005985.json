post_cb({"bq_ids": {"n4140": {"so_17005985_17008568_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 321}, "so_17005985_17008568_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 321}, "so_17005985_17008568_3": {"length": 27, "quality": 0.9642857142857143, "section_id": 321}, "so_17005985_17008568_4": {"length": 26, "quality": 0.9285714285714286, "section_id": 147}, "so_17005985_17008568_6": {"length": 22, "quality": 1.0, "section_id": 147}, "so_17005985_17005985_0": {"length": 60, "quality": 0.8571428571428571, "section_id": 321}, "so_17005985_17008568_1": {"length": 28, "quality": 0.9655172413793104, "section_id": 162}, "so_17005985_17008568_5": {"length": 22, "quality": 1.0, "section_id": 147}}, "n3337": {"so_17005985_17005985_0": {"length": 60, "quality": 0.8571428571428571, "section_id": 311}, "so_17005985_17008568_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 311}, "so_17005985_17008568_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 311}, "so_17005985_17008568_6": {"length": 22, "quality": 1.0, "section_id": 141}, "so_17005985_17008568_4": {"length": 26, "quality": 0.9285714285714286, "section_id": 141}, "so_17005985_17008568_3": {"length": 27, "quality": 0.9642857142857143, "section_id": 311}, "so_17005985_17008568_1": {"length": 28, "quality": 0.9655172413793104, "section_id": 156}, "so_17005985_17008568_5": {"length": 22, "quality": 1.0, "section_id": 141}}, "n4659": {"so_17005985_17008568_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 329}, "so_17005985_17008568_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 329}, "so_17005985_17008568_3": {"length": 27, "quality": 0.9642857142857143, "section_id": 329}, "so_17005985_17008568_4": {"length": 24, "quality": 0.8571428571428571, "section_id": 151}, "so_17005985_17008568_6": {"length": 20, "quality": 0.9090909090909091, "section_id": 151}, "so_17005985_17005985_0": {"length": 60, "quality": 0.8571428571428571, "section_id": 329}, "so_17005985_17008568_1": {"length": 28, "quality": 0.9655172413793104, "section_id": 166}, "so_17005985_17008568_5": {"length": 20, "quality": 0.9090909090909091, "section_id": 151}}}, "17005985": {"ViewCount": "1923", "Body": "<p>I read about the c++11 standard but can't understand well the meanning of the following.example are very preferred. </p>\n<blockquote>\n<p id=\"so_17005985_17005985_0\">Two sets of types are used to determine the partial ordering. For each\n  of the templates involved there is the original function type and the\n  transformed function type. [Note: The creation of the transformed type\n  is described in 14.5.6.2. \u2014 end note ] The deduction process uses the\n  transformed type as the argument template and the original type of the\n  other template as the parameter template. This process is done twice\n  for each type involved in the partial ordering comparison: once using\n  the transformed template-1 as the argument template and template-2 as\n  the parameter template and again using the transformed template-2 as\n  the argument template and template-1 as the parameter template<br>\n  -- <em>N3242 14.8.2.4.2</em></br></p>\n</blockquote>\n", "AcceptedAnswerId": "17008568", "Title": "what's the partial ordering procedure in template deduction", "CreationDate": "2013-06-09T02:57:04.593", "Id": "17005985", "CommentCount": "2", "FavoriteCount": "11", "PostTypeId": "1", "LastEditDate": "2013-06-09T11:32:27.140", "LastEditorUserId": "819272", "LastActivityDate": "2013-06-09T11:32:27.140", "Score": "23", "OwnerUserId": "1501948", "Tags": "<c++><templates><c++11><partial-ordering><template-deduction>", "AnswerCount": "1"}, "17008568": {"Id": "17008568", "PostTypeId": "2", "Body": "<p>While Xeo gave <a href=\"https://stackoverflow.com/questions/17005985/whats-the-partial-ordering-procedure-in-template-deduction#comment24575293_17005985\">a pretty good description in the comments</a>, I will try to give a step-by-step explanation with a working example.</p>\n<p>First of all, the first sentence from the paragraph you quoted says:</p>\n<blockquote>\n<p id=\"so_17005985_17008568_0\">For each of the templates involved there is the original function type and the <strong>transformed function type</strong>. [...]</p>\n</blockquote>\n<p>Hold on, what is this \"<em>transformed function type</em>\"? Paragraph 14.5.6.2/3 explains that:</p>\n<blockquote>\n<p id=\"so_17005985_17008568_1\">To produce the transformed template, for each type, non-type, or template template parameter (including\n  template parameter packs (14.5.3) thereof) synthesize a unique type, value, or class template respectively\n  and substitute it for each occurrence of that parameter in the function type of the template [...]</p>\n</blockquote>\n<p>This formal description may sound obscure, but it is actually very simple in practice. Let's take this function template as an example:</p>\n<pre><code>template&lt;typename T, typename U&gt;\nvoid foo(T, U) // #1\n</code></pre>\n<p>Now since <code>T</code> and <code>U</code> are type parameters, the above paragraph is asking us to pick a corresponding type argument for <code>T</code> (whatever) and substitute it everywhere in the function signature where <code>T</code> appears, then to do the same for <code>U</code>.</p>\n<p>Now \"<em>synthesizing a unique type</em>\" means that you have to pick a fictitious type you haven't used anywhere else, and we could call that <code>P1</code> (and then pick a <code>P2</code> for <code>U</code>), but that would make our discussion uselessly formal. </p>\n<p>Let's just simplify things and pick <code>int</code> for <code>T</code> and <code>bool</code> for <code>U</code> - we're not using those types anywhere else, so for our purposes, they are just as good as <code>P1</code> and <code>P2</code>. </p>\n<p>So after the transformation, we have:</p>\n<pre><code>void foo(int, bool) // #1b\n</code></pre>\n<p>This is the transformed function type for our original <code>foo()</code> function template.</p>\n<p>So let's continue interpreting the paragraph you quoted. The second sentence says:</p>\n<blockquote>\n<p id=\"so_17005985_17008568_2\">The deduction process uses the transformed type as the argument template and the original type of the <strong>other template</strong> as the parameter template. [...]</p>\n</blockquote>\n<p>Wait, what \"<em>other template</em>\"? We only have one overload of <code>foo()</code> so far. Right, but for the purpose of establishing an ordering between function templates, we need at least two of them, so we'd better create a second one. Let's use:</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo(T const*, X&lt;T&gt;) // #2\n</code></pre>\n<p>Where <code>X</code> is some class template of ours. </p>\n<p>Now what with this second function template? Ah, yes, we need to do the same we previously did for the first overload of <code>foo()</code> and transform it: so again, let's pick some type argument for <code>T</code> and replace <code>T</code> everywhere. I'll pick <code>char</code> this time (we aren't using it anywhere else in this example, so that's as good as some fictitious <code>P3</code>):</p>\n<pre><code>void foo(char const*, X&lt;char&gt;) #2b\n</code></pre>\n<p>Great, now he have two function templates and the corresponding transformed function types. So how to determine whether <code>#1</code> is more specialized than <code>#2</code> or vice versa? </p>\n<p>What we know from the above sentence is that the original templates and their transformed function types must be matched somehow. But how? That's what the third sentence explains:</p>\n<blockquote>\n<p id=\"so_17005985_17008568_3\">This process is done twice for each type involved in the partial ordering comparison: once using the transformed template-1 as the argument template and template-2 as the parameter template and again using the transformed template-2 as the argument template and template-1 as the parameter template</p>\n</blockquote>\n<p>So basically the <em>transformed</em> function type of the first template (<code>#1b</code>) is to be matched against the function type of the <em>original</em> second template (<code>#2</code>). And of course the other way round, the <em>transformed</em> function type of the second second template (<code>#2b</code>) is to be matched against the function type of the <em>original</em> first template (<code>#1</code>).</p>\n<p>If matching will succeed in one direction but not in the other, then we will know that one of the templates is more specialized than the other. Otherwise, neither is more specialized.</p>\n<p>Let's start. First of all, we will have to match:</p>\n<pre><code>void foo(int, bool) // #1b\n</code></pre>\n<p>Against:</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo(T const*, X&lt;T&gt;) // #2\n</code></pre>\n<p>Is there a way we can perform type deduction on <code>T</code> so that <code>T const*</code> becomes exactly <code>int</code> and <code>X&lt;T&gt;</code> becomes exactly <code>bool</code>? (actually, an <em>exact</em> match is not necessary, but there are really few exceptions to this rule and they are not relevant for the purpose of illustrating the partial ordering mechanism, so we'll ignore them).</p>\n<p>Hardly. So let's try matching the other way round. We should match:</p>\n<pre><code>void foo(char const*, X&lt;char&gt;) // #2b\n</code></pre>\n<p>Against:</p>\n<pre><code>template&lt;typename T, typename U&gt;\nvoid foo(T, U) // #1\n</code></pre>\n<p>Can we deduce <code>T</code> and <code>U</code> here to produce an exact match for <code>char const*</code> and <code>X&lt;char&gt;</code>, respectively? Sure! It's trivial. We just pick <code>T = char const*</code> and <code>U = X&lt;char&gt;</code>.</p>\n<p>So we found out that the transformed function type of our first overload of <code>foo()</code> (<code>#1b</code>) cannot be matched against the original function template of our second overload of <code>foo()</code> (<code>#2</code>); on the other hand, the transformed function type of the second overload (<code>#2b</code>) <strong>can</strong> be matched against the original function template of the first overload (<code>#1</code>).</p>\n<p>Conclusion? The second overload of <code>foo()</code> is more specialized than the first one.</p>\n<p>To pick a counter-example, consider these two function templates:</p>\n<pre><code>template&lt;typename T, typename U&gt;\nvoid bar(X&lt;T&gt;, U)\n\ntemplate&lt;typename T, typename U&gt;\nvoid bar(U, T const*)\n</code></pre>\n<p>Which overload is more specialized than the other? I won't go through the whole procedure again, but you can do it, and that should convince you that a match cannot be produced in either direction, since the first overload is more specialized than the second one for what concerns the first parameter, but the second one is more specialized than the first one for what concerns the second parameter.</p>\n<p>Conclusion? Neither function template is more specialized than the other.</p>\n<p>Now in this explanation I have ignored a lot of details, exceptions to the rules, and cryptic passages in the Standard, but the mechanism outlined in the paragraph you quoted is indeed this one.</p>\n<p>Also notice, that the same mechanism outlined above is used to establish a \"<em>more-specialized-than</em>\" ordering between partial specializations of a <em>class</em> template by first creating an associated, fictitious function template for each specialization, and then ordering those function templates through the algorithm described in this answer.</p>\n<p>This is specified by paragraph 14.5.5.2/1 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_17005985_17008568_4\">For two class template partial specializations, the first is at least as specialized as the second if, <strong>given the\n  following rewrite to two function templates, the first function template is at least as specialized as the second\n  according to the ordering rules for function templates</strong> (14.5.6.2):</p>\n<p id=\"so_17005985_17008568_5\">\u2014 the first function template has the same template parameters as the first partial specialization and has\n  a single function parameter whose type is a class template specialization with the template arguments\n  of the first partial specialization, and</p>\n<p id=\"so_17005985_17008568_6\">\u2014 the second function template has the same template parameters as the second partial specialization\n  and has a single function parameter whose type is a class template specialization with the template\n  arguments of the second partial specialization.</p>\n</blockquote>\n<p>Hope this helped.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-06-09T11:26:07.183", "Score": "35", "CreationDate": "2013-06-09T10:13:37.230", "ParentId": "17005985", "CommentCount": "6", "OwnerUserId": "1932150", "LastEditDate": "2017-05-23T10:29:24.460"}});