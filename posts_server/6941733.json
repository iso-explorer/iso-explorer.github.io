post_cb({"6941799": {"ParentId": "6941733", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2011-08-04T12:56:44.493", "Id": "6941799", "LastEditDate": "2017-05-23T12:19:50.857", "OwnerDisplayName": "user195488", "Score": "0", "Body": "<p>You should read the <a href=\"http://floating-point-gui.de/errors/comparison/\" rel=\"nofollow noreferrer\">floating point comparison guide</a>. In short, here are some examples:</p>\n<pre><code>float a = 0.15 + 0.15\nfloat b = 0.1 + 0.2\nif(a == b) // can be false!\nif(a &gt;= b) // can also be false!\n</code></pre>\n<p>The comparison with an epsilon value is what most people do.</p>\n<pre><code>#define EPSILON 0.00000001\n\nbool AreSame(double a, double b)\n{\n    return fabs(a - b) &lt; EPSILON;\n}\n</code></pre>\n<p>In your case, that max value is REALLY big. Adding or subtracting 50 does nothing. Thus they look the same because of the size of the number. See @RichieHindle's answer.</p>\n<p>Here are some additional resources for research.</p>\n<ul>\n<li>See this <a href=\"http://realtimecollisiondetection.net/blog/?p=89\" rel=\"nofollow noreferrer\">blog post</a>.</li>\n<li>Also, there was a <a href=\"https://stackoverflow.com/questions/4915462/how-should-i-do-floating-point-comparison\">stack overflow question on this very topic (language agnostic)</a>.</li>\n</ul>\n", "LastActivityDate": "2011-08-04T12:56:44.493", "LastEditorUserId": "-1"}, "6941788": {"ParentId": "6941733", "CommentCount": "0", "Body": "<p><code>numeric_limits&lt;double&gt;::max()</code></p>\n<p>is a <strong><em>huuuuuge</em></strong> number. But the greater the absolute value of a double, the smaller is its precision. Apparently in this case <code>max-50</code>and <code>max-5</code> are indistinguishable from <code>double</code>'s point of view.</p>\n", "OwnerUserId": "469935", "PostTypeId": "2", "Id": "6941788", "Score": "2", "CreationDate": "2011-08-04T12:56:02.373", "LastActivityDate": "2011-08-04T12:56:02.373"}, "6941733": {"CommentCount": "3", "ViewCount": "953", "PostTypeId": "1", "LastEditorUserId": "878611", "CreationDate": "2011-08-04T12:51:45.673", "LastActivityDate": "2011-08-04T13:18:40.743", "Title": "double variables in c++ are showing equal even when they are not", "FavoriteCount": "3", "LastEditDate": "2011-08-04T13:06:33.850", "Id": "6941733", "Score": "4", "Body": "<p>I just wrote the following code in C++:</p>\n<pre><code>double variable1;\ndouble variable2;\nvariable1=numeric_limits&lt;double&gt;::max()-50;\nvariable2=variable1;\nvariable1=variable1+5;\ncout&lt;&lt;\"\\nVariable1==Variable2 ? \"&lt;&lt;(variable1==variable2);\n</code></pre>\n<p>The answer to the cout statement comes out 1, even when variable2 and variable1 are not equal.Can someone help me with this? Why is this happening?</p>\n<p>I knew the concept of imprecise floating point math but didn't think this would happen with comparing two doubles directly. Also I am getting the same resuklt when I replace variable1 with:</p>\n<pre><code>double variable1=(numeric_limits&lt;double&gt;::max()-10000000000000);\n</code></pre>\n<p>The comparison still shows them as equal. How much would I have to subtract to see them start differing?</p>\n", "Tags": "<c++><c>", "OwnerUserId": "878611", "AnswerCount": "6"}, "6941783": {"ParentId": "6941733", "CommentCount": "4", "Body": "<p>Please read <a href=\"http://download.oracle.com/docs/cd/E19957-01/806-3568/ncg_goldberg.html\" rel=\"nofollow\">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a>.</p>\n", "OwnerUserId": "622220", "PostTypeId": "2", "Id": "6941783", "Score": "-1", "CreationDate": "2011-08-04T12:55:29.357", "LastActivityDate": "2011-08-04T12:55:29.357"}, "6941779": {"ParentId": "6941733", "CommentCount": "10", "Body": "<p><a href=\"http://msdn.microsoft.com/en-us/library/s086ab1z%28v=vs.71%29.aspx\">The maximum value for a double is 1.7976931348623157E+308</a>. Due to lack of precision, adding and removing small values such as 50 and 5 does not actually changes the values of the variable. Thus they stay the same.</p>\n", "OwnerUserId": "361535", "PostTypeId": "2", "Id": "6941779", "Score": "10", "CreationDate": "2011-08-04T12:55:19.777", "LastActivityDate": "2011-08-04T12:55:19.777"}, "bq_ids": {"n4140": {"so_6941733_6942028_1": {"section_id": 5937, "quality": 0.65, "length": 13}, "so_6941733_6942028_0": {"section_id": 7217, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_6941733_6942028_1": {"section_id": 5709, "quality": 0.65, "length": 13}, "so_6941733_6942028_0": {"section_id": 6961, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_6941733_6942028_1": {"section_id": 7421, "quality": 0.65, "length": 13}, "so_6941733_6942028_0": {"section_id": 8726, "quality": 0.5714285714285714, "length": 4}}}, "6941782": {"ParentId": "6941733", "CommentCount": "0", "Body": "<p>There isn't enough precision in a <code>double</code> to differentiate between <code>M</code> and <code>M-45</code> where <code>M</code> is the largest value that can be represented by a <code>double</code>.</p>\n<p>Imagine you're counting atoms to the nearest million.  \"123,456 million atoms\" plus 1 atom is still \"123,456 million atoms\" because there's no space in the \"millions\" counting system for the 1 extra atom to make any difference.</p>\n", "OwnerUserId": "21886", "PostTypeId": "2", "Id": "6941782", "Score": "3", "CreationDate": "2011-08-04T12:55:25.710", "LastActivityDate": "2011-08-04T12:55:25.710"}, "6942028": {"ParentId": "6941733", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From the C++03 standard:</p>\n<blockquote>\n<p id=\"so_6941733_6942028_0\">3.9.1/ [...] The value representation of floating-point types is\n  implementation-defined</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_6941733_6942028_1\">5/ [...] If during the evaluation of an expression, the result is not\n  mathematically defined or not in the range of representable values for\n  its type, the behavior is undefined, unless such an expression is a\n  constant expression (5.19), in which case the program is ill-formed.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_6941733_6942028_2\">18.2.1.2.4/ (about <code>numeric_limits&lt;T&gt;::max()</code>) Maximum finite value.</p>\n</blockquote>\n<p>This implies that once you add something to <code>std::numeric_limits&lt;T&gt;::max()</code>, the behavior of the program is implementation defined if <code>T</code> is floating point, perfectly defined if <code>T</code> is an unsigned type, and undefined otherwise.</p>\n<p>If you happen to have <code>std::numeric_limits&lt;T&gt;::is_iec559 == true</code>, in this case the behavior is defined by IEEE 754. I don't have it handy, so I cannot tell whether <code>variable1</code> is finite or infinite in this case. It seems (according to some lecture notes on IEEE 754 on the internet) that it <a href=\"http://en.wikipedia.org/wiki/IEEE_754-1985#Rounding_floating-point_numbers\" rel=\"nofollow\">depends on the rounding mode</a>..</p>\n", "OwnerUserId": "373025", "LastEditorUserId": "373025", "LastEditDate": "2011-08-04T13:18:40.743", "Id": "6942028", "Score": "0", "CreationDate": "2011-08-04T13:12:28.843", "LastActivityDate": "2011-08-04T13:18:40.743"}});