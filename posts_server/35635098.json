post_cb({"35635098": {"CommentCount": "4", "AcceptedAnswerId": "35635395", "PostTypeId": "1", "LastEditorUserId": "572670", "CreationDate": "2016-02-25T18:15:50.417", "LastActivityDate": "2016-02-25T19:22:51.507", "LastEditDate": "2016-02-25T18:31:18.070", "ViewCount": "166", "FavoriteCount": "0", "Title": "Unable to pass derived Compare to std::priority_queue", "Id": "35635098", "Score": "6", "Body": "<p>I need to pass a derived comparator to <code>std::priority_queue</code>, but for some reason the base class' operator() is being called.</p>\n<p>Here is a minimal code that shows this behavior:</p>\n<pre><code>class Base {\n    public:\n    virtual bool operator() (int l, int r) const {\n        cout &lt;&lt; \"Should not be called\" &lt;&lt; std::endl;\n        return 0;\n    }\n    virtual ~Base() {}\n};\nclass A : public Base { \n    public:\n    bool operator() (int l, int r) const override {\n        cout &lt;&lt; \"Should be called!!!!\";\n        return l &lt; r;\n    }\n};\nint main() {\n    priority_queue&lt;int, vector&lt;int&gt;, Base&gt; pq((A()));\n    pq.push(1);\n    pq.push(2);\n    pq.push(3);\n    pq.push(0);\n    cout &lt;&lt; pq.top();\n    return 0;\n}\n</code></pre>\n<p><a href=\"https://ideone.com/6aZluP\" rel=\"nofollow\">The code is available on ideone as well</a></p>\n<p>Note that I cannot use <code>priority_queue&lt;int, vector&lt;int&gt;, A&gt;</code>, because I have other subclasses for <code>Base</code>, and that will result in a lot of code duplication<sup>1</sup>.</p>\n<p>What am I doing wrong? How can I pass a comparator to the priority_queue that will be used during its life time?</p>\n<hr>\n<p>(1) I know I can bypass the code duplication issue by using template functions that accept <code>priority_queue&lt;int,vector&lt;int&gt;, T&gt;</code> - but I really rather not to.</p>\n</hr>", "Tags": "<c++><c++11><std><priority-queue>", "OwnerUserId": "572670", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_35635098_35635395_0": {"section_id": 1115, "quality": 1.0, "length": 7}}, "n3337": {"so_35635098_35635395_0": {"section_id": 1112, "quality": 1.0, "length": 7}}, "n4659": {"so_35635098_35635395_0": {"section_id": 1206, "quality": 1.0, "length": 7}}}, "35635351": {"ParentId": "35635098", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2016-02-25T18:27:40.190", "Score": "5", "LastEditorUserId": "4342498", "LastEditDate": "2016-02-25T19:22:51.507", "Id": "35635351", "OwnerUserId": "4342498", "Body": "<p>The constructor takes a <code>const Compare&amp;</code> which would not cause any slicing when passing the object to the function but we then have in the <a href=\"http://en.cppreference.com/w/cpp/container/priority_queue/priority_queue\" rel=\"nofollow\">documentation</a></p>\n<blockquote>\n<p id=\"so_35635098_35635351_0\">Copy-constructs the underlying container c with the contents of cont. Copy-constructs the comparison functor comp with the contents of compare.</p>\n</blockquote>\n<p>Since a copy is happening and the template type is <code>Base</code> you are only going to copy and store the <code>Base</code> part of the <code>A</code> object.</p>\n<p>You will have to wrap the comparison object in some sort of wrapper and expose a non virtual <code>operator ()</code> that will call the virtual <code>operator()</code> of the type passed to the <code>priority_queue</code> constructor.</p>\n", "LastActivityDate": "2016-02-25T19:22:51.507"}, "35635395": {"ParentId": "35635098", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2016-02-25T18:30:12.140", "Score": "8", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:07:30.323", "Id": "35635395", "OwnerUserId": "620382", "Body": "<p>The standard specifies <code>Compare comp</code> as value members of the class template in <em>23.6.4.1</em>. The constructors are said to:</p>\n<blockquote>\n<p id=\"so_35635098_35635395_0\">Initializes comp with x and c with y (copy constructing or move\n  constructing as appropriate);</p>\n</blockquote>\n<p>Therefore you have slicing, even if the parameter type is actually a <code>const Compare&amp;</code>.</p>\n<p>To work around that, you could implement a pimpl-wrapper for the comparator. This wrapper would internally keep a <code>Base&amp;</code> to the actual comparator, and in it's non-virtual <code>operator()</code> simply call the <code>virtual operator()</code> of the <code>Base</code> / <code>A</code> comparator.</p>\n<p>Please think carefully about the lifetime of your <code>A</code> Object. Depending on the needed state of your Comparator, you could implement a <a href=\"https://stackoverflow.com/a/17292813/620382\">virtual <code>clone</code>-method</a> in <code>Base</code>. And keep <code>Base</code> as a <code>std::unique_ptr&lt;Base&gt;</code> in your <code>PimplCompare</code> - which you clone in it's copy-ctor. Or you keep it as <code>std::shared_ptr&lt;Base&gt;</code>.</p>\n", "LastActivityDate": "2016-02-25T19:11:35.023"}});