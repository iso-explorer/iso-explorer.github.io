post_cb({"bq_ids": {"n4140": {"so_1092714_47414201_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 638}, "so_1092714_47414201_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 638}, "so_1092714_47414201_3": {"length": 10, "quality": 0.8333333333333334, "section_id": 638}}, "n3337": {"so_1092714_47414201_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 628}, "so_1092714_47414201_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 628}, "so_1092714_47414201_3": {"length": 10, "quality": 0.8333333333333334, "section_id": 628}}, "n4659": {"so_1092714_47414201_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 666}, "so_1092714_47414201_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 666}, "so_1092714_47414201_3": {"length": 10, "quality": 0.8333333333333334, "section_id": 666}}}, "1092724": {"Id": "1092724", "PostTypeId": "2", "Body": "<p>When overload resolution is performed to select the best candidate out of all viable overloads - the compiler ranks all the conversion sequences for each argument for each candidate.  For a function to win (be selected as the best candidate), its conversion ranks for each argument have to be better than or equal to every other function's conversion ranks for that argument AND at least one conversion rank has to be better than all the other function's conversion ranks for a certain argument.</p>\n<p>The user defined conversion (which uses either a constructor or a cast operator) has one of the worst possible ranks (only the ellipsis has a worse rank).  The integral-floating conversion has a better rank (see below for a list of the rankings).</p>\n<p>Thus, the compiler prefers converting an int -&gt; double (using a standard conversion) than converting an int -&gt; A (using a user defined conversion), and therefore it selects f1.</p>\n<p>Edit: Although \"Overload resolution\" works in the background and most of the time does exactly what you would expect (i.e. most programmers won't need to delve into the technicalities) - if you do want to go deeper (but be warned that some of the darker corners of overload resolution are considered to be one of the trickiest aspects for compiler writers to get exactly right in a C++ compiler) refer to the excellent <a href=\"http://rads.stackoverflow.com/amzn/click/0201734842\" rel=\"noreferrer\">\nC++ Templates: The Complete Guide by David Vandevoorde and Nicolai M. Josuttis</a> which provides, in appendix B, one of the best introductions to the machinery behind overload resolution that I have read.  </p>\n<p>Here is an excerpt from B.2:</p>\n<blockquote>\n<p id=\"so_1092714_1092724_0\">Overload resolution ranks the viable\n  candidate functions by comparing how\n  each argument of the call matches the\n  corresponding parameter of the\n  candidates. For one candidate to be\n  considered better than another, the\n  better candidate cannot have any of\n  its parameters be a worse match than\n  the corresponding parameter in the\n  other candidate. \n  ...</p>\n<p id=\"so_1092714_1092724_1\">Given this first principle, we are\n  left with specifying how well a given\n  argument matches the corresponding\n  parameter of a viable candidate. As a\n  first approximation we can rank the\n  possible matches as follows (from best\n  to worst):</p>\n<p id=\"so_1092714_1092724_2\">Perfect match. The parameter has the\n  type of the expression, or it has a\n  type that is a reference to the type\n  of the expression (possibly with added\n  const and/or volatile qualifiers).</p>\n<p id=\"so_1092714_1092724_3\">Match with minor adjustments. This\n  includes, for example, the decay of an\n  array variable to a pointer to its\n  first element, or the addition of\n  const to match an argument of type\n  int** to a parameter of type int\n  const* const*.</p>\n<p id=\"so_1092714_1092724_4\">Match with promotion. Promotion is a\n  kind of implicit conversion that\n  includes the conversion of small\n  integral types (such as bool, char,\n  short, and sometimes enumerations) to\n  int, unsigned int, long or unsigned\n  long, and the conversion of float to\n  double.</p>\n<p id=\"so_1092714_1092724_5\">Match with standard conversions only.\n  This includes any sort of standard\n  conversion (such as int to float) but\n  excludes the implicit call to a\n  conversion operator or a converting\n  constructor.</p>\n<p id=\"so_1092714_1092724_6\">Match with user-defined conversions.\n  This allows any kind of implicit\n  conversion.</p>\n<p id=\"so_1092714_1092724_7\">Match with ellipsis. An ellipsis\n  parameter can match almost any type\n  (but non-POD class types result in\n  undefined behavior).</p>\n</blockquote>\n<p>But that's just the beginning - if you are intrigued - I urge you to read the book and then the relevant portions of the standard :)</p>\n", "LastEditorUserId": "51103", "LastActivityDate": "2009-07-09T06:53:55.390", "Score": "14", "CreationDate": "2009-07-07T14:37:56.810", "ParentId": "1092714", "CommentCount": "0", "OwnerUserId": "51103", "LastEditDate": "2009-07-09T06:53:55.390"}, "1092714": {"ViewCount": "2163", "Body": "<p>I have the following code:</p>\n<pre><code>Some functions:\n\nA::A(int i_a) {cout&lt;&lt;\"int Ctor\\n\";}          //conversion constructor\n\nvoid h(double d) {cout&lt;&lt;\"double param\\n\";}   //f1\nvoid h(A a) {cout&lt;&lt;\"A param\\n\";}             //f2\n</code></pre>\n<p>In the main function:</p>\n<pre><code>h(1);\n</code></pre>\n<p>The function that h(1) calls is f1. </p>\n<p>My question is why does it choose to call that. 1 is an int and therefore requires \nimplicit conversion to double. It could just as easily convert the int into an A using the \nconversion constructor defined above. Why don't I get an error? What are the \nprecedence rules with casting?</p>\n<hr>\n<p>N.b. I've posted above the code that I think will be necessary to answer the question, \nbut below I'm posting the entire code:</p>\n<pre><code> #include &lt;iostream&gt;\n using namespace std;\n class B;\n class A {\n public:\n explicit A(const B&amp;) {cout&lt;&lt;\"Ctor through B\\n\";}\n A() {cout&lt;&lt;\"Default Ctor\\n\";}\n A(int i_a) {cout&lt;&lt;\"int Ctor\\n\";}\n operator int() {cout&lt;&lt;\"A =&gt; int\\n\"; return 2;}\n };\n class B {\n public:\n operator A() const {cout&lt;&lt;\"B =&gt; A\\n\"; A a; return a;}\n };\n void h(double d) {cout&lt;&lt;\"double param\\n\";}\n void h(A a) {cout&lt;&lt;\"A param\\n\";}\n void f(const A&amp; a)\n {\n cout&lt;&lt;\"f function\\n\";\n //Without the const it will never try to convert\n }\n void main()\n {\n B b;\n cout &lt;&lt;\"-----------------\\n\";\n f(b);\n cout &lt;&lt;\"-----------------\\n\";\n h(1);\n }\n</code></pre>\n</hr>", "AcceptedAnswerId": "1092724", "Title": "conversion precedence in c++", "CreationDate": "2009-07-07T14:35:48.917", "Id": "1092714", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2009-07-07T14:43:30.263", "LastEditorUserId": "63309", "LastActivityDate": "2017-11-21T13:24:50.263", "Score": "4", "OwnerUserId": "99213", "Tags": "<c++>", "AnswerCount": "2"}, "47414201": {"Id": "47414201", "PostTypeId": "2", "Body": "<p>Addition from standard(N4687)</p>\n<blockquote>\n<p id=\"so_1092714_47414201_0\">2 </p>\n<p id=\"so_1092714_47414201_1\">When comparing the basic forms of implicit conversion sequences (as\n  defined in 16.3.3.1) </p>\n<p id=\"so_1092714_47414201_2\">\u2014 (2.1) a standard conversion sequence\n  (16.3.3.1.1) is a better conversion sequence than a user-defined\n  conversion sequence or an ellipsis conversion sequence, and </p>\n<p id=\"so_1092714_47414201_3\">\u2014 (2.2) a\n  user-defined conversion sequence (16.3.3.1.2) is a better conversion\n  sequence than an ellipsis conversion sequence (16.3.3.1.3).</p>\n</blockquote>\n", "LastActivityDate": "2017-11-21T13:24:50.263", "CommentCount": "0", "CreationDate": "2017-11-21T13:24:50.263", "ParentId": "1092714", "Score": "0", "OwnerUserId": "6949852"}});