post_cb({"2170050": {"ParentId": "2169932", "CommentCount": "0", "Body": "<p>Good point. I guess there are two things to look at: 1) as you pointed out the non-class rvalue thingsy and 2) how overload resolution works:</p>\n<blockquote>\n<p id=\"so_2169932_2170050_0\">The selection criteria for the best\n  function are the number of arguments,\n  how well the arguments match the\n  parameter-type-list of the candidate\n  function, [...]</p>\n</blockquote>\n<p>I haven't seen anything in the standard that tells me non-class rvalues are treated specially during overload resolution.</p>\n<p>Your question is covered in the draft of the standard I have though (N-4411) somewhat:</p>\n<p>What does come into play is however a parallel reading of reference binding, implicit conversion sequences, references, and overload resolution in general:</p>\n<p><strong>13.3.3.1.4 Reference binding</strong></p>\n<blockquote>\n<p id=\"so_2169932_2170050_1\">2 When a parameter of reference type\n  is not bound directly to an argument\n  expression, the conversion sequence\n      is the one required to convert the argument expression to the underlying\n  type of the reference according\n      to 13.3.3.1.</p>\n</blockquote>\n<p>and</p>\n<p><strong>13.3.3.2 Ranking implicit conversion sequences</strong></p>\n<blockquote>\n<p id=\"so_2169932_2170050_2\">3 Two implicit conversion sequences of\n  the same form are indistinguishable\n  conversion sequences unless one of the\n  following rules applies:</p>\n<p id=\"so_2169932_2170050_3\">\u2014 Standard conversion sequence S1 is a better conversion sequence than\n  standard<br>\n         conversion sequence S2 if</br></p>\n<p id=\"so_2169932_2170050_4\">\u2014 S1 and S2 are reference bindings (8.5.3) and neither refers to an\n  implicit object parameter of a\n  nonstatic\n      member function declared without a ref-qualifier, and either S1 binds an\n  lvalue reference\n      to an lvalue and S2 binds an rvalue reference or S1 binds an rvalue\n  reference to an rvalue and S2\n      binds an lvalue reference.</p>\n<p id=\"so_2169932_2170050_5\">[ Example:</p>\n</blockquote>\n<pre><code>int i;\nint f();\nint g(const int&amp;);\nint g(const int&amp;&amp;);\nint j = g(i); // calls g(const int&amp;)\nint k = g(f()); // calls g(const int&amp;&amp;)\n</code></pre>\n", "OwnerUserId": "66692", "PostTypeId": "2", "Id": "2170050", "Score": "2", "CreationDate": "2010-01-31T00:16:24.547", "LastActivityDate": "2010-01-31T00:16:24.547"}, "bq_ids": {"n4140": {"so_2169932_2170050_3": {"section_id": 603, "quality": 0.8888888888888888, "length": 8}, "so_2169932_2170050_1": {"section_id": 626, "quality": 0.95, "length": 19}, "so_2169932_2170050_0": {"section_id": 562, "quality": 0.9285714285714286, "length": 13}, "so_2169932_2170050_4": {"section_id": 639, "quality": 0.75, "length": 21}, "so_2169932_2170050_2": {"section_id": 639, "quality": 1.0, "length": 13}}, "n3337": {"so_2169932_2170050_3": {"section_id": 593, "quality": 0.8888888888888888, "length": 8}, "so_2169932_2170050_1": {"section_id": 616, "quality": 0.95, "length": 19}, "so_2169932_2170050_0": {"section_id": 553, "quality": 0.9285714285714286, "length": 13}, "so_2169932_2170050_4": {"section_id": 629, "quality": 0.75, "length": 21}, "so_2169932_2170050_2": {"section_id": 629, "quality": 1.0, "length": 13}}, "n4659": {"so_2169932_2170050_3": {"section_id": 629, "quality": 0.8888888888888888, "length": 8}, "so_2169932_2170050_1": {"section_id": 652, "quality": 0.85, "length": 17}, "so_2169932_2170050_0": {"section_id": 585, "quality": 0.9285714285714286, "length": 13}, "so_2169932_2170050_4": {"section_id": 667, "quality": 0.75, "length": 21}, "so_2169932_2170050_2": {"section_id": 667, "quality": 1.0, "length": 13}}}, "2170078": {"ParentId": "2169932", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The committee already seems to be aware that there's a problem in this part of the standard. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#690\" rel=\"noreferrer\">CWG issue 690</a> talks about a somewhat similar problem with exactly the same part of the standard (in the \"additional note\" from September, 2009). I'd guess new language will be drafted for that part of the standard soon.</p>\n<p>Edit: I've just submitted a post on comp.std.c++, noting the problem and suggesting new wording for the relevant piece of the standard. Unfortunately, being a moderated newsgroup, nearly everybody will probably have forgotten this question by the time it makes it through the approval queue there.</p>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2010-01-31T01:03:45.720", "Id": "2170078", "Score": "11", "CreationDate": "2010-01-31T00:27:22.043", "LastActivityDate": "2010-01-31T01:03:45.720"}, "2169932": {"CommentCount": "5", "AcceptedAnswerId": "2170078", "PostTypeId": "1", "LastEditorUserId": "500104", "CreationDate": "2010-01-30T23:31:52.680", "LastActivityDate": "2012-05-30T06:26:00.803", "LastEditDate": "2012-05-30T06:26:00.803", "ViewCount": "1060", "FavoriteCount": "11", "Title": "non-class rvalues always have cv-unqualified types", "Id": "2169932", "Score": "33", "Body": "<p>\u00a73.10 section 9 says \"non-class rvalues always have cv-unqualified types\". That made me wonder...</p>\n<pre><code>int foo()\n{\n    return 5;\n}\n\nconst int bar()\n{\n    return 5;\n}\n\nvoid pass_int(int&amp;&amp; i)\n{\n    std::cout &lt;&lt; \"rvalue\\n\";\n}\n\nvoid pass_int(const int&amp;&amp; i)\n{\n    std::cout &lt;&lt; \"const rvalue\\n\";\n}\n\nint main()\n{\n    pass_int(foo()); // prints \"rvalue\"\n    pass_int(bar()); // prints \"const rvalue\"\n}\n</code></pre>\n<p>According to the standard, there is no such thing as a const rvalue for non-class types, yet <code>bar()</code> prefers to bind to <code>const int&amp;&amp;</code>. Is this a compiler bug?</p>\n<p>EDIT: Apparently, <code>this</code> is also a const rvalue :)</p>\n<p>EDIT: This issue seems to be fixed in g++ 4.5.0, both lines print \"rvalue\" now.</p>\n", "Tags": "<c++><c++11><rvalue-reference><rvalue>", "OwnerUserId": "252000", "AnswerCount": "2"}});