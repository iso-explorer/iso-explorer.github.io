post_cb({"24156872": {"Id": "24156872", "PostTypeId": "2", "Body": "<p>Move semantics in c++ are not related to emplace/insert methods. The latter are just one of the cases which uses move semantics to gain performance.</p>\n<p>You should learn about rvalue references and move semantics in order to understand why p has undefined value after the line \"m.emplace(\"foo\", std::move(p));\"</p>\n<p>You can read in in detail for example here:\n<a href=\"http://www.slideshare.net/oliora/hot-c11-1-rvalue-references-and-move-semantics\" rel=\"nofollow\">http://www.slideshare.net/oliora/hot-c11-1-rvalue-references-and-move-semantics</a></p>\n<p>In short, std::move(p) statement tells compiler that you do not care about p's contents anymore and totally okey that they will be moved somewhere else. In practice, std::move(p) converts p to rvalue reference type (T&amp;&amp;). rvalue existed in c++ before c++11 without having the \"official\" type. For example expression (string(\"foo\") + string(\"bar\")) produces rvalue which is a string with an allocated buffer containing \"foobar\". Before c++11 you could not use the fact that this expression is totally temporary and is going to vanish in a second (besides in compiler optimizations). Now you get this as part of the language:</p>\n<pre><code>v.emplace_back(string(\"foo\") + string(\"bar\"))\n</code></pre>\n<p>is going to take the temporary string and move its contents directly into the container (no redundant allocations). </p>\n<p>It works elegantly with temporary expressions but you can not do it directly with variables (which are the opposite of rvalues). However, in some cases you <strong>know</strong> that you do not need this variable anymore and you want to <strong>move it</strong> some where else. For that you use std::move(..) which tells the compiler to treat this variable as an rvalue. You need to understand that you can not use it afterwards. That is the contract between you and the compiler. </p>\n", "LastActivityDate": "2014-06-11T07:17:39.330", "Score": "3", "CreationDate": "2014-06-11T07:17:39.330", "ParentId": "24156369", "CommentCount": "0", "OwnerUserId": "2280111"}, "24156369": {"ViewCount": "1590", "Body": "<p>Currently I'm reading C++1y papers, for now I'm trying to understand the n3873 paper titled <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2014/n3873.html\">Improved insertion interface for unique-key maps</a>. The paper states that there's a problem with insert and emplace methods, it illustrates the problem with the following example:</p>\n<pre><code>std::map&lt;std::string, std::unique_ptr&lt;Foo&gt;&gt; m;\nm[\"foo\"];\n\nstd::unique_ptr&lt;Foo&gt; p(new Foo);\nauto res = m.emplace(\"foo\", std::move(p));\n</code></pre>\n<p>And after the code above, it express the following:</p>\n<blockquote>\n<p id=\"so_24156369_24156369_0\">What is the value of <code>p</code>? It is currently unspecified whether <code>p</code> has been moved-from. (The answer is that it depends on the library implementation.)</p>\n</blockquote>\n<p>Well, I'm having troubles while looking for the explanation of the previous quote, mainly because I'm unable to find where in the standard is specified that in a code like the above to move or not to move <code>p</code> is implementation defined; looking to the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf\">n3690 standard</a> associative containers section (23.2.4) about the <code>emplace(args)</code> (Inserts a <code>value_type</code> object <code>t</code> constructed with <code>std::forward&lt;Args&gt;(args)</code>) and <code>insert(t)</code> methods only mentions that the value is inserted or emplaced...</p>\n<blockquote>\n<p id=\"so_24156369_24156369_1\">... if and only if there is no element in the container with key equivalent to the key of <code>t</code>.</p>\n</blockquote>\n<p>Not a word about moving (or not) the <code>t</code> value; on the other hand, the <code>p</code> managed memory is freed anyways (if it is moved <code>p</code> is freed after the no-insertion, and if isn't moved is freed ad the end of the scope) isn't it?</p>\n<hr>\n<p>After the introduction, let me ask the following questions:</p>\n<ul>\n<li>Why moving a value while inserting/emplacing it into an associative container which already have the inserted key, sets the value in an unspecified state?</li>\n<li>Where is worded that this operation is implementation-defined?</li>\n<li>What happens with the <code>p</code> of the example? Is it really freed?</li>\n</ul>\n<p>Please, try to forgive if the question looks silly or with an obvious answer, it could be due my lack of english understanding skills or because I'm not used to dive into the standard  papers. Any guidance would be appreciated.</p>\n</hr>", "AcceptedAnswerId": "24156559", "Title": "std::map emplace/insert moving value being inserted", "CreationDate": "2014-06-11T06:49:47.277", "Id": "24156369", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-08-19T06:38:08.103", "LastEditorUserId": "241631", "LastActivityDate": "2014-08-19T06:38:08.103", "Score": "10", "OwnerUserId": "499359", "Tags": "<c++><map><c++14>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_24156369_24156369_1": {"length": 6, "quality": 1.0, "section_id": 744}, "so_24156369_24795559_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 744}, "so_24156369_24166309_0": {"length": 11, "quality": 1.0, "section_id": 6325}}, "n3337": {"so_24156369_24156369_1": {"length": 6, "quality": 1.0, "section_id": 733}, "so_24156369_24795559_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 733}, "so_24156369_24166309_0": {"length": 11, "quality": 1.0, "section_id": 6082}}, "n4659": {"so_24156369_24156369_1": {"length": 6, "quality": 1.0, "section_id": 802}, "so_24156369_24795559_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 802}, "so_24156369_24166309_0": {"length": 11, "quality": 1.0, "section_id": 7835}}}, "24795559": {"Id": "24795559", "PostTypeId": "2", "Body": "<p>Contrary to what the linked article says, I would say the language of the standard almost guarantees that this code does the wrong thing: it moves the pointer from <code>p</code>, and then destroys the object originally pointed to by <code>p</code> because in the end nothing gets inserted into the map <code>m</code> (since the key constructed from <code>\"foo\"</code> is already present). [I say \"almost\" only because the language of the Standard is less clear than one should wish; obviously the question at hand simply wasn't on the mind of whoever wrote this.]</p>\n<p>Citing from table 102 in 23.2.4, entry <code>a_uniq.emplace(args)</code>, the effect is </p>\n<blockquote>\n<p id=\"so_24156369_24795559_0\">Inserts a <code>value_type</code> object <code>t</code> constructed with <code>std::forward&lt;Args&gt;(args)...</code>if and only if there is no element in the container with key equivalent to the key of <code>t</code>.</p>\n</blockquote>\n<p>Here <code>value_type</code> for the case of a <code>std::map</code> is <code>std::pair&lt;const Key, T&gt;</code>, in the example with <code>Key</code> equal to <code>std::string</code> and <code>T</code> equal to <code>std::unique_ptr&lt;Foo&gt;</code>. So the object <code>t</code> referred to is (or would be) constructed as</p>\n<pre><code>std::pair&lt;const std::string, std::unique_ptr&lt;Foo&gt;&gt; t(\"foo\", std::move(p));\n</code></pre>\n<p>and the \"key of <code>t</code>\" is the first component of that pair. As the linked article indicates, the language is imprecise due to the conflation of \u201cconstruct\u201d and \u201cinsert\u201d: one might construe that \"if and only if\" refers to both of them, and that therefore <code>t</code> is <em>neither constructed nor inserted</em> in case there is an element in the container with key equivalent to the key of <code>t</code>; then in this scenario nothing would be moved from <code>p</code> (because of the lack of construction) and <code>p</code> would not become null. However, there is a logical inconsistency in this reading of the cited phrase: if <code>t</code> should never be constructed, what on earth could the \"key of <code>t</code>\" refer to? Therefore I think the only reasonable reading of this text is: the object <code>t</code> is (unconditionally) constructed as indicated, and then <code>t</code> is inserted into the container if and only if there is no element in the container with key equivalent to the key of <code>t</code>. In the case <code>t</code> is not inserted (as in the example), the temporary will disappear on returning from the call to <code>emplace</code>, destroying the resource moved into it as it goes.</p>\n<p>Of course this does not mean it is impossible for an implementation to do the right thing: <em>separately</em> construct the first (key) component of <code>t</code>, look up that key in the container, and <em>only if it is not found</em> construct the complete pair <code>t</code> (at this time moving the mapped-to object form <code>p</code> to the second component of <code>t</code>) and inserting that. (This does require that the key type is copy or move constructible, since what will become the first component of <code>t</code> is initially constructed in a different place.) It is exactly because such implementation is possible that the article proposes to provide a means to reliably ask for such behaviour. But the current language of the standard does not seem to give licence to such an implementation, and even less an obligation to behave like that.</p>\n<hr>\n<p>Let me add that I ran into this problem in practice, because I naively thought that having a nice new method <code>emplace</code> it would certainly be defined to work well with move semantics. So I wrote something along the lines of:</p>\n<pre><code>auto p = m.emplace(key,std::move(mapped_to_value));\nif (not p.second) // no insertion took place\n{ /* some action with value p.first-&gt;second about to be overwritten here */\n  p.first-&gt;second = std::move(mapped_to_value) // replace mapped-to value\n}\n</code></pre>\n<p>It turned out to be not so, and in my \"mapped to\" type, which happened to contain both a shared pointer and a unique pointer, the shared pointer component behaved fine, but the unique pointer component would become null in case a previous entry in the map was overwritten. Given that this idiom does not work, I rewrote it to</p>\n<pre><code>auto range = m.equal_range(key);\nif (range.first==range.second) // the key was previously absent; insert a pair\n  m.emplace_hint(range.first,key,std::move(mapped_to_value));\nelse // the key was present, replace the associated value\n{ /* some action with value range.first-&gt;second about to be overwritten here */\n  range.first-&gt;second = std::move(mapped_to_value) // replace mapped-to value\n}\n</code></pre>\n<p>This is a reasonable work-around that works without much assumptions about the mapped-to type (notably it need not be default-constructible or copy-constructible, just move-constructible and move-assignable).</p>\n<p>It looks like this idiom should even work for <code>unordered_map</code>, though I did not try it for that case. In fact looking closer, it works, but the use of <code>emplace_hint</code> is pointless, since unlike for the case of <code>std::map</code>, the method <code>std::unordered_map::equal_range</code> is <strong>obliged</strong> in case of an absent key to return a pair of iterators both equal to the (uninformative) value returned by <code>std::unordered_map::end</code>, rather than some other pair of equal iterators. Indeed it seems that <code>std::unordered_map::emplace_hint</code>, which is allowed to ignore the hint, is almost forced to do so, since either the key is already present and <code>emplace_hint</code> should do nothing (except gobble up the resources possibly moved into its temporary pair <code>t</code>), or else (no such key is present) there is no way to obtain a useful hint, since neither the methods <code>m.find</code> nor <code>m.equal_range</code> are allowed to return anything else than <code>m.end()</code> when invoked with a key that turns out to be absent.</p>\n</hr>", "LastEditorUserId": "1436796", "LastActivityDate": "2014-07-17T11:49:50.150", "Score": "2", "CreationDate": "2014-07-17T05:31:55.497", "ParentId": "24156369", "CommentCount": "0", "LastEditDate": "2014-07-17T11:49:50.150", "OwnerUserId": "1436796"}, "24166309": {"Id": "24166309", "PostTypeId": "2", "Body": "<p>I think the third bullet of 17.6.4.9/1 [res.on.arguments] applies here (quoting N3936):</p>\n<blockquote>\n<p id=\"so_24156369_24166309_0\">Each of the following applies to all arguments to functions defined in the C++ standard library, unless explicitly stated otherwise.</p>\n<ul>\n<li>If an argument to a function has an invalid value (such as a value outside the domain of the function or a pointer invalid for its intended use), the behavior is undefined.</li>\n<li>If a function argument is described as being an array, the pointer actually passed to the function shall have a value such that all address computations and accesses to objects (that would be valid if the pointer did point to the first element of such an array) are in fact valid.</li>\n<li>If a function argument binds to an rvalue reference parameter, the implementation may assume that\n  this parameter is a unique reference to this argument. [ Note: If the parameter is a generic parameter of the form <code>T&amp;&amp;</code> and an lvalue of type <code>A</code> is bound, the argument binds to an lvalue reference (14.8.2.1) and thus is not covered by the previous sentence. \u2014end note ] [ Note: If a program casts an lvalue to an xvalue while passing that lvalue to a library function (e.g. by calling the function with the argument <code>move(x)</code>), the program is effectively asking that function to treat that lvalue as a temporary. The implementation is free to optimize away aliasing checks which might be needed if the argument was an lvalue. \u2014end note ]</li>\n</ul>\n</blockquote>\n<p>By passing an rvalue expression referring to an object to a reference parameter, you are essentially giving the standard library permission to do whatever it likes with that object. It may move from the object, or not, or modify it in any other way that is convenient for the standard library implementation.</p>\n", "LastActivityDate": "2014-06-11T15:02:13.273", "Score": "2", "CreationDate": "2014-06-11T15:02:13.273", "ParentId": "24156369", "CommentCount": "0", "OwnerUserId": "923854"}, "24156559": {"Id": "24156559", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24156369_24156559_0\">Not a word about moving (or not)</p>\n</blockquote>\n<p>This is precisely the problem, it's left unspecified under what conditions the <code>mapped_type</code> will be moved. </p>\n<blockquote>\n<p id=\"so_24156369_24156559_1\">Why moving a value while inserting/emplacing it into an associative container which already have the inserted key, sets the value in an unspecified state?</p>\n</blockquote>\n<p>There's nothing preventing an implementation from moving the <code>unique_ptr</code> into a temporary variable first, and then searching for the key <code>\"foo\"</code>. In this case, regardless of whether the <code>map</code> already contains the key or not, <code>p == nullptr</code> when the call to <code>emplace</code> returns.</p>\n<p>Conversely, an implementation could conditionally move depending on whether the key exists or not. Then, if the key exists, <code>p != nullptr</code> when the function call returns. Both methods are equally correct, and in the first case there's no way to retrieve the original contents of <code>p</code> even if the insertion never takes place, it will be destroyed by the time <code>emplace</code> returns.</p>\n<p>The proposed <code>emplace_stable()</code> and <code>emplace_or_update()</code> functions are to make the behavior predictable under all circumstances.</p>\n<blockquote>\n<p id=\"so_24156369_24156559_2\">Where is worded that this operation is implementation-defined?</p>\n</blockquote>\n<p>It's not specified as implementation defined, it's under specified, allowing implementations too much latitude, potentially resulting in behavior that's not always desirable.</p>\n<blockquote>\n<p id=\"so_24156369_24156559_3\">What happens with the <code>p</code> of the example? Is it really freed?</p>\n</blockquote>\n<p>In the example you've shown the contents of <code>p</code> will not be inserted into the map (since the key <code>\"foo\"</code> already exists). But <code>p</code> may or may not be moved from when the call to <code>emplace</code> returns.</p>\n<p>There will never be a resource leak in any case. If the implementation unconditionally moves <code>p</code> it'll move it into a local copy, which will either be destroyed if the key exists, or inserted into the map if the key doesn't exist.</p>\n<p>On the other hand, if the implementation conditionally moves <code>p</code>, it'll either be inserted into the <code>map</code>, or <code>p</code> will own it when <code>emplace</code> returns. In the latter case, it'll, of course, be destroyed when <code>p</code> goes out of scope.</p>\n", "LastEditorUserId": "241631", "LastActivityDate": "2014-06-11T17:13:34.257", "Score": "11", "CreationDate": "2014-06-11T07:00:26.367", "ParentId": "24156369", "CommentCount": "3", "LastEditDate": "2014-06-11T17:13:34.257", "OwnerUserId": "241631"}});