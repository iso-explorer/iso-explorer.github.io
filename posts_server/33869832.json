post_cb({"33870295": {"ParentId": "33869832", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>As far as standard C++ is concerned, they cannot differ. C and C++ are similar on this point.</p>\n<p>But there are many architectures out there with compilers written for them that do not follow this rule. Indeed then we are not really talking about standard C++, and some folk would argue then that the language is not C++, but my reading of your question (prior to the addition of the language lawyer tag) is more about the possibility.</p>\n<p>In which case, it is possible. You may well find that a pointer to ROM (therefore const) is a different size to a pointer to RAM (const or non const.)</p>\n<p>If you know for sure that your code will only wind up on a standards complaint compiler then your assumption is correct. If not, then I'd think carefully about relying on their sizes being the same.</p>\n", "OwnerUserId": "2380830", "LastEditorUserId": "2380830", "LastEditDate": "2015-11-24T07:39:35.367", "Id": "33870295", "Score": "2", "CreationDate": "2015-11-23T11:45:14.760", "LastActivityDate": "2015-11-24T07:39:35.367"}, "33879879": {"ParentId": "33869832", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Microchip released such a C compiler where the <code>sizeof(T*)</code> was 2 but <code>sizeof(const T*)</code> was 3.</p>\n<p>The C compiler was not standards-compliant in a few ways, so this says nothing about this being valid (I suspect it isn't and other answers agree).</p>\n", "OwnerUserId": "14768", "LastEditorUserId": "1757964", "LastEditDate": "2015-11-27T00:28:24.823", "Id": "33879879", "Score": "8", "CreationDate": "2015-11-23T20:16:37.320", "LastActivityDate": "2015-11-27T00:28:24.823"}, "33869832": {"CommentCount": "1", "AcceptedAnswerId": "33869976", "PostTypeId": "1", "LastEditorUserId": "2692339", "CreationDate": "2015-11-23T11:20:42.327", "LastActivityDate": "2015-11-27T00:28:24.823", "LastEditDate": "2015-11-23T15:27:44.440", "ViewCount": "3263", "FavoriteCount": "4", "Title": "Could it be the case that sizeof(T*) != sizeof(const T*)?", "Id": "33869832", "Score": "66", "Body": "<p>I'm arguing with my boss about this. They say \"Yes they can be different.\"</p>\n<p>Is it possible that <code>sizeof(T*) != sizeof(const T*)</code> for a type <code>T</code>?</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "3415258", "AnswerCount": "4"}, "33869976": {"ParentId": "33869832", "PostTypeId": "2", "CommentCount": "21", "Body": "<p>No, they can't be different. For sufficiently different <code>T1</code> and <code>T2</code>, <code>sizeof(T1 *)</code> can be different from <code>sizeof(T2 *)</code>, but if <code>T2</code> is just <code>const T1</code>, then:</p>\n<blockquote>\n<p id=\"so_33869832_33869976_0\"><strong>3.9.2 Compound types [basic.compound]</strong></p>\n<p id=\"so_33869832_33869976_1\">3 [...] Pointers to cv-qualified and cv-unqualified versions (3.9.3) of layout-compatible types shall have the same value representation and alignment requirements (3.11). [...]</p>\n</blockquote>\n<p>And any type <code>T</code> is layout-compatible with itself:</p>\n<blockquote>\n<p id=\"so_33869832_33869976_2\"><strong>3.9 Types [basic.types]</strong></p>\n<p id=\"so_33869832_33869976_3\">11 If two types <code>T1</code> and <code>T2</code> are the same type, then <code>T1</code> and <code>T2</code> are <em>layout-compatible</em> types. [...]</p>\n</blockquote>\n<hr>\n<p>Value representation is in relation to the object representation, you can't have the same value representation without also having the same object representation. The latter means the same number of bits is required.</p>\n<blockquote>\n<p id=\"so_33869832_33869976_4\"><strong>3.9 Types [basic.types]</strong></p>\n<p id=\"so_33869832_33869976_5\">4 The <em>object representation</em> of an object of type <code>T</code> is the sequence of <em>N</em> <code>unsigned char</code> objects taken up by the object of type <code>T</code>, where <em>N</em> equals <code>sizeof(T)</code>. The <em>value representation</em> of an object is the set of bits that hold the value of type <code>T</code>. For trivially copyable types, the value representation is a set of bits in the object representation that determines a <em>value</em>, which is one discrete element of an implementation-defined set of values.<sup>44</sup></p>\n<p id=\"so_33869832_33869976_6\">44) The intent is that the memory model of C++ is compatible with that of ISO/IEC 9899 Programming Language C.</p>\n</blockquote>\n<p>The point of the requirement, the reason it doesn't just say that the two types have the same object representation, is that <code>T *</code> and <code>const T *</code> not only have the same number of bits, but also that it's the same bits in <code>T *</code> and <code>const T *</code> that make up the value. This is meant to guarantee not only that <code>sizeof(T *) == sizeof(const T *)</code>, but it means even that you can use <code>memcpy</code> to copy a <code>T *</code> pointer value to a <code>const T *</code> pointer value or vice versa and get a meaningful result, the exact same result you would get with <code>const_cast</code>.</p>\n<p>The alignment requirements provide some additional guarantees too, but they're complicated to explain properly and not directly relevant to this question, and there are issues in the standard that undermine some of the intended guarantees, so I think that's best left ignored here.</p>\n</hr>", "OwnerUserId": "743382", "LastEditorUserId": "743382", "LastEditDate": "2015-11-23T20:33:36.600", "Id": "33869976", "Score": "80", "CreationDate": "2015-11-23T11:28:06.113", "LastActivityDate": "2015-11-23T20:33:36.600"}, "bq_ids": {"n4140": {"so_33869832_33869976_1": {"section_id": 7223, "quality": 0.8571428571428571, "length": 12}, "so_33869832_33869976_3": {"section_id": 7209, "quality": 0.8571428571428571, "length": 6}, "so_33869832_33869976_6": {"section_id": 7202, "quality": 0.8888888888888888, "length": 8}, "so_33869832_33869976_5": {"section_id": 7202, "quality": 0.8095238095238095, "length": 34}}, "n3337": {"so_33869832_33869976_1": {"section_id": 6967, "quality": 0.8571428571428571, "length": 12}, "so_33869832_33869976_3": {"section_id": 6953, "quality": 1.0, "length": 7}, "so_33869832_33869976_6": {"section_id": 6946, "quality": 0.8888888888888888, "length": 8}, "so_33869832_33869976_5": {"section_id": 6946, "quality": 0.8095238095238095, "length": 34}}, "n4659": {"so_33869832_33869976_1": {"section_id": 8732, "quality": 0.6428571428571429, "length": 9}, "so_33869832_33869976_3": {"section_id": 6124, "quality": 0.7142857142857143, "length": 5}, "so_33869832_33869976_6": {"section_id": 8711, "quality": 0.8888888888888888, "length": 8}, "so_33869832_33869976_5": {"section_id": 8711, "quality": 0.8095238095238095, "length": 34}}}, "33872377": {"ParentId": "33869832", "CommentCount": "6", "Body": "<p>Hmm, this is highly esoterical, but I'm thinking that theoretically there <em>could</em> be an architecture which has, say, 256 bytes of RAM in address 0 and, say, some kilobytes of ROM in higher addresses. And there <em>could</em> be a compiler that would create a 8-bit pointer for <code>int *i</code> because 8 bits is enough to hold the address of any object in the highly limited RAM area and any mutable object of course is implicitly known to be in the RAM area. Pointers of type <code>const int *i</code> would need 16 bits so that they could point to any location in the address space. The 8-bit pointer <code>int *i</code> is castable to a 16-bit pointer <code>const int *i</code> (but not vice versa) so the castability requirement of C standard would be satisfied. </p>\n<p>But if there's such an architecture in existense, I'd sure like to see it (but not write code for it) :)</p>\n", "OwnerUserId": "4186130", "PostTypeId": "2", "Id": "33872377", "Score": "5", "CreationDate": "2015-11-23T13:32:50.940", "LastActivityDate": "2015-11-23T13:32:50.940"}});