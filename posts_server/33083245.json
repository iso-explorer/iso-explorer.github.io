post_cb({"bq_ids": {"n4140": {"so_33083245_33083361_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 1617}}, "n3337": {"so_33083245_33083361_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 1613}}, "n4659": {"so_33083245_33083361_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 1770}}}, "33088349": {"Id": "33088349", "PostTypeId": "2", "Body": "<p>@Bartek Banachewicz's <a href=\"https://stackoverflow.com/a/33083361/1593077\">answer</a> explains which circumstances allow you to make your assumption. I would like to add that</p>\n<h3>this is bad programming.</h3>\n<p>Why? For several reasons:</p>\n<ol>\n<li>You have to be a language lawyer just to be sure this isn't a bug. I wouldn't know the answer if not for this page, and frankly - I don't think you should really bother to know either.</li>\n<li>People without the intuition of a string being a null-terminated sequence of characters will have no idea what you're trying to do until they read the standard or ask their friends.</li>\n<li>Breaks the <a href=\"http://www.catb.org/esr/writings/taoup/html/ch11s01.html\" rel=\"nofollow noreferrer\">principle of least surprise</a> in a bad way.</li>\n<li>Goes against the principle of \"writing what you mean\", i.e. having the code express problem-domain concepts.</li>\n<li>Sort-of-a use of a <a href=\"https://stackoverflow.com/questions/47882/what-is-a-magic-number-and-why-is-it-bad\">magic number</a> (it's arguable whether 0 actually constitutes a magic number in this case).</li>\n</ol>\n<p>Shall I continue? ... I'm 99% sure you have an alternative superior in almost every respect. I'm even 66% convinced you've done something else that's \"bad\" to manipulate yourself into wanting to do this.</p>\n<p>Always remember: <strong>Other people, who will not be consulting you, will sooner-or-later need to maintain this code.</strong> Think of them, not just of yourself, who can figure it out. Plus, in a decade from now, who's to say you're going to remember your own trick? You might be that confounded maintainer...</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-12-05T21:57:43.100", "Score": "29", "CreationDate": "2015-10-12T19:00:33.787", "ParentId": "33083245", "CommentCount": "10", "OwnerUserId": "1593077", "LastEditDate": "2017-05-23T12:02:34.407"}, "33083245": {"ViewCount": "2125", "Body": "<pre><code>std::string my_string = \"\";\nchar test = my_string[0];\n</code></pre>\n<p>I've noticed that this doesn't crash, and every time I've tested it, test is 0.</p>\n<p>Can I depend on it always being 0? or is it arbitrary?</p>\n<p>Is this bad programming?</p>\n<p>Edit:\nFrom some comments, I gather that there is some misunderstanding about the usefulness of this.</p>\n<p>The purpose of this is NOT to check to see if the string is empty.\nIt is to not need to check whether the string is empty.</p>\n<p>The situation is that there is a string that may or may not be empty.\nI only care about the first character of this string (if it is not empty).</p>\n<p>It seems to me, it would be less efficient to check to see if the string is empty, and then, if it isn't empty, look at the first character.</p>\n<pre><code>if (! my_string.empty())\n    test = my_string[0];\nelse\n    test = 0;\n</code></pre>\n<p>Instead, I can just look at the first character without needing to check to see if the string is empty.</p>\n<pre><code>test = my_string[0];\n</code></pre>\n", "AcceptedAnswerId": "33083361", "Title": "Is it bad to depend on index 0 of an empty std::string?", "CreationDate": "2015-10-12T14:06:51.343", "Id": "33083245", "CommentCount": "10", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-10-14T15:21:06.213", "LastEditorUserId": "4379334", "LastActivityDate": "2016-03-24T11:44:03.343", "Score": "43", "OwnerUserId": "4379334", "Tags": "<c++><stdstring>", "AnswerCount": "2"}, "33083361": {"Id": "33083361", "PostTypeId": "2", "Body": "<h3>C++14</h3>\n<p><strong>No; you can depend on it.</strong></p>\n<p>In <strong>21.4.5.2</strong> (or [string.access]) we can find:</p>\n<blockquote>\n<p id=\"so_33083245_33083361_0\">Returns: <code>*(begin() + pos)</code> if <code>pos &lt; size()</code>. Otherwise, returns a reference to an object of type <code>charT</code> with value <code>charT()</code>, where modifying the object leads to undefined behavior.</p>\n</blockquote>\n<p>In other words, when <code>pos == size()</code> (which is true when both are 0), the operator will return a reference to a <strong>default-constructed</strong> character type <strong>which you are forbidden to modify</strong>.</p>\n<p>It is not special-cased for the empty (or 0-sized) strings and works the same for every length.</p>\n<hr>\n<h3>C++03</h3>\n<p><sub>And <em>most certainly</em> C++98 as well.</sub></p>\n<p><strong>It depends.</strong></p>\n<p>Here's <strong>21.3.4.1</strong> from the official ISO/IEC 14882:</p>\n<blockquote>\n<p id=\"so_33083245_33083361_1\">Returns: If <code>pos &lt; size()</code>, returns <code>data()[pos]</code>. Otherwise, if <code>pos == size()</code>, the const version returns <code>charT()</code>. Otherwise, the behavior is undefined.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "752976", "LastActivityDate": "2016-03-24T11:44:03.343", "Score": "67", "CreationDate": "2015-10-12T14:12:27.410", "ParentId": "33083245", "CommentCount": "5", "OwnerUserId": "752976", "LastEditDate": "2016-03-24T11:44:03.343"}});