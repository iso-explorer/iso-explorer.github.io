post_cb({"3056210": {"ParentId": "3056174", "CommentCount": "2", "Body": "<p>Ultimately, this is a question of personal taste more than anything. It's not \"standards non-compliant\" to have a vector that contains invalid pointers, but it is <em>dangerous</em>, just like it's dangerous to have any pointer that points to invalid memory. Your latter example will ensure that your vector never contains a bad pointer, yes, so it's the safest choice.</p>\n<p>But if you <em>knew</em> that the vector would never be used during your former example's loop (if the vector is locally scoped, for example), it's perfectly fine.</p>\n", "OwnerUserId": "12716", "PostTypeId": "2", "Id": "3056210", "Score": "1", "CreationDate": "2010-06-16T18:42:39.003", "LastActivityDate": "2010-06-16T18:42:39.003"}, "3056373": {"ParentId": "3056174", "CommentCount": "0", "Body": "<p>In storing raw pointers in a container (I wouldn't recommend this) then having to do a 2 phase delete, I would choose your first option over the second.</p>\n<p>I believe container::clear() will delete the contents of the map more efficiently than popping a single item at a time.</p>\n<p>You could probably turn the for loop into a nice (psuedo) <code>forall(begin(),end(),delete)</code> and make it more generic so it didn't even matter if you changed from vector to some other container.</p>\n", "OwnerUserId": "37558", "PostTypeId": "2", "Id": "3056373", "Score": "0", "CreationDate": "2010-06-16T19:07:17.650", "LastActivityDate": "2010-06-16T19:07:17.650"}, "3056631": {"ParentId": "3056174", "PostTypeId": "2", "CommentCount": "14", "Body": "<blockquote>\n<p id=\"so_3056174_3056631_0\">it is illegal for a vector to contain\n  pointers to invalid memory</p>\n</blockquote>\n<p>This is what the Standard has to say about the contents of a container:</p>\n<p>(23.3) : The type of objects stored in these components must meet the requirements of <em>CopyConstructible</em> types (20.1.3), and the additional requirements of <em>Assignable</em> types.</p>\n<p>(20.1.3.1, CopyConstructible) : In the following Table 30, T is a type to be supplied by a C + + program instantiating a template, t is a value of type T, and u is a value of type const T.</p>\n<pre><code>expression  return type  requirement\nxxxxxxxxxx    xxxxxxxxxxx  xxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nT(t)                       t is equivelant to T(t)\nT(u)                       u is equivelant to T(u)\nt.~T()      \n&amp;t          T*           denotes the address of t\n&amp;u          const T*     denotes the address of u\n</code></pre>\n<p>(23.1.4, Assignable) : 64, T is the type used to instantiate the container, t is a value of T, and u is a value of (possibly\nconst) T.</p>\n<pre><code>expression  return type  requirement\nxxxxxxxxxx    xxxxxxxxxxx  xxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nt = u         T&amp;           t is equivilant to u\n</code></pre>\n<p>That's all that is says about the contents of an STL collection.  It says nothing about pointers and it is particularly silent about the pointers pointing to valid memory.</p>\n<p>Therefore, <code>delete</code>ing pointers in a <code>vector</code>, while most likely a very bad architectural decision and an invitation to pain and suffering with the debugger at 3:00 AM on a Saturday night, is perfectly legal.</p>\n<h2>EDIT:</h2>\n<p>Regarding Kranar's comment that \"assigning a pointer to an invalid pointer value results in undefined behavior.\"  No, this is incorrect.  This code is perfectly valid:</p>\n<pre><code>Foo* foo = new Foo();\ndelete foo;\nFoo* foo_2 = foo;  // This is legal\n</code></pre>\n<p>What is illegal is trying to do something with that pointer (or <code>foo</code>, for that matter):</p>\n<pre><code>delete foo_2; // UB\nfoo_2-&gt;do_something(); // UB\nFoo&amp; foo_ref = *foo_2; // UB\n</code></pre>\n<p>Simply creating a wild pointer is legal according to the Standard.  Probably not a good idea, but legal nonetheless.</p>\n<h2>EDIT2:</h2>\n<p>More from the Standard regarding pointer types.  </p>\n<p>So sayeth the Standard (3.9.2.3) :</p>\n<blockquote>\n<p id=\"so_3056174_3056631_1\">... A valid value of an object pointer\n  type represents either the address of\n  a byte in memory (1.7) or a null\n  pointer (4.10)...</p>\n</blockquote>\n<p>...and regarding \"a byte in memory,\" (1.7.1) :</p>\n<blockquote>\n<p id=\"so_3056174_3056631_2\">The fundamental storage unit in the C\n  + + memory model is the byte. A byte is at least large enough to contain\n  any member of the basic execution\n  character set and is composed of a\n  contiguous sequence of bits, the\n  number of which is\n  implementation-defined. The least\n  significant bit is called the\n  low-order bit; the most significant\n  bit is called the high-order bit. The\n  memory available to a C + + program\n  consists of one or more sequences of\n  contiguous bytes. Every byte has a\n  unique address.</p>\n</blockquote>\n<p>There is nothing here about that byte being part of a living <code>Foo</code>, about you having access to it, or anything of the sort.  Its just a byte in memory.</p>\n", "OwnerUserId": "241536", "LastEditorUserId": "241536", "LastEditDate": "2010-06-16T20:05:39.397", "Id": "3056631", "Score": "0", "CreationDate": "2010-06-16T19:44:16.450", "LastActivityDate": "2010-06-16T20:05:39.397"}, "3056209": {"ParentId": "3056174", "PostTypeId": "2", "CommentCount": "18", "Body": "<p>You code is valid, but the better solution will be to use smart pointers.</p>\n<p>The thing is that all requirements to <code>std::vector</code> are located in 23.2.4 section of C++ Standard. There're no limitations about invalid pointers. <code>std::vector</code> works with <code>int*</code> as with any other type (we doesn't consider the case of <code>vector&lt;bool&gt;</code>), it doesn't care where they are point to.</p>\n", "OwnerUserId": "123111", "LastEditorUserId": "123111", "LastEditDate": "2010-06-16T19:07:07.890", "Id": "3056209", "Score": "8", "CreationDate": "2010-06-16T18:42:28.900", "LastActivityDate": "2010-06-16T19:07:07.890"}, "3056174": {"CommentCount": "1", "AcceptedAnswerId": "3056288", "PostTypeId": "1", "LastEditorUserId": "4370109", "CreationDate": "2010-06-16T18:37:25.883", "LastActivityDate": "2015-07-06T20:40:24.150", "LastEditDate": "2015-07-06T20:40:24.150", "ViewCount": "2480", "FavoriteCount": "1", "Title": "Deleting a element from a vector of pointers in C++", "Id": "3056174", "Score": "1", "Body": "<p>I remember hearing that the following code is not C++ compliant and was hoping someone with much more C++ legalese than me would be able to confirm or deny it.</p>\n<pre><code>std::vector&lt;int*&gt; intList;\nintList.push_back(new int(2));\nintList.push_back(new int(10));\nintList.push_back(new int(17));\n\nfor(std::vector&lt;int*&gt;::iterator i = intList.begin(); i != intList.end(); ++i) {\n  delete *i;\n}\nintList.clear()\n</code></pre>\n<p>The rationale was that it is illegal for a vector to contain pointers to invalid memory.  Now obviously my example will compile and it will even work on all compilers I know of, but is it standard compliant C++ or am I supposed to do the following, which I was told is in fact the standard compliant approach:</p>\n<pre><code>while(!intList.empty()) {\n  int* element = intList.back();\n  intList.pop_back();\n  delete element;\n}\n</code></pre>\n", "Tags": "<c++><vector><stl><delete-operator>", "OwnerUserId": "88315", "AnswerCount": "8"}, "3056219": {"ParentId": "3056174", "CommentCount": "6", "Body": "<p>Where did you hear that?  Consider this:</p>\n<pre><code>std::vector&lt;int *&gt; intList(5);\n</code></pre>\n<p>I just created a vector filled with 5 invalid pointers.</p>\n", "OwnerUserId": "117539", "PostTypeId": "2", "Id": "3056219", "Score": "0", "CreationDate": "2010-06-16T18:44:16.760", "LastActivityDate": "2010-06-16T18:44:16.760"}, "3056288": {"ParentId": "3056174", "CommentCount": "0", "Body": "<p>Your code is fine. If you're worried for some reason about the elements being invalid momentarily, then change the body of the loop to</p>\n<pre><code>int* tmp = 0;\nswap (tmp, *i);\ndelete tmp;\n</code></pre>\n", "OwnerUserId": "368578", "PostTypeId": "2", "Id": "3056288", "Score": "5", "CreationDate": "2010-06-16T18:55:24.120", "LastActivityDate": "2010-06-16T18:55:24.120"}, "3056435": {"ParentId": "3056174", "CommentCount": "1", "Body": "<p>The C++ philosophy is to allow the programmer as much latitude as possible, and to only ban things that are actually going to cause harm.  Invalid pointers do no harm in themselves, and therefore you can have them around freely.  What will cause harm is using the pointer in any way, and that therefore invokes undefined behavior.</p>\n", "OwnerUserId": "14148", "PostTypeId": "2", "Id": "3056435", "Score": "2", "CreationDate": "2010-06-16T19:16:03.967", "LastActivityDate": "2010-06-16T19:16:03.967"}, "bq_ids": {"n4140": {"so_3056174_3056631_2": {"section_id": 5785, "quality": 0.8571428571428571, "length": 42}, "so_3056174_3056631_1": {"section_id": 7223, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_3056174_3056631_2": {"section_id": 5558, "quality": 0.8571428571428571, "length": 42}, "so_3056174_3056631_1": {"section_id": 6967, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_3056174_3056631_2": {"section_id": 7242, "quality": 0.8571428571428571, "length": 42}, "so_3056174_3056631_1": {"section_id": 8732, "quality": 0.6153846153846154, "length": 8}}}, "3056541": {"ParentId": "3056174", "CommentCount": "0", "Body": "<p>I don't believe this is an issue of standards compliance.  The C++ standards define the syntax of the language and implementation requirements.  You are using the STL which is a powerful library, but like all libraries it is not part of C++ itself...although I guess it could be argued that when used aggressively, libraries like STL and Qt extend the language into a different superset language.</p>\n<p>Invalid pointers are perfectly compliant with the C++ standards, the computer just won't like it when you dereference them.</p>\n<p>What you are asking is more of a best practices question.  If your code is multi-threaded and <code>intList</code> is potentially shared, then your first approach may be  more dangerous, but as Greg suggested if you know that <code>intList</code> can't be accessed then the first approach may be more efficient.  That said, I believe safety should usually win in a trade-off until you know there is a performance problem.</p>\n<p>As suggested by the Design by Contract concept, all code defines a contract whether implicit or explicit.  The real issue with code like this is what are you promising the user: preconditions, postconditions, invariants, etc.  The libraries make a certain contract and each function you write defines its own contract.  You just need to pick the appropriate balance for you code, and as long as you make it clear to the user (or yourself six months from now) what is safe and what isn't, it will be okay.</p>\n<p>If there are best practices documented with with an API, then use them whenever possible.  They probably are best practices for a reason.  But remember, a best practice may be in the eye of the beholder...that is they may not be a best practice in all situations.</p>\n", "OwnerUserId": "366698", "PostTypeId": "2", "Id": "3056541", "Score": "0", "CreationDate": "2010-06-16T19:31:36.443", "LastActivityDate": "2010-06-16T19:31:36.443"}});