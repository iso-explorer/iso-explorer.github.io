post_cb({"bq_ids": {"n4140": {"so_34288844_34289000_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 6032}}, "n3337": {"so_34288844_34289000_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 5800}}, "n4659": {"so_34288844_34289000_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 7531}}}, "34288915": {"Id": "34288915", "PostTypeId": "2", "Body": "<p>This statement:</p>\n<pre><code>(void)x;\n</code></pre>\n<p>Says \"Ignore the value of x.\"  There is no such type as <code>void</code> - it is the absence of a type.  So it's very different from this:</p>\n<pre><code>(int)x;\n</code></pre>\n<p>Which says \"Treat x as if it were an integer.\"  When the resulting integer is ignored, you get a warning (if it's enabled).</p>\n<p>When you ignore something which is nothing, it is not considered a problem by GCC--and with good reason, since casting to void is an idiomatic way to ignore a variable explicitly in C and C++.</p>\n", "LastActivityDate": "2015-12-15T12:09:47.113", "CommentCount": "7", "CreationDate": "2015-12-15T12:09:47.113", "ParentId": "34288844", "Score": "7", "OwnerUserId": "4323"}, "34289000": {"Id": "34289000", "PostTypeId": "2", "Body": "<p>Casting to void is used to suppress compiler warnings. The <a href=\"http://www.csci.csusb.edu/dick/c++std/cd2/expr.html\">Standard</a> says in \u00a75.2.9/4 says,</p>\n<blockquote>\n<p id=\"so_34288844_34289000_0\">Any expression can be explicitly converted to type \u201ccv void.\u201d The\n  expression value is discarded.</p>\n</blockquote>\n", "LastEditorUserId": "1501794", "LastActivityDate": "2015-12-15T12:19:46.993", "Score": "17", "CreationDate": "2015-12-15T12:13:53.600", "ParentId": "34288844", "CommentCount": "0", "OwnerUserId": "1501794", "LastEditDate": "2015-12-15T12:19:46.993"}, "34288844": {"ViewCount": "2707", "Body": "<p>An often used statement like <code>(void)x;</code> allows to suppress warnings about unused variable <code>x</code>. But if I try compiling the following, I get some results I don't quite understand:</p>\n<pre><code>int main()\n{\n    int x;\n    (short)x;\n    (void)x;\n    (int)x;\n}\n</code></pre>\n<p>Compiling this with g++, I get the following warnings:</p>\n<pre><code>$ g++ test.cpp -Wall -Wextra -o test\ntest.cpp: In function \u2018int main()\u2019:\ntest.cpp:4:13: warning: statement has no effect [-Wunused-value]\n     (short)x;\n             ^\ntest.cpp:6:11: warning: statement has no effect [-Wunused-value]\n     (int)x;\n           ^\n</code></pre>\n<p>So I conclude that casting to <code>void</code> is very different from casting to any other types, be the target type the same as <code>decltype(x)</code> or something different. My guess at possible explanations is:</p>\n<ul>\n<li>It is just a convention that <code>(void)x;</code> but not the other casts will suppress warnings. All the statements equally don't have any effect.</li>\n<li>This difference is somehow related to the fact that <code>void x;</code> isn't a valid statement while <code>short x;</code> is.</li>\n</ul>\n<p>Which of these if any is more correct? If none, then how can the difference in compiler warnings be explained?</p>\n", "AcceptedAnswerId": "34289000", "Title": "What does casting to `void` really do?", "CreationDate": "2015-12-15T12:06:20.503", "Id": "34288844", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-08-10T16:48:21.980", "LastEditorUserId": "4284627", "LastActivityDate": "2017-08-10T16:48:21.980", "Score": "12", "OwnerUserId": "673852", "Tags": "<c++><casting><compiler-warnings><void><suppress-warnings>", "AnswerCount": "3"}, "34290286": {"Id": "34290286", "PostTypeId": "2", "Body": "<p>The standard does not mandate generating a warning (\"diagnostic\" in standardese) for unused local variables or function parameters. Likewise, it does not mandate how such a warning might be suppressed. Casting a variable expression to <code>void</code> to suppress this warning has become an idiom in the C and later C++ community instead because the result cannot be used in any way (other than e.g. <code>(int)x</code>), so it's unlikely that the corresponding code is just missing. E.g.:</p>\n<pre><code>(int)x;  // maybe you meant f((int)x);\n(void)x; // cannot have intended f((void)x);\n(void)x; // but remote possibility: f((void*)x);\n</code></pre>\n<p>Personally, I find this convention too obscure still, which is why I prefer to use a function template:</p>\n<pre><code>template&lt;typename T&gt;\ninline void ignore(const T&amp;) {} // e.g. ignore(x);\n</code></pre>\n<p>The idiomatic way to ignore function parameters is, however, to omit their name (as seen above). A frequent use I have for this function is when I need to be able to name a function parameter in conditionally compiled code such as an <code>assert</code>. I find e.g. the following more legible than the use of <code>#ifdef NDEBUG</code>:</p>\n<pre><code>void rate(bool fantastic)\n{\n    assert(fantastic);\n    ignore(fantastic);\n}\n</code></pre>\n", "LastActivityDate": "2015-12-15T13:16:03.327", "CommentCount": "0", "CreationDate": "2015-12-15T13:16:03.327", "ParentId": "34288844", "Score": "4", "OwnerUserId": "4083309"}});