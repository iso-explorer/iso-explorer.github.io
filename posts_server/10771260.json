post_cb({"10771286": {"ParentId": "10771260", "CommentCount": "0", "Body": "<p>An obvious use for a <code>long</code> larger than 32 bits is to have a larger range available.</p>\n<p>For example, before <code>long long int</code> (and company) were in the standard, DEC was selling 64-bit (Alpha) processors and a 64-bit operating system. They built a (conforming) system with:</p>\n<pre><code>char = 1 byte\nshort = 2 bytes\nint = 4 bytes\nlong = 8 bytes\n</code></pre>\n<p>As to why they'd do this: well, an obvious reason was so their customers would have access to a 64-bit type and take advantage of their 64-bit hardware.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "10771286", "Score": "1", "CreationDate": "2012-05-27T02:45:53.593", "LastActivityDate": "2012-05-27T02:45:53.593"}, "10771283": {"ParentId": "10771260", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-05-27T02:45:36.463", "Score": "1", "LastEditorUserId": "66692", "LastEditDate": "2012-05-27T02:54:36.910", "Id": "10771283", "OwnerUserId": "66692", "Body": "<p>You're assuming quite a few things:</p>\n<ul>\n<li>A byte is <code>CHAR_BIT</code> bits wide</li>\n</ul>\n<p>The PDP-10 had bytes ranging from 1 to 36 bits. The DEC VAX supported operations on 128-bit integer types. So, there's plenty reason to go over and above what the standard mandates.</p>\n<ul>\n<li>The limits for data types are given in \u00a73.9.1/8</li>\n</ul>\n<blockquote>\n<p id=\"so_10771260_10771283_0\">Specializations of the standard template std::numeric_limits (18.3)\n  shall specify the maximum and minimum values of each arithmetic type\n  for an implementation.</p>\n</blockquote>\n<p>Lookup <code>&lt;limits&gt;</code> header. </p>\n<p><a href=\"http://www.bandwidthco.com/whitepapers/programming/c-c++/Integer%20Types%20in%20C%20and%20C++.pdf\" rel=\"nofollow\">This</a> article by Jack Klein may be of interest to you!</p>\n", "LastActivityDate": "2012-05-27T02:54:36.910"}, "10771557": {"ParentId": "10771260", "CommentCount": "0", "Body": "<p>If you want an integer of a specific size, then you want to use the types with the size specified:</p>\n<p>int8_t\nint16_t\nint32_t\nint64_t\nint128_t\n...</p>\n<p>These are available in some random header file (it varies depending on the OS you're using, although in C++ it seems to be &lt;stdint&gt;)</p>\n<p>You have the unsigned version using a u at the beginning (uint32_t).</p>\n<p>The others already answered why the size would be so and so.</p>\n<p>Note that the newest Intel processors support numbers of 256 bits too. What a waste, hey?! 8-)</p>\n<p>Oh! And time_t is starting to use 64 bits too. In 2068, time_t in 32 bits will go negative and give you a date in late 1800... That's a good reason to adopt 64 bits for a few things.</p>\n", "OwnerUserId": "212378", "PostTypeId": "2", "Id": "10771557", "Score": "0", "CreationDate": "2012-05-27T04:01:47.533", "LastActivityDate": "2012-05-27T04:01:47.533"}, "16500825": {"ParentId": "10771260", "CommentCount": "0", "Body": "<p>One reason for using an 8 byte integer is to be able to address more than 4 gigs of memory.  Ie. 2^32 = 4 gigabytes.  2^64 = well, it's a lot!</p>\n<p>Personally, I've used 8 byte ints for implementing a radix sort on double floats (casting the floats as ints then doing magical things with it that aren't worth describing here. :))</p>\n", "OwnerUserId": "1219901", "PostTypeId": "2", "Id": "16500825", "Score": "0", "CreationDate": "2013-05-11T19:18:26.683", "LastActivityDate": "2013-05-11T19:18:26.683"}, "10771280": {"ParentId": "10771260", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2012-05-27T02:45:16.640", "Score": "1", "LastEditorUserId": "659804", "LastEditDate": "2012-05-27T02:53:47.947", "Id": "10771280", "OwnerUserId": "659804", "Body": "<p>The extra bytes aren't a waste of space. A larger range is quite useful. The standard specifies <em>minimum</em> ranges, not the precise range itself; there's nothing wrong with having wider types.</p>\n<p>When the standard originally specified an <code>int</code> should be at least 16 bits, common processors had registers no larger than that. Representing a <code>long</code> took two registers and special operations!</p>\n<p>But then 32 bits became the norm, and now <code>int</code>s are 32 bits everywhere and <code>long</code>s are 64. Nowadays most processors have 64-bit instructions, and a <code>long</code> can often be stored in a single register.</p>\n", "LastActivityDate": "2012-05-27T02:53:47.947"}, "bq_ids": {"n4140": {"so_10771260_10771283_0": {"section_id": 7217, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_10771260_10771283_0": {"section_id": 6961, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_10771260_10771283_0": {"section_id": 8726, "quality": 0.9166666666666666, "length": 11}}}, "10771260": {"CommentCount": "9", "ViewCount": "929", "CreationDate": "2012-05-27T02:40:32.123", "LastActivityDate": "2013-05-11T19:18:26.683", "Title": "Why does long integer take more than 4 bytes on some systems?", "AcceptedAnswerId": "10771280", "PostTypeId": "1", "Id": "10771260", "Score": "0", "Body": "<p>I understand that the standard says that the size of a <code>long integer</code> is implementation dependant, but I am not sure why.</p>\n<p>All it needs to do is to be able to store -2147483647 to 2147483647 or 0 to 4294967295.</p>\n<p>Assuming that 1 byte is 8 bits, this should never need more than 4 bytes. Is it safe to say, then, that a long integer will take more than 4 bytes only if a byte has less than 8 bits? Or could there be other possibilities as well? Like maybe inefficient implementations wasting space?</p>\n", "Tags": "<c++><long-integer>", "OwnerUserId": "113124", "AnswerCount": "5"}});