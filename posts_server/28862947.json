post_cb({"28862947": {"ViewCount": "233", "Body": "<p>Why do <code>std::numeric</code> algorithms seem to prefer <strong><em>op</em></strong> instead of <strong><em>op=</em></strong>? For example, here is the implementation of <code>std::accumulate</code> in LLVM:</p>\n<pre><code>template &lt;class _InputIterator, class _Tp&gt;\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\naccumulate(_InputIterator __first, _InputIterator __last, _Tp __init)\n{\n    for (; __first != __last; ++__first)\n        __init = __init + *__first;\n    return __init;\n}\n</code></pre>\n<p>Would this not be potentially more efficient/less verbose/better if implemented using the <code>+=</code> operator?</p>\n", "AcceptedAnswerId": "28863128", "Title": "Why do STL numeric algorithms use 'op' rather than 'op='?", "CreationDate": "2015-03-04T19:17:08.993", "Id": "28862947", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-03-07T10:39:56.153", "LastEditorUserId": "2970186", "LastActivityDate": "2015-03-12T19:44:39.900", "Score": "8", "OwnerUserId": "2970186", "Tags": "<c++><stl>", "AnswerCount": "5"}, "28863123": {"Id": "28863123", "PostTypeId": "2", "Body": "<p>In my opinion the main reason is that you could use standard functional object <code>std::plus</code> and get the same result as with <code>operator +</code> the same way as using <code>operator &lt;</code> and standard functional object <code>std::less</code> in sorting algorithms like <code>std::sort</code>.</p>\n", "LastActivityDate": "2015-03-04T19:26:15.877", "CommentCount": "2", "CreationDate": "2015-03-04T19:26:15.877", "ParentId": "28862947", "Score": "1", "OwnerUserId": "2877241"}, "29011259": {"Id": "29011259", "PostTypeId": "2", "Body": "<p>There are plenty of reasons for using + instead of +=.</p>\n<p>A. Because it is the correct way.  <a href=\"http://en.wikipedia.org/wiki/Fold_(higher-order_function)\" rel=\"nofollow\">Accumulate is fold</a>, a functor (a function that maps functions to functions) that operates on +, not +=.  Why + instead of +=?  Because += is not a mathematical function.</p>\n<p>B. It is more efficient (on modern compilers, on all primitive types and well-designed objects).  += might be faster for compilers 30 years ago, but + is faster now, unless what you are accumulating is a monstrous object with too much OO.  Object lifetime analysis is easier done on const objects rather than references.</p>\n<p>C. It is clearer.  This reason is really not substantially different from (A).  + is clearer than +=.  Clarity trumps verbosity.</p>\n", "LastActivityDate": "2015-03-12T13:35:20.657", "CommentCount": "7", "CreationDate": "2015-03-12T13:35:20.657", "ParentId": "28862947", "Score": "0", "OwnerUserId": "3517622"}, "28863128": {"Id": "28863128", "PostTypeId": "2", "Body": "<h2>It is defined like this in the standard\u2026</h2>\n<p>The standard is defined in terms of <code>+</code>, not <code>+=</code>:</p>\n<blockquote>\n<h3>26.7.2 Accumulate <code>[accumulate]</code></h3>\n<pre><code>template &lt;class InputIterator, class T&gt;\n  T accumulate(InputIterator first, InputIterator last, T init);\ntemplate &lt;class InputIterator, class T, class BinaryOperation&gt;\n  T accumulate(InputIterator first, InputIterator last, T init,\n               BinaryOperation binary_op);\n</code></pre>\n<p id=\"so_28862947_28863128_0\">Effects: Computes its result by initializing the accumulator <code>acc</code> with the initial value <code>init</code> and then modifies it with <code>acc = acc + *i</code> or a<code>cc = binary_op(acc, *i)</code> for every iterator <code>i</code> in the range\n  <code>[first,last)</code> in order.</p>\n</blockquote>\n<p>Same holds for other numerical algorithms. </p>\n<h2>\u2026and the standard is based on STL\u2026</h2>\n<p>But that's the reason why they're <em>implemented</em> like this nowadays. However, to learn about the original reason, one needs to <a href=\"http://www.sgi.com/tech/stl/accumulate.html\" rel=\"noreferrer\">go further down the rabbit hole</a>:</p>\n<blockquote>\n<h3>Requirements on types</h3>\n<p id=\"so_28862947_28863128_1\">For the first version, the one that takes two arguments:</p>\n<ul>\n<li><code>InputIterator</code> is a model of Input Iterator.</li>\n<li><code>T</code> is a model of Assignable.</li>\n<li>If <code>x</code> is an object of type <code>T</code> and <code>y</code> is an object of <code>InputIterator</code>'s <code>value</code> type, then <code>x + y</code> is defined.</li>\n<li>The return type of <code>x + y</code> is convertible to <code>T</code>. </li>\n</ul>\n</blockquote>\n<h2>\u2026and the STL has been created by\u2026?</h2>\n<p>So, why is that? Lets ask Alexander Stepanov, the mind behind STL:</p>\n<blockquote>\n<p id=\"so_28862947_28863128_2\">[A] user has asked a [question] on StackOverflow two days ago concerning\n  the implementation and formulation of numerical algorithms like\n  <code>accumulate</code> or <code>inner_product</code>, which are defined in terms of <code>+</code>\n  instead of <code>+=</code> (section 26.7 in ISO C++11).</p>\n<p id=\"so_28862947_28863128_3\">I've tried to find some rationale behind the decision, but even the\n  version on SGI's page doesn't mention anything regarding this\n  particular choice of the operator.</p>\n<p id=\"so_28862947_28863128_4\">Was the choice of the operator (a = a + b instead of a += b) only\n  based on your personal preference, as some comments assume? Was a+b\n  the more natural way to write the operation back then? Or was it\n  simply a matter of symmetry between a = a +b and a = bin_op(a,b)?</p>\n<p id=\"so_28862947_28863128_5\">-- [Zeta]</p>\n</blockquote>\n<p>Now, before you read his answer, remember that he started to write a generic library about ~30 years ago, and his and Meng Lee's initial document <a href=\"http://www.stepanovpapers.com/STL/DOC.PDF\" rel=\"noreferrer\">The Standard Template Library</a> will have its twenty years anniversary this October. Without further ado, I present his answer:</p>\n<blockquote>\n<p id=\"so_28862947_28863128_6\">I suspect that it was a matter of symmetry between a = a + b and a = bin_op(a,b), but I really do not remember. I should have written a rationale document stating all the reasoning between different design choices in STL, but I did not. Sorry.</p>\n</blockquote>\n<p><sup>(If Stepanov reads this by any chance: thanks again for your answer!)</sup></p>\n<p>I <em>personally</em> believe that the inspiration by Common Lisp's <code>reduce</code> has been another factor, but that's just speculation.</p>\n<h2>What can one learn from this?</h2>\n<p>Sometimes, decision in a standard are based on personal preference and elegance. For example, if Stroustrup had written the STL, he would have \"strongly prefer[ed] the use of a+=b as being a more direct expression of intent and typically faster than a=a+b\". However, I have to admit that the symmetry between a = a+b and a=bin_op(a,b) has its own beauty.</p>\n<p>That being said, this <code>a+=b</code> and <code>a=a+b</code> controversy will promote challenges:</p>\n<blockquote>\n<p id=\"so_28862947_28863128_7\">This issue will become very important when we define standard concepts, and I do not know how it will be resolved. [Stroustrup; also thanks to him for answering my question!]</p>\n</blockquote>\n<p>That's all, I hope you've enjoyed the ride through a little bit of C++ history.</p>\n", "LastEditorUserId": "1139697", "LastActivityDate": "2015-03-06T14:54:29.973", "Score": "15", "CreationDate": "2015-03-04T19:26:34.870", "ParentId": "28862947", "CommentCount": "9", "OwnerUserId": "1139697", "LastEditDate": "2015-03-06T14:54:29.973"}, "29018909": {"Id": "29018909", "PostTypeId": "2", "Body": "<p>The truth, I guess, is reuse. The rest of the STL is using binary <em>operators</em> while <code>+=</code> is an <em>action</em>. So there's <code>plus</code>, <code>multiplies</code>, etc, but no <code>add_action</code> (say). Operators and actions are completely symmetric, but if you implement more than 90 algorithms, at some point you'll probably have to stop adding new concepts and Ship It.</p>\n<p>Alex has said that he never intended for his STL to be the end of all STL development, esp. since the standardized version contains only a fraction of what he originally proposed. This is an obvious extension.</p>\n", "LastActivityDate": "2015-03-12T19:44:39.900", "CommentCount": "0", "CreationDate": "2015-03-12T19:44:39.900", "ParentId": "28862947", "Score": "0", "OwnerUserId": "134841"}, "bq_ids": {"n4140": {"so_28862947_28863128_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 3849}}, "n3337": {"so_28862947_28863128_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 3710}}, "n4659": {"so_28862947_28863128_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 4620}}}, "28863042": {"Id": "28863042", "PostTypeId": "2", "Body": "<p>It might be more efficient, and would clearly be less verbose.</p>\n<p>The usual reason for doing things this way is to minimize the requirements on the underlying type. If you used <code>+=</code>, then the underlying type would have to support <code>+=</code>. For something like <code>int</code> that's trivial and already present, but for a class you define, it's entirely possible would define <code>+</code> and <code>=</code>, but not the compound <code>+=</code> (in which case, code that used <code>+=</code> would obviously fail).</p>\n", "LastActivityDate": "2015-03-04T19:21:38.097", "CommentCount": "9", "CreationDate": "2015-03-04T19:21:38.097", "ParentId": "28862947", "Score": "10", "OwnerUserId": "179910"}});