post_cb({"23703601": {"CommentCount": "2", "AcceptedAnswerId": "23703753", "PostTypeId": "1", "LastEditorUserId": "734069", "CreationDate": "2014-05-16T19:57:16.813", "LastActivityDate": "2017-07-21T17:14:42.123", "LastEditDate": "2017-07-21T17:14:42.123", "ViewCount": "2265", "FavoriteCount": "8", "Title": "In f(x), can x be evaluated before f?", "Id": "23703601", "Score": "52", "Body": "<p>I have a C++ program. This program does something like this:</p>\n<pre><code>struct MyT {void memfunc(std::unique_ptr&lt;MyT&gt; arg);};\nstd::unique_ptr&lt;MyT&gt; obj = /* some init */;\nobj-&gt;memfunc(std::move(obj));\n</code></pre>\n<p>Is this guaranteed to be valid, or can I end up calling a member function on <code>nullptr</code>?<br>\nStandard quotes applicable.<br>\nI know that the order of evaluation of the arguments is unsequenced, but I don't recall what the sequencing is w.r.t. the function object being called.</br></br></p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "298661", "AnswerCount": "2"}, "23703716": {"ParentId": "23703601", "CommentCount": "7", "Body": "<p><strong>Yes</strong>, the evaluation of <code>x</code> can occur before, after, or during the evaluation of <code>f</code> (they are <em>unsequenced</em>).</p>\n<blockquote>\n<p id=\"so_23703601_23703716_0\">[ <em>Note:</em> The evaluations of the postfix expression and of the argument expressions are all unsequenced\n   relative to one another. All side effects of argument expression evaluations are sequenced before the function\n    is entered (see 1.9). \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>(C++11, \u00a75.2.2/8)</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "23703716", "Score": "18", "CreationDate": "2014-05-16T20:04:34.483", "LastActivityDate": "2014-05-16T20:04:34.483"}, "bq_ids": {"n4140": {"so_23703601_23703753_0": {"section_id": 5811, "quality": 0.9496402877697842, "length": 132}, "so_23703601_23703753_3": {"section_id": 5988, "quality": 0.625, "length": 15}, "so_23703601_23703716_0": {"section_id": 5995, "quality": 0.72, "length": 18}}, "n3337": {"so_23703601_23703753_1": {"section_id": 3806, "quality": 0.625, "length": 5}, "so_23703601_23703753_0": {"section_id": 5584, "quality": 0.9496402877697842, "length": 132}, "so_23703601_23703753_3": {"section_id": 5756, "quality": 0.5833333333333334, "length": 14}, "so_23703601_23703716_0": {"section_id": 5763, "quality": 0.84, "length": 21}}, "n4659": {"so_23703601_23703753_3": {"section_id": 7488, "quality": 0.625, "length": 15}}}, "23703753": {"ParentId": "23703601", "PostTypeId": "2", "CommentCount": "2", "Body": "<h1>Pre-C++17, it is undefined behavior:</h1>\n<p>Here the quote which proves that all evaluation neccessary to call a function and associated side-effects are sequenced before the function call.<br>\nAlso, all other evaluations not specifically sequenced are indeterminately sequenced.<br>\nThat does not impose any ordering constraints on the sub-expressions evaluated though with respect to each other, they remain <em>unsequenced</em> with respect to each other.</br></br></p>\n<blockquote>\n<h3>1.9 Program execution \u00a7 15</h3>\n<p id=\"so_23703601_23703753_0\"><strong>Except where noted,</strong> <em>evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced.</em><br>\n  [...]<br>\n  The value computations of the operands of an operator are sequenced before the value computation of the result of the operator. If a side effect on a scalar object is unsequenced relative to either anotherside effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined.<br>\n<strong>When calling a function</strong> (whether or not the function is inline), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is sequenced before execution of every expression or statement in the body of the called function.<br>\n  [ Note: Value computations and side effects associated with different argument expressions are unsequenced. \u2014end note ]<br>\n<strong>Every evaluation in the calling function (including other function calls) that is not otherwise specifically sequenced before or after the execution of the body of the called function is indeterminately sequenced with respect to the execution of the called function</strong>.9 <strong><em>Several contexts in C++ cause evaluation of a function call, even though no corresponding function call syntax appears</em></strong> in the translation unit. [ ... ]<br>\n  The sequencing constraints on the execution of the called function (as described above) are features of the function calls as evaluated, whatever the syntax of the expression that calls the function might be.</br></br></br></br></br></br></p>\n</blockquote>\n<p>Other relevant quotes are about <code>std::move</code></p>\n<blockquote>\n<p id=\"so_23703601_23703753_1\">template  typename remove_reference::type&amp;&amp; move(T&amp;&amp; t) noexcept;<br>\n  Returns: static_cast&lt;typename remove_reference::type&amp;&amp;&gt;(t).</br></p>\n</blockquote>\n<p>And <code>std::unique_ptr&lt;T&gt;.operator-&gt;()</code>:</p>\n<blockquote>\n<h3>20.7.1.2.4 unique_ptr observers</h3>\n<p id=\"so_23703601_23703753_2\">pointer operator-&gt;() const noexcept;<br>\n  Requires: get() != nullptr.<br>\n  Returns: get().</br></br></p>\n</blockquote>\n<p><code>memfunc</code> gets its argument by value, so we have 3 calls:<br>\na) <code>obj-&gt;memfunc</code>\nb) <code>std::move(obj)</code><br>\nc) the move constructor of the passed argument.<br>\nBecause b) does not change anything, we can disregard it for the argument:</br></br></br></p>\n<p>a and c are indeterminately sequenced, so either can be before the other.<br>\nIf a happens first, everything is good, c changing <code>obj</code> does not matter.<br>\nIf c happens first, a is evaluated with a zeroed <code>obj</code>, violating the precondition, so we have UB.</br></br></p>\n<p>In summary, it is Undefined Behavior, because one of the allowed orders has undefined behavior.</p>\n<h1>Post-C++17, it is well-defined:</h1>\n<blockquote>\n<h3>8.2.2 Function call [expr.call]</h3>\n<p id=\"so_23703601_23703753_3\">1 A function call is a post\ufb01x expression followed by parentheses containing a possibly empty, comma-separated list of <em>initializer-clauses</em> which constitute the arguments to the function. [...]<br>\n  [...]<br>\n  5 The <em>post\ufb01x-expression</em> is sequenced before each <em>expression</em> in the <em>expression-list</em> and any default argument. [...]<br>\n  [...]</br></br></br></p>\n</blockquote>\n", "OwnerUserId": "3204551", "LastEditorUserId": "3204551", "LastEditDate": "2017-07-21T17:07:39.627", "Id": "23703753", "Score": "19", "CreationDate": "2014-05-16T20:08:20.887", "LastActivityDate": "2017-07-21T17:07:39.627"}});