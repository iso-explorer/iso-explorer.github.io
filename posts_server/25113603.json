post_cb({"25114672": {"ParentId": "25113603", "CommentCount": "0", "Body": "<p>I was unable to get a clear interpretation from the standard, so I decided to check what's the <em>de facto</em> standard. The following code:</p>\n<pre><code>#include &lt;cstdio&gt;\n\nstruct MyClass\n{\n    MyClass() { printf(\"constructor\\n\"); }\n    ~MyClass() { printf(\"destructor\\n\");  }\n    MyClass(const MyClass&amp;) { printf(\"copy\\n\"); }\n    MyClass(MyClass&amp;&amp;) { printf(\"move\\n\"); }\n};\n\nconst MyClass&amp; f(const MyClass&amp; arg) {\n    return arg;\n}\n\nint main()\n{\n    {\n        printf(\"before construction\\n\");\n        const MyClass&amp; reference = f(MyClass());\n        printf(\"after construction\\n\");   \n    }\n    printf(\"outside scope\\n\");\n}\n</code></pre>\n<p>Yields:</p>\n<pre><code>before construction\nconstructor\ndestructor\nafter construction\noutside scope\n</code></pre>\n<p>For MSVC, clang and g++. Seems it is not legal according to our main compiler suppliers.</p>\n", "OwnerUserId": "461632", "PostTypeId": "2", "Id": "25114672", "Score": "5", "CreationDate": "2014-08-04T08:38:01.523", "LastActivityDate": "2014-08-04T08:38:01.523"}, "bq_ids": {"n4140": {"so_25113603_25114728_0": {"section_id": 382, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_25113603_25114728_0": {"section_id": 373, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_25113603_25114728_0": {"section_id": 397, "quality": 0.7857142857142857, "length": 11}}}, "25114728": {"ParentId": "25113603", "LastEditDate": "2015-01-08T12:41:55.467", "CommentCount": "1", "CreationDate": "2014-08-04T08:41:48.957", "OwnerUserId": "1142110", "LastEditorUserId": "1142110", "PostTypeId": "2", "Id": "25114728", "Score": "10", "Body": "<p>As far as I know, you can't do this. While binding a temporary to a const reference is legal C++(and lengthens the lifetime of that temporary -- <a href=\"http://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/\" rel=\"nofollow\">see GOTW 88</a>), further binding a const ref to another const ref doesn't lengthen the lifetime of that temporary. </p>\n<p>The quote from page 192(<a href=\"http://cs.nyu.edu/courses/fall11/CSCI-GA.2110-003/documents/c++2003std.pdf\" rel=\"nofollow\">C++03 standard</a>):</p>\n<blockquote>\n<p id=\"so_25113603_25114728_0\">A temporary bound to a reference parameter in a function call (5.2.2)\n  persists until the completion of the full expression containing the\n  call</p>\n</blockquote>\n<p>I think the standard is pretty explicit that using reference after <code>// Use reference.</code> is invalid. I modified your snippet to check it(Mac OS X, clang: <code>Apple LLVM version 5.1 (clang-503.0.40) (based on LLVM 3.4svn)</code>):</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct MyClass\n{\n    ~MyClass()\n    {\n        std::cout &lt;&lt; \"~MyClass()\" &lt;&lt; std::endl;\n    }\n};\n\nconst MyClass&amp; f(const MyClass&amp; arg) {\n    std::cout &lt;&lt; \"f()\" &lt;&lt; std::endl;\n    return arg;\n}\n\nint main() {\n    const MyClass&amp; reference = f(MyClass());\n    std::cout &lt;&lt; \"main()\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>It outputs:</p>\n<pre><code>f()\n~MyClass()\nmain()\n</code></pre>\n<p>In other words, unless both me and clang developers are misinterpreting the C++ standard, it is illegal.</p>\n", "LastActivityDate": "2015-01-08T12:41:55.467"}, "25113603": {"CommentCount": "2", "ViewCount": "1229", "LastActivityDate": "2015-01-08T12:41:55.467", "Body": "<p>I cannot get a clear idea of whether this is legal, even after looking at related questions on SO and reading the C++03 standard page 192 (<a href=\"http://cs.nyu.edu/courses/fall11/CSCI-GA.2110-003/documents/c++2003std.pdf\" rel=\"noreferrer\">http://cs.nyu.edu/courses/fall11/CSCI-GA.2110-003/documents/c++2003std.pdf</a>). Is this legal and safe:</p>\n<pre><code>const MyClass&amp; f(const MyClass&amp; arg) {\n  return arg;\n}\n\nvoid some_other_function() {\n  const MyClass&amp; reference = f(MyClass());\n  // Use reference.\n}\n</code></pre>\n<p>It seems to me that it is.</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "25114728", "FavoriteCount": "1", "Title": "C++ temporary object bound to argument and return value const references", "Id": "25113603", "Score": "14", "CreationDate": "2014-08-04T07:23:36.063", "Tags": "<c++>", "OwnerUserId": "955679", "AnswerCount": "3"}, "25115267": {"ParentId": "25113603", "LastEditDate": "2014-08-04T09:53:10.537", "CommentCount": "0", "CreationDate": "2014-08-04T09:13:51.053", "OwnerUserId": "2112844", "LastEditorUserId": "2112844", "PostTypeId": "2", "Id": "25115267", "Score": "3", "Body": "<p>This question is similar to following question: <a href=\"https://stackoverflow.com/questions/24990370/pass-const-key-type-to-operator-of-stdmap/24990727#24990727\">Pass const Key_Type&amp; to operator[] of std::map</a></p>\n<p>The code below explains what exactly is happening</p>\n<pre><code>#include &lt;iostream&gt;\n\n\nstruct MyClass{\n\n  int member;\n\n\n  MyClass():member(0){\n      std::cout&lt;&lt;\"MyClass ctr \"&lt;&lt;std::endl;\n  }\n\n  MyClass(const MyClass&amp; rhs){\n\n      std::cout&lt;&lt;\"MyClass copy ctr \"&lt;&lt;std::endl;\n  }\n\n  ~MyClass(){\n\n      std::cout&lt;&lt;\"MyClass dtr\"&lt;&lt;std::endl;\n      member = -1;\n  }\n};\n\nvoid f2(const MyClass&amp; obj){\n\n    std::cout&lt;&lt;\"func \"&lt;&lt;obj.member&lt;&lt;std::endl;\n\n}   \n\nconst MyClass&amp; f3(){ \n    return MyClass(); \n}\n\nMyClass f4(){ \n    return MyClass(); //ideally not a good idea, exception is\n    //http://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/\n}\n\nint main()\n{\n    std::cout &lt;&lt; \"-----Faulty Case-----------\"&lt;&lt;std::endl;\n\n    //reference returned by f3 is local to f3 call and \n    //is destructed as soon as f3() is out of stack\n    //and hence the reference in f2() is not valid\n    f2( f3() );\n\n    std::cout &lt;&lt;std::endl&lt;&lt; \"-----Correct way-----------\"&lt;&lt;std::endl;\n\n    //A temporary object is returned by f4 which is then referred by reference in f2.\n    //This reference is alive in stack of f2 and hence can be used inside \n    //f2 with valid results.\n    //As explained in following article, the refernce should remain\n    //alive in stack to use temporary objects.\n    //http://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/\n    f2( f4() );\n\n    //note in previous expression, f4 returns by value but still copy ctr is not invoked,\n    //this I believe is Return Value Optimization (might be compiler dependent)\n\n    return 0;\n}\n</code></pre>\n<p>Output of this program would be:</p>\n<pre><code>Executing the program....\n$demo \n-----Faulty Case-----------\nMyClass ctr \nMyClass dtr\nfunc -1\n\n-----Correct way-----------\nMyClass ctr \nfunc 0\nMyClass dtr\n</code></pre>\n", "LastActivityDate": "2014-08-04T09:53:10.537"}});