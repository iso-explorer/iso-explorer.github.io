post_cb({"bq_ids": {"n4140": {"so_34860809_34932967_0": {"length": 11, "quality": 1.0, "section_id": 5811}, "so_34860809_34860809_0": {"length": 59, "quality": 0.9365079365079365, "section_id": 5811}, "so_34860809_34860809_1": {"length": 7, "quality": 1.0, "section_id": 5811}}, "n3337": {"so_34860809_34932967_0": {"length": 11, "quality": 1.0, "section_id": 5584}, "so_34860809_34860809_0": {"length": 59, "quality": 0.9365079365079365, "section_id": 5584}, "so_34860809_34860809_1": {"length": 7, "quality": 1.0, "section_id": 5584}}, "n4659": {"so_34860809_34932967_0": {"length": 11, "quality": 1.0, "section_id": 7272}, "so_34860809_34860809_0": {"length": 35, "quality": 0.5555555555555556, "section_id": 7273}, "so_34860809_34860809_1": {"length": 7, "quality": 1.0, "section_id": 7273}}}, "34860854": {"Id": "34860854", "PostTypeId": "2", "Body": "<p>If you have two functions that return <code>int</code></p>\n<pre><code>int Foo();\nint Bar();\n</code></pre>\n<p>Then you have some calling function</p>\n<pre><code>void SomeFunction(int x, int y);\n</code></pre>\n<p>Then the calling code looks like</p>\n<pre><code>SomeFunction(Foo(), Bar());\n</code></pre>\n<p>They are saying the execution order of <code>Foo</code> and <code>Bar</code> is indeterminant.</p>\n", "LastActivityDate": "2016-01-18T17:41:25.197", "CommentCount": "3", "CreationDate": "2016-01-18T17:41:25.197", "ParentId": "34860809", "Score": "4", "OwnerUserId": "2296458"}, "34932967": {"Id": "34932967", "PostTypeId": "2", "Body": "<p>The <a href=\"https://stackoverflow.com/a/34860854/1566221\">answer by CoryKramer</a> is entirely correct but perhaps insufficiently elaborated. The clarification in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1949\" rel=\"nofollow noreferrer\">DR 1949</a> is not relevant.</p>\n<p>The key is paragraph 13 of \u00a71.9: which defines the relation \"sequenced before\" as a partial order, and provides four possibilites for two evaluations A and B:</p>\n<ol>\n<li><p>A is <em>sequenced before</em> B</p></li>\n<li><p>B is <em>sequenced before</em> A</p></li>\n<li><p>One of (1) or (2) holds, but the standard does not specify which. In this case, we say that A and B are <em>indeterminately sequenced</em>.</p></li>\n<li><p>Neither (1) nor (2) holds. In this case, we say that A and B are <em>unsequenced</em>.</p></li>\n</ol>\n<p>There is a difference between <em>indeterminately sequenced</em> and <em>unsequenced</em>, and it is this difference which is addressed in paragraph 15. Paragraph 15 commences with the general rule (emphasis added):</p>\n<blockquote>\n<p id=\"so_34860809_34932967_0\">Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are <em>unsequenced</em>.</p>\n</blockquote>\n<p>The consequence of that is that in the function call</p>\n<pre><code>f(argument1, argument2);\n</code></pre>\n<p>the evaluations <code>argument1</code> and <code>argument2</code> are <em>unsequenced</em>. That makes the following <em>undefined behaviour</em>:</p>\n<pre><code>f(i++, i++);\n</code></pre>\n<p>But suppose we had:</p>\n<pre><code>int incr(int&amp; i) { return i++; }\n</code></pre>\n<p>and we instead wrote:</p>\n<pre><code>f(incr(i), incr(i));\n</code></pre>\n<p>If we applied the general rule, then this would also be undefined behaviour, with exactly the same argument: the two evaluations are unsequenced, so the evaluations of the bodies of the two function calls are unsequenced, and we end up with two unsequenced modifications of the same variable.</p>\n<p>But this is really not desirable, as it would lead to chaos. [It should be noted that the above example is brutally simplified; the two functions might be completely different and the common variable might not be named. In particular, as a common case, the two functions might both send output to <code>std::cout</code>, thus performing a mutable operation on the same shared object (<code>std::cout</code> itself).]</p>\n<p>So an explicit exception is made for function calls: the body of a function evaluation is always sequenced with respect to sub-expressions of the expression which contains the function call. So in</p>\n<pre><code>f(incr1(i), incr2(i));\n</code></pre>\n<p>because these are function calls, the evaluation of the <em>bodies</em> of <code>incr1</code> and <code>incr2</code> are <em>indeterminately sequenced</em>, not <em>unsequenced</em>, and since both orders result in <code>i</code> being incremented twice, the value of <code>i</code> at the end of the evaluation of the argument list is well-defined. Furthermore, the actual arguments passed to <code>f</code> are <em>unspecified</em>, not <em>undefined</em>; either the first or the second will be greater, but they will not be equal.</p>\n<p>That exception doesn't apply to the evaluation of the calls themselves, only to the evaluation of the bodies of the called function. So <code>f(g(i++), h(i++))</code> is still undefined behaviour, because the evaluation of the two subexpressions <code>i++</code> are not part of the evaluation of the body of either function.</p>\n<h3>Two side issues</h3>\n<ol>\n<li><p>Paragraph 15 also extends this exception to function calls which are the result of the semantics of the language, including operator overrides, with the interesting result that</p>\n<pre><code>f(i++, i++);\n</code></pre>\n<p>is <em>unspecified</em> rather than <em>undefined</em> if <code>i</code> is an instance of an object with an <code>operator++(int)</code> override. Similarly,</p>\n<pre><code>f(std::cout &lt;&lt; 'a', std::cout &lt;&lt; 'b');\n</code></pre>\n<p>will cause either <code>ab</code> or <code>ba</code> to be sent to <code>std::cout</code> (it is unspecified which), but is not <em>undefined behaviour</em>.</p></li>\n<li><p>The point of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1949\" rel=\"nofollow noreferrer\">DR 1949</a> is that \"sequenced after\" has never been formally defined. So rather than saying \"A is sequenced either before or after B\", the more precise formulation is \"either A is sequenced before B or B is sequenced before A\". You could achieve the same logical effect by formally defining \"A is sequenced after B\" as \"B is sequenced before A\". DR 1949 does both.</p></li>\n</ol>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-01-21T19:48:10.337", "Score": "2", "CreationDate": "2016-01-21T19:48:10.337", "ParentId": "34860809", "CommentCount": "0", "OwnerUserId": "1566221", "LastEditDate": "2017-05-23T10:29:00.967"}, "34860809": {"ViewCount": "150", "Body": "<p>[intro.execution]/15 contains these statements in page 11 of N4140 (emphasis is mine):  </p>\n<blockquote>\n<p id=\"so_34860809_34860809_0\">When calling a function (whether or not the function is inline), every\n  value computation and side effect associated with any argument\n  expression, or with the postfix expression designating the called\n  function, is sequenced before execution of every expression or\n  statement in the body of the called function. [ Note: Value\n  computations and side effects associated with different argument\n  expressions are unsequenced. \u2014end note ]\n  <strong>Every evaluation in the calling function (including other function calls) that is not otherwise specifically sequenced before or after\n  the execution of the body of the called function is indeterminately\n  sequenced with respect to the execution of the called\n  function</strong>.<sup>9</sup> </p>\n<p id=\"so_34860809_34860809_1\">9) In other words, function executions do not interleave with each\n  other.</p>\n</blockquote>\n<p>I'm wondering what are these evaluations in the calling function that are <strong>not</strong> specifically sequenced before the execution of the body of the called function?</p>\n<hr>\n<p><strong>* Edit *</strong> I claim both answers in the question <a href=\"https://stackoverflow.com/questions/30558980/sequenced-before-and-every-evaluation-in-the-calling-function-in-c\">\"sequence before\" and \"Every evaluation in the calling function\" in C++</a> have nothing whatsoever to do with my question. Please read my question and the answers given therein. See also my comment to the answer given below by @CoryKramer.</p>\n<hr>\n<p><strong>* Edit 2 *</strong> This is probably the answer to my question. See Proposed Resolution number 3 in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1949\" rel=\"nofollow noreferrer\">DR 1949</a>:</p>\n<p><strike>Every evaluation in the calling function (including other function calls) that is not otherwise specifically\nsequenced before or after the execution of the body of the called function is indeterminately sequenced with\nrespect to the execution of the called function</strike> For each function invocation F, for every evaluation A that occurs within F and every evaluation B that does not occur within F but is evaluated on the same thread and as part of the same signal handler (if any), either A is sequenced before B or B is sequenced before A.<sup>9</sup> [Note: if A and B would not otherwise be sequenced then they are indeterminately sequenced. \u2014end note]  </p>\n</hr></hr>", "Title": "What are these evaluations in the calling function that are not specifically sequenced before the body of the called function?", "CreationDate": "2016-01-18T17:38:18.733", "LastActivityDate": "2016-01-21T19:48:10.337", "CommentCount": "3", "LastEditDate": "2017-05-23T12:18:32.893", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "34860809", "Score": "6", "OwnerUserId": "1042389", "Tags": "<c++><language-lawyer><c++14>", "AnswerCount": "2"}});