post_cb({"18543786": {"LastActivityDate": "2013-08-31T03:53:27.827", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_18542804_18543786_0\">Is there any guarantee that global static initialization will be single threaded?</p>\n</blockquote>\n<p>You mean dynamic initialization.  No, single threaded initialization is explicitly not guaranteed.</p>\n<p>From 3.6.2:</p>\n<blockquote>\n<p id=\"so_18542804_18543786_1\">If a program starts a thread (30.3), the subsequent initialization\n  of a variable is unsequenced with respect to the initialization of a variable defined in a different translation\n  unit. Otherwise, the initialization of a variable is indeterminately sequenced with respect to the initialization\n  of a variable defined in a different translation unit. If a program starts a thread, the subsequent unordered\n  initialization of a variable is unsequenced with respect to every other dynamic initialization. Otherwise,\n  the unordered initialization of a variable is indeterminately sequenced with respect to every other dynamic\n  initialization</p>\n</blockquote>\n<p>So if you start a thread in your program then two different global variables from two different TUs could theoretically have their constructors running at the same time from two different threads.</p>\n<p>The best way to deal with these issues is to wrap your static storage duration variables as local static variables in the following \"singleton pattern\":</p>\n<pre><code>const T&amp; f()\n{\n    static T t(a,b,c);\n    return t;\n}\n</code></pre>\n<p>The latest standard guarantees that the construction of <code>t</code> is thread-safe, so you will not need a mutex at all (at least not one explicitly specified, the compiler will generate the guard for you).</p>\n<p>As an added benefit, the object is constructed \"lazily\" on the first call to <code>f</code>, so you don't need to worry about initialization order.  If multiple such singletons call each other in their constructors (provided the dependencies are acyclic of course), they will be initialized in a working order.  This is not the case for non-local variables.</p>\n", "PostTypeId": "2", "LastEditDate": "2013-08-31T03:53:27.827", "ParentId": "18542804", "Id": "18543786", "OwnerUserId": "1131467", "Score": "3", "CreationDate": "2013-08-31T02:05:17.987", "LastEditorUserId": "1131467"}, "18542804": {"FavoriteCount": "1", "ViewCount": "1426", "Id": "18542804", "AcceptedAnswerId": "18543786", "Score": "2", "Title": "Global static initialization threading", "LastEditorUserId": "2012007", "CommentCount": "18", "Body": "<p>I have a collection that I am protecting with a mutex.  After initialization it is only ever read, so I won't need a mutex there.</p>\n<p>The collection is initialized and populated in global static initializers.  I know that global static initialization is guaranteed within a single translation unit.  Is there any guarantee that global static initialization will be single threaded?</p>\n<hr>\n<p>I have a static collection that protected by a Schwarz counter and is populated by constructors of other static objects.  The container is associated with a mutex.  Given that the collection is read-only after <code>main</code> starts, I would like to get rid of the mutex if I can guarantee that static constructors are called in a single thread.</p>\n<p>My understanding is that static initialization order is generally well defined within a single translation unit, but unspecified between translation units.  Does the standard allow for the static objects to be initialized/constructed by different runtime provided threads?</p>\n<hr>\n<p>Schwarz counter:</p>\n<p>Header file:</p>\n<pre><code>struct Init\n{\n   Init();\n   ~Init();\n};\nnamespace\n{\n   Init _init;\n}\nextern std::map&lt;int, std::unique_ptr&lt;...&gt;&gt; &amp;protected;\n</code></pre>\n<p>Source file:</p>\n<pre><code>namespace\n{\n   int init_count;\n   std::aligned_storage&lt;sizeof(std::map&lt;int, std::unique_ptr&lt;...&gt;&gt;), alignof(std::map&lt;int, std::unique_ptr&lt;...&gt;&gt;&gt;)&gt; protected_storage;\n}\nstd::map&lt;int, std::uniqe_ptr&lt;...&gt;&gt; &amp;protected = *reinterpret_cast&lt;std::map&lt;int, std::unique_ptr&lt;...&gt;&gt; *&gt;(&amp;protected_storage);\nInit::Init()\n{\n   if (!init_counter++)\n   {\n      new(&amp;protected_storage) std::map&lt;int, std::unique_ptr&lt;...&gt;&gt;();\n   }\n}\nInit::~Init()\n{\n   if (!--init_counter)\n   {\n      protected.~std::map&lt;int, std::unique_ptr&lt;...&gt;&gt;();\n   }\n}\n</code></pre>\n<hr>\n<p>Collection population:</p>\n<pre><code>struct helper\n{\n   helper(...)\n   {\n      protected.insert(std::make_pair(...));\n   }\n};\n</code></pre>\n<p>A macro is expanded that creates static instances of helper.</p>\n</hr></hr></hr>", "Tags": "<c++><c++11>", "CreationDate": "2013-08-30T23:21:13.640", "LastEditDate": "2013-09-03T14:53:28.990", "LastActivityDate": "2013-09-03T14:53:28.990", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "2012007"}, "bq_ids": {"n4140": {"so_18542804_18543786_1": {"length": 48, "quality": 0.9795918367346939, "section_id": 7151}}, "n3337": {"so_18542804_18543786_1": {"length": 48, "quality": 0.9795918367346939, "section_id": 6895}}}});