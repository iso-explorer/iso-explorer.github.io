post_cb({"10524622": {"ParentId": "10524598", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Because the standard says so (see the section [expr.dynamic.cast] in the C++ standard):</p>\n<blockquote>\n<p id=\"so_10524598_10524622_0\">... <code>dynamic_cast&lt;T&gt;(v)</code></p>\n<p id=\"so_10524598_10524622_1\">... <code>v</code> shall be a pointer to or an lvalue of a polymorphic type</p>\n</blockquote>\n<p>In practice, because the <a href=\"http://en.wikipedia.org/wiki/RTTI\" rel=\"nofollow\">run-time type information (RTTI)</a> required to make dynamic down-casts (i.e. from base to derived) possible are generated along with the <a href=\"http://en.wikipedia.org/wiki/VTBL\" rel=\"nofollow\">vtbl/vptr mechanism</a>, which isn't required if there are no polymorphic member functions.</p>\n<p>Up-casts (i.e. derived to base), on the other hand, require no RTTI (there's no run-time decision to be made).  Quoting from the same section of the standard:</p>\n<blockquote id=\"so_10524598_10524622_2\">\n<pre><code>struct B { };\nstruct D : B { };\nvoid foo(D* dp) {\n    B* bp = dynamic_cast&lt;B*&gt;(dp); // equivalent to B* bp = dp;\n}\n</code></pre>\n</blockquote>\n", "OwnerUserId": "129570", "LastEditorUserId": "129570", "LastEditDate": "2012-05-09T22:41:51.363", "Id": "10524622", "Score": "6", "CreationDate": "2012-05-09T21:52:41.780", "LastActivityDate": "2012-05-09T22:41:51.363"}, "10524598": {"CommentCount": "0", "ViewCount": "1386", "CreationDate": "2012-05-09T21:51:06.013", "LastActivityDate": "2012-05-09T22:41:51.363", "Title": "dynamic cast not working for non polymorphic base class?", "PostTypeId": "1", "Id": "10524598", "Score": "2", "Body": "<p>Here the second cast gives an error saying </p>\n<p><code>cast.cc:35:35: error: cannot dynamic_cast \u2018base\u2019 (of type \u2018class CBase*\u2019) to type \u2018class CDerived*\u2019 (source type is not polymorphic)</code></p>\n<pre><code>    CBase * base = new CDerived; \n    CBase* pb;\n    CDerived * der = new CDerived; \n    CDerived* pd;\n    pb = dynamic_cast&lt;CBase*&gt;(der);     // ok: derived-to-base\n    pd = dynamic_cast&lt;CDerived*&gt;(base);  // wrong: base-to-derived\n</code></pre>\n<p>What is meannt by this ??</p>\n<p>And why this works if I make the base class polymorphic ?</p>\n<p>Can some one please let me know the basic concept behind this.</p>\n", "Tags": "<c++><casting>", "OwnerUserId": "1084308", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_10524598_10524622_1": {"section_id": 6185, "quality": 1.0, "length": 4}}, "n3337": {"so_10524598_10524622_1": {"section_id": 5784, "quality": 1.0, "length": 4}}, "n4659": {"so_10524598_10524622_1": {"section_id": 7687, "quality": 1.0, "length": 4}}}});