post_cb({"2612400": {"ParentId": "2611357", "CommentCount": "4", "Body": "<p>Read <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3043.html\" rel=\"nofollow noreferrer\">n3043</a>. Lambdas are now convertible to function pointers provided they don't have any state. I believe (...but do not know) GCC initially implemented this behavior accidentally, \"fixed it\", now will be re-adding it to 4.5 or 4.6. VC10 implemented lambdas correctly as initially designed, but not conforming to the latest working papers with n3043.</p>\n", "OwnerUserId": "238128", "PostTypeId": "2", "Id": "2612400", "Score": "1", "CreationDate": "2010-04-10T05:44:12.643", "LastActivityDate": "2010-04-10T05:44:12.643"}, "2611616": {"ParentId": "2611357", "LastEditDate": "2010-04-11T01:58:57.010", "CommentCount": "11", "CreationDate": "2010-04-09T23:34:53.160", "OwnerUserId": "153285", "LastEditorUserId": "153285", "PostTypeId": "2", "Id": "2611616", "Score": "4", "Body": "<p><s>I believe that GCC is noncompliant.</s> N3092 \u00a75.1.2/5 says</p>\n<blockquote>\n<p id=\"so_2611357_2611616_0\">The closure type for a\n  lambda-expression has a public inline\n  function call operator (13.5.4) whose\n  param- eters and return type are\n  described by the lambda-expression\u2019s\n  parameter-declaration-clause and\n  trailing- return-type respectively.\n  This function call operator is\n  declared const (9.3.1) if and only if\n  the lambda- expression\u2019s\n  parameter-declaration-clause is not\n  followed by mutable.</p>\n</blockquote>\n<p>So while many things about the closure object's type are implementation-defined, the function itself must be a member to be <code>public</code> and must be a nonstatic member to be <code>const</code>.</p>\n<p><strong>EDIT:</strong> This program indicates that <code>operator()</code> is a member function on GCC 4.6, which is essentially the same as 4.5.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\nusing namespace std;\n\ntemplate&lt; class ... &gt; struct print_types {};\n\ntemplate&lt;&gt; struct print_types&lt;&gt; {\n friend ostream &amp;operator&lt;&lt; ( ostream &amp;lhs, print_types const &amp;rhs ) {\n  return lhs;\n }\n};\n\ntemplate&lt; class H, class ... T &gt; struct print_types&lt;H, T...&gt; {\n friend ostream &amp;operator&lt;&lt; ( ostream &amp;lhs, print_types const &amp;rhs ) {\n  lhs &lt;&lt; typeid(H).name() &lt;&lt; \" \" &lt;&lt; print_types&lt;T...&gt;();\n  return lhs;\n }\n};\n\ntemplate&lt; class T &gt;\nstruct spectfun {\n friend ostream &amp;operator&lt;&lt; ( ostream &amp;lhs, spectfun const &amp;rhs ) {\n  lhs &lt;&lt; \"unknown\";\n  return lhs;\n }\n};\n\ntemplate&lt; class R, class ... A &gt;\nstruct spectfun&lt; R (*)( A ... ) &gt; {\n friend ostream &amp;operator&lt;&lt; ( ostream &amp;lhs, spectfun const &amp;rhs ) {\n  lhs &lt;&lt; \"returns \" &lt;&lt; print_types&lt;R&gt;()\n   &lt;&lt; \" takes \" &lt;&lt; print_types&lt;A ...&gt;();\n  return lhs;\n }\n};\n\ntemplate&lt; class C, class R, class ... A &gt;\nstruct spectfun&lt; R (C::*)( A ... ) &gt; {\n friend ostream &amp;operator&lt;&lt; ( ostream &amp;lhs, spectfun const &amp;rhs ) {\n  lhs &lt;&lt; \"member of \" &lt;&lt; print_types&lt;C&gt;() &lt;&lt; \", \" &lt;&lt; spectfun&lt;R (*)(A...)&gt;();\n  return lhs;\n }\n};\n\ntemplate&lt; class T &gt;\nstruct getcall {\n typedef decltype(&amp;T::operator()) type;\n};\n\nint main() {\n int counter = 0;\n\n auto count = [=]( int ) mutable { return ++ counter; };\n\n cerr &lt;&lt; spectfun&lt; getcall&lt;decltype(count)&gt;::type &gt;() &lt;&lt; endl;\n}\n</code></pre>\n<p>output:</p>\n<pre><code>member of Z4mainEUlvE_, returns i takes i\n</code></pre>\n<p><strong>EDIT:</strong> It looks like the only problem is that pointers to certain closure call operators fail to match ptmf template patterns. The workaround is to declare the lambda expression <code>mutable</code>. This is meaningless if there is no capture and only (aside from fixing the problem) seems to change the const-ness of the call operator.</p>\n<pre><code>template&lt; class T &gt;\nstruct getcall {\n    typedef decltype(&amp;T::operator()) type;\n    static type const value;\n};\ntemplate&lt; class T &gt;\ntypename getcall&lt;T&gt;::type const getcall&lt;T&gt;::value = &amp;T::operator();\n\nint main() {\n    auto id = []( int x ) mutable { return x; };\n    int (*idp)( int ) = id;\n    typedef decltype(id) idt;\n    int (idt::*idptmf)( int ) /* const */ = getcall&lt; decltype(id) &gt;::value;\n\ncerr &lt;&lt; spectfun&lt; decltype(idp) &gt;() &lt;&lt; endl;\ncerr &lt;&lt; spectfun&lt; decltype(idptmf) &gt;() &lt;&lt; endl;\ncerr &lt;&lt; spectfun&lt; getcall&lt;decltype(id)&gt;::type &gt;() &lt;&lt; endl;\n</code></pre>\n<p>output:</p>\n<pre><code>returns i takes i \nmember of Z4mainEUliE0_ , returns i takes i \nmember of Z4mainEUliE0_ , returns i takes i \n</code></pre>\n<p>Without the mutable and with the const, <code>spectfun</code> does not print signatures for either of the last two queries.</p>\n", "LastActivityDate": "2010-04-11T01:58:57.010"}, "bq_ids": {"n4140": {"so_2611357_2611616_0": {"section_id": 5964, "quality": 0.696969696969697, "length": 23}}, "n3337": {"so_2611357_2611616_0": {"section_id": 5733, "quality": 0.696969696969697, "length": 23}}, "n4659": {"so_2611357_2611616_0": {"section_id": 7453, "quality": 0.5757575757575758, "length": 19}}}, "6475854": {"ParentId": "2611357", "CommentCount": "0", "Body": "<p>I think gcc developers has a good reason for this behaivor. Remember, a static function do not have a \"this\" pointer, and when it is being actually called, the caller do not required to pass the \"this\" pointer. So this is a small performance optimisation when it is actually nothing contained in the closure object. And you can see the G++ developer leave you a way to workaround by declaring the lambda expression as \"mutable\" (remember you actually do not have anything to mutate).</p>\n", "OwnerUserId": "812034", "PostTypeId": "2", "Id": "6475854", "Score": "0", "CreationDate": "2011-06-25T04:36:26.543", "LastActivityDate": "2011-06-25T04:36:26.543"}, "2611357": {"CommentCount": "0", "CreationDate": "2010-04-09T22:26:21.303", "PostTypeId": "1", "AcceptedAnswerId": "2611616", "LastEditorUserId": "-1", "LastActivityDate": "2011-06-25T04:36:26.543", "LastEditDate": "2017-05-23T11:47:38.673", "ViewCount": "1646", "FavoriteCount": "3", "Title": "lambda traits inconsistency across C++0x compilers", "Id": "2611357", "Score": "15", "Body": "<p>I observed some inconsistency between two compilers (g++ 4.5, VS2010 RC) in the way they match lambdas with partial specializations of class templates. I was trying to implement something like boost::function_types for lambdas to extract type traits. Check <a href=\"https://stackoverflow.com/questions/2562320/specializing-a-template-on-a-lambda-in-c0x\">this</a> for more details.</p>\n<p>In g++ 4.5, the type of the <code>operator()</code> of a lambda appears to be like that of a free standing function (R (*)(...)) whereas in VS2010 RC, it appears to be like that of a member function (R (C::*)(...)). So the question is are compiler writers free to interpret any way they want? If not, which compiler is correct? See the details below.</p>\n<pre><code>template &lt;typename T&gt;\nstruct function_traits \n  : function_traits&lt;decltype(&amp;T::operator())&gt; \n{ \n// This generic template is instantiated on both the compilers as expected.\n};\n\ntemplate &lt;typename R, typename C&gt;\nstruct function_traits&lt;R (C::*)() const&gt;  { // inherits from this one on VS2010 RC\n  typedef R result_type;\n};\n\ntemplate &lt;typename R&gt;\nstruct function_traits&lt;R (*)()&gt; { // inherits from this one on g++ 4.5\n  typedef R result_type;\n};\n\nint main(void) {\n  auto lambda = []{};\n  function_traits&lt;decltype(lambda)&gt;::result_type *r; // void *\n}\n</code></pre>\n<p>This program compiles on both g++ 4.5 and VS2010 but the function_traits that are instantiated are different as noted in the code.</p>\n", "Tags": "<c++><lambda><c++11><traits>", "OwnerUserId": "25014", "AnswerCount": "3"}});