post_cb({"28247170": {"CommentCount": "2", "ViewCount": "73", "PostTypeId": "1", "LastEditorUserId": "701092", "CreationDate": "2015-01-31T01:21:56.727", "LastActivityDate": "2015-01-31T06:37:46.587", "Title": "Is this recursive reference with tuples safe?", "AcceptedAnswerId": "28247271", "LastEditDate": "2015-01-31T01:27:36.287", "Id": "28247170", "Score": "2", "Body": "<p>I'm experimenting and wrote this monster:</p>\n<pre><code>class my_tuple : public std::tuple &lt; std::vector&lt;my_tuple&gt; &gt; {};\n</code></pre>\n<p>And it compiles and actually works, it seems. And I find it dodgy because the following doesn't compile:</p>\n<pre><code>using my_other_tuple = std::tuple &lt; std::vector&lt;my_other_tuple&gt; &gt; ;\n</code></pre>\n<p>Ultimately, I'm trying to wrap my head around why my_tuple works and if there's any potential terrible consequences. I'm trying to learn what tuples are all about and what I can/am supposed to do with them. So if anyone would care to comment on that, give some nifty insights, I would appreciate it.</p>\n<p>Windows 7 and VS 2013.</p>\n", "Tags": "<c++><c++11><visual-studio-2013>", "OwnerUserId": "855367", "AnswerCount": "1"}, "28247271": {"ParentId": "28247170", "PostTypeId": "2", "CommentCount": "2", "Body": "<pre><code>class my_tuple : public std::tuple &lt; std::vector&lt;my_tuple&gt; &gt; {};\n</code></pre>\n<p>This is currently undefined behavior because it instantiates a standard library container, <code>std::vector</code>, with an incomplete type, <code>my_tuple</code>, which does not become complete until the closing <code>}</code> of its definition. However, there is a <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4056.html\" rel=\"nofollow\">proposal</a> to permit instantiating certain standard containers, including <code>std::vector</code>, with incomplete types. <a href=\"http://www.boost.org/doc/libs/1_57_0/doc/html/container/main_features.html#container.main_features.containers_of_incomplete_types\" rel=\"nofollow\">Boost.Containers supports incomplete types as well.</a></p>\n<pre><code>using my_other_tuple = std::tuple &lt; std::vector&lt;my_other_tuple&gt; &gt; ;\n</code></pre>\n<p>This is ill-formed. [dcl.typedef]/p2, emphasis mine:</p>\n<blockquote>\n<p id=\"so_28247170_28247271_0\">A <em>typedef-name</em> can also be introduced by an <em>alias-declaration</em>. The\n  <em>identifier</em> following the <code>using</code> keyword becomes a <em>typedef-name</em> and the optional <em>attribute-specifier-seq</em> following the <em>identifier</em>\n  appertains to that <em>typedef-name</em>. It has the same semantics as if it\n  were introduced by the <code>typedef</code> specifier. In particular, it does not\n  define a new type and <strong>it shall not appear in the <em>type-id</em></strong>.</p>\n</blockquote>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2015-01-31T06:37:46.587", "Id": "28247271", "Score": "5", "CreationDate": "2015-01-31T01:39:18.577", "LastActivityDate": "2015-01-31T06:37:46.587"}, "bq_ids": {"n4140": {"so_28247170_28247271_0": {"section_id": 5408, "quality": 0.967741935483871, "length": 30}}, "n3337": {"so_28247170_28247271_0": {"section_id": 5203, "quality": 0.967741935483871, "length": 30}}, "n4659": {"so_28247170_28247271_0": {"section_id": 6830, "quality": 0.9032258064516129, "length": 28}}}});