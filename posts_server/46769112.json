post_cb({"bq_ids": {"n4140": {"so_46769112_46769854_1": {"section_id": 286, "quality": 1.0, "length": 41}, "so_46769112_46769854_0": {"section_id": 5504, "quality": 1.0, "length": 35}, "so_46769112_46769854_2": {"section_id": 87, "quality": 1.0, "length": 5}}, "n3337": {"so_46769112_46769854_1": {"section_id": 277, "quality": 1.0, "length": 41}, "so_46769112_46769854_0": {"section_id": 5290, "quality": 1.0, "length": 35}, "so_46769112_46769854_2": {"section_id": 82, "quality": 1.0, "length": 5}}, "n4659": {"so_46769112_46769854_1": {"section_id": 293, "quality": 1.0, "length": 41}, "so_46769112_46769854_0": {"section_id": 6938, "quality": 0.9142857142857143, "length": 32}}}, "46769854": {"ParentId": "46769112", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>Regarding the example in the OP: as pointed out to me by <a href=\"https://stackoverflow.com/questions/46769112/hiding-of-member-function-templates-not-working-on-gcc/46769854?noredirect=1#comment80487059_46769854\">W.F.</a>, what matters here is that those are <strong>member</strong> function templates. You added a using declaration, which specifies (<a href=\"https://timsong-cpp.github.io/cppwp/n3337/namespace.udecl#15\" rel=\"nofollow noreferrer\">[namespace.udecl]/15</a>):</p>\n<blockquote>\n<p id=\"so_46769112_46769854_0\">When a using-declaration brings names from a base class into a derived\n  class scope, member functions and member function templates in the\n  derived class override and/or hide member functions and <strong>member\n  function templates with the same name, parameter-type-list, cv-qualification, and ref-qualifier (if any) in a base\n  class (rather than conflicting).</strong></p>\n</blockquote>\n<p>Note how template parameters aren't accounted. And it is Clang that treated the code correctly by hiding the <code>int</code> version.</p>\n<hr>\n<p>On the other hand if one examines the example <a href=\"http://coliru.stacked-crooked.com/a/34164635e522c61b\" rel=\"nofollow noreferrer\">tobi303</a> suggested <a href=\"https://stackoverflow.com/questions/46769112/hiding-of-member-function-templates-not-working-on-gcc/46769854?noredirect=1#comment80483811_46769112\">under your post</a>, GCC is kinda in the right. This simply isn't specified to be resolved somehow.</p>\n<p>For one, there's <a href=\"https://timsong-cpp.github.io/cppwp/n3337/temp.fct.spec#temp.arg.explicit-3\" rel=\"nofollow noreferrer\">[temp.fct.spec]/3</a>:</p>\n<blockquote>\n<p id=\"so_46769112_46769854_1\">Trailing template arguments that can be deduced or\n  obtained from default template-arguments may be omitted from the list\n  of explicit template-arguments. [...] <strong>In contexts where deduction is\n  done and fails, or in contexts where deduction is not done, if a\n  template argument list is specified and it, along with any default\n  template arguments, identifies a single function template\n  specialization, then the template-id is an lvalue for the function\n  template specialization</strong>.</p>\n</blockquote>\n<p>The text in bold indicates that your program is well-formed only if the template argument we give nominates a single specialization. And ostensibly, it doesn't, since according to <a href=\"https://timsong-cpp.github.io/cppwp/n3337/temp.arg.nontype#1\" rel=\"nofollow noreferrer\">[temp.arg.nontype]/1</a>:</p>\n<blockquote>\n<p id=\"so_46769112_46769854_2\">A template-argument for a non-type, non-template template-parameter\n  shall be one of:</p>\n<ul>\n<li>for a non-type template-parameter of integral or enumeration type, a converted constant expression of the type of the\n  template-parameter;</li>\n</ul>\n</blockquote>\n<p>And 0 fits both overloads as a converted constant expression. On account of there not being any ICS ranking for template arguments, this is ambiguous.</p>\n</hr>", "OwnerUserId": "817643", "LastEditorUserId": "817643", "LastEditDate": "2017-11-01T21:35:25.293", "Id": "46769854", "Score": "11", "CreationDate": "2017-10-16T12:01:47.913", "LastActivityDate": "2017-11-01T21:35:25.293"}, "46769112": {"CommentCount": "11", "AcceptedAnswerId": "46769854", "PostTypeId": "1", "LastEditorUserId": "6935629", "CreationDate": "2017-10-16T11:20:10.743", "LastActivityDate": "2017-11-01T21:35:25.293", "LastEditDate": "2017-10-27T07:56:28.007", "ViewCount": "536", "FavoriteCount": "4", "Title": "Hiding of member function templates - Which compiler is correct?", "Id": "46769112", "Score": "23", "Body": "<p>I wrote the following code that hiding of member function templates.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A \n{\n    template&lt;int&gt; void func()\n    {\n        std::cout&lt;&lt;\"Function tamplate of A\"&lt;&lt;std::endl;\n    }\n};\n\nstruct B : A \n{\n    template&lt;char&gt; void func()\n    {\n        std::cout&lt;&lt;\"Function tamplate of B\"&lt;&lt;std::endl;\n    }\n    using A::func;\n};\n\nint main()\n{\n    B().func&lt;0&gt;();\n}\n</code></pre>\n<p>This program working in in <strong>Clang</strong> compiler. <a href=\"https://wandbox.org/permlink/yHl9eb3mDqCesSPI\" rel=\"noreferrer\">Live demo Clang</a></p>\n<p>But, <strong>GCC</strong> compiler give an ambiguity error.<a href=\"https://wandbox.org/permlink/7sUns0T8GOVoi0gz\" rel=\"noreferrer\">Live demo GCC</a></p>\n<pre><code>source_file.cpp: In function \u2018int main()\u2019:\nsource_file.cpp:22:17: error: call of overloaded \u2018func()\u2019 is ambiguous\n     B().func&lt;0&gt;();\n</code></pre>\n<p>So, Which compiler is correct?</p>\n", "Tags": "<c++><c++11><templates><gcc><clang>", "OwnerUserId": "6935629", "AnswerCount": "1"}});