post_cb({"bq_ids": {"n4140": {"so_26168164_26178478_1": {"length": 24, "quality": 0.8571428571428571, "section_id": 5961}, "so_26168164_26178478_0": {"length": 5, "quality": 1.0, "section_id": 5961}, "so_26168164_26170459_1": {"length": 11, "quality": 0.8461538461538461, "section_id": 5979}}, "n3337": {"so_26168164_26178478_0": {"length": 5, "quality": 1.0, "section_id": 5730}, "so_26168164_26170459_1": {"length": 11, "quality": 0.8461538461538461, "section_id": 5747}}, "n4659": {"so_26168164_26178478_1": {"length": 24, "quality": 0.8571428571428571, "section_id": 7448}, "so_26168164_26178478_0": {"length": 5, "quality": 1.0, "section_id": 7448}, "so_26168164_26170459_1": {"length": 10, "quality": 0.7692307692307693, "section_id": 7461}}}, "26178478": {"Id": "26178478", "PostTypeId": "2", "Body": "<p>No the situation in C++14 has not changed at all and in fact the language in section <code>5.1.2</code> <em>Lambda expressions</em> paragraph <em>2</em> has been tightened from:</p>\n<blockquote>\n<p id=\"so_26168164_26178478_0\">A lambda-expression shall not appear in an unevaluated operand (Clause\n  5).</p>\n</blockquote>\n<p>to:</p>\n<blockquote>\n<p id=\"so_26168164_26178478_1\">[...]A lambda-expression shall not appear in an unevaluated operand\n  (Clause 5), in a templateargument, in an alias-declaration, in a\n  typedef declaration, or in the declaration of a function or function\n  template outside its function body and default arguments. [ Note: The\n  intention is to prevent lambdas from appearing in a signature. \u2014end\n  note ][...]</p>\n</blockquote>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1607\" rel=\"nofollow\">Defect report 1607. Lambdas in template parameters</a> lead to this change.</p>\n<p>The defect report only obliquely deals with the rationale for disallowing this but we can find a very detailed explanation for why this is disallowed in <a href=\"https://groups.google.com/forum/#!msg/comp.lang.c++.moderated/J9MbhcOrAzY/XjKeWEbU1EcJ\" rel=\"nofollow\">Rationale for lambda-expressions not being allowed in unevaluated contexts</a>. The reasons boil down to:</p>\n<ul>\n<li><em>Lambda expressions</em> not having a unique type</li>\n<li>Compiler implementation issues:\n<ul>\n<li>Such as an extraordinary expansion of <code>SFINAE</code></li>\n<li>The possible requirement to name mangle the whole body of a lambda. </li>\n</ul></li>\n</ul>\n<p>Given the rationale for this restriction it seems unlikely to change.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-10-06T15:48:13.550", "Score": "2", "CreationDate": "2014-10-03T11:54:24.123", "ParentId": "26168164", "CommentCount": "0", "LastEditDate": "2014-10-06T15:48:13.550", "OwnerUserId": "1708801"}, "26168164": {"ViewCount": "609", "Body": "<p>The question <a href=\"https://stackoverflow.com/questions/5849059/lambda-expressions-as-class-template-parameters\">Lambda expressions as class template parameters</a> asks about the possibility of using lambda expressions as class template parameters.</p>\n<p>The answer to the question was no. However, it was about C++11.</p>\n<p>Has the situation changed in the new standard, C++14?</p>\n", "AcceptedAnswerId": "26178478", "Title": "Lambda expressions as class template parameters in C++14", "CreationDate": "2014-10-02T19:27:49.837", "Id": "26168164", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:31:29.733", "LastEditorUserId": "-1", "LastActivityDate": "2016-03-17T10:39:36.483", "Score": "6", "OwnerUserId": "3642151", "Tags": "<c++><templates><lambda><language-lawyer><c++14>", "AnswerCount": "2"}, "26170459": {"Id": "26170459", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_26168164_26170459_0\">Has the situation changed in the new standard, C++14?</p>\n</blockquote>\n<p>A Lambda expression shall still not appear in an unevaluated operand - the same quote as the one in <a href=\"https://stackoverflow.com/a/5849247/3647361\">Xeo's Post</a> also exists in the latest publicly available draft N3797, in the exact same place.</p>\n<p>However, every closure type has a deleted default constructor (N3797, \u00a75.1.2/20):</p>\n<blockquote>\n<p id=\"so_26168164_26170459_1\">The closure type associated with a <em>lambda-expression</em> has a deleted\n  (8.4.3) default constructor and a deleted copy assignment operator.</p>\n</blockquote>\n<p>So, for portabiliby and standard conformance (and probably for the code to work on reasonable compilers), you would need to pass a closure object to the constructor of the instantiated class to copy from. But to pass a closure object <strong>of the same type as the template argument of that specialization</strong> you have to define it first anyway:</p>\n<pre><code>using my_map_type = map&lt;int, int, decltype([] (auto&amp;&amp; lhs, auto&amp;&amp; rhs) {return lhs &lt; rhs*4;})&gt;;\n// Assuming the above compiles\n\nmy_map_type m( [] (auto&amp;&amp; lhs, auto&amp;&amp; rhs) {return lhs &lt; rhs*4;} );\n// Different closure type - compiler error! What do you copy from!? \n</code></pre>\n<p>There isn't any legal way to create a single object of the closure type of the first lambda. Therefore, even if said rule was to be removed, you couldn't create a single instance of <code>my_map_type</code>. Similar problems occur with other \"closure type as template argument\" scenarios. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-03T07:10:35.880", "Score": "1", "CreationDate": "2014-10-02T22:12:25.117", "ParentId": "26168164", "CommentCount": "16", "LastEditDate": "2017-05-23T12:31:29.733", "OwnerUserId": "3647361"}});