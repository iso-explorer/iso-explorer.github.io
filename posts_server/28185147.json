post_cb({"bq_ids": {"n4140": {"so_28185147_28189804_0": {"length": 11, "quality": 1.0, "section_id": 7070}, "so_28185147_28189804_1": {"length": 15, "quality": 1.0, "section_id": 7070}, "so_28185147_28185147_0": {"length": 11, "quality": 1.0, "section_id": 7070}}, "n3337": {"so_28185147_28189804_0": {"length": 11, "quality": 1.0, "section_id": 6814}, "so_28185147_28189804_1": {"length": 15, "quality": 1.0, "section_id": 6814}, "so_28185147_28185147_0": {"length": 11, "quality": 1.0, "section_id": 6814}}, "n4659": {"so_28185147_28189804_1": {"length": 15, "quality": 1.0, "section_id": 8568}}}, "28189804": {"Id": "28189804", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_28185147_28189804_0\">If reordering member declarations in a class yields an alternate valid\n  program <strong>under (1) and (2)</strong>, the program is ill-formed, no\n  diagnostic is required.</p>\n</blockquote>\n<p>Despite the removal of this exact (superfluous) bullet point due to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1875\" rel=\"nofollow\">CWG issue #1875</a>, note the bolded part; If we reorder the declarations</p>\n<pre><code>struct A\n{\n    T i;\n    typedef char T;\n};\n</code></pre>\n<p>The program is not conforming to rule 2):</p>\n<blockquote>\n<p id=\"so_28185147_28189804_1\">2) A name <code>N</code> used in a class <code>S</code> shall refer to the same declaration\n  in its context and when re-evaluated in the completed scope of <code>S</code>. No\n  diagnostic is required for a violation of this rule.</p>\n</blockquote>\n<p><code>T</code> is used in the declaration of <code>i</code>, where it refers to the global <code>typedef</code>. However, when reevaluated in the completed scope of <code>A</code>, <code>T</code> refers to the member typedef, which is clearly a different declaration.<br>\nThis rule is not violated by your code, though.</br></p>\n<p>The standard gives an example to show the difference between my first snippet and yours, and their validity. [basic.scope.class]/5:</p>\n<pre><code>typedef char* T;\nstruct Y {\n    T a;             // error: T refers to ::T\n                     // but when reevaluated is Y::T\n    typedef long T;\n    T b;\n};\n</code></pre>\n<p>Thus the code in your question is indeed well-formed.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-07-01T16:05:59.770", "Score": "0", "CreationDate": "2015-01-28T10:25:11.577", "ParentId": "28185147", "CommentCount": "5", "OwnerUserId": "3647361", "LastEditDate": "2015-07-01T16:05:59.770"}, "28185147": {"ViewCount": "157", "Body": "<p>The program</p>\n<pre><code>#include &lt;iostream&gt;\n\ntypedef int T;\n\nstruct A\n{\n    typedef char T;\n    T i;\n};\n\nint main(){ }\n</code></pre>\n<p>should have been ill-formed, because <code>N4296::3.3.7/5 [basic.scope.class]</code>:</p>\n<blockquote>\n<p id=\"so_28185147_28185147_0\">If reordering member declarations in a class yields an alternate valid\n  program under (1) and (2), the program is ill-formed, no diagnostic is\n  required.</p>\n</blockquote>\n<p>But both clang and g++ compile it well</p>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/f8a6119dfe85f167\" rel=\"nofollow\">G++</a></strong></p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/c406edeaa049e0c4\" rel=\"nofollow\"><strong>CLANG</strong></a></p>\n<p>Is it their bug?</p>\n", "Title": "Reordering of the class members in clang and g++", "CreationDate": "2015-01-28T05:19:11.767", "LastActivityDate": "2015-07-01T16:05:59.770", "CommentCount": "1", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "Id": "28185147", "Score": "1", "Tags": "<c++><g++><clang>", "AnswerCount": "1"}});