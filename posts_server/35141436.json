post_cb({"bq_ids": {"n4140": {"so_35141436_35141554_1": {"length": 9, "quality": 0.6428571428571429, "section_id": 5572}}, "n3337": {"so_35141436_35141554_1": {"length": 9, "quality": 0.6428571428571429, "section_id": 5354}}, "n4659": {"so_35141436_35141554_1": {"length": 9, "quality": 0.6428571428571429, "section_id": 7019}}}, "35141436": {"ViewCount": "220", "Body": "<p>Which or what kind of STL algorithms are safe to use in a standard-compliant STL implementation?</p>\n<p>In other words: which or what kind STL algorithms are required by the standard to be single-pass?</p>\n<p>If the exhaustive list would be too long, a way to identify those which are safe is also OK.</p>\n", "AcceptedAnswerId": "35141554", "Title": "Which STL algorithms are safe to use with single-pass input iterators?", "CreationDate": "2016-02-01T22:15:45.403", "LastActivityDate": "2016-10-26T18:56:45.877", "CommentCount": "20", "LastEditDate": "2016-02-01T22:30:20.813", "PostTypeId": "1", "Tags": "<c++><stl><iterator><language-lawyer>", "Id": "35141436", "AnswerCount": "1", "Score": "2", "OwnerUserId": "59557", "ClosedDate": "2016-02-03T14:20:11.890", "LastEditorUserId": "59557"}, "35141554": {"Id": "35141554", "PostTypeId": "2", "Body": "<p>Algorithms which operate on <a href=\"http://en.cppreference.com/w/cpp/concept/InputIterator\" rel=\"nofollow\"><code>InputIterator</code></a>s and <a href=\"http://en.cppreference.com/w/cpp/concept/OutputIterator\" rel=\"nofollow\"><code>OutputIterator</code></a>s may by contract rely only on a single pass through the range they operate over.</p>\n<p>From cppreference<sup>1</sup>:</p>\n<p>On <a href=\"http://en.cppreference.com/w/cpp/concept/InputIterator\" rel=\"nofollow\"><code>InputIterator</code>s</a>:</p>\n<blockquote>\n<p id=\"so_35141436_35141554_0\">An InputIterator is an Iterator that can read from the pointed-to element. InputIterators only guarantee validity for single pass algorithms: once an InputIterator i has been incremented, all copies of its previous value may be invalidated. </p>\n</blockquote>\n<p>and on <a href=\"http://en.cppreference.com/w/cpp/concept/OutputIterator\" rel=\"nofollow\"><code>OutputIterator</code>s</a></p>\n<blockquote>\n<p id=\"so_35141436_35141554_1\">Assignment through the same value of an output iterator happens only once: algorithms on output iterators must be single-pass algorithms. </p>\n</blockquote>\n<hr>\n<p>This is a list of those algorithms which have arguments of <code>InputIterator</code> and <code>OutputIterator</code>:</p>\n<ul>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/all_any_none_of\" rel=\"nofollow\"><code>all_of, any_of and none_of</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/for_each\" rel=\"nofollow\"><code>for_each</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/count\" rel=\"nofollow\"><code>count and count_if</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/mismatch\" rel=\"nofollow\"><code>mismatch</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/equal\" rel=\"nofollow\"><code>equal</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/find\" rel=\"nofollow\"><code>find, find_if and find_if_not</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/find_first_of\" rel=\"nofollow\"><code>find_first_of</code></a> offers <code>InputIterator</code> behavior for the first iterator pair</li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/copy\" rel=\"nofollow\"><code>copy and copy_if</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/copy\" rel=\"nofollow\"><code>copy_n</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/move\" rel=\"nofollow\"><code>move</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/fill_n\" rel=\"nofollow\"><code>fill_n</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/transform\" rel=\"nofollow\"><code>transform</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/generate_n\" rel=\"nofollow\"><code>generate_n</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/remove_copy\" rel=\"nofollow\"><code>remove_copy and remove_copy_if</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/replace_copy\" rel=\"nofollow\"><code>replace_copy and replace_copy_if</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/unique_copy\" rel=\"nofollow\"><code>unique_copy</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/is_partitioned\" rel=\"nofollow\"><code>is_partitioned</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/partition_copy\" rel=\"nofollow\"><code>partition_copy</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/partial_sort_copy\" rel=\"nofollow\"><code>partial_sort_copy</code></a>, offers <code>InputIterator</code> behavior for the first iterator pair</li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/merge\" rel=\"nofollow\"><code>merge</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/includes\" rel=\"nofollow\"><code>includes</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/set_difference\" rel=\"nofollow\"><code>set_difference</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/set_intersection\" rel=\"nofollow\"><code>set_intersection</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference\" rel=\"nofollow\"><code>set_symmetric_difference</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/set_union\" rel=\"nofollow\"><code>set_union</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare\" rel=\"nofollow\"><code>lexicographical_compare</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/accumulate\" rel=\"nofollow\"><code>accumulate</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/inner_product\" rel=\"nofollow\"><code>inner_product</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/adjacent_difference\" rel=\"nofollow\"><code>adjacent_difference</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/partial_sum\" rel=\"nofollow\"><code>partial_sum</code></a></li>\n</ul>\n<p>added in C++17:</p>\n<ul>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/for_each_n\" rel=\"nofollow\"><code>for_each_n</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/sample\" rel=\"nofollow\"><code>sample</code></a> either the input or the output iterators may be single pass, but not both--either the input must satisfy <code>ForwardIterator</code> or the output must satisfy <code>RandomAccessIterator</code>.</li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/exclusive_scan\" rel=\"nofollow\"><code>exclusive_scan</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/inclusive_scan\" rel=\"nofollow\"><code>inclusive_scan</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/transform_reduce\" rel=\"nofollow\"><code>transform_reduce</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/transform_exclusive_scan\" rel=\"nofollow\"><code>transform_exclusive_scan</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/transform_inclusive_scan\" rel=\"nofollow\"><code>transform_inclusive_scan</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/memory/uninitialized_move\" rel=\"nofollow\"><code>uninitialized_move</code></a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/memory/uninitialized_move_n\" rel=\"nofollow\"><code>uninitialized_move_n</code></a></li>\n</ul>\n<p>Interestingly, there are three algorithms <em>not</em> on this list that one might expect: <a href=\"http://en.cppreference.com/w/cpp/algorithm/max_element\" rel=\"nofollow\"><code>max_element</code></a>, <a href=\"http://en.cppreference.com/w/cpp/algorithm/min_element\" rel=\"nofollow\"><code>min_element</code></a> and <a href=\"http://en.cppreference.com/w/cpp/algorithm/minmax_element\" rel=\"nofollow\"><code>minmax_element</code></a> are the standard's algorithms for finding the maximum, minimum and both the minimum and maximum value of a range. One might expect them to iterate over their given range only a single time, and thus require <code>InputIterator</code> arguments. Instead, they require <code>ForwardIterator</code> arguments, because rather than returning the <em>value</em> of the chosen element, they return an iterator to it. Since this violates the single pass requirement of an InputIterator, these algorithms are naturally left with a <code>ForwardIterator</code>.</p>\n<hr>\n<p><sup>1.  cppreference is backed on both counts by the standard (n4140 draft).</sup></p>\n<p><sup>\u00a724.2.3 [input.iterators] states that after <code>++r</code> where <code>r</code> is the input iterator, \"any copies of the previous value of r are no longer required either to be dereferenceable or to be in the domain of ==\"</sup></p>\n<p><sup>\u00a724.2.4 [output.iterators] states for both the expressions <code>*r = o</code> and <code>*r++ = o</code> \"After this operation r is not required to be dereferenceable.\"\n</sup></p>\n<p><sup>Both sections contain notes that mention that the iterator in question is safe for single pass ranges, stating that \"Algorithms on (input|output) iterators should never attempt to pass through the same iterator twice. They should be single pass algorithms.\" Of course, notes aren't binding.</sup></p>\n</hr></hr>", "LastEditorUserId": "4892076", "LastActivityDate": "2016-10-26T18:56:45.877", "Score": "14", "CreationDate": "2016-02-01T22:23:18.100", "ParentId": "35141436", "CommentCount": "2", "LastEditDate": "2016-10-26T18:56:45.877", "OwnerUserId": "4892076"}});