post_cb({"3499491": {"CreationDate": "2010-08-17T05:08:14.333", "CommentCount": "0", "Body": "<p>Section 5.1 of <a href=\"http://rads.stackoverflow.com/amzn/click/0201734842\" rel=\"noreferrer\">C++ Templates</a> explains this construct in detail</p>\n<p>The below function has a problem</p>\n<pre><code>template&lt;class T,class U&gt; \nvoid func2(myClass&lt;T&gt; k) \n{ \n    k.template func&lt;U&gt;(k); //even it does not compile \n\n} \n</code></pre>\n<p>Here T = char and U = int</p>\n<pre><code>myclass&lt;char&gt;::func&lt;int&gt;(myclass&lt;char&gt;) \n</code></pre>\n<p>is being called. However such a function does not exist</p>\n<p>Even though in normal circumstances 'char' is convertible to 'int', this does not hold good for explicitly specified template arguments</p>\n", "Id": "3499491", "OwnerUserId": "418110", "LastEditDate": "2010-08-17T05:19:46.397", "ParentId": "3499101", "LastActivityDate": "2010-08-17T05:19:46.397", "PostTypeId": "2", "Score": "7", "LastEditorUserId": "418110"}, "3499101": {"FavoriteCount": "1", "ViewCount": "3025", "Id": "3499101", "AcceptedAnswerId": "3507906", "Score": "7", "Title": "When do we need a .template construct", "LastEditorUserId": "165520", "CommentCount": "3", "Body": "<p>I made the following program</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\ntemplate&lt;class T&gt;\nstruct Class\n{\n    template&lt;class U&gt;\n    void display(){\n\n        std::cout&lt;&lt;typeid(U).name()&lt;&lt;std::endl;\n        return ;\n    }\n\n};\n\n\ntemplate&lt;class T,class U&gt;\nvoid func(Class&lt;T&gt;k)\n{\n    k.display&lt;U&gt;(); \n\n}\n\nint main()\n{\n    Class&lt;int&gt; d;\n    func&lt;int,double&gt;(d);\n}\n</code></pre>\n<p>The above program doesn not compile because <code>display()</code> is a template member function so a qualification of <code>.template</code> before <code>display()</code> must be done. Am I right?</p>\n<p>But when I made the following program</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\ntemplate&lt;typename T&gt;\nclass myClass\n{\n    T dummy;\n    /*******/\npublic:\n    template&lt;typename U&gt;\n    void func(myClass&lt;U&gt; obj);\n\n};\n\ntemplate&lt;typename T&gt;\ntemplate&lt;typename U&gt;\n\nvoid myClass&lt;T&gt;::func(myClass&lt;U&gt; obj)\n{\n    std::cout&lt;&lt;typeid(obj).name()&lt;&lt;std::endl;\n}\ntemplate&lt;class T,class U&gt;\nvoid func2(myClass&lt;T&gt;k)\n{\n    k.template func&lt;U&gt;(k); //even it does not compile\n\n}\nint main()\n{\n    myClass&lt;char&gt; d;\n    func2&lt;char,int&gt;(d);\n    std::cin.get();\n}\n</code></pre>\n<p>Why <code>k.func&lt;char&gt;(k);</code> does not compile even after giving  a <code>.template</code> construct?</p>\n", "Tags": "<c++><templates><member-functions>", "CreationDate": "2010-08-17T03:21:54.000", "LastEditDate": "2010-08-17T13:12:23.583", "LastActivityDate": "2010-08-17T23:56:28.827", "PostTypeId": "1", "AnswerCount": "4", "OwnerUserId": "165520"}, "3507906": {"CommentCount": "1", "Body": "<p>The <code>&lt;</code> symbol means both \"less than\" and \"begin template arguments.\" To distinguish between these two meanings, the parser must know whether the preceding identifier names a template or not.</p>\n<p>For example consider the code</p>\n<pre><code>template&lt; class T &gt;\nvoid f( T &amp;x ) {\n    x-&gt;variable &lt; T::constant &lt; 3 &gt;;\n}\n</code></pre>\n<p>Either <code>T::variable</code> or <code>T::constant</code> must be a template. The function means different things depending which is and which isn't:</p>\n<ol>\n<li>either <code>T::constant</code> gets compared to 3 and the Boolean result becomes a template argument to <code>T::variable&lt;&gt;</code></li>\n<li>or <code>T::constant&lt;3&gt;</code> gets compared to <code>x-&gt;variable</code>.</li>\n</ol>\n<p>The to disambiguate, the <code>template</code> keyword is required before either <code>variable</code> or <code>constant</code>. Case 1:</p>\n<pre><code>template&lt; class T &gt;\nvoid f( T &amp;x ) {\n    x-&gt;template variable &lt; T::constant &lt; 3 &gt;;\n}\n</code></pre>\n<p>Case 2:</p>\n<pre><code>template&lt; class T &gt;\nvoid f( T &amp;x ) {\n    x-&gt;variable &lt; T::template constant &lt; 3 &gt;;\n}\n</code></pre>\n<p>It would be kind of nice if the keyword were only required in actual ambiguous situations (which are kind of rare), but it makes the parser much easier to write and it prevents such problems from catching you by surprise.</p>\n<p>For standardese, see 14.2/4:</p>\n<blockquote>\n<p id=\"so_3499101_3507906_0\">When the name of a member template\n  specialization appears after . or -&gt;\n  in a postfix-expression, or after\n  nested-name-specifier in a\n  qualified-id, and the\n  postfix-expression or qualified-id\n  explicitly depends on a\n  template-parameter (14.6.2), the\n  member template name must be prefixed\n  by the keyword template. Otherwise the\n  name is assumed to name a\n  non-template.</p>\n</blockquote>\n", "CreationDate": "2010-08-17T23:56:28.827", "ParentId": "3499101", "Id": "3507906", "LastActivityDate": "2010-08-17T23:56:28.827", "PostTypeId": "2", "Score": "10", "OwnerUserId": "153285"}, "3499157": {"CommentCount": "0", "Body": "<p>The first example compiles and runs fine for me in VS 2010.  </p>\n", "CreationDate": "2010-08-17T03:38:52.553", "ParentId": "3499101", "Id": "3499157", "LastActivityDate": "2010-08-17T03:38:52.553", "PostTypeId": "2", "Score": "0", "OwnerUserId": "168871"}, "bq_ids": {"n4140": {"so_3499101_3507906_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 72}}, "n3337": {"so_3499101_3507906_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 67}}}, "3499145": {"CommentCount": "0", "Body": "<p>The standard requires the <code>template</code> or <code>typename</code> keywords to <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Name-lookup.html\" rel=\"nofollow noreferrer\">disambiguate things that depend on the template context</a>.</p>\n", "CreationDate": "2010-08-17T03:36:13.693", "ParentId": "3499101", "Id": "3499145", "LastActivityDate": "2010-08-17T03:36:13.693", "PostTypeId": "2", "Score": "0", "OwnerUserId": "10593"}});