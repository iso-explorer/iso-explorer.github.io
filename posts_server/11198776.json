post_cb({"11198921": {"ParentId": "11198776", "CommentCount": "1", "Body": "<p>Yes, in this case the two have the same behavior, but that's not necessarily always the case.</p>\n<p>Most uses of an array name give the address of the first element of the array. For an array of T, the type of the pointer will be <code>T *</code>.</p>\n<p>If you explicitly take the address of the array instead, you get the same address, but a different type (\"pointer to array of N objects of type T\" instead of \"Pointer to T\").</p>\n<p>In this case, the address you pass is converted to a <code>void *</code>, so that difference in type is immediately discarded -- but if you use them in another context that doesn't immediately discard the type difference, they won't necessarily have the same effect. Just for example, if you wanted to leave the first element of the array un-initialized, you might do something like:</p>\n<pre><code>memset(szMain+1, 'a', sizeof(szMain));\n</code></pre>\n<p>Since the type there is (in this case) \"pointer to char\", that will start from the second char in the array, as desired. If, however, you did:</p>\n<pre><code>memset(&amp;szMain+1, 'a', sizeof(szMain));\n</code></pre>\n<p>Instead of adding 1, it'll add the size of one array, so you'll be passing the address just after the end of the array, instead of the the address of the second element.</p>\n<p>As an aside: if you want 'a', I'd advise using it directly as I have above, rather than encoding the value in hex as you did in the question. At the very least, it's a lot more readable. It's theoretically more portable too, though few people really care about the machines (primarily IBM mainframes) where the hex value won't work correctly.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "11198921", "Score": "2", "CreationDate": "2012-06-25T23:37:35.190", "LastActivityDate": "2012-06-25T23:37:35.190"}, "11198871": {"ParentId": "11198776", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>What is happening is described in the standard as an <em>array-to-pointer conversion</em>.</p>\n<blockquote>\n<h3>4.2    Array-to-pointer conversion [conv.array]</h3>\n<p id=\"so_11198776_11198871_0\">An lvalue or rvalue of type \u201carray of N T\u201d or \u201carray of unknown bound\n  of T\u201d can be converted to an rvalue of type \u201cpointer to T\u201d. The result\n  is a pointer to the first element of the array.</p>\n</blockquote>\n<hr>\n<p>The above says that in your first call to <code>memset</code> <code>szMain</code> is converted to a pointer (more specifically a pointer to <code>char</code>) storing the address of the first element of your array.</p>\n<p>In the second call, <code>&amp;szMain</code> will yield a pointer of type <code>char (*)[512]</code>, ie. a pointer to an array which has the same type as <code>szMain</code>, storing the address of the array itself.</p>\n<p><em>Both of these expressions will yield the same exact value since the start of <code>szMain</code> is located at the same address as the first element of it (<code>szMain[0]</code>), but please not that they are not of the same type.</em></p>\n<hr>\n<p><code>memset</code> accepts a <code>void*</code> as the first argument, therefore any pointer type can be used implicitly to invoke the function.</p>\n</hr></hr>", "OwnerUserId": "1090079", "LastEditorUserId": "1090079", "LastEditDate": "2012-06-25T23:36:34.017", "Id": "11198871", "Score": "4", "CreationDate": "2012-06-25T23:30:47.420", "LastActivityDate": "2012-06-25T23:36:34.017"}, "11198833": {"ParentId": "11198776", "CommentCount": "6", "Body": "<p><code>szMain</code> is the identifier of an array.  In most contexts, array identifiers decay to become a pointer to the first element in the array, in other words <code>&amp;szMain[0]</code>.</p>\n<p>So in your first example, you're passing <code>memset</code> the address of the first element of the array.  In the second example, you're passing it the address of the array itself.  However, these are exactly the same address.</p>\n", "OwnerUserId": "129570", "PostTypeId": "2", "Id": "11198833", "Score": "3", "CreationDate": "2012-06-25T23:25:35.220", "LastActivityDate": "2012-06-25T23:25:35.220"}, "bq_ids": {"n4140": {"so_11198776_11198871_0": {"section_id": 11, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_11198776_11198871_0": {"section_id": 8, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_11198776_11198871_0": {"section_id": 12, "quality": 0.8888888888888888, "length": 16}}}, "11198776": {"CommentCount": "2", "ViewCount": "216", "CreationDate": "2012-06-25T23:20:09.293", "LastActivityDate": "2012-06-25T23:37:35.190", "Title": "memset difference?", "AcceptedAnswerId": "11198833", "PostTypeId": "1", "Id": "11198776", "Score": "2", "Body": "<p>I did read the usage of memset on msdn and on cplusplus.com, I know that(please correct me if im wrong):</p>\n<pre><code>int p =3;\n// p = object value\n// &amp;p = memory address where p is stored\n</code></pre>\n<p>so what is the difference of: </p>\n<pre><code>char szMain[512];\nmemset( szMain, 0x61, sizeof( szMain ) );\ncout &lt;&lt; szMain[4];\n</code></pre>\n<p>and:</p>\n<pre><code>char szMain[512];\nmemset( &amp;szMain, 0x61, sizeof( szMain ) );\ncout &lt;&lt; szMain[4];\n</code></pre>\n<p>(0x61 = a, ASCII table hex)</p>\n<p>why both have same behavior? Please forgive me if this isn't a constructive question.\nI'm somewhat of a newbie on c++ and i can't seem to understand.</p>\n", "Tags": "<c++><pointers>", "OwnerUserId": "1452014", "AnswerCount": "3"}});