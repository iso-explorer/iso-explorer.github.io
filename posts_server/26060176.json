post_cb({"26060449": {"ParentId": "26060176", "CommentCount": "0", "Body": "<p>Yes, it is possible to do so. C++ 11 14.3.3/3 specifically allows it, and provides an example.</p>\n<blockquote>\n<p id=\"so_26060176_26060449_0\">3 A <em>template-argument</em> matches a template <em>template-parameter</em> (call it <code>P</code>) when each of the template parameters\n  in the <em>template-parameter-list</em> of the <em>template-argument</em>\u2019s corresponding class template or alias template (call\n  it <code>A</code>) matches the corresponding template parameter in the <em>template-parameter-list</em> of <code>P</code>. <strong>When <code>P</code>\u2019s <em>template-parameter-list</em> contains a template parameter pack (14.5.3), the template parameter pack will match zero\n  or more template parameters or template parameter packs in the <em>template-parameter-list</em> of <code>A</code> with the\n  same type and form as the template parameter pack in <code>P</code> (ignoring whether those template parameters are\n  template parameter packs)</strong> [ <em>Example:</em></p>\n<pre><code>template &lt;class T&gt; struct eval;\n\ntemplate &lt;template &lt;class, class...&gt; class TT, class T1, class... Rest&gt;\nstruct eval&lt;TT&lt;T1, Rest...&gt;&gt; { };\n\ntemplate &lt;class T1&gt; struct A;\ntemplate &lt;class T1, class T2&gt; struct B;\ntemplate &lt;int N&gt; struct C;\ntemplate &lt;class T1, int N&gt; struct D;\ntemplate &lt;class T1, class T2, int N = 17&gt; struct E;\n\neval&lt;A&lt;int&gt;&gt; eA; // OK: matches partial specialization of eval\neval&lt;B&lt;int, float&gt;&gt; eB; // OK: matches partial specialization of eval\neval&lt;C&lt;17&gt;&gt; eC; // error: C does not match TT in partial specialization\neval&lt;D&lt;int, 17&gt;&gt; eD; // error: D does not match TT in partial specialization\neval&lt;E&lt;int, float&gt;&gt; eE; // error: E does not match TT in partial specialization\n</code></pre>\n<p id=\"so_26060176_26060449_1\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<p>(Emphasis mine)</p>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "26060449", "Score": "5", "CreationDate": "2014-09-26T13:11:52.483", "LastActivityDate": "2014-09-26T13:11:52.483"}, "26060493": {"ParentId": "26060176", "CommentCount": "1", "Body": "<p>[temp.arg.template] describes how template template arguments are matched with the corresponding parameter. In particular, C++11 14.3.3/3 says</p>\n<blockquote>\n<p id=\"so_26060176_26060493_0\">When P\u2019s <em>template-parameter-list</em> contains a template parameter pack, the template parameter pack will match zero or more template parameters or template parameter packs in the <em>template-parameter-list</em> of A with the same type and form as the template parameter pack in P</p>\n</blockquote>\n<p>where P is the parameter (<code>U</code> in your example), and A the argument (<code>A</code> in your example). So your example, with only a parameter pack, will match a template with any number of type parameters.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "26060493", "Score": "3", "CreationDate": "2014-09-26T13:13:55.013", "LastActivityDate": "2014-09-26T13:13:55.013"}, "bq_ids": {"n4140": {"so_26060176_26060449_0": {"section_id": 94, "quality": 0.9649122807017544, "length": 55}, "so_26060176_26060493_0": {"section_id": 94, "quality": 1.0, "length": 25}}, "n3337": {"so_26060176_26060449_0": {"section_id": 89, "quality": 0.9649122807017544, "length": 55}, "so_26060176_26060493_0": {"section_id": 89, "quality": 1.0, "length": 25}}, "n4659": {"so_26060176_26060449_0": {"section_id": 97, "quality": 0.8070175438596491, "length": 46}, "so_26060176_26060493_0": {"section_id": 97, "quality": 1.0, "length": 25}}}, "26060176": {"CommentCount": "3", "AcceptedAnswerId": "26060493", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-09-26T12:58:11.820", "LastActivityDate": "2014-09-26T13:13:55.013", "LastEditDate": "2017-05-23T10:32:32.870", "ViewCount": "234", "FavoriteCount": "1", "Title": "C++11 : Is it possible to give fixed-template-parameted template to varidic-template-template-parameter?", "Id": "26060176", "Score": "6", "Body": "<p>(Yes, the title is so weird thanks to my <em>poor</em> English; I hope someone can improve it.)</p>\n<p>Answering <a href=\"https://stackoverflow.com/questions/26059219/template-deduction-fails-for-stdmap-as-template-parameter\">this question</a>, I found that this code works:</p>\n<pre><code>template &lt;typename T1, typename T2&gt; class A { };\ntemplate &lt;template &lt;typename...&gt; class U&gt; class B { };\n\nint main()\n{\n    B&lt;A&gt; it_works;\n}\n</code></pre>\n<p>..although <code>template &lt;typename...&gt; class</code> and <code>template &lt;typename, typename&gt; class</code> aren't equal.</p>\n<p>I tried to figure out why it is possible and watch [temp.param] of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">N3337 standard</a>, but I can't find anything. How is it possible?</p>\n", "Tags": "<c++><templates><c++11><language-lawyer>", "OwnerUserId": "2729109", "AnswerCount": "2"}});