post_cb({"bq_ids": {"n4140": {"so_26346386_26346386_1": {"length": 25, "quality": 0.9259259259259259, "section_id": 6066}, "so_26346386_26346386_0": {"length": 42, "quality": 0.8936170212765957, "section_id": 5955}}, "n3337": {"so_26346386_26346386_1": {"length": 25, "quality": 0.9259259259259259, "section_id": 5834}, "so_26346386_26346386_0": {"length": 42, "quality": 0.8936170212765957, "section_id": 5724}}, "n4659": {"so_26346386_26346386_1": {"length": 25, "quality": 0.9259259259259259, "section_id": 7562}, "so_26346386_26346386_0": {"length": 42, "quality": 0.8936170212765957, "section_id": 7443}}}, "26346386": {"ViewCount": "97", "Body": "<p>I was trying to validate this statement (my emphasis) in paragraph \u00a75.1.1/8 (page 87) of the C++11 Standard</p>\n<blockquote>\n<p id=\"so_26346386_26346386_0\">A nested-name-specifier that denotes a class, optionally followed by\n  the keyword template (14.2), and then followed by the name of a member\n  of either that class (9.2) or one of its base classes (Clause 10), is\n  a qualified-id; 3.4.3.1 describes name lookup for class members that\n  appear in qualified-ids. The result is the member. The type of the\n  result is the type of the member. <strong>The result is an lvalue if the\n  member is a static member function or a data member and a prvalue\n  otherwise</strong>.</p>\n</blockquote>\n<p>with the following snippet:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace N {\n    class A {\n    public:\n        int i;\n        void f();\n    };\n}\n\nint main()\n{\n    std::cout &lt;&lt; &amp;N::A::f &lt;&lt; '\\n';\n    std::cout &lt;&lt; &amp;N::A::i &lt;&lt; '\\n';\n}\n</code></pre>\n<p><code>clang</code> and <code>gcc</code> compile this code and <code>VS2013</code> requires the definition of the member function <code>f</code>.</p>\n<p>All three of them print</p>\n<pre><code>1\n1\n</code></pre>\n<p>but I have no idea where these numbers come from.</p>\n<p><a href=\"http://rextester.com/WKAN91227\" rel=\"nofollow\">live example</a></p>\n<p>According to the paragraph highlighted above the expressions <code>N::A::f</code> is a prvalue, as <code>f</code> is not a static member function. Nonetheless, I was able to take its address in the code.</p>\n<p>At the same time, in \u00a75.3.1/3 one reads (emphasis mine):</p>\n<blockquote>\n<p id=\"so_26346386_26346386_1\">The result of the unary &amp; operator is a pointer to its operand. The\n  operand shall be an lvalue <strong>or</strong> a <em>qualified-id</em>. If the operand is a\n  <em>qualified-id</em> naming a non-static member m of some class C with type T,\n  the result has type \u201cpointer to member of class C of type T\u201d and is a\n  prvalue designating C::m.</p>\n</blockquote>\n<p>which gives the impression that neither <code>N::A::f</code> nor <code>N::A::i</code> are lvalues, as they are <em>qualified-id</em>s.</p>\n", "AcceptedAnswerId": "26346461", "Title": "Qualified-ids, are they lvalues or prvalues?", "CreationDate": "2014-10-13T18:20:54.447", "Id": "26346386", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-10-13T18:53:44.640", "Score": "0", "OwnerUserId": "2548699", "Tags": "<c++><c++11><language-lawyer><lvalue><qualified-name>", "AnswerCount": "1"}, "26346461": {"Id": "26346461", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_26346386_26346461_0\">but I have no idea where these numbers come from.</p>\n</blockquote>\n<p>Pointer-to-members aren't pointers. No <code>operator&lt;&lt;</code> can output their original value, the best <em>and only</em> match is the one that outputs <code>bool</code> values. Thus they are converted to <code>bool</code> (which obviously yields <code>true</code>) and the output is <code>1</code>. Try to insert <code>std::boolalpha</code> and check the output again.</p>\n<blockquote>\n<p id=\"so_26346386_26346461_1\">Nonetheless, I was able to take its address in the code.</p>\n</blockquote>\n<p>How is that a surprise to you? You quoted the part that allows and explains this exact construct. It clearly states that taking the adress of a qualified-id that names a non-static member designates that member.</p>\n<p><em>qualified-id</em>s are not only lvalues or rvalues. It completely depends on context. If they designate non-static members from outside that members class or any subclass of it, they have to be prvalues as they don't designate any specific object but rather a value (or information, in other words -- the type and an offset).</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-10-13T18:53:44.640", "Score": "2", "CreationDate": "2014-10-13T18:25:25.483", "ParentId": "26346386", "CommentCount": "6", "OwnerUserId": "3647361", "LastEditDate": "2014-10-13T18:53:44.640"}});