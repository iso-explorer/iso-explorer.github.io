post_cb({"bq_ids": {"n4140": {"so_25573711_25573937_0": {"length": 57, "quality": 0.890625, "section_id": 5908}}, "n3337": {"so_25573711_25573937_0": {"length": 57, "quality": 0.890625, "section_id": 5680}}}, "25573937": {"LastActivityDate": "2014-08-29T18:24:07.097", "CommentCount": "1", "Body": "<p>The fact that the array is a class member is an important part of this puzzle.</p>\n<p><code>static constexpr</code> (and in some cases, also <code>const</code>) class members have a special rule that they don't require a definition if they are never odr-used.  But your program does odr-use the variable, so according to the C++ standard you need a definition.</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/272900/103167\">Undefined reference to static class member</a></li>\n</ul>\n<p>The reason the behavior changed between <code>2</code> and <code>x</code> is that in the former case the optimizer was able to eliminate runtime access to the array.  But you can't rely on this<sup>1</sup>, the rule is that the definition is required if there is an odr-use.</p>\n<p>Here's the full rule, found in section 9.4.2 (<code>[class.static.data]</code>):</p>\n<blockquote>\n<p id=\"so_25573711_25573937_0\">If a non-volatile <code>const static</code> data member is of integral or enumeration type, its declaration in the class definition  can  specify  a  <em>brace-or-equal-initializer</em>  in  which  every  <em>initializer-clause</em>  that  is  an  <em>assignment-\n  expression</em>  is a constant expression (5.19).  A <code>static</code> data member of literal type can be declared in the class definition with the <code>constexpr</code> specifier;  if so, its declaration shall specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression.  [ Note:  In both these cases, the member may appear in constant expressions.  \u2014 end note ] <strong>The member shall still be defined in a namespace scope if it is odr-used (3.2) in the program and the namespace scope definition shall not contain an initializer.</strong></p>\n</blockquote>\n<hr>\n<p>In other circumstances, the optimization <em>is</em> required.  For example, you could use</p>\n<pre><code>var = sizeof (char[COORDINATES[0][2][0]]);\n</code></pre>\n<p>which is never an odr-use of <code>COORDINATES</code>.  But this guarantee is made only where a constant expression is required, like in an array bound, and not in general.</p>\n<p>Of course things go wrong if you try to use a negative array bound.  So maybe you'd prefer:</p>\n<pre><code>enum { varc = COORDINATES[0][2][0] };\nvar = varc;\n</code></pre>\n<p>The point is using it in a context which absolutely must be evaluated at compile time.</p>\n</hr>", "CreationDate": "2014-08-29T18:12:36.500", "LastEditDate": "2017-05-23T12:22:17.560", "ParentId": "25573711", "Id": "25573937", "LastEditorUserId": "-1", "PostTypeId": "2", "Score": "4", "OwnerUserId": "103167"}, "25573711": {"CreationDate": "2014-08-29T17:56:31.377", "ViewCount": "210", "FavoriteCount": "1", "Id": "25573711", "AcceptedAnswerId": "25573937", "Score": "2", "Title": "constexpr array not defined", "LastEditorUserId": "3952475", "CommentCount": "3", "Body": "<p>I'm with c++11. I'm trying to initialice a multidimensional array. The first try was</p>\n<pre><code>const static int COORDINATES[4][4][2]={{{-1,-1},{0,0},{1,1},{2,0}},\n                                       {{-1,1},{0,0},{1,-1},{0,-2}},\n                                        {{1,1},{0,0},{-1,-1},{-2,0}},\n                                         {{1,-1},{0,0},{-1,1},{0,2}}}; \n</code></pre>\n<p>Compiler complained about a constexpr, so I wrote</p>\n<pre><code>constexpr const static int COORDINATES[4][4][2]={{{-1,-1},{0,0},{1,1},{2,0}},\n                                       {{-1,1},{0,0},{1,-1},{0,-2}},\n                                        {{1,1},{0,0},{-1,-1},{-2,0}},\n                                         {{1,-1},{0,0},{-1,1},{0,2}}};\n</code></pre>\n<p>No erros, but when I use the array in a method, get an error. I don't understand...</p>\n<pre><code>void LShape::rotateShape(Square* cloneSquares) {\n    int var=COORDINATES[1][1][1]; //no problems\n    int x=2;\n    var=COORDINATES[0][x][0]; //error 'not defined' because of x\n                             //if changed to number, works\n}\n</code></pre>\n<p>The error:</p>\n<pre><code>LShape.cpp:23: referencia a `LShape::COORDINATES' sin definir //reference to L...S not defined\n</code></pre>\n<p>Where line 23 is the second use of COORDINATES</p>\n<p>My complete code, LShape header</p>\n<pre><code>#ifndef LSHAPE_H \n#define LSHAPE_H\n\n#include \"Square.h\"\n#include \"EmptySquare.h\"\n#include \"Shape.h\"\n\nclass LShape : public Shape {\n\npublic:\nLShape();\nLShape(const LShape&amp; orig);\nvirtual ~LShape();\n\ninline int getState() {return state;}\ninline int getNUMBER_OF_STATES() {return NUMBER_OF_STATES;}\ninline int getNUMBER_OF_SQUARES() {return NUMBER_OF_SQUARES;} \n\nvoid rotateShape(Square* cloneSquares);\n\n\nprivate:\nint state;\nstatic const int NUMBER_OF_STATES=4;\nstatic const int NUMBER_OF_SQUARES=4;\n\n\nconstexpr const static int INITIAL_COORDINATES[3][2]={{1,0},{1,0},{1,1}};\n\nconstexpr const static int COORDINATES[4][4][2]={{{-1,-1},{0,0},{1,1},{2,0}},\n                                       {{-1,1},{0,0},{1,-1},{0,-2}},\n                                        {{1,1},{0,0},{-1,-1},{-2,0}},\n                                         {{1,-1},{0,0},{-1,1},{0,2}}}; \n\n\n};\n#endif  /* LSHAPE_H */\n</code></pre>\n<p>LShape code</p>\n<pre><code>#include \"../../include/LShape.h\"\n\nLShape::LShape() : Shape(){\n    //numberSquares=4;\n    //squares = new Square[numberSquares];\n}\n\nLShape::~LShape(){\n    //dtor\n}\n\nLShape::LShape(const LShape&amp; other){\n    //copy ctor\n}\n\n\nvoid LShape::rotateShape(Square* cloneSquares) {\n\n    int var=COORDINATES[1][1][1]; //no problems\n    int x=2;\n    var=COORDINATES[0][x][0]; //error not defined\n}\n</code></pre>\n<p>By the way, I'm newbie in C++, don't be bad with me :)</p>\n<p>EDIT: I'm using the default compiler in linux (GCC) the IDE is using the following command</p>\n<pre><code>g++ -std=c++11   -c -g -MMD -MP -MF \"build/Debug/GNU-Linux-x86/src/shape/LShape.o.d\" -o build/Debug/GNU-Linux-x86/src/shape/LShape.o src/shape/LShape.cpp\n</code></pre>\n", "Tags": "<c++><arrays><c++11><constexpr>", "LastEditDate": "2014-08-29T18:11:57.797", "LastActivityDate": "2014-08-29T18:24:07.097", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "3952475"}, "25573919": {"CommentCount": "0", "Body": "<p>I removed `constexpr' and was able to compile the code at <a href=\"http://www.compileonline.com/compile_cpp_online.php\" rel=\"nofollow\">http://www.compileonline.com/compile_cpp_online.php</a></p>\n<pre><code>const static int COORDINATES[4][4][2]={{{-1,-1},{0,0},{1,1},{2,0}},\n                                      {{-1,1},{0,0},{1,-1},{0,-2}},\n                                      {{1,1},{0,0},{-1,-1},{-2,0}},\n                                      {{1,-1},{0,0},{-1,1},{0,2}}}; \n\n\nvoid LShape_rotateShape() \n{\n\n    int var=COORDINATES[1][1][1]; //no problems\n    int x=2;\n    var=COORDINATES[0][x][0]; //error not defined\n}\n</code></pre>\n<p>I compiled it successfully with the following compilers:</p>\n<ul>\n<li>C++ Online (GNU GCC version 4.8.1)</li>\n<li>C++11 Online (GNU GCC version 4.7.2)</li>\n</ul>\n", "CreationDate": "2014-08-29T18:11:25.100", "ParentId": "25573711", "Id": "25573919", "LastActivityDate": "2014-08-29T18:11:25.100", "PostTypeId": "2", "Score": "0", "OwnerUserId": "3421814"}});