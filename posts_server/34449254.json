post_cb({"34449254": {"CommentCount": "3", "ViewCount": "158", "PostTypeId": "1", "ClosedDate": "2015-12-26T03:41:44.110", "LastEditorUserId": "658087", "CreationDate": "2015-12-24T07:54:03.247", "LastActivityDate": "2015-12-25T09:51:32.960", "Title": "How is argument-dependent lookup looking *here*?", "LastEditDate": "2015-12-25T09:51:32.960", "Id": "34449254", "Score": "1", "Body": "<p>In VS2015 (but not using various other compilers on multiple platforms, including VS10), I'm getting </p>\n<pre><code>Charlie\\Gamma.cpp(224): error C2668: 'boost::make_shared': ambiguous call to overloaded function\n  E:\\C++Libs\\boost_1_60_0\\boost/smart_ptr/make_shared_object.hpp(246): note: could be 'boost::shared_ptr&lt;T&gt; boost::make_shared&lt;Able::Bravo::Charlie::Dog,Able::Bravo::Charlie::Egg&amp;,const uint32_t&amp;,const Frank&amp;&gt;(Able::Bravo::Charlie::Egg &amp;,const uint32_t &amp;,const Frank &amp;)' [found using argument-dependent lookup]\n          with\n          [\n              T=Able::Bravo::Charlie::Dog\n          ] (compiling source file Charlie\\Gamma.cpp)\n  D:\\@Prog-Charon\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\memory(968): note: or       'std::shared_ptr&lt;Able::Bravo::Charlie::Dog&gt; std::make_shared&lt;Able::Bravo::Charlie::Dog,Able::Bravo::Charlie::Egg&amp;,const uint32_t&amp;,const Frank&amp;&gt;(Able::Bravo::Charlie::Egg &amp;,const uint32_t &amp;,const Frank &amp;)' (compiling source file Charlie\\Gamma.cpp)\n  Charlie\\Gamma.cpp(224): note: while trying to match the argument list '(Able::Bravo::Charlie::Egg, const uint32_t, const Frank)'\n</code></pre>\n<p>(with my closed-source names sanitized, and Boost and standard names left intact)</p>\n<p>The code is:</p>\n<pre><code>namespace Able {\nnamespace Bravo {\nnamespace Charlie {\n\n\nusing std::string;\nusing std::tr1::shared_ptr;\nusing std::tr1::make_shared;\n\n\u22ee  // then later in the file\n\nshared_ptr&lt;Dog&gt; Gamma::knockout (const Hotel&amp; target)\n{\n   Egg softboiled (target.ID);\n   softboiled.sequence ^= 0x40000000;\n   return make_shared&lt;Dog&gt;(softboiled, target.kin, Frank::myself());\n}\n</code></pre>\n<p>The use of <code>make_shared</code> sees <code>std::tr1::make_shared</code> brought into scope via the <code>using</code> declaration, and that's what is intended.  The error shows that it is resolving to <code>std::make_shared</code>, and I expect that <code>tr1</code> is just a bunch of typedefs for backward compatibility.</p>\n<p>But it also reports finding <code>boost::make_shared</code> via argument-dependent lookup.  But the arguments are</p>\n<pre><code>Able::Bravo::Charlie::Egg &amp;,\nconst uint32_t &amp;,\nconst Frank &amp;\n</code></pre>\n<p>none of which are in the <code>boost</code> namespace.</p>\n<p>So why would it be finding <code>boost::make_shared</code> via argument-dependent lookup?</p>\n<p><strong>Hmm</strong>, could it be because <code>Frank</code> is derived <em>privately</em> from <code>boost::totally_ordered1</code> (and <code>Egg</code> from <code>boost::totally_ordered</code>)?  Is this a change in the lookup rules, a fix or bug in <em>one</em> of the compilers, or something like that?</p>\n<p>If that's correct, then any use of boost's mix-in types will cause all sorts of ambiguities as old boost stuff matches the names of now-standard functions, or common names in general.  These private base classes end up polluting my class's namespace without even being apparent in the public interface that it's at all related to boost!  That can't be right.</p>\n<hr>\n<p><strong>Update:</strong>  This occurs with Boost 1.60 but not with Boost 1.59.  So disregard my conclusion that it varies by compiler/platform: it's worked on various platforms with an older version of Boost.</p>\n<p>I moved to the latest release Boost as a first step to solve compile-time issues happening with Boost, and it seems to have introduced another instead.</p>\n<p>Boost\u2019s operators.hpp defines template <code>struct totally_ordered2</code> etc. within namespace <code>boost</code>, not anything more fancy, in Boost version 1.59.</p>\n</hr>", "Tags": "<c++><boost><c++14><argument-dependent-lookup>", "OwnerUserId": "658087", "AnswerCount": "1"}, "34449471": {"ParentId": "34449254", "CommentCount": "3", "Body": "<p>It does look like it's because, like you say, <code>Frank</code> derives from <code>boost::totally_ordered1</code>.</p>\n<p>\u00a7 3.4.2 [basic.lookup.argdep] of the C++14 standard (n4296) specifies the sets of namespaces and classes that are considered. Here is \u00a7 3.4.2/2:</p>\n<blockquote>\n<p id=\"so_34449254_34449471_0\">For each argument type <code>T</code> in the function call, there is a set of zero or more associated namespaces and a set of zero or more associated classes to be considered. The sets of namespaces and classes is determined entirely by the types of the function arguments (and the namespace of any template template argument). Typedef names and <em>using-declarations</em> used to specify the types do not contribute to this set. The sets of namespaces and classes are determined in the following way:</p>\n</blockquote>\n<p>and \u00a7 3.4.2/2.2 concerns class types:</p>\n<blockquote>\n<p id=\"so_34449254_34449471_1\">If <code>T</code> is a class type (including unions), its associated classes are: the <strong>class itself</strong>; the class of which it is a member, if any; <strong>and its direct and indirect base classes</strong>. <strong>Its associated namespaces are the innermost enclosing namespaces of its associated classes</strong>. Furthermore, if <code>T</code> is a class template specialization, its associated namespaces and classes also include: the namespaces and classes associated with the types of the template arguments provided for template type parameters (excluding template template parameters); the namespaces of which any template template arguments are members; and the classes of which any member templates used as template template arguments are members. [ <em>Note</em>: Non-type template arguments do not contribute to the set of associated namespaces. \u2014<em>end note</em> ]</p>\n</blockquote>\n<hr/>\n<p><strong>Edit</strong>: Just saw your update, not sure what could account for it working in 1.59 but not 1.60 under the same compiler, flags, and C++ version.</p>\n", "OwnerUserId": "101090", "PostTypeId": "2", "Id": "34449471", "Score": "4", "CreationDate": "2015-12-24T08:14:10.660", "LastActivityDate": "2015-12-24T08:14:10.660"}, "bq_ids": {"n4140": {"so_34449254_34449471_1": {"section_id": 7104, "quality": 0.9577464788732394, "length": 68}, "so_34449254_34449471_0": {"section_id": 7104, "quality": 0.9318181818181818, "length": 41}}, "n3337": {"so_34449254_34449471_1": {"section_id": 6848, "quality": 0.9295774647887324, "length": 66}, "so_34449254_34449471_0": {"section_id": 6848, "quality": 0.9318181818181818, "length": 41}}, "n4659": {"so_34449254_34449471_1": {"section_id": 8605, "quality": 0.9577464788732394, "length": 68}, "so_34449254_34449471_0": {"section_id": 8605, "quality": 0.8409090909090909, "length": 37}}}});