post_cb({"34552056": {"CommentCount": "4", "ViewCount": "182", "PostTypeId": "1", "LastEditorUserId": "4958516", "CreationDate": "2015-12-31T22:19:49.867", "LastActivityDate": "2016-01-11T07:19:29.293", "Title": "What does \"The template arguments of a specialization are deduced from the arguments of the primary template\" mean?", "AcceptedAnswerId": "34716046", "LastEditDate": "2016-01-02T22:27:52.740", "Id": "34552056", "Score": "2", "Body": "<blockquote>\n<p id=\"so_34552056_34552056_0\">N4567 14.5.5.1 [temp.class.spec.match]p4</p>\n<p id=\"so_34552056_34552056_1\">In a type name that refers to a class template specialization, (e.g., A) the argument list shall\n  match the template parameter list of the primary template. <strong>The template arguments of a specialization are deduced from the arguments of the primary template.</strong></p>\n</blockquote>\n<pre><code>template&lt;class T1, class T2, int I&gt; class A             { }; // #1\ntemplate&lt;class T, int I&gt;            class A&lt;T, T*, I&gt;   { }; // #2\nA&lt;int, int, 1&gt;   a1; // uses #1\n</code></pre>\n<p>Does this \"deduced\" mean 14.8.2.5 [temp.deduct.type]? </p>\n<blockquote>\n<p id=\"so_34552056_34552056_2\">Template arguments can be deduced in several different contexts, but in each case a type that is specified in terms of template parameters (call it <code>P</code>) is compared with an actual type (call it <code>A</code>), and an attempt is made to find template argument values (a type for a type parameter, a value for a non-type parameter, or a template for a template parameter) that will make <code>P</code>, after substitution of the deduced values (call it the deduced A), compatible with A.</p>\n</blockquote>\n<p>If it does, what is the P and A?</p>\n<p><em>The template arguments of a specialization</em> means <em>the <strong>actual</strong> template arguments of the <strong>primary template</strong></em> <code>int, int, 1</code> <strong>or</strong> <em>the template arguments of the <strong>partial specialization</strong></em> <code>T, T*, I</code> or other?</p>\n<p><em>the arguments of the primary template</em> means <em>the <strong>actual</strong> template arguments of the primary template</em> <code>int, int, 1</code> <strong>or</strong> <em>the <strong>implicitly</strong> template arguments of the primary template</em> <code>T1, T2, I</code> or other?</p>\n<p>What does this sentence mean?</p>\n<hr>\n<p><strong>UPDATE:</strong></p>\n<p>It looks @Igor Tandetnik and @R Sahu have different answers, I need more help.</p>\n</hr>", "Tags": "<c++><templates><language-lawyer>", "OwnerUserId": "4958516", "AnswerCount": "2"}, "34552118": {"ParentId": "34552056", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Given your template and its specialization, using:</p>\n<pre><code>A&lt;int, int*, 1&gt;   a2;\n</code></pre>\n<p>will use the specialization.</p>\n<p>For this usage, </p>\n<p>The template parameters of the primary template are <code>int</code>, <code>int*</code>, and <code>1</code>.<br>\nThe template parameters of the template specialization are <code>int</code>, and <code>1</code>.  </br></p>\n<p>The arguments of the specialization, <code>int</code> and <code>1</code> are deduced from the arguments of the primary template, <code>int</code>, <code>int*</code>, and <code>1</code>.</p>\n<p>In this case,</p>\n<p><code>P</code> is <code>int</code>, <code>int*</code>, and <code>1</code>.<br>\n<code>A</code> is the specialization.</br></p>\n<p>I think that's the answer you are looking for.</p>\n", "OwnerUserId": "434551", "LastEditorUserId": "434551", "LastEditDate": "2015-12-31T23:21:03.983", "Id": "34552118", "Score": "-1", "CreationDate": "2015-12-31T22:30:39.177", "LastActivityDate": "2015-12-31T23:21:03.983"}, "bq_ids": {"n4140": {"so_34552056_34716046_5": {"section_id": 147, "quality": 0.5294117647058824, "length": 9}, "so_34552056_34552056_2": {"section_id": 332, "quality": 1.0, "length": 44}, "so_34552056_34716046_3": {"section_id": 294, "quality": 1.0, "length": 24}, "so_34552056_34716046_1": {"section_id": 146, "quality": 0.6363636363636364, "length": 7}, "so_34552056_34716046_0": {"section_id": 146, "quality": 0.9583333333333334, "length": 23}, "so_34552056_34552056_1": {"section_id": 146, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_34552056_34716046_5": {"section_id": 141, "quality": 0.5294117647058824, "length": 9}, "so_34552056_34552056_2": {"section_id": 322, "quality": 1.0, "length": 44}, "so_34552056_34716046_3": {"section_id": 285, "quality": 1.0, "length": 24}, "so_34552056_34716046_1": {"section_id": 140, "quality": 0.6363636363636364, "length": 7}, "so_34552056_34716046_0": {"section_id": 140, "quality": 0.9583333333333334, "length": 23}, "so_34552056_34552056_1": {"section_id": 140, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_34552056_34552056_2": {"section_id": 341, "quality": 1.0, "length": 44}, "so_34552056_34716046_1": {"section_id": 150, "quality": 0.6363636363636364, "length": 7}, "so_34552056_34716046_3": {"section_id": 301, "quality": 1.0, "length": 24}, "so_34552056_34552056_1": {"section_id": 150, "quality": 0.9545454545454546, "length": 21}, "so_34552056_34716046_0": {"section_id": 150, "quality": 0.9583333333333334, "length": 23}}}, "34716046": {"ParentId": "34552056", "CommentCount": "3", "Body": "<p>First, it should be noted that <a href=\"https://github.com/cplusplus/draft/blob/master/papers/n4567.pdf\" rel=\"nofollow\">these rules</a> are meant more as if you were implementing a C++ parser (like a compiler), so if one of these specific rules is not met, then the program should be non-conforming (and an error generated). So in the paragraph you mention:</p>\n<blockquote>\n<p id=\"so_34552056_34716046_0\">In a type name that refers to a class template specialization, (e.g., <code>A&lt;int, int, 1&gt;</code>) the argument list shall match the template parameter list of the primary template. The template arguments of a specialization are deduced from the arguments of the primary template.</p>\n</blockquote>\n<p>Think of it to mean that if the source being parsed does not meet the restrictions of these paragraphs, it is non-conforming so generate an error.</p>\n<p>Directly answering the main question of:</p>\n<blockquote>\n<p id=\"so_34552056_34716046_1\">What does <i>\u201cThe template arguments of a specialization are deduced from the arguments of the primary template\u201d</i> mean?</p>\n</blockquote>\n<p><code>14.5.5</code> is about template partial specializations, <code>14.5.5.1</code> is specifically about matching the partial specialization and paragraph 4 (where the sentence is from) is just saying that the template arguments passed to a template must match those of a specialized template.</p>\n<p>The last sentence of paragraph 4 (the one in question), is simply saying that the arguments passed in are deduced based on the main template. </p>\n<p>It gives an example of <code>A&lt;int, int, 1&gt;</code> when talking about this paragraph, and it's referring to the other template specializations in the example it gives in <code>14.5.5.1</code> (separated for easier reading):</p>\n<pre><code>// #1 (main template)\ntemplate&lt;class T1, class T2, int I&gt;\nclass A\n{ };\n\n// #2\ntemplate&lt;class T, int I&gt;\nclass A&lt;T, T*, I&gt;\n{ };\n\n// #3\ntemplate&lt;class T1, class T2, int I&gt;\nclass A&lt;T1*, T2, I&gt;\n{ };\n\n// #4\ntemplate&lt;class T&gt;\nclass A&lt;int, T*, 5&gt;\n{ };\n\n// #5\ntemplate&lt;class T1, class T2, int I&gt; \nclass A&lt;T1, T2*, I&gt;\n{ };\n</code></pre>\n<p>So, given the following code:</p>\n<pre><code>A&lt;int, int, 1&gt; a1;\nA&lt;int, char*, 5&gt; a2;\nA&lt;int, int, 2.0f&gt; a3;\nA&lt;int*&gt; a4;\n</code></pre>\n<p><code>a1</code> will compile fine, and template <code>#1</code> will be used (since it matches exactly to that specialization), so template <code>#1</code> will compile to the following:</p>\n<pre><code>template&lt;\n    class T1 = int,\n    class T2 = int,\n    int I = 1&gt;\nclass A\n{ };\n</code></pre>\n<p><code>a2</code> will compile fine as well and template <code>#4</code> will be used as such:</p>\n<pre><code>template&lt;\n    class T = char&gt;\nclass A&lt;int, T*, 5&gt;\n{ };\n</code></pre>\n<p><code>a3</code>, however, doesn't match any of the template specializations, and a conforming compiler will generate an error when compiling <code>a3</code> since the types of <code>int</code> do not match type of <code>float</code>; that is, <code>a3</code> would generate a template of the following type:</p>\n<pre><code>template&lt;\n    class T1 = int,\n    class T2 = int,\n    int I = 2.0f&gt;\nclass A\n{ };\n</code></pre>\n<p>And thus should generate an error since an <code>int</code> is not a <code>float</code>. Lastly, <code>a4</code> will not compile as well since it only has 1 template argument and all template specializations for <code>A</code> take 3 arguments.</p>\n<p>Continuing with your questions:</p>\n<blockquote>\n<p id=\"so_34552056_34716046_2\">Does this \"deduced\" mean 14.8.2.5 [temp.deduct.type]? </p>\n</blockquote>\n<p>Yes and no, <code>deduced</code> is referring to the whole of <code>14.8.2 Template argument deduction</code>, where paragraph 2 states:</p>\n<blockquote>\n<p id=\"so_34552056_34716046_3\">When an explicit template argument list is specified, the template arguments must be compatible with the template parameter list and must result in a valid function type as described below; otherwise type deduction fails.</p>\n</blockquote>\n<p>Where <code>described below</code> has additional points not posted here for brevities sake.</p>\n<p>However, <code>14.8.2.5</code> specifically refers to <i>how</i> to deduce the type in a conforming way, and if a template specialization can't be deduced this way then it should fail (i.e. compiler should generate an error).</p>\n<blockquote>\n<p id=\"so_34552056_34716046_4\">If it does, what is the P and A?</p>\n</blockquote>\n<p>The <code>P</code> and <code>A</code> in this sentence are just place holder values to use for the rest of the text.</p>\n<p>Specifically what it's trying to get at is that <code>P</code> is to mean a template argument and <code>A</code> is to mean an actual type that can be used, like an <code>int</code> or <code>std::string</code> or a user defined type like a <code>class</code>, <code>struct</code> or <code>typedef</code>, or function.</p>\n<p>Take this code for example:</p>\n<pre><code>#1\ntemplate &lt; class T &gt;\nstruct A {\n    T val;\n};\n\n#2\ntemplate&lt;&gt;\nstruct A&lt;double&gt;\n{\n    double val;\n};\n\nint main() {\n    A&lt;int&gt; a1; // uses #1\n    A&lt;double&gt; a2; // uses #2\n    A&lt;someVal&gt; a3; // uses #1 but generate error since `someVal` is invalid type\n}\n</code></pre>\n<p>In this code, the <code>P</code> val would be the template argument of <code>class T</code> and the <code>A</code> val would be <code>int</code> for <code>a1</code>, <code>double</code> for <code>a2</code> and <code>someVal</code> for <code>a3</code>. A conforming compiler should generate an error for <code>a3</code> since there is not type <code>that will make P, after substitution of the deduced values (call it the deduced A), compatible with A</code>, since <code>someVal</code> is not a valid type.</p>\n<p>Using the example <code>A&lt;int, int, 2.0f&gt; a3;</code> from above, since there were no templates defined that could take the last argument (the <code>2.0f</code>), the <code>P</code> val here is <code>int</code> and the <code>A</code> val is <code>2.0f</code>; since <code>2.0f</code> is not an <code>int</code>, this template deduction fails and an error is generated.</p>\n<p>You also asked:</p>\n<blockquote>\n<p id=\"so_34552056_34716046_5\">The template arguments of a specialization means the actual template arguments of the primary template int, int, 1 or the template arguments of the partial specialization T, T*, I or other?</p>\n</blockquote>\n<p><code>The template arguments of a specialization</code> is referring to the arguments passed into the template, so in <code>A&lt;int, int, 1&gt;</code> the template arguments of this specializations are <code>int</code>, <code>int</code> and <code>1</code>.</p>\n<blockquote>\n<p id=\"so_34552056_34716046_6\">the arguments of the primary template means the actual template arguments of the primary template int, int, 1 or the implicitly template arguments of the primary template T1, T2, I or other?</p>\n</blockquote>\n<p><code>the arguments of the primary template</code> are referring to the primary template itself, so in the <code>A</code> example above, the primary template would be <code>template&lt;class T1, class T2, int I&gt; class A { };</code></p>\n<p>I hope that can help.</p>\n", "OwnerUserId": "1152524", "PostTypeId": "2", "Id": "34716046", "Score": "0", "CreationDate": "2016-01-11T07:19:29.293", "LastActivityDate": "2016-01-11T07:19:29.293"}});