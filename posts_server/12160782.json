post_cb({"bq_ids": {"n4140": {"so_12160782_12160964_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 7233}}, "n3337": {"so_12160782_12160964_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 6977}}, "n4659": {"so_12160782_12160964_0": {"length": 9, "quality": 0.75, "section_id": 8746}}}, "12160964": {"Id": "12160964", "PostTypeId": "2", "Body": "<p>GCC is correct. From paragraph 4 of 3.10 Lvalues and rvalues [basic.lval]:</p>\n<blockquote>\n<p id=\"so_12160782_12160964_0\">Class prvalues can have cv-quali\ufb01ed types; non-class prvalues always have cv-unquali\ufb01ed types. [...]</p>\n</blockquote>\n<p>A function call such as <code>fun_ci()</code> is in fact a prvalue*, and as such has type <code>int</code>, not <code>const int</code>. <code>int&amp;&amp;</code> is a better match than <code>const int&amp;&amp;</code>, and should be picked by overload resolution.</p>\n<p>*: it's customarily said that top-level cv-qualifiers are ignored for non-class return types.</p>\n", "LastEditorUserId": "726300", "LastActivityDate": "2012-08-28T14:07:29.197", "Score": "9", "CreationDate": "2012-08-28T14:01:22.673", "ParentId": "12160782", "CommentCount": "2", "OwnerUserId": "726300", "LastEditDate": "2012-08-28T14:07:29.197"}, "12160782": {"ViewCount": "198", "Body": "<p>Consider this code:</p>\n<pre><code>#include &lt;iostream&gt;\n\n\nvoid f(int&amp;&amp; i)\n{\n    std::cout &lt;&lt; \"f(int&amp;&amp;)\\n\";\n}\n\nvoid f(const int&amp;&amp; i)\n{\n    std::cout &lt;&lt; \"f(const int&amp;&amp;)\\n\";\n}\n\n\nint fun_i()\n{\n    return 0;\n}\n\nconst int fun_ci()\n{\n    return 0;\n}\n\nint main()\n{\n    f(fun_i());\n    f(fun_ci());\n}\n</code></pre>\n<p>If I compile this with MSVC 2012, the output is:</p>\n<pre><code>f(int&amp;&amp;)\nf(const int&amp;&amp;)\n</code></pre>\n<p>If I compile with GCC 4.7, the output is:</p>\n<pre><code>f(int&amp;&amp;)\nf(int&amp;&amp;)\n</code></pre>\n<p>Which is correct?</p>\n<p>(If I remove the second definition of f, the program will not compile under MSVC 2012, but it does compile under GCC 4.7.)</p>\n", "AcceptedAnswerId": "12160964", "Title": "Const rvalue compiler difference", "CreationDate": "2012-08-28T13:52:57.433", "Id": "12160782", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2012-08-28T14:07:29.197", "Score": "7", "OwnerUserId": "919705", "Tags": "<c++><c++11><rvalue-reference>", "AnswerCount": "2"}, "12160968": {"Id": "12160968", "PostTypeId": "2", "Body": "<p>I'm inclined to say that gcc appears to be doing the right thing, based on a warning it emits:</p>\n<pre><code>stieber@gatekeeper:~$ g++ -std=c++11 -Wignored-qualifiers Test.cpp\nTest.cpp:20:18: warning: type qualifiers ignored on function return type [-Wignored-qualifiers]\n</code></pre>\n", "LastActivityDate": "2012-08-28T14:01:39.223", "CommentCount": "0", "CreationDate": "2012-08-28T14:01:39.223", "ParentId": "12160782", "Score": "2", "OwnerUserId": "826751"}});