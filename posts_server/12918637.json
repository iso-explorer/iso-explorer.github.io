post_cb({"12918752": {"Id": "12918752", "PostTypeId": "2", "Body": "<p>Making it pure forces derived (non-abstract) classes to implement their own.</p>\n<p>Providing an implementation allows derived classes to invoke base class behavior (which destructors do by default).</p>\n", "LastEditorUserId": "673730", "LastActivityDate": "2012-10-16T16:01:04.583", "Score": "6", "CreationDate": "2012-10-16T15:57:28.033", "ParentId": "12918637", "CommentCount": "3", "OwnerUserId": "1343", "LastEditDate": "2012-10-16T16:01:04.583"}, "bq_ids": {"n4140": {"so_12918637_12918985_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 405}, "so_12918637_12918985_1": {"length": 8, "quality": 0.5333333333333333, "section_id": 7040}, "so_12918637_12918725_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 5988}}, "n3337": {"so_12918637_12918985_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 396}, "so_12918637_12918985_1": {"length": 8, "quality": 0.5333333333333333, "section_id": 6785}, "so_12918637_12918725_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 6750}}, "n4659": {"so_12918637_12918985_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 423}, "so_12918637_12918985_1": {"length": 8, "quality": 0.5333333333333333, "section_id": 8537}, "so_12918637_12918725_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 8501}}}, "12918637": {"ViewCount": "573", "Body": "<p>Scott said on Effective C++, 3rd Edition, pg. 43 that to make an abstract class, we just need to give it a pure virtual destructor:</p>\n<pre><code>class AWOV {                  // AWOV = \"Abstract w/o Virtuals\"\npublic:\n  virtual ~AWOV() = 0;        // declare pure virtual destructor\n};\n</code></pre>\n<p>Then, he went on said that there is one twist: we must provide a definition for the pure virtual destructor:</p>\n<pre><code>AWOV::~AWOW() {}              // definition of pure virtual dtor\n</code></pre>\n<p>My question is, by specifiying <code>= 0</code>, for pure virtual functions, we are saying that the function cannot have any definition for the class where this pure virtual function is declared.</p>\n<p>Why is it OK to provide a definition (even it is empty) for the pure virtual destructor here?</p>\n", "AcceptedAnswerId": "12918725", "Title": "Why does it make sense to give definition for a pure virtual function?", "CreationDate": "2012-10-16T15:52:50.450", "Id": "12918637", "CommentCount": "3", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2012-10-16T15:56:36.523", "LastEditorUserId": "1561378", "LastActivityDate": "2012-10-16T16:16:35.860", "Score": "20", "OwnerUserId": "1060209", "Tags": "<c++><class><polymorphism><virtual-functions>", "AnswerCount": "5"}, "12918725": {"Id": "12918725", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_12918637_12918725_0\">\"we are saying that the function cannot have any definition for the class where this pure virtual function is declared.\"</p>\n</blockquote>\n<p>That's not what pure virtual means. Pure virtual only means that the containing class cannot be instantiated (is abstract), so it has to be subclassed, and subclasses must override the method. E.g.,</p>\n<pre><code>struct A {\n    virtual ~A() = 0;\n};\n\nA::~A() {}\n\nstruct B : A {};\n\nint main()\n{\n    A a;  // error\n    B b;  // ok\n}\n</code></pre>\n<p>Here, the <code>B</code> destructor is implicitly defined. If it was another method that is pure virtual, you'd have to explicitly override it:</p>\n<pre><code>struct A {\n    virtual void foo() = 0;\n};\n\nvoid A::foo() {}\n\nstruct B : A {};\n\nint main()\n{\n    B b;  // error\n}\n</code></pre>\n<p>Providing a definition for a pure virtual method is desirable when the base class must be abstract but still provide some default behavior.</p>\n<p>In the specific case of a destructor, it <em>has</em> to be provided because <a href=\"https://stackoverflow.com/a/677626/166749\">it will be called automatically</a> when subclass instances are destroyed. A program that tries to instantiate a subclass of a class with a pure virtual destructor without a definition will not pass the linker.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-10-16T16:16:35.860", "Score": "10", "CreationDate": "2012-10-16T15:56:34.450", "ParentId": "12918637", "CommentCount": "2", "OwnerUserId": "166749", "LastEditDate": "2017-05-23T10:27:57.973"}, "12918985": {"Id": "12918985", "PostTypeId": "2", "Body": "<p>There are 2 cases.</p>\n<h2>Pure virtual destructor</h2>\n<p>This case is specifically treated by the standard.</p>\n<h3>12.4 Destructors [class.dtor]</h3>\n<blockquote>\n<p id=\"so_12918637_12918985_0\">9) A destructor can be declared <code>virtual</code> (10.3) or pure <code>virtual</code> (10.4); if any objects of that class or any\n  derived class are created in the program, the destructor shall be defined. If a class has a base class with a\n  virtual destructor, its destructor (whether user- or implicitly-declared) is virtual. </p>\n</blockquote>\n<p>The case of the destructor is different because all destructors are called in an inheritance hierearchy (assuming correct deletion) in reverse order of construction, even if not explicitly. So the base class destructor is called when the object gets deleted - that's why it needs an implementation.</p>\n<h2>Pure virtual method</h2>\n<p>These differ from destructors in that they're not required to be implemented, nor do they need an implementation. The difference for the missing requirement is that when a <code>Derived::foo()</code> gets called, it doesn't automatically call <code>Base::foo()</code> (not that it could, since it can or can not be implemented).</p>\n<p>Why you would want to implement a pure <code>virtual</code> method depends on the case. I look at the pure specifier as a hint to the programmer, as opposed to related to the logic. It tells you - the programmer - <strong>that you should implement that method</strong>. It doesn't really matter if the base class has an implementation or not.</p>\n<blockquote>\n<p id=\"so_12918637_12918985_1\">by specifiying = 0, for pure virtual functions, we are saying that the function cannot have any definition for the class where this pure virtual function is declared.</p>\n</blockquote>\n<p>Not really. You're saying derived non-abstract classes have to override that function. This doesn't prevent you from implementing it yourself. </p>\n", "LastActivityDate": "2012-10-16T16:11:26.627", "CommentCount": "2", "CreationDate": "2012-10-16T16:11:26.627", "ParentId": "12918637", "Score": "5", "OwnerUserId": "673730"}, "12918789": {"Id": "12918789", "PostTypeId": "2", "Body": "<p>By making a function pure virtual we force the user of the class to replace the function with another in the derived class.</p>\n<p>The base class function can still be called with <code>BaseClass::myfunction(...)</code></p>\n<p>Now the base class might want to provide some core functionality that the derived class may use if it chooses to do so.</p>\n", "LastActivityDate": "2012-10-16T15:59:11.340", "CommentCount": "0", "CreationDate": "2012-10-16T15:59:11.340", "ParentId": "12918637", "Score": "0", "OwnerUserId": "232918"}, "12918794": {"Id": "12918794", "PostTypeId": "2", "Body": "<p>This is not necessary for all <em>pure virtual</em> functions. Not at all.  </p>\n<p>This way, the derived classes will <strong>still be forced to override the implementation</strong>, but there will be a default implementation in the base class, <strong>in case you <em>need</em> to call it</strong>. And that's the case here - because you're dealing with a destructor: when a derived object is being destroyed, its destructor is called <em>and its base classes destructors are called as well</em>. That's why you need an implementation for <code>A::~A</code>.</p>\n", "LastEditorUserId": "435800", "LastActivityDate": "2012-10-16T16:07:47.057", "Score": "2", "CreationDate": "2012-10-16T15:59:27.723", "ParentId": "12918637", "CommentCount": "0", "OwnerUserId": "435800", "LastEditDate": "2012-10-16T16:07:47.057"}});