post_cb({"bq_ids": {"n4140": {"so_42727765_42728073_0": {"length": 68, "quality": 0.9315068493150684, "section_id": 480}, "so_42727765_42728073_1": {"length": 19, "quality": 0.6333333333333333, "section_id": 3296}}, "n3337": {"so_42727765_42728073_0": {"length": 65, "quality": 0.8904109589041096, "section_id": 471}, "so_42727765_42728073_1": {"length": 19, "quality": 0.6333333333333333, "section_id": 3166}}, "n4659": {"so_42727765_42728073_0": {"length": 56, "quality": 0.7671232876712328, "section_id": 502}, "so_42727765_42728073_1": {"length": 27, "quality": 0.9, "section_id": 4058}}}, "42727765": {"ViewCount": "155", "Body": "<p>I have the following program:</p>\n<pre><code>#include &lt;iostream&gt;\n\n#define PRINT_LOCATION()\\\n    do { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \"\\n\"; } while (false)\n\nstruct foo\n{\n    int val;\n\n    foo()\n        : val(1)\n    {\n        PRINT_LOCATION();\n    }\n\n    foo(const foo&amp; other)\n        : val(other.val * 2)\n    {\n        PRINT_LOCATION();\n    }\n\n    foo(foo&amp;&amp; other)\n        : val(other.val * 2)\n    {\n        PRINT_LOCATION();\n    }\n};\n\nint main()\n{\n    foo f{foo{foo{foo{}}}};\n\n    std::cout &lt;&lt; \"value = \" &lt;&lt; f.val &lt;&lt; \"\\n\";\n\n    if (f.val == 1)\n        throw f;\n}\n</code></pre>\n<p>Compilation and execution:</p>\n<pre><code>[mkc /tmp]$ g++ -Wall -Wextra -pedantic -std=c++14 -O0 -o a.out main.cpp\n[mkc /tmp]$ ./a.out \nfoo::foo()\nvalue = 1\nfoo::foo(foo&amp;&amp;)\nterminate called after throwing an instance of 'foo'\nAborted (core dumped)\n[mkc /tmp]$ clang++ -Wall -Wextra -pedantic -std=c++14 -O0 -o a.out main.cpp\n[mkc /tmp]$ ./a.out \nfoo::foo()\nfoo::foo(foo &amp;&amp;)\nfoo::foo(foo &amp;&amp;)\nvalue = 4\n[mkc /tmp]$\n</code></pre>\n<p>I know that the compiler is allowed to remove some constructor calls, but isn't it only allowed to do it when there are no side effects? It looks like Clang is correct here, is it a bug in GCC?</p>\n", "AcceptedAnswerId": "42728073", "Title": "Constructor call sequence different on GCC and clang", "CreationDate": "2017-03-10T21:09:10.373", "Id": "42727765", "CommentCount": "1", "LastEditDate": "2017-03-10T21:36:42.827", "PostTypeId": "1", "LastEditorUserId": "2069064", "LastActivityDate": "2017-03-10T21:36:42.827", "Score": "2", "OwnerUserId": "4208360", "Tags": "<c++><g++><c++14><clang++>", "AnswerCount": "2"}, "42727851": {"Id": "42727851", "PostTypeId": "2", "Body": "<p>Neither is incorrect. This is called copy elision. As @chris pointed out below, it is only a required optimization in C++17. More details can be found on  <a href=\"http://en.cppreference.com/w/cpp/language/copy_elision\" rel=\"nofollow noreferrer\">cppreference.com</a>. The relevant section prior to C++17 is:</p>\n<blockquote>\n<p id=\"so_42727765_42727851_0\">Under the following circumstances, the compilers are permitted to omit\n  the copy- and move- (since C++11)constructors of class objects even if\n  copy/move (since C++11) constructor and the destructor have observable\n  side-effects.</p>\n<p id=\"so_42727765_42727851_1\">When a nameless temporary, not bound to any references, would be moved\n  or (since C++11) copied into an object of the same type (ignoring\n  top-level cv-qualification), the copy/move (since C++11) is omitted.\n  When that temporary is constructed, it is constructed directly in the\n  storage where it would otherwise be moved or (since C++11) copied to.\n  When the nameless temporary is the argument of a return statement,\n  this variant of copy elision is known as RVO, \"return value\n  optimization\".</p>\n</blockquote>\n", "LastEditorUserId": "459615", "LastActivityDate": "2017-03-10T21:34:10.300", "Score": "1", "CreationDate": "2017-03-10T21:16:19.150", "ParentId": "42727765", "CommentCount": "5", "OwnerUserId": "459615", "LastEditDate": "2017-03-10T21:34:10.300"}, "42728073": {"Id": "42728073", "PostTypeId": "2", "Body": "<p>In C++14, both compilers are correct. From [class.copy] in N4296, which I think is close to C++14:</p>\n<blockquote>\n<p id=\"so_42727765_42728073_0\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class\n  object, even if the constructor selected for the copy/move operation and/or the destructor for the object\n  have side effects. [...] This elision of copy/move operations, called <em>copy elision</em>, is permitted in the following circumstances (which\n  may be combined to eliminate multiple copies):<br>\n  \u2014 in a <code>return</code> statement in a function [...]<br>\n  \u2014 in a <em>throw-expression</em> (5.17), [...]<br>\n  \u2014 <strong>when a temporary class object that has not been bound to a reference (12.2) would be copied/moved\n  to a class object with the same cv-unqualified type, the copy/move operation can be omitted by\n  constructing the temporary object directly into the target of the omitted copy/move</strong><br>\n  \u2014 when the <em>exception-declaration</em> of an exception handler [...]</br></br></br></br></p>\n</blockquote>\n<p>This declaration:</p>\n<pre><code>foo f{foo{foo{foo{}}}};\n</code></pre>\n<p>precisely meets that third criteria, so the compiler is <em>allowed</em> to, but isn't <em>required</em> to, elide that copy/move. Hence, both gcc and clang are correct. Note that if you do not want copy elision, you can add the flag <code>-fno-elide-constructors</code>.</p>\n<hr/>\n<p>In C++17 mode, there would not even be a move to elide. The initialization rules themselves in [dcl.init] change to read:</p>\n<blockquote>\n<p id=\"so_42727765_42728073_1\">If the destination type is a (possibly cv-qualified) class type:<br>\n  \u2014 If the initializer expression is a prvalue and the cv-unqualified version of the source type is the same\n  class as the class of the destination, the initializer expression is used to initialize the destination\n  object. <em>[ Example:</em> <code>T x = T(T(T()));</code> calls the <code>T</code> default constructor to initialize <code>x</code>. <em>\u2014end example ]</em></br></p>\n</blockquote>\n", "LastActivityDate": "2017-03-10T21:34:08.683", "CommentCount": "0", "CreationDate": "2017-03-10T21:34:08.683", "ParentId": "42727765", "Score": "3", "OwnerUserId": "2069064"}});