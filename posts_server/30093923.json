post_cb({"30094209": {"Id": "30094209", "PostTypeId": "2", "Body": "<p><em>ref-qualifiers</em> affect the implicit object parameter, \u00a713.3.1/4:</p>\n<blockquote>\n<p id=\"so_30093923_30094209_0\">For non-static member functions, the type of the implicit object\n  parameter is </p>\n<ul>\n<li>\u201clvalue reference to <em>cv</em> <code>X</code>\u201d for functions declared\n  without a <em>ref-qualifier</em> or with the <code>&amp;</code> <em>ref-qualifier</em> </li>\n<li>\u201crvalue\n  reference to <em>cv</em> <code>X</code>\u201d for functions declared with the <code>&amp;&amp;</code>\n<em>ref-qualifier</em> </li>\n</ul>\n<p id=\"so_30093923_30094209_1\">where <code>X</code> is the class of which the function is a member and <em>cv</em> is\n  the cv-qualification on the member function declaration.</p>\n</blockquote>\n<p>Overload resolution is, roughly speaking, performed on the object argument to object parameter conversion just as any other argument-&gt;parameter conversion.<br>\nHowever, <code>f()</code> is transformed into <code>(*this).f()</code> (\u00a79.3.1/3), and <code>*this</code> is an lvalue. \u00a75.3.1/1:</br></p>\n<blockquote>\n<p id=\"so_30093923_30094209_2\">The unary <code>*</code> operator performs indirection: [\u2026] <strong>and the result is an lvalue referring to the object or function to which the expression points</strong>.</p>\n</blockquote>\n<p>Hence the overloads of <code>f</code> with the <code>&amp;</code> qualifier are preferred - in fact, the rvalue overloads are entirely ignored since initializers of rvalue object references must be rvalues (last bullet point in \u00a78.5.3/5). Also, non-const references are preferred over const ones in overload resolution (\u00a713.3.3.2/3, last bullet point concerning standard conversions).</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-05-07T07:18:44.067", "Score": "2", "CreationDate": "2015-05-07T07:11:29.097", "ParentId": "30093923", "CommentCount": "0", "LastEditDate": "2015-05-07T07:18:44.067", "OwnerUserId": "3647361"}, "30094344": {"Id": "30094344", "PostTypeId": "2", "Body": "<p>The call <code>f()</code> is interpreted as <code>(*this).f()</code>. The result of dereferencing a pointer is always an lvalue, so <code>*this</code> is an lvalue and the lvalue-qualified function is called.</p>\n<p>This behaviour even makes sense, at least to me. Most of the time the object referred to by an rvalue expression will either be destroyed at the end of the full-expression (a temporary) or at the end of the current scope (an automatic local variable that we choose to <code>std::move</code>). But when you're <em>inside</em> a member function, neither of those is true, so the object should not treat itself as an rvalue, so to speak. This is also why it makes sense for the name of an rvalue reference function parameter to be an lvalue within the function.</p>\n<p>If you want the rvalue-qualified <code>f</code> to be called, you can do this:</p>\n<pre><code>std::move(*this).f();\n</code></pre>\n", "LastEditorUserId": "481267", "LastActivityDate": "2015-05-07T07:20:27.947", "Score": "10", "CreationDate": "2015-05-07T07:19:17.640", "ParentId": "30093923", "CommentCount": "2", "LastEditDate": "2015-05-07T07:20:27.947", "OwnerUserId": "481267"}, "bq_ids": {"n4140": {"so_30093923_30094209_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 6064}, "so_30093923_30094209_0": {"length": 7, "quality": 0.875, "section_id": 568}, "so_30093923_30094209_1": {"length": 8, "quality": 1.0, "section_id": 568}}, "n3337": {"so_30093923_30094209_0": {"length": 7, "quality": 0.875, "section_id": 559}, "so_30093923_30094209_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 5832}, "so_30093923_30094209_1": {"length": 8, "quality": 1.0, "section_id": 559}}, "n4659": {"so_30093923_30094209_0": {"length": 7, "quality": 0.875, "section_id": 591}, "so_30093923_30094209_2": {"length": 10, "quality": 0.8333333333333334, "section_id": 7560}, "so_30093923_30094209_1": {"length": 8, "quality": 1.0, "section_id": 591}}}, "30093923": {"ViewCount": "573", "Body": "<p>I'm confused by the following code:</p>\n<pre><code>struct test {\n  void f() &amp; {\n    std::cout &lt;&lt; \"&amp;\" &lt;&lt; std::endl;\n  }\n  void f() const&amp; {\n    std::cout &lt;&lt; \"const&amp;\" &lt;&lt; std::endl;\n  }\n  void f() &amp;&amp; {\n    std::cout &lt;&lt; \"&amp;&amp;\" &lt;&lt; std::endl;\n  }\n  void f() const&amp;&amp; {\n    std::cout &lt;&lt; \"const&amp;&amp;\" &lt;&lt; std::endl;\n  }\n\n  void g() &amp; {\n    std::cout &lt;&lt; \"&amp; -&gt; \";\n    f();\n  }\n  void g() const&amp; {\n    std::cout &lt;&lt; \"const&amp; -&gt; \" ;\n    f();\n  }\n  void g() &amp;&amp; {\n    std::cout &lt;&lt; \"&amp;&amp; -&gt; \";\n    f();\n  }\n  void g() const&amp;&amp; {\n    std::cout &lt;&lt; \"const&amp;&amp; -&gt; \";\n    f();\n  }\n\n  test() {} //allow default const construction\n};\n\nint main(int, char**) {\n    test value;\n    const test constant;\n\n    value.g();\n    constant.g();\n\n    std::move(value).g();\n    std::move(constant).g();\n}\n</code></pre>\n<p>When I compile with clang 3.5 I get this output:</p>\n<pre><code>&amp; -&gt; &amp;\nconst&amp; -&gt; const&amp;\n&amp;&amp; -&gt; &amp;\nconst&amp;&amp; -&gt; const&amp;\n</code></pre>\n<p>Why is the r-value qualifier being dropped here? And is there any way to call <code>f</code> from <code>g</code> with the right qualifier?</p>\n", "AcceptedAnswerId": "30094344", "Title": "function && qualifier behaviour", "CreationDate": "2015-05-07T06:54:40.873", "Id": "30093923", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-05-07T12:18:59.637", "LastEditorUserId": "3425536", "LastActivityDate": "2015-05-07T12:18:59.637", "Score": "11", "OwnerUserId": "2743454", "Tags": "<c++><c++14><rvalue-reference>", "AnswerCount": "4"}, "30094022": {"Id": "30094022", "PostTypeId": "2", "Body": "<p>It is because <em>dereferencing</em><sup>1</sup> <code>this</code> <strong>always</strong> produces an lvalue, irrespective of the fact that it is pointing to a temporary object or not. </p>\n<p>So when you write this:</p>\n<pre><code>f();\n</code></pre>\n<p>it actually means this:</p>\n<pre><code>this-&gt;f(); //or (*this).f()\n           //either way 'this' is getting dereferenced here\n</code></pre>\n<p>So the overload of <code>f()</code> which is written for <em>lvalue</em> is invoked from <code>g()</code> \u2014 and const-correctness is applied accordingly as well.</p>\n<p>Hope that helps.</p>\n<hr>\n<p><sup>1. Note that <code>this</code> is a prvalue; only after dereferencing it produces an lvalue. </sup></p>\n</hr>", "LastEditorUserId": "415784", "LastActivityDate": "2015-05-07T07:09:53.023", "Score": "3", "CreationDate": "2015-05-07T07:00:22.200", "ParentId": "30093923", "CommentCount": "0", "LastEditDate": "2015-05-07T07:09:53.023", "OwnerUserId": "415784"}, "30094006": {"Id": "30094006", "PostTypeId": "2", "Body": "<p>Well, for <code>f()</code> the right qualifier is always <code>lvalue reference</code> since you use it on <code>this</code>. All your <code>f</code> calls are nothing else than <code>this-&gt;f()</code> and <code>this</code> is always <code>lvalue</code>. It doesn't matter that for the outside world the object is <code>rvalue</code> <code>this</code> is lvalue for the object insides. </p>\n", "LastActivityDate": "2015-05-07T06:59:15.213", "Score": "1", "CreationDate": "2015-05-07T06:59:15.213", "ParentId": "30093923", "CommentCount": "0", "OwnerUserId": "643393"}});