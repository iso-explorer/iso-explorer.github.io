post_cb({"44946408": {"CommentCount": "0", "ViewCount": "267", "PostTypeId": "1", "LastEditorUserId": "4324224", "CreationDate": "2017-07-06T10:29:30.467", "LastActivityDate": "2017-07-08T14:42:53.177", "LastEditDate": "2017-07-06T10:53:35.973", "AcceptedAnswerId": "44947538", "FavoriteCount": "2", "Title": "Is there a special rule for lambda in case of decltype(auto)?", "Id": "44946408", "Score": "10", "Body": "<p>If I understood correctly <a href=\"https://stackoverflow.com/a/44701336/4324224\">this answer</a> and referenced standard section <a href=\"http://eel.is/c++draft/dcl.spec.auto#dcl.type.auto.deduct-5\" rel=\"noreferrer\">[dcl.type.auto.deduct-5]</a>, the code:</p>\n<pre><code>decltype(auto) a = e;\n</code></pre>\n<p>is always equivalent to </p>\n<pre><code>decltype( e  ) a = e;\n</code></pre>\n<p>But now the problem appears if instead of <code>e</code> I put the lambda expression to <code>decltype(auto)</code>:</p>\n<pre><code>decltype(auto) lambda = [](){};\n</code></pre>\n<p>This compiles, to my surprise, successfully in both <a href=\"https://wandbox.org/permlink/zG0ICwrThNaOZody\" rel=\"noreferrer\">gcc</a> and <a href=\"https://wandbox.org/permlink/NRUCxC7wuokG9xog\" rel=\"noreferrer\">clang</a>. Reason for the shock I've experienced lays in standard which says specifically that lambda should not occur in unevaluated operand <a href=\"http://eel.is/c++draft/expr.prim.lambda#2\" rel=\"noreferrer\">[expr.prim.lambda#2]</a> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_44946408_44946408_0\">A lambda-expression is a prvalue whose result object is called the\n  closure object. <strong>A lambda-expression shall not appear in an unevaluated\n  operand</strong>, in a template-argument, in an alias-declaration, in a typedef\n  declaration, or in the declaration of a function or function template\n  outside its function body and default arguments.</p>\n</blockquote>\n<p>But as I mentioned the example would be equivalent to:</p>\n<pre><code>decltype([](){}) lambda = [](){};\n</code></pre>\n<p>The above code written explicitly obviously would be ill-formed. Of course we could assume that the statement <code>[](){}</code> inside <code>decltype</code> is kind of reference that isn't really a reference like in case of <a href=\"https://stackoverflow.com/questions/44695684/structured-bindings-when-something-looks-like-a-reference-and-behaves-similarly\">structured bindings</a>, but maybe there is a special rule in standard that I've missed covering lambda initializing <code>decltype(auto)</code>?</p>\n", "Tags": "<c++><lambda><c++14><language-lawyer><decltype>", "OwnerUserId": "4324224", "AnswerCount": "1"}, "44947538": {"ParentId": "44946408", "LastEditDate": "2017-07-08T14:42:53.177", "CommentCount": "23", "CreationDate": "2017-07-06T11:24:07.857", "Score": "7", "LastEditorUserId": "3980929", "PostTypeId": "2", "Id": "44947538", "OwnerUserId": "3980929", "Body": "<p>This answer is based on my interpretation of the relevant Standard text. Those sections are not very clear with divided opinions, and thus it is currently hard to know the exact meaning of them. It seems that, excluding a possible oversight, the major compilers seem to agree that the definition in question is indeed well-formed.</p>\n<p>In addition, it is my opinion that it would be very surprising to hear that the definition were ill-formed. </p>\n<hr>\n<blockquote>\n<p id=\"so_44946408_44947538_0\">Reason for the shock I've experienced lays in standard which says specifically that lambda should not occur in unevaluated operand\u00a0[...]</p>\n</blockquote>\n<p>Where do you see that a lambda appears in an unevaluated context?</p>\n<pre><code>decltype(auto) lambda = [](){};\n</code></pre>\n<p>I don't see it, because there is none. The lambda is used as an initializer, which is completely legal.</p>\n<p>Now your confusion probably comes about because you seem to think that the above statement is equivalent to</p>\n<pre><code>decltype([](){}) lambda = [](){};\n</code></pre>\n<p>That's not the case though, strictly speaking. If you look at the language of the wording, there is a small difference (highlighted by me):</p>\n<blockquote>\n<p id=\"so_44946408_44947538_1\">If the placeholder is the\u00a0<code>decltype(auto)</code>\u00a0<em>type-specifier</em>,\u00a0<code>T</code>\u00a0shall be the placeholder alone. The type deduced for\u00a0<code>T</code>\u00a0is determined as described in\u00a0[dcl.type.simple], as <strong>though</strong>\u00a0<code>e</code>\u00a0had been the operand of the\u00a0<code>decltype</code>.</p>\n</blockquote>\n<p>The key word here is <em>though</em>. It just means that the deduction happens as if it were <code>decltype(e)</code>, meaning that the deduction rules of <code>decltype</code> apply instead of those for <code>auto</code> for the operand <code>e</code>.</p>\n<p>Here, the operand <code>e</code> is indeed the lambda, but that is completely legal, because the Standard mandates that the behavior is the same <em>as if</em> you would have written <code>decltype([](){})</code>, meaning that of the rules of <code>decltype</code> deduction apply for the lambda. Now <code>[expr.prim.lambda]/2</code> doesn't apply here, because the lambda is not in an unevaluated context, so it is actually legal for the compiler to use <code>decltype([](){})</code> to deduce the type, meaning that the <code>decltype</code> rules have to be used for the lambda.</p>\n<p>Sure, if you write <code>decltype([](){})</code>, the program is ill-formed, but that is not the case here, as mentioned above.</p>\n<p>In this case, because a lambda expression is a prvalue, the deduced type should just be the type of the lambda.</p>\n<p>At least that's how I understand it...</p>\n</hr>", "LastActivityDate": "2017-07-08T14:42:53.177"}, "bq_ids": {"n4140": {"so_44946408_44947538_1": {"section_id": 5451, "quality": 0.8125, "length": 13}, "so_44946408_44946408_0": {"section_id": 5961, "quality": 0.8461538461538461, "length": 22}}, "n4659": {"so_44946408_44947538_1": {"section_id": 6890, "quality": 0.875, "length": 14}, "so_44946408_44946408_0": {"section_id": 7448, "quality": 0.9615384615384616, "length": 25}}}});