post_cb({"722016": {"Id": "722016", "PostTypeId": "2", "Body": "<p>The type of <code>w*i</code> is unsigned in your case. If I read the standard correctly, the rule is that the operands are converted to the larger type (with its signedness), or unsigned type corresponding to the signed type (which is <code>unsigned int</code> in your case).</p>\n<p>However, even if it's unsigned, it doesn't prevent the wraparound (writing to memory before <code>buf</code>), because it might be the case (on i386 platform, it is), that <code>p[-1]</code> is the same as <code>p[-1u]</code>. Anyway, in your case, both <code>buf[-1]</code> and <code>buf[big unsigned number]</code> would be undefined behavior, so the signed/unsigned question is not that important.</p>\n<p>Note that signed/unsigned matters in other contexts - eg. <code>(int)(x*y/2)</code> gives different results depending on the types of <code>x</code> and <code>y</code>, even in the absence of undefined behaviour.</p>\n<p>I would solve your problem by checking for overflow on line 9; since 4096 is a pretty small constant and 4096*4096 doesn't overflow on most architectures (you need to check), I'd do</p>\n<pre><code>if (w&gt;4096 || h&gt;4096 || w*h &gt; 4096)\n     return (NULL);\n</code></pre>\n<p>This leaves out the case when <code>w</code> or <code>h</code> are 0, you might want to check for it if needed.</p>\n<p>In general, you could check for overflow like this:</p>\n<pre><code>if(w*h &gt; 4096 || (w*h)/w!=h || (w*h)%w!=0)\n</code></pre>\n", "LastActivityDate": "2009-04-06T15:38:13.227", "CommentCount": "0", "CreationDate": "2009-04-06T15:38:13.227", "ParentId": "721861", "Score": "2", "OwnerUserId": "51831"}, "722100": {"Id": "722100", "PostTypeId": "2", "Body": "<p>For C, refer to \"Usual arithmetic conversions\" (C99: Section 6.3.1.8, ANSI C K&amp;R A6.5) for details on how the operands of the mathematical operators are treated.</p>\n<p>In your example the following rules apply:</p>\n<p>C99:</p>\n<blockquote>\n<p id=\"so_721861_722100_0\">Otherwise, if the type of the operand\n  with signed integer type can represent\n  all of the values of the type of the\n  operand with unsigned integer type,\n  then the operand with unsigned integer\n  type is converted to the type of the\n  operand with signed integer type.</p>\n<p id=\"so_721861_722100_1\">Otherwise, both operands are converted\n  to the unsigned integer type\n  corresponding to the type of the\n  operand with signed integer type.</p>\n</blockquote>\n<p>ANSI C:</p>\n<blockquote>\n<p id=\"so_721861_722100_2\">Otherwise, if either operand is unsigned int, the other is converted to unsigned int.</p>\n</blockquote>\n", "LastActivityDate": "2009-04-06T15:58:58.310", "CommentCount": "0", "CreationDate": "2009-04-06T15:58:58.310", "ParentId": "721861", "Score": "1", "OwnerUserId": "9083"}, "721861": {"ViewCount": "2429", "Body": "<p>In case of integer overflows what is the result of <code>(unsigned int) * (int)</code> ? <code>unsigned</code> or <code>int</code>? What type does the array index operator (<code>operator[]</code>) take for <code>char*</code>: <code>int</code>, <code>unsigned int</code> or something else?</p>\n<p>I was auditing the following function, and suddenly this question arose. The function has a vulnerability at line 17.</p>\n<pre><code>// Create a character array and initialize it with init[] \n// repeatedly. The size of this character array is specified by \n// w*h.\nchar *function4(unsigned int w, unsigned int h, char *init)\n{\n    char *buf;\n    int i;\n\n    if (w*h &gt; 4096)\n        return (NULL);\n\n    buf = (char *)malloc(4096+1);\n    if (!buf)\n        return (NULL);\n\n    for (i=0; i&lt;h; i++)\n        memcpy(&amp;buf[i*w], init, w);  // line 17\n\n    buf[4096] = '\\0';\n\n    return buf;\n}\n</code></pre>\n<p>Consider both <code>w</code> and <code>h</code> are very large unsigned integers. The multiplication at line 9 have a chance to pass the validation. </p>\n<p>Now the problem is at line 17. Multiply <code>int i</code> with <code>unsigned int w</code>: if the result is <code>int</code>, it is possible that the product is negative, resulting in accessing a position that is before <code>buf</code>. If the result is <code>unsigned int</code>, the product will always be positive, resulting in accessing a position that is after <code>buf</code>.</p>\n<p>It's hard to write code to justify this: <code>int</code> is too large. Does anyone has ideas on this?</p>\n<p>Is there any documentation that specifies the type of the product? I have searched for it, but so far haven't found anything.</p>\n<p>I suppose that as far as the vulnerability is concerned, whether <code>(unsigned int) * (int)</code> produces <code>unsigned int</code> or <code>int</code> doesn't matter, because in the compiled object file, they are just bytes. The following code works the same no matter the type of the product:</p>\n<pre><code>unsigned int x = 10;\nint y = -10;\n\nprintf(\"%d\\n\", x * y);  // print x * y in signed integer\nprintf(\"%u\\n\", x * y);  // print x * y in unsigned integer\n</code></pre>\n<p>Therefore, it does not matter what type the multiplication returns. It matters that whether the consumer function takes <code>int</code> or <code>unsigned</code>.</p>\n<p>The question here is <strong>not</strong> how bad the function is, or how to improve the function to make it better. The function undoubtedly has a vulnerability. The question is about the exact behavior of the function, based on the prescribed behavior from the standards.</p>\n", "AcceptedAnswerId": "721996", "Title": "In case of integer overflows what is the result of (unsigned int) * (int) ? unsigned or int?", "CreationDate": "2009-04-06T15:01:18.713", "Id": "721861", "CommentCount": "0", "LastEditDate": "2012-04-01T14:05:51.460", "PostTypeId": "1", "LastEditorUserId": "90527", "LastActivityDate": "2012-04-01T14:05:51.460", "Score": "8", "OwnerUserId": "80347", "Tags": "<c++><c><overflow><buffer>", "AnswerCount": "13"}, "3739974": {"Id": "3739974", "PostTypeId": "2", "Body": "<p>There are 3 paragraphs in the current C1X draft on calculating (UNSIGNED TYPE1) X (SIGNED TYPE2) in 6.3.1.8 Usual arithmetic coversions, N1494,</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/projects\" rel=\"nofollow noreferrer\">WG 14: C - Project status and milestones</a></p>\n<blockquote>\n<p id=\"so_721861_3739974_0\">Otherwise, if the operand that has unsigned integer type has rank greater or\n  equal to the rank of the type of the other operand, then the operand with\n  signed integer type is converted to the type of the operand with unsigned\n  integer type.</p>\n<p id=\"so_721861_3739974_1\">Otherwise, if the type of the operand with signed integer type can represent\n  all of the values of the type of the operand with unsigned integer type, then\n  the operand with unsigned integer type is converted to the type of the\n  operand with signed integer type.</p>\n<p id=\"so_721861_3739974_2\">Otherwise, both operands are converted to the unsigned integer type\n  corresponding to the type of the operand with signed integer type.</p>\n</blockquote>\n<p>So if a is unsigned int and b is int, parsing of (a * b) should generate code (a * (unsigned int)b).  Will overflow if b &lt; 0 or a * b &gt; UINT_MAX.</p>\n<p>If a is unsigned int and b is long of greater size, (a * b) should generate ((long)a * (long)b).  Will overflow if a * b &gt; LONG_MAX or a * b &lt; LONG_MIN.</p>\n<p>If a is unsigned int and b is long of the same size, (a * b) should generate ((unsigned long)a * (unsigned long)b).  Will overflow if b &lt; 0 or a * b &gt; ULONG_MAX.</p>\n<p>On your second question about the type expected by \"indexer\", the answer appears \"integer type\" which allows for any (signed) integer index.</p>\n<blockquote>\n<p id=\"so_721861_3739974_3\">6.5.2.1 Array subscripting</p>\n<p id=\"so_721861_3739974_4\">Constraints</p>\n<p id=\"so_721861_3739974_5\">1 One of the expressions shall have type \u2018\u2018pointer to complete object type\u2019\u2019, the other\n  expression shall have integer type, and the result has type \u2018\u2018type\u2019\u2019.</p>\n<p id=\"so_721861_3739974_6\">Semantics</p>\n<p id=\"so_721861_3739974_7\">2 A postfix expression followed by an expression in square brackets [] is a subscripted\n  designation of an element of an array object. The definition of the subscript operator []\n  is that E1[E2] is identical to (*((E1)+(E2))). Because of the conversion rules that\n  apply to the binary + operator, if E1 is an array object (equivalently, a pointer to the\n  initial element of an array object) and E2 is an integer, E1[E2] designates the E2-th\n  element of E1 (counting from zero).</p>\n</blockquote>\n<p>It is up to the compiler to perform static analysis and warn the developer about possibility of buffer overrun when the pointer expression is an array variable and the index may be negative.  Same goes about warning on possible array size overruns even when the index is positive or unsigned.</p>\n", "LastActivityDate": "2010-09-18T01:11:07.347", "CommentCount": "0", "CreationDate": "2010-09-18T01:11:07.347", "ParentId": "721861", "Score": "0", "OwnerUserId": "80772"}, "721993": {"Id": "721993", "PostTypeId": "2", "Body": "<p>2 changes make it safer:</p>\n<pre><code>if (w &gt;= 4096 || h &gt;= 4096 || w*h &gt; 4096)  return NULL;\n\n...\n\nunsigned i;\n</code></pre>\n<p>Note also that it's not less a bad idea to write to or read from past the buffer end. So the question is not whether i<em>w may become negative, but whether 0 &lt;= i</em>h +w &lt;= 4096 holds.</p>\n<p>So it's not the type that matters, but the result of h*i.\nFor example, it doesn't make a difference whether this is (unsigned)0x80000000 or (int)0x80000000, the program will seg-fault anyway.</p>\n", "LastEditorUserId": "86604", "LastActivityDate": "2009-04-06T15:48:03.703", "Score": "1", "CreationDate": "2009-04-06T15:30:26.007", "ParentId": "721861", "CommentCount": "0", "OwnerUserId": "86604", "LastEditDate": "2009-04-06T15:48:03.703"}, "721911": {"Id": "721911", "PostTypeId": "2", "Body": "<p>do the w*h calculation in long long, check if bigger than MAX_UINT  </p>\n<p>EDIT : alternative : if overflown (w*h)/h != w (is this always the case ?! should be, right ?)</p>\n", "LastEditorUserId": "79182", "LastActivityDate": "2009-04-06T15:21:42.567", "Score": "4", "CreationDate": "2009-04-06T15:13:05.537", "ParentId": "721861", "CommentCount": "3", "OwnerUserId": "79182", "LastEditDate": "2009-04-06T15:21:42.567"}, "721996": {"Id": "721996", "PostTypeId": "2", "Body": "<p>To answer your question:  the type of an expression multiplying an int and an unsigned int will be an unsigned int in C/C++.</p>\n<p>To answer your implied question, one decent way to deal with possible overflow in integer arithmetic is to use the \"<code>IntSafe</code>\" set of routines from Microsoft:</p>\n<p><a href=\"http://blogs.msdn.com/michael_howard/archive/2006/02/02/523392.aspx\" rel=\"nofollow noreferrer\">http://blogs.msdn.com/michael_howard/archive/2006/02/02/523392.aspx</a></p>\n<p>It's available in the SDK and contains inline implementations so you can study what they're doing if you're on another platform.</p>\n", "LastActivityDate": "2009-04-06T15:31:56.393", "CommentCount": "0", "CreationDate": "2009-04-06T15:31:56.393", "ParentId": "721861", "Score": "2", "OwnerUserId": "12711"}, "bq_ids": {"n4140": {"so_721861_3739974_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 5943}, "so_721861_3739974_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 5943}, "so_721861_722100_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 5943}, "so_721861_722100_1": {"length": 13, "quality": 1.0, "section_id": 5943}, "so_721861_722100_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 5943}, "so_721861_3739974_5": {"length": 11, "quality": 0.6875, "section_id": 5986}, "so_721861_3739974_2": {"length": 13, "quality": 1.0, "section_id": 5943}}, "n3337": {"so_721861_3739974_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 5714}, "so_721861_3739974_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 5714}, "so_721861_3739974_2": {"length": 13, "quality": 1.0, "section_id": 5714}, "so_721861_722100_1": {"length": 13, "quality": 1.0, "section_id": 5714}, "so_721861_722100_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 5714}, "so_721861_3739974_5": {"length": 11, "quality": 0.6875, "section_id": 5754}, "so_721861_722100_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 5714}}, "n4659": {"so_721861_3739974_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 7428}, "so_721861_3739974_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 7428}, "so_721861_3739974_2": {"length": 13, "quality": 1.0, "section_id": 7428}, "so_721861_722100_1": {"length": 13, "quality": 1.0, "section_id": 7428}, "so_721861_722100_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 7428}, "so_721861_3739974_5": {"length": 10, "quality": 0.625, "section_id": 7687}, "so_721861_722100_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 7428}}}, "721902": {"Id": "721902", "PostTypeId": "2", "Body": "<p>memcpy(&amp;buf[i<em>w &gt; -1 ? i</em>w &lt; 4097? i<em>w : 0 : 0], init, w);\nI don't think the triple calculation of i</em>w does degrade the perfomance)</p>\n", "LastActivityDate": "2009-04-06T15:11:18.347", "CommentCount": "0", "CreationDate": "2009-04-06T15:11:18.347", "ParentId": "721861", "Score": "0"}, "721931": {"Id": "721931", "PostTypeId": "2", "Body": "<p>To actually answer your question, without specifying the hardware you're running on, you don't know, and in code intended to be portable, you shouldn't depend on any particular behavior.</p>\n", "LastActivityDate": "2009-04-06T15:19:26.177", "CommentCount": "1", "CreationDate": "2009-04-06T15:19:26.177", "ParentId": "721861", "Score": "-1", "OwnerUserId": "35092"}, "721942": {"Id": "721942", "PostTypeId": "2", "Body": "<p>Unsigned arithmetic is done as modular (or wrap-around), so the product of two large unsigned ints can easily be less than 4096.  The multiplication of int and unsigned int will result in an unsigned int (see section 4.5 of the C++ standard).</p>\n<p>Therefore, given large w and a suitable value of h, you can indeed get into trouble.</p>\n<p>Making sure integer arithmetic doesn't overflow is difficult.  One easy way is to convert to floating-point and doing a floating-point multiplication, and seeing if the result is at all reasonable.  As qwerty suggested, long long would be usable, if available on your implementation.  (It's a common extension in C90 and C++, does exist in C99, and will be in C++0x.)</p>\n", "LastActivityDate": "2009-04-06T15:21:41.553", "CommentCount": "3", "CreationDate": "2009-04-06T15:21:41.553", "ParentId": "721861", "Score": "0", "OwnerUserId": "14148"}, "722024": {"Id": "722024", "PostTypeId": "2", "Body": "<p>In C/C++ the <code>p[n]</code> notation is really a shortcut to writting <code>*(p+n)</code>, and this pointer arithmetic takes into account the sign. So <code>p[-1]</code> is valid and refers to the value immediately before <code>*p</code>. </p>\n<p>So the sign really matters here, the result of arithmetic operator with integer follow a set of rules defined by the standard, and this is called integer promotions.</p>\n<p>Check out this page: <a href=\"https://www.securecoding.cert.org/confluence/display/seccode/INT02-C.+Understand+integer+conversion+rules\" rel=\"nofollow noreferrer\">INT02-C. Understand integer conversion rules</a></p>\n", "LastEditorUserId": "635608", "LastActivityDate": "2011-11-22T20:19:14.000", "Score": "2", "CreationDate": "2009-04-06T15:40:06.517", "ParentId": "721861", "CommentCount": "0", "OwnerUserId": "5999", "LastEditDate": "2011-11-22T20:19:14.000"}, "721890": {"Id": "721890", "PostTypeId": "2", "Body": "<p>Ensure that w * h doesn't overflow by limiting w and h.</p>\n", "LastActivityDate": "2009-04-06T15:08:59.867", "CommentCount": "2", "CreationDate": "2009-04-06T15:08:59.867", "ParentId": "721861", "Score": "2", "OwnerUserId": "49246"}, "721884": {"Id": "721884", "PostTypeId": "2", "Body": "<p>Why not just declare i as unsigned int? Then the problem goes away.</p>\n<p>In any case, i*w is guaranteed to be &lt;= 4096, as the code tests for this, so it's never going to overflow.</p>\n", "LastActivityDate": "2009-04-06T15:07:22.990", "CommentCount": "2", "CreationDate": "2009-04-06T15:07:22.990", "ParentId": "721861", "Score": "0", "OwnerUserId": "45552"}, "721937": {"Id": "721937", "PostTypeId": "2", "Body": "<p>w*h could overflow if w and/or h are sufficiently large and the following validation could pass.</p>\n<pre><code>9.      if (w*h &gt; 4096)\n10.         return (NULL);\n</code></pre>\n<p>On int , unsigned int mixed operations, int is elevated to unsigned int, in which case, a negative value of 'i' would become a large positive value. In that case</p>\n<pre><code>&amp;buf[i*w]\n</code></pre>\n<p>would be accessing a out of bound value.</p>\n", "LastActivityDate": "2009-04-06T15:20:45.547", "CommentCount": "0", "CreationDate": "2009-04-06T15:20:45.547", "ParentId": "721861", "Score": "0", "OwnerUserId": "85150"}});