post_cb({"bq_ids": {"n4140": {"so_17518019_17518061_0": {"length": 29, "quality": 0.8529411764705882, "section_id": 6955}}, "n3337": {"so_17518019_17518061_0": {"length": 29, "quality": 0.8529411764705882, "section_id": 6702}}, "n4659": {"so_17518019_17518061_0": {"length": 29, "quality": 0.8529411764705882, "section_id": 8452}}}, "17518019": {"ViewCount": "183", "Body": "<p>Why <code>std::initializer_list&lt;T&gt;::iterator</code> is defined as a naked pointer <code>T const*</code> rather than a <code>random_access_iterator</code> concept ?</p>\n", "AcceptedAnswerId": "17518061", "Title": "choice of initializer_list iterator definition", "CreationDate": "2013-07-08T01:25:08.083", "Id": "17518019", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2013-07-08T01:32:32.613", "Score": "3", "OwnerUserId": "1003615", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "17518061": {"Id": "17518061", "PostTypeId": "2", "Body": "<p>The reason is probably from this little tid-bit from the standard</p>\n<p>Section 18.9</p>\n<blockquote>\n<p id=\"so_17518019_17518061_0\">An object of type initializer_list provides access to an array of\n  objects of type const E. [ Note: A pair of pointers or a pointer plus\n  a length would be obvious representations for initializer_list.\n  initializer_list is used to implement initializer lists as specified\n  in 8.5.4. Copying an initializer list does not copy the underlying\n  elements. \u2014end note ]</p>\n</blockquote>\n<p>This indicates that initializer_lists when copied will have pointer semantics and not value semantics, which is probably why their iterators are directly pointers and not wrapped into a \"random-access-iterator\" type.</p>\n<p>AFAIK this is the only standard \"<em>container</em>\" (notice the quotes here), to have pointer semantics as opposed to value semantics.</p>\n", "LastActivityDate": "2013-07-08T01:32:32.613", "CommentCount": "0", "CreationDate": "2013-07-08T01:32:32.613", "ParentId": "17518019", "Score": "5", "OwnerUserId": "583833"}});