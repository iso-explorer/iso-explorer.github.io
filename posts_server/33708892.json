post_cb({"bq_ids": {"n4140": {"so_33708892_33709665_4": {"length": 6, "quality": 0.75, "section_id": 5310}, "so_33708892_33709665_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 5054}, "so_33708892_33709665_2": {"length": 16, "quality": 1.0, "section_id": 5310}, "so_33708892_33709665_5": {"length": 4, "quality": 1.0, "section_id": 5310}, "so_33708892_33709665_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 5310}}, "n3337": {"so_33708892_33709665_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 5107}, "so_33708892_33709665_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 4851}, "so_33708892_33709665_2": {"length": 16, "quality": 1.0, "section_id": 5107}, "so_33708892_33709665_4": {"length": 6, "quality": 0.75, "section_id": 5107}, "so_33708892_33709665_5": {"length": 4, "quality": 1.0, "section_id": 5107}}, "n4659": {"so_33708892_33709665_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 6734}, "so_33708892_33709665_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 6475}, "so_33708892_33709665_2": {"length": 16, "quality": 1.0, "section_id": 6734}, "so_33708892_33709665_4": {"length": 6, "quality": 0.75, "section_id": 6734}, "so_33708892_33709665_5": {"length": 4, "quality": 1.0, "section_id": 6734}}}, "33709665": {"Id": "33709665", "PostTypeId": "2", "Body": "<ol>\n<li><p>Some aspects of regex matching are locale-aware, with the result that a <code>std::regex_traits</code> object includes or references an instance of a <code>std::locale</code> object. The C++ standard library only provides locales for <code>char</code> and <code>wchar_t</code> characters, so there is no standard locale for <code>char32_t</code> (unless it happens to be the same as <code>wchar_t</code>), and this restriction carries over into regexes.</p></li>\n<li><p>Your description is imprecise. Unicode defines canonical equivalence relationship between two strings, which is based on normalizing the two strings, using either NFC or NFD, and then codepoint-by-codepoint comparing the normalized values. It does not defined canonical equivalence simply as an equivalence between a codepoint and a codepoint sequence, because normalization cannot simply be done character-by-character. Normalisation may require reordering composing characters into the canonical order (after canonical (de)composition). As such, it does not easily fit into the C++ model of locale transformations, which are generally single-character.</p>\n<p>The C++ standard library does not implement any Unicode normalization algorithm; in C++, as in many other languages, the two strings <code>L\"\\u00e4\"</code> (\u00e4) and <code>L\"\\u0061\\u0308\"</code> (a\u0308) will compare as different, although they are canonically equivalent, and look to the human reader like the same grapheme. (On the machine I'm writing this answer, the rendering of those two graphemes is subtly different; if you look closely, you'll see that the umlaut in the second one is slightly displaced from its visually optimal position. That violates the Unicode requirement that canonically equivalent string have precisely the same rendering.)</p>\n<p>If you want to check for canonical equivalence of two strings, you need to use a Unicode normalisation library. Unfortunately, the C++ standard library does not include any such API; you could look at <a href=\"http://site.icu-project.org/\">ICU</a> (which also includes <a href=\"http://icu-project.org/apiref/icu4c/classicu_1_1RegexPattern.html\">Unicode-aware regex matching</a>).</p>\n<p>In any case, regular expression matching -- to the extent that it is specified in the C++ standard -- does not normalize the target string. This is permitted by the <a href=\"http://www.unicode.org/reports/tr18/#Canonical_Equivalents\">Unicode Technical Report on regular expressions</a>, which recommends that the target string be explicitly normalized to some normalization form and the pattern written to work with strings normalized to that form:</p>\n<blockquote>\n<p id=\"so_33708892_33709665_0\">For most full-featured regular expression engines, it is quite difficult to match under canonical equivalence, which may involve reordering, splitting, or merging of characters.\u2026 In practice, regex APIs are not set up to match parts of characters or handle discontiguous selections. There are many other edge cases\u2026 It is feasible, however, to construct patterns that will match against NFD (or NFKD) text. That can be done by:</p>\n<ul>\n<li>Putting the text to be matched into a defined normalization form (NFD or NFKD).</li>\n<li>Having the user design the regular expression pattern to match against that defined normalization form. For example, the pattern should contain no characters that would not occur in that normalization form, nor sequences that would not occur.</li>\n<li>Applying the matching algorithm on a code point by code point basis, as usual.</li>\n</ul>\n</blockquote></li>\n<li><p>The bulk of the work in creating a <code>char32_t</code> specialization of <code>std::regex_traits</code> would be creating a <code>char32_t</code> locale object. I've never tried doing either of these things; I suspect it would require a fair amount of attention to detail, because there are a lot of odd corner cases.</p></li>\n</ol>\n<hr>\n<p>The C++ standard is somewhat vague about the details of regular expression matching, leaving the details to external documentation about each flavour of regular expression (and without a full explanation about how to apply such external specifications to character types other than the one each flavour is specified on). However, the fact that matching is character-by-character is possible to deduce. For example, in \u00a7 28.3, Requirements [re.req], Table 136 includes the locale method responsible for the character-by-character equivalence algorithm:</p>\n<blockquote>\n<p id=\"so_33708892_33709665_1\">Expression: <code>v.translate(c)</code>\n     Return type: <code>X::char_type</code>\n     Assertion: Returns a character such that for any character <code>d</code> that is to be considered equivalent to <code>c</code> then <code>v.translate(c) == v.translate(d)</code>.</p>\n</blockquote>\n<p>Similarly, in the description of regular expression matching for the default \"Modified ECMAScript\" flavour (\u00a7 28.13), the standard describes how the regular expression engine to matches two characters (one in the pattern and one in the target): (paragraph 14.1):</p>\n<blockquote>\n<p id=\"so_33708892_33709665_2\">During matching of a regular expression finite state machine against a sequence of characters, two characters <code>c</code> and <code>d</code> are compared using the following rules:</p>\n<ol>\n<li><p id=\"so_33708892_33709665_3\">if <code>(flags() &amp; regex_constants::icase)</code> the two characters are equal if <code>traits_inst.translate_nocase(c) == traits_inst.translate_nocase(d)</code>;</p></li>\n<li><p id=\"so_33708892_33709665_4\">otherwise, if <code>flags() &amp; regex_constants::collate</code> the two characters are equal if <code>traits_inst.translate(c) == traits_inst.translate(d)</code>;</p></li>\n<li><p id=\"so_33708892_33709665_5\">otherwise, the two characters are equal if <code>c == d</code>.</p></li>\n</ol>\n</blockquote>\n</hr>", "LastEditorUserId": "1566221", "LastActivityDate": "2015-11-14T19:22:09.243", "Score": "7", "CreationDate": "2015-11-14T14:54:16.500", "ParentId": "33708892", "CommentCount": "12", "OwnerUserId": "1566221", "LastEditDate": "2015-11-14T19:22:09.243"}, "33708892": {"ViewCount": "311", "Body": "<p>I would like to use regular expressions on UTF-32 codepoints and found this <a href=\"http://en.cppreference.com/w/cpp/regex/regex_traits\" rel=\"nofollow\">reference</a> stating that std::regex_traits has to be defined by the user, so that std::basic_regex can be used at all. There seems to be no changes planned in the future for this.</p>\n<ol>\n<li><p>Why is this even the case?</p></li>\n<li><p>Does this have to do with the fact that Unicode says combined codepoint have to be treated equal to the single-code point representation (like the umlaut '\u00e4' represented as a single codepoint or with the a and the dots as two separate ones) ?</p></li>\n<li><p>Given the simplification that only single-codepoint characters would be supported, could this trait be defined easily or would this be either non-trivial nevertheless or require further limitations?</p></li>\n</ol>\n", "AcceptedAnswerId": "33709665", "Title": "Why is there no definition for std::regex_traits<char32_t> (and thus no std::basic_regex<char32_t>) provided?", "CreationDate": "2015-11-14T13:27:07.450", "Id": "33708892", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-11-14T13:33:24.850", "LastEditorUserId": "3144964", "LastActivityDate": "2015-11-14T19:22:09.243", "Score": "3", "OwnerUserId": "3144964", "Tags": "<c++><regex><c++11>", "AnswerCount": "1"}});