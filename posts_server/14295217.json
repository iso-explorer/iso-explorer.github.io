post_cb({"bq_ids": {"n4140": {"so_14295217_14298922_0": {"length": 5, "quality": 1.0, "section_id": 3876}}, "n3337": {"so_14295217_14298922_0": {"length": 5, "quality": 1.0, "section_id": 3736}}, "n4659": {"so_14295217_14298922_0": {"length": 5, "quality": 1.0, "section_id": 4690}}}, "16167820": {"Id": "16167820", "PostTypeId": "2", "Body": "<p>A workaround is to specialise <code>_Common_float_type</code> for <code>half</code> and <code>half_expr</code> to be an undefined type, so that SFINAE gets rid of the VS2012 version of <code>atan2</code>. </p>\n<pre><code>namespace std {\n    template&lt;class T1, class T2&gt;\n    struct _Common_float_type&lt;half_float::half_expr&lt;T1&gt;, half_float::half_expr&lt;T2&gt;&gt;;\n    template&lt;class T2&gt;\n    struct _Common_float_type&lt;half_float::half, half_float::half_expr&lt;T2&gt;&gt;;\n    template&lt;class T1&gt;\n    struct _Common_float_type&lt;half_float::half_expr&lt;T1&gt;, half_float::half&gt;;\n    template&lt;&gt;\n    struct _Common_float_type&lt;half_float::half, half_float::half&gt;;\n}\n</code></pre>\n<p>Note that you have to specialise for all four combinations of <code>half</code> and <code>half_expr</code>, because template specialisation doesn't consider base classes.</p>\n", "LastActivityDate": "2013-04-23T11:09:56.250", "Score": "0", "CreationDate": "2013-04-23T11:09:56.250", "ParentId": "14295217", "CommentCount": "0", "OwnerUserId": "1509804"}, "14296231": {"Id": "14296231", "PostTypeId": "2", "Body": "<p>I just tried your code, and I figured out what was wrong with it.</p>\n<p>Since you haven't implemented <code>half::sin</code> and <code>half::atan2</code>, the linker will throw an error anyway. So if you implement the methods <code>half::sin</code> and <code>half::atan2</code>, that should solve it (I implemented them by letting them return an empty half, which is, of course, meaningless). </p>\n<p>After I took that step (providing a (meaningless) implementation of the two required methods), the error messages almost magically disappeared.</p>\n<p>Maybe this isn't the solution to your problem, as I'm using GCC, and not VS.</p>\n<hr>\n<p><strong>EDIT:</strong> I just tried the sample I used with G++ with visual studio, which gave me a peculier error message. Provided the strangeness of the error, and the code working with GCC, I must conclude that this is a bug in VC2012.</p>\n</hr>", "LastEditorUserId": "743214", "LastActivityDate": "2013-01-12T18:18:26.817", "Score": "0", "CreationDate": "2013-01-12T17:58:50.023", "ParentId": "14295217", "CommentCount": "2", "LastEditDate": "2013-01-12T18:18:26.817", "OwnerUserId": "1008691"}, "14295217": {"ViewCount": "469", "Body": "<p>Let's take the following example program:</p>\n<pre><code>#include &lt;cmath&gt;\n\nnamespace half_float\n{\n    template&lt;typename T&gt; struct half_expr {};\n\n    struct half : half_expr&lt;half&gt;\n    {\n        operator float() const;\n    };\n\n    template&lt;typename T&gt; half sin(const half_expr&lt;T&gt;&amp;);\n    template&lt;typename T&gt; half atan2(const half_expr&lt;T&gt;&amp;, const half_expr&lt;T&gt;&amp;);\n}\n\nusing namespace std;\nusing half_float::half;\n\nint main()\n{\n    half a, b;\n    half s = sin(a);\n    half t = atan2(a, b);\n}\n</code></pre>\n<p>In <em>VS 2010</em> this compiles just fine (ignore the obvious linker errors for now). But in <em>VS 2012</em> this gives me:</p>\n<blockquote>\n<p id=\"so_14295217_14295217_0\">error C2440: 'conversion' : cannot convert from 'float' to\n  'half_float::half'</p>\n</blockquote>\n<p>So it seems overload resolution doesn't pick the version from namespace <code>half_float</code> (which ADL should accomplish), but the one from <code>std</code> using the implicit conversion to <code>float</code>. But the strange thing is, that this only happens for the <code>atan2</code> call and not the <code>sin</code> call.</p>\n<p>In the larger project, where this error actually first occured to me it also occurs for other 2-argument functions (or rather those with 2 <code>half</code> arguments), like <code>fmod</code>, but not for any 1-argument function. Likewise in the larger project it also works fine for <em>gcc 4.6/4.7</em> and <em>clang 3.1</em> without error, though I didn't test this SSCCE version explicitly there.</p>\n<p>So my question is, is this erroneous behaviour on <em>VS 2012</em>'s side (given that it only happens for <em>2012</em> and only for the 2-argument function), or did I oversee some subtleties in the overload resolution rules (which can indeed get a bit tricky, I guess)?</p>\n<p><strong>EDIT:</strong> It also happens if I'm directly <code>using namespace half_float</code> or put the whole thing in global namespace directly. Likewise does it also happen if I'm not <code>using namespace std</code>, but this is rather the VS-implementation putting the math functions in global namespace.</p>\n<p><strong>EDIT:</strong> It happens both with the original <em>VC 2012</em> compiler as well as the <em>November 2012 CTP</em> of it.</p>\n<p><strong>EDIT:</strong> Although I'm not completely sure it is really a violation of the standard in the strictest sense, I have filed a <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/776471/c-math-functions-too-generic\" rel=\"nofollow\">bug</a> for it based on the findings in my answer, since it is at least inconsistent to the definition of the 1-argument functions and deserves further investigation by the <em>VS</em>-Team.</p>\n", "AcceptedAnswerId": "14298922", "Title": "Incorrect overload resolution for 2-argument functions", "CreationDate": "2013-01-12T16:13:32.283", "Id": "14295217", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-01-14T12:51:32.340", "LastEditorUserId": "743214", "LastActivityDate": "2013-04-23T11:09:56.250", "Score": "9", "OwnerUserId": "743214", "Tags": "<c++><visual-studio-2012><overload-resolution>", "AnswerCount": "3"}, "14298922": {"Id": "14298922", "PostTypeId": "2", "Body": "<p>I think I found the cause. The C++ standard says in section <strong>26.8 [c.math]</strong>, that for the  mathematical functions of the C library,</p>\n<blockquote>\n<p id=\"so_14295217_14298922_0\">there shall be additional overloads sufficient to ensure:</p>\n<ol>\n<li>If any argument corresponding to a double parameter has type long double, then all arguments corresponding to double parameters are\n  effectively cast to long double.</li>\n<li>Otherwise, if any argument corresponding to a double parameter has type double or an integer type, then all arguments corresponding to\n  double parameters are effectively cast to double.</li>\n<li>Otherwise, all arguments corresponding to double parameters are effectively cast to float.</li>\n</ol>\n</blockquote>\n<p>Which can also be seen in the <a href=\"http://en.cppreference.com/w/cpp/numeric/math/atan2\">atan2 documentation</a>.</p>\n<p>Those overloads are provided by <em>VS 2012</em> through the use of a general function template of the form:</p>\n<pre><code>template&lt;typename T,typename U&gt; common_float_type&lt;T,U&gt;::type atan2(T, U);\n</code></pre>\n<p>So we have a template function whose instantiation would involve an implicit conversion (from <code>half&amp;</code> to <code>const half_expr&lt;half&gt;&amp;</code>) and a template function which can be instantiated directly. Thus the latter is preferred. This doesn't happen for the 1-argument functions because for those there only has to be a general version for integral arguments, which is provided by <em>VS 2012</em> for only those using a <code>std::enable_if</code> of <code>std::is_integral</code>.</p>\n<p>But I think the standard is a bit unclear about the fact that those <em>\"additional overloads\"</em> are to be provided only for builtin types. So in the end I'm still not sure if <em>VS 2012</em> strictly violates the standard with its overly generic functions or if it is a viable implementation option to provide those.</p>\n<p><strong>EDIT:</strong> As it seems, there is already <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2086\">defect report 2086</a> for the standard's unclear wording and a fix is on it's way, limiting the requirement for those additional overloads to only arithmetic types. Since this seems to have always been the original intent (and realized by nearly all existing implementations) and it was merely the wording that was unclear, I would indeed regard this a bug in <em>VS 2012</em>'s implementation.</p>\n", "LastEditorUserId": "743214", "LastActivityDate": "2013-01-16T14:00:44.893", "Score": "6", "CreationDate": "2013-01-12T23:09:19.270", "ParentId": "14295217", "CommentCount": "0", "LastEditDate": "2013-01-16T14:00:44.893", "OwnerUserId": "743214"}});