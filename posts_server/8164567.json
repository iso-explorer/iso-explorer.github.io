post_cb({"28926968": {"ParentId": "8164567", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-03-08T13:29:03.563", "Score": "17", "LastEditorUserId": "1286476", "LastEditDate": "2017-05-10T14:10:05.843", "Id": "28926968", "OwnerUserId": "1286476", "Body": "<p>I write my answer because some people might be more happy with simple real life example without STL includes.</p>\n<p>I have my own plain only data array implementation for some reason, and I wanted to use the range based for loop. Here is my solution:</p>\n<pre><code> template &lt;typename DataType&gt;\n class PodArray {\n public:\n   class iterator {\n   public:\n     iterator(DataType * ptr): ptr(ptr){}\n     iterator operator++() { ++ptr; return *this; }\n     bool operator!=(const iterator &amp; other) { return ptr != other.ptr; }\n     const DataType&amp; operator*() const { return *ptr; }\n   private:\n     DataType* ptr;\n   };\n private:\n   unsigned len;\n   DataType *val;\n public:\n   iterator begin() const { return iterator(val); }\n   iterator end() const { return iterator(val + len); }\n\n   // rest of the container definition not related to the question ...\n };\n</code></pre>\n<p>Then the usage example:</p>\n<pre><code>PodArray&lt;char&gt; array;\n// fill up array in some way\nfor(auto&amp; c : array)\n  printf(\"char: %c\\n\", c);\n</code></pre>\n", "LastActivityDate": "2017-05-10T14:10:05.843"}, "23616017": {"ParentId": "8164567", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-05-12T18:16:45.367", "Score": "8", "LastEditorUserId": "130427", "LastEditDate": "2014-05-12T20:34:17.423", "Id": "23616017", "OwnerUserId": "130427", "Body": "<p>In case you want to back a class's iteration directly with its <code>std::vector</code> or <code>std::map</code> member, here is the code for that:</p>\n<pre><code>#include &lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n#include &lt;string&gt;\nusing std::string;\n#include &lt;vector&gt;\nusing std::vector;\n#include &lt;map&gt;\nusing std::map;\n\n\n/////////////////////////////////////////////////////\n/// classes\n/////////////////////////////////////////////////////\n\nclass VectorValues {\nprivate:\n    vector&lt;int&gt; v = vector&lt;int&gt;(10);\n\npublic:\n    vector&lt;int&gt;::iterator begin(){\n        return v.begin();\n    }\n    vector&lt;int&gt;::iterator end(){\n        return v.end();\n    }\n    vector&lt;int&gt;::const_iterator begin() const {\n        return v.begin();\n    }\n    vector&lt;int&gt;::const_iterator end() const {\n        return v.end();\n    }\n};\n\nclass MapValues {\nprivate:\n    map&lt;string,int&gt; v;\n\npublic:\n    map&lt;string,int&gt;::iterator begin(){\n        return v.begin();\n    }\n    map&lt;string,int&gt;::iterator end(){\n        return v.end();\n    }\n    map&lt;string,int&gt;::const_iterator begin() const {\n        return v.begin();\n    }\n    map&lt;string,int&gt;::const_iterator end() const {\n        return v.end();\n    }\n\n    const int&amp; operator[](string key) const {\n        return v.at(key);\n    }\n    int&amp; operator[](string key) {\n        return v[key];\n    } \n};\n\n\n/////////////////////////////////////////////////////\n/// main\n/////////////////////////////////////////////////////\n\nint main() {\n    // VectorValues\n    VectorValues items;\n    int i = 0;\n    for(int&amp; item : items) {\n        item = i;\n        i++;\n    }\n    for(int&amp; item : items)\n        cout &lt;&lt; item &lt;&lt; \" \";\n    cout &lt;&lt; endl &lt;&lt; endl;\n\n    // MapValues\n    MapValues m;\n    m[\"a\"] = 1;\n    m[\"b\"] = 2;\n    m[\"c\"] = 3;\n    for(auto pair: m)\n        cout &lt;&lt; pair.first &lt;&lt; \" \" &lt;&lt; pair.second &lt;&lt; endl;\n}\n</code></pre>\n", "LastActivityDate": "2014-05-12T20:34:17.423"}, "8165154": {"ParentId": "8164567", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2011-11-17T09:54:39.240", "Score": "52", "LastEditorUserId": "13005", "LastEditDate": "2011-11-17T10:27:30.503", "Id": "8165154", "OwnerUserId": "13005", "Body": "<p>The relevant part of the standard is 6.5.4/1:</p>\n<blockquote>\n<p id=\"so_8164567_8165154_0\">if _RangeT is a class type, the unquali\ufb01ed-ids begin and end are\n  looked up in the scope of class _RangeT as if by class member access\n  lookup (3.4.5), and if either (or both) \ufb01nds at least one declaration,\n  begin- expr and end-expr are <code>__range.begin()</code> and <code>__range.end()</code>,\n  respectively;</p>\n<p id=\"so_8164567_8165154_1\">\u2014 otherwise, begin-expr and end-expr are <code>begin(__range)</code> and\n  <code>end(__range)</code>, respectively, where begin and end are looked up with\n  argument-dependent lookup (3.4.2). For the purposes of this name\n  lookup, namespace std is an associated namespace.</p>\n</blockquote>\n<p>So, you can do any of the following:</p>\n<ul>\n<li>define <code>begin</code> and <code>end</code> member functions</li>\n<li>define <code>begin</code> and <code>end</code> free functions that will be found by ADL (simplified version: put them in the same namespace as the class)</li>\n<li>specialize <code>std::begin</code> and <code>std::end</code></li>\n</ul>\n<p><code>std::begin</code> calls the <code>begin()</code> member function anyway, so if you only implement one of the above, then the results should be the same no matter which one you choose. That's the same results for ranged-based for loops, and also the same result for mere mortal code that doesn't have its own magical name resolution rules so just does <code>using std::begin;</code> followed by an unqualified call to <code>begin(a)</code>.</p>\n<p>If you implement the member functions <em>and</em> the ADL functions, though, then range-based for loops should call the member functions, whereas mere mortals will call the ADL functions. Best make sure they do the same thing in that case!</p>\n<p>If the thing you're writing implements the container interface, then it will have <code>begin()</code> and <code>end()</code> member functions already, which should be sufficient. If it's a range that isn't a container (which would be a good idea if it's immutable or if you don't know the size up front), you're free to choose.</p>\n<p>Of the options you lay out, note that you <em>must not</em> overload <code>std::begin()</code>. You are permitted to specialize standard templates for a user-defined type, but aside from that, adding definitions to namespace std is undefined behavior. But anyway, specializing standard functions is a poor choice if only because the lack of partial function specialization means you can only do it for a single class, not for a class template.</p>\n", "LastActivityDate": "2011-11-17T10:27:30.503"}, "8164567": {"CommentCount": "1", "AcceptedAnswerId": "31457319", "PostTypeId": "1", "LastEditorUserId": "476681", "CreationDate": "2011-11-17T09:08:34.763", "LastActivityDate": "2017-05-10T14:10:05.843", "LastEditDate": "2012-10-04T15:04:59.113", "ViewCount": "38380", "FavoriteCount": "33", "Title": "How to make my custom type to work with \"range-based for loops\"?", "Id": "8164567", "Score": "135", "Body": "<p>Like many people these days I've been trying the different features that C+11 brings. One of my favorites is the \"range-based for loops\".</p>\n<p>I understand that:</p>\n<pre><code>for(Type&amp; v : a) { ... }\n</code></pre>\n<p>Is equivalent to:</p>\n<pre><code>for(auto iv = begin(a); iv != end(a); ++iv)\n{\n  Type&amp; v = *iv;\n  ...\n}\n</code></pre>\n<p>And that <code>begin()</code> simply returns <code>a.begin()</code> for standard containers.</p>\n<p>But what if I want to <em>make my custom type \"range-based for loop\"-aware</em> ?</p>\n<p>Should I just specialize <code>begin()</code> and <code>end()</code> ?</p>\n<p>If my custom type belongs to the namespace <code>xml</code>, should I define <code>xml::begin()</code> or <code>std::begin()</code> ?</p>\n<p>In short, what are the guidelines to do that ?</p>\n", "Tags": "<c++><for-loop><c++11><customization>", "OwnerUserId": "279259", "AnswerCount": "5"}, "8164793": {"ParentId": "8164567", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2011-11-17T09:26:40.217", "Score": "25", "LastEditorUserId": "476681", "LastEditDate": "2011-11-17T10:28:45.850", "Id": "8164793", "OwnerUserId": "476681", "Body": "<blockquote>\n<p id=\"so_8164567_8164793_0\">Should I just specialize begin() and end() ?</p>\n</blockquote>\n<p>As far as I know, that is enough. You also have to make sure that incrementing the pointer would get from the begin to the end.</p>\n<p>Next example (it is missing const version of begin and end) compiles and works fine.  </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nint i=0;\n\nstruct A\n{\n    A()\n    {\n        std::generate(&amp;v[0], &amp;v[10], [&amp;i](){  return ++i;} );\n    }\n    int * begin()\n    {\n        return &amp;v[0];\n    }\n    int * end()\n    {\n        return &amp;v[10];\n    }\n\n    int v[10];\n};\n\nint main()\n{\n    A a;\n    for( auto it : a )\n    {\n        std::cout &lt;&lt; it &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p>Here is another example with begin/end as functions. They <strong>have to</strong> be in the same namespace as the class, because of ADL :  </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\n\nnamespace foo{\nint i=0;\n\nstruct A\n{\n    A()\n    {\n        std::generate(&amp;v[0], &amp;v[10], [&amp;i](){  return ++i;} );\n    }\n\n    int v[10];\n};\n\nint *begin( A &amp;v )\n{\n    return &amp;v.v[0];\n}\nint *end( A &amp;v )\n{\n    return &amp;v.v[10];\n}\n} // namespace foo\n\nint main()\n{\n    foo::A a;\n    for( auto it : a )\n    {\n        std::cout &lt;&lt; it &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n", "LastActivityDate": "2011-11-17T10:28:45.850"}, "31457319": {"ParentId": "8164567", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-07-16T14:37:48.160", "Score": "93", "LastEditorUserId": "1774667", "LastEditDate": "2017-01-19T16:37:47.010", "Id": "31457319", "OwnerUserId": "1774667", "Body": "<p>The standard has been changed since the question (and most answers) were posted <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1442\" rel=\"noreferrer\">in the resolution of this defect report</a>.</p>\n<p>The way to make a <code>for(:)</code> loop work on your type <code>X</code> is now one of two ways:</p>\n<ul>\n<li><p>Create member <code>X::begin()</code> and <code>X::end()</code> that return something that acts like an iterator</p></li>\n<li><p>Create a free function <code>begin(X&amp;)</code> and <code>end(X&amp;)</code> that return something that acts like an iterator, in the same namespace as your type <code>X</code>.\u00b9</p></li>\n</ul>\n<p>And similar for <code>const</code> variations.  This will work both on compilers that implement the defect report changes, and compilers that do not.</p>\n<p>The objects returned do not have to actually be iterators.  The <code>for(:)</code> loop, unlike most parts of the C++ standard, is <a href=\"http://en.cppreference.com/w/cpp/language/range-for\" rel=\"noreferrer\">specified to expand to something equivalent to</a>:</p>\n<pre><code>for( range_declaration : range_expression )\n</code></pre>\n<p>becomes:</p>\n<pre><code>{\n  auto &amp;&amp; __range = range_expression ;\n  for (auto __begin = begin_expr,\n            __end = end_expr;\n            __begin != __end; ++__begin) {\n    range_declaration = *__begin;\n    loop_statement\n  }\n}\n</code></pre>\n<p>where the variables beginning with <code>__</code> are for exposition only, and <code>begin_expr</code> and <code>end_expr</code> is the magic that calls <code>begin</code>/<code>end</code>.\u00b2</p>\n<p>The requirements on the begin/end return value are simple: You must overload pre-<code>++</code>, ensure the initialization expressions are valid, binary <code>!=</code> that can be used in a boolean context, unary <code>*</code> that returns something you can assign-initialize <code>range_declaration</code> with, and expose a public destructor.</p>\n<p>Doing so in a way that isn't compatible with an iterator is probably a bad idea, as future iterations of C++ might be relatively cavalier about breaking your code if you do.</p>\n<p>As an aside, it is reasonably likely that a future revision of the standard will permit <code>end_expr</code> to return a different type than <code>begin_expr</code>.  This is useful in that it permits \"lazy-end\" evaluation (like detecting null-termination) that is easy to optimize to be as efficient as a hand-written C loop, and other similar advantages.</p>\n<hr>\n<p>\u00b9 Note that <code>for(:)</code> loops store any temporary in an <code>auto&amp;&amp;</code> variable, and pass it to you as an lvalue.  You cannot detect if you are iterating over a temporary (or other rvalue); such an overload will not be called by a <code>for(:)</code> loop.  See [stmt.ranged] 1.2-1.3 from n4527.</p>\n<p>\u00b2  Either call the <code>begin</code>/<code>end</code> method, or ADL-only lookup of free function <code>begin</code>/<code>end</code>, <em>or</em> magic for C-style array support.  Note that <code>std::begin</code> is not called unless <code>range_expression</code> returns an object of type in <code>namespace std</code> or dependent on same.</p>\n<hr>\n<p>In <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b17\" rel=\"tag\" title=\"show questions tagged 'c++17'\">c++17</a> the range-for expression has been updated</p>\n<pre><code>{\n  auto &amp;&amp; __range = range_expression ;\n  auto __begin = begin_expr;\n  auto __end = end_expr\n  for (;__begin != __end; ++__begin) {\n    range_declaration = *__begin;\n    loop_statement\n  }\n}\n</code></pre>\n<p>with the types of <code>__begin</code> and <code>__end</code> have been decoupled.</p>\n<p>This permits the end iterator to not be the same type as begin.  Your end iterator type can be a \"sentinel\" which only supports <code>!=</code> with the begin iterator type.</p>\n<p>A practical example of why this is useful is that your end iterator can read \"check your <code>char*</code> to see if it points to <code>'0'</code>\" when <code>==</code> with a <code>char*</code>.  This allows a C++ range-for expression to generate optimal code when iterating over a null-terminated <code>char*</code> buffer.</p>\n<pre><code>struct null_sentinal_t {\n  template&lt;class Rhs,\n    std::enable_if_t&lt;!std::is_same&lt;Rhs, null_sentinal_t&gt;{},int&gt; =0\n  &gt;\n  friend bool operator==(Rhs const&amp; ptr, null_sentinal_t) {\n    return !*ptr;\n  }\n  template&lt;class Rhs,\n    std::enable_if_t&lt;!std::is_same&lt;Rhs, null_sentinal_t&gt;{},int&gt; =0\n  &gt;\n  friend bool operator!=(Rhs const&amp; ptr, null_sentinal_t) {\n    return !(ptr==null_sentinal_t{});\n  }\n  template&lt;class Lhs,\n    std::enable_if_t&lt;!std::is_same&lt;Lhs, null_sentinal_t&gt;{},int&gt; =0\n  &gt;\n  friend bool operator==(null_sentinal_t, Lhs const&amp; ptr) {\n    return !*ptr;\n  }\n  template&lt;class Lhs,\n    std::enable_if_t&lt;!std::is_same&lt;Lhs, null_sentinal_t&gt;{},int&gt; =0\n  &gt;\n  friend bool operator!=(null_sentinal_t, Lhs const&amp; ptr) {\n    return !(null_sentinal_t{}==ptr);\n  }\n  friend bool operator==(null_sentinal_t, null_sentinal_t) {\n    return true;\n  }\n  friend bool operator!=(null_sentinal_t, null_sentinal_t) {\n    return false;\n  }\n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/8cbbd3c00d92d0a3\" rel=\"noreferrer\">live example</a> in a compiler without full C++17 support; <code>for</code> loop manually expanded.</p>\n</hr></hr>", "LastActivityDate": "2017-01-19T16:37:47.010"}, "bq_ids": {"n4140": {"so_8164567_8165154_0": {"section_id": 3906, "quality": 0.7777777777777778, "length": 21}}, "n3337": {"so_8164567_8165154_0": {"section_id": 3766, "quality": 0.7777777777777778, "length": 21}, "so_8164567_8165154_1": {"section_id": 3766, "quality": 0.8571428571428571, "length": 18}}, "n4659": {"so_8164567_8165154_0": {"section_id": 4792, "quality": 0.6666666666666666, "length": 18}}}});