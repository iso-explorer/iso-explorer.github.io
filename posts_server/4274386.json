post_cb({"bq_ids": {"n4140": {"so_4274386_4279182_2": {"length": 23, "quality": 0.8214285714285714, "section_id": 7070}, "so_4274386_4279182_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5485}, "so_4274386_4279182_1": {"length": 15, "quality": 0.625, "section_id": 5485}, "so_4274386_4279182_3": {"length": 23, "quality": 1.0, "section_id": 225}}, "n3337": {"so_4274386_4279182_2": {"length": 23, "quality": 0.8214285714285714, "section_id": 6814}, "so_4274386_4279182_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5271}, "so_4274386_4279182_1": {"length": 15, "quality": 0.625, "section_id": 5271}, "so_4274386_4279182_3": {"length": 23, "quality": 1.0, "section_id": 218}}, "n4659": {"so_4274386_4279182_2": {"length": 23, "quality": 0.8214285714285714, "section_id": 8567}, "so_4274386_4279182_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 6920}, "so_4274386_4279182_1": {"length": 16, "quality": 0.6666666666666666, "section_id": 6920}, "so_4274386_4279182_3": {"length": 23, "quality": 1.0, "section_id": 233}}}, "4274471": {"Id": "4274471", "PostTypeId": "2", "Body": "<p>//Run this- it now will compile for you</p>\n<pre><code>template &lt;typename U &gt; class b; //&lt;----- forward declaration\n\ntemplate&lt;typename T&gt;\nclass List\n{\nprotected:\n\n\n        class a {\n        int x;\n        int y;\n        private:\n          friend class b&lt;T&gt;;  // &lt;------------ Add &lt;T&gt;\n        };\n        template &lt;typename U &gt; class b { \n          int z;\n          U y;\n        };\n\n        public:\n        List() {\n          a* ptr = (a *)new unsigned char[sizeof(a)];\n        }\n};\n\nint main() {\n    List&lt;int&gt;  mylist;\n\n}\n</code></pre>\n", "LastActivityDate": "2010-11-25T07:02:06.407", "CommentCount": "0", "CreationDate": "2010-11-25T07:02:06.407", "ParentId": "4274386", "Score": "3", "OwnerUserId": "505931"}, "4274386": {"ViewCount": "1423", "Body": "<p>Making an unknown friend</p>\n<pre><code>template&lt;typename T&gt;\nclass List\n{\nprotected:\n\n    class a {\n        int x;\n        int y;\n    private:\n        friend class b;  // &lt;------------ Why this is not an error? \n    };\n\n    template &lt;typename U &gt; class b {  //If that is not a error this should be an error\n        int z;\n        U y;\n    };\n\n    public:\n        List() {\n            a* ptr = (a *)new unsigned char[sizeof(a)];\n        }\n};\n\nint main() {\n    List&lt;int&gt;  mylist;\n}\n</code></pre>\n<p>Please go through this link, I have my questions as comments in the code.\nI am trying to make another class a friend of my class. But that class is not know at the time of making friend. What is the C++ rule that allows for it.\nLater I am defining that class in such a way that, it is incompatible with the friend declaration. Why is that not throwing an error. \nThanks</p>\n", "AcceptedAnswerId": "4279182", "Title": "Making an undefined class as friend, and defining it later", "CreationDate": "2010-11-25T06:43:41.483", "Id": "4274386", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2010-11-26T14:11:36.333", "LastEditorUserId": "165520", "LastActivityDate": "2010-11-26T14:11:36.333", "Score": "7", "OwnerUserId": "420536", "Tags": "<c++><templates><declaration><local><friend>", "AnswerCount": "3"}, "4279182": {"Id": "4279182", "PostTypeId": "2", "Body": "<p>Yes your code is <strong>invalid</strong>! This is an interesting show of how templates can change meaning of code in subtle ways. The following code <em>is</em> valid:</p>\n<pre><code>class List\n{\npublic:\n    class a {\n        typedef int type;\n        friend class b; // that's fine!\n    };\n\n    template &lt;typename U &gt; class b;\n};\n\nclass b {\n  List::a::type an_int; // allowed to access private member\n};\n</code></pre>\n<p>Standard says at 7.3.1.2/3</p>\n<blockquote>\n<p id=\"so_4274386_4279182_0\">If a friend declaration in a non-local class first declares a class or function83) the friend class or function is a member of the innermost enclosing namespace.</p>\n</blockquote>\n<p>When is it a \"first declared class\"? It says that too there</p>\n<blockquote>\n<p id=\"so_4274386_4279182_1\">When looking for a prior declaration of a class or a function declared as a friend, and when the name of the friend class or function is neither a qualified name nor a template-id, scopes outside the innermost enclosing namespace scope are not considered.</p>\n</blockquote>\n<p>The lookup for \"class b\" is delegated from 7.1.5.3/2 to 3.4.4 which in turn delegates to unqualified name lookup at 3.4/7. All the question now is whether the template-name \"b\" is visible in the friend declaration class a. If it isn't, the name is not found and the friend declaration will refer to a new declared class at global scope. 3.3.6/1 about the scope of it says</p>\n<blockquote>\n<p id=\"so_4274386_4279182_2\">The potential scope of a name declared in a class consists not only of the declarative region following\n  the name\u2019s declarator, but also of all function bodies, default arguments, and constructor ctor-\n  initializers in that class (including such things in nested classes).</p>\n</blockquote>\n<p>Ignoring a few pedantic points that would make this wording not apply to here (which were a defect but are fixed in the C++0x version of that paragraph which also makes this easier to read), this list does not include the friend declaration as an area where that template name is visible. </p>\n<p><strong>However</strong>, the friend was declared in a member class of a class template. When the member class is instantiated <em>different</em> lookup applies - the lookup for friend names declared in a class template! The Standard says</p>\n<blockquote>\n<p id=\"so_4274386_4279182_3\">Friend classes or functions can be declared within a class template. When a template is instantiated, the\n  names of its friends are treated as if the specialization had been explicitly declared at its point of instantiation.</p>\n</blockquote>\n<p>So the following code is invalid:</p>\n<pre><code>template&lt;typename T&gt;\nclass List\n{\npublic:\n    class a {\n        typedef int type;\n        friend class b; // that's fine!\n    };\n\n    template &lt;typename U &gt; class b;\n};\n\n// POI\nList&lt;int&gt;::a x; \n</code></pre>\n<p>When that causes <code>List&lt;int&gt;::a</code> to be implicitly instantiated, the name <code>a</code> is looked up at \"// POI\" as if there would have been an explicit specialization declared. In that case, the template <code>List::b</code> has already been declared, and this lookup will hit it and emit an error because it's a template and not a non-template class. </p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2010-11-26T12:15:29.953", "Score": "6", "CreationDate": "2010-11-25T16:37:34.887", "ParentId": "4274386", "CommentCount": "8", "OwnerUserId": "34509", "LastEditDate": "2010-11-26T12:15:29.953"}, "4274442": {"Id": "4274442", "PostTypeId": "2", "Body": "<p>The code is ill-formed and Comeau rejects it giving the following error</p>\n<pre><code>error: invalid redeclaration of type name \"b\" (declared at\n      line 11)\n</code></pre>\n<p>I think this is a bug in g++. Intel C++ rejects it too. You can fix the code by defining class <code>B</code> above <code>A</code>.</p>\n<pre><code>template &lt;typename U &gt; class b { \n        int z;\n        U y;\n};\nclass a {\n        int x;\n        int y;\n    private:\n        friend class b&lt;T&gt;;  \n};\n</code></pre>\n", "LastEditorUserId": "165520", "LastActivityDate": "2010-11-25T10:46:40.537", "Score": "2", "CreationDate": "2010-11-25T06:54:54.337", "ParentId": "4274386", "CommentCount": "2", "OwnerUserId": "165520", "LastEditDate": "2010-11-25T10:46:40.537"}});