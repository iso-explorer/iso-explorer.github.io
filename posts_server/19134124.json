post_cb({"19134124": {"ViewCount": "1302", "Body": "<p>Does the C++ standard guarantee that two pointers to a function always compare equal? I understand that this will normally be true for non-inline functions. But if there is an inline function and a pointer to the function is created in two separate compilation units, will the linker merge the two instantiations, or is it allowed to emit duplicate functions?</p>\n<p>If the answer to the above is \"they are equal\": Does this still hold if there is a common header with an inline function, and both the main program and a dynamically loaded plugin (shared object/DLL) create a pointer to the function?</p>\n", "AcceptedAnswerId": "19134258", "Title": "Are two function pointers to the same function always equal?", "CreationDate": "2013-10-02T09:46:16.573", "Id": "19134124", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-10-02T09:50:13.680", "LastEditorUserId": "72882", "LastActivityDate": "2013-10-10T09:57:15.203", "Score": "27", "OwnerUserId": "509319", "Tags": "<c++><function-pointers>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_19134124_19134258_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 6155}, "so_19134124_19134422_0": {"length": 5, "quality": 0.625, "section_id": 6156}, "so_19134124_19134422_2": {"length": 10, "quality": 1.0, "section_id": 5404}}, "n3337": {"so_19134124_19134258_0": {"length": 17, "quality": 1.0, "section_id": 5917}, "so_19134124_19134422_0": {"length": 5, "quality": 0.625, "section_id": 5913}, "so_19134124_19134422_2": {"length": 10, "quality": 1.0, "section_id": 5199}}, "n4659": {"so_19134124_19134258_0": {"length": 11, "quality": 0.6470588235294118, "section_id": 7652}, "so_19134124_19134422_0": {"length": 5, "quality": 0.625, "section_id": 7653}, "so_19134124_19134422_2": {"length": 10, "quality": 1.0, "section_id": 6853}}}, "19134422": {"Id": "19134422", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_19134124_19134422_0\">Does the C++ standard guarantee that two pointers to a function always\n  compare equal?</p>\n</blockquote>\n<p>Yes, two pointers that point to the same function compare equal.</p>\n<blockquote>\n<p id=\"so_19134124_19134422_1\">Does this still hold if there is a common header with an inline\n  function, and both the main program and a dynamically loaded plugin\n  (shared object/DLL) create a pointer to the function?</p>\n</blockquote>\n<p>Yes, per 7.1.2.p4</p>\n<blockquote>\n<p id=\"so_19134124_19134422_2\">An inline function with external linkage shall have the same address\n  in all translation units.</p>\n</blockquote>\n", "LastActivityDate": "2013-10-02T10:02:06.790", "CommentCount": "1", "CreationDate": "2013-10-02T10:02:06.790", "ParentId": "19134124", "Score": "8", "OwnerUserId": "906773"}, "19134258": {"Id": "19134258", "PostTypeId": "2", "Body": "<p>Section \u00a75.10/1 of the C++11 standard says:</p>\n<blockquote>\n<p id=\"so_19134124_19134258_0\">Two pointers of the same type compare equal if and only if they are\n  both null, both point to the same function, or both represent the same\n  address</p>\n</blockquote>\n<p>Two copies of the same <code>inline</code> function are still the same function. From an implementation point-of-view, the compiler will generate a copy of the function in each translation unit but the linker will then throw one of the copies away so only one is remaining.</p>\n<p>By taking the address of a function you prevent it from being inlined (different from <code>inline</code>, which is more about avoiding violation of the One Definition Rule).</p>\n<p>DLLs are outside the scope of the standard but only one copy of the function will remain in the binary image so getting the function address (e.g. <code>GetProcAddress</code>) from the DLL will get the same function pointer as code inside the DLL.</p>\n", "LastEditorUserId": "322333", "LastActivityDate": "2013-10-10T09:57:15.203", "Score": "26", "CreationDate": "2013-10-02T09:53:52.990", "ParentId": "19134124", "CommentCount": "6", "OwnerUserId": "2491746", "LastEditDate": "2013-10-10T09:57:15.203"}});