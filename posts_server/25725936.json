post_cb({"25726846": {"ParentId": "25725936", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong>In C an object's stored value can be modified only once between two sequence points.</strong></p>\n<p>A sequence point occurs:</p>\n<ol>\n<li>At the end of full expression.</li>\n<li>At the <code>&amp;&amp;</code>, <code>||</code> and <code>?:</code> operators</li>\n<li>At a function call.</li>\n</ol>\n<p>So for example this expression <code>x = i++ * i++</code> is <em>undefined</em>, whereas <code>x = i++ &amp;&amp; i++</code> is <em>perfectly legal</em>.</p>\n<p>Your code shows <strong>defined behaviour</strong>.</p>\n<blockquote>\n<p id=\"so_25725936_25726846_0\">int x=0;</p>\n<p id=\"so_25725936_25726846_1\">cout &lt;&lt; ( x == 0 ? x++ : x) &lt;&lt; endl;</p>\n</blockquote>\n<p>In the above expression <code>x</code> is <code>0</code>, so <code>x++</code> will be executed, here x++ is post increment so it will output <code>0</code>.</p>\n<blockquote>\n<p id=\"so_25725936_25726846_2\">cout &lt;&lt; \"x=\" &lt;&lt; x &lt;&lt; endl;</p>\n</blockquote>\n<p>In the above expression as <code>x</code> now has value <code>1</code> so the output will be <code>1</code>.</p>\n<blockquote>\n<p id=\"so_25725936_25726846_3\">cout &lt;&lt; (x == 1 || --x == 0 ? 1 : 2) &lt;&lt; endl;</p>\n</blockquote>\n<p>Here <code>x</code> is <code>1</code> so the next condition is not evaluated(<code>--x == 0</code>) and the output will <code>1</code>.</p>\n<blockquote>\n<p id=\"so_25725936_25726846_4\">cout &lt;&lt; \"x=\" &lt;&lt; x &lt;&lt; endl;</p>\n</blockquote>\n<p>As the expression <code>--x == 0</code> is not evaluated the output will again be <code>1</code>.</p>\n", "OwnerUserId": "1336087", "LastEditorUserId": "1336087", "LastEditDate": "2014-09-09T05:47:27.043", "Id": "25726846", "Score": "3", "CreationDate": "2014-09-08T14:39:42.193", "LastActivityDate": "2014-09-09T05:47:27.043"}, "25725987": {"ParentId": "25725936", "PostTypeId": "2", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_25725936_25725987_0\">I understand the output, but is this undefined behaviour or not?  </p>\n</blockquote>\n<p>Code is perfectly defined. C11 standard says:  </p>\n<h3>6.5.15 Conditional operator</h3>\n<blockquote>\n<p id=\"so_25725936_25725987_1\">The first operand is evaluated; <strong>there is a sequence point between its evaluation and the\n  evaluation of the second or third operand</strong> (whichever is evaluated). The second operand\n  is evaluated only if the first compares unequal to <code>0</code>; the third operand is evaluated only if\n  the first compares equal to <code>0</code>; the result is the value of the second or third operand\n  (whichever is evaluated), converted to the type described below.110)   </p>\n</blockquote>\n<h3>6.5.14 Logical OR operator</h3>\n<blockquote>\n<p id=\"so_25725936_25725987_2\">Unlike the bitwise <code>|</code> operator, <strong>the <code>||</code> operator guarantees left-to-right evaluation</strong>; if the\n  second operand is evaluated, <strong>there is a sequence point between the evaluations of the first\n  and second operands</strong>. If the first operand compares unequal to <code>0</code>, the second operand is\n  not evaluated. </p>\n</blockquote>\n<p>Further <a href=\"http://en.wikipedia.org/wiki/Sequence_point\" rel=\"nofollow\">wiki</a> explains it with example:  </p>\n<blockquote>\n<ul>\n<li><p id=\"so_25725936_25725987_3\">Between evaluation of the left and right operands of the <code>&amp;&amp;</code> (logical AND), <code>||</code> (logical OR) (as part of short-circuit evaluation), and <code>comma operators</code>. For example, in the expression <code>*p++ != 0 &amp;&amp; *q++ != 0</code>, all side effects of the sub-expression <code>*p++ != 0</code> are completed before any attempt to access <code>q</code>.  </p></li>\n<li><p id=\"so_25725936_25725987_4\">Between the evaluation of the first operand of the ternary \"question-mark\" operator and the second or third operand. For example, in the expression <code>a = (*p++) ? (*p++) : 0</code> there is a sequence point after the first <code>*p++</code>, meaning it has already been incremented by the time the second instance is executed.    </p></li>\n</ul>\n</blockquote>\n<p>The rule for <code>||</code> and <code>?:</code> is same for C++ (section 5.15 and 5.16) as in C.</p>\n<hr>\n<blockquote>\n<p id=\"so_25725936_25725987_5\">Is the order of evaluation guaranteed in either case?  </p>\n</blockquote>\n<p>Yes. The order of evaluation of the operands of operators <code>||</code>, <code>&amp;&amp;</code>, <code>,</code> and <code>?:</code> is guaranteed to be from left to right.</p>\n</hr>", "OwnerUserId": "2455888", "LastEditorUserId": "2455888", "LastEditDate": "2014-09-09T06:23:52.503", "Id": "25725987", "Score": "7", "CreationDate": "2014-09-08T13:57:59.747", "LastActivityDate": "2014-09-09T06:23:52.503"}, "25725936": {"CommentCount": "6", "AcceptedAnswerId": "25726087", "CreationDate": "2014-09-08T13:54:30.137", "LastActivityDate": "2014-09-10T21:03:19.800", "PostTypeId": "1", "ViewCount": "3656", "FavoriteCount": "2", "Title": "Is it safe to put increment/decrement operators inside ternary/conditional operators?", "Id": "25725936", "Score": "24", "Body": "<p>Here's an example</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{   \n    int x = 0;\n    cout &lt;&lt; (x == 0 ? x++ : x) &lt;&lt; endl; //operator in branch\n    cout &lt;&lt; \"x=\" &lt;&lt; x &lt;&lt; endl;\n    cout &lt;&lt; (x == 1 || --x == 0 ? 1 : 2) &lt;&lt; endl; //operator in condition\n    cout &lt;&lt; \"x=\" &lt;&lt; x &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>output:</p>\n<pre><code>0\nx=1\n1\nx=1\n</code></pre>\n<p>I understand the output, but <em>is this undefined behaviour or not? Is the order of evaluation guaranteed in either case?</em></p>\n<p>Even if guaranteed, I'm quite aware using increment/decrement can quickly become an issue for readability. I only ask as I saw similar code and was immediately unsure, given there are lots of examples of ambiguous/undefined use of increment/decrement operators, such as...</p>\n<ul>\n<li><blockquote>\n<p id=\"so_25725936_25725936_0\">C++ does not define the order in which function parameters are evaluated. <a href=\"http://www.learncpp.com/cpp-tutorial/33-incrementdecrement-operators-and-side-effects/\">\u21aa</a></p>\n</blockquote>\n<pre><code>int nValue = Add(x, ++x);\n</code></pre></li>\n<li><blockquote>\n<p id=\"so_25725936_25725936_1\">The C++ language says you cannot modify a variable more than once between sequence points. <a href=\"http://www.parashift.com/c++-faq-lite/double-mod-betw-seq-pt.html\">\u21aa</a></p>\n</blockquote>\n<pre><code> x = ++y + y++\n</code></pre></li>\n<li><blockquote>\n<p id=\"so_25725936_25725936_2\">Because increment and decrement operators have side effects, using expressions with increment or decrement operators in a preprocessor macro can have undesirable results. <a href=\"http://msdn.microsoft.com/en-us/library/dy3d35h8.aspx\">\u21aa</a></p>\n</blockquote>\n<pre><code> #define max(a,b) ((a)&lt;(b))?(b):(a)\n k = max( ++i, j );\n</code></pre></li>\n</ul>\n", "Tags": "<c++><c><increment><ternary-operator><decrement>", "OwnerUserId": "1888983", "AnswerCount": "5"}, "25726045": {"ParentId": "25725936", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>There is a guaranteed order of execution in ternary operators and boolean <code>&amp;&amp;</code> and <code>||</code> operations, so there is no conflict in evaluation sequence points.</p>\n<p>One at a time</p>\n<pre><code> cout &lt;&lt; (x == 0 ? x++ : x) &lt;&lt; endl; //operator in branch\n</code></pre>\n<p>Will always output <code>x</code> but will increment it only if it was 0.</p>\n<pre><code> cout &lt;&lt; (x == 1 || --x == 0 ? 1 : 2) &lt;&lt; endl; //operator in condition\n</code></pre>\n<p>This is well defined too, if <code>x</code> was 1 it will not evaluate the RHS, if it wasn't it will decrement it but <code>--x</code> will never be 0, so it will be true iff x==1, in which case <code>x</code> will also now be 0.</p>\n<p>In the latter case if x is <code>INT_MIN</code> it is not well-defined behaviour to decrement it (and it would execute).</p>\n<p>That can't happen in the first case where x won't be 0 if it is <code>INT_MAX</code> so you are safe.</p>\n", "OwnerUserId": "442284", "LastEditorUserId": "442284", "LastEditDate": "2014-09-08T14:09:53.590", "Id": "25726045", "Score": "9", "CreationDate": "2014-09-08T14:00:48.047", "LastActivityDate": "2014-09-08T14:09:53.590"}, "25726087": {"ParentId": "25725936", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>For the conditional operator (\u00a75.16 [expr.cond]/p1):</p>\n<blockquote>\n<p id=\"so_25725936_25726087_0\">Every value computation and side effect associated with the first\n  expression is sequenced before every value computation and side effect\n  associated with the second or third expression.</p>\n</blockquote>\n<p>For the logical OR operator (\u00a75.15 [expr.log.or]/p1-2):</p>\n<blockquote>\n<p id=\"so_25725936_25726087_1\">the second operand is not evaluated if the first operand evaluates to <code>true</code>.\n  [...] If the second expression is evaluated, every value computation and\n  side effect associated with the first expression is sequenced before\n  every value computation and side effect associated with the second\n  expression.</p>\n</blockquote>\n<p>The behavior of your code is well-defined.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-09-10T21:03:19.800", "Id": "25726087", "Score": "32", "CreationDate": "2014-09-08T14:02:57.027", "LastActivityDate": "2014-09-10T21:03:19.800"}, "25731540": {"ParentId": "25725936", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, it is safe to use the increment/decrement operators as you have.  Here is what is happening in your code:</p>\n<h2>Snippet #1</h2>\n<pre><code>cout &lt;&lt; (x == 0 ? x++ : x) &lt;&lt; endl; //operator in branch\n</code></pre>\n<p>In this snippet, you are testing if <code>x == 0</code>, which is <code>true</code>.  Since it is <code>true</code>, your ternary expression evaluates the <code>x++</code>.\nSince you are using a post-increment here, the original value for <code>x</code> is printed to the standard output stream, <strong>and then</strong> <code>x</code> is incremented.</p>\n<h2>Snippet #2</h2>\n<pre><code>cout &lt;&lt; (x == 1 || --x == 0 ? 1 : 2) &lt;&lt; endl; //operator in condition\n</code></pre>\n<p>This snippet is a bit more confusing, but it still yields a predictable result.  At this point, <code>x = 1</code> from the first snippet.  In the ternary expression, the conditional part is evaluated first; however, due to <a href=\"http://en.wikipedia.org/wiki/Short-circuit_evaluation\" rel=\"nofollow\">Short-Circuiting</a>, <strong>the second condition,</strong> <code>--x == 0</code><strong>, is never evaluated.</strong></p>\n<p>For C++ the operators <code>||</code> and <code>&amp;&amp;</code> are the short-circuiting boolean operators for <strong>logical OR</strong> and <strong>logical AND</strong> respectively.  When you use these operators, your conditions are checked (from left to right) until the final result can be determined.  Once the result is determined, no more conditions are checked.</p>\n<p>Looking at snippet #2, your first condition checks if <code>x == 1</code>.  Since your first condition evaluates to <code>true</code> and you are using the logical OR, there is no need to keep evaluating other conditions.  That means that <code>--x == 0</code> is <strong>never executed</strong>.</p>\n<hr>\n<h2>A quick side-note about short-circuiting:</h2>\n<p>Short-circuiting is useful for increasing performance in your program.\nSuppose you had a condition like this which calls several time-expensive functions:</p>\n<pre><code>if (task1() &amp;&amp; task2())\n{ \n    //...Do something...\n}\n</code></pre>\n<p>In this example, <code>task2</code> should never be called unless <code>task1</code> completes successfully (<code>task2</code> depends on some data that is altered by <code>task1</code>).</p>\n<p>Because we are using a <strong>short-circuiting AND operator</strong>, if <code>task1</code> fails by returning <code>false</code>, then if-statement has the sufficient information to exit early and stop checking other conditions.  This means that <code>task2</code> is never called.</p>\n</hr>", "OwnerUserId": "975724", "LastEditorUserId": "975724", "LastEditDate": "2014-09-08T19:23:17.550", "Id": "25731540", "Score": "2", "CreationDate": "2014-09-08T19:18:04.987", "LastActivityDate": "2014-09-08T19:23:17.550"}, "bq_ids": {"n4140": {"so_25725936_25726087_1": {"section_id": 6167, "quality": 0.7857142857142857, "length": 22}, "so_25725936_25725936_0": {"section_id": 3260, "quality": 0.6666666666666666, "length": 4}, "so_25725936_25726087_0": {"section_id": 6167, "quality": 1.0, "length": 19}}, "n3337": {"so_25725936_25726087_1": {"section_id": 5928, "quality": 0.7857142857142857, "length": 22}, "so_25725936_25725936_0": {"section_id": 3132, "quality": 0.6666666666666666, "length": 4}, "so_25725936_25726087_0": {"section_id": 5928, "quality": 1.0, "length": 19}}, "n4659": {"so_25725936_25726087_1": {"section_id": 7664, "quality": 0.7857142857142857, "length": 22}, "so_25725936_25726087_0": {"section_id": 7664, "quality": 1.0, "length": 19}}}});