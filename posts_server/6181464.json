post_cb({"bq_ids": {"n4140": {"so_6181464_6181507_0": {"length": 11, "quality": 0.55, "section_id": 5971}}, "n3337": {"so_6181464_6181507_0": {"length": 19, "quality": 0.95, "section_id": 5739}}, "n4659": {"so_6181464_6181507_0": {"length": 11, "quality": 0.55, "section_id": 7470}}}, "6181511": {"Id": "6181511", "PostTypeId": "2", "Body": "<p>No, <code>my_huge_vector</code> will not be captured. <code>[=]</code> means all <strong>used</strong> variables are captured in the lambda.</p>\n", "LastActivityDate": "2011-05-30T23:10:24.437", "CommentCount": "1", "CreationDate": "2011-05-30T23:10:24.437", "ParentId": "6181464", "Score": "14", "OwnerUserId": "776774"}, "6181464": {"ViewCount": "18304", "Body": "<p>When I use <code>[=]</code> to indicate that I would like all local variables to be captured by value in a lambda, will that result in <em>all</em> local variables in the function being copied, or just all local variables <em>that are used by the lambda</em>?</p>\n<p>So, for example, if i I have:</p>\n<pre><code>vector&lt;int&gt; my_huge_vector(100000);\nint my_measly_int;\nsome_function([=](int i){ return my_measly_int + i; });\n</code></pre>\n<p>Will my_huge_vector be copied, even though I don't use it in the lambda?</p>\n", "AcceptedAnswerId": "6181507", "Title": "Do c++11 lambdas capture variables they don't use?", "CreationDate": "2011-05-30T23:02:44.607", "Id": "6181464", "CommentCount": "0", "FavoriteCount": "15", "PostTypeId": "1", "LastEditDate": "2014-02-19T23:16:24.557", "LastEditorUserId": "24874", "LastActivityDate": "2014-02-19T23:16:24.557", "Score": "100", "OwnerUserId": "141719", "Tags": "<c++><lambda><c++11>", "AnswerCount": "2"}, "6181507": {"Id": "6181507", "PostTypeId": "2", "Body": "<p>Each variable expressly named in the capture list is captured.  The default capture will only capture variables that are both (a) not expressly named in the capture list and (b) <em>used</em> in the body of the lambda expression.  If a variable is not expressly named and you don't use the variable in the lambda expression, then the variable is not captured.  In your example, <code>my_huge_vector</code> is not captured.</p>\n<p>Per C++11 \u00a75.1.2[expr.prim.lambda]/11:</p>\n<blockquote>\n<p id=\"so_6181464_6181507_0\">If a <em>lambda-expression</em> has an associated <em>capture-default</em> and its <em>compound-statement</em> <em>odr-uses</em> <code>this</code> or a variable with automatic storage duration and the <em>odr-used</em> entity is not explicitly captured, then the <em>odr-used</em> entity is said to be implicitly captured.</p>\n</blockquote>\n<p>Your lambda expression has an associated capture default:  by default, you capture variables by value using the <code>[=]</code>.  </p>\n<p>If and only if a variable is used (in the One Definition Rule sense of the term \"used\") is a variable implicitly captured.  Since you don't use <code>my_huge_vector</code> at all in the body (the \"compound statement\") of the lambda expression, it is not implicitly captured.</p>\n<p>To continue with \u00a75.1.2/14</p>\n<blockquote>\n<p id=\"so_6181464_6181507_1\">An entity is captured by copy if </p>\n<ul>\n<li>it is implicitly captured and the <em>capture-default</em> is <code>=</code> or if </li>\n<li>it is explicitly captured with a capture that does not include an <code>&amp;</code>. </li>\n</ul>\n</blockquote>\n<p>Since your <code>my_huge_vector</code> is not implicitly captured and it is not explicitly captured, it is not captured at all, by copy or by reference.</p>\n", "LastEditorUserId": "151292", "LastActivityDate": "2012-10-15T20:23:25.950", "Score": "99", "CreationDate": "2011-05-30T23:09:46.223", "ParentId": "6181464", "CommentCount": "9", "OwnerUserId": "151292", "LastEditDate": "2012-10-15T20:23:25.950"}});