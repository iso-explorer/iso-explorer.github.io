post_cb({"12982668": {"CommentCount": "14", "ViewCount": "602", "PostTypeId": "1", "LastEditorUserId": "1489639", "CreationDate": "2012-10-19T21:24:49.080", "LastActivityDate": "2012-10-19T21:55:07.783", "Title": "Should std::vector::erase() destroy the element being erased? (instead of the last element)", "AcceptedAnswerId": "12982747", "LastEditDate": "2012-10-19T21:53:51.683", "Id": "12982668", "Score": "2", "Body": "<p><strong>Background</strong></p>\n<p>A while back, I ran into some behaviour that I found very strange and seemingly incorrect and I filed a bug report with GCC about it.  You can see the report and the response I got here:   </p>\n<p><a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=47305\" rel=\"nofollow\">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=47305</a></p>\n<p>(I'm going to replicate most of that here.)</p>\n<p>At the time, I didn't understand the answer, but was not a member of StackOverflow and didn't have anyone to ask about it, so I just hacked a work-around and went on.  But recently, I was revisiting this code and I still don't understand the rationale for this not being a bug, so...</p>\n<p><strong>My Question</strong></p>\n<p>In the C++ stdlib distribution included with with my Mac (currently OS X, Darwin 12.2.0 x86_64), the implementation of <code>std::vector::erase()</code> from <code>/usr/include/c++/4.2.1/vector.tcc</code> lines 106-116 is shown here:</p>\n<pre><code>template&lt;typename _Tp, typename _Alloc&gt;\n  typename vector&lt;_Tp, _Alloc&gt;::iterator\n  vector&lt;_Tp, _Alloc&gt;::\n  erase(iterator __position)\n  {\n    if (__position + 1 != end())\n      std::copy(__position + 1, end(), __position);\n    --this-&gt;_M_impl._M_finish;\n    this-&gt;_M_impl.destroy(this-&gt;_M_impl._M_finish);\n    return __position;\n  }\n</code></pre>\n<p>Note that <code>destroy()</code> will be called for the element that is <em>last</em> in the\nvector prior to the call to this <code>erase()</code>, instead of being called for the\nelement pointed to by <code>__position</code>.  I believe this is incorrect -- I think it\nshould instead call <code>destroy()</code> for the element pointed to by <code>__position</code>.  For\nsimple POD types, this isn't that big of a deal, but for classes where the\ndestructors have side effects (such as smart pointers), it can be critical. </p>\n<p>The following code illustrates the problem:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nclass MyClass\n{\n    int m_x;\npublic:\n     MyClass(int x) : m_x(x) { }\n    ~MyClass()\n    {\n        std::cerr &lt;&lt; \"Destroying with m_x=\" &lt;&lt; m_x &lt;&lt; std::endl;\n    }\n};\n\nint main(void)\n{\n    std::vector&lt;MyClass&gt; testvect;\n    testvect.reserve(8);\n    testvect.push_back(MyClass(1));\n    testvect.push_back(MyClass(2));\n    testvect.push_back(MyClass(3));\n    testvect.push_back(MyClass(4));\n    testvect.push_back(MyClass(5));\n\n    std::cerr &lt;&lt; \"ABOUT TO DELETE #3:\" &lt;&lt; std::endl;\n\n    testvect.erase(testvect.begin() + 2);\n\n    std::cerr &lt;&lt; \"DONE WITH DELETE.\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>When I compile this with g++ version 4.2.1 (no command line arguments) on my\nMac, it produces the following when I run it:</p>\n<pre><code>Destroying with m_x=1\nDestroying with m_x=2\nDestroying with m_x=3\nDestroying with m_x=4\nDestroying with m_x=5\nABOUT TO DELETE #3:\nDestroying with m_x=5\nDONE WITH DELETE.\nDestroying with m_x=1\nDestroying with m_x=2\nDestroying with m_x=4\nDestroying with m_x=5\n</code></pre>\n<p>Note that the key line after the \"ABOUT TO DELETE #3\" message shows that the\ndestructor was actually called for the (copy of the) fifth thing I added.  <em>Importantly, the\ndestructor for #3 is never called!!</em></p>\n<p>It appears that the version of <code>erase()</code> that takes a range (two iterators) also\nhas a similar problem.</p>\n<p><em><strong>So my question is, am I wrong to expect that the destructor of the element I am erasing from a vector gets called?</strong></em></p>  It seems that if you can't count on this, you can't safely use smart pointers in vectors.  Or is this just a bug in the STL vector implementation distributed by Apple?  Am I missing something obvious?\n", "Tags": "<c++><stdvector>", "OwnerUserId": "1489639", "AnswerCount": "4"}, "12982748": {"ParentId": "12982668", "CommentCount": "0", "CreationDate": "2012-10-19T21:32:24.577", "OwnerUserId": "51831", "PostTypeId": "2", "Id": "12982748", "Score": "3", "Body": "<p>Actually, there is no problem. In the line</p>\n<pre><code>std::copy(__position + 1, end(), __position);\n</code></pre>\n<p>the deleted element gets overwritten with consecutive elements; if it holds resources that need to be freed, it would do so in its <code>operator=</code>.</p>\n<p>In C++11, you would want to use move instead of copy; but what you posted is an OK C++03 implementation for <code>std::vector::erase</code>.</p>\n", "LastActivityDate": "2012-10-19T21:32:24.577"}, "12982747": {"ParentId": "12982668", "CommentCount": "1", "CreationDate": "2012-10-19T21:32:11.590", "OwnerUserId": "927034", "PostTypeId": "2", "Id": "12982747", "Score": "4", "Body": "<p>When you <code>erase</code> the element containing a <strong>3</strong>, the following elements have to be shifted back to fill the void. Then element <strong>#3</strong> gets assigned what <strong>#4</strong> has, and <strong>#4</strong> gets assigned what <strong>#5</strong> has. The last element, <strong>#5</strong>, is left with whatever value it has since it is about to be deleted anyway.</p>\n<p>When the <code>vector</code> goes out of scope, you see the remaining 4 elements being destroyed.</p>\n<p>If you were to hold <em>smart pointers</em> in your <code>vector</code>, the resources will be properly freed when the assignment operator is called.</p>\n", "LastActivityDate": "2012-10-19T21:32:11.590"}, "12982762": {"ParentId": "12982668", "CommentCount": "0", "CreationDate": "2012-10-19T21:33:45.467", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "12982762", "Score": "2", "Body": "<p>The destructor only get called for the last element, but the object being erased gets overwritten by assigning from the next element to it. So the assignment operator frees up the old resources. When the type is a smart pointer, that means doing adjusting the reference and, if appropriate, deleting the controlled object.</p>\n", "LastActivityDate": "2012-10-19T21:33:45.467"}, "bq_ids": {"n4140": {"so_12982668_12982926_0": {"section_id": 989, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_12982668_12982926_0": {"section_id": 974, "quality": 0.9130434782608695, "length": 21}}, "n4659": {"so_12982668_12982926_0": {"section_id": 1052, "quality": 0.9130434782608695, "length": 21}}}, "12982926": {"ParentId": "12982668", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2012-10-19T21:49:58.190", "Score": "2", "LastEditorUserId": "13005", "LastEditDate": "2012-10-19T21:55:07.783", "Id": "12982926", "OwnerUserId": "13005", "Body": "<p>It's a reasonable point, there are at least two different ways that you could think to implement <code>erase</code>:</p>\n<ul>\n<li>destroy element 3, then copy-construct element 3 from 4, then 4 from 5, then destroy 5.</li>\n<li>copy-assign to 3 from 4, then to 4 from 5, then destroy 5.</li>\n</ul>\n<p>C++11 introduces a third way to do it:</p>\n<ul>\n<li>move-assign to 3 from 4, then to 4 from 5, then destroy 5.</li>\n</ul>\n<p>In fact for <code>vector::erase</code> the first way is forbidden by the C++03 standard in 23.2.4.3/4:</p>\n<blockquote>\n<p id=\"so_12982668_12982926_0\">Complexity: The destructor of T is called the number of times equal to\n  the number of the elements erased, but the assignment operator of T is\n  called the number of times equal to the number of elements in the\n  vector after the erased elements.</p>\n</blockquote>\n<p>Although this text is designed primarily to indicate the runtime complexity of the operation, you see that it mandates the second implementation. C++11 says the same thing with \"move assignment\" in place of \"assignment\".</p>\n<p>There's also a more fundamental problem with the first way, which is that in general (although not for <code>int</code> and hence not for <code>MyClass</code> either), copying can fail. If <code>erase</code> destroyed the third element of the vector, and then the copy from the 4th element failed then the vector would be in a rather dangerous state -- the third element isn't a proper object any more. So the restriction in the standard does rather more than just define the runtime, it prevents this bad failure case.</p>\n", "LastActivityDate": "2012-10-19T21:55:07.783"}});