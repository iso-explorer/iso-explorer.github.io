post_cb({"bq_ids": {"n4140": {"so_7455982_11144575_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 717}, "so_7455982_7456166_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 6348}, "so_7455982_7456166_3": {"length": 16, "quality": 1.0, "section_id": 6352}, "so_7455982_7456166_2": {"length": 15, "quality": 1.0, "section_id": 6351}}, "n3337": {"so_7455982_11144575_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 706}, "so_7455982_7456166_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 6105}, "so_7455982_7456166_3": {"length": 16, "quality": 1.0, "section_id": 6109}, "so_7455982_7456166_2": {"length": 15, "quality": 1.0, "section_id": 6108}}, "n4659": {"so_7455982_11144575_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 748}, "so_7455982_7456166_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 7857}, "so_7455982_7456166_3": {"length": 16, "quality": 1.0, "section_id": 7861}, "so_7455982_7456166_2": {"length": 15, "quality": 1.0, "section_id": 7860}}}, "7456166": {"Id": "7456166", "PostTypeId": "2", "Body": "<p>There is a specific mention in the C++0x FDIS (n3290) for this.</p>\n<blockquote>\n<p id=\"so_7455982_7456166_0\"><strong>\u00a7 17.6.5.9 Data race avoidance</strong></p>\n</blockquote>\n<p>The whole paragraph is of interest but more particularly:</p>\n<blockquote>\n<p id=\"so_7455982_7456166_1\"><em>3/</em> A C++ standard library function shall not directly or indirectly modify objects (1.10) accessible by threads other than the current thread unless the objects are accessed directly or indirectly via the function\u2019s non-const arguments, including this.</p>\n</blockquote>\n<p>means that you may call <code>cbegin</code> and <code>cend</code> on <code>std::vector&lt;T&gt;</code> safely. As well as calling <code>operator==</code> or <code>operator&lt;</code> on <code>std::string</code>.</p>\n<blockquote>\n<p id=\"so_7455982_7456166_2\"><em>6/</em> Operations on iterators obtained by calling a standard library container or string member function may access the underlying container, but shall not modify it.</p>\n</blockquote>\n<p>means that merely iterating over a container should not modify the said container in any way.</p>\n<p>Despite <em>3/</em> though, there seems to be room for global objects though, as iterators modifying some kind of shared register object in which they would associate themselves with the container (STL debug features). I don't make sense of:</p>\n<blockquote>\n<p id=\"so_7455982_7456166_3\"><em>7/</em> Implementations may share their own internal objects between threads if the objects are not visible to users and are protected against data races.</p>\n</blockquote>\n<p>otherwise.</p>\n<p>Anyway, the Standard guarantees that iterating over the <code>vector</code> will be safe... but makes no guarantees when it comes to actually reading the objects (those are your own). In this case, this is covered because <code>std::string</code> is covered above.</p>\n<p><strong>EDIT:</strong> As David Hammen justly noted, this Standard is not yet fully implemented. Many compilers already provided the guarantees above, even though the previous Standard never spoke about threads. MSVC, gcc, clang, icc, comeau, etc... All big names should already provide this guarantee, as can be seen from Als' answer.</p>\n", "LastEditorUserId": "147192", "LastActivityDate": "2011-09-17T18:46:19.580", "Score": "8", "CreationDate": "2011-09-17T16:21:06.020", "ParentId": "7455982", "CommentCount": "2", "LastEditDate": "2011-09-17T18:46:19.580", "OwnerUserId": "147192"}, "7455982": {"ViewCount": "13661", "Body": "<p>I am working on a application where huge number of threads are expected to iterate over set of string values and try to match it's own data with the data available in the list.</p>\n<p>I am looking for following use case:</p>\n<ol>\n<li>Vector is initialized with few elements of type std::string. (Lets say object name is strList). strList will get initialized at the time of application startup.</li>\n<li>All threads will iterate over strList to see if it's value matches with atleast one element of strList.</li>\n<li>No thread will ever try to modify strList and it will be strictly used as readonly object.</li>\n</ol>\n<p>So could you please tell me if concurrent reads are thread-safe on vector object. I am using RHEL 6 and gcc version is 4.5.x</p>\n", "AcceptedAnswerId": "7456012", "Title": "Is stl vector concurrent read thread-safe?", "CreationDate": "2011-09-17T15:50:52.950", "Id": "7455982", "CommentCount": "1", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2014-12-26T22:01:31.503", "LastEditorUserId": "2229099", "LastActivityDate": "2016-11-09T13:36:50.630", "Score": "18", "OwnerUserId": "512656", "Tags": "<c++><concurrency><stl><thread-safety><language-lawyer>", "AnswerCount": "3"}, "11144575": {"Id": "11144575", "PostTypeId": "2", "Body": "<p>In addition to the generic rules about data race avoidance, in [container.requirements.dataraces] the standard says</p>\n<blockquote>\n<p id=\"so_7455982_11144575_0\">-1- For purposes of avoiding data races (17.6.5.9), implementations shall consider the following functions to be <code>const</code>: <code>begin</code>, <code>end</code>, <code>rbegin</code>, <code>rend</code>, <code>front</code>, <code>back</code>, <code>data</code>, <code>find</code>, <code>lower_bound</code>, <code>upper_bound</code>, <code>equal_range</code>, <code>at</code> and, except in associative or unordered associative containers, <code>operator[]</code>.</p>\n</blockquote>\n<p>So even if you call the non-const <code>begin()</code>/<code>end()</code> etc. as long as you don't actually modify anything it's safe.  </p>\n", "LastActivityDate": "2012-06-21T18:33:49.870", "Score": "2", "CreationDate": "2012-06-21T18:33:49.870", "ParentId": "7455982", "CommentCount": "0", "OwnerUserId": "981959"}, "7456012": {"Id": "7456012", "PostTypeId": "2", "Body": "<p><strong>YES</strong> for the scenario you mention, it is perfectly Thread Safe.</p>\n<hr>\n<p>Actually, STL is not a correct way of referring it.<br>\nIt is the <strong><a href=\"https://stackoverflow.com/questions/5205491/whats-this-stl-vs-c-standard-library-fight-all-about/\">C++ Standard Library</a></strong>.</br></p>\n<p>The C++03 Standard does not talk about concurrency at all, So the concurrency aspect is left out as an implementation detail for compilers. So the documentation that comes with your compiler is where one should look to for answers related to concurrency. </p>\n<p>Most of the STL implementations are <strong>not</strong> thread safe as such.<br>\nBut for concurrent reads of same object from multiple threads most implementations of STL are indeed thread safe.  </br></p>\n<p><strong>References:</strong></p>\n<p><strong><a href=\"http://msdn.microsoft.com/en-us/library/c9ceah3b.aspx\" rel=\"nofollow noreferrer\">MSDN</a></strong> says:   </p>\n<blockquote>\n<p id=\"so_7455982_7456012_0\">A single object is thread safe for reading from multiple threads. For example, given an object A, it is safe to read A from thread 1 and from thread 2 simultaneously.</p>\n</blockquote>\n<p><strong>The Dinkumware STL-Documentation</strong> says:  </p>\n<blockquote>\n<p id=\"so_7455982_7456012_1\">Multiple threads can safely read the same container object. (There are nunprotected mutable subobjects within a container object.)</p>\n</blockquote>\n<p><strong><a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/manual/using_concurrency.html\" rel=\"nofollow noreferrer\">GCC Documentation</a></strong> says:  </p>\n<p>We currently use the <strong><a href=\"http://www.sgi.com/tech/stl/thread_safety.html\" rel=\"nofollow noreferrer\">SGI STL</a></strong> definition of thread safety, which states:  </p>\n<blockquote>\n<p id=\"so_7455982_7456012_2\">The SGI implementation of STL is thread-safe only in the sense that simultaneous accesses to distinct containers are safe, and simultaneous read accesses to to shared containers are safe. <strong>If multiple threads access a single container, and at least one thread may potentially write, then the user is responsible for ensuring mutual exclusion between the threads during the container accesses.</strong></p>\n</blockquote>\n<p>So from the above, Yes it is thread safe in GCC to have concurrent reads of same object from multiple threads.</p>\n<p>Note: GCC's Standard Library is a derivative of SGI's STL code.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2011-09-17T17:09:38.277", "Score": "34", "CreationDate": "2011-09-17T15:54:49.923", "ParentId": "7455982", "CommentCount": "2", "LastEditDate": "2017-05-23T12:25:06.277", "OwnerUserId": "452307"}});