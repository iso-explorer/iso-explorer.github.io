post_cb({"bq_ids": {"n4140": {"so_29759441_29759556_3": {"length": 12, "quality": 1.0, "section_id": 474}, "so_29759441_29759556_0": {"length": 4, "quality": 1.0, "section_id": 4706}, "so_29759441_29759556_5": {"length": 8, "quality": 0.8888888888888888, "section_id": 3274}, "so_29759441_29759556_2": {"length": 11, "quality": 1.0, "section_id": 461}, "so_29759441_29759556_1": {"length": 4, "quality": 1.0, "section_id": 4706}}, "n3337": {"so_29759441_29759556_0": {"length": 4, "quality": 1.0, "section_id": 4515}, "so_29759441_29759556_5": {"length": 8, "quality": 0.8888888888888888, "section_id": 3145}, "so_29759441_29759556_1": {"length": 4, "quality": 1.0, "section_id": 4515}}, "n4659": {"so_29759441_29759556_0": {"length": 4, "quality": 1.0, "section_id": 6103}, "so_29759441_29759556_5": {"length": 8, "quality": 0.8888888888888888, "section_id": 4032}, "so_29759441_29759556_1": {"length": 4, "quality": 1.0, "section_id": 6103}}}, "29759556": {"Id": "29759556", "PostTypeId": "2", "Body": "<p><strong>Update</strong>: The proposed resolution of <a href=\"http://wg21.link/CWG1734\" rel=\"nofollow\">CWG 1734</a>, currently in \"ready\" status, would modify [class]/p6 to read:</p>\n<blockquote>\n<p id=\"so_29759441_29759556_0\">A trivially copyable class is a class:</p>\n<ul>\n<li>where each copy constructor, move constructor, copy assignment operator, and move assignment operator (12.8 [class.copy], 13.5.3\n  [over.ass]) is either deleted or trivial,</li>\n<li>that has at least one non-deleted copy constructor, move constructor, copy assignment operator, or move assignment operator,\n  and</li>\n<li>that has a trivial, non-deleted destructor (12.4 [class.dtor]).</li>\n</ul>\n</blockquote>\n<p>This renders classes like</p>\n<pre><code>struct B {\n    B() = default;\n    B(const B&amp;) = delete;\n    B&amp; operator=(const B&amp;) = delete;\n};\n</code></pre>\n<p>no longer trivially copyable. (Classes of this sort include synchronization primitives like <code>std::atomic&lt;T&gt;</code> and <code>std::mutex</code>.)</p>\n<p>However, the <code>A</code> in the OP has a implicitly declared, non-deleted copy assignment operator that is trivial, so it remains trivially copyable.</p>\n<p>The original answer for the pre-CWG1734 situation is preserved below for reference.</p>\n<hr>\n<p>Yes, somewhat counterintuitively, it is trivially copyable. [class]/p6:</p>\n<blockquote>\n<p id=\"so_29759441_29759556_1\">A trivially copyable class is a class that:</p>\n<ul>\n<li>has no non-trivial copy constructors (12.8),</li>\n<li>has no non-trivial move constructors (12.8),</li>\n<li>has no non-trivial copy assignment operators (13.5.3, 12.8),</li>\n<li>has no non-trivial move assignment operators (13.5.3, 12.8), and</li>\n<li>has a trivial destructor (12.4).</li>\n</ul>\n</blockquote>\n<p>[class.copy]/p12:</p>\n<blockquote>\n<p id=\"so_29759441_29759556_2\">A copy/move constructor for class X is trivial if it is not\n  user-provided, its <em>parameter-type-list</em> is equivalent to the\n  <em>parameter-type-list</em> of an implicit declaration, and if</p>\n<ul>\n<li>class X has no virtual functions (10.3) and no virtual base classes (10.1), and</li>\n<li>class X has no non-static data members of volatile-qualified type, and</li>\n<li>the constructor selected to copy/move each direct base class subobject is trivial, and</li>\n<li>for each non-static data member of X that is of class type (or array thereof), the constructor selected to copy/move that member is\n  trivial;</li>\n</ul>\n</blockquote>\n<p>Similarly ([class.copy]/p25):</p>\n<blockquote>\n<p id=\"so_29759441_29759556_3\">A copy/move assignment operator for class X is trivial if it is not\n  user-provided, its <em>parameter-type-list</em> is equivalent to the\n  <em>parameter-type-list</em> of an implicit declaration, and if</p>\n<ul>\n<li>class X has no virtual functions (10.3) and no virtual base classes (10.1), and</li>\n<li>class X has no non-static data members of volatile-qualified type, and</li>\n<li>the assignment operator selected to copy/move each direct base class subobject is trivial, and</li>\n<li>for each non-static data member of X that is of class type (or array thereof), the assignment operator selected to copy/move that member is\n  trivial;</li>\n</ul>\n</blockquote>\n<p>[class.dtor]/p5:</p>\n<blockquote>\n<p id=\"so_29759441_29759556_4\">A destructor is trivial if it is not user-provided and if:</p>\n<ul>\n<li>the destructor is not <code>virtual</code>,</li>\n<li>all of the direct base classes of its class have trivial destructors, and</li>\n<li>for all of the non-static data members of its class that are of class type (or array thereof), each such class has a trivial\n  destructor.</li>\n</ul>\n</blockquote>\n<p>[dcl.fct.def.default]/p5:</p>\n<blockquote>\n<p id=\"so_29759441_29759556_5\">A function is <em>user-provided</em> if it is user-declared and not explicitly\n  defaulted or deleted on its first declaration.</p>\n</blockquote>\n<p>Indeed, this has been <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2424\" rel=\"nofollow\">a source of problems for the committee itself</a>, because under the current definition <code>atomic&lt;T&gt;</code> (along with mutexes and condition variables) would be trivially copyable. (And obviously, allowing someone to <code>memcpy</code> over an <code>atomic</code> or a <code>mutex</code> without invoking UB would be ... let's just say seriously problematic.) See also <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4460.html\" rel=\"nofollow\">N4460</a>.</p>\n</hr>", "LastEditorUserId": "2756719", "LastActivityDate": "2015-12-30T14:33:39.597", "Score": "21", "CreationDate": "2015-04-20T22:29:06.873", "ParentId": "29759441", "CommentCount": "5", "LastEditDate": "2015-12-30T14:33:39.597", "OwnerUserId": "2756719"}, "29759441": {"ViewCount": "984", "Body": "<p>Is this class:</p>\n<pre><code>class A {\n  public:\n    A() = default;\n    A(const A&amp;) = delete;\n};\n</code></pre>\n<p>trivially copyable? (At least clang seems to think so (<a href=\"http://coliru.stacked-crooked.com/a/3bf899de8625279d\" rel=\"nofollow noreferrer\">live</a>)) </p>\n<p>In particular, would</p>\n<pre><code>A a,b;\nstd::memcpy(&amp;a, &amp;b, sizeof(A));\n</code></pre>\n<p>invoke undefined behavior?</p>\n<p>Context: <a href=\"https://stackoverflow.com/a/29759170/3002139\">This answer</a> [deleted because proven wrong] plus its comment tree.</p>\n", "AcceptedAnswerId": "29759556", "Title": "Is a class with deleted copy-constructor trivially copyable?", "CreationDate": "2015-04-20T22:19:03.427", "Id": "29759441", "CommentCount": "10", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:24:24.747", "LastEditorUserId": "-1", "LastActivityDate": "2015-12-30T14:33:39.597", "Score": "24", "OwnerUserId": "3002139", "Tags": "<c++><language-lawyer>", "AnswerCount": "1"}});