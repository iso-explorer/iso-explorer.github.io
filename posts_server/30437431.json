post_cb({"30437431": {"CommentCount": "1", "AcceptedAnswerId": "30437435", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2015-05-25T11:33:58.130", "LastActivityDate": "2017-09-13T22:19:39.907", "LastEditDate": "2016-01-19T16:08:56.947", "ViewCount": "218", "FavoriteCount": "1", "Title": "Is assert usable in constant expressions?", "Id": "30437431", "Score": "10", "Body": "<p>The <code>assert</code>-macro from <code>&lt;cassert&gt;</code> provides a concise way of ensuring that a condition is met. If the argument evaluates to <code>true</code>, it shall not have any further effects. However, can its invocation also be used inside a constant expression in that case?</p>\n", "Tags": "<c++><language-lawyer><c++14><assert><constant-expression>", "OwnerUserId": "3647361", "AnswerCount": "1"}, "30437435": {"ParentId": "30437431", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>This was dealt with by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2234\" rel=\"nofollow noreferrer\">LWG 2234</a>, which was brought back to attention after relaxed constraints on <code>constexpr</code> functions had been introduced.</p>\n<blockquote>\n<p id=\"so_30437431_30437435_0\"><strong>Proposed resolution</strong>:</p>\n<p id=\"so_30437431_30437435_1\">This wording is relative to N3936.</p>\n<ol>\n<li><p id=\"so_30437431_30437435_2\">Introduce the following new definition to the existing list in 17.3\n  [definitions]:</p>\n<p id=\"so_30437431_30437435_3\"><strong>constant subexpression</strong> [defns.const.subexpr]</p>\n<p id=\"so_30437431_30437435_4\">an expression whose evaluation as subexpression of a  <em>conditional-expression CE</em> (5.16 [expr.cond]) would not prevent <em>CE</em> from being a core constant expression (5.20 [expr.const]).</p></li>\n<li><p id=\"so_30437431_30437435_5\">Insert a new paragraph following 19.3 [assertions] p1 as indicated:</p>\n<p id=\"so_30437431_30437435_6\">-?- An expression <code>assert(</code><em>E</em><code>)</code> is a constant subexpression ( [defns.const.subexpr]), if either</p>\n<ul>\n<li><p id=\"so_30437431_30437435_7\"><code>NDEBUG</code> is defined at the point where assert(E) appears, or</p></li>\n<li><p id=\"so_30437431_30437435_8\"><em>E</em> contextually converted to <code>bool</code> (4 [conv]), is a constant subexpression that evaluates to the value <code>true</code>.</p></li>\n</ul></li>\n</ol>\n</blockquote>\n<h3>Constant subexpressions</h3>\n<p>This resolution introduced the notion of a <em>constant subexpression</em> - essentially an expression that is not (necessarily) a constant expression in itself, but can be used inside one. Consider for example</p>\n<pre><code>constexpr void f() {\n    int i = 0;\n    ++i;\n}\n</code></pre>\n<p><code>++i</code> is not a constant expression as it modifies an object whose lifetime started outside that expression (\u00a75.20/(2.15)). However, the expression <code>f()</code> is in its entirety a  constant expression, because the previous point does not apply - <code>i</code>'s lifetime starts in <code>f</code>. Hence <code>++i</code> is a constant subexpression, as <code>++i</code> does not prevent <code>f()</code> from being a constant expression.  </p>\n<h3>And <code>assert</code>?</h3>\n<p>The second part of the resolution guarantees that <code>assert(</code><em>E</em><code>)</code> is a constant subexpression if either <code>NDEBUG</code> is defined or the argument is itself a constant subexpression and evaluates to <code>true</code>. This implies that a call to <code>assert</code> can also be a bog-standard constant expression.</p>\n<p>The following is well-formed:</p>\n<pre><code>constexpr int check(bool b) {\n    assert(b);\n    return 7;\n}\nconstexpr int k = check(true);\n</code></pre>\n<p><code>b</code> is a constant subexpression and evaluates to <code>true</code> in the call <code>check(true)</code>, hence <code>assert(b)</code> is a constant subexpression and therefore does not prevent <code>check(true)</code> from being one. </p>\n<p>Of course, the same pitfall as with <code>static_assert</code> in templates is possible. Given that <code>NDEBUG</code> isn't defined, this definition is ill-formed, no diagnostic required by \u00a77.1.5/5 :</p>\n<pre><code>constexpr void fail() {\n    assert(false);\n}\n</code></pre>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2017-09-13T22:19:39.907", "Id": "30437435", "Score": "7", "CreationDate": "2015-05-25T11:34:10.690", "LastActivityDate": "2017-09-13T22:19:39.907"}, "bq_ids": {"n4140": {"so_30437431_30437435_7": {"section_id": 177, "quality": 0.6666666666666666, "length": 4}, "so_30437431_30437435_8": {"section_id": 6072, "quality": 0.5555555555555556, "length": 5}}, "n3337": {"so_30437431_30437435_7": {"section_id": 171, "quality": 0.6666666666666666, "length": 4}, "so_30437431_30437435_8": {"section_id": 5840, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_30437431_30437435_6": {"section_id": 3309, "quality": 0.6666666666666666, "length": 4}, "so_30437431_30437435_7": {"section_id": 182, "quality": 0.6666666666666666, "length": 4}, "so_30437431_30437435_8": {"section_id": 3309, "quality": 0.7777777777777778, "length": 7}, "so_30437431_30437435_4": {"section_id": 7709, "quality": 0.7333333333333333, "length": 11}}}});