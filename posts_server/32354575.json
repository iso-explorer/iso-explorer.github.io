post_cb({"32355514": {"ParentId": "32354575", "CommentCount": "0", "Body": "<p>In addition typeid is mainly used with polymorphic types to detect polymorphic object types at runtime:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nclass B\n{\npublic:\n    virtual ~B() {}\n};\n\nclass D1 : public B\n{\n\n};\n\nclass D2 : public D1\n{\n\n};\n\nint main()\n{\n    B* b1 = new D2;\n    if (typeid(*b1) == typeid(B))\n    {\n        std::cout &lt;&lt; \"*b1 is B\\n\";\n    }\n    if (typeid(*b1) == typeid(D1))\n    {\n        std::cout &lt;&lt; \"*b1 is D1\\n\";\n    }\n    if (typeid(*b1) == typeid(D2))\n    {\n        std::cout &lt;&lt; \"*b1 is D2\\n\";\n    }\n}\n</code></pre>\n<p>This will print </p>\n<blockquote>\n<p id=\"so_32354575_32355514_0\">*b1 is D2</p>\n</blockquote>\n<p>So it is not intended for printing names of object types.</p>\n", "OwnerUserId": "2543838", "PostTypeId": "2", "Id": "32355514", "Score": "0", "CreationDate": "2015-09-02T14:11:16.113", "LastActivityDate": "2015-09-02T14:11:16.113"}, "32355012": {"ParentId": "32354575", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>To expand on Jonathan Wakely's answer, the typical use of <code>typeid</code> is</p>\n<pre><code>if ( typeid(variable1) == typeid(variable2) )\n     // same type\n</code></pre>\n<p>but also</p>\n<pre><code>if ( typeid(variable1).name() == typeid(variable2).name() )\n    // same type\n</code></pre>\n<p>as you can see there is no need to know the exact implementation-defined name. Since you don't really need that, the standard gives the implementation freedom to implement it in a more efficient way, which is reasonably good.</p>\n<p>For example, compare\n<code>_ZStplIcSt11char_traitsIcESaIcEESbIT_T0_T1_ERKS6_S8_</code>\nand <code>std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; std::operator+&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;(std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;)\n</code>: definitely less verbose and efficient, to compare and to store.</p>\n", "OwnerUserId": "2692339", "LastEditorUserId": "2692339", "LastEditDate": "2015-09-02T13:55:26.767", "Id": "32355012", "Score": "0", "CreationDate": "2015-09-02T13:48:18.930", "LastActivityDate": "2015-09-02T13:55:26.767"}, "32354575": {"CommentCount": "1", "AcceptedAnswerId": "32354652", "PostTypeId": "1", "LastEditorUserId": "3777958", "CreationDate": "2015-09-02T13:29:18.680", "LastActivityDate": "2015-09-02T14:11:16.113", "LastEditDate": "2015-09-02T13:34:05.507", "ViewCount": "123", "FavoriteCount": "1", "Title": "Why strings returned by name() function is implementation defined?", "Id": "32354575", "Score": "3", "Body": "<p>Consider following example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\nint main()\n{\n    int a=9;\n    std::cout &lt;&lt; typeid(a).name() &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Output on g++ 4.8.1 : i</p>\n<p>Output on MSVS 2010: int</p>\n<p>Why output is compiler depedent? What is the reason behind this? Why it is left as implementation defined? Why not same output on all compilers? Does C++ standard says it explicitly?</p>\n", "Tags": "<c++><rtti><typeid>", "OwnerUserId": "3777958", "AnswerCount": "5"}, "32354724": {"ParentId": "32354575", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, C++ standard says it explicitly:</p>\n<p>18.7.1$9,10 Class type_info [type.info]</p>\n<pre><code>const char* name() const noexcept; \n</code></pre>\n<blockquote>\n<p id=\"so_32354575_32354724_0\">9 Returns: An\n  implementation-defined ntbs.<br>\n  10 Remarks: The message may be a\n  null-terminated multibyte string (17.5.2.1.4.2), suitable for\n  conversion and display as a wstring (21.3, 22.4.1.4)</br></p>\n</blockquote>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2015-09-02T13:48:07.137", "Id": "32354724", "Score": "2", "CreationDate": "2015-09-02T13:36:35.143", "LastActivityDate": "2015-09-02T13:48:07.137"}, "32354644": {"ParentId": "32354575", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The C++ standard says:</p>\n<blockquote>\n<p id=\"so_32354575_32354644_0\">The class type_info describes type information generated by the\n  implementation. Objects of this class effectively store a pointer to a\n  name for the type, and an encoded value suitable for comparing two\n  types for equality or collating order. The names, encoding rule, and\n  collating sequence for types are all unspecified and may differ\n  between programs.</p>\n</blockquote>\n<p>g++ is returning you the <a href=\"https://en.wikipedia.org/wiki/Name_mangling\" rel=\"nofollow noreferrer\">decorated name</a> which you can demangle easily.</p>\n<p>Also refer: <a href=\"https://stackoverflow.com/questions/81870/print-variable-type-in-c\">Print variable type in C++</a></p>\n", "OwnerUserId": "1501794", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:08:41.390", "Id": "32354644", "Score": "1", "CreationDate": "2015-09-02T13:32:46.960", "LastActivityDate": "2015-09-02T13:32:46.960"}, "bq_ids": {"n4140": {"so_32354575_32354644_0": {"section_id": 6885, "quality": 0.9459459459459459, "length": 35}, "so_32354575_32354724_0": {"section_id": 6894, "quality": 0.5294117647058824, "length": 9}}, "n3337": {"so_32354575_32354644_0": {"section_id": 6631, "quality": 0.9459459459459459, "length": 35}, "so_32354575_32354724_0": {"section_id": 6640, "quality": 0.5294117647058824, "length": 9}}, "n4659": {"so_32354575_32354644_0": {"section_id": 8385, "quality": 0.9459459459459459, "length": 35}, "so_32354575_32354724_0": {"section_id": 5305, "quality": 0.5294117647058824, "length": 9}}}, "32354652": {"ParentId": "32354575", "CommentCount": "0", "Body": "<p>Because compilers represent types differently and don't use the same internals.</p>\n<p>The G++ string is the <a href=\"https://en.wikipedia.org/wiki/Name_mangling\">mangled</a> type name, returning that (rather than demangling it) is less work and more efficient. Requiring compilers to demangle those strings would add more work. The standard leaves it up to implementors to decide if they want to do that.</p>\n<p>If the standard dictated it then it would also have to specify all sorts of things, like whether to say <code>signed long</code> or just <code>long</code> and how to represent complex template instantiations that depend on other types and constants. The benefits of standardising those strings would be very small, but a large amount of work.</p>\n", "OwnerUserId": "981959", "PostTypeId": "2", "Id": "32354652", "Score": "6", "CreationDate": "2015-09-02T13:33:10.920", "LastActivityDate": "2015-09-02T13:33:10.920"}});