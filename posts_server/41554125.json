post_cb({"41554125": {"CommentCount": "10", "AcceptedAnswerId": "41556825", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2017-01-09T18:04:29.033", "LastActivityDate": "2017-01-09T21:19:00.637", "LastEditDate": "2017-05-23T10:30:43.187", "ViewCount": "106", "FavoriteCount": "1", "Title": "How standard C++ input output streams have to handle intXX_t types?", "Id": "41554125", "Score": "3", "Body": "<p>According to answers to this questions <a href=\"https://stackoverflow.com/questions/41552514/is-overloading-on-all-of-the-fundamental-integer-types-is-sufficient-to-capture\">Is overloading on all of the fundamental integer types is sufficient to capture all integers?</a> overloading of all fundamental types may not be able to handle types like <code>int8_t</code> <code>int64_t</code> etc. On another side according to documentation <a href=\"http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt\" rel=\"nofollow noreferrer\">std::ostream formatted output</a> and <a href=\"http://en.cppreference.com/w/cpp/io/basic_istream/operator_gtgt\" rel=\"nofollow noreferrer\">std::istream formatted input</a> is implemented exactly by overloading all fundamental types. So on platform where <code>int8_t</code> and others could not be handled by such overloading how C++ streams would have to handle them? Would it fail to compile? Would standard library implementors have to provide additional undocumented methods? Something else?</p>\n", "Tags": "<c++><c++11><language-lawyer>", "OwnerUserId": "432358", "AnswerCount": "2"}, "41556825": {"ParentId": "41554125", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2017-01-09T20:59:19.043", "Score": "4", "LastEditorUserId": "1505939", "LastEditDate": "2017-01-09T21:19:00.637", "Id": "41556825", "OwnerUserId": "1505939", "Body": "<p>For integer types, [istream] defines:</p>\n<pre><code>basic_istream&lt;charT,traits&gt;&amp; operator&gt;&gt;(bool&amp; n);\nbasic_istream&lt;charT,traits&gt;&amp; operator&gt;&gt;(short&amp; n);\nbasic_istream&lt;charT,traits&gt;&amp; operator&gt;&gt;(unsigned short&amp; n);\nbasic_istream&lt;charT,traits&gt;&amp; operator&gt;&gt;(int&amp; n);\nbasic_istream&lt;charT,traits&gt;&amp; operator&gt;&gt;(unsigned int&amp; n);\nbasic_istream&lt;charT,traits&gt;&amp; operator&gt;&gt;(long&amp; n);\nbasic_istream&lt;charT,traits&gt;&amp; operator&gt;&gt;(unsigned long&amp; n);\nbasic_istream&lt;charT,traits&gt;&amp; operator&gt;&gt;(long long&amp; n);\nbasic_istream&lt;charT,traits&gt;&amp; operator&gt;&gt;(unsigned long long&amp; n);\n</code></pre>\n<p>Any code of the form <code>is &gt;&gt; x</code> may fail to compile if <code>x</code> is an integer type that's not in that list. </p>\n<p>As a quality of implementation issue, an implementation which offers extended integer types could add <code>operator&gt;&gt;</code> overloads for those types. This is permitted by [member.functions]/2 (as noted by hvd in comments), talking about classes in the standard library:</p>\n<blockquote>\n<p id=\"so_41554125_41556825_0\">An implementation may declare additional non-virtual member function signatures within a class:</p>\n<p id=\"so_41554125_41556825_1\">[...]</p>\n<ul>\n<li>by adding a member function signature for a member function name.</li>\n</ul>\n<p id=\"so_41554125_41556825_2\">A call to a member function signature described in the C ++ standard library behaves as if the implementation declares no additional member function signatures. </p>\n</blockquote>\n<p>This is a stronger guarantee than the general rule that implementations may add extensions that don't break conforming programs.  The behaviour of conforming programs using SFINAE might be affected by the presence of the extra overloads.</p>\n<hr>\n<p>For output, integer types not in the list will be implicitly convertible to another integer type which is in the list. </p>\n</hr>", "LastActivityDate": "2017-01-09T21:19:00.637"}, "41556538": {"ParentId": "41554125", "PostTypeId": "2", "CommentCount": "16", "CreationDate": "2017-01-09T20:38:46.280", "Score": "1", "LastEditorUserId": "734069", "LastEditDate": "2017-01-09T21:14:33.080", "Id": "41556538", "OwnerUserId": "734069", "Body": "<blockquote>\n<p id=\"so_41554125_41556538_0\">So on platform where <code>int8_t</code> and others could not be handled by such overloading how C++ streams would have to handle them?</p>\n</blockquote>\n<p>As far as integer insertion is concerned (operator&lt;&lt;), it would handle them in accord with standard C++ overload resolution. Extended integer types are <em>still</em> integer types and follow the rules of implicit conversion for the purpose of overload resolution.</p>\n<p>For example, <code>int8_t</code> can be upconverted to any signed integer type large enough to hold it. So if <code>int8_t</code> is an extended integer type rather than an alias of the standard integer types, it can be upconverted to one of the standard ones, in accord with overload resolution rules.</p>\n<p>For integer extraction (<code>operator&gt;&gt;</code>), this requires a non-<code>const</code> reference to a live integer, so conversion is not possible. Therefore, if you do not provide one of the explicit types that <code>operator&gt;&gt;</code> is overloaded for, your code should fail to compile.</p>\n<p>The best you might get is if an implementation adds overloads specifically for those types, but you can't rely on that.</p>\n<p>It should be noted that C++17's new <code>to_chars</code> and <code>from_chars</code> are explicitly stated by the standard to have overloads for <em>all</em> signed&amp;unsigned integer types (and <code>char</code>). So that includes extended integer types.</p>\n<blockquote>\n<p id=\"so_41554125_41556538_1\">Would it fail to compile?</p>\n</blockquote>\n<p>For insertion, that depends on the types used. <code>int8_t</code> is safe because there are standard integer types that are larger than it. It may have different behavior than you expect, but it will work.</p>\n<p>By contrast, there is no guarantee that <code>int_least64_t</code> or <code>intmax_t</code> is not larger than <code>long long</code>. And implicit conversion can't go from larger to smaller. In those cases, you get a compile error.</p>\n<p>For extraction, you get compilation failures if you don't match the types.</p>\n<blockquote>\n<p id=\"so_41554125_41556538_2\">Would standard library implementors have to provide additional undocumented methods?</p>\n</blockquote>\n<p>No. They are permitted to do so, but that's not something you can rely on.</p>\n<hr>\n<p><code>int8_t</code> is a special case because of the treatment of how it can be implemented.</p>\n<p><code>char</code> serves double duty as a byte-sized type and a character type. Because it's a character type, iostream operations will treat uses of <code>char</code> differently from how it treats integer types. With integers, it will parse/generate integer strings. With a character, it assumes you mean to read a character.</p>\n<p>A valid implementation of <code>int8_t</code> could be as an alias of <code>signed char</code> or just <code>char</code> if it is signed. As such, use of it with stream operations will <em><a href=\"http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt2\" rel=\"nofollow noreferrer\">treat it as a character</a></em>.</p>\n<p>A valid implementation of <code>int8_t</code> could be as an extended integer type, a type which is <em>distinct</em> from <code>char</code>. As such, the value will be upconverted to a larger integer type that matches one of the standard ones, in accord with overload resolution rules. And therefore, it will <a href=\"http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt\" rel=\"nofollow noreferrer\">call one of these</a>.</p>\n</hr>", "LastActivityDate": "2017-01-09T21:14:33.080"}, "bq_ids": {"n4140": {"so_41554125_41556825_0": {"section_id": 6341, "quality": 1.0, "length": 10}, "so_41554125_41556825_2": {"section_id": 6342, "quality": 1.0, "length": 13}}, "n3337": {"so_41554125_41556825_0": {"section_id": 6098, "quality": 1.0, "length": 10}, "so_41554125_41556825_2": {"section_id": 6099, "quality": 1.0, "length": 13}}, "n4659": {"so_41554125_41556825_0": {"section_id": 49, "quality": 0.6, "length": 6}, "so_41554125_41556825_2": {"section_id": 7851, "quality": 0.6923076923076923, "length": 9}}}});