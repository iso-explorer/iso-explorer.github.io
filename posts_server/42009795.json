post_cb({"bq_ids": {"n4140": {"so_42009795_42010117_0": {"length": 10, "quality": 1.0, "section_id": 7020}}, "n3337": {"so_42009795_42010117_0": {"length": 10, "quality": 1.0, "section_id": 6766}}, "n4659": {"so_42009795_42010117_0": {"length": 10, "quality": 1.0, "section_id": 8517}}}, "42010117": {"Id": "42010117", "PostTypeId": "2", "Body": "<p>In [class.abstract], pretty straightforwardly:</p>\n<blockquote>\n<p id=\"so_42009795_42010117_0\"><strong>An abstract class shall not be used</strong> as a parameter type, <strong>as a function return type</strong>, or as the type of an explicit conversion.</p>\n</blockquote>\n<p>Any code that tries to do such a thing is ill-formed. </p>\n", "LastActivityDate": "2017-02-02T18:52:27.207", "CommentCount": "10", "CreationDate": "2017-02-02T18:52:27.207", "ParentId": "42009795", "Score": "10", "OwnerUserId": "2069064"}, "42009795": {"ViewCount": "228", "Body": "<p>I was wondering of the following was legal according to the C++ standard:</p>\n<pre><code>struct Abstract { virtual ~Abstract() = 0; };\n\nauto get_type() -&gt; Abstract;\n\n// I use `get_type` only to extract the return type.\nusing MyType = decltype(get_type());\n</code></pre>\n<p>GCC 6.3 accept it, but Clang 3.9 reject it.</p>\n<p>However, if I do this instead:</p>\n<pre><code>auto get_type() -&gt; struct Abstract;\n\nstruct Abstract { virtual ~Abstract() = 0; };\n\nusing MyType = decltype(get_type());\n</code></pre>\n<p>Now both compiler accept it. Are they both wrong in this case?</p>\n", "AcceptedAnswerId": "42010117", "Title": "Is having a function header that return an abstract type legal?", "CreationDate": "2017-02-02T18:34:06.860", "Id": "42009795", "CommentCount": "8", "PostTypeId": "1", "LastActivityDate": "2017-02-02T18:52:27.207", "Score": "8", "OwnerUserId": "2104697", "Tags": "<c++><c++11><abstract-class><language-lawyer>", "AnswerCount": "1"}});