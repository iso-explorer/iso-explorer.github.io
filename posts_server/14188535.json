post_cb({"14309329": {"ParentId": "14188535", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2013-01-13T23:10:24.143", "Score": "4", "LastEditorUserId": "34509", "LastEditDate": "2013-01-16T22:28:16.470", "Id": "14309329", "OwnerUserId": "34509", "Body": "<p>The below was only sufficient for making the class template definition itself valid. However the same rules that made the lookup not find the data member in the class template (which necessiated the introduction of the empty dependent base class or the dependent function call) will also make the instantiation of the class template not find the data member, and thereby will trigger a compiler error.</p>\n<p>We told the compiler \"hold on, perhaps you will find the data member at instantiation time\", but I did not think about what will happen when actually instantiating. We will now make it so that the name is still dependent even after instantiation of the class happened. The resolution will have to wait until the call to <code>operator()</code>. </p>\n<pre><code>// keep this little util somewhere :)\ntemplate&lt;typename T&gt;\nstruct self { \n  template&lt;typename U&gt; U &amp;operator()(U &amp;t) { return t; } \n};\n\ntemplate &lt;class T&gt;\nclass Synchronised {\n    public:\n// ...\n        auto operator()(F f) const -&gt; decltype(f(self&lt;F&gt;()(*this).t_)) {\n// ...\n};\n</code></pre>\n<p>The use of a class template for <code>self</code> instead of a function template will also prevent argument dependent lookup from happening, preventing that the author of <code>F</code> also writes a function called <code>self</code> that matches the argument <code>*this</code> (this could have been a potential problem with the partial solution below, too).</p>\n<hr>\n<p>You have several other options, beside reordering </p>\n<ol>\n<li><p>Making the expression on the left side of <code>.</code> dependent, but not just the enclosing class (because it will be special-cased)</p>\n<pre><code>// keep this little util somewhere :)\ntemplate &lt;class T&gt; T &amp;self(T &amp;t) { return t; }\n\ntemplate &lt;class T&gt;\nclass Synchronised {\n    public:\n// ...\n        auto operator()(F f) const -&gt; decltype(f(self(*this).t_)) {\n// ...\n};\n</code></pre></li>\n<li><p>Introduce a dependent base class to work-around the special casing of the enclosing class</p>\n<pre><code>// Keep this little util somewhere\ntemplate&lt;typename T&gt; struct Dependent { };\n\ntemplate &lt;class T&gt;\nclass Synchronised : Dependent&lt;T&gt; {\n    public:\n// ...\n        auto operator()(F f) const -&gt; decltype(f(this-&gt;t_)) {\n// ...\n};\n</code></pre></li>\n</ol>\n<p>The first is based on the Standard making <code>self(*this).t_</code> a member of an unknown specialization</p>\n<blockquote id=\"so_14188535_14309329_0\">\n<ul>\n<li>the type of the object expression is dependent and is not the current instantiation.</li>\n</ul>\n</blockquote>\n<p>The second is based on the Standard making <code>this-&gt;t_</code> a member of an unknown specialization</p>\n<blockquote id=\"so_14188535_14309329_1\">\n<ul>\n<li>the type of the object expression is the current instantiation, the current instantiation has at least one dependent base class, and name lookup of the id-expression does not find a member of the current instantiation or a non-dependent base class thereof; </li>\n</ul>\n</blockquote>\n<p>This in turn makes <code>x-&gt;t_</code> for both cases a dependent expression and hence the name will be looked up at instantiation time. The Standard says</p>\n<blockquote>\n<p id=\"so_14188535_14309329_2\">A class member access expression (5.2.5) is type-dependent if the expression refers to a member of the current instantiation and the type of the referenced member is dependent, or the class member access expression refers to a member of an unknown specialization. </p>\n</blockquote>\n</hr>", "LastActivityDate": "2013-01-16T22:28:16.470"}, "14188535": {"CommentCount": "3", "AcceptedAnswerId": "14309329", "PostTypeId": "1", "LastEditorUserId": "1445334", "CreationDate": "2013-01-07T01:03:57.280", "LastActivityDate": "2013-01-16T22:28:16.470", "LastEditDate": "2013-01-14T17:25:31.063", "ViewCount": "754", "FavoriteCount": "1", "Title": "Clang access modifier order and decltype", "Id": "14188535", "Score": "4", "Body": "<p>I have been looking at creating a synchroniser helper template class which is based on Herb Sutter's ideas of a wrapper class in this <a href=\"http://channel9.msdn.com/Shows/Going+Deep/C-and-Beyond-2012-Herb-Sutter-Concurrency-and-Parallelism\" rel=\"nofollow\">talk</a> This does not work in msvc as is (unless we remove the brace initialisation) but when brace initialisation is removed then it's fine. </p>\n<p>In clang/gcc (ubuntu 12.10, gcc4.7.2, clang (3.2) self built with libc++) it seems the private access modifier has to appear before the public: which seems a little strange. </p>\n<p>The error in gcc is \n<code>error: \u2018t_\u2019 was not declared in this scope</code> </p>\n<p>and clang is  </p>\n<pre><code>error: use of undeclared identifier 't_'\n  auto operator()(F f) const -&gt;decltype(f(t_))\n</code></pre>\n<p>It may be a template/declytpe issue that I am not aware of and wonder if anyone can help with this one. (all compiled with relevant c++11 flags)</p>\n<pre><code>template &lt;class T&gt;\nclass Synchronised {\n    public:\n        Synchronised(T t = T{}) : t_{t} {}\n        template &lt;typename F&gt;\n        auto operator()(F f) const -&gt; decltype(f(t_)) {\n            std::lock_guard&lt;std::mutex&gt; lock{mutex_};\n            return f(t_);\n        }\n        private: // place this before public: and this object compiles\n            mutable T t_;\n            mutable std::mutex mutex_;\n};\n</code></pre>\n<p>Edit: Adding Johannes's ideas and full class in case anyone wants a cut and paste. </p>\n<pre><code>#include &lt;future&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\ntemplate &lt;class T&gt; T &amp;self(T &amp;t) { return t;  }\ntemplate&lt;typename T&gt; struct Dependent {  };\n\ntemplate&lt;typename T&gt;\nclass Synchronised : Dependent&lt;T&gt;{\n public:\n  explicit Synchronised(T t = T()) : t_(t) {}\n  template&lt;typename Functor&gt;\n  auto operator()(Functor functor) const -&gt;decltype(functor(self(*this).t_)) {\n  //auto operator()(Functor functor) const -&gt;decltype(functor(this-&gt;t_)) {\n    std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n    return functor(t_);\n  }\n private:\n  mutable T t_;\n  mutable std::mutex mutex_;\n};\n\n\nint main() {\n\n    Synchronised&lt;std::string&gt; sync_string(\"Start\\n\");\n    std::vector&lt;std::future&lt;void&gt;&gt; futures;\n}\n</code></pre>\n", "Tags": "<c++><templates><c++11><order><dependent-name>", "OwnerUserId": "1445334", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_14188535_14309329_0": {"section_id": 195, "quality": 1.0, "length": 6}, "so_14188535_14309329_1": {"section_id": 195, "quality": 1.0, "length": 24}, "so_14188535_14309329_2": {"section_id": 204, "quality": 0.9565217391304348, "length": 22}}, "n3337": {"so_14188535_14309329_0": {"section_id": 189, "quality": 1.0, "length": 6}, "so_14188535_14309329_1": {"section_id": 189, "quality": 1.0, "length": 24}, "so_14188535_14309329_2": {"section_id": 198, "quality": 0.9565217391304348, "length": 22}}, "n4659": {"so_14188535_14309329_1": {"section_id": 201, "quality": 1.0, "length": 24}, "so_14188535_14309329_0": {"section_id": 201, "quality": 1.0, "length": 6}, "so_14188535_14309329_2": {"section_id": 210, "quality": 0.9565217391304348, "length": 22}}}});