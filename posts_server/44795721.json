post_cb({"bq_ids": {"n4140": {"so_44795721_44797625_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 587}, "so_44795721_44797625_1": {"length": 15, "quality": 0.5769230769230769, "section_id": 584}}, "n3337": {"so_44795721_44797625_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 577}, "so_44795721_44797625_1": {"length": 15, "quality": 0.5769230769230769, "section_id": 574}}, "n4659": {"so_44795721_44797625_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 610}, "so_44795721_44797625_1": {"length": 15, "quality": 0.5769230769230769, "section_id": 607}}}, "44795721": {"ViewCount": "77", "Body": "<p>The following code implements template class <code>Data</code> whose purpose is to compare its member object. The intent is that if the member object is of the same type, that object's <code>operator&lt;</code> is used for the comparison, and if the member objects are of different types, <code>std::string</code>'s <code>operator&lt;</code> is used on a stringification of the member objects.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n\ntemplate &lt;typename T&gt;\nclass Data\n{\npublic:\n  Data( const T&amp; t ) : m_data( t ) {}\n  template &lt;typename U&gt; bool operator&lt;( const Data&lt;U&gt;&amp; cu )\n  {\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n    return ( static_cast&lt;std::ostringstream&amp;&gt;(( std::ostringstream().flush() &lt;&lt; m_data )).str() &lt;\n             static_cast&lt;std::ostringstream&amp;&gt;(( std::ostringstream().flush() &lt;&lt; cu.m_data )).str() );\n  }\n\n#if 1 // Change this to \"#if 0\" and code doesn't work anymore.\n  bool operator&lt;( const Data&lt;T&gt;&amp; ct )\n  {\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n    return ( m_data &lt; ct.m_data );\n  }\n#endif\n\nprivate:\n  T m_data;\n  template&lt; typename U&gt; friend class Data;\n\nfriend bool operator&lt; &lt;T&gt; ( const Data&lt;T&gt;&amp;, const Data&lt;T&gt;&amp; );\n};\n\ntemplate&lt;typename T&gt;\nbool operator&lt;( const Data&lt;T&gt;&amp; a, const Data&lt;T&gt;&amp; b )\n{\n  std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n  return ( a.m_data &lt; b.m_data );\n}\n\nint main( int argc, char* argv[] )\n{\n  Data&lt;int&gt; a(10);\n  Data&lt;std::string&gt; b(\"2\");\n  Data&lt;int&gt; c(2);\n  std::cout &lt;&lt; \"10 &lt; \\\"2\\\"? \" &lt;&lt; std::boolalpha &lt;&lt; ( a &lt; b ) &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"10 &lt; 2? \" &lt;&lt; std::boolalpha &lt;&lt; ( a &lt; c ) &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>\n<p>I was experimenting with a member <code>operator&lt;()</code> versus a global-scoped <code>operator&lt;()</code>. The former is demonstrated in the <code>#if 1</code> block, and works as expected. When I try to force use of the latter by changing the <code>#if 1</code> to <code>#if 0</code>, code no longer behaves as desired: the global-scope <code>operator&lt;()</code> appears to not be invoked.</p>\n<p>Can someone please point out why the global-scoped <code>operator&lt;()</code> is not invoked/does not work, whereas the member <code>operator&lt;()</code> does?</p>\n", "AcceptedAnswerId": "44797625", "Title": "Template operator< not called", "CreationDate": "2017-06-28T07:04:39.207", "Id": "44795721", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-06-28T09:12:07.843", "Score": "0", "OwnerUserId": "5437543", "Tags": "<c++><templates><operator-overloading><template-specialization>", "AnswerCount": "1"}, "44797625": {"Id": "44797625", "PostTypeId": "2", "Body": "<p>What is happening here is what <a href=\"https://stackoverflow.com/questions/44795721/template-operator-not-called#comment76572468_44795721\">@n.m. said in the comments</a>.  It took me a while to track down the precise reason why this happens, although it was pretty simple in the end.  </p>\n<p>When you consider operator overloading, there is a list of viable functions that gets generated and then gets passed to the algorithm that determines which out of those will be called.  In particular for operator overloading the list of considered functions is this</p>\n<p><strong>16.3.1.2 Operators in expressions [over.match.oper/6]</strong></p>\n<blockquote>\n<p id=\"so_44795721_44797625_0\">The set of candidate functions for overload resolution is the union of the member candidates, the non-member candidates, and the built-in candidates.</p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution\" rel=\"nofollow noreferrer\">cppreference explains it in more detail</a></p>\n<blockquote>\n<p id=\"so_44795721_44797625_1\">For a unary operator @ whose argument has type T1 (after removing cv-qualifications), or binary operator @ whose left operand has type T1 and right operand of type T2 (after removing cv-qualifications), three sets of candidate functions are prepared:</p>\n<p id=\"so_44795721_44797625_2\">1) <strong>member candidates:</strong> </p>\n<p id=\"so_44795721_44797625_3\">2) <strong>non-member candidates:</strong> </p>\n<p id=\"so_44795721_44797625_4\">3) <strong>built-in candidates:</strong> </p>\n</blockquote>\n<p>And when overload resolution happens something special happens for member functions (emphasis mine)</p>\n<blockquote>\n<p id=\"so_44795721_44797625_5\">If any candidate function is a member function (static or non-static), but not a constructor, <strong>it is treated as if it has an extra parameter</strong> (implicit object parameter) <strong>which represents the object for which they are called</strong> and appears before the first of the actual parameters.</p>\n</blockquote>\n<p>So essentially the overloads you get for your case are </p>\n<pre><code>template &lt;typename U&gt; \nbool operator&lt;(EXACT_TYPE_PTR this, const Data&lt;U&gt;&amp; cu );\ntemplate&lt;typename T&gt;\nbool operator&lt;(const Data&lt;T&gt;&amp; a, const Data&lt;T&gt;&amp; b)\n</code></pre>\n<p>Where <code>EXACT_TYPE_PTR</code> is replaced by the type of whichever object you decide to call <code>operator&lt;</code> on.  Now you have two candidates, one a template and another one that accepts one template parameter and one template argument.  So naturally the one with the exact type is preferred, since it is an <strong>exact match</strong> </p>\n<hr>\n<p><strong>Note</strong>  You should probably make the member <code>operator&lt;()</code> function const, so that it can be more general and accept even const arguments.  As it stands in the current case, if you have a <code>const Data</code> instance, then the non-member overload will be called</p>\n</hr>", "LastEditorUserId": "5501675", "LastActivityDate": "2017-06-28T09:12:07.843", "Score": "2", "CreationDate": "2017-06-28T08:41:20.720", "ParentId": "44795721", "CommentCount": "3", "OwnerUserId": "5501675", "LastEditDate": "2017-06-28T09:12:07.843"}});