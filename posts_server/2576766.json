post_cb({"bq_ids": {"n4140": {"so_2576766_2576775_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 5012}}, "n3337": {"so_2576766_2576775_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 4813}}}, "2576766": {"ViewCount": "725", "Body": "<p>I read <a href=\"http://www.cplusplus.com/reference/std/memory/auto_ptr/operator=/\" rel=\"nofollow noreferrer\">here</a> about std::auto_ptr&lt;&gt;::operator=</p>\n<blockquote>\n<p id=\"so_2576766_2576766_0\">Notice however that the left-hand side\n  object is not automatically\n  deallocated when it already points to\n  some object. You can explicitly do\n  this by calling member function reset\n  before assigning it a new value.</p>\n</blockquote>\n<p>However, when I read the source code for header file <code>C:\\Program Files\\Microsoft Visual Studio 8\\VC\\ce\\include\\memory</code></p>\n<pre><code>template&lt;class _Other&gt;\n    auto_ptr&lt;_Ty&gt;&amp; operator=(auto_ptr&lt;_Other&gt;&amp; _Right) _THROW0()\n    { // assign compatible _Right (assume pointer)\n    reset(_Right.release());\n    return (*this);\n    }\n\nauto_ptr&lt;_Ty&gt;&amp; operator=(auto_ptr&lt;_Ty&gt;&amp; _Right) _THROW0()\n    { // assign compatible _Right (assume pointer)\n    reset(_Right.release());\n    return (*this);\n    }\n\nauto_ptr&lt;_Ty&gt;&amp; operator=(auto_ptr_ref&lt;_Ty&gt; _Right) _THROW0()\n    { // assign compatible _Right._Ref (assume pointer)\n    _Ty **_Pptr = (_Ty **)_Right._Ref;\n    _Ty *_Ptr = *_Pptr;\n    *_Pptr = 0; // release old\n    reset(_Ptr); // set new\n    return (*this);\n    }\n</code></pre>\n<p>What is the correct/standard behavior? How do other STL implementations behave? If the website cited above has wrong/outdated information, which website do you recommend as a reference?</p>\n", "AcceptedAnswerId": "2576775", "Title": "should std::auto_ptr<>::operator = reset / deallocate its existing pointee?", "CreationDate": "2010-04-05T03:19:35.057", "Id": "2576766", "CommentCount": "3", "LastEditDate": "2010-04-05T03:29:31.430", "PostTypeId": "1", "LastEditorUserId": "109747", "LastActivityDate": "2010-04-05T03:29:31.430", "Score": "3", "OwnerUserId": "109747", "Tags": "<c++><stl><visual-c++><smart-pointers><auto-ptr>", "AnswerCount": "1"}, "2576775": {"PostTypeId": "2", "Body": "<p>If the <code>auto_ptr</code> being assigned to already holds a pointer, that pointer must be deleted first.</p>\n<p>From the 2003 standard (\u00a720.4.5.1):</p>\n<pre><code>auto_ptr&amp; operator=(auto_ptr&amp; a) throw();\n</code></pre>\n<blockquote>\n<p id=\"so_2576766_2576775_0\">7 Requires: The expression <code>delete get()</code> is well formed.</p>\n<p id=\"so_2576766_2576775_1\">8 Effects: <code>reset(a.release())</code>.</p>\n<p id=\"so_2576766_2576775_2\">9 Returns: <code>*this</code>.</p>\n</blockquote>\n<p>So, assigning to an <code>auto_ptr</code> has the same effect as calling <code>reset</code> on it with the pointer released from the right hand side <code>auto_ptr</code>.</p>\n<p>The website you cite is wrong.</p>\n", "LastActivityDate": "2010-04-05T03:23:47.453", "Id": "2576775", "CommentCount": "3", "CreationDate": "2010-04-05T03:23:47.453", "ParentId": "2576766", "Score": "6", "OwnerUserId": "151292"}});