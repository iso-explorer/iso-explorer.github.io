post_cb({"5916268": {"ParentId": "5916239", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>You are passing the <code>foo</code> size by advancing to 20th position. Definitely it is not end of the vector. It should invoke <em>undefined behavior</em> on dereferencing, AFAIK.</p>\n<p>Edit 1: </p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n     std::vector&lt;int&gt; foo(10,10) ;\n     std::vector&lt;int&gt;::iterator iter = foo.begin() ;\n     std::advance(iter,20);\n\n     std::cout &lt;&lt; *iter &lt;&lt; \"\\n\" ;\n\n     return 0;\n}\n</code></pre>\n<p><strong>Output:</strong> 0</p>\n<p>If it is the vector's last element, then it should have given 10 on iterator dereferencing. So, it is UB.</p>\n<p><a href=\"http://ideone.com/QpeCM\" rel=\"nofollow\">IdeOne Results</a></p>\n", "OwnerUserId": "528724", "LastEditorUserId": "528724", "LastEditDate": "2011-05-06T20:08:14.070", "Id": "5916268", "Score": "3", "CreationDate": "2011-05-06T19:43:31.703", "LastActivityDate": "2011-05-06T20:08:14.070"}, "5916416": {"ParentId": "5916239", "CommentCount": "0", "Body": "<p>That is probably undefined behavior. The only thing the standard says is:</p>\n<p>Since only random access iterators provide + and - operators, the library provides two function templates advance and distance. These function templates use + and - for random access iterators (and are, therefore, constant time for them); for input, forward and bidirectional iterators they use ++ to provide linear time implementations. </p>\n<pre><code>template &lt;class InputIterator, class Distance&gt; \nvoid advance(InputIterator&amp; i, Distance n);\n</code></pre>\n<p>Requires: n shall be negative only for bidirectional and random access iterators. Effects: Increments (or decrements for negative n) iterator reference i by n.</p>\n", "OwnerUserId": "648078", "PostTypeId": "2", "Id": "5916416", "Score": "1", "CreationDate": "2011-05-06T19:59:24.170", "LastActivityDate": "2011-05-06T19:59:24.170"}, "5916426": {"ParentId": "5916239", "CommentCount": "1", "Body": "<p>According to the C++ Standard \u00a724.3.4 <code>std::advance(i, 20)</code> has the same effect as <code>for ( int n=0; n &lt; 20; ++n ) ++i;</code> for positive <code>n</code>. From the other side (\u00a724.1.3) if <code>i</code> is past-the-end, then <code>++i</code> operation is undefined. So the result of <code>std::advance(i, 20)</code> is undefined.</p>\n", "OwnerUserId": "123111", "PostTypeId": "2", "Id": "5916426", "Score": "7", "CreationDate": "2011-05-06T20:00:56.450", "LastActivityDate": "2011-05-06T20:00:56.450"}, "5916402": {"ParentId": "5916239", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From the SGI page for <a href=\"http://www.sgi.com/tech/stl/advance.html\" rel=\"nofollow noreferrer\">std::advance</a>:</p>\n<blockquote>\n<p id=\"so_5916239_5916402_0\">Every iterator between i and i+n\n  (inclusive) is nonsingular.</p>\n</blockquote>\n<p>Therefore i is not foo.end() and dereferencing will result in undefined behavior.</p>\n<p>Notes:</p>\n<ol>\n<li>See <a href=\"https://stackoverflow.com/questions/5441893/what-is-singular-and-non-singular-values-in-the-context-of-stl-iterators\">this question</a> for more details about what (non)singular means when referring to iterators.</li>\n<li>I know that the SGI page is not the de-facto standard but pretty much all STL implementations follow those guidelines.</li>\n</ol>\n", "OwnerUserId": "153861", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:29:02.410", "Id": "5916402", "Score": "1", "CreationDate": "2011-05-06T19:58:13.440", "LastActivityDate": "2011-05-06T19:58:13.440"}, "5916239": {"CommentCount": "0", "AcceptedAnswerId": "5916268", "ClosedDate": "2017-11-29T14:32:13.743", "CreationDate": "2011-05-06T19:41:25.537", "LastActivityDate": "2011-05-06T20:19:09.527", "PostTypeId": "1", "ViewCount": "6316", "FavoriteCount": "1", "Title": "std::advance behavior when advancing beyond end of container", "Id": "5916239", "Score": "19", "Body": "<p>What is the behavior of std::advance when you have say:</p>\n<pre><code>std::vector&lt;int&gt; foo(10,10);\nauto i = foo.begin();\nstd::advance(i, 20);\n</code></pre>\n<p>What is the value of <strong>i</strong>? Is it <strong>foo.end()</strong>?</p>\n", "Tags": "<c++><stl>", "OwnerUserId": "29049", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_5916239_5916501_0": {"section_id": 5593, "quality": 0.9523809523809523, "length": 20}}, "n3337": {"so_5916239_5916501_0": {"section_id": 5376, "quality": 0.9523809523809523, "length": 20}}, "n4659": {"so_5916239_5916501_0": {"section_id": 7037, "quality": 0.9523809523809523, "length": 20}}}, "5916501": {"ParentId": "5916239", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The standard defines <code>std::advance()</code> in terms of the types of iterator it's being used on (24.3.4 \"Iterator operations\"):</p>\n<blockquote>\n<p id=\"so_5916239_5916501_0\">These function templates use + and - for random access iterators (and are, therefore, constant time for them); for input, forward and bidirectional iterators they use ++ to provide linear time implementations.</p>\n</blockquote>\n<p>The requirements for these operations on various iterator types are also outlined in the standard (in Tables 72, 74, 75 and 76):</p>\n<ul>\n<li><p>For an input or forward iterator</p>\n<pre><code>++r precondition: r is dereferenceable\n</code></pre></li>\n<li><p>for a bidirectional iterator:</p>\n<pre><code>--r precondition: there exists s such that r == ++s\n</code></pre></li>\n<li><p>For random access iterators, the <code>+</code>, <code>+=</code>, <code>-</code>, and <code>-=</code> operations are defined in terms of the bidirectional &amp; forward iterator prefix <code>++</code> and <code>--</code> operations, so the same preconditions hold.</p></li>\n</ul>\n<p>So advancing an iterator beyond the 'past-the-end' value (as might be returned by the <code>end()</code> function on containers) or advancing before the first dereferenceable element of an iterator's valid range (as might be returned by <code>begin()</code> on a container) is undefined behavior since you're violating the preconditions of the <code>++</code> or <code>--</code> operation.</p>\n<p>Since it's undefined behavior you can't 'expect' anything in particular.  But you'll likely crash at some point (hopefully sooner rather than later, so you can fix the bug).</p>\n", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2011-05-06T20:19:09.527", "Id": "5916501", "Score": "29", "CreationDate": "2011-05-06T20:09:56.950", "LastActivityDate": "2011-05-06T20:19:09.527"}});