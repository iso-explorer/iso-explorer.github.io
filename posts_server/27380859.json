post_cb({"bq_ids": {"n4140": {"so_27380859_27380937_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 6110}}, "n3337": {"so_27380859_27380937_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 5876}}, "n4659": {"so_27380859_27380937_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 7607}}}, "27381015": {"Id": "27381015", "PostTypeId": "2", "Body": "<p>No, this will not work, as the destructor would permit calling <code>delete</code> on <code>NULL</code> pointers.</p>\n", "LastActivityDate": "2014-12-09T14:14:40.813", "Score": "0", "CreationDate": "2014-12-09T14:14:40.813", "ParentId": "27380859", "CommentCount": "0", "OwnerUserId": "3355476"}, "27380937": {"Id": "27380937", "PostTypeId": "2", "Body": "<p>Yes it will work provided that leaf nodes have left and right equal to nullptr.</p>\n<p>Acccording to the C++ Standard (5.3.5 Delete)</p>\n<blockquote>\n<p id=\"so_27380859_27380937_0\">6 If the value of the operand of the delete-expression <strong>is not a null\n  pointer value</strong>, the delete-expression <strong>will invoke the destructor</strong>\n  (if any) for the object or the elements of the array being deleted. In\n  the case of an array, the elements will be destroyed in order of\n  decreasing address (that is, in reverse order of the completion of\n  their constructor; see 12.6.2).</p>\n</blockquote>\n<p>So the destructor of a node will be called only in case when the node is not a null pointer value.</p>\n<p>If you want to check that the destructor is indeed working then simply insert an output statement in the body of the destructor.</p>\n<p>Here is a demonstrative program</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct node\n{\n    node *next;\n    int x;\n    ~node()\n    {\n        std::cout &lt;&lt; \"inside node: \" &lt;&lt; x &lt;&lt; std::endl;\n        delete next;\n    }\n};\n\nvoid push_front( node **tree, int x )\n{\n    node *n = new node;\n    n-&gt;x = x;\n    n-&gt;next = *tree;\n\n    *tree = n;\n}\n\nvoid clear( node **tree )\n{\n    delete *tree;\n    *tree = nullptr;\n}\n\nint main()\n{\n    node *tree = nullptr;\n\n    for ( int i = 0; i &lt; 10; i++ ) push_front( &amp;tree, i );\n\n    clear( &amp;tree );\n}\n</code></pre>\n<p>The output is</p>\n<pre><code>Compiled with /EHsc /nologo /W4\nmain.cpp\n\nCompilation successful!\n\nTotal compilation time: 187ms\n\ninside node: 9\n\ninside node: 8\n\ninside node: 7\n\ninside node: 6\n\ninside node: 5\n\ninside node: 4\n\ninside node: 3\n\ninside node: 2\n\ninside node: 1\n\ninside node: 0\n\nTotal execution time: 734ms\n</code></pre>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2014-12-09T14:56:02.330", "Score": "2", "CreationDate": "2014-12-09T14:10:54.460", "ParentId": "27380859", "CommentCount": "8", "LastEditDate": "2014-12-09T14:56:02.330", "OwnerUserId": "2877241"}, "27380859": {"ViewCount": "4883", "Body": "<p>from my understanding, this code for binary search tree destructor works:</p>\n<pre><code>~tree(){\n\n    remove(root);\n}\n\nvoid remove(node* root) \n{\n    if (root == NULL) return;\n    remove(root-&gt;left);\n    remove(root-&gt;right);\n    delete root;\n}\n</code></pre>\n<p>However, I would like to know if the following call for destructor works?</p>\n<pre><code>~node(){\n    delete left;\n    delete right;\n}\n\n~tree(){\n    delete root;\n}\n</code></pre>\n<p>My understanding is that deleting the root would automatically call the child nodes and delete them as well. Is that a correct assumption? <strong>If it is indeed correct, what is a simple approach to verify that the destructor is working?</strong></p>\n<p><strong>{{This part of the post has been added later}}</strong></p>\n<p>I am using the second method here. Going by the output expression verification, the code below does not seem to be working, because I am getting a single delete output (which seemingly is for the root node)</p>\n<pre><code>struct node{\n\n    ~node(){\n     delete left;\n     delete right;\n     }  \n};\n\nclass tree {\n     node* root;\n\npublic:\n\n     tree(){\n         root=NULL;\n     }\n\n     ~tree(){\n         cout&lt;&lt;\"Deleting: \"&lt;&lt;endl;\n         delete root;\n      }\n\n      void insert (int x){};\n}\n\nint main(){\n\n      A.insert(12);A.insert(13);A.insert(10);\n\n      return 0;\n} \n</code></pre>\n<p>Here is the output I am getting:</p>\n<pre><code> Deleting:\n</code></pre>\n<p>Ideally, there should be 3 such expressions but I am getting only 1.</p>\n", "AcceptedAnswerId": "27380937", "Title": "Recursive calls for Binary Tree Destructor", "CreationDate": "2014-12-09T14:06:15.923", "Id": "27380859", "CommentCount": "7", "LastEditDate": "2014-12-09T14:43:16.017", "PostTypeId": "1", "LastEditorUserId": "4341737", "LastActivityDate": "2014-12-09T14:56:02.330", "Score": "3", "OwnerUserId": "4341737", "Tags": "<c++><data-structures><binary-search-tree><destructor>", "AnswerCount": "2"}});