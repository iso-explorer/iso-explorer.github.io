post_cb({"23503013": {"CommentCount": "0", "AcceptedAnswerId": "23503087", "PostTypeId": "1", "LastEditorUserId": "2548699", "CreationDate": "2014-05-06T19:11:08.417", "LastActivityDate": "2014-05-07T13:54:40.557", "LastEditDate": "2014-05-06T19:39:18.697", "ViewCount": "301", "FavoriteCount": "4", "Title": "What does this sentence mean in paragraph \u00a73.2/2 of the C++11 Standard?", "Id": "23503013", "Score": "6", "Body": "<p>The sentence is part of paragraph \u00a73.2/2 :</p>\n<blockquote>\n<p id=\"so_23503013_23503013_0\">A variable whose name appears as a potentially-evaluated expression is\n  odr-used unless <strong>it is an object that satisfies the requirements for\n  appearing in a constant expression (5.19) and the lvalue-to-rvalue\n  conversion (4.1) is immediately applied</strong>.</p>\n</blockquote>\n<p>What exactly does the sentence in bold mean above?</p>\n<p><strong>Edit</strong>:</p>\n<p>The answer to the question of which this one is considered a duplicate, doesn't say anything that could answer my question.</p>\n", "Tags": "<c++><c++11><language-lawyer><one-definition-rule>", "OwnerUserId": "2548699", "AnswerCount": "1"}, "23503087": {"ParentId": "23503013", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>It means that when you use a constant as a constant, it's just like you were actually using a constant.</p>\n<pre><code>struct S {\n  static const int i = 0;\n};\nint main() {\n  return S::i;\n}\n</code></pre>\n<p>Although <code>S::i</code> has an initialiser, it has no definition, but the text in your question makes a special exception for uses like this, where <code>S::i</code> is only accessed for its value. In that case, no definition is needed.</p>\n<p>On the other hand, other uses do require a definition:</p>\n<pre><code>struct S {\n  static const int i = 0;\n};\nint f(const int &amp;i) {\n  return i;\n}\nint main() {\n  return f(S::i);\n}\n</code></pre>\n<p>This program is invalid, and is accepted by some implementations, but rejected by others. The call to <code>f</code> requires an actual definition of <code>S::i</code> to exist, although if <code>f</code> gets inlined, it's possible for the lack of a definition to go undiagnosed.</p>\n<p>On my system, if compiling and linking the second program without optimisations, I get:</p>\n<pre>\n$ g++ test2.cc -o test2\n/tmp/ccdEsfxs.o:test2.cc:function main: error: undefined reference to 'S::i'\ncollect2: error: ld returned 1 exit status\n</pre>\n<p>To make it work, a definition needs to be provided, like so:</p>\n<pre><code>struct S {\n  static const int i = 0;\n};\nconst int S::i;\n</code></pre>\n", "OwnerUserId": "743382", "LastEditorUserId": "743382", "LastEditDate": "2014-05-06T19:28:27.960", "Id": "23503087", "Score": "7", "CreationDate": "2014-05-06T19:15:38.647", "LastActivityDate": "2014-05-06T19:28:27.960"}, "bq_ids": {"n4140": {"so_23503013_23503013_0": {"section_id": 7040, "quality": 0.5555555555555556, "length": 10}}, "n3337": {"so_23503013_23503013_0": {"section_id": 6785, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_23503013_23503013_0": {"section_id": 8537, "quality": 0.5555555555555556, "length": 10}}}});