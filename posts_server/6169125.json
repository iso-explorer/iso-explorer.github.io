post_cb({"6169172": {"ParentId": "6169125", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>They standard guarantees this for a raw array, but I can't find anything that would guarantee it for containers.</p>\n<p>From <code>[expr.delete]</code> (new wording for C++0x):</p>\n<blockquote>\n<p id=\"so_6169125_6169172_0\">If the value of the operand of the delete-expression is not a null pointer value, the delete-expression will\n  invoke the destructor (if any) for the object or the elements of the array being deleted.  In the case of an\n  array, the elements will be destroyed in order of decreasing address (that is, in reverse order of the completion\n  of their constructor; see 12.6.2).</p>\n</blockquote>\n<p><code>std::vector</code> (and in fact, all containers in the standard library, possibly excluding <code>std::array</code>) do not use <code>delete[]</code> to destroy the elements (they use <code>allocator_traits&lt;allocator_type&gt;::destroy</code> on each element individually), so the above guarantee doesn't apply.  And I can find no restrictions on <code>std::vector</code> in particular or containers in general, about the order of deletion.  For some containers, such a guarantee would be very expensive (e.g. <code>std::forward_list</code> can't iterate the elements in reverse to delete them, and <code>std::map</code> doesn't remember the order in which pairs were added).</p>\n<p>From <code>[container.requirements.general]</code> (C++0x wording):</p>\n<blockquote>\n<p id=\"so_6169125_6169172_1\">For the components a\ufb00ected by this subclause that declare an allocator_type, objects stored in these\n  components shall be constructed using the allocator_traits::construct function and\n  destroyed using the allocator_traits::destroy function (20.6.8.2).</p>\n</blockquote>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2011-05-29T17:37:29.693", "Id": "6169172", "Score": "3", "CreationDate": "2011-05-29T17:17:42.177", "LastActivityDate": "2011-05-29T17:37:29.693"}, "6169125": {"CommentCount": "3", "ViewCount": "2090", "PostTypeId": "1", "ClosedDate": "2011-05-29T18:54:37.220", "LastEditorUserId": "-1", "CreationDate": "2011-05-29T17:09:28.910", "LastActivityDate": "2011-05-29T18:07:22.820", "Title": "Order of destruction of elements of an std::vector", "AcceptedAnswerId": "6169143", "LastEditDate": "2017-05-23T12:15:25.317", "Id": "6169125", "Score": "20", "Body": "<blockquote>\n<p id=\"so_6169125_6169125_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/2083603/stl-containers-element-destruction-order\">STL containers element destruction order</a> </br></p>\n</blockquote>\n<p>Is there a guarantee the the elements of an <code>std::vector</code> would be destroyed from last to first?</p>\n", "Tags": "<c++><vector><destructor>", "OwnerUserId": "9611", "AnswerCount": "3"}, "6169143": {"ParentId": "6169125", "PostTypeId": "2", "CommentCount": "15", "Body": "<p>2003:5.3.5/6 says about <code>delete[]</code>:</p>\n<blockquote>\n<p id=\"so_6169125_6169143_0\">The delete-expression will invoke the destructor (if any) for the object or the elements of the array being deleted. In the case of an array, the elements will be destroyed <strong>in order of decreasing address</strong> (that is, in reverse order of the completion of their constructor; see 12.6.2).</p>\n</blockquote>\n<p>So if your <code>std::vector</code> object's allocator uses <code>delete[]</code> then, yes, it is bound to destroy elements in reverse order.</p>\n<p>However, there is no guarantee that your <code>std::vector</code> will work this way (and, in fact, it most likely does not), and I can't find any citations specific to the container.</p>\n<p>Really, I think it's all down to your allocator and 2003:20.1.5 (which lists the requirements placed upon allocators) doesn't appear to say anything about it.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2011-05-29T17:24:06.863", "Id": "6169143", "Score": "15", "CreationDate": "2011-05-29T17:13:31.827", "LastActivityDate": "2011-05-29T17:24:06.863"}, "bq_ids": {"n4140": {"so_6169125_6169172_1": {"section_id": 704, "quality": 0.7222222222222222, "length": 13}, "so_6169125_6169172_0": {"section_id": 6110, "quality": 0.9666666666666667, "length": 29}, "so_6169125_6169143_0": {"section_id": 6110, "quality": 0.92, "length": 23}}, "n3337": {"so_6169125_6169172_1": {"section_id": 694, "quality": 0.7222222222222222, "length": 13}, "so_6169125_6169172_0": {"section_id": 5876, "quality": 0.9666666666666667, "length": 29}, "so_6169125_6169143_0": {"section_id": 5876, "quality": 0.92, "length": 23}}, "n4659": {"so_6169125_6169172_1": {"section_id": 733, "quality": 0.7222222222222222, "length": 13}, "so_6169125_6169172_0": {"section_id": 7607, "quality": 0.9666666666666667, "length": 29}, "so_6169125_6169143_0": {"section_id": 7607, "quality": 0.92, "length": 23}}}, "6169463": {"ParentId": "6169125", "CommentCount": "1", "Body": "<p>No, there <strong>are</strong> guarantees for arrays, where all elements are constructed is order and destroyed in the reverse order. This is somewhat consistent with how global objects are handled.</p>\n<p>Container members, on the other hand, can be constructed and destroyed in any order using for example <code>insert</code> and <code>erase</code> member functions. To be somewhat consistent and destroy the elements in the reverse order of construction, this would require the containers to keep some kind of log over these changes. Obviously this would be expensive!</p>\n<p>The best bet is that the container destructor calls <code>clear()</code>, which is defined as <code>erase(begin(), end())</code>, but I cannot find any requirements for that either. The standard only says \"linear complexity\" in table 65.</p>\n", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "6169463", "Score": "3", "CreationDate": "2011-05-29T18:07:22.820", "LastActivityDate": "2011-05-29T18:07:22.820"}});