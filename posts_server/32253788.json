post_cb({"bq_ids": {"n4140": {"so_32253788_32254282_0": {"length": 56, "quality": 0.9824561403508771, "section_id": 0}, "so_32253788_32254282_2": {"length": 28, "quality": 1.0, "section_id": 44}, "so_32253788_32254282_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 11}}, "n3337": {"so_32253788_32254282_0": {"length": 56, "quality": 0.9824561403508771, "section_id": 0}, "so_32253788_32254282_2": {"length": 28, "quality": 1.0, "section_id": 41}, "so_32253788_32254282_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 8}}, "n4659": {"so_32253788_32254282_0": {"length": 52, "quality": 0.9122807017543859, "section_id": 0}, "so_32253788_32254282_2": {"length": 28, "quality": 1.0, "section_id": 45}, "so_32253788_32254282_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 12}}}, "32253788": {"ViewCount": "700", "Body": "<p>I expect the code below to print <code>Test::Test(string,string,bool)</code>, however it prints <code>Test::Test(string,bool)</code>. Why does it call the constructor that takes only one string parameter when two are provided? Surely a string can't be converted to a bool...? I have tried adding the explicit keyword but it does not help.  Code is also at <a href=\"http://ideone.com/n3tep1\" rel=\"nofollow\">http://ideone.com/n3tep1</a>.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nclass Test\n{\npublic:\n\n    Test(const string&amp; str1, bool flag=false)\n    {\n        cout &lt;&lt; \"Test::Test(string,bool)\" &lt;&lt; endl;\n    }\n\n    Test(const string&amp; str1, const string&amp; str2, bool flag=false)\n    {\n        cout &lt;&lt; \"Test::Test(string,string,bool)\" &lt;&lt; endl;\n    }\n};\n\nint main()\n{\n    Test* test = new Test(\"foo\", \"bar\");\n}\n</code></pre>\n", "Title": "C++ wrong constructor being called", "CreationDate": "2015-08-27T15:38:10.517", "Id": "32253788", "CommentCount": "6", "LastEditDate": "2015-08-27T16:19:31.200", "PostTypeId": "1", "LastEditorUserId": "2113881", "LastActivityDate": "2015-08-28T14:08:20.317", "Tags": "<c++><c++11>", "Score": "9", "OwnerUserId": "1775138", "ClosedDate": "2015-08-27T18:56:35.803", "AnswerCount": "3"}, "32254282": {"Id": "32254282", "PostTypeId": "2", "Body": "<p><code>\"bar\"</code> is of type <code>char const [4]</code>, and the conversion from that to a <code>bool</code> is an standard conversion sequence, while conversion to <code>std::string</code> is a user defined conversion. The former is always preferred over the latter.</p>\n<p>From N3337, <em>[conv]/1</em></p>\n<blockquote>\n<p id=\"so_32253788_32254282_0\">Standard conversions are implicit conversions with built-in meaning. Clause 4 enumerates the full set of such conversions. A <em>standard conversion sequence</em> is a sequence of standard conversions in the following order:<br/>\n  \u00a0\u00a0\u00a0\u00a0\u2014 Zero or one conversion from the following set: lvalue-to-rvalue conversion, <strong>array-to-pointer conversion</strong>,\n  and function-to-pointer conversion.<br/>\n  \u00a0\u00a0\u00a0\u00a0\u2014 Zero or one conversion from the following set: integral promotions, floating point promotion, integral\n  conversions, floating point conversions, floating-integral conversions, pointer conversions, pointer to member conversions, and <strong>boolean conversions</strong>.<br/>\n  \u00a0\u00a0\u00a0\u00a0\u2014 Zero or one qualification conversion.</p>\n</blockquote>\n<p>In your example, the standard conversion sequence consists of array-to-pointer conversion and boolean conversion.</p>\n<p><em>[conv.array]/1</em></p>\n<blockquote>\n<p id=\"so_32253788_32254282_1\">An lvalue or rvalue of type \u201carray of <code>N T</code>\u201d or \u201carray of unknown bound of <code>T</code>\u201d can be converted to a prvalue of type \u201cpointer to <code>T</code>\u201d. The result is a pointer to the first element of the array.</p>\n</blockquote>\n<p><em>[conv.bool]/1</em></p>\n<blockquote>\n<p id=\"so_32253788_32254282_2\">A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a prvalue of type <code>bool</code>. A zero value, null pointer value, or null member pointer value is converted to <code>false</code>;\n  any other value is converted to <code>true</code>. ...</p>\n</blockquote>\n<p>Thus <code>Test(\"foo\", \"bar\")</code> results in a call to the <code>Test(const string&amp;, bool)</code> constructor instead of the other one.</p>\n<hr>\n<p>One way to trigger a call to the other constructor would be to use <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/operator%22%22s\" rel=\"nofollow\"><code>string_literals</code></a></p>\n<pre><code>using namespace std::literals::string_literals;\nTest(\"foo\", \"bar\"s);  // calls Test(const string&amp;, const string&amp;, bool)\n//               ^ \n</code></pre>\n</hr>", "LastEditorUserId": "241631", "LastActivityDate": "2015-08-27T20:25:03.297", "Score": "2", "CreationDate": "2015-08-27T15:58:32.580", "ParentId": "32253788", "CommentCount": "0", "OwnerUserId": "241631", "LastEditDate": "2015-08-27T20:25:03.297"}, "32253886": {"Id": "32253886", "PostTypeId": "2", "Body": "<p>I would expect that if anything the compiler would complain about ambiguous functions.</p>\n<p>The reason I would expect that, and that you get the wrong constructor being called, is that using a string literal results in a pointer, and pointer can implicitly be converted to a boolean value.</p>\n<p>In this case the compiler apparently thinks that the boolean conversion is a better match than conversion to a <code>std::string</code>.</p>\n", "LastActivityDate": "2015-08-27T15:42:31.817", "CommentCount": "2", "CreationDate": "2015-08-27T15:42:31.817", "ParentId": "32253788", "Score": "0", "OwnerUserId": "440558"}, "32253986": {"Id": "32253986", "PostTypeId": "2", "Body": "<p>The type of the argument being used to construct <code>Test</code> is <code>char const[4]</code>.</p>\n<p><code>char const[4]</code> decays to <code>char const*</code>, and has to be converted to a <code>bool</code> or  a <code>std::string const&amp;</code> to make the function call unambiguous.</p>\n<p>A pointer can be converted to <code>bool</code> using standard conversion rules.</p>\n<p>A <code>char const*</code> can be converted to <code>std::string const&amp;</code> using a user defined conversion rule.</p>\n<p>Given that, the conversion from <code>char const*</code>, a pointer, to <code>bool</code> is considered a better match than the conversion from <code>char const*</code> to <code>std::string const&amp;</code>.</p>\n<p>Hence, the call resolves to the first constructor.</p>\n", "LastEditorUserId": "434551", "LastActivityDate": "2015-08-28T14:08:20.317", "Score": "6", "CreationDate": "2015-08-27T15:45:34.250", "ParentId": "32253788", "CommentCount": "0", "OwnerUserId": "434551", "LastEditDate": "2015-08-28T14:08:20.317"}});