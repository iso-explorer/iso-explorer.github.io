post_cb({"36109560": {"ParentId": "35889337", "CommentCount": "0", "Body": "<p>All versions of the C++ standard have a paragraph that makes this undefined behaviour.    In C++98, Section 6.7 para 4.</p>\n<blockquote>\n<p id=\"so_35889337_36109560_0\">An implementation is permitted to perform early initialization of\n  other local objects with static storage duration under the same\n  conditions that an implementation is permitted to statically\n  initialize an object with static storage duration in namespace scope\n  (3.6.2). Otherwise such an object is initialized the first time\n  control passes through its declaration; such an object is considered\n  initialized upon the completion of its initialization. If the\n  initialization exits by throwing an exception, the initialization is\n  not complete, so it will be tried again the next time control enters\n  the declaration. If control reenters the declaration (recursively)\n  while the object is being initialized, the behavior is undefined.</p>\n</blockquote>\n<p>All subsequent standards have essentially the same paragraph (only differences are inconsequential - such as section numbering for cross-referencing, etc).</p>\n<p>What you have done is implement the constructor of your singleton so it calls the function which constructs it.    <code>getInstance()</code> creates the object, the constructor (indirectly) calls <code>getInstance()</code>.   Hence it runs afoul of the last sentence in the quote above, and introduces undefined behaviour.</p>\n<p>The solution, as with anything recursive, is to either reimplement so recursion does not occur, or to prevent interference between the first call and any recursive calls.</p>\n<p>There are three ways to achieve this.</p>\n<p>The first, which you have said you don't want, is to construct an object and then parse data to initialise it (two-stage construction).</p>\n<p>The second is to parse the data first, and only construct the object if the parsed data is valid (i.e. suitable for use in constructing the object).</p>\n<p>The third is for the constructor to handle the parsing (which you are trying to do) but, if parsed data is invalid, to force the constructor to fail (which your code does not do).</p>\n<p>An example of the third is to leave the <code>getInstance()</code> alone, and restructure the constructor so it never calls <code>getInstance()</code>. </p>\n<pre><code>static StaticLocalData* getInstance()\n{\n    static StaticLocalData inst_;\n    return &amp;inst_;\n}\n\nStaticLocalData::StaticLocalData()\n{\n    parseConfig();\n}\n\nvoid StaticLocalData::parseConfig()\n{\n     int data = getData();    // data can be any type you like\n\n     if (IsValid(data))\n     {\n          //   this function is called from constructor so simply initialise\n          //    members of the current object using data\n     }\n     else\n     {\n           //   okay, we're in the process of constructing our object, but\n           //     the data is invalid.  The constructor needs to fail\n\n           throw std::invalid_argument(\"Construction of static local data failed\");\n     }\n}\n</code></pre>\n<p>In the above, <code>IsValid()</code> represents a function or expression that checks if the parsed data is valid.</p>\n<p>This approach actually exploits the second last sentences in the paragraph I quoted above from the standard.   It has the effect of ensuring that calling <code>staticLocal::getInstance()</code> repeatedly will keep resulting in an exception until the parsing succeeds.   Once the parsing has succeeded, the object will exist, and no further attempt will be made to it (it's address will simply be returned instead).</p>\n<p>If the caller does not <code>catch</code> the exception, the effect is simple - the program will <code>terminate()</code>.    If the caller does <code>catch</code> the exception, it should not try to use the pointer.</p>\n<pre><code> try\n {\n       StaticLocal *thing = StaticLocal::getInstance();\n\n       //  code using thing here will never be reached if an exception is thrown\n\n }\n catch (std::invalid_argument &amp;e)\n {\n       // thing does not exist here, so can't be used\n       //     Worry about recovery, not trying to use thing\n }\n</code></pre>\n<p>So, yes, your approach introduces undefined behaviour.   But same part of the standard  that makes the behaviour undefined also provides the basis for a solution.</p>\n", "OwnerUserId": "4706785", "PostTypeId": "2", "Id": "36109560", "Score": "1", "CreationDate": "2016-03-20T02:21:02.593", "LastActivityDate": "2016-03-20T02:21:02.593"}, "36006664": {"ParentId": "35889337", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>see <a href=\"https://stackoverflow.com/questions/11711920/how-to-implement-multithread-safe-singleton-in-c11-without-using-mutex\">How to implement multithread safe singleton in C++11 without using &lt;mutex&gt;</a></p>\n<p>singleton declaration in c++11 is thread safe by standard. In VS2015 it may be implemented by mutex.</p>\n<p>So, you last solution is fully applicable</p>\n<pre><code>StaticLocal() { /* do nothing */ }\n\nstatic StaticLocal *getInstance() {\n   static StaticLocal inst_; \n   std::call_once(once_flag, [&amp;inst_]() {inst_.parseConfig(); return &amp;inst_;});\n   return &amp;inst_;\n}\n</code></pre>\n<p>about destructor: you can register you singleton destructor by using\n<code>int atexit(void (*function)(void));</code>. This applied in Linux and may be exist in Win too, as function from standard library. </p>\n", "OwnerUserId": "4974190", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:07:56.587", "Id": "36006664", "Score": "-1", "CreationDate": "2016-03-15T09:03:32.647", "LastActivityDate": "2016-03-21T10:00:07.470"}, "36060569": {"ParentId": "35889337", "CommentCount": "0", "Body": "<p>The problem is that inside the class, you should be using \"this\" instead of calling getInstance, in particular:</p>\n<pre><code>void parseConfig() {\n    int d = StaticLocal::getInstance()-&gt;getData();\n}\n</code></pre>\n<p>Should simply be:</p>\n<pre><code>void parseConfig() {\n    int d = getData();\n}\n</code></pre>\n<p>The object is a singleton because the constructor is private and thus the user cannot construct an arbitrary number of objects.  It's bad design to write the whole class assuming there will be only one instance of the object ever.  At some point somebody may stretch the concept of a singleton like this:</p>\n<pre><code>static StaticLocal *getInstance(int idx) {\n    static StaticLocal inst_[3];\n    if (idx &lt; 0 || idx &gt;= 3)\n      throw // some error;\n    return &amp;inst_[idx];\n}\n</code></pre>\n<p>When that happens, it's much easier to update the code if there aren't calls to getInstance() throughout the class.</p>\n<p>Why do changes like this happen?  Imagine you were writing a class 20 years ago to represent the CPU.  Of course there will only ever be one CPU in the system, so you make it a singleton.  Then, suddenly, multi-core systems become commonplace.  You still want only as many instances of the CPU class as there are cores in the system, but you won't know until the program is run how many cores are actually on a given system.</p>\n<p>Moral of the story: Using the this pointer not only avoids recursively calling getInstance(), but future proofs your code as well.</p>\n", "OwnerUserId": "5878042", "PostTypeId": "2", "Id": "36060569", "Score": "7", "CreationDate": "2016-03-17T12:27:56.310", "LastActivityDate": "2016-03-17T12:27:56.310"}, "36004096": {"ParentId": "35889337", "CommentCount": "0", "Body": "<p>One straight forward way of solving this is to separate the responsibilities, in this case \"<em>whatever <code>StaticLocal</code> is supposed to do</em>\" and \"<em>reading the configuration data</em>\"</p>\n<pre><code>class StaticLocal;\n\nclass StaticLocalData\n{\nprivate:\n  friend StaticLocal;\n  StaticLocalData()\n  {\n  }\n  StaticLocalData(const StaticLocalData&amp;) = delete;\n  StaticLocalData&amp; operator=(const StaticLocalData&amp;) = delete;\n\n  int getData()\n  {\n    return 1;\n  }\n\npublic:\n  static StaticLocalData* getInstance()\n  {\n    static StaticLocalData inst_;\n    return &amp;inst_;\n  }\n};\n\nclass StaticLocal\n{\nprivate:\n  StaticLocal()\n  {\n    // Indirectly calls getInstance()\n    parseConfig();\n  }\n  StaticLocal(const StaticLocal&amp;) = delete;\n  StaticLocal&amp; operator=(const StaticLocal&amp;) = delete;\n\n  void parseConfig()\n  {\n    int d = StaticLocalData::getInstance()-&gt;getData();\n  }\n\npublic:\n  static StaticLocal* getInstance()\n  {\n    static StaticLocal inst_;\n    return &amp;inst_;\n  }\n\n  void doIt(){};\n};\n\nint main()\n{\n  StaticLocal::getInstance()-&gt;doIt();\n  return 0;\n}\n</code></pre>\n<p>This way, StaticLocal does not call itself, the circle is broken.</p>\n<p>Also, you have cleaner classes. If you move the implementation of <code>StaticLocal</code> into a separate compile unit, users of static local won't even know that the <code>StaticLocalData</code> thingy exists.</p>\n<p>There is a good chance that you will find that you do not need the functionality of <code>StaticLocalData</code> to be wrapped into a Singleton.</p>\n", "OwnerUserId": "2173029", "PostTypeId": "2", "Id": "36004096", "Score": "1", "CreationDate": "2016-03-15T06:26:13.917", "LastActivityDate": "2016-03-15T06:26:13.917"}, "35889337": {"CommentCount": "7", "AcceptedAnswerId": "36128311", "PostTypeId": "1", "LastEditorUserId": "345027", "CreationDate": "2016-03-09T10:45:20.977", "LastActivityDate": "2016-03-21T10:18:46.457", "LastEditDate": "2016-03-11T11:27:52.043", "ViewCount": "708", "FavoriteCount": "2", "Title": "Can I access a static local while it is being constructed in C++?", "Id": "35889337", "Score": "11", "Body": "<p>Static locals are guaranteed to be instantiated at first use by the C++ standard. However, I'm wondering what happens if I access a static local object while it is beeing constructed. I assume that this is UB. \nBut what are the best practices to avoid this in the following situation?</p>\n<h2>A problem situation</h2>\n<p>The Meyers Singleton pattern uses a static local in a static <code>getInstance()</code> method to construct the object on the first use. Now if the constructor (directly or indireclty) calls <code>getInstance()</code> again, we face\na situation where the static initialization is not yet completed. Here is a minimal example, that illustrates the problem situation:</p>\n<pre><code>class StaticLocal {\nprivate:\n    StaticLocal() {\n        // Indirectly calls getInstance()\n        parseConfig();\n    }\n    StaticLocal(const StaticLocal&amp;) = delete;\n    StaticLocal &amp;operator=(const StaticLocal &amp;) = delete;\n\n    void parseConfig() {\n        int d = StaticLocal::getInstance()-&gt;getData();\n    }\n    int getData() {\n        return 1;\n    }\n\npublic:\n    static StaticLocal *getInstance() {\n        static StaticLocal inst_;\n        return &amp;inst_;\n    }\n\n    void doIt() {};\n};\n\nint main()\n{\n    StaticLocal::getInstance()-&gt;doIt();\n    return 0;\n}\n</code></pre>\n<p>In VS2010, this works without problems, but <strong>VS2015 deadlocks.</strong></p>\n<p>For this simple, reduced situation, the obvious solution is to direclty call <code>getData()</code>, without calling <code>getInstance()</code> again. However, in more complex scenarios (as my actual situation), this solution is not feasible.</p>\n<h2>Attempting a solution</h2>\n<p>If we change the <code>getInstance()</code> method to work on a static local pointer like this (and thus abandon the Meyers Singleton pattern):</p>\n<pre><code>static StaticLocal *getInstance() {\n    static StaticLocal *inst_ = nullptr;\n    if (!inst_) inst_ = new StaticLocal;\n    return inst_;\n}\n</code></pre>\n<p>It is clear that we get an endless recursion. <code>inst_</code> is <code>nullptr</code> on the first invokation, so we call the constructor with <code>new StaticLocal</code>. At this point, <code>inst_</code> is still <code>nullptr</code> as it will only get assigned when\nthe constructor finishes. However, the constructor will call <code>getInstance()</code> again, finding a <code>nullptr</code> in <code>inst_</code>, and thus call the constructor again. And again, and again, ...</p>\n<p>A possible solution is to move the constructor's body into the <code>getInstance()</code>:</p>\n<pre><code>StaticLocal() { /* do nothing */ }\n\nstatic StaticLocal *getInstance() {\n    static StaticLocal *inst_ = nullptr;\n    if (!inst_) {\n        inst_ = new StaticLocal;\n        inst_-&gt;parseConfig();\n    }\n    return inst_;\n}\n</code></pre>\n<p>This will work. However, I'm not happy with this situation, as a constructor should, well, <em>construct</em> a <em>complete object</em>. It is debateable if this situation can be made an exception, as it is a singleton. However, I dislike it.</p>\n<p>But what's more, what if the class has a non-trivial destructor?</p>\n<pre><code>~StaticLocal() { /* Important Cleanup */ }\n</code></pre>\n<p>In the above situation, the destructor is never called. We loose RAII and thus one important distinguishing feature of C++! We are in a world like Java or C#...</p>\n<p>So we could wrap our singleton in some sort of smart pointer:</p>\n<pre><code>static StaticLocal *getInstance() {\n    static std::unique_ptr&lt;StaticLocal&gt; inst_;\n    if (!inst_) {\n        inst_.reset(new StaticLocal);\n        inst_-&gt;parseConfig();\n    }\n    return inst_.get();\n}\n</code></pre>\n<p>This will correctly call the destructor on program exit. But it forces us to make the destructor public.</p>\n<p>At this point, I feel I'm doing the compiler's job...</p>\n<h2>Back to the original question</h2>\n<p>Is this situation really undefined behaviour? Or is it a compiler bug in VS2015?</p>\n<p>What is the best solution to such a situation, prefably without dropping a full constructor, and RAII?</p>\n", "Tags": "<c++><visual-studio-2015><static-initialization>", "OwnerUserId": "345027", "AnswerCount": "7"}, "36053379": {"ParentId": "35889337", "CommentCount": "1", "Body": "<p>In terms of <code>dtor</code>, I think you don't have to worry about it.  Once you define it, then it will be automatically called after main() exits. </p>\n", "OwnerUserId": "6067383", "PostTypeId": "2", "Id": "36053379", "Score": "-1", "CreationDate": "2016-03-17T06:46:39.313", "LastActivityDate": "2016-03-17T06:46:39.313"}, "36128311": {"ParentId": "35889337", "CommentCount": "1", "Body": "<p>Actually this code in its current form is stuck into <strong>3-way infinite recursion</strong>. Hence it will never work.</p>\n<pre><code>getInstance() --&gt; StaticLocal()\n ^                    |  \n |                    |  \n ----parseConfig() &lt;---\n</code></pre>\n<p>To let it work, anyone of the above 3 methods has to compromise and come out of the vicious circle. You judged it right, <code>parseConfig()</code> is the best candidate.</p>\n<p>Let's assume that all the recursive content of constructor is put into <code>parseConfig()</code> and non-recursive contents are retained in constructor. Then you may do following (only relevant code):</p>\n<pre><code>    static StaticLocal *s_inst_ /* = nullptr */;  // &lt;--- introduce a pointer\n\npublic:\n    static StaticLocal *getInstance() {\n      if(s_inst_ == nullptr)\n      {   \n        static StaticLocal inst_;  // &lt;--- RAII\n        s_inst_ = &amp;inst_;  // &lt;--- never `delete s_inst_`!\n        s_inst_-&gt;parseConfig();  // &lt;--- moved from constructor to here\n      }   \n      return s_inst_;\n    }   \n</code></pre>\n<p>This works fine.</p>\n", "OwnerUserId": "514235", "PostTypeId": "2", "Id": "36128311", "Score": "2", "CreationDate": "2016-03-21T10:18:46.457", "LastActivityDate": "2016-03-21T10:18:46.457"}, "35991335": {"ParentId": "35889337", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This leads to undefined behaviour by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">c++ 11 standard</a>. The relevant section is 6.7:</p>\n<blockquote>\n<p id=\"so_35889337_35991335_0\">If control enters the declaration concurrently while the variable is\n  being initialized, the concurrent execution shall wait for completion\n  of the initialization. If control re-enters the declaration\n  recursively while the variable is being initialized, the behavior is\n  undefined.</p>\n</blockquote>\n<p>The example from the standard is bellow:</p>\n<pre><code>int foo(int i) {\n    static int s = foo(2*i); // recursive call - undefined\n    return i+1;\n}\n</code></pre>\n<p>You are facing the deadlock since MSVC inserts mutex lock/unlock to make static variable initialization thread safe. Once you call it recursively, you are locking the same mutex two times in the same thread, what leads to dead lock.</p>\n<p><a href=\"http://www.opensource.apple.com/source/libcppabi/libcppabi-14/src/cxa_guard.cxx\" rel=\"nofollow noreferrer\">This</a> is how static initialization is implemented internally in llvm compiler.</p>\n<p>The best solution IMO is to do not use singletons at all. Significant group of developers tend to think that <a href=\"https://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons\">singleton is anti-pattern</a>. The issues like you mentioned is really hard to debug, because it occurs before main. Because order of globals initialization is undefined. Also, multiple translation units might be involved, so compiler won't catch this types of errors. So, when I faced the same problem in production code, I was obliged to remove all of the singletons.</p>\n<p>If you still think that singleton is the right way to go, then you need to re-structurize your code somehow when your singleton object owns (holds them as members, for example) all the classes that calls <code>GetInstance</code> during the singleton initialization. Think of your classes like ownership tree, where the singleton is the root. Pass reference to parent, when you create a child, if child needs it.</p>\n", "OwnerUserId": "1282773", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:58:39.613", "Id": "35991335", "Score": "14", "CreationDate": "2016-03-14T15:16:23.917", "LastActivityDate": "2016-03-18T06:43:43.877"}, "bq_ids": {"n4140": {"so_35889337_36109560_0": {"section_id": 3919, "quality": 0.8955223880597015, "length": 60}, "so_35889337_35991335_0": {"section_id": 3919, "quality": 1.0, "length": 23}}, "n3337": {"so_35889337_36109560_0": {"section_id": 3779, "quality": 0.8955223880597015, "length": 60}, "so_35889337_35991335_0": {"section_id": 3779, "quality": 1.0, "length": 23}}, "n4659": {"so_35889337_36109560_0": {"section_id": 4805, "quality": 0.6268656716417911, "length": 42}, "so_35889337_35991335_0": {"section_id": 4805, "quality": 1.0, "length": 23}}}});