post_cb({"bq_ids": {"n4140": {"so_25994594_25994811_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 3261}}, "n3337": {"so_25994594_25994811_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 3133}}, "n4659": {"so_25994594_25994811_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 4019}}}, "25994594": {"ViewCount": "217", "Body": "<p><strong>header.h</strong> </p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nclass A\n{\n    public:\n        virtual void display(int i=5) { cout&lt;&lt; \"Base::\" &lt;&lt; i &lt;&lt; endl; }\n};\n\nclass B : public A\n{\n    public:\n        void display(int i=9) { cout&lt;&lt; \"Derived::\" &lt;&lt; i &lt;&lt; endl; }\n};  \n</code></pre>\n<p><strong>source.h</strong> </p>\n<pre><code>#include &lt;iostream&gt;\n#include \"header.h\"\nusing namespace std;\nint main()\n{\n    A * a = new B();\n    a-&gt;display();\n\n    A* aa = new A();\n    aa-&gt;display();\n\n    B* bb = new B();\n    bb-&gt;display();\n}  \n</code></pre>\n<p><strong>output</strong> </p>\n<pre><code>Derived::5\nBase::5\nDerived::9  \n</code></pre>\n<p>My understanding was default parameter functions were resolved during compile time using function overloading.  Virtual functions were then resolved during runtime using function overriding.  </p>\n<p>But what is happening is a mess.<br>\nHow does the function resolution actually happen here?</br></p>\n", "AcceptedAnswerId": "25994783", "Title": "Resolution of virtual function with default parameters", "CreationDate": "2014-09-23T12:00:05.697", "LastActivityDate": "2014-09-23T14:49:16.017", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "Tags": "<c++><virtual-functions><overload-resolution>", "Id": "25994594", "Score": "6", "OwnerUserId": "806299", "ClosedDate": "2014-09-23T12:17:08.793", "AnswerCount": "3"}, "25994765": {"Id": "25994765", "PostTypeId": "2", "Body": "<p>There is no polymorphism on default arguments. They are resolved compile-time.</p>\n<p><code>A::display</code> has default argument equal 5.\n<code>B::display</code> has default argument equal 9.\nIt's only the type of <code>a</code>, <code>aa</code>, <code>bb</code> variables that matters.</p>\n<p>Use of different default arguments in polymorphic methods is confusing and should be avoided.</p>\n", "LastEditorUserId": "2032514", "LastActivityDate": "2014-09-23T12:15:44.373", "Score": "7", "CreationDate": "2014-09-23T12:08:19.820", "ParentId": "25994594", "CommentCount": "2", "OwnerUserId": "2032514", "LastEditDate": "2014-09-23T12:15:44.373"}, "25994811": {"Id": "25994811", "PostTypeId": "2", "Body": "<p>This behaviour is specified in <em>Chapter 8.3.6: Default arguments</em> within <a href=\"https://openassist.googlecode.com/files/C%2B%2B%20Standard%20-%20ANSI%20ISO%20IEC%2014882%202003.pdf\" rel=\"nofollow\">Programming languages \u2014 C++ (ISO/IEC 14882:2003(E))</a> :</p>\n<blockquote>\n<p id=\"so_25994594_25994811_0\">A virtual function call (10.3) uses the default arguments in the declaration of the virtual function <strong>determined by the static type of the pointer or reference denoting the object</strong></p>\n</blockquote>\n", "LastActivityDate": "2014-09-23T12:11:11.410", "CommentCount": "0", "CreationDate": "2014-09-23T12:11:11.410", "ParentId": "25994594", "Score": "5", "OwnerUserId": "1611055"}, "25994783": {"Id": "25994783", "PostTypeId": "2", "Body": "<p>Your code is actually seen by the compiler like this:<br>\n<em>(The <code>display()</code> method is not actually there, but the resolving works in similar way)</em></br></p>\n<pre><code>class A\n{\npublic:\n    virtual void display(int i) { cout&lt;&lt; \"Base::\" &lt;&lt; i &lt;&lt; endl; }\n    void display() { display(5); }\n};\n\nclass B : public A\n{\npublic:\n    void display(int i) override { cout&lt;&lt; \"Derived::\" &lt;&lt; i &lt;&lt; endl; }\n    void display() { display(9); }\n};\n</code></pre>\n<p>Now you should understand what happens. You are <em>calling</em> the non-virtual <code>display()</code> which calls the virtual function. <em>In more strict words: the default argument is resolved just like if the no-arg non-virtual method was there - <strong>by the type of the variable</strong> (not by the actual type of the object), but the code gets executed according to real object type, because it is virtual method:</em></p>\n<pre><code>int main()\n{\n    A * a = new B(); // type of a is A*   real type is B\n    a-&gt;display();    // calls A::display() which calls B::display(5)\n\n    A* aa = new A(); // type of aa is A*  real type is A\n    aa-&gt;display();   // calls A::display() which calls A::display(5)\n\n    B* bb = new B(); // type of bb is B*  real type is B\n    bb-&gt;display();   // calls B::display() which calls B::display(9)\n}  \n</code></pre>\n", "LastEditorUserId": "1722660", "LastActivityDate": "2014-09-23T14:49:16.017", "Score": "7", "CreationDate": "2014-09-23T12:09:46.637", "ParentId": "25994594", "CommentCount": "8", "OwnerUserId": "1722660", "LastEditDate": "2014-09-23T14:49:16.017"}});