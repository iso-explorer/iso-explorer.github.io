post_cb({"2223276": {"ParentId": "2223245", "CommentCount": "5", "Body": "<p>Why won't you just define swap in MyType's namespace and exploit argument-dependent lookup power?</p>\n", "OwnerUserId": "104451", "PostTypeId": "2", "Id": "2223276", "Score": "3", "CreationDate": "2010-02-08T16:55:02.303", "LastActivityDate": "2010-02-08T16:55:02.303"}, "2223288": {"CommentCount": "0", "CreationDate": "2010-02-08T16:56:07.920", "LastEditorUserId": "-1", "LastActivityDate": "2010-02-08T18:02:01.283", "ParentId": "2223245", "LastEditDate": "2017-05-23T10:28:11.707", "LastEditorDisplayName": "Roger Pate", "PostTypeId": "2", "Id": "2223288", "Score": "14", "Body": "<p>What you have is not a specialization, it is overloading and exactly what the standard prohibits.  (However, it will almost always currently work in practice, and may be acceptable to you.)</p>\n<p>Here is how you provide your own swap for your class template:</p>\n<pre><code>template&lt;class T&gt;\nstruct Ex {\n  friend void swap(Ex&amp; a, Ex&amp; b) {\n    using std::swap;\n    swap(a.n, b.n);\n  }\n  T n;\n}\n</code></pre>\n<p>And here is how you call swap, which you'll notice is used in Ex's swap too:</p>\n<pre><code>void f() {\n  using std::swap; // std::swap is the default or fallback\n  Ex&lt;int&gt; a, b;\n  swap(a, b); // invokes ADL\n}\n</code></pre>\n<p>Related: <a href=\"https://stackoverflow.com/questions/2197141/why-template-specialization-is-important-and-necessary-in-c/2197682#2197682\">Function template specialization importance and necessity</a></p>\n", "OwnerDisplayName": "Roger Pate"}, "bq_ids": {"n4140": {"so_2223245_14769750_0": {"section_id": 6299, "quality": 0.9705882352941176, "length": 33}}, "n3337": {"so_2223245_14769750_0": {"section_id": 6056, "quality": 0.9705882352941176, "length": 33}}, "n4659": {"so_2223245_14769750_0": {"section_id": 7808, "quality": 0.9705882352941176, "length": 33}}}, "14769750": {"ParentId": "2223245", "CommentCount": "0", "Body": "<p>What you're doing is an overload and not a template specialization. The standard does not allow you to overload inside <code>namespace std</code> (17.6.4.2.1 \u00a71)</p>\n<blockquote>\n<p id=\"so_2223245_14769750_0\">The behavior of a C++ program is undefined if it adds declarations or definitions to <code>namespace std</code> or to a namespace within <code>namespace std</code> unless otherwise specified. A program may add a template specialization for any standard library template to <code>namespace std</code> only if the declaration depends on a user-defined type and the specialization meets the standard library requirements for the original template and is not explicitly prohibited.</p>\n</blockquote>\n<p>Therefore, prefer to put your template type into your own namespace and define a non-member <code>swap()</code> within that namespace (this is not strictly necessary, but good practice). This way <code>swap(x,y)</code> will work from anywhere via argument dependent lookup (ADL, aka Koenig lookup), if <code>x</code> or <code>y</code> are in your namespace.</p>\n<pre><code>namespace my_ns {\n\ntemplate &lt;typename T&gt; class MyType\n{\npublic:\n    void swap( MyType &amp; other ) noexcept;\n};\n\ntemplate &lt;typename T&gt;\nvoid swap( MyType&lt;T&gt; &amp; lhs, MyType&lt;T&gt; &amp; rhs ) noexcept\n{\n    lhs.swap(rhs);\n}\n\n} // namespace my_ns\n</code></pre>\n<p>Code using <code>swap()</code> should normally use the <code>using namespace std</code> technique. This way your version of swap will be found by ADL and it will be prefered to the <code>std::swap()</code> function, since it is more specialized. </p>\n<pre><code>// client code\nMyType&lt;Bla&gt; x, y;\n/* ... some code ... */\nusing namespace std;\nswap( x, y ); // will call your swap version\n</code></pre>\n", "OwnerUserId": "1335865", "PostTypeId": "2", "Id": "14769750", "Score": "0", "CreationDate": "2013-02-08T09:47:55.223", "LastActivityDate": "2013-02-08T09:47:55.223"}, "2223602": {"ParentId": "2223245", "CommentCount": "1", "Body": "<p>Define own <code>swap</code>. This function must call std::swap for any type T except your types.</p>\n<pre><code>namespace help // my namespace\n{ \n\n  template &lt;class T&gt; \n  void swap(T&amp; t1, T&amp; t2) \n  { \n     ::std::swap(t1, t2);  // Redirect to std for almost all cases\n  } \n\n  // My special case: overloading\n  template &lt;class T&gt; \n  void swap(MyType&lt;T&gt;&amp; t1, MyType&lt;T&gt;&amp; t2) \n  { \n     t1.swap(t2); \n  } \n\n}  //  namespace help \n\n// Sample\nint main() \n{\n\n   MyType&lt;int&gt; t1, t2; // may be add initialization\n   int i1=5, i2=7;\n\n   help::swap(t1, t2); //  Your swap\n   help::swap(i1, i2); //  Redirect to std::swap\n}\n</code></pre>\n", "OwnerUserId": "124161", "PostTypeId": "2", "Id": "2223602", "Score": "-1", "CreationDate": "2010-02-08T17:41:17.237", "LastActivityDate": "2010-02-08T17:41:17.237"}, "2223291": {"ParentId": "2223245", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>Define your type and your swap function in the same namespace:</p>\n<pre><code>namespace foo\n{\n   struct Bar\n   {\n   };\n\n   void swap(Bar &amp; t1, Bar&amp; t2)\n   {\n     // whatever\n   }\n}\n\nint main()\n{\n    using std::swap;\n    foo::Bar a, b;\n    swap(a, b); // Argument-dependent lookup chooses foo::swap\n                // if it exists, or else reverts to std::swap\n}\n</code></pre>\n", "OwnerUserId": "244576", "LastEditorUserId": "244576", "LastEditDate": "2010-02-08T17:33:53.230", "Id": "2223291", "Score": "-1", "CreationDate": "2010-02-08T16:56:16.583", "LastActivityDate": "2010-02-08T17:33:53.230"}, "2223691": {"ParentId": "2223245", "PostTypeId": "2", "CommentCount": "6", "Body": "<h3>Edit</h3>\n<p>See Scott Meyer's article: See <i><b>Effective C++ 3rd Edition</b>, item 25: Consider support for a non-throwing swap (p106-p112)</i> for a confirmation of my answer.</p>\n<h3>Original answer</h3>\n<p>Scott Meyers wrote about this, so my answer comes from memory.</p>\n<p>First, define a swap function in the namespace of your class. For example :</p>\n<pre><code>namespace MyNamespace\n{\n   class MyClass { /* etc. */ } ;\n\n   template&lt;typename T&gt;\n   class MyTemplate { /* etc. */ } ;\n\n   void swap(MyClass &amp; lhs, MyClass &amp; rhs)\n   {\n      // the swapping code (**)\n   }\n\n   template&lt;typename T&gt;\n   void swap(MyTemplate&lt;T&gt; &amp; lhs, MyTemplate&lt;T&gt; &amp; rhs)\n   {\n      // the swapping code (**)\n   }\n}\n</code></pre>\n<p>Then, <i>if possible</i> (it is not always possible for templated classes (*) ), specialize the swap function in the namespace std. For example :</p>\n<pre><code>namespace std\n{\n   template&lt;&gt;\n   void swap&lt;MyNamespace::MyClass&gt;(MyNamespace::MyClass &amp; lhs, MyNamespace::MyClass &amp; rhs)\n   {\n      // the swapping code (**)\n   }\n\n   // The similar code for MyTemplate is forbidden, so don't try\n   // to uncomment it\n   //\n   // template&lt;typename T&gt;\n   // void swap&lt;MyNamespace::MyTemplate&lt;T&gt; &gt;(MyNamespace::MyTemplate&lt;T&gt; &amp; lhs, MyNamespace::MyTemplate&lt;T&gt; &amp; rhs)\n   // {\n   //   // the swapping code (**)\n   // }\n}\n</code></pre>\n<p>The, when using the swap function, do it indirectly, importing the std swap function into your scope. For example :</p>\n<pre><code>void doSomething(MyClass &amp; lhs, MyClass &amp; rhs)\n{\n   // etc.\n\n   // I swap the two objects below:\n   {\n      using std::swap ;\n      swap(lhs, rhs) ;\n   }\n\n   // etc.\n}\n\nvoid doSomethingElse(MyTemplate&lt;int&gt; &amp; lhs, MyTemplate&lt;int&gt; &amp; rhs)\n{\n   // etc.\n\n   // I swap the two objects below:\n   {\n      using std::swap ;\n      swap(lhs, rhs) ;\n   }\n\n   // etc.\n}\n</code></pre>\n<p>As soon as I have access to my books, I'll post here the exact reference.</p>\n<ul>\n<li>(*) template partial specialization of a function is forbidden</li>\n<li>(**) of course, a good pattern is to have a \"swap\" method declared in the class, have the swap functions call the swap method, and have the user call the swap function.</li>\n</ul>\n", "OwnerUserId": "14089", "LastEditorUserId": "14089", "LastEditDate": "2010-02-10T13:11:08.257", "Id": "2223691", "Score": "1", "CreationDate": "2010-02-08T17:54:42.193", "LastActivityDate": "2010-02-10T13:11:08.257"}, "2223289": {"ParentId": "2223245", "CommentCount": "5", "Body": "<p>Because of argument dependent (aka Koenig) lookup, I believe you can specify your own swap in the namespace of the type you want it for and it will be found in preference to <code>::std::swap</code>.  Also, I believe the template for <code>::std::swap</code> will expand differently for classes that have their own swap member function and so you can add that member function to the class and that will be used for your type.</p>\n", "OwnerUserId": "167958", "PostTypeId": "2", "Id": "2223289", "Score": "3", "CreationDate": "2010-02-08T16:56:09.697", "LastActivityDate": "2010-02-08T16:56:09.697"}, "2223245": {"CommentCount": "1", "AcceptedAnswerId": "2223288", "CreationDate": "2010-02-08T16:51:11.550", "LastActivityDate": "2013-02-08T09:47:55.223", "PostTypeId": "1", "ViewCount": "3635", "FavoriteCount": "5", "Title": "Overloading global swap for user-defined type", "Id": "2223245", "Score": "12", "Body": "<p>The C++ standard prohibits declaring types or defining anything in namespace <code>std</code>, but it does allow you to specialize standard STL templates for user-defined types.</p>\n<p>Usually, when I want to specialize <code>std::swap</code> for my own custom templated type, I just do:</p>\n<pre><code>namespace std\n{\n  template &lt;class T&gt;\n  void swap(MyType&lt;T&gt;&amp; t1, MyType&lt;T&gt;&amp; t2)\n  {\n     t1.swap(t2);\n  }\n}\n</code></pre>\n<p>...and that works out fine.  But I'm not entirely sure if my usual practice is standard compliant.  Am I doing this correctly?</p>\n", "Tags": "<c++><stl><swap><standards>", "OwnerUserId": "268816", "AnswerCount": "7"}});