post_cb({"5687540": {"CommentCount": "1", "AcceptedAnswerId": "5687553", "PostTypeId": "1", "LastEditorUserId": "3980929", "CreationDate": "2011-04-16T15:32:04.943", "LastActivityDate": "2017-06-17T10:21:31.533", "LastEditDate": "2017-06-17T10:21:31.533", "ViewCount": "45113", "FavoriteCount": "30", "Title": "Non-type template parameters", "Id": "5687540", "Score": "60", "Body": "<p>I understand that the non-type template parameter should be a constant integral expression. Can someone shed light why is it so ?</p>\n<pre><code>template &lt;std::string temp&gt;\nvoid foo()\n{\n     // ...\n}\n</code></pre>\n<blockquote id=\"so_5687540_5687540_0\">\n<pre><code>error C2993: 'std::string' : illegal type for non-type template parameter 'temp'.\n</code></pre>\n</blockquote>\n<p>I understand what a constant integral expression is. What are the reasons for not allowing  non-constant types like <code>std::string</code> as in the above snippet ?</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "528724", "AnswerCount": "4"}, "5687553": {"ParentId": "5687540", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The reason you can't do this is because non-constant expressions can't be parsed and substituted during compile-time. They could change during runtime, which would require the generation of a new template during runtime, which isn't possible because templates are a compile-time concept.  </p>\n<p>Here's what the standard allows for non-type template parameters (14.1 [temp.param] p4):</p>\n<blockquote>\n<p id=\"so_5687540_5687553_0\">A non-type template-parameter shall have one of the following (optionally cv-qualified) types:</p>\n<ul>\n<li>integral or enumeration type,</li>\n<li>pointer to object or pointer to function,</li>\n<li>lvalue reference to object or lvalue reference to function,</li>\n<li>pointer to member,</li>\n<li><code>std::nullptr_t</code>.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "500104", "LastEditorUserId": "366904", "LastEditDate": "2012-01-05T12:31:50.183", "Id": "5687553", "Score": "88", "CreationDate": "2011-04-16T15:33:30.497", "LastActivityDate": "2012-01-05T12:31:50.183"}, "5687728": {"ParentId": "5687540", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You need to be able to mangle template arguments</p>\n<pre><code>template &lt;std::string temp&gt;\nvoid f() {\n // ...\n}\n\nf&lt;\"foo\"&gt;();\nf&lt;\"bar\"&gt;(); // different function!?\n</code></pre>\n<p>Now an impl would need to come up with a unique sequence of characters for a <code>std::string</code> or, for that matter, any other arbitrary user defined class, storing a particular value, the meaning of which is not known to the implementation. And in addition, the value of arbitrary class objects can't be calculated at compile time. </p>\n<p>It's planned to consider allowing literal class types as template parameter types for post-C++0x, which are initialized by constant expressions. Those could be mangled by having the data members recursively mangled according to their values (for base classes, for example we can apply depth-first, left-to-right traversal). But it's definitely not going to work for arbitrary classes.</p>\n", "OwnerUserId": "34509", "LastEditorUserId": "415784", "LastEditDate": "2011-04-16T18:11:06.497", "Id": "5687728", "Score": "19", "CreationDate": "2011-04-16T16:04:32.210", "LastActivityDate": "2011-04-16T18:11:06.497"}, "5687562": {"ParentId": "5687540", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>A non-type template argument provided within a template argument list is an expression whose value can be determined at compile time. Such arguments must be:</p>\n<blockquote>\n<p id=\"so_5687540_5687562_0\">constant expressions, addresses of\n  functions or objects with external\n  linkage, or addresses of static class\n  members.</p>\n</blockquote>\n<p>Also, string literals are objects with internal linkage, so you can't use them as template arguments. You cannot use a global pointer, either. Floating-point literals are not allowed, given the obvious possibility of rounding-off errors.</p>\n", "OwnerUserId": "418729", "LastEditorUserId": "366904", "LastEditDate": "2012-01-05T12:33:07.793", "Id": "5687562", "Score": "8", "CreationDate": "2011-04-16T15:34:50.787", "LastActivityDate": "2012-01-05T12:33:07.793"}, "5687575": {"ParentId": "5687540", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>That is not allowed.</p>\n<p>However, this is allowed:</p>\n<pre><code>template &lt;std::string * temp&gt; //pointer to object\nvoid f();\n\ntemplate &lt;std::string &amp; temp&gt; //reference to object\nvoid g();\n</code></pre>\n<p>See \u00a714.1/6,7,8 in C++ Standard (2003).</p>\n<hr>\n<p>Illustration:</p>\n<pre><code>template &lt;std::string * temp&gt; //pointer to object\nvoid f()\n{\n   cout &lt;&lt; *temp &lt;&lt; endl;\n}\n\ntemplate &lt;std::string &amp; temp&gt; //reference to object\nvoid g()\n{\n     cout &lt;&lt; temp &lt;&lt; endl;\n     temp += \"...appended some string\";\n}\n\nstd::string s; //must not be local as it must have external linkage!\n\nint main() {\n        s = \"can assign values locally\";\n        f&lt;&amp;s&gt;();\n        g&lt;s&gt;();\n        cout &lt;&lt; s &lt;&lt; endl;\n        return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>can assign values locally\ncan assign values locally\ncan assign values locally...appended some string\n</code></pre>\n</hr>", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2016-10-19T13:31:59.903", "Id": "5687575", "Score": "57", "CreationDate": "2011-04-16T15:36:58.263", "LastActivityDate": "2016-10-19T13:31:59.903"}, "bq_ids": {"n4140": {"so_5687540_5687553_0": {"section_id": 57, "quality": 1.0, "length": 8}}, "n3337": {"so_5687540_5687553_0": {"section_id": 52, "quality": 1.0, "length": 8}}, "n4659": {"so_5687540_5687553_0": {"section_id": 59, "quality": 1.0, "length": 8}}}});