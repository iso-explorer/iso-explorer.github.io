post_cb({"22828861": {"ParentId": "22828120", "CommentCount": "0", "Body": "<p>When you consider your enable_if:</p>\n<pre><code>template &lt;bool B, typename T = void&gt; struct enable_if{ };\n\ntemplate &lt;typename T&gt; struct enable_if&lt;true, T&gt; \n{\n    typedef T type;\n};\n</code></pre>\n<p>in</p>\n<pre><code>void test_EnableIf\n{\n static_assert(\n   std::is_same&lt;\n     enable_if&lt;(sizeof(int) &gt; 0)&gt;::type,\n     void&gt;::value, \"test_EnableIf failed.\" );\n}\n</code></pre>\n<p>the result (type) is void, as no type was specified (as second \ntemplate parameter). The specialization of enable_if is selected \nbecause of the boolean expression being true, and the default \nparameter is selected (from primary template) because no other was \nprovided, and hence type is void, but NOTE that the definition \nof type does exist (as the specialization was selected).</p>\n<p>Now, in your definition of A...</p>\n<pre><code>template &lt;typename T, typename Enable = void&gt; struct A; \ntemplate &lt;typename T&gt; \nstruct A&lt;T, typename enable_if&lt;\n  (sizeof(T) &lt;= ~0ULL)&gt;::type&gt; \n{\n    void f() { } \n};\n</code></pre>\n<p>...because type does exist in enable_if, it is a better match, which causes the specialization to be selected, and hence compiles.</p>\n<p>A trivial example which amounts to the same thing is the following:</p>\n<pre><code>template &lt;class T, class U = void&gt;\nstruct X;\n\ntemplate &lt;class T&gt;\nstruct X&lt;T,void&gt;\n{\n  static int foo(){ return 0; }\n};\n\nint main()\n{\n  return X&lt;int&gt;::foo();\n}\n</code></pre>\n", "OwnerUserId": "1400817", "PostTypeId": "2", "Id": "22828861", "Score": "0", "CreationDate": "2014-04-03T05:48:33.367", "LastActivityDate": "2014-04-03T05:48:33.367"}, "22828120": {"CommentCount": "3", "ViewCount": "149", "CreationDate": "2014-04-03T04:51:39.193", "LastActivityDate": "2014-04-03T05:48:33.367", "Title": "template specialization with default parameters", "PostTypeId": "1", "Id": "22828120", "Score": "1", "Body": "<p>The following code compiles. Anyone can explain why? I've been digging the standard to figure out why it's legal.</p>\n<pre><code>template &lt;bool B, typename T = void&gt; struct enable_if { };\ntemplate &lt;typename T&gt; struct enable_if&lt;true, T&gt; {\n    typedef T type;\n};\ntemplate &lt;typename T, typename Enable = void&gt; struct A;\ntemplate &lt;typename T&gt; struct A&lt;T, typename enable_if&lt;(sizeof(T) &lt;= ~0ULL)&gt;::type&gt; {\n    void f() { }\n};\nint main() {\n    A&lt;int&gt; a;\n    a.f();\n}\n</code></pre>\n<p>At the statement:</p>\n<pre><code>A&lt;int&gt; a;\n</code></pre>\n<p>As there's only one template paramerter \"int\", the compiler should go to use the primary template, which is:</p>\n<pre><code>template &lt;typename T, typename Enable = void&gt; struct A;\n</code></pre>\n<p>which is undefined, thus causing an error.</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "3456737", "AnswerCount": "4"}, "22828416": {"ParentId": "22828120", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Let's try to figure out what's going on here:</p>\n<pre><code>// definition of enable_if, second parameter is defaulted to void\ntemplate &lt;bool B, typename T = void&gt; \nstruct enable_if { };\n\n// specialization of enable_if, if first parameter is true, \n// enable_if has a typedef for the second parameter\ntemplate &lt;typename T&gt; \nstruct enable_if&lt;true, T&gt; {\n    typedef T type;\n};\n\n// definition of struct A, second parameter defaults to void\ntemplate &lt;typename T, typename Enable = void&gt; \nstruct A;\n\n// specialization of struct A, second parameter \n// is obtained from the enable_if::type typedef\n// the first parameter of enable_if is true if the size of T\n// is smaller than the max long long (~0 --&gt; all F)\ntemplate &lt;typename T&gt; \nstruct A&lt;T, typename enable_if&lt;(sizeof(T) &lt;= ~0ULL)&gt;::type&gt; {\n    void f() { }\n};\n\nint main() {\n    // So we attempt the specialization for struct A&lt;int,enable_if...&gt;\n    // The expression of enable_if evaluates to...\n    // (sizeof(int) &lt;= ~0ULL) == true\n    // ... so it applies the specialization of enable_if&lt;true,void&gt;\n    //     (second parameter is void because none is provided, so it \n    //     uses the default.\n    // so the enable_if template is valid (selected the specialization)\n    // and that means that the struct A&lt;int,enable_if&gt; specialization\n    // is valid too, so it is selected.\n    A&lt;int&gt; a;\n    a.f();\n}\n</code></pre>\n", "OwnerUserId": "308705", "LastEditorUserId": "308705", "LastEditDate": "2014-04-03T05:35:48.963", "Id": "22828416", "Score": "1", "CreationDate": "2014-04-03T05:16:18.640", "LastActivityDate": "2014-04-03T05:35:48.963"}, "22828369": {"ParentId": "22828120", "CommentCount": "0", "Body": "<p>The compiler uses the <code>template A&lt;int, enable_if&lt;true&gt;:::type &gt;</code> when you declare <code>A&lt;int&gt;</code> since <code>sizeof(int) &lt;= ~0ULL</code> evaluates to <code>true</code>.</p>\n<p>There is no problem with <code>enable_if&lt;true&gt;::type</code> because the compiler is able to use <code>enable_if&lt;true, true&gt;::type</code>.</p>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "22828369", "Score": "0", "CreationDate": "2014-04-03T05:12:30.113", "LastActivityDate": "2014-04-03T05:12:30.113"}, "bq_ids": {"n4140": {"so_22828120_22828304_0": {"section_id": 143, "quality": 0.967741935483871, "length": 30}, "so_22828120_22828304_1": {"section_id": 143, "quality": 1.0, "length": 8}}, "n3337": {"so_22828120_22828304_0": {"section_id": 137, "quality": 0.967741935483871, "length": 30}, "so_22828120_22828304_1": {"section_id": 137, "quality": 1.0, "length": 8}}, "n4659": {"so_22828120_22828304_1": {"section_id": 147, "quality": 1.0, "length": 8}, "so_22828120_22828304_0": {"section_id": 147, "quality": 0.967741935483871, "length": 30}}}, "22828304": {"ParentId": "22828120", "CommentCount": "0", "Body": "<p>From \u00a7 14.5.5.1</p>\n<blockquote>\n<p id=\"so_22828120_22828304_0\">1 When a class template is used in a context that requires an\n  instantiation of the class, it is necessary to determine whether the\n  instantiation is to be generated using the primary template or one of\n  the partial specializations. This is done by matching the template\n  arguments of the class template specialization with the template\n  argument lists of the partial specializations.</p>\n<p id=\"so_22828120_22828304_1\"><strong>\u2014 If exactly one matching specialization is found, the instantiation is generated from\n  that specialization.</strong></p>\n</blockquote>\n", "OwnerUserId": "657267", "PostTypeId": "2", "Id": "22828304", "Score": "3", "CreationDate": "2014-04-03T05:07:23.110", "LastActivityDate": "2014-04-03T05:07:23.110"}});