post_cb({"19307651": {"ParentId": "19307578", "CommentCount": "1", "Body": "<p>The type of <code>f</code> is a built-in type. Operations on objects of built-in types never consider user-define operators. Calling <code>operator+(f, f)</code> explicitly force two conversions which will not happen unless they are forced. The relevant clause is 13.3.1.2 [over.match.oper] paragraph 1:</p>\n<blockquote>\n<p id=\"so_19307578_19307651_0\">If no operand of an operator in an expression has a type that is a class or an enumeration, the operator is assumed to be a built-in operator and interpreted according to Clause 5. ...</p>\n</blockquote>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "19307651", "Score": "2", "CreationDate": "2013-10-10T23:01:53.453", "LastActivityDate": "2013-10-10T23:01:53.453"}, "19307578": {"CommentCount": "3", "ViewCount": "107", "CreationDate": "2013-10-10T22:53:31.800", "LastActivityDate": "2013-10-10T23:01:53.453", "Title": "Difference between a+b and operator+(a,b)", "AcceptedAnswerId": "19307651", "PostTypeId": "1", "Id": "19307578", "Score": "0", "Body": "<p>Consider the following program:</p>\n<pre><code>#include&lt;functional&gt;\n\ntypedef std::function&lt; int( int ) &gt; F;\n\nF operator+( F, F )\n{\n    return F();\n}\n\nint f( int x ) { return x; }\n\nint main()\n{\n    operator+(f,f); // ok\n    f+f; // error: invalid operands to binary expression\n}\n</code></pre>\n<p>Why does the last line <code>f+f;</code> not compile? Why is it not identical to <code>operator+(f,f);</code>? A reference to the standard would be appreciated.</p>\n", "Tags": "<c++><operator-overloading><language-lawyer>", "OwnerUserId": "2073257", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_19307578_19307651_0": {"section_id": 582, "quality": 1.0, "length": 13}}, "n3337": {"so_19307578_19307651_0": {"section_id": 572, "quality": 1.0, "length": 13}}, "n4659": {"so_19307578_19307651_0": {"section_id": 605, "quality": 1.0, "length": 13}}}});