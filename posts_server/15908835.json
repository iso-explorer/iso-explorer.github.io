post_cb({"15909202": {"PostTypeId": "2", "Body": "<p>Generally it's impossibly. Specifically one can take certain measures to increase the probability:</p>\n<p>Use proper optimization level eg. <code>-O2</code> </p>\n<p>Keep the number of the variables small</p>\n<pre><code>register int a,b,c,d,e,f,g,h,i, ... z;  // can also produce an error\n// results in _spilling_ a register to stack\n// as the CPU runs out of physical registers\n</code></pre>\n<p>Do not take an address of the register variable.  </p>\n<pre><code>register int a;\nint *b = &amp;a;  /* this would be an error in most compilers, but\n                 especially in the embedded world the compilers\n                 release the restrictions */\n</code></pre>\n<p>In some compilers, you can suggest</p>\n<pre><code>register int a asm (\"eax\");  // to put a variable to a specific register\n</code></pre>\n", "LastActivityDate": "2013-04-09T18:01:11.497", "Id": "15909202", "CommentCount": "1", "CreationDate": "2013-04-09T18:01:11.497", "ParentId": "15908835", "Score": "3", "OwnerUserId": "1716339"}, "22896695": {"PostTypeId": "2", "Body": "<p>Here you can use <code>volatile register int i = 10</code> in C++ to ensure <code>i</code> to be stored in register. <code>volatile</code> keyword will not allow the compiler to optimize the variable <code>i</code>. </p>\n", "LastActivityDate": "2014-04-06T16:22:38.993", "Id": "22896695", "CommentCount": "0", "CreationDate": "2014-04-06T16:22:38.993", "ParentId": "15908835", "Score": "0", "OwnerUserId": "1866401"}, "21740289": {"PostTypeId": "2", "Body": "<p>The only way to ensure that you are using a register, is to use inline assembly. But, even if you do this, you are not guaranteed that the compiler won't store your value <em>outside</em> of the inline assembly block. And, of course, your OS may decide to interrupt your program at any point, storing all your registers to memory, in order to give the CPU to another process.</p>\n<p>So, unless you write assembler code within the kernel with all interrupts disabled, there is absolutely no way to ensure that your variable will never hit memory.</p>\n<p>Of course, that is only relevant if you are concerned about safety. From a performance perspective, compiling with <code>-O3</code> is usually enough, the compiler usually does quite a good job at determining which variables to hold in registers. Anyway, storing variables in registers is only one small aspect of performance tuning, the much more important aspect is to ensure that no superfluous or expensive work gets done in the inner loop.</p>\n", "LastActivityDate": "2014-02-12T21:40:18.293", "Id": "21740289", "CommentCount": "0", "CreationDate": "2014-02-12T21:40:18.293", "ParentId": "15908835", "Score": "0", "OwnerUserId": "2445184"}, "15908835": {"ViewCount": "16619", "Body": "<p>I would like some clarification regarding a point about the storage of register variables:\nIs there a way to ensure that if we have declared a register variable in our code, that it will ONLY be stored in a register?</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\nregister int i=10;// how can we ensure this will store in register only.\ni++;\ncout&lt;&lt;i&lt;&lt;endl;\nreturn 0;\n}\n</code></pre>\n", "Title": "How to store a C++ variable in a register", "CreationDate": "2013-04-09T17:43:26.427", "LastActivityDate": "2017-03-26T10:46:49.527", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-03-26T10:46:49.527", "LastEditorUserId": "3204692", "Id": "15908835", "Score": "12", "OwnerUserId": "2205200", "Tags": "<c++><inline-assembly><cpu-registers>", "AnswerCount": "8"}, "bq_ids": {"n4140": {"so_15908835_15908876_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 4903}, "so_15908835_15908876_1": {"length": 21, "quality": 0.8076923076923077, "section_id": 5393}}, "n3337": {"so_15908835_15908876_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 4698}, "so_15908835_15908876_1": {"length": 21, "quality": 0.8076923076923077, "section_id": 5187}}}, "25114581": {"PostTypeId": "2", "Body": "<p>Generally CPP compilers(g++) do quite a few optimizations to the code. So when you declare a register variable, it is not necessary that the compiler will store that value directly in the register. (i.e) the code 'register int x' may not result in compiler storing that int directly in the register. But if we can force the compiler to do so, we may be successful.</p>\n<p>For example, if we use the following piece of code, then we may force the compiler to do what we desire. Compilation of the following piece of code may error out, which indicates that the int is actually getting stored directly in the register.</p>\n<pre><code>int main() {\n    volatile register int x asm (\"eax\"); \n    int y = *(&amp;x);\n    return 0;\n}\n</code></pre>\n<p>For me, g++ compiler is throwing the following error in this case.</p>\n<pre><code>[nsidde@nsidde-lnx cpp]$ g++ register_vars.cpp \nregister_vars.cpp: In function \u2018int main()\u2019:\nregister_vars.cpp:3: error: address of explicit register variable \u2018x\u2019 requested\n</code></pre>\n<p>The line 'volatile register int x asm (\"eax\")' is instructing the compiler that, store the integer x in 'eax' register and in doing so do not do any optimizations. This will make sure that the value is stored in the register directly. That is why accessing the address of the variable is throwing an error.</p>\n<p>Alternatively, the C compiler (gcc), may error out with the following code itself.</p>\n<pre><code>int main() {\n    register int a=10;\n    int c = *(&amp;a);\n    return 0;\n}\n</code></pre>\n<p>For me, the gcc compiler is throwing the following error in this case.</p>\n<pre><code>[nsidde@nsidde-lnx cpp]$ gcc register.c \nregister.c: In function \u2018main\u2019:\nregister.c:5: error: address of register variable \u2018a\u2019 requested\n</code></pre>\n", "LastActivityDate": "2014-08-04T09:12:56.987", "LastEditorUserId": "2604532", "Id": "25114581", "CommentCount": "0", "CreationDate": "2014-08-04T08:32:11.457", "ParentId": "15908835", "Score": "0", "OwnerUserId": "2604532", "LastEditDate": "2014-08-04T09:12:56.987"}, "15908876": {"PostTypeId": "2", "Body": "<p>You can't. It is only a hint to the compiler that suggests that the variable is heavily used. Here's the C99 wording:</p>\n<blockquote>\n<p id=\"so_15908835_15908876_0\">A declaration of an identi\ufb01er for an object with storage-class speci\ufb01er <code>register</code> suggests that access to the object be as fast as possible. The extent to which such suggestions are effective is implementation-de\ufb01ned.</p>\n</blockquote>\n<p>And here's the C++11 wording:</p>\n<blockquote>\n<p id=\"so_15908835_15908876_1\">A <code>register</code> specifier is a hint to the implementation that the variable so declared will be heavily used. [ Note: The hint can be ignored and in most implementations it will be ignored if the address of the variable is taken. This use is deprecated (see D.2). \u2014end note ]</p>\n</blockquote>\n<p>In fact, the <code>register</code> storage class specifier is deprecated in C++11 (Annex D.2):</p>\n<blockquote>\n<p id=\"so_15908835_15908876_2\">The use of the <code>register</code> keyword as a <em>storage-class-specifier</em> (7.1.1) is deprecated.</p>\n</blockquote>\n<p>Note that you cannot take the address of a <code>register</code> variable in C because registers do not have an address. This restriction is removed in C++ and taking the address is pretty much guaranteed to ensure the variable won't end up in a register.</p>\n<p>Many modern compilers simply ignore the <code>register</code> keyword in C++ (unless it is used in an invalid way, of course). They are simply much better at optimizing than they were when the <code>register</code> keyword was useful. I'd expect compilers for niche target platforms to treat it more seriously.</p>\n", "LastActivityDate": "2013-04-10T09:02:08.183", "LastEditorUserId": "150634", "Id": "15908876", "CommentCount": "6", "CreationDate": "2013-04-09T17:45:14.387", "ParentId": "15908835", "Score": "28", "OwnerUserId": "150634", "LastEditDate": "2013-04-10T09:02:08.183"}, "15912791": {"PostTypeId": "2", "Body": "<p>The <code>register</code> keyword has different meanings in C and C++. In C++ it is in fact redundant and seems even to be deprecated nowadays.</p>\n<p>In C it is different. First don't take the name of the keyword literally, it is has not always to do with a \"hardware register\" on a modern CPU. The restriction that is imposed on <code>register</code> variables is that you can't take their address, the <code>&amp;</code> operation is not allowed. This allows you to mark a variable for optimization and ensure that the compiler will shout at you if you try to take its address. In particular a <code>register</code> variable that is also <code>const</code> qualified can never alias, so it is a good candidate for optimization.</p>\n<p>Using <code>register</code> as in C systematically forces you to think of every place where you take the address of a variable. This is probably nothing you would want to do in C++, which heavily relies on references to objects and things like that. This might be a reason why C++ didn't copy this property of <code>register</code> variables from C.</p>\n", "LastActivityDate": "2014-02-12T21:18:22.837", "LastEditorUserId": "366377", "Id": "15912791", "CommentCount": "1", "CreationDate": "2013-04-09T21:22:22.240", "ParentId": "15908835", "Score": "5", "OwnerUserId": "366377", "LastEditDate": "2014-02-12T21:18:22.837"}, "15909542": {"PostTypeId": "2", "Body": "<p>The \"register\" keyword is a remnant of the time when compilers had to fit on machines with 2MB of RAM (shared between 18 terminals with a user logged in on each). Or PC/Home computers with 128-256KB of RAM. At that point, the compiler couldn't really run through a large function to figure out which register to use for which variable, to use the registers most effectively. So if the programmer gave a \"hint\" with <code>register</code>, the compiler would put that in a register (if possible). </p>\n<p>Modern compilers don't fit several times in 2MB of RAM, but they are much more clever at assigning variables to registers. In the example given, I find it very unlikley that the compiler wouldn't put it in a register. Obviously, registers are limited in number, and given a sufficiently complex piece of code, some variables will not fit in registers. But for such a simple example, a modern compiler will make <code>i</code> a register, and it will probably not touch memory until somewhere inside <code>ostream&amp; ostream::operator&lt;&lt;(ostream&amp; os, int x)</code>. </p>\n", "LastActivityDate": "2013-04-09T18:20:26.247", "Id": "15909542", "CommentCount": "2", "CreationDate": "2013-04-09T18:20:26.247", "ParentId": "15908835", "Score": "1", "OwnerUserId": "1919155"}, "15908880": {"PostTypeId": "2", "Body": "<p>It's just a hint to the compiler; you can't <em>force</em> it to place the variable in a register. In any event, the compiler writer probably has much better knowledge of the target architecture than the application programmer, and is therefore better placed to write code that makes register allocation decisions. In other words, you are unlikely to achieve anything by using <code>register</code>.</p>\n", "LastActivityDate": "2013-04-09T17:45:21.930", "Id": "15908880", "CommentCount": "1", "CreationDate": "2013-04-09T17:45:21.930", "ParentId": "15908835", "Score": "3", "OwnerUserId": "367273"}});