post_cb({"3723630": {"ViewCount": "472", "Body": "<p>This was motivated by <a href=\"http://www.aristeia.com/Papers/C++ReportColumns/jan95.pdf\" rel=\"nofollow noreferrer\">this</a> article (page 5)</p>\n<pre><code>template&lt;class T&gt; \nT const &amp;f(T const &amp;a, T const &amp;b){\n    return (a &gt; b ? a : b);\n}\n\ntemplate int const &amp;f&lt;int&gt;(int const &amp;, int const &amp;);\n\nint main(){\n    int x = 0, y = 0;\n    short s = 0;\n    f(x, y);     // OK\n    f(x, s);     // Is this call well-formed?\n}\n</code></pre>\n<p>Is the call <code>'f(x, s)'</code> well-formed? I assumed that since the function template <code>'f'</code> is explicitly instantiated, standard conversions would be applied and hence <code>'short s'</code> would be converted to <code>'int'</code> to match the call to the explicit specialization <code>'f&lt;int&gt;'</code>. But it appears that this is ill-formed?</p>\n<p>Which part of the Standard talks about the applicable rules in this context?</p>\n", "Title": "Explicit Instantiation", "CreationDate": "2010-09-16T04:05:54.687", "LastActivityDate": "2010-09-16T16:54:27.530", "CommentCount": "2", "LastEditDate": "2010-09-16T04:11:23.197", "PostTypeId": "1", "LastEditorUserId": "418110", "Id": "3723630", "Score": "1", "OwnerUserId": "418110", "Tags": "<c++><templates><explicit-specialization>", "AnswerCount": "3"}, "3723640": {"Id": "3723640", "PostTypeId": "2", "Body": "<p>The call <code>f(x, s)</code> is syntactically well-formed, but the compiler will not be able to deduce the template parameter <code>T</code> from it because is could a <code>int</code> or a <code>short</code> (because of the first and second arguments). Instantiating the template does not help, that only indicates the compiler to compile that specialization and add it to the generated object file.</p>\n<p>If you want the call to cast <code>s</code> to a <code>int</code> automatically, use <code>f&lt;int&gt;(x, s)</code>.</p>\n", "LastEditorUserId": "408347", "LastActivityDate": "2010-09-16T16:54:27.530", "Score": "3", "CreationDate": "2010-09-16T04:09:08.747", "ParentId": "3723630", "CommentCount": "6", "OwnerUserId": "408347", "LastEditDate": "2010-09-16T16:54:27.530"}, "3723905": {"Id": "3723905", "PostTypeId": "2", "Body": "<p>No, the call <code>f(x, s)</code> is not well-formed.  Since you do not explicitly state the specialization to be used, the compiler uses argument deduction to attempt to instantiate the function template; this fails because <code>x</code> and <code>s</code> have different types so <code>T</code> is ambiguous.</p>\n<p>The applicable rule is in the specification of the overload resolution process in 13.3.1:</p>\n<blockquote>\n<p id=\"so_3723630_3723905_0\">In each case where a candidate is a function template, candidate function template specializations are generated using template argument deduction (14.8.3, 14.8.2).  Those candidates are then handled as candidate functions in the usual way.</p>\n</blockquote>\n<p>14.8.3/1 is also relevant:</p>\n<blockquote>\n<p id=\"so_3723630_3723905_1\">For each function template, if the argument deduction and checking succeeds, the template arguments (deduced and/or explicit) are used to instantiate a single function template specialization which is added to the candidate functions set to be used in overload resolution.  If, for a given function template, argument deduction fails, no such function is added to the set of candidate functions for that template.</p>\n</blockquote>\n<p>The function template is explicitly instantiated for <code>T = int</code>, but the compiler doesn't know that it should use this instantiation until after it performs template argument deduction to determine what <code>T</code> should be.</p>\n", "LastEditorUserId": "151292", "LastActivityDate": "2010-09-16T15:07:55.663", "Score": "5", "CreationDate": "2010-09-16T05:18:14.730", "ParentId": "3723630", "CommentCount": "5", "OwnerUserId": "151292", "LastEditDate": "2010-09-16T15:07:55.663"}, "bq_ids": {"n4140": {"so_3723630_3723905_0": {"length": 23, "quality": 0.92, "section_id": 571}, "so_3723630_3723905_1": {"length": 33, "quality": 0.8918918918918919, "section_id": 355}}, "n3337": {"so_3723630_3723905_0": {"length": 23, "quality": 0.92, "section_id": 562}, "so_3723630_3723905_1": {"length": 33, "quality": 0.8918918918918919, "section_id": 345}}, "n4659": {"so_3723630_3723905_0": {"length": 23, "quality": 0.92, "section_id": 594}, "so_3723630_3723905_1": {"length": 33, "quality": 0.8918918918918919, "section_id": 365}}}, "3723908": {"Id": "3723908", "PostTypeId": "2", "Body": "<p>An explicitly instantiated specialization doesn't have any higher priority or preferential treatment. It simply exists in its entirety from the point of instantiation. Useful for libraries.</p>\n<p>The compiler simply can't figure out which argument to convert, and gets stuck just as it would without the extra declaration.</p>\n<p>By the way, if you return it a reference to an argument which was converted, it will be dangling once the temporary expires. If the arguments are references to different types, there is no way to properly form the return value.</p>\n<p>Here is my updated <code>min</code>:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt; typename A, typename B &gt;\ntypename std::common_type&lt; A, B &gt;::type // cannot return ref\nmy_min( A const &amp;a, B const &amp;b ) {\n    return a &lt; b? a : b;\n}\n\n // enable_if&lt; is_same&lt; A, B &gt; &gt; the old, return-by-reference impl\n\nint main() {\n    int q = my_min( short(5), long(3) );\n}\n</code></pre>\n", "LastEditorUserId": "153285", "LastActivityDate": "2010-09-16T05:44:43.163", "Score": "1", "CreationDate": "2010-09-16T05:19:29.030", "ParentId": "3723630", "CommentCount": "6", "OwnerUserId": "153285", "LastEditDate": "2010-09-16T05:44:43.163"}});