post_cb({"bq_ids": {"n4140": {"so_48543582_48544108_4": {"length": 10, "quality": 1.0, "section_id": 335}, "so_48543582_48544108_2": {"length": 11, "quality": 1.0, "section_id": 336}, "so_48543582_48544108_1": {"length": 18, "quality": 0.9, "section_id": 336}}, "n3337": {"so_48543582_48544108_4": {"length": 10, "quality": 1.0, "section_id": 325}, "so_48543582_48544108_2": {"length": 11, "quality": 1.0, "section_id": 326}, "so_48543582_48544108_1": {"length": 18, "quality": 0.9, "section_id": 326}}, "n4659": {"so_48543582_48544108_4": {"length": 10, "quality": 1.0, "section_id": 344}, "so_48543582_48544108_2": {"length": 11, "quality": 1.0, "section_id": 345}, "so_48543582_48544108_1": {"length": 18, "quality": 0.9, "section_id": 345}}}, "48543582": {"ViewCount": "109", "Body": "<p><strong>The Problem</strong></p>\n<p>Please bear with me, this is really just an example:</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;iterator&gt;\nstruct foo {\n    static int my_transform(int x) { return x;}\n    static std::vector&lt;int&gt; my_transform(std::vector&lt;int&gt; x){\n        std::vector&lt;int&gt; result;            \n        std::transform(x.begin(),x.end(),std::back_inserter(result),my_transform);\n        return result;\n    }\n};\n</code></pre>\n<p><strong>What I expect to happen</strong></p>\n<p>There are two possible overloads for <code>my_transform</code>, but only one results in a well-formed template instantiation, while for the other the template instantiation is ill-formed. I would expect the ill-formed one to be discarded and the above to compile.</p>\n<p><strong>What really happens</strong></p>\n<pre><code> main.cpp:165:75: error: no matching function for call to\n \u2018transform(std::vector&lt;int&gt;::iterator, std::vector&lt;int&gt;::iterator, \n std::back_insert_iterator&lt;std::vector&lt;int&gt; &gt;, &lt;unresolved overloaded function type&gt;)\u2019\n   std::transform(x.begin(),x.end(),std::back_inserter(result),my_transform);\n                                                               ^\n</code></pre>\n<p><strong>How to fix it</strong></p>\n<p>Casting the function pointer to the right type resolves the ambiguity and it compiles:</p>\n<pre><code>static std::vector&lt;int&gt; foo::my_transform(std::vector&lt;int&gt; x){\n    std::vector&lt;int&gt; result;\n    typedef int (*my_transform_t)(int);     \n    std::transform(x.begin(),\n                   x.end(),\n                   std::back_inserter(result),\n                   static_cast&lt;my_transform_t&gt;(my_transform));\n    return result;\n}\n</code></pre>\n<p><strong>The Question</strong></p>\n<p>What exactly prevents the compiler from choosing the \"correct\" overload? Considering that only one can result in a valid template instantiation there isnt really a ambiguity.</p>\n<p>PS: Note that this is C++98. In C++11 and beyond, the problem can be easily avoided by using lambdas (thanks to @appleapple for pointing that out).</p>\n", "AcceptedAnswerId": "48544108", "Title": "Pick the right overload when passing function pointer to algorithm", "CreationDate": "2018-01-31T13:41:06.110", "LastActivityDate": "2018-01-31T14:34:22.653", "CommentCount": "11", "LastEditDate": "2018-01-31T13:51:19.863", "PostTypeId": "1", "LastEditorUserId": "4117728", "Id": "48543582", "Score": "6", "OwnerUserId": "4117728", "Tags": "<c++><templates><language-lawyer><function-pointers><stl-algorithm>", "AnswerCount": "1"}, "48544108": {"Id": "48544108", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48543582_48544108_0\">Considering that only one can result in a valid template instantiation there isn't really a ambiguity.</p>\n</blockquote>\n<p>But there is! You are just too quick. <code>std::transform</code> takes a template parameter and that parameter needs to be deduced. But you are passing it an overload set and the the parameter can't be deduced.</p>\n<p>You might think that SFINAE also applies here too, but this is not the case. SFINAE happens when substituting template parameters for functions, but nowhere else. Here there is no substitution, because the compiler can't even reach that point because of the overload set deduction failure. Also, SFINAE applies to function parameters, not to the body of the function.</p>\n<p>Basically: the compiler will not instantiate multiple possible templates and look which one is the only one that compiles. That would get complicatd quickly.</p>\n<p>This is described in <a href=\"http://eel.is/c++draft/temp#deduct.type-5.5.1\" rel=\"nofollow noreferrer\">[temp.deduct.type]p5</a>:</p>\n<blockquote>\n<p id=\"so_48543582_48544108_1\">A function parameter for which argument deduction cannot be done because the associated function argument is a function, or <strong>a set of overloaded functions</strong> ([over.over]), and one or more of the following apply:\n  (5.5.1)</p>\n<ul>\n<li><p id=\"so_48543582_48544108_2\"><strong>more than one function matches the function parameter type (resulting in an ambiguous deduction)</strong>, or</p></li>\n<li><p id=\"so_48543582_48544108_3\">[...]</p></li>\n</ul>\n</blockquote>\n<p>And so we have a non-deduced context. What now? According to <a href=\"http://eel.is/c++draft/temp.deduct#type-4.sentence-4\" rel=\"nofollow noreferrer\">[temp.deduct]p4</a>:</p>\n<blockquote>\n<p id=\"so_48543582_48544108_4\">[...]. If a template parameter is used only in non-deduced contexts and is not explicitly specified, template argument deduction fails. [...]</p>\n</blockquote>\n<p>And we're done!</p>\n", "LastEditorUserId": "3980929", "LastActivityDate": "2018-01-31T14:34:22.653", "Score": "4", "CreationDate": "2018-01-31T14:07:02.120", "ParentId": "48543582", "CommentCount": "7", "OwnerUserId": "3980929", "LastEditDate": "2018-01-31T14:34:22.653"}});