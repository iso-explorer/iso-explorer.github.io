post_cb({"bq_ids": {"n4140": {"so_12551884_12551944_1": {"length": 108, "quality": 0.7297297297297297, "section_id": 382}, "so_12551884_12551944_2": {"length": 80, "quality": 0.8602150537634409, "section_id": 382}, "so_12551884_12551944_0": {"length": 27, "quality": 0.7714285714285715, "section_id": 381}}, "n3337": {"so_12551884_12551944_1": {"length": 108, "quality": 0.7297297297297297, "section_id": 373}, "so_12551884_12551944_2": {"length": 82, "quality": 0.8817204301075269, "section_id": 373}, "so_12551884_12551944_0": {"length": 27, "quality": 0.7714285714285715, "section_id": 372}}, "n4659": {"so_12551884_12551944_2": {"length": 80, "quality": 0.8602150537634409, "section_id": 399}, "so_12551884_12551944_0": {"length": 26, "quality": 0.7428571428571429, "section_id": 396}}}, "12551949": {"Id": "12551949", "PostTypeId": "2", "Body": "<p>Both are safe. Temporaries can bind to <code>const</code> references and they last until the expression in which the temporary is bound, is executed. In this case you bind it the constructor argument and it lives until the closing brace of the constructor.</p>\n<p>An analogous phenomenon is using a temporary as a default function argument to a <code>const</code> reference:</p>\n<pre><code>void foo(const someclass&amp; bla = someclass()); // bind const ref with default constructed someclass\n</code></pre>\n", "LastEditorUserId": "256138", "LastActivityDate": "2012-09-23T14:32:55.257", "Score": "1", "CreationDate": "2012-09-23T11:28:49.593", "ParentId": "12551884", "CommentCount": "11", "LastEditDate": "2012-09-23T14:32:55.257", "OwnerUserId": "256138"}, "12551884": {"ViewCount": "232", "Body": "<p>Consider the following code dealing with const references:</p>\n<pre><code>const int &amp; func (const int &amp;x)\n{\n    return x;\n}\n\nstruct Foo {\n    Foo (const int &amp;x)\n    : m_x(x) {}\n\n    const int &amp; getX ()\n    { return m_x; }\n\n    const int &amp;m_x;\n};\n</code></pre>\n<p>I'd like to know which, if any, of the following is now allowed:</p>\n<pre><code>int x = func(int(7));\nint y = Foo(int(7)).getX();\n</code></pre>\n<p>Is there any guarantee that the temporary <code>int</code> object still exists before it is used by the assignment or <code>getX</code>?.</p>\n<p><strong>UPDATE</strong>: So it appears this is safe - but why exactly?</p>\n<ol>\n<li>Is it because temporaries bind to const references recursively and are guaranteed to exist as long as of those bound references to them exists?</li>\n<li>Or is it because they are guaranteed to exist for the duration of the full expression?</li>\n</ol>\n<p>Consider the edge case which stores a pointer instead of a reference:</p>\n<pre><code>struct Foo {\n    Foo (const int &amp;x)\n    : m_x(&amp;x) {}\n\n    const int &amp; getX ()\n    { return *m_x; }\n\n    const int *m_x;\n};\n\nint y = Foo(int(7)).getX();\n</code></pre>\n<p>It seems that if case 1) was correct, this would not work. But if case 2) was correct, it would.</p>\n", "AcceptedAnswerId": "12551944", "Title": "C++ return reference to temporaries or store them in objects", "CreationDate": "2012-09-23T11:19:29.500", "Id": "12551884", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-09-23T11:57:47.297", "LastEditorUserId": "1020667", "LastActivityDate": "2012-09-23T14:32:55.257", "Score": "5", "OwnerUserId": "1020667", "Tags": "<c++><reference><return><temporary>", "AnswerCount": "2"}, "12551944": {"Id": "12551944", "PostTypeId": "2", "Body": "<p>Both are safe, because you copy the values into <code>x</code> and <code>y</code>. The temporaries are valid until the end of the full expression.</p>\n<h3>12.2 Temporary objects</h3>\n<blockquote>\n<p id=\"so_12551884_12551944_0\">4) There are two contexts in which temporaries are destroyed at a\n  different point than the end of the full-expression. The first context\n  is when a default constructor is called to initialize an element of an\n  array. If the constructor has one or more default arguments, any\n  temporaries created in the default argument expressions are destroyed\n  immediately after return from the constructor. </p>\n<p id=\"so_12551884_12551944_1\">5) The second context is\n  when a reference is bound to a temporary. The temporary to which the\n  reference is bound or the temporary that is the complete object of a\n  subobject to which the reference is bound persists for the lifetime of\n  the reference except as specified below. A temporary bound to a\n  reference member in a constructor\u2019s ctor-initializer (12.6.2) persists\n  until the constructor exits. A temporary bound to a reference\n  parameter in a function call (5.2.2) persists until the completion of\n  the full expression containing the call. A temporary bound to the\n  returned value in a function return statement (6.6.3) persists until\n  the function exits. In all these cases, the temporaries created during\n  the evaluation of the expression initializing the reference, except\n  the temporary to which the reference is bound, are destroyed at the\n  end of the full-expression in which they are created and in the\n  reverse order of the completion of their construction. If the lifetime\n  of two or more temporaries to which references are bound ends at the\n  same point, these temporaries are destroyed at that point in the\n  reverse order of the completion of their construction. In addition,\n  the destruction of temporaries bound to references shall take into\n  account the ordering of destruction of objects with static or\n  automatic storage duration (3.7.1,\n  3.7.2); that is, if obj1 is an object with static or automatic storage duration created before the temporary is created, the temporary shall\n  be destroyed before obj1 is destroyed; if obj2 is an object with\n  static or automatic storage duration created after the temporary is\n  created, the temporary shall be destroyed after obj2 is destroyed. [\n  Example: </p>\n</blockquote>\n<pre><code>class C \n{ \n/ / ... \npublic : \n    C(); \n    C(int ); \n    friend C operator +(const C&amp;, const C&amp;); \n    ~C(); \n}; \nC obj1 ; \nconst C&amp; cr = C (16)+ C (23); \nC obj2 ; \n</code></pre>\n<blockquote>\n<p id=\"so_12551884_12551944_2\">the\n  expression C(16)+C(23) creates three temporaries. A first temporary T1\n  to hold the result of the expression C(16), a second temporary T2 to\n  hold the result of the expression C(23), and a third temporary T3 to\n  hold the result of the addition of these two expressions. The\n  temporary T3 is then bound to the reference cr. It is unspecified\n  whether T1 or T2 is created first. On an implementation where T1 is\n  created before T2, it is guaranteed that T2 is destroyed before T1.\n  The temporaries T1 and T2 are bound to the reference parameters of\n  operator+; these temporaries are destroyed at the end of the full\n  expression containing the call to operator+. The temporary T3 bound to\n  the reference cr is destroyed at the end of cr\u2019s lifetime, that is, at\n  the end of the program. In addition, the order in which T3 is\n  destroyed takes into account the destruction order of other objects\n  with static storage duration. That is, because obj1 is constructed\n  before T3, and T3 is constructed before obj2, it is guaranteed that\n  obj2 is destroyed before T3, and that T3 is destroyed before obj1.\n  \u2014end example ]</p>\n</blockquote>\n", "LastEditorUserId": "673730", "LastActivityDate": "2012-09-23T12:17:00.353", "Score": "7", "CreationDate": "2012-09-23T11:27:47.273", "ParentId": "12551884", "CommentCount": "11", "LastEditDate": "2012-09-23T12:17:00.353", "OwnerUserId": "673730"}});