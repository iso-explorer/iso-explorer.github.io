post_cb({"28908765": {"ParentId": "28908636", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The explicit destructor declaration (and definition) suppresses the implicit declaration of the move constructor and the move assignment operator. Thus the only thing that can be used is the copy constructor (which is implicitly declared no matter what) - but it's defined as deleted because <code>unique_ptr</code>s are not copyable. Hence the error.</p>\n<p>Explicitly default them - and the default constructor too since you have a user-declared constructor now:</p>\n<pre><code>Foo() = default;\nFoo(Foo&amp;&amp;) = default;\nFoo&amp; operator=(Foo&amp;&amp;) = default;\n</code></pre>\n<blockquote>\n<p id=\"so_28908636_28908765_0\">Why wouldn't it (the copy constructor) be implicitly deleted if I remove the destructor?</p>\n</blockquote>\n<p>It's still implicitly deleted. But since now a move constructor is implicitly declared, the move constructor can used for moving, and the copy constructor simply isn't used.</p>\n<hr>\n<p>Relevant standard quote (\u00a712.8 [class.copy]/p9, 20, emphasis added):</p>\n<blockquote>\n<p id=\"so_28908636_28908765_1\">9 If the definition of a class <code>X</code> does not explicitly declare a move\n  constructor, one will be implicitly declared as defaulted if and only\n  if</p>\n<ul>\n<li><code>X</code> does not have a user-declared copy constructor,</li>\n<li><code>X</code> does not have a user-declared copy assignment operator,</li>\n<li><code>X</code> does not have a user-declared move assignment operator, and</li>\n<li><strong><code>X</code> does not have a user-declared destructor</strong>.</li>\n</ul>\n<p id=\"so_28908636_28908765_2\">20 If the definition of a class <code>X</code> does not explicitly declare a move\n  assignment operator, one will be implicitly declared as defaulted if\n  and only if</p>\n<ul>\n<li><code>X</code> does not have a user-declared copy constructor,</li>\n<li><code>X</code> does not have a user-declared move constructor,</li>\n<li><code>X</code> does not have a user-declared copy assignment operator, and</li>\n<li><strong><code>X</code> does not have a user-declared destructor</strong>.</li>\n</ul>\n</blockquote>\n</hr>", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2015-03-06T22:46:10.627", "Id": "28908765", "Score": "7", "CreationDate": "2015-03-06T22:29:24.523", "LastActivityDate": "2015-03-06T22:46:10.627"}, "28908636": {"CommentCount": "0", "AcceptedAnswerId": "28908765", "PostTypeId": "1", "LastEditorUserId": "241631", "CreationDate": "2015-03-06T22:18:57.013", "LastActivityDate": "2015-03-06T22:46:10.627", "LastEditDate": "2015-03-06T22:30:29.343", "ViewCount": "607", "FavoriteCount": "1", "Title": "Class with explicit destructor and std::unique_ptr<> member can't be used in std::vector<>?", "Id": "28908636", "Score": "2", "Body": "<p>This code</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;vector&gt;\n\nclass Foo\n{\npublic:\n    ~Foo()\n    {\n    }\n\n    std::unique_ptr&lt;int&gt; bar;\n};\n\nint main()\n{\n    std::vector&lt;Foo&gt; foos;\n    foos.emplace_back();\n}\n</code></pre>\n<p>yields the following error message in g++:</p>\n<pre><code>In file included from /usr/include/c++/4.8/memory:64:0,\n                 from main.cpp:1:\n/usr/include/c++/4.8/bits/stl_construct.h: In instantiation of \u2018void std::_Construct(_T1*, _Args&amp;&amp; ...) [with _T1 = Foo; _Args = {Foo}]\u2019:\n/usr/include/c++/4.8/bits/stl_uninitialized.h:75:53:   required from \u2018static _ForwardIterator std::__uninitialized_copy&lt;_TrivialValueTypes&gt;::__uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = std::move_iterator&lt;Foo*&gt;; _ForwardIterator = Foo*; bool _TrivialValueTypes = false]\u2019\n/usr/include/c++/4.8/bits/stl_uninitialized.h:117:41:   required from \u2018_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = std::move_iterator&lt;Foo*&gt;; _ForwardIterator = Foo*]\u2019\n/usr/include/c++/4.8/bits/stl_uninitialized.h:258:63:   required from \u2018_ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator, std::allocator&lt;_Tp&gt;&amp;) [with _InputIterator = std::move_iterator&lt;Foo*&gt;; _ForwardIterator = Foo*; _Tp = Foo]\u2019\n/usr/include/c++/4.8/bits/stl_uninitialized.h:281:69:   required from \u2018_ForwardIterator std::__uninitialized_move_if_noexcept_a(_InputIterator, _InputIterator, _ForwardIterator, _Allocator&amp;) [with _InputIterator = Foo*; _ForwardIterator = Foo*; _Allocator = std::allocator&lt;Foo&gt;]\u2019\n/usr/include/c++/4.8/bits/vector.tcc:415:43:   required from \u2018void std::vector&lt;_Tp, _Alloc&gt;::_M_emplace_back_aux(_Args&amp;&amp; ...) [with _Args = {}; _Tp = Foo; _Alloc = std::allocator&lt;Foo&gt;]\u2019\n/usr/include/c++/4.8/bits/vector.tcc:101:54:   required from \u2018void std::vector&lt;_Tp, _Alloc&gt;::emplace_back(_Args&amp;&amp; ...) [with _Args = {}; _Tp = Foo; _Alloc = std::allocator&lt;Foo&gt;]\u2019\nmain.cpp:17:23:   required from here\n/usr/include/c++/4.8/bits/stl_construct.h:75:7: error: use of deleted function \u2018Foo::Foo(const Foo&amp;)\u2019\n     { ::new(static_cast&lt;void*&gt;(__p)) _T1(std::forward&lt;_Args&gt;(__args)...); }\n       ^\nmain.cpp:4:7: note: \u2018Foo::Foo(const Foo&amp;)\u2019 is implicitly deleted because the default definition would be ill-formed:\n class Foo\n       ^\nmain.cpp:4:7: error: use of deleted function \u2018std::unique_ptr&lt;_Tp, _Dp&gt;::unique_ptr(const std::unique_ptr&lt;_Tp, _Dp&gt;&amp;) [with _Tp = int; _Dp = std::default_delete&lt;int&gt;]\u2019\nIn file included from /usr/include/c++/4.8/memory:81:0,\n                 from main.cpp:1:\n/usr/include/c++/4.8/bits/unique_ptr.h:273:7: error: declared here\n       unique_ptr(const unique_ptr&amp;) = delete;\n</code></pre>\n<p>yet if I remove the <code>~Foo()</code> implementation (and declaration) it compiles just fine.\nThe same behaviour can be observed would <code>main()</code> look like this:</p>\n<pre><code>int main()\n{\n    auto f = Foo();\n}\n</code></pre>\n<ul>\n<li><p>Why is the copy constructor of <code>Foo</code> being called anyway? Shouldn't everything here happen via move semantics? </p></li>\n<li><p>Why wouldn't it (the copy constructor) be implicitly deleted if I remove the destructor?</p></li>\n</ul>\n", "Tags": "<c++><c++11><move-semantics>", "OwnerUserId": "2861516", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_28908636_28908765_0": {"section_id": 456, "quality": 0.625, "length": 5}, "so_28908636_28908765_1": {"section_id": 458, "quality": 1.0, "length": 12}, "so_28908636_28908765_2": {"section_id": 469, "quality": 1.0, "length": 13}}, "n3337": {"so_28908636_28908765_0": {"section_id": 447, "quality": 0.625, "length": 5}, "so_28908636_28908765_1": {"section_id": 449, "quality": 1.0, "length": 12}, "so_28908636_28908765_2": {"section_id": 460, "quality": 1.0, "length": 13}}, "n4659": {"so_28908636_28908765_0": {"section_id": 479, "quality": 0.625, "length": 5}, "so_28908636_28908765_1": {"section_id": 481, "quality": 1.0, "length": 12}, "so_28908636_28908765_2": {"section_id": 492, "quality": 1.0, "length": 13}}}, "28908770": {"ParentId": "28908636", "CommentCount": "0", "Body": "<p><code>Foo</code> is not copyable since it has a member <code>unique_ptr</code>. <code>Foo</code> is also not <em>movable</em> because declaration of a user-provided destructor suppresses the implicit generation of the default move constructor / assignment. If you want <code>Foo</code> to be movable default the move constructor/assignment so the compiler will generate them for you:</p>\n<pre><code>class Foo\n{\npublic:\n    ~Foo()\n    {\n    }\n\n    Foo(Foo&amp;&amp;) = default;\n    Foo&amp; operator=(Foo&amp;&amp;) = default;\n\n    std::unique_ptr&lt;int&gt; bar;\n};\n</code></pre>\n", "OwnerUserId": "923854", "PostTypeId": "2", "Id": "28908770", "Score": "2", "CreationDate": "2015-03-06T22:29:35.870", "LastActivityDate": "2015-03-06T22:29:35.870"}});