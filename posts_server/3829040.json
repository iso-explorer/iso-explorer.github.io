post_cb({"3829146": {"ParentId": "3829040", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_3829040_3829146_0\">Not writing Type here gives error, why?</p>\n</blockquote>\n<p>If you omit <code>Type</code> there is no way for the compiler to decide whether <code>Base</code> is a base class or is it a member of <code>Derived</code>. Specifying <code>Type</code> makes sure that <code>Base</code> is a template class [base class].</p>\n<blockquote>\n<p id=\"so_3829040_3829146_1\">'member' was not declared in this scope</p>\n</blockquote>\n<p>This is something to do with the rules for name lookup (dependent base classes).</p>\n<p>C++03 [Section 14.6/8] says</p>\n<blockquote>\n<p id=\"so_3829040_3829146_2\">When looking for the declaration of a name used in a template definition, the usual lookup rules (3.4.1, 3.4.2) are used for nondependent names. The lookup of names dependent on the template parameters is <strong>postponed until the actual template argument is known</strong> (14.6.2).</p>\n</blockquote>\n<p>Now <code>Section 14.6.2/3</code> says</p>\n<blockquote>\n<p id=\"so_3829040_3829146_3\">In the definition of a class template or a member of a class template, <strong>if a base class of the class template depends on a template-parameter, the base class scope is not examined during unqualified name lookup either at the point of definition of the class template or member or during an instantiation of the class template or member.</strong></p>\n</blockquote>\n<p><code>member</code> is an unqualified name so the base class is not examined. </p>\n<p>So you have two options.</p>\n<ol>\n<li>Use fully qualified name of <code>Member</code> i.e <code>Base&lt;Type&gt;::member</code><br/></li>\n<li>Use <code>this-&gt;member</code>.</li>\n</ol>\n", "OwnerUserId": "165520", "LastEditorUserId": "165520", "LastEditDate": "2010-09-30T09:04:30.907", "Id": "3829146", "Score": "8", "CreationDate": "2010-09-30T08:58:34.337", "LastActivityDate": "2010-09-30T09:04:30.907"}, "3829128": {"ParentId": "3829040", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Your question is somewhat confusing. At first I thought you were asking about <code>base&lt;Type&gt;</code> in the member initialization list, then I thought you were asking about accessing <code>member</code>, then back to the first... Now I'm thinking you're asking both, so I'll answer both. </p>\n<hr>\n<blockquote>\n<p id=\"so_3829040_3829128_0\">Not writing Type here gives error, why?</p>\n</blockquote>\n<p>When you use a class template's name (<code>my_class_templ</code>), it refers to the <em>template</em>, which is not a type. In order to use it as a type, you need to provide template parameters (<code>my_class_templ&lt;int&gt;</code>, <code>my_class_templ&lt;T&gt;</code>). So wherever a type name is needed (and that includes the base class names in an initialization list), you need to provide template parameters. </p>\n<p><em>You can omit the template parameter list</em> for class templates names within the class template's definition. For example, a copy constructor can be declared as </p>\n<pre><code> my_class_templ(const my_class_templ&amp; rhs);\n</code></pre>\n<p>instead of </p>\n<pre><code> my_class_templ&lt;T&gt;(const my_class_templ&lt;T&gt;&amp; rhs);\n</code></pre>\n<p>This is just a little syntactic sugar, allowing you to type less. </p>\n<p>However, outside of the class templates definition, you need to explicitly spell out all the template parameters. This is also true for derived classes: </p>\n<pre><code>my_dervied_class_templ(const my_derived_class_templ&amp; rhs)\n : my_class_templ&lt;T&gt;(rhs)                          // need to spell out &lt;T&gt; here\n{\n}\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_3829040_3829128_1\">I get error <code>'member' was not declared in this scope</code>. How to fix the problems?</p>\n</blockquote>\n<p>When your template is encountered first by the compiler, there's only its definition and no instantiations have been seen by the compiler yet. The compiler doesn't know whether, at a point of instantiation, there might be specializations of the template in scope or not. However, you could specialize your template for <code>Base&lt;T&gt;::member</code> to refer to something else or not to be defined entirely. (Say, a specialization <code>Base&lt;void&gt;</code> doesn't have a data member.) Therefore, the compiler must not speculate about the members of <code>Base</code>. Consequentially, they will not be looked up in <code>Derived</code>. </p>\n<p>The result of this is that, if you need to refer to one of the members of <code>Base</code>, you need to tell the compiler that you expect a <code>Base&lt;T&gt;</code> to have such a member. This is done by fully qualifying its name: <code>Base&lt;Type&gt;::member</code>. </p>\n</hr></hr>", "OwnerUserId": "140719", "LastEditorUserId": "140719", "LastEditDate": "2012-04-13T11:29:20.700", "Id": "3829128", "Score": "10", "CreationDate": "2010-09-30T08:56:20.340", "LastActivityDate": "2012-04-13T11:29:20.700"}, "3829161": {"ParentId": "3829040", "CommentCount": "0", "Body": "<p>The C++ standard requires a compiler to do a \"two phase lookup\" for templates. That is, they are trying to resolve all non-dependent names (names that don't depend on template parameters) in the first phase when the template is parsed and all the dependent names in the second phase when the template is instantiated.</p>\n<p>If you don't qualify <code>member</code> it is treated as a non-dependent name and lookup fails in the first phase. You can solve this by prepending <code>this-&gt;</code> to it. This makes <code>member</code> a dependent name and lookup is delayed until you actually instantiate the template.</p>\n", "OwnerUserId": "172531", "PostTypeId": "2", "Id": "3829161", "Score": "2", "CreationDate": "2010-09-30T09:00:55.657", "LastActivityDate": "2010-09-30T09:00:55.657"}, "3829138": {"ParentId": "3829040", "PostTypeId": "2", "CommentCount": "3", "Body": "<pre><code>Derived(Type param):Base&lt;Type&gt;(param){ \n</code></pre>\n<p>That <code>Base&lt;Type&gt;</code> is required because the base of Derived is <code>Base&lt;T&gt;</code>. There is nothing called <code>Base</code>.</p>\n<pre><code>void display()   \n{   \n        //cout &lt;&lt; member; /** ERROR HERE **/ \n        cout &lt;&lt; this-&gt;member;\n        cout &lt;&lt; this&gt;Base&lt;Type&gt;::member;  \n}\n</code></pre>\n<p>Alternatively having a using declaration in the scope of 'Derived' is also a valid technique.</p>\n", "OwnerUserId": "418110", "LastEditorUserId": "2971", "LastEditDate": "2010-09-30T09:01:22.257", "Id": "3829138", "Score": "0", "CreationDate": "2010-09-30T08:57:39.687", "LastActivityDate": "2010-09-30T09:01:22.257"}, "3829040": {"CommentCount": "0", "AcceptedAnswerId": "3829128", "PostTypeId": "1", "LastEditorUserId": "165520", "CreationDate": "2010-09-30T08:40:44.473", "LastActivityDate": "2012-04-13T11:29:20.700", "LastEditDate": "2010-09-30T13:26:52.637", "ViewCount": "2149", "FavoriteCount": "1", "Title": "Scope problems in template C++", "Id": "3829040", "Score": "1", "Body": "<p>Is there any scope problem in this program?</p>\n<pre><code>#include&lt;iostream&gt;\n\nusing namespace std;\n\ntemplate&lt;class Type&gt;\nclass Base\n{\n   public:\n   Type member;\n   Base(Type param): member(param){\n\n   }\n};\n\ntemplate&lt;class Type&gt;\nclass Derived: public Base&lt;Type&gt;\n{\n    public:               \n    Derived(Type param):Base&lt;Type&gt;(param){\n     //                       ^\n     //                       |_______  Not writing Type here gives error, why?\n    }\n    void display()\n    {\n        cout &lt;&lt; member; /** ERROR HERE **/\n    }\n};\n\nint main()\n{\n   Derived&lt;int&gt; p(5);\n   p.display();\n   return 0;\n}\n</code></pre>\n<p>I get error <code>'member' was not declared in this scope</code>. How to fix the problems?</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "165520", "AnswerCount": "5"}, "3829065": {"ParentId": "3829040", "CommentCount": "3", "Body": "<p>At the point where the compiler reads the template (not when it instanciates it), it cannot tell what <code>Base&lt;Type&gt;</code> is (it could be specialized), and therefore doesn't attempt to deduce it has a <code>member</code> member. You have to explicitely tell it: <code>cout &lt;&lt; this-&gt;Base&lt;Type&gt;::member;</code>.</p>\n<p>I think (check it, I'm not sure) that a <code>using Base&lt;Type&gt;::member</code> at class scope works too.</p>\n", "OwnerUserId": "373025", "PostTypeId": "2", "Id": "3829065", "Score": "2", "CreationDate": "2010-09-30T08:44:25.997", "LastActivityDate": "2010-09-30T08:44:25.997"}, "bq_ids": {"n4140": {"so_3829040_3829146_3": {"section_id": 190, "quality": 0.8709677419354839, "length": 27}, "so_3829040_3829146_2": {"section_id": 176, "quality": 0.8461538461538461, "length": 22}}, "n3337": {"so_3829040_3829146_3": {"section_id": 184, "quality": 0.8709677419354839, "length": 27}, "so_3829040_3829146_2": {"section_id": 170, "quality": 0.8461538461538461, "length": 22}}, "n4659": {"so_3829040_3829146_3": {"section_id": 195, "quality": 0.7096774193548387, "length": 22}, "so_3829040_3829146_2": {"section_id": 181, "quality": 0.8461538461538461, "length": 22}}}});