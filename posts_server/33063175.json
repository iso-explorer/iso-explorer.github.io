post_cb({"bq_ids": {"n4140": {"so_33063175_33063175_3": {"length": 6, "quality": 0.6, "section_id": 469}, "so_33063175_33063348_0": {"length": 12, "quality": 1.0, "section_id": 458}}, "n3337": {"so_33063175_33063175_3": {"length": 7, "quality": 0.7, "section_id": 460}, "so_33063175_33063348_0": {"length": 12, "quality": 1.0, "section_id": 449}}, "n4659": {"so_33063175_33063175_3": {"length": 6, "quality": 0.6, "section_id": 492}, "so_33063175_33063348_0": {"length": 12, "quality": 1.0, "section_id": 481}}}, "33063348": {"Id": "33063348", "PostTypeId": "2", "Body": "<p>The problem is that your <code>uncopiable</code> class is not moveable. Therefore the <code>default</code> move constructor / assignment operator of the derived class try to use the <code>delete</code>d copy versions.</p>\n<pre><code>static_assert(std::is_move_constructible&lt;uncopiable&gt;::value, \"\");  // fails\nstatic_assert(std::is_move_assignable&lt;uncopiable&gt;::value, \"\");     // fails\n</code></pre>\n<p>The reason for this is \u00a7 12.8 \u00b6 9:</p>\n<blockquote>\n<p id=\"so_33063175_33063348_0\">If the definition of a class <code>X</code> does not explicitly declare a move constructor, one will be implicitly declared as defaulted if and only if</p>\n<ul>\n<li><code>X</code> does not have a user-declared copy constructor,</li>\n<li><code>X</code> does not have a user-declared copy assignment operator,</li>\n<li><code>X</code> does not have a user-declared move assignment operator, and</li>\n<li><code>X</code> does not have a user-declared destructor.</li>\n</ul>\n</blockquote>\n<p>Declaring a copy operator or assignment operator as <code>delete</code>d still counts as declaring it.</p>\n<p>The solution is of course to declare the move operations for <code>uncopiable</code>.</p>\n<pre><code>uncopiable(uncopiable&amp;&amp;) noexcept = default;\nuncopiable&amp; operator=(uncopiable&amp;&amp;) noexcept = default;\n</code></pre>\n<p>Note that the <a href=\"https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-move-noexcept\" rel=\"nofollow\">move operations should usually be declared <code>noexcept</code></a>.  Especially if you want to use the type in a <code>std::vector</code> like in your example.</p>\n", "LastActivityDate": "2015-10-11T09:12:33.520", "Score": "4", "CreationDate": "2015-10-11T09:12:33.520", "ParentId": "33063175", "CommentCount": "2", "OwnerUserId": "1392132"}, "33063175": {"ViewCount": "137", "Body": "<p>Take a look a the following code example which uses class <code>uncopiable</code> similar to <code>boost::noncopyable</code>:</p>\n<pre><code>#include &lt;vector&gt;\n\nclass uncopiable {\n    using self = uncopiable;\nprotected:\n    uncopiable() {}\n    ~uncopiable() {}\n    uncopiable(const self&amp;) = delete;\n    self&amp; operator=(const self&amp;) = delete;\n};\n\nstruct A {\n    struct B : uncopiable {\n        using self = B;\n\n        B() {\n        }\n\n        B(B&amp;&amp;) = default;\n        self&amp; operator=(B&amp;&amp;) = default;\n\n        ~B() {\n        }\n    };\n\n    A() { v.emplace_back(); }\n    ~A() {}\n\nprivate:\n    std::vector&lt;B&gt; v;\n};\n\nint main () {}\n</code></pre>\n<p>Since I wanted to make inner class move only I explicitly specified its move constructor and assignment operator to be default ones but also since I've heard that it's a good practice to specify all of the \"special member functions\" in such case I inherited it from <code>uncopiable</code>. The problem is that compilation fails with every compiler and something similar to the following error message is displayed (this message is excerpt from the clang one):</p>\n<blockquote>\n<p id=\"so_33063175_33063175_0\">/usr/include/c++/v1/memory:1645:31: error: call to implicitly-deleted copy constructor of 'A::B'</p>\n<p id=\"so_33063175_33063175_1\">...</p>\n<p id=\"so_33063175_33063175_2\">main.cpp:26:10: note: in instantiation of function template specialization 'std::__1::vector &gt;::emplace_back&lt;&gt;' requested here</p>\n<p id=\"so_33063175_33063175_3\">main.cpp:19:3: note: copy constructor is implicitly deleted because 'B' has a user-declared move constructor</p>\n</blockquote>\n<p>It could be fixed by removing inheritance (copy operations would still not be created). But writing copy operations to be explicitly deleted inside class after that is also okay.</p>\n<p>My questions are: why does it happen? Could it be considered a deficiency of disabling constructors/assignment operators through inheritance of helper classes?</p>\n", "AcceptedAnswerId": "33063348", "Title": "Code unexpectedly fails to compile. Why?", "CreationDate": "2015-10-11T08:53:38.920", "Id": "33063175", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-10-11T09:02:18.537", "LastEditorUserId": "560648", "LastActivityDate": "2015-10-11T09:26:44.430", "Score": "3", "OwnerUserId": "1269661", "Tags": "<c++><c++11><inheritance><inner-classes><move-constructor>", "AnswerCount": "2"}, "33063455": {"Id": "33063455", "PostTypeId": "2", "Body": "<p>This compiles ok on MinGw:</p>\n<pre><code>#include &lt;vector&gt;\n\nclass uncopiable {\n    using self = uncopiable;\nprotected:\n    uncopiable() {}\n    ~uncopiable() {}\n    uncopiable(const self&amp;) = delete;\n    self&amp; operator=(const self&amp;) = delete;\n};\n\nstruct A {\n    struct B : uncopiable {\n        using self = B;\n\n        B() {\n        }\n\n        B(B&amp;&amp;) {};\n        self&amp; operator=(B&amp;&amp;) = default;\n\n        ~B() {\n        }\n    };\n\n    A() { v.emplace_back(); }\n    ~A() {}\n\nprivate:\n    std::vector&lt;B&gt; v;\n};\n\nint main () {\n    A* a = new A();\n}\n</code></pre>\n", "LastActivityDate": "2015-10-11T09:26:44.430", "Score": "0", "CreationDate": "2015-10-11T09:26:44.430", "ParentId": "33063175", "CommentCount": "0", "OwnerUserId": "1894478"}});