post_cb({"991085": {"ParentId": "991062", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Why should you create an anonymous class when you want to pass it to a function?</p>\n<p>Just explicitly declare the class:</p>\n<pre><code>class Foo {\n  // ...\n};\n\nvoid Method(Foo instance); \n\nint main() {\n    Foo bar;\n    Method(bar);\n}\n</code></pre>\n<p>The 2nd possibility would be using a template-function, so the compiler would infer the type (Note that this is not standard-compatible!)</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;typename T&gt;\nvoid SayFoo(T&amp; arg) {\n    arg.Foo();\n}\n\nint main() {\n\n    class {\n    public: \n        void Foo() { cout &lt;&lt; \"Hi\" &lt;&lt; endl; }\n    } Bar;\n\n    Bar.Foo();\n\n    SayFoo(Bar);\n\n    return 0;\n}\n</code></pre>\n<p>There is no problem with copying the class since the compiler generated the copy constructor automatically and you can use tools like <a href=\"http://www.boost.org/doc/libs/1_35_0/doc/html/typeof.html\" rel=\"nofollow noreferrer\">boost::typeof</a> in order to avoid referring to the type explicitly.</p>\n<pre><code>BOOST::AUTO(copy, Bar);\n</code></pre>\n<p>Another approch is using (relatively slow) runtime-polymorphism (interfaces/inheritance).</p>\n", "OwnerUserId": "105459", "LastEditorUserId": "105459", "LastEditDate": "2009-06-13T18:12:50.817", "Id": "991085", "Score": "2", "CreationDate": "2009-06-13T17:18:24.833", "LastActivityDate": "2009-06-13T18:12:50.817"}, "991071": {"ParentId": "991062", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Hmmm, nameless class.</p>\n<p>You could pass a pointer to it as void *.</p>\n<p>Since you cannot refer to it by name, you cannot call its constructor, copy constructor, or destructor except for the one instance, so you cannot copy it.</p>\n<p>EDIT: you could still pass it to a template function which could copy it.</p>\n<p>REEDIT: edit was wrong.</p>\n", "OwnerUserId": "14768", "LastEditorUserId": "14768", "LastEditDate": "2009-06-13T18:49:34.940", "Id": "991071", "Score": "-1", "CreationDate": "2009-06-13T17:12:49.277", "LastActivityDate": "2009-06-13T18:49:34.940"}, "991069": {"ParentId": "991062", "CommentCount": "0", "Body": "<p>Yes you have to name the class to pass it a instance of to the function. As you have not provided your own copy ctor compiler will generate its own and use it.</p>\n", "OwnerUserId": "39742", "PostTypeId": "2", "Id": "991069", "Score": "0", "CreationDate": "2009-06-13T17:12:20.370", "LastActivityDate": "2009-06-13T17:12:20.370"}, "991162": {"ParentId": "991062", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Maybe it would be better if you explicit what you want to do. Why do you want to create an unnamed class? Does it conform to an interface? Unnamed classes are quite limited, they cannot be used as parameters to functions, they cannot be used as template type-parameters...</p>\n<p>Now if you are implmenting an interface then you can pass references to that interface:</p>\n<pre><code>class interface {\npublic:\n   virtual void f() const = 0;\n};\nvoid function( interface const&amp; o )\n{\n   o.f();\n}\nint main()\n{\n   class : public interface {\n   public:\n      virtual void f() const {\n         std::cout &lt;&lt; \"bar\" &lt;&lt; std::endl;\n      }\n   } bar;\n   function( bar ); // will printout \"bar\"\n}\n</code></pre>\n<p>NOTE: For all those answers that consider template arguments as an option, unnamed classes cannot be passed as template type arguments.</p>\n<p>C++ Standard. 14.3.1, paragraph 2:</p>\n<blockquote>\n<p id=\"so_991062_991162_0\">2 A local type, a type with no\n  linkage, an unnamed type or a type\n  compounded from any of these types\n  shall not be used as a\n  template-argument for a template\n  type-parameter.</p>\n</blockquote>\n<p>If you test with <a href=\"http://www.comeaucomputing.com/tryitout/\" rel=\"nofollow noreferrer\">comeau</a> compiler (the link is for the online tryout) you will get the following error:</p>\n<blockquote>\n<p id=\"so_991062_991162_1\">error: a template argument may not\n  reference an unnamed type</p>\n</blockquote>\n<p>As a side note, comeau compiler is the most standard compliant compiler I know of, besides being the one with the most helpful error diagnostics I have tried.</p>\n<p>NOTE: Comeau and gcc (g++ 4.0) give an error with the code above. Intel compiler (and from other peoples comments MSVS 2008) accept using unnamed classes as template parameters, against the standard.</p>\n", "OwnerUserId": "36565", "LastEditorUserId": "36565", "LastEditDate": "2009-06-13T23:20:49.127", "Id": "991162", "Score": "6", "CreationDate": "2009-06-13T17:54:02.483", "LastActivityDate": "2009-06-13T23:20:49.127"}, "991062": {"CommentCount": "0", "ViewCount": "3239", "CreationDate": "2009-06-13T17:09:29.520", "LastActivityDate": "2009-06-13T23:20:49.127", "Title": "Passing unnamed classes through functions", "AcceptedAnswerId": "991162", "PostTypeId": "1", "Id": "991062", "Score": "4", "Body": "<p>How do I pass this instance as a parameter into a function?</p>\n<pre><code>class\n{\n    public:\n    void foo();\n} bar;\n</code></pre>\n<p>Do I have to name the class?<br>\nIt is copyable since I haven't made the class's copy ctor private.<br>\nSo how is it possible if at all?</br></br></p>\n", "Tags": "<c++><oop><class>", "OwnerUserId": "85140", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_991062_991162_1": {"section_id": 85, "quality": 0.5714285714285714, "length": 4}, "so_991062_991162_0": {"section_id": 7141, "quality": 0.6666666666666666, "length": 8}}, "n3337": {"so_991062_991162_1": {"section_id": 80, "quality": 0.5714285714285714, "length": 4}, "so_991062_991162_0": {"section_id": 6885, "quality": 0.6666666666666666, "length": 8}}, "n4659": {"so_991062_991162_1": {"section_id": 88, "quality": 0.5714285714285714, "length": 4}, "so_991062_991162_0": {"section_id": 8642, "quality": 0.6666666666666666, "length": 8}}}});