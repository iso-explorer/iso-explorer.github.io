post_cb({"bq_ids": {"n4140": {"so_36892827_36894485_0": {"length": 14, "quality": 1.0, "section_id": 5939}}, "n4659": {"so_36892827_36894485_0": {"length": 14, "quality": 1.0, "section_id": 7423}}}, "36894485": {"Id": "36894485", "PostTypeId": "2", "Body": "<p>There are no cv-qualified scalar prvalues. <a href=\"http://eel.is/c++draft/expr#6\" rel=\"nofollow\">[expr]/6</a>:</p>\n<blockquote>\n<p id=\"so_36892827_36894485_0\">If a prvalue initially has the type \u201c<em>cv</em> <code>T</code>\u201d, where <code>T</code> is a\n  cv-unqualified non-class, non-array type, the type of the expression\n  is adjusted to <code>T</code> prior to any further analysis.</p>\n</blockquote>\n<p>I.e. the same rule giving </p>\n<pre><code>int const f();\nf() // &lt;=\n</code></pre>\n<p>type <code>int</code> applies here as well. If you try some class type instead of <code>int</code> (e.g. <code>std::string</code>), you will get the expected types.</p>\n", "Score": "4", "LastActivityDate": "2016-04-27T15:36:55.990", "CreationDate": "2016-04-27T15:36:55.990", "ParentId": "36892827", "CommentCount": "2", "OwnerUserId": "3647361"}, "36892827": {"ViewCount": "101", "LastEditDate": "2016-04-27T14:39:51.390", "AcceptedAnswerId": "36894485", "Title": "Unexpected return type when combining std::forward, std::move and volatile", "CreationDate": "2016-04-27T14:28:51.437", "LastActivityDate": "2016-04-27T15:36:55.990", "CommentCount": "2", "Body": "<p><em>Code <a href=\"https://godbolt.org/g/4cfwFl\" rel=\"nofollow\">on gcc.godbolt.org</a>.</em></p>\n<p>I created a simple type trait to remove rvalue references:</p>\n<pre><code>template &lt;typename T&gt;\nstruct remove_rvalue_reference { using type = T; };\n\ntemplate &lt;typename T&gt;\nstruct remove_rvalue_reference&lt;T&amp;&amp;&gt; { using type = T; };\n\ntemplate &lt;typename T&gt;\nusing remove_rvalue_reference_t = \n    typename remove_rvalue_reference&lt;T&gt;::type;\n</code></pre>\n<p>I'm using it to implent a <code>copy_if_rvalue(x)</code> function whose return type depends on the passed argument:</p>\n<pre><code>template &lt;typename T&gt;\nconstexpr auto copy_if_rvalue(T &amp;&amp; x) \n  -&gt; remove_rvalue_reference_t&lt;decltype(std::forward&lt;decltype(x)&gt;(x))&gt;\n{\n    return std::forward&lt;decltype(x)&gt;(x);\n}\n</code></pre>\n<p>To make sure the function returns the correct types, I've written some simple static assertions:</p>\n<pre><code>// literal\nstatic_assert(std::is_same&lt;\n    decltype(copy_if_rvalue(0)), int\n&gt;{});\n\n// lvalue\nint lv = 10;\nstatic_assert(std::is_same&lt;\n    decltype(copy_if_rvalue(lv)), int&amp;\n&gt;{});\n\n// const lvalue\nconst int clv = 10;\nstatic_assert(std::is_same&lt;\n    decltype(copy_if_rvalue(clv)), const int&amp;\n&gt;{});\n\n// rvalue\nint rv = 10;\nstatic_assert(std::is_same&lt;\n    decltype(copy_if_rvalue(std::move(rv))), int\n&gt;{});\n\n// volatile lvalue\nvolatile int vlv = 10;\nstatic_assert(std::is_same&lt;\n    decltype(copy_if_rvalue(vlv)), volatile int&amp;\n&gt;{});\n\n// const lvalue\nvolatile const int vclv = 10;\nstatic_assert(std::is_same&lt;\n    decltype(copy_if_rvalue(vclv)), volatile const int&amp;\n</code></pre>\n<p>All the above static assertions compile successfully. When trying to <code>std::move</code> a <code>volatile int</code> variable, though, something unexpected occurs:</p>\n<pre><code>// volatile rvalue\nvolatile int vrv = 10;\n\n// (0) fails:\nstatic_assert(std::is_same&lt;\n    decltype(copy_if_rvalue(std::move(vrv))), volatile int\n&gt;{});\n\n// (1) unexpectedly passes:\nstatic_assert(std::is_same&lt;\n    decltype(copy_if_rvalue(std::move(vrv))), int\n&gt;{});\n\n// (2) unexpectedly passes:\nstatic_assert(std::is_same&lt;\n    remove_rvalue_reference_t&lt;decltype(std::forward&lt;decltype(vrv)&gt;(std::move(vrv)))&gt;, \n    volatile int\n&gt;{});\n</code></pre>\n<p>Assertion (0) fails - the <code>volatile</code> does not propagate, as demonstrated by assertion (1).</p>\n<p>However, assertion (2) passes, even if I think it should be equivalent to assertion (0), since <code>copy_if_rvalue</code>'s return type is exactly the same as (2)'s first type:</p>\n<pre><code>// (from assertion (2))\nremove_rvalue_reference_t&lt;decltype(std::forward&lt;decltype(vrv)&gt;(std::move(vrv)))&gt; \n\n// ...should be equivalent to...\n\n// (from copy_if_rvalue)\n-&gt; remove_rvalue_reference_t&lt;decltype(std::forward&lt;decltype(x)&gt;(x))&gt;\n</code></pre>\n<p>It seems that <code>volatile</code> is not propagated only when <code>std::move</code> is used and only through the <code>copy_if_rvalue</code> template function. </p>\n<p>What is going on here?</p>\n", "PostTypeId": "1", "LastEditorUserId": "598696", "Id": "36892827", "AnswerCount": "1", "Score": "6", "OwnerUserId": "598696", "Tags": "<c++><language-lawyer><c++14><decltype><trailing-return-type>", "FavoriteCount": "1"}});