post_cb({"bq_ids": {"n4140": {"so_16886788_16886788_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 6985}, "so_16886788_16889408_2": {"length": 46, "quality": 0.9387755102040817, "section_id": 6985}, "so_16886788_16886788_1": {"length": 13, "quality": 0.8125, "section_id": 6985}}, "n3337": {"so_16886788_16886788_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 6731}, "so_16886788_16889408_2": {"length": 46, "quality": 0.9387755102040817, "section_id": 6731}, "so_16886788_16886788_1": {"length": 13, "quality": 0.8125, "section_id": 6731}}, "n4659": {"so_16886788_16886788_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 8483}, "so_16886788_16889408_2": {"length": 44, "quality": 0.8979591836734694, "section_id": 8483}, "so_16886788_16886788_1": {"length": 13, "quality": 0.8125, "section_id": 8483}}}, "16886788": {"ViewCount": "368", "Body": "<p>In C++11 (N3485) 10.1.4 [class.mi] it says:</p>\n<blockquote>\n<p id=\"so_16886788_16886788_0\">For each distinct occurence of a <em>non-virtual</em> base class in the class lattice of the most derived class, the most derived object shall contain a corresponding <em>distinct</em> base class subobject of that type.</p>\n<p id=\"so_16886788_16886788_1\">For each distinct base class that is specified <em>virtual</em>, the most derived class shall contain a <em>single</em> base class object of that type.</p>\n</blockquote>\n<p>Consider the following C++11 code:</p>\n<pre><code>struct B {};\n\nstruct BV : virtual B {};\nstruct BN : B {};\n\nstruct C1 : BV, BN {};\nstruct C2 : BV, BN {};\n\nstruct D : C1, C2 {};\n</code></pre>\n<p>Firstly, for clarity, how many vertices does the class lattice of D have?</p>\n<p>Secondly, how many distinct subobjects of type B does the standard require that a most derived object of type D have?</p>\n<p><strong>update:</strong></p>\n<p>Which of the following is the class lattice?</p>\n<p>(1)</p>\n<pre><code>    B     B     B    B\n    ^     ^     ^    ^\n    |     |     |    |\n    BV    BN    BV   BN\n    ^     ^     ^    ^\n    |     |     |    |\n     \\   /       \\  /\n       C1         C2\n         \\        /\n          \\      /\n           -  D -\n</code></pre>\n<p>(2)</p>\n<pre><code>    B&lt;---------\n    ^          \\\n    |           |\n    |     B     |    B\n    |     ^     |    ^\n    |     |     |    |\n    BV    BN    BV   BN\n    ^     ^     ^    ^\n    |     |     |    |\n     \\   /       \\  /\n       C1         C2\n         \\        /\n          \\      /\n           -  D -\n</code></pre>\n<p>(3)</p>\n<pre><code>       B   \n      /  \\     \n     /    \\ \n    BV    BN\n    | \\  / |\n    |  \\/  |\n    |  / \\ |\n    | /   \\|\n    C1     C2\n     \\    /\n      \\  /\n       D\n</code></pre>\n<p>If the intention is that it is (1) then isn't it impossible to have any DAG that isn't a tree? (ie a diamond is impossible)  If so wouldn't it be better to call it the class tree?</p>\n<p>If it is (2) wouldn't it be sufficient to say \"for each occurence of a base class in the class lattice there is a corresponding base class subobject\" ?.  That is, if the construction of the lattice already depends on virtual and non-virtual base class relationships to select edges and vertices?</p>\n<p>If it is (3) then isn't the language incorrect in the standard because there can only ever be one occurence of a class in the class lattice?</p>\n", "Title": "C++11 class lattice with mixed virtual and non-virtual bases?", "CreationDate": "2013-06-02T20:03:47.427", "LastActivityDate": "2013-06-03T16:20:14.460", "CommentCount": "12", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-06-03T16:20:14.460", "LastEditorUserId": "365496", "Id": "16886788", "Score": "7", "OwnerUserId": "1131467", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "16889408": {"Id": "16889408", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_16886788_16889408_0\">Which of the following is the class lattice?</p>\n</blockquote>\n<p>2</p>\n<p>Demonstration:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct B {};\n\nstruct BV : virtual B {};\nstruct BN : B {};\n\nstruct C1 : BV, BN {};\nstruct C2 : BV, BN {};\n\nstruct D : C1, C2 {};\n\nint\nmain()\n{\n    D d;\n    C1* c1 = static_cast&lt;C1*&gt;(&amp;d);\n    BV* bv1 = static_cast&lt;BV*&gt;(c1);\n    BN* bn1 = static_cast&lt;BN*&gt;(c1);\n    B* b1 = static_cast&lt;B*&gt;(bv1);\n    B* b2 = static_cast&lt;B*&gt;(bn1);\n    C2* c2 = static_cast&lt;C2*&gt;(&amp;d);\n    BV* bv2 = static_cast&lt;BV*&gt;(c2);\n    BN* bn2 = static_cast&lt;BN*&gt;(c2);\n    B* b3 = static_cast&lt;B*&gt;(bv2);\n    B* b4 = static_cast&lt;B*&gt;(bn2);\n    std::cout &lt;&lt; \"d = \" &lt;&lt; &amp;d &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"c1 = \" &lt;&lt; c1 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"c2 = \" &lt;&lt; c2 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"bv1 = \" &lt;&lt; bv1 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"bv2 = \" &lt;&lt; bv2 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"bn1 = \" &lt;&lt; bn1 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"bn2 = \" &lt;&lt; bn2 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"b1 = \" &lt;&lt; b1 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"b2 = \" &lt;&lt; b2 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"b3 = \" &lt;&lt; b3 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"b4 = \" &lt;&lt; b4 &lt;&lt; '\\n';\n}\n</code></pre>\n<p>My output:</p>\n<pre><code>d = 0x7fff5ca18998\nc1 = 0x7fff5ca18998\nc2 = 0x7fff5ca189a0\nbv1 = 0x7fff5ca18998\nbv2 = 0x7fff5ca189a0\nbn1 = 0x7fff5ca18998\nbn2 = 0x7fff5ca189a0\nb1 = 0x7fff5ca189a8\nb2 = 0x7fff5ca18998\nb3 = 0x7fff5ca189a8\nb4 = 0x7fff5ca189a0\n</code></pre>\n<blockquote>\n<p id=\"so_16886788_16889408_1\">If it is (2) wouldn't it be sufficient to say \"for each occurence of a\n  base class in the class lattice there is a corresponding base class\n  subobject\" ?. That is, if the construction of the lattice already\n  depends on virtual and non-virtual base class relationships to select\n  edges and vertices?</p>\n</blockquote>\n<p>Merging your suggestion...</p>\n<blockquote>\n<p id=\"so_16886788_16889408_2\">A base class specifier that contains the keyword <strong>virtual</strong>,\n  specifies a <em>virtual</em> base class. For each <del>distinct</del>\n  occurrence of a <del>non-virtual</del> base class in the class lattice\n  <del>of the most derived class, the most derived object (1.8) shall\n  contain</del> there is a corresponding <del>distinct</del>\n  base class subobject <del>of that type</del>.  <del>For each distinct\n  base class that is specified virtual, the most derived object shall\n  contain a single base class subobject of that type.</del></p>\n</blockquote>\n<p>I'm not an expert in the language half of the standard.  However when I read your modified specification, I don't see how:</p>\n<pre><code>class V { /\u2217...\u2217/ };\nclass A : virtual public V { /\u2217 ... \u2217/ };\nclass B : virtual public V { /\u2217 ... \u2217/ };\nclass C : public A, public B { /\u2217...\u2217/ };\n</code></pre>\n<p>Results in Figure 4:</p>\n<pre><code>   V\n  / \\\n /   \\\nA     B\n \\   /\n  \\ /\n   C\n</code></pre>\n<p>I don't see another place in the standard that specifies that although <code>V</code> appears twice in the class hierarchy below <code>C</code>, only one subobject of type <code>V</code> actually exists because of the use of the <code>virtual</code> keyword.</p>\n", "LastActivityDate": "2013-06-03T02:46:38.233", "CommentCount": "4", "CreationDate": "2013-06-03T02:46:38.233", "ParentId": "16886788", "Score": "3", "OwnerUserId": "576911"}});