post_cb({"bq_ids": {"n4140": {"so_23233395_23233483_0": {"length": 20, "quality": 0.8, "section_id": 5834}}, "n3337": {"so_23233395_23233483_0": {"length": 22, "quality": 0.88, "section_id": 5605}}, "n4659": {"so_23233395_23233483_0": {"length": 20, "quality": 0.8, "section_id": 7296}}}, "23233395": {"ViewCount": "181", "Body": "<p>Declarations: I use vs 2010/vs 2013, and clang 3.4 prebuilt binary.</p>\n<p>I've found a bug in our production code. I minimize the reproduce code to the following:</p>\n<pre><code>#include &lt;windows.h&gt;\n#include &lt;process.h&gt;\n#include &lt;stdio.h&gt;\nusing namespace std;\n\nbool s_begin_init =  false;\nbool s_init_done =  false;\n\nvoid thread_proc(void * arg)\n{\n    DWORD tid = GetCurrentThreadId();\n    printf(\"Begin Thread %2d, TID=%u\\n\", reinterpret_cast&lt;int&gt;(arg), tid);\n    if (!s_begin_init)\n    {\n        s_begin_init = true;\n        Sleep(20);\n        s_init_done = true;\n    }\n    else\n    {\n        while(!s_init_done) { ; }\n    }\n    printf(\"End   Thread %2d, TID=%u\\n\", reinterpret_cast&lt;int&gt;(arg), tid);\n}\n\nint main(int argc, char *argv[])\n{\n    argc = argc                       ; argv = argv                       ; \n    for(int i = 0; i &lt; 30; ++i)\n    {\n        _beginthread(thread_proc, 0, reinterpret_cast&lt;void*&gt;(i));\n    }\n    getchar();\n    return 0;\n}\n</code></pre>\n<p>To compile and run the code:\ncl /O2 /Zi /Favc.asm vc_O2_bug.cpp   &amp;&amp; vc_O2_bug.exe</p>\n<p>Some of the threads are busying in the while loop. By checking the produced assembly code, I found the assembly code of </p>\n<blockquote>\n<p id=\"so_23233395_23233395_0\">while(!s_init_done) {; }</p>\n</blockquote>\n<p>is:</p>\n<pre><code>; Line 19\n    mov al, BYTE PTR ?s_init_done@@3_NA     ; s_init_done\n$LL2@thread_pro:\n; Line 21\n    test    al, al\n    je  SHORT $LL2@thread_pro\n; Line 23\n</code></pre>\n<p>It's obvious that when use -O2 optimization flag, VC copy the s_init_done to al register, and repeatedly test the al register.</p>\n<p>I then use the clang-cl.exe  compiler driver to test the code. The result is same, and the assembly code are<br>\nequivalent.</br></p>\n<p>It looks that the compiler think that variable s_init_done will never be changed because the only statement which change it's value is in the \"if\" block, which is exclusive with the current \"else\" branch.</p>\n<p>I tried the same code with VS2013, The result is also same.</p>\n<p>What I doubt is: In C++98/C++03 standard, there's no concept of thread. So the compiler can perform such an optimization for a single-thread-machine. But since c++11 has thread, and both clang 3.4 and VC2013 have support C++11 well, do my question is:</p>\n<p>Is think kind of optimization a compiler bug for C++98/C++03, and for C++11 separately?</p>\n<p>BTW: When I use -O1 instead, or add volatile qualifier to s_init_done, the bug disappeared.</p>\n", "AcceptedAnswerId": "23233483", "Title": "Is this kind of optimization a compiler bug or not?", "CreationDate": "2014-04-23T01:47:26.833", "Id": "23233395", "CommentCount": "10", "PostTypeId": "1", "LastActivityDate": "2014-04-23T02:24:03.353", "Score": "0", "OwnerUserId": "64469", "Tags": "<c++><multithreading><visual-c++><c++11><clang>", "AnswerCount": "1"}, "23233483": {"Id": "23233483", "PostTypeId": "2", "Body": "<p>Your program contains data races on <code>s_begin_init</code> and <code>s_init_done</code>, and therefore has undefined behavior. Per C++11 \u00a71.10/21:</p>\n<blockquote>\n<p id=\"so_23233395_23233483_0\">The execution of a program contains a <em>data race</em> if it contains two conflicting actions in different threads, at least one of which is not atomic, and neither happens before the other. Any such data race results in undefined behavior.</p>\n</blockquote>\n<p>The fix is to declare both boolean variables to be atomic:</p>\n<pre><code>std::atomic&lt;bool&gt; s_begin_init{false};\nstd::atomic&lt;bool&gt; s_init_done{false};\n</code></pre>\n<p>or to synchronize accesses to them with a <code>mutex</code> (I'll throw in a condition variable to avoid busy-waiting):</p>\n<pre><code>std::mutex mtx;\nstd::condition_variable cvar;\nbool s_begin_init = false;\nbool s_init_done = false;\n\nvoid thread_proc(void * arg)\n{\n    DWORD tid = GetCurrentThreadId();\n    printf(\"Begin Thread %2d, TID=%u\\n\", reinterpret_cast&lt;int&gt;(arg), tid);\n    std::unique_lock&lt;std::mutex&gt; lock(mtx);\n    if (!s_begin_init)\n    {\n        s_begin_init = true;\n        lock.unlock();\n        Sleep(20);\n        lock.lock();\n        s_init_done = true;\n        cvar.notify_all();\n    }\n    else\n    {\n        while(!s_init_done) { cvar.wait(lock); }\n    }\n    printf(\"End   Thread %2d, TID=%u\\n\", reinterpret_cast&lt;int&gt;(arg), tid);\n}\n</code></pre>\n<p>EDIT: I just noticed the mention of VS2010 in the OP. <a href=\"http://msdn.microsoft.com/en-us/library/hh567368.aspx\" rel=\"nofollow\">VS2010 does not support C++11 atomics</a>, so you will have to use the <code>mutex</code> solution or take advantage of <a href=\"http://msdn.microsoft.com/en-us/library/12a04hfd.aspx\" rel=\"nofollow\">MSVC's non-standard extension that gives <code>volatile</code> variables acquire-release semantics</a>:</p>\n<pre><code>volatile bool s_begin_init = false;\nvolatile bool s_init_done = false;\n</code></pre>\n", "LastEditorUserId": "923854", "LastActivityDate": "2014-04-23T02:24:03.353", "Score": "7", "CreationDate": "2014-04-23T01:56:55.947", "ParentId": "23233395", "CommentCount": "0", "LastEditDate": "2014-04-23T02:24:03.353", "OwnerUserId": "923854"}});