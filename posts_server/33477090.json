post_cb({"33477090": {"CommentCount": "4", "ViewCount": "86", "PostTypeId": "1", "LastEditorUserId": "1178267", "CreationDate": "2015-11-02T11:58:36.263", "LastActivityDate": "2015-11-02T12:40:04.513", "Title": "Why can I use 'this' in methods", "AcceptedAnswerId": "33477809", "LastEditDate": "2015-11-02T12:35:52.237", "Id": "33477090", "Score": "0", "Body": "<p>Ok, this is a very basic question.</p>\n<p><strong>What is the true reason why I can use the <em>this</em> pointer in c++ methods / member functions?</strong></p>\n<p>In other words: when I have</p>\n<pre><code>class foo\n{\n    void bar();\n}\n</code></pre>\n<p>Why can I use</p>\n<pre><code>void foo::bar()\n{\n    this-&gt;...\n}\n</code></pre>\n<p>I can imagine two possibilities:</p>\n<ol>\n<li>Is it some sort of automatically created member variable</li>\n<li>It is passed to each method as parameter (and thus each method is automatically extended by that parameter)</li>\n</ol>\n", "Tags": "<c++><methods>", "OwnerUserId": "1178267", "AnswerCount": "3"}, "33477238": {"ParentId": "33477090", "CommentCount": "0", "Body": "<p>If you look the assembly code of a class function you will notice that a hidden parameter is passed. This parameter is called the this pointer and is nothing more than the address of the current object. If this address was not passed then your compiler would have no idea what object to call. Another usage is to return a current object address which is extremely usefull in operator overloading for subsequent operations(assignment especially).</p>\n", "OwnerUserId": "2309279", "PostTypeId": "2", "Id": "33477238", "Score": "1", "CreationDate": "2015-11-02T12:07:59.090", "LastActivityDate": "2015-11-02T12:07:59.090"}, "33477809": {"ParentId": "33477090", "CommentCount": "3", "Body": "<p>As pointed out by several others, the <code>this</code> keyword is often implemented by the compiler by passing it along as the first parameter to a member function, so that a member function: <code>void SomeClass::func(int a, int b)</code> could internally look like: <code>void SomeClass::func(SomeClass* this, int a, int b)</code>, and the const version like this: <code>void SomeClass::func(const SomeClass* this, int a, int b)</code>. </p>\n<p>However what I find most interesting about this, is that it is something that is <em>not</em> enforced by the standard.</p>\n<p>The C++ standard says (\u00a7 9.3.2 ad 1):</p>\n<blockquote>\n<p id=\"so_33477090_33477809_0\">In the body of a non-static (9.3) member function, the <strong>keyword this is a prvalue expression whose value is the address of the object for which the function is called</strong>. The type of this in a member function of a class <code>X</code> is <code>X*</code>. If the member function is declared const, the type of this is <code>const X*</code>, if the member function is declared volatile, the type of this is <code>volatile X*</code>, and if the member function is declared const volatile, the type of this is <code>const volatile X*</code>. [ Note: thus in a const member function, the object for which the function is called is accessed through a const access path. \u2014end note ]</p>\n</blockquote>\n<p>This is interesting, because like with many other things, the C++ <a href=\"https://en.wikipedia.org/wiki/Application_binary_interface\" rel=\"nofollow\">ABI</a> is left mostly to the compiler, which can be troublesome. So while it is certainly true for most compilers (might even be all), that <code>this</code> is implemented by being implicitly passed as the first parameter, it is not guaranteed by the standard, so it could be implemented differently by a new compiler, though I doubt it will happen.</p>\n", "OwnerUserId": "111143", "PostTypeId": "2", "Id": "33477809", "Score": "4", "CreationDate": "2015-11-02T12:40:04.513", "LastActivityDate": "2015-11-02T12:40:04.513"}, "33477244": {"ParentId": "33477090", "CommentCount": "0", "Body": "<p>When a member function is invoked on a class member, C++ uses the keyword <code>this</code> to refer to something that acts like an unmodifiable pointer to the class instance the function was invoked on. It behaves as if it was a parameter to the function.</p>\n<p>You can think of <code>foo.bar(1);</code> as kind of like <code>bar(&amp;foo, 1);</code>.\nAnd you can think of<br>\n<code>int foo::f(int);</code> as kind of like <code>int f(foo const* this, int);</code>.</br></p>\n", "OwnerUserId": "721269", "PostTypeId": "2", "Id": "33477244", "Score": "3", "CreationDate": "2015-11-02T12:08:27.437", "LastActivityDate": "2015-11-02T12:08:27.437"}, "bq_ids": {"n4140": {"so_33477090_33477809_0": {"section_id": 5895, "quality": 0.9245283018867925, "length": 49}}, "n3337": {"so_33477090_33477809_0": {"section_id": 5666, "quality": 0.6981132075471698, "length": 37}}, "n4659": {"so_33477090_33477809_0": {"section_id": 7378, "quality": 0.9056603773584906, "length": 48}}}});