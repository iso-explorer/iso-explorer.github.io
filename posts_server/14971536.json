post_cb({"bq_ids": {"n4140": {"so_14971536_14973116_0": {"length": 23, "quality": 0.92, "section_id": 571}, "so_14971536_14972228_2": {"length": 21, "quality": 1.0, "section_id": 305}, "so_14971536_14972228_3": {"length": 16, "quality": 0.8888888888888888, "section_id": 306}, "so_14971536_14972228_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 305}}, "n3337": {"so_14971536_14972228_3": {"length": 16, "quality": 0.8888888888888888, "section_id": 297}, "so_14971536_14972228_2": {"length": 21, "quality": 1.0, "section_id": 296}, "so_14971536_14972228_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 296}, "so_14971536_14973116_0": {"length": 23, "quality": 0.92, "section_id": 562}}, "n4659": {"so_14971536_14972228_3": {"length": 16, "quality": 0.8888888888888888, "section_id": 313}, "so_14971536_14972228_2": {"length": 21, "quality": 1.0, "section_id": 312}, "so_14971536_14972228_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 312}, "so_14971536_14973116_0": {"length": 23, "quality": 0.92, "section_id": 594}}}, "14972228": {"Id": "14972228", "PostTypeId": "2", "Body": "<p>In this case I believe gcc is right. You are asking the compiler to perform type deduction for you, and the problem is that the given argument of type <code>DerivedFunction</code> is not a <code>FunctionImplementation&lt;TDerived&gt;</code> directly, so a conversion has to be performed. At this point the list of conversions includes <code>FunctionImplementation&lt;BaseFunction&gt;</code> (through <code>BaseFunction</code>) and <code>FunctionImplementation&lt;DerivedFunction&gt;</code> (directly). There is no ordering among those two choices, so the compiler bails out with an ambiguity.</p>\n<p>The standard treats this in \u00a714.8.2.1 [temp.deduct.call]/4,5</p>\n<blockquote>\n<p id=\"so_14971536_14972228_0\">(paragraph 4) In general, the deduction process attempts to find template argument values that will make the deduced A identical to A (after the type A is transformed as described above). However, there are three cases that allow a difference:</p>\n<p id=\"so_14971536_14972228_1\">[...]</p>\n<p id=\"so_14971536_14972228_2\">If P is a class and P has the form simple-template-id, then the transformed A can be a derived class of the deduced A. Likewise, if P is a pointer to a class of the form simple-template-id, the transformed A can be a pointer to a derived class pointed to by the deduced A.</p>\n<p id=\"so_14971536_14972228_3\">(paragraph 5) These alternatives are considered only if type deduction would otherwise fail. If they yield more than one possible deduced A, the type deduction fails.</p>\n</blockquote>\n<p>In the 4th paragraph it allows type deduction to pick a base of the argument type, in this case there are 2 such bases. The 5th paragraph determines that if the application of the previous rule yields more than one result, then type deduction fails.</p>\n", "LastEditorUserId": "36565", "LastActivityDate": "2013-02-20T04:33:32.760", "Score": "3", "CreationDate": "2013-02-20T04:19:19.730", "ParentId": "14971536", "CommentCount": "7", "LastEditDate": "2013-02-20T04:33:32.760", "OwnerUserId": "36565"}, "14973116": {"Id": "14973116", "PostTypeId": "2", "Body": "<p>Okay, the answer below is wrong.  I had always believed from reading 13.3.1p7</p>\n<blockquote>\n<p id=\"so_14971536_14973116_0\">In each case where a candidate is a function template, candidate function template specializations are generated using template argument deduction (14.8.3, 14.8.2). Those candidates are then handled as candidate functions in the usual way.</p>\n</blockquote>\n<p>that template argument deduction used the appropriate overload resolution machinery to choose among the syntactically-possible specializations (function overload resolution for functions, etc.).</p>\n<p>It turns out that's not true: template argument deduction has its own, very restricted set of rules that insist on exact matches (pace cv-qualifiers and dereferencing and the like), only permitting the derived-class-to-templated-base argument conversion seen here as a special case -- and that special case explicitly forbids using function overload resolution to handle any ambiguities.</p>\n<p>So for the right answer, see above.  I'm leaving this answer here because it's getting upvotes, leading me to believe I'm not the only one who has it wrong this way:</p>\n<p>Overload resolution for <code>foo(derived)</code> is looking up <code>FunctionImplementation&lt;T&gt;</code> declarations in class <code>Derived</code>.  Class <code>Derived</code> has no member-scope declarations of that template, so the recursive lookup results from its base classes are combined, yielding both of the specializations in its hierarchy:</p>\n<pre><code>Derived\n:   Base\n    :   AbstractFunction\n    ,   FunctionImplementation&lt;Base&gt;\n,   FunctionImplementation&lt;Derived&gt;\n</code></pre>\n<p>Considering the depth at which a declaration was found within the base-class derivation hierarchy when doing name lookup would mean no name or base could ever be added to a class without <em>silently</em> affecting previous results in all derived classes that use multiple inheritance.  Instead, C++ refuses to pick for you and supplies using-declarations to explicitly declare which base class's use of the (tepmlate, in this case) name is the one you mean to refer to.</p>\n<p>The standardese for this is in 10.2, p3-5 are the meat.</p>\n", "LastEditorUserId": "1290731", "LastActivityDate": "2013-02-20T23:06:58.583", "Score": "1", "CreationDate": "2013-02-20T05:47:59.323", "ParentId": "14971536", "CommentCount": "11", "LastEditDate": "2013-02-20T23:06:58.583", "OwnerUserId": "1290731"}, "14971536": {"ViewCount": "340", "Body": "<p>I was thinking about using CRTP classes to help with overloading and wondered what the following bit of code would do:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\ntemplate &lt;class TDerived&gt;\nclass FunctionImplementation\n{\n};\n\nclass AbstractFunction\n{\n};\n\nclass BaseFunction : public AbstractFunction, public FunctionImplementation&lt;BaseFunction&gt;\n{\n};\n\nclass DerivedFunction : public BaseFunction, public FunctionImplementation&lt;DerivedFunction&gt;\n{\n};\n\ntemplate &lt;class TDerived&gt;\nvoid foo(const FunctionImplementation&lt;TDerived&gt;&amp; function) {\n    std::cout &lt;&lt; \"In foo for \" &lt;&lt; typeid(TDerived).name() &lt;&lt; std::endl;\n}\n\nint main() {\n    BaseFunction base;\n    DerivedFunction derived;\n\n    foo(base);\n    foo(derived);\n}\n</code></pre>\n<p>With GCC 4.2 on OS X it doesn't compile:</p>\n<pre><code>overload.cpp: In function \u2018int main()\u2019:\noverload.cpp:31: error: no matching function for call to \u2018foo(DerivedFunction&amp;)\u2019\n</code></pre>\n<p>With Clang 4.0 on the same system, it compiles and does the 'natural' thing when it runs:</p>\n<pre><code>In foo for 12BaseFunction\nIn foo for 15DerivedFunction\n</code></pre>\n<p>With Visual C++ 2010, it also compiles but runs differently:</p>\n<pre><code>In foo for class BaseFunction\nIn foo for class BaseFunction\n</code></pre>\n<p>Finally, GCC 4.7.2 on Linux does not compile but gives a more complete and fairly authoritative-sounding error message:</p>\n<pre><code>overload.cpp: In function \u2018int main()\u2019:\noverload.cpp:31:16: error: no matching function for call to \u2018foo(DerivedFunction&amp;)\u2019\noverload.cpp:31:16: note: candidate is:\noverload.cpp:22:6: note: template&lt;class TDerived&gt; void foo(const FunctionImplementation&lt;TDerived&gt;&amp;)\noverload.cpp:22:6: note:   template argument deduction/substitution failed:\noverload.cpp:31:16: note:   \u2018DerivedFunction\u2019 is an ambiguous base class of \u2018const FunctionImplementation&lt;TDerived&gt;\u2019\n</code></pre>\n<p>Which is correct? I am no expert at navigating the language standard...</p>\n", "AcceptedAnswerId": "14972228", "Title": "Should this bit of C++ CRTP code compile, and if so what should it do?", "CreationDate": "2013-02-20T02:54:05.113", "Id": "14971536", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-02-20T23:06:58.583", "Score": "1", "OwnerUserId": "953078", "Tags": "<c++><templates><inheritance><method-overloading><crtp>", "AnswerCount": "2"}});