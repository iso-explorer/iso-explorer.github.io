post_cb({"45755990": {"Id": "45755990", "PostTypeId": "2", "Body": "<p>I think that you're overthinking this. I don't see any reason for <code>mmap</code> or equivalent (I'll use the POSIX terminology here) memory to be volatile.</p>\n<p>From the point of view of the compiler <code>mmap</code> returns an object that is modified and then given to <code>msync</code> or <code>munmap</code> or the implied unmap during <code>_Exit</code>. Those functions need to be treated as I/O, nothing else.</p>\n<p>You could pretty much replace <code>mmap</code> with <code>malloc</code>+<code>read</code> and <code>munmap</code> with <code>write</code>+<code>free</code> and you would get most of the guarantees of when and how I/O is done.</p>\n<p>Note that this doesn't even require the data to be fed back to <code>munmap</code>, it was just easier to demonstrate it this way. You can have <code>mmap</code> return a piece of memory and also save it internally in a list, then a function (let's call it <code>msyncall</code>) that doesn't have any arguments that writes out all the memory all calls to <code>mmap</code> previously returned. We can then build from that, saying that any function that performs I/O has an implicit <code>msyncall</code>. We don't need to go that far though. From the point of view of a compiler libc is a black box where some function returned some memory, that memory has to be in sync before any other call into libc because the compiler can't know which bits of memory that were previously returned from libc are still referenced and in active use inside.</p>\n<p>The above paragraph is how it works in practice, but how can we approach it from the point of view of a standard? Let's look at a similar problem first. For threads the shared memory is only synchronized at some <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_12\" rel=\"nofollow noreferrer\">very specific function calls</a>. This is quite important because modern CPUs reorder reads and writes and memory barriers are expensive and old CPUs could need explicit cache flushes before written data was visible by others (be it other threads, processes or I/O). The specification for <code>mmap</code> says:</p>\n<blockquote>\n<p id=\"so_45753903_45755990_0\">The application must ensure correct synchronization when using mmap() in conjunction with any other file access method</p>\n</blockquote>\n<p>but it doesn't specify how that synchronization is done. I know in practice that synchronization pretty much has to be <code>msync</code> because there are still systems out there where read/write are not using the same page cache as mmap.</p>\n", "LastEditorUserId": "939410", "LastActivityDate": "2017-08-18T13:15:58.657", "Score": "1", "CreationDate": "2017-08-18T11:51:08.233", "ParentId": "45753903", "CommentCount": "2", "OwnerUserId": "939410", "LastEditDate": "2017-08-18T13:15:58.657"}, "bq_ids": {"n4140": {"so_45753903_45753903_0": {"length": 69, "quality": 0.9324324324324325, "section_id": 5808}}, "n3337": {"so_45753903_45753903_0": {"length": 69, "quality": 0.9324324324324325, "section_id": 5581}}, "n4659": {"so_45753903_45753903_0": {"length": 72, "quality": 0.972972972972973, "section_id": 7269}}}, "45753903": {"ViewCount": "297", "Body": "<p>My understanding of the semantics of <code>volatile</code> in C and C++ is that it turns memory access into <a href=\"http://eel.is/c++draft/intro.execution#14\" rel=\"nofollow noreferrer\">(observable) side effects</a>. Whenever reading or writing to a memory mapped file (or shared memory) I would expect the the pointer to be volatile qualified, to indicate that this is in fact I/O. (John Regehr wrote a very good <a href=\"https://blog.regehr.org/archives/28\" rel=\"nofollow noreferrer\">article</a> on the semantics of <code>volatile</code>).</p>\n<p>Furthermore, I would expect using functions like <code>memcpy()</code> to access shared memory to be incorrect, since the signature suggests the volatile qualification is cast away, and the memory access not be treated as I/O.</p>\n<p>In my mind, this is an argument in favor of <code>std::copy()</code>, where the volatile qualifier won't be cast away, and memory accesses being correctly treated as I/O.</p>\n<p>However, my experience of using pointers to volatile objects and <code>std::copy()</code> to access memory mapped files is that it's orders of magnitude slower than just using <code>memcpy()</code>. I am tempted to conclude that perhaps clang and GCC are overly conservative in their treatment of <code>volatile</code>. Is that the case?</p>\n<p><strong>What guidance is there for accessing shared memory with regards to <code>volatile</code>, if I want to follow the letter of the standard and have it back the semantics I rely on?</strong></p>\n<hr>\n<p>Relevant quote from the standard <a href=\"http://eel.is/c++draft/intro.execution#14\" rel=\"nofollow noreferrer\">[intro.execution] \u00a714</a>:</p>\n<blockquote>\n<p id=\"so_45753903_45753903_0\">Reading an object designated by a volatile glvalue, modifying an\n  object, calling a library I/O function, or calling a function that\n  does any of those operations are all side effects, which are changes\n  in the state of the execution environment. Evaluation of an expression\n  (or a subexpression) in general includes both value computations\n  (including determining the identity of an object for glvalue\n  evaluation and fetching a value previously assigned to an object for\n  prvalue evaluation) and initiation of side effects. When a call to a\n  library I/O function returns or an access through a volatile glvalue\n  is evaluated the side effect is considered complete, even though some\n  external actions implied by the call (such as the I/O itself) or by\n  the volatile access may not have completed yet.</p>\n</blockquote>\n</hr>", "Title": "memory mapped files and pointers to volatile objects", "CreationDate": "2017-08-18T10:00:56.237", "LastActivityDate": "2017-08-18T13:15:58.657", "CommentCount": "12", "LastEditDate": "2017-08-18T11:14:56.080", "PostTypeId": "1", "LastEditorUserId": "657930", "Id": "45753903", "Score": "7", "OwnerUserId": "657930", "Tags": "<c++><c><language-lawyer><volatile><mmap>", "AnswerCount": "3"}, "45755723": {"Id": "45755723", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_45753903_45755723_0\">My understanding of the semantics of volatile in C and C++ is that it turns memory access into I/O</p>\n</blockquote>\n<p>No it does not do that. All <code>volatile</code> does is to communicate from the programmer to the compiler that a certain memory area can be changed at any time, by \"something else\". </p>\n<p>\"Something else\" might be a lot of different things. Examples:</p>\n<ul>\n<li>Memory-mapped hardware register</li>\n<li>Variable shared with an ISR</li>\n<li>Variable updated from a callback function</li>\n<li>Variable shared with another thread or process</li>\n<li>Memory area updated through DMA</li>\n</ul>\n<p>Since the standard (5.1.2.3) guarantees that an access (read/write) to a volatile object may not get optimized away, <code>volatile</code> can also be used to block certain compiler optimizations, which is mostly useful in hardware-related programming. </p>\n<blockquote>\n<p id=\"so_45753903_45755723_1\">Whenever reading or writing to a memory mapped file (or shared memory) I would expect the the pointer to be volatile qualified</p>\n</blockquote>\n<p>Not necessarily, no. The nature of the data doesn't matter, only how it is updated.</p>\n<blockquote>\n<p id=\"so_45753903_45755723_2\">I would expect using functions like memcpy() to access shared memory to be incorrect</p>\n</blockquote>\n<p>Overall it depends on your definition of \"shared memory\". This is a problem with your whole question, because you keep talking about \"shared memory\" which is not a formal, well-defined term. Memory shared with another ISR/thread/process? </p>\n<p>Yes, memory shared with another ISR/thread/process <em>might</em> have to be declared as <code>volatile</code>, depending on compiler. But this is <em>only</em> becaue <code>volatile</code> can prevent a compiler from making incorrect assumptions and optimize code accessing such \"shared\" variables the wrong way. Something which was especially prone to happen on older embedded systems compilers. It shouldn't be necessary on modern hosted system compilers. </p>\n<p><code>volatile</code> does not lead to memory barrier behavior. It does not (necessarily) force expressions to get executed in a certain order.</p>\n<p><code>volatile</code> does certainly not guarantee any form of atomicity. This is why the <code>_Atomic</code> type qualifier was added to the C language.</p>\n<p>So back to the copy issue - if the memory area is \"shared\" between several ISRs/threads/processes, then <code>volatile</code> won't help at all. Instead you need some means of synchronization, such as a mutex, semaphore or critical section.</p>\n<blockquote>\n<p id=\"so_45753903_45755723_3\">In my mind, this is an argument in favor of std::copy(), where the volatile qualifier won't be cast away, and memory accesses being correctly treated as I/O.</p>\n</blockquote>\n<p>No, this is just wrong, for the already mentioned reasons.</p>\n<blockquote>\n<p id=\"so_45753903_45755723_4\">What guidance is there for accessing shared memory with regards to volatile, if I want to follow the letter of the standard and have it back the semantics I rely on?</p>\n</blockquote>\n<p>Use system-specific API:s to protect the memory access, through mutex/semaphore/critical section.</p>\n", "LastActivityDate": "2017-08-18T11:36:15.967", "CommentCount": "6", "CreationDate": "2017-08-18T11:36:15.967", "ParentId": "45753903", "Score": "3", "OwnerUserId": "584518"}, "45753977": {"Id": "45753977", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_45753903_45753977_0\">My understanding of the semantics of volatile in C and C++ is that it\n  turns memory access into I/O</p>\n</blockquote>\n<p>Your understanding is wrong. Volatile object is side effect volatile - and its value may be changed by something not visible for the compiler during the compilation</p>\n<p>so volatile object has to have a permanent (inside its scope of course)  memory storage location, has to be read from it before any use, and saved after every change</p>\n<p>See the example:\n<a href=\"https://godbolt.org/g/1vm1pq\" rel=\"nofollow noreferrer\">https://godbolt.org/g/1vm1pq</a></p>\n<p>BTW IMO that article is rubbish - it assumes that programmers think that volatile means atomicity and coherency as well, which is not the truth. That article should have a title - \"Why my understanding of volatile was wrong, and why I still live in the world of myths\"</p>\n", "LastEditorUserId": "6110094", "LastActivityDate": "2017-08-18T11:14:45.203", "Score": "0", "CreationDate": "2017-08-18T10:04:29.643", "ParentId": "45753903", "CommentCount": "24", "OwnerUserId": "6110094", "LastEditDate": "2017-08-18T11:14:45.203"}});