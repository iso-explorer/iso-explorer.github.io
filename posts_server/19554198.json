post_cb({"bq_ids": {"n4140": {"so_19554198_19555419_3": {"section_id": 3221, "quality": 1.0, "length": 5}, "so_19554198_19555419_1": {"section_id": 3222, "quality": 0.8918918918918919, "length": 33}}, "n3337": {"so_19554198_19555419_3": {"section_id": 3095, "quality": 1.0, "length": 5}, "so_19554198_19555419_1": {"section_id": 3096, "quality": 0.918918918918919, "length": 34}}, "n4659": {"so_19554198_19555419_3": {"section_id": 3978, "quality": 1.0, "length": 5}, "so_19554198_19555419_1": {"section_id": 3979, "quality": 0.8918918918918919, "length": 33}}}, "19554231": {"ParentId": "19554198", "CommentCount": "3", "Body": "<p>It is undefined behaviour to evaluate the expression <code>args[1]</code> if <code>args</code> isn't a pointer to the first element of an array of at least two elements. Taking the address immediately, like <code>&amp;args[1]</code>, is valid only if <code>args</code> points to the first element of an array of at least one element.</p>\n<p>Basically, don't do it.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "19554231", "Score": "3", "CreationDate": "2013-10-23T23:32:25.390", "LastActivityDate": "2013-10-23T23:32:25.390"}, "19554198": {"CommentCount": "3", "AcceptedAnswerId": "19555419", "PostTypeId": "1", "LastEditorUserId": "1009479", "CreationDate": "2013-10-23T23:28:49.250", "LastActivityDate": "2013-10-24T02:11:13.640", "LastEditDate": "2013-10-24T02:11:13.640", "ViewCount": "113", "FavoriteCount": "1", "Title": "Is it safe to have a reference to an out-of-bounds array element if I never actually use the reference?", "Id": "19554198", "Score": "3", "Body": "<p>I am working with an API wherein the caller passes in an array of pointers to stuff, as well as the length of the array. To make my code more readable/maintainable, I would like to be able to effectively give names to each argument rather than refer to them as <code>arg[0]</code>, <code>arg[1]</code>, etc. Is it safe to declare references to all of the possible arguments even if the length of the passed-in array can be different sizes due to optional arguments?</p>\n<p>I am trying to do something like this:</p>\n<pre><code>void myFunc(int out_args[], size_t nargs) {\n  int &amp;foo = out_args[0];\n  int &amp;bar = out_args[1];    // bar is optional argument. is this safe?\n  ...\n  foo = 5;\n  if(2 &gt;= nargs)\n    bar = 10;\n  ...\n}\n</code></pre>\n<p>Note that the arguments are <em>output</em> arguments, so I really want to have references to them. <strong>So, is it safe to have a dangling-ish reference to args[1] if I never actually use it?</strong></p>\n<p>My guess is that this is safe because I imagine the way references are implemented is to treat <code>&amp;</code> in the variable declaration of references as <code>* const</code>, and whenever I use the references, then the compiler automatically dereferences the pointers for me. Ie, under the hood, I imagine that what I wrote is translated to something like</p>\n<pre><code>void myFunc(int out_args[], size_t nargs) {\n  int *const foo = &amp;out_args[0];\n  int *const bar = &amp;out_args[1];    // bar is optional argument. is this safe?\n  ...\n  *foo = 5;\n  if(2 &gt;= nargs)\n    *bar = 10;\n  ...\n}\n</code></pre>\n<p>In this case, I believe the code never actually accesses memory it shouldn't, so if the version above is equivalent to this, then I should be ok, right?</p>\n<hr>\n<p>EDIT:\nI'm basically writing a plug in, and the API I'm using and can't do anything about can call my code with either something like</p>\n<pre><code>int ret_vals[1];     // only care about 1 return value\nmyFunc(ret_vals, 1);\n</code></pre>\n<p>or</p>\n<pre><code>int ret_vals[2];     // care about both return values\nmyFunc(ret_vals, 2);\n</code></pre>\n<p>or even</p>\n<pre><code>myFunc(NULL, 0);     // ignore all return values; just marvel at the side effects\n</code></pre>\n<p>and my code needs to work in all cases.</p>\n</hr>", "Tags": "<c++><arrays>", "OwnerUserId": "1072468", "AnswerCount": "2"}, "19555419": {"ParentId": "19554198", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_19554198_19555419_0\">So, is it safe to have a dangling-ish reference to args[1] if I never actually use it?</p>\n</blockquote>\n<p>The standard impose that a reference shall be bound to a valid object in \u00a7 8.3.2:</p>\n<blockquote>\n<p id=\"so_19554198_19555419_1\">There shall be no references to references, no arrays of references,\n  and no pointers to references. [...] A reference shall be initialized\n  to refer to a valid object or function. [ Note: in particular, a null\n  reference cannot exist in a well-defined program, because the only way\n  to create such a reference would be to bind it to the \u201cobject\u201d\n  obtained by dereferencing a null pointer, which causes undefined\n  behavior. [...] \u2014 end note ]</p>\n</blockquote>\n<p>It means that it is <strong>not</strong> safe.</p>\n<blockquote>\n<p id=\"so_19554198_19555419_2\">My guess is that this is safe because I imagine the way references are\n  implemented is to treat &amp; in the variable declaration of references as\n  * const, and whenever I use the references, then the compiler automatically dereferences the pointers for me.</p>\n</blockquote>\n<p>No, don't do that. Again, the standard doesn't specify how references shall be implemented. In fact in \u00a7 8.3.2 it states that:</p>\n<blockquote>\n<p id=\"so_19554198_19555419_3\">It is unspecified whether or not a reference requires storage.</p>\n</blockquote>\n<p>As for your code: you could name the parameters once you are sure they exists.</p>\n<pre><code>void myFunc(int out_args[], size_t nargs) {\n  int &amp;foo = out_args[0];\n  ...\n  foo = 5;\n  if(nargs &gt;= 2) {\n    int &amp;bar = out_args[1];\n    bar = 10;\n  }\n  ...\n}\n</code></pre>\n<p>I feel obligated to make you notice that the use of C-style arrays in C++ is discouraged. It is generally a good idea to use <code>std::vector</code> or <code>std::array</code> instead.</p>\n", "OwnerUserId": "493122", "PostTypeId": "2", "Id": "19555419", "Score": "1", "CreationDate": "2013-10-24T01:43:03.803", "LastActivityDate": "2013-10-24T01:43:03.803"}});