post_cb({"46814017": {"Id": "46814017", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_46810474_46814017_0\">If the string is the same as the literal, will the comparison using <code>==</code> be true in all cases?</p>\n</blockquote>\n<p>A common consideration not yet explored: <code>FLT_EVAL_METHOD</code></p>\n<pre><code>#include &lt;float.h&gt;\n...\nprintf(\"%d\\n\", FLT_EVAL_METHOD);\n</code></pre>\n<blockquote>\n<p id=\"so_46810474_46814017_1\">2 evaluate all operations and constants to the range and precision of the\n  <code>long double</code> type.</p>\n</blockquote>\n<p>If this returns 2, then the math used in <code>value == 7.7</code> is <code>long double</code> and <code>7.7</code> treated as <code>7.7L</code>.  In OP's case, this may evaluate to false.</p>\n<p>To account for this wider precision, assign values which will removes all extra range and precision.</p>\n<pre><code>scanf(file, \"%lf\", &amp;value);\ndouble seven_seven = 7.7;\nif (value == seven_seven)\n  printf(\"strictly equal\\n\");\n</code></pre>\n<p>IMO, this is a more likely occurring problem than variant rounding modes or variations in library/compiler conversions.</p>\n<hr>\n<p>Note that this case is akin to the below, a well known issue.</p>\n<pre><code>float value;\nfscanf(file, \"%f\", &amp;value);\nif (value == 7.7)\n   printf(\"strictly equal\\n\");\n</code></pre>\n<hr>\n<p>Demonstration</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;float.h&gt;\nint main() {\n  printf(\"%d\\n\", FLT_EVAL_METHOD);\n  double value;\n  sscanf(\"7.7\", \"%lf\", &amp;value);\n  double seven_seven = 7.7;\n  if (value == seven_seven) {\n    printf(\"value == seven_seven\\n\");\n  } else {\n    printf(\"value != seven_seven\\n\");\n  }\n  if (value == 7.7) {\n    printf(\"value == 7.7\\n\");\n  } else {\n    printf(\"value != 7.7\\n\");\n  }\n  return 0;\n}\n</code></pre>\n<p>Output</p>\n<pre><code>2\nvalue == seven_seven\nvalue != 7.7\n</code></pre>\n<hr>\n<p><strong>Alternative Compare</strong></p>\n<p>To compare 2 <code>double</code> that are \"near\" each other, we need a definition of \"near\".    A useful approach is to consider all the finite <code>double</code> values sorted into a ascending sequence and then compare their sequence numbers from each other.  <code>double_distance(x, nextafter(x, 2*x)</code> --&gt; 1</p>\n<p>Following code makes various assumptions about <code>double</code> layout and size. </p>\n<pre><code>#include &lt;assert.h&gt;\n\nunsigned long long double_order(double x) {\n  union {\n    double d;\n    unsigned long long ull;\n  } u;\n  assert(sizeof(double) == sizeof(unsigned long long));\n  u.d = x;\n  if (u.ull &amp; 0x8000000000000000) {\n    u.ull ^= 0x8000000000000000;\n    return 0x8000000000000000 - u.ull;\n  }\n  return u.ull + 0x8000000000000000;\n}\n\nunsigned long long double_distance(double x, double y) {\n  unsigned long long ullx = double_order(x);\n  unsigned long long ully = double_order(y);\n  if (x &gt; y) return ullx - ully;\n  return ully - ullx;\n}\n\n....\nprintf(\"%llu\\n\", double_distance(value, 7.7));                       // 0\nprintf(\"%llu\\n\", double_distance(value, nextafter(value,value*2)));  // 1\nprintf(\"%llu\\n\", double_distance(value, nextafter(value,value/2)));  // 1\n</code></pre>\n<p>Or just use</p>\n<pre><code>if (nextafter(7.7, -INF) &lt;= value &amp;&amp; value &lt;= nextafter(7.7, +INF)) {\n  puts(\"Close enough\");\n}\n</code></pre>\n</hr></hr></hr>", "LastEditorUserId": "2410359", "LastActivityDate": "2017-10-18T18:35:15.280", "Score": "2", "CreationDate": "2017-10-18T15:35:02.360", "ParentId": "46810474", "CommentCount": "2", "OwnerUserId": "2410359", "LastEditDate": "2017-10-18T18:35:15.280"}, "46810818": {"Id": "46810818", "PostTypeId": "2", "Body": "<p>About C++, <a href=\"http://en.cppreference.com/w/c/language/floating_constant\" rel=\"nofollow noreferrer\">from cppreference one can read</a>:</p>\n<p><strong><code>[lex.fcon]</code></strong> (\u00a76.4.4.2)</p>\n<blockquote>\n<p id=\"so_46810474_46810818_0\">The result of evaluating a floating constant is either the nearest representable value or the larger or smaller representable value immediately adjacent to the nearest representable value, chosen in an implementation-defined manner (in other words, default rounding direction during translation is implementation-defined).</p>\n</blockquote>\n<p>Since the representation of a floating literal is unspecified, I guess you cannot conclude about its comparison with a <code>scanf</code> result.</p>\n<hr>\n<p>About C11 (standard ISO/IEC 9899:2011):</p>\n<p><strong><code>[lex.fcon]</code></strong> (\u00a76.4.4.2)</p>\n<blockquote>\n<p id=\"so_46810474_46810818_1\"><strong>Recommended practice</strong></p>\n<p id=\"so_46810474_46810818_2\">7 The  translation-time  conversion  of  floating  constants  should  match  the  execution-time conversion  of  character  strings  by  library functions,  such  as <code>strtod</code>,  given  matching inputs  suitable  for  both  conversions,  the  same  result  format,  and  default  execution-time\n  rounding.</p>\n</blockquote>\n<p>So clearly for C11, this is not guaranteed to match.</p>\n</hr>", "LastEditorUserId": "5470596", "LastActivityDate": "2017-10-19T07:39:18.127", "Score": "16", "CreationDate": "2017-10-18T13:01:35.197", "ParentId": "46810474", "CommentCount": "7", "OwnerUserId": "5470596", "LastEditDate": "2017-10-19T07:39:18.127"}, "bq_ids": {"n4140": {"so_46810474_46810797_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 5348}}, "n3337": {"so_46810474_46810797_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 5145}}, "n4659": {"so_46810474_46810797_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 6773}}}, "46819416": {"Id": "46819416", "PostTypeId": "2", "Body": "<p>There's no guarantee. </p>\n<p>You can hope that the compiler uses a high quality algorithm for the conversion of literals, and that the standard library implementation uses a high quality conversion as well, and two high quality algorithms should agree quite often. </p>\n<p>It's also possible that both use the exact same algorithm (for example, the compiler converts the literal by putting the characters into a char array and calling sscanf. </p>\n<p>BTW. I had one bug caused by the fact that a compiler didn't convert the literal 999999999.5 exactly. Replaced it with 9999999995 / 10.0 and everything was fine. </p>\n", "LastActivityDate": "2017-10-18T21:18:15.190", "CommentCount": "0", "CreationDate": "2017-10-18T21:18:15.190", "ParentId": "46810474", "Score": "1", "OwnerUserId": "3255455"}, "46810474": {"ViewCount": "1120", "Body": "<p><strong>This is not a duplicate of the famous <a href=\"https://stackoverflow.com/questions/588004/is-floating-point-math-broken\"><em>Is floating point math broken</em></a>, even if it looks like one at first sight.</strong></p>\n<p>I'm reading a <code>double</code> from a text file using <code>fscanf(file, \"%lf\", &amp;value);</code> and comparing it with the <code>==</code> operator against a double literal. If the string is the same as the literal, will the comparision using <code>==</code> be <code>true</code> in all cases?</p>\n<p><strong>Example</strong></p>\n<p>Text file content:</p>\n<pre><code>7.7\n</code></pre>\n<p>Code snippet:</p>\n<pre><code>double value;\nfscanf(file, \"%lf\", &amp;value);     // reading \"7.7\" from file into value\n\nif (value == 7.7)\n   printf(\"strictly equal\\n\");\n</code></pre>\n<p>The expected and actual output is</p>\n<pre><code>strictly equal\n</code></pre>\n<p>But this supposes that the compiler converts the double literal <code>7.7</code> into a double exactly the same way as does the <code>fscanf</code> function, but the compiler may or may not use the same library for converting strings to double.</p>\n<p>Or asked otherwise: does the conversion from string to double result in a unique binary representation or may there be slight implementation dependent differences?</p>\n<p><strong><a href=\"https://www.ideone.com/HmSuGo\" rel=\"noreferrer\">Live demonstration</a></strong></p>\n", "AcceptedAnswerId": "46810818", "Title": "Comparing floating point values converted from strings with literals", "CreationDate": "2017-10-18T12:43:27.167", "Id": "46810474", "CommentCount": "11", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-10-19T07:44:15.863", "LastEditorUserId": "5470596", "LastActivityDate": "2017-10-19T07:44:15.863", "Score": "23", "OwnerUserId": "898348", "Tags": "<c++><c><floating-point><language-lawyer>", "AnswerCount": "4"}, "46810797": {"Id": "46810797", "PostTypeId": "2", "Body": "<p>From the c++ standard:</p>\n<blockquote>\n<h3>[lex.fcon]</h3>\n<p id=\"so_46810474_46810797_0\">... If the scaled value is in the range\n  of representable values for its type, the result is the scaled value if representable, else the larger or smaller\n  representable value nearest the scaled value, <strong>chosen in an implementation-defined manner</strong>...</p>\n</blockquote>\n<p>emphasis mine.</p>\n<p>So you can only rely on equality if the value is strictly representable by a double.</p>\n", "LastEditorUserId": "2015579", "LastActivityDate": "2017-10-18T13:18:44.883", "Score": "18", "CreationDate": "2017-10-18T13:00:21.080", "ParentId": "46810474", "CommentCount": "6", "OwnerUserId": "2015579", "LastEditDate": "2017-10-18T13:18:44.883"}});