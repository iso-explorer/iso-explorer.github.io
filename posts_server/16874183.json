post_cb({"16874183": {"CommentCount": "13", "AcceptedAnswerId": "16905832", "PostTypeId": "1", "LastEditorUserId": "1422197", "CreationDate": "2013-06-01T15:18:14.013", "LastActivityDate": "2013-06-04T09:26:27.860", "LastEditDate": "2013-06-03T23:08:08.123", "ViewCount": "904", "FavoriteCount": "5", "Title": "(Re)Using std::algorithms with non-standard containers", "Id": "16874183", "Score": "8", "Body": "<p>I have a \"column\" container type:</p>\n<pre><code>struct MyColumnType { \n  // Data: Each row represents a member of an object.\n  vector&lt;double&gt; a;   // All vectors are guaranteed to have always\n  vector&lt;string&gt; b;   // the same length.\n  vector&lt;int&gt; c;\n\n  void copy(int from_pos, int to_pos); // The column type provides an interface\n  void swap(int pos_a, int pos_b);     // for copying, swapping, ...\n\n  void push_back();      // And for resizing the container.\n  void pop_back();\n  void insert(int pos);\n  void remove(int pos);\n  // The interface can be extended/modified if required\n};\n</code></pre>\n<p><strong>Usage:</strong></p>\n<pre><code>// If table is a constructed container with elements stored \n// To acces the members of the object stored at the 4th position:\ntable.a[4] = 4.0;\ntable.b[4] = \"4th\";\ntable.c[4] = 4;\n</code></pre>\n<p><strong>Question:</strong> How can I create a standard-compliant random access iterator (and probably a required proxy reference type) for this kind of container?</p>\n<p>I want to be able to use <code>std::algorithms</code> for random access iterators with my type, e.g. <code>sort</code> (note: for sorting the comparison would be provided by an user-defined functor, e.g. a lambda). </p>\n<p>In particular the iterator should provide an interface similar to </p>\n<pre><code>struct {\n  double&amp; a;\n  string&amp; b;\n  int&amp; c;\n};\n</code></pre>\n<p><strong>Note 0:</strong> C++11/C++14 is allowed.</p>\n<p><strong>Note 1:</strong> There is an old paper <a href=\"http://hci.iwr.uni-heidelberg.de/vigra/documents/DataAccessors.ps\">http://hci.iwr.uni-heidelberg.de/vigra/documents/DataAccessors.ps</a> where a similar attempt is undertaken. However, I haven't been able to get their approach working with sort. Requirements like defaultConstructible are hard to satisfy using a proxy type approach (why does <code>std::sort</code> require types to be default constructible instead of swappable is beyond my understanding).</p>\n<p><strong>Note 2:</strong> I cannot do the following:</p>\n<pre><code>struct MyType {\n  double a;\n  string b;\n  int c;\n};\n\nstd::vector&lt;MyType&gt; v;\n</code></pre>\n<p>and then use <code>std::algorithm</code>. </p>\n<p><strong>Motivation:</strong> Performance. A cache-line is usually 64bytes, i.e. 8 doubles. In this simple struct if you iterate over the doubles, you are polluting a cache-line with a string an an int. In other cases, you might get only 1 double transfered per cache-line. That is, you end up using 1/8-th of the memory bandwith available. If you need to iterate over a couple of Gb of doubles, this simple decision improves your application performance by a factor of 6-7x. And no, I cannot give that up.</p>\n<p><strong>Bonus:</strong> the answer should be as generic as possible. Think about adding/removing fields to the container type as adding/removing members to a struct. You don't want to change a lot of code every time you add a new member.</p>\n", "Tags": "<c++><algorithm><proxy><iterator>", "OwnerUserId": "1422197", "AnswerCount": "2"}, "16906372": {"ParentId": "16874183", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>If you're really concerned about performance and you want to sort your container with <code>std::sort</code>, use the overload that allows you to provide a custom comparison object:</p>\n<pre><code>template &lt;class RandomAccessIterator, class Compare&gt;\nvoid sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n</code></pre>\n<p>.. and sort an array of indices into the container. Here's how:</p>\n<p>You'll need the following members in your container:</p>\n<pre><code>struct MyColumnType { \n    ...\n\n    int size() const;\n\n    // swaps columns\n    void swap(int l, int r);\n\n    // returns true if column l is less than column r\n    bool less(int l, int r) const;\n\n    ...\n};\n</code></pre>\n<p>Then define the following comparison object:</p>\n<pre><code>struct MyColumnTypeLess\n{\n    const MyColumnType* container;\n    MyColumnTypeLess(const MyColumnType* container)\n        : container(container)\n    {\n    }\n    bool operator()(int l, int r) const\n    {\n        return container-&gt;less(l, r);\n    }\n};\n</code></pre>\n<p>And use it to sort an array of indices:</p>\n<pre><code>void sortMyColumnType(MyColumnType&amp; container)\n{\n    std::vector&lt;int&gt; indices;\n    indices.reserve(container.size());\n    // fill with [0, n)\n    for(int i = 0; i != container.size(); ++i)\n    {\n        indices.push_back(i);\n    }\n    // sort the indices\n    std::sort(indices.begin(), indices.end(), MyColumnTypeLess(&amp;container));\n}\n</code></pre>\n<p>The 'less' member of the container controls which order to sort in:</p>\n<pre><code>bool MyColumnType::less(int l, int r) const\n{\n    // sort first by a, then b, then c\n    return a[l] != a[r] ? a[l] &lt; a[r]\n        : b[l] != b[r] ? b[l] &lt; b[r]\n        : c[l] &lt; c[r];\n}\n</code></pre>\n<p>The sorted array of indices can be used in further algorithms - you can avoid copying the actual data around until you need to.</p>\n<p>All <code>std</code> algorithms that work with RandomAccessIterators have overloads that allow you to specify custom comparison objects, so they can also be used with this technique.</p>\n", "OwnerUserId": "1690864", "LastEditorUserId": "1690864", "LastEditDate": "2013-06-04T09:26:27.860", "Id": "16906372", "Score": "0", "CreationDate": "2013-06-03T21:46:07.757", "LastActivityDate": "2013-06-04T09:26:27.860"}, "bq_ids": {"n4140": {"so_16874183_16905832_0": {"section_id": 5583, "quality": 0.8148148148148148, "length": 22}}, "n3337": {"so_16874183_16905832_0": {"section_id": 5365, "quality": 0.8148148148148148, "length": 22}}, "n4659": {"so_16874183_16905832_0": {"section_id": 7030, "quality": 0.8148148148148148, "length": 22}}}, "16905832": {"ParentId": "16874183", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>I think something like this could be Standard-compliant. It uses some C++11 features to simplify the syntax, but could as well be changed to comply C++03 AFAIK.</p>\n<p>Tested and works with clang++3.2</p>\n<p>Prelude:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;  // for std::swap\n#include &lt;iterator&gt;\n\nusing std::vector;\nusing std::string;\n\n\n// didn't want to insert all those types as nested classes of MyColumnType\nnamespace MyColumnType_iterator\n{\n    struct all_copy;\n    struct all_reference;\n    struct all_iterator;\n}\n\n\n// just provided `begin` and `end` member functions\nstruct MyColumnType {\n    // Data: Each row represents a member of an object.\n    vector&lt;double&gt; a;   // All vectors are guaranteed to have always\n    vector&lt;string&gt; b;   // the same length.\n    vector&lt;int&gt; c;\n\n    void copy(int from_pos, int to_pos); // The column type provides an itface\n    void swap(int pos_a, int pos_b);     // for copying, swapping, ...\n\n    void push_back();      // And for resizing the container.\n    void pop_back();\n    void insert(int pos);\n    void remove(int pos);\n    // The interface can be extended/modified if required\n\n\n    using iterator = MyColumnType_iterator::all_iterator;\n    iterator begin();\n    iterator end();\n};\n</code></pre>\n<p>The iterator classes: a <code>value_type</code> (<code>all_copy</code>), a <code>reference</code> type (<code>all_reference</code>) and the iterator type (<code>all_iterator</code>). Iterating is done by keeping and updating three iterators (one to each <code>vector</code>). I don't know if that's the most performant option, though.</p>\n<p>How it works: <code>std::iterator_traits</code> defines several associated types for an iterator:\n[iterator.traits]/1</p>\n<blockquote>\n<p id=\"so_16874183_16905832_0\"><code>iterator_traits&lt;Iterator&gt;::difference_type</code><br/>\n<code>iterator_traits&lt;Iterator&gt;::value_type</code><br/>\n<code>iterator_traits&lt;Iterator&gt;::iterator_category</code><br/>\n  be defined as the iterator\u2019s difference type, value type and iterator category, respectively. In addition, the types<br/>\n<code>iterator_traits&lt;Iterator&gt;::reference</code><br/>\n<code>iterator_traits&lt;Iterator&gt;::pointer</code><br/>\n  shall be defined as the iterator\u2019s reference and pointer types, that is, for an iterator object a, the same type as the type of <code>*a</code> and <code>a-&gt;</code>, respectively</p>\n</blockquote>\n<p>Therefore, you can introduce a struct (<code>all_reference</code>) keeping three references as <code>reference</code> type. This type is the return value of <code>*a</code>, where <code>a</code> is of the iterator type (possibly <code>const</code>-qualified). There needs to be a different <code>value_type</code> because some Standard Library algorithms such as <code>sort</code> might want to create a local variable temporarily storing the value of <code>*a</code> (by copy or move into the local variable). In this case, <code>all_copy</code> provides this functionality.</p>\n<p>You're not required to use it (<code>all_copy</code>) in you own loops, where it could affect performance.</p>\n<pre><code>namespace MyColumnType_iterator\n{\n    struct all_copy;\n\n    struct all_reference\n    {\n        double&amp; a;\n        string&amp; b;\n        int&amp; c;\n\n        all_reference() = delete;\n        // not required for std::sort, but stream output is simpler to write\n        // with this\n        all_reference(all_reference const&amp;) = default;\n        all_reference(double&amp; pa, string&amp; pb, int&amp; pc)\n            : a{pa}\n            , b{pb}\n            , c{pc}\n        {}\n\n        // MoveConstructible required for std::sort\n        all_reference(all_reference&amp;&amp; other) = default;\n        // MoveAssignable required for std::sort\n        all_reference&amp; operator= (all_reference&amp;&amp; other)\n        {\n            a = std::move(other.a);\n            b = std::move(other.b);\n            c = std::move(other.c);\n\n            return *this;\n        }\n\n        // swappable required for std::sort\n        friend void swap(all_reference p0, all_reference p1)\n        {\n            std::swap(p0.a, p1.a);\n            std::swap(p0.b, p1.b);\n            std::swap(p0.c, p1.c);\n        }\n\n        all_reference&amp; operator= (all_copy const&amp; p) = default;\n        all_reference&amp; operator= (all_copy&amp;&amp; p) = default;\n\n        // strict total ordering required for std::sort\n        friend bool operator&lt; (all_reference const&amp; lhs,\n                               all_reference const&amp; rhs);\n        friend bool operator&lt; (all_reference const&amp; lhs, all_copy const&amp; rhs);\n        friend bool operator&lt; (all_copy const&amp; lhs, all_reference const&amp; rhs);\n    };\n\n    struct all_copy\n    {\n        double a;\n        string b;\n        int c;\n\n        all_copy(all_reference const&amp; p)\n            : a{p.a}\n            , b{p.b}\n            , c{p.c}\n        {}\n        all_copy(all_reference&amp;&amp; p)\n            : a{ std::move(p.a) }\n            , b{ std::move(p.b) }\n            , c{ std::move(p.c) }\n        {}\n    };\n</code></pre>\n<p>There needs to be a comparison function for <code>std::sort</code>. For some reason we have to provide all three.</p>\n<pre><code>    bool operator&lt; (all_reference const&amp; lhs, all_reference const&amp; rhs)\n    {\n        return lhs.c &lt; rhs.c;\n    }\n    bool operator&lt; (all_reference const&amp; lhs, all_copy const&amp; rhs)\n    {\n        return lhs.c &lt; rhs.c;\n    }\n    bool operator&lt; (all_copy const&amp; lhs, all_reference const&amp; rhs)\n    {\n        return lhs.c &lt; rhs.c;\n    }\n</code></pre>\n<p>Now, the iterator class:</p>\n<pre><code>    struct all_iterator\n        : public std::iterator &lt; std::random_access_iterator_tag, all_copy &gt;\n    {\n        //+ specific to implementation\n        private:\n            using ItA = std::vector&lt;double&gt;::iterator;\n            using ItB = std::vector&lt;std::string&gt;::iterator;\n            using ItC = std::vector&lt;int&gt;::iterator;\n            ItA iA;\n            ItB iB;\n            ItC iC;\n\n        public:\n            all_iterator(ItA a, ItB b, ItC c)\n                : iA(a)\n                , iB(b)\n                , iC(c)\n            {}\n        //- specific to implementation\n\n\n        //+ for iterator_traits\n            using reference = all_reference;\n            using pointer = all_reference;\n        //- for iterator_traits\n\n\n        //+ iterator requirement [iterator.iterators]/1\n            all_iterator(all_iterator const&amp;) = default;            // CopyConstructible\n            all_iterator&amp; operator=(all_iterator const&amp;) = default; // CopyAssignable\n            ~all_iterator() = default;                              // Destructible\n\n            void swap(all_iterator&amp; other)                          // lvalues are swappable\n            {\n                std::swap(iA, other.iA);\n                std::swap(iB, other.iB);\n                std::swap(iC, other.iC);\n            }\n        //- iterator requirements [iterator.iterators]/1\n        //+ iterator requirement [iterator.iterators]/2\n            all_reference operator*()\n            {\n                return {*iA, *iB, *iC};\n            }\n            all_iterator&amp; operator++()\n            {\n                ++iA;\n                ++iB;\n                ++iC;\n                return *this;\n            }\n        //- iterator requirement [iterator.iterators]/2\n\n        //+ input iterator requirements [input.iterators]/1\n            bool operator==(all_iterator const&amp; other) const        // EqualityComparable\n            {\n                return iA == other.iA;  // should be sufficient (?)\n            }\n        //- input iterator requirements [input.iterators]/1\n        //+ input iterator requirements [input.iterators]/2\n            bool operator!=(all_iterator const&amp; other) const        // \"UnEqualityComparable\"\n            {\n                return iA != other.iA;  // should be sufficient (?)\n            }\n\n            all_reference const operator*() const                   // *a\n            {\n                return {*iA, *iB, *iC};\n            }\n\n            all_reference operator-&gt;()                              // a-&gt;m\n            {\n                return {*iA, *iB, *iC};\n            }\n            all_reference const operator-&gt;() const                  // a-&gt;m\n            {\n                return {*iA, *iB, *iC};\n            }\n\n            // ++r already satisfied\n\n            all_iterator operator++(int)                            // *++r\n            {\n                all_iterator temp(*this);\n                ++(*this);\n                return temp;\n            }\n        //- input iterator requirements [input.iterators]/2\n\n        //+ output iterator requirements [output.iterators]/1\n            // *r = o already satisfied\n            // ++r already satisfied\n            // r++ already satisfied\n            // *r++ = o already satisfied\n        //- output iterator requirements [output.iterators]/1\n\n        //+ forward iterator requirements [forward.iterators]/1\n            all_iterator() = default;                               // DefaultConstructible\n            // r++ already satisfied\n            // *r++ already satisfied\n            // multi-pass must be guaranteed\n        //- forward iterator requirements [forward.iterators]/1\n\n        //+ bidirectional iterator requirements [bidirectional.iterators]/1\n            all_iterator&amp; operator--()                              // --r\n            {\n                --iA;\n                --iB;\n                --iC;\n                return *this;\n            }\n            all_iterator operator--(int)                            // r--\n            {\n                all_iterator temp(*this);\n                --(*this);\n                return temp;\n            }\n            // *r-- already satisfied\n        //- bidirectional iterator requirements [bidirectional.iterators]/1\n\n        //+ random access iterator requirements [random.access.iterators]/1\n            all_iterator&amp; operator+=(difference_type p)             // r += n\n            {\n                iA += p;\n                iB += p;\n                iC += p;\n                return *this;\n            }\n            all_iterator operator+(difference_type p) const         // a + n\n            {\n                all_iterator temp(*this);\n                temp += p;\n                return temp;\n            }\n            // doesn't have to be a friend function, but this way,\n            // we can define it here\n            friend all_iterator operator+(difference_type p,\n                                         all_iterator temp)         // n + a\n            {\n                temp += p;\n                return temp;\n            }\n\n            all_iterator&amp; operator-=(difference_type p)             // r -= n\n            {\n                iA -= p;\n                iB -= p;\n                iC -= p;\n                return *this;\n            }\n            all_iterator operator-(difference_type p) const         // a - n\n            {\n                all_iterator temp(*this);\n                temp -= p;\n                return temp;\n            }\n\n            difference_type operator-(all_iterator const&amp; p)        // b - a\n            {\n                return iA - p.iA;   // should be sufficient (?)\n            }\n\n            all_reference operator[](difference_type p)             // a[n]\n            {\n                return *(*this + p);\n            }\n            all_reference const operator[](difference_type p) const // a[n]\n            {\n                return *(*this + p);\n            }\n\n            bool operator&lt;(all_iterator const&amp; p) const             // a &lt; b\n            {\n                return iA &lt; p.iA;   // should be sufficient (?)\n            }\n            bool operator&gt;(all_iterator const&amp; p) const             // a &gt; b\n            {\n                return iA &gt; p.iA;   // should be sufficient (?)\n            }\n            bool operator&gt;=(all_iterator const&amp; p) const            // a &gt;= b\n            {\n                return iA &gt;= p.iA;  // should be sufficient (?)\n            }\n            bool operator&lt;=(all_iterator const&amp; p) const            // a &gt;= b\n            {\n                return iA &lt;= p.iA;  // should be sufficient (?)\n            }\n        //- random access iterator requirements [random.access.iterators]/1\n    };\n}//- namespace MyColumnType_iterator\n\n\nMyColumnType::iterator MyColumnType::begin()\n{\n    return { a.begin(), b.begin(), c.begin() };\n}\nMyColumnType::iterator MyColumnType::end()\n{\n    return { a.end(), b.end(), c.end() };\n}\n</code></pre>\n<p>Usage example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstddef&gt;\n#include &lt;algorithm&gt;\n\n\nnamespace MyColumnType_iterator\n{\n    template &lt; typename char_type, typename char_traits &gt;\n    std::basic_ostream &lt; char_type, char_traits &gt;&amp;\n    operator&lt;&lt; (std::basic_ostream &lt; char_type, char_traits &gt;&amp; o,\n                std::iterator_traits&lt;MyColumnType::iterator&gt;::reference p)\n    {\n        return o &lt;&lt; p.a &lt;&lt; \";\" &lt;&lt; p.b &lt;&lt; \";\" &lt;&lt; p.c;\n    }\n}\n\nint main()\n{\n    using std::cout;\n\n    MyColumnType mct =\n    {\n          {1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1}\n        , {\"j\", \"i\", \"h\", \"g\", \"f\", \"e\", \"d\", \"c\", \"b\", \"a\"}\n        , {10,    9,   8,   7,   6,   5,   4,   3,   2,   1}\n    };\n\n    using ref = std::iterator_traits&lt;MyColumnType::iterator&gt;::reference;\n    std::copy(mct.begin(), mct.end(), std::ostream_iterator&lt;ref&gt;(cout, \", \"));\n    std::cout &lt;&lt; std::endl;\n\n    std::sort(mct.begin(), mct.end());\n    std::copy(mct.begin(), mct.end(), std::ostream_iterator&lt;ref&gt;(cout, \", \"));\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Output:</p>\n<blockquote>\n<p id=\"so_16874183_16905832_1\">1;j;10, 0.9;i;9, 0.8;h;8, 0.7;g;7, 0.6;f;6, 0.5;e;5, 0.4;d;4, 0.3;c;3, 0.2;b;2, 0.1;a;1, <br/>\n  0.1;a;1, 0.2;b;2, 0.3;c;3, 0.4;d;4, 0.5;e;5, 0.6;f;6, 0.7;g;7, 0.8;h;8, 0.9;i;9, 1;j;10,</p>\n</blockquote>\n", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2013-06-03T21:27:16.453", "Id": "16905832", "Score": "4", "CreationDate": "2013-06-03T21:05:37.527", "LastActivityDate": "2013-06-03T21:27:16.453"}});