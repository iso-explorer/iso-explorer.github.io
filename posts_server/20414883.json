post_cb({"20415441": {"ParentId": "20414883", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-12-06T03:33:12.327", "Score": "3", "LastEditorUserId": "923854", "LastEditDate": "2013-12-06T03:38:33.760", "Id": "20415441", "OwnerUserId": "923854", "Body": "<p><code>std::declval</code> is actually specified to be (C++11 \u00a720.2.4 [declval] p1):</p>\n<pre><code>template &lt;class T&gt;\ntypename add_rvalue_reference&lt;T&gt;::type declval() noexcept;\n</code></pre>\n<p>The result of the reference collapsing rules (\u00a78.3.2 [dcl.ref] p6) is that <code>declval</code> returns an lvalue reference when <code>T</code> is an lvalue reference type, and an rvalue reference otherwise. So yes, your interpretation is correct.</p>\n<p>If your compiler thinks that <code>double&amp;&amp;</code> is assignable from <em>any</em> type, then it has a bug. \u00a75.17 [expr.ass] p1 states:</p>\n<blockquote>\n<p id=\"so_20414883_20415441_0\">The assignment operator (<code>=</code>) and the compound assignment operators all group right-to-left. All require a <strong>modifiable lvalue</strong> as their left operand and return an lvalue referring to the left operand.</p>\n</blockquote>\n<p>[emphasis mine].</p>\n<p>Many programmers choose to emulate this behavior - assingment only to lvalues - with their own types by declaring the assignment operators with an lvalue reference qualifier:</p>\n<pre><code>class foo {\n  foo&amp; operator = (const foo&amp;) &amp; = default;\n  foo&amp; operator = (foo&amp;&amp;) &amp; = default;\n};\n</code></pre>\n", "LastActivityDate": "2013-12-06T03:38:33.760"}, "bq_ids": {"n4140": {"so_20414883_20415441_0": {"section_id": 6173, "quality": 0.9523809523809523, "length": 20}}, "n3337": {"so_20414883_20415441_0": {"section_id": 5934, "quality": 0.9523809523809523, "length": 20}}, "n4659": {"so_20414883_20415441_0": {"section_id": 7675, "quality": 0.9523809523809523, "length": 20}}}, "20414883": {"CommentCount": "2", "ViewCount": "144", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2013-12-06T02:35:23.447", "LastActivityDate": "2013-12-06T05:34:56.727", "Title": "How to interpret declval<_Dest>() = declval<_Src>() in is_assignable", "AcceptedAnswerId": "20415441", "LastEditDate": "2013-12-06T05:34:56.727", "Id": "20414883", "Score": "4", "Body": "<p>I am trying to figure out how to interpret declval&lt;_Dest&gt;() = declval&lt;_Src&gt;() in the implementation of is_assignable.</p>\n<p>declval turns a type into a reference.  Given that, I translate the expression into one of the following four possibilities:</p>\n<ol>\n<li>_Dest&amp;&amp; = _Src&amp;&amp; </li>\n<li>_Dest&amp;&amp; = _Src&amp; </li>\n<li>_Dest&amp; = _Src&amp;&amp; </li>\n<li>_Dest&amp; = _Src&amp;</li>\n</ol>\n<p>I then created two helper functions.</p>\n<pre><code>template &lt;typename T&gt; T rvalue();\ntemplate &lt;typename T&gt; T&amp; lvalue();\n</code></pre>\n<p>My understanding is the four expressions can be realized by using the template functions.</p>\n<ol>\n<li>_Dest&amp;&amp; = _Src&amp;&amp;   -----&gt;    rvalue&lt;_Dest&gt;() = rvalue&lt;_Src&gt;()</li>\n</ol>\n<p>Same goes for the other three.</p>\n<p>Then I simulated decltype(declval&lt;_Dest&gt;() = declval&lt;_Src&gt;(), ..) by compiling the templated function version of each of the possibilities for three pairs of concrete types.</p>\n<ul>\n<li>_Dest=int, _Src=int.  Compiler accepts #3 and #4.  is_assignable returned true for #3 and #4.  They agreed.</li>\n<li>_Dest=int, _Src=double.  Same result as </li>\n<li>_Dest=double, _Src=int.  For this one, the compiler and is_assignable didn't agree.  Compiler again does not like assigning to rvalues.  However, is_assignable returns true for all four possibilities.</li>\n</ul>\n<p>My questions are</p>\n<ul>\n<li>Did I interpret declval&lt;_Dest&gt;() = declval&lt;_Src&gt;() correctly?  In order words, does this really translate into the four possibilities.  If yes, can each one be mapped to a templated function expression?</li>\n<li>Why the compiler and is_assignable disagree on the _Dest=double, _Src=int case?</li>\n</ul>\n<p>Thanks.</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "264140", "AnswerCount": "1"}});