post_cb({"bq_ids": {"n4140": {"so_29990045_29990971_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 3906}, "so_29990045_29990971_6": {"length": 8, "quality": 0.8888888888888888, "section_id": 3906}}, "n3337": {"so_29990045_29990971_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 3766}, "so_29990045_29990971_6": {"length": 8, "quality": 0.8888888888888888, "section_id": 3766}}, "n4659": {"so_29990045_29990971_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 4792}}}, "29990971": {"Id": "29990971", "PostTypeId": "2", "Body": "<p>The reason the lifetime of the temporary is not extended is how the standard defines range-based for loops in</p>\n<blockquote>\n<h3>6.5.4 The range-based for statement [stmt.ranged]</h3>\n<p id=\"so_29990045_29990971_0\"><sup>1</sup> For a range-based <code>for</code> statement of the form</p>\n<p id=\"so_29990045_29990971_1\"><code>for (</code><em>for-range-declaration</em><code>:</code><em>expression</em><code>)</code><em>statement</em></p>\n<p id=\"so_29990045_29990971_2\">let <em>range-init</em> be equivalent to the <em>expression</em> surrounded by parentheses</p>\n<p id=\"so_29990045_29990971_3\"><code>( expression )</code></p>\n<p id=\"so_29990045_29990971_4\">and for a range-based <code>for</code> statement of the form</p>\n<p id=\"so_29990045_29990971_5\"><code>for (</code><em>for-range-declaration</em><code>:</code><em>braced-init-list</em><code>)</code><em>statement</em></p>\n<p id=\"so_29990045_29990971_6\">let <em>range-init</em> be equivalent to the <em>braced-init-list</em>. In each case, a range-based <code>for</code> statement is equivalent to</p>\n<pre><code>{\n   auto &amp;&amp; __range = range-init;\n   for ( auto __begin = begin-expr,\n              __end = end-expr;\n         __begin != __end;\n         ++__begin ) {\n      for-range-declaration = *__begin;\n      statement\n   }\n}\n</code></pre>\n</blockquote>\n<p>Note that <code>auto &amp;&amp; __range = range-init;</code> would extend the lifetime of a temporary returned from <em>range-init</em>, but it does not extend the lifetime of nested temporaries <em>inside</em> of <em>range-init</em>.</p>\n<p>This is IMHO a very unfortunate definition and was even discussed as <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#900\" rel=\"nofollow\">Defect Report 900</a>. It seems to be the only part of the standard where a reference is <strong><em>implicitly</em></strong> bound to extend the lifetime of an expressions result without extending the lifetime of nested temporaries.</p>\n<p>The solution is to store a copy in the wrapper - which often defeats the purpose of the wrapper.</p>\n", "LastActivityDate": "2015-05-01T16:31:39.067", "CommentCount": "3", "CreationDate": "2015-05-01T16:31:39.067", "ParentId": "29990045", "Score": "4", "OwnerUserId": "2073257"}, "29990419": {"Id": "29990419", "PostTypeId": "2", "Body": "<p>Lifetime extension only occurs when binding directly to references outside of a constructor.</p>\n<p>Reference lifetime extension within a constructor would be technically challenging for compilers to implement.</p>\n<p>If you want reference lifetime extension, you will be forced to make a copy of it.  The usual way is:</p>\n<pre><code>struct wrap {\n  wrap(A&amp;&amp; a) : a(std::move(a))\n  {} \n\n  const char* begin() const { return a.begin(); }\n  const char* end() const { return a.end(); }\n\n  A a;\n};\n</code></pre>\n<p>In many contexts, <code>wrap</code> is itself a template:</p>\n<pre><code>template&lt;class A&gt;\nstruct wrap {\n  wrap(A&amp;&amp; a) : a(std::forward&lt;A&gt;(a))\n  {} \n\n  const char* begin() const { return a.begin(); }\n  const char* end() const { return a.end(); }\n\n  A a;\n};\n</code></pre>\n<p>and if <code>A</code> is a <code>Foo&amp;</code> or a <code>Foo const&amp;</code>, references are stored.  If it is a <code>Foo</code>, then a copy is made.</p>\n<p>An example of such a pattern in use would be if <code>wrap</code> where called <code>backwards</code>, and it returned iterators that where reverse iterators constructed from <code>A</code>.  Then temporary ranges would be copied into <code>backwards</code>, while non-temporary objects would be just viewed.</p>\n<p>In theory, a language that allowed you to markup parameters to functions and constructors are \"dependent sources\" whose lifetime should be extended as long as the object/return value would be interesting.  This probably is tricky.  As an example, imagine <code>new wrap( A{\"works\"} )</code> -- the automatic storage temporary now has to last as long as the free store <code>wrap</code>!</p>\n", "LastActivityDate": "2015-05-01T15:58:09.583", "CommentCount": "3", "CreationDate": "2015-05-01T15:58:09.583", "ParentId": "29990045", "Score": "5", "OwnerUserId": "1774667"}, "29990045": {"ViewCount": "562", "Body": "<p>Consider a simple class <code>A</code> that can be used as a range:</p>\n<pre><code>struct A { \n    ~A() { std::cout &lt;&lt; \"~A \"; }\n\n    const char* begin() const {\n        std::cout &lt;&lt; \"A::begin \";\n        return s.data();\n    }   \n\n    const char* end() const {\n        std::cout &lt;&lt; \"A::end \";\n        return s.data() + s.size();\n    }   \n\n    std::string s;\n};\n</code></pre>\n<p>If I make a temporary <code>A</code> in a range-for, it works exactly as I would hope:</p>\n<pre><code>for (auto c : A{\"works\"}) {\n    std::cout &lt;&lt; c &lt;&lt; ' ';\n} \n\n// output\nA::begin A::end w o r k s ~A \n</code></pre>\n<p>However, if I try to wrap the temporary:</p>\n<pre><code>struct wrap {\n    wrap(A&amp;&amp; a) : a(std::move(a))\n    { } \n\n    const char* begin() const { return a.begin(); }\n    const char* end() const { return a.end(); }\n\n    A&amp;&amp; a;\n};\n\nfor (auto c : wrap(A{\"fails\"})) {\n    std::cout &lt;&lt; c &lt;&lt; ' ';\n}\n\n// The temporary A gets destroyed before the loop even begins: \n~A A::begin A::end \n^^\n</code></pre>\n<p>Why is <code>A</code>'s lifetime not extended for the full range-for expression, and how can I make that happen without resorting to making a copy of the <code>A</code>?</p>\n", "AcceptedAnswerId": "29990419", "Title": "temporary lifetime in range-for expression", "CreationDate": "2015-05-01T15:39:04.380", "Id": "29990045", "CommentCount": "3", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2016-09-27T04:05:12.197", "Score": "13", "OwnerUserId": "2069064", "Tags": "<c++><c++11>", "AnswerCount": "2"}});