post_cb({"44409207": {"CommentCount": "3", "AcceptedAnswerId": "44416191", "CreationDate": "2017-06-07T09:50:26.337", "LastActivityDate": "2017-07-04T22:50:02.267", "PostTypeId": "1", "ViewCount": "361", "FavoriteCount": "2", "Title": "Pointer arithmetic using cast to \"wrong\" type", "Id": "44409207", "Score": "6", "Body": "<p>I have an array of structs, and I have a pointer to <em>a member</em> of one of those structs.  I would like to know which element of the array contains the member.  Here are two approaches:</p>\n<pre><code>#include &lt;array&gt;\n#include &lt;string&gt;\n\nstruct xyz\n{\n    float x, y;\n    std::string name;\n};\n\ntypedef std::array&lt;xyz, 3&gt; triangle;\n\n// return which vertex the given coordinate is part of\nint vertex_a(const triangle&amp; tri, const float* coord)\n{\n    return reinterpret_cast&lt;const xyz*&gt;(coord) - tri.data();\n}\n\nint vertex_b(const triangle&amp; tri, const float* coord)\n{\n    std::ptrdiff_t offset = reinterpret_cast&lt;const char*&gt;(coord) - reinterpret_cast&lt;const char*&gt;(tri.data());\n    return offset / sizeof(xyz);\n}\n</code></pre>\n<p>Here's a test driver:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    triangle tri{{{12.3, 45.6}, {7.89, 0.12}, {34.5, 6.78}}};\n    for (const xyz&amp; coord : tri) {\n        std::cout\n            &lt;&lt; vertex_a(tri, &amp;coord.x) &lt;&lt; ' '\n            &lt;&lt; vertex_b(tri, &amp;coord.x) &lt;&lt; ' '\n            &lt;&lt; vertex_a(tri, &amp;coord.y) &lt;&lt; ' '\n            &lt;&lt; vertex_b(tri, &amp;coord.y) &lt;&lt; '\\n';\n    }\n}\n</code></pre>\n<p>Both approaches produce the expected results:</p>\n<pre><code>0 0 0 0\n1 1 1 1\n2 2 2 2\n</code></pre>\n<p><strong>But are they valid code?</strong></p>\n<p>In particular I wonder if <code>vertex_a()</code> might be invoking undefined behavior by casting <code>float* y</code> to <code>xyz*</code> since the result does not actually point to a <code>struct xyz</code>.  That concern led me to write <code>vertex_b()</code>, which I think is safe (is it?).</p>\n<p>Here's the code generated by GCC 6.3 with -O3:</p>\n<pre><code>vertex_a(std::array&lt;xyz, 3ul&gt; const&amp;, float const*):\n    movq    %rsi, %rax\n    movabsq $-3689348814741910323, %rsi ; 0xCCC...CD\n    subq    %rdi, %rax\n    sarq    $3, %rax\n    imulq   %rsi, %rax\n\nvertex_b(std::array&lt;xyz, 3ul&gt; const&amp;, float const*):\n    subq    %rdi, %rsi\n    movabsq $-3689348814741910323, %rdx ; 0xCCC...CD\n    movq    %rsi, %rax\n    mulq    %rdx\n    movq    %rdx, %rax\n    shrq    $5, %rax\n</code></pre>\n", "Tags": "<c++><language-lawyer><undefined-behavior><pointer-arithmetic>", "OwnerUserId": "4323", "AnswerCount": "4"}, "44914882": {"ParentId": "44409207", "CommentCount": "3", "Body": "<p><code>vertex_b</code> is completely fine. You only maybe need to refine <code>return offset / sizeof(xyz);</code> since you're dividing <code>std::ptrdiff_t</code> with <code>std::size_t</code> and implicitly casting the result into <code>int</code>.\nBy book, this behavior is implementation defined. <code>std::ptrdiff_t</code> is signed and <code>std::size_t</code> unsigned and result of division might be larger than <code>INT_MAX</code> (very unlikely) with huge array size on some platforms/compilers.</p>\n<p>To cast away your worries, you can put <code>assert()</code>s and/or <code>#error</code>s which check <code>PTRDIFF_MIN</code>, <code>PTRDIFF_MAX</code>, <code>SIZE_MAX</code>, <code>INT_MIN</code> and <code>INT_MAX</code>, but I personally would not bother so much.</p>\n", "OwnerUserId": "4161406", "PostTypeId": "2", "Id": "44914882", "Score": "2", "CreationDate": "2017-07-04T22:50:02.267", "LastActivityDate": "2017-07-04T22:50:02.267"}, "44409481": {"ParentId": "44409207", "CommentCount": "2", "Body": "<p><code>vertex_a</code> indeed breaks the strict aliasing rule (none of your <code>float</code>s are valid <code>xyz</code>s, and in 50% of your example they're not even at the start of an <code>xyz</code> even if there's no padding).</p>\n<p><code>vertex_b</code> relies on, shall we say, <em>creative</em> interpretation of the standard. Though your cast to <code>const char*</code> is sound, performing arithmetic with it around the rest of the array is a little more dodgy. Historically I've concluded that this kind of thing has undefined behaviour, because \"the object\" in this context is the <code>xyz</code>, not the array. However, I'm leaning towards others' interpretation nowadays that this will always work, and wouldn't expect anything else in practice.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "44409481", "Score": "4", "CreationDate": "2017-06-07T10:00:52.603", "LastActivityDate": "2017-06-07T10:00:52.603"}, "44416191": {"ParentId": "44409207", "CommentCount": "18", "Body": "<p>Neither is valid per the standard. </p>\n<hr/>\n<p>In <code>vertex_a</code>, you're allowed to convert a pointer to <code>xyz::x</code> to a pointer to <code>xyz</code> because they're <a href=\"http://eel.is/c++draft/basic#compound-4.3\" rel=\"noreferrer\"><em>pointer-interconvertible</em></a>:</p>\n<blockquote>\n<p id=\"so_44409207_44416191_0\">Two objects <em>a</em> and <em>b</em> are <em>pointer-interconvertible</em> if [...] one is a standard-layout class object and the other is the first non-static data member of that object [...]   </p>\n<p id=\"so_44409207_44416191_1\">If two objects are pointer-interconvertible, then they have the same address, and it is possible to obtain a pointer to one from a pointer to the other via a <code>reinterpret_\u00adcast</code>.</p>\n</blockquote>\n<p>But you can't do the cast from a pointer to <code>xyz::y</code> to a pointer to <code>xyz</code>. That operation is undefined.</p>\n<hr/>\n<p>In <code>vertex_b</code>, you're subtracting two pointers to <code>const char</code>. That operation is defined in <a href=\"http://eel.is/c++draft/expr.add\" rel=\"noreferrer\">[expr.add]</a> as:</p>\n<blockquote>\n<p id=\"so_44409207_44416191_2\">If the expressions <code>P</code> and <code>Q</code> point to, respectively, elements <code>x[i]</code> and <code>x[j]</code> of the same array object <code>x</code>, the expression <code>P - Q</code> has the value <code>i \u2212 j</code>; otherwise, the behavior is undefined</p>\n</blockquote>\n<p>Your expressions don't point to elements of an array of <code>char</code>, so the behavior is undefined. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "44416191", "Score": "7", "CreationDate": "2017-06-07T14:57:28.840", "LastActivityDate": "2017-06-07T14:57:28.840"}, "44909320": {"ParentId": "44409207", "CommentCount": "1", "Body": "<p>Perhaps a more robust approach would involve changing the type signature to <code>xyz::T*</code> (<code>T</code> is a template argument so you can take <code>xyz::x</code> or <code>xyz::y</code> as needed) instead of <code>float*</code> </p>\n<p>Then you can use <code>offsetof(struct xyz,T)</code> to confidently compute the location of the start of the struct in a way that should be more resilient to future changes in its definition.</p>\n<p>Then the rest follows as you are currently doing: once you have a pointer to the start of the struct finding its offset in the array is a valid pointer subtraction.</p>\n<p>There is some pointer nastiness involved. But this is an approach that is used. e.g. see the container_of() macro in the linux kernel.\n<a href=\"https://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/067/6717/6717s2.html\" rel=\"nofollow noreferrer\">https://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/067/6717/6717s2.html</a></p>\n", "OwnerUserId": "600618", "PostTypeId": "2", "Id": "44909320", "Score": "1", "CreationDate": "2017-07-04T15:06:11.190", "LastActivityDate": "2017-07-04T15:06:11.190"}, "bq_ids": {"n4140": {"so_44409207_44416191_0": {"section_id": 5879, "quality": 0.6153846153846154, "length": 8}, "so_44409207_44416191_2": {"section_id": 6143, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_44409207_44416191_0": {"section_id": 5621, "quality": 0.5384615384615384, "length": 7}, "so_44409207_44416191_2": {"section_id": 5907, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_44409207_44416191_0": {"section_id": 8733, "quality": 0.9230769230769231, "length": 12}, "so_44409207_44416191_1": {"section_id": 8733, "quality": 1.0, "length": 16}, "so_44409207_44416191_2": {"section_id": 7639, "quality": 1.0, "length": 12}}}});