post_cb({"31773372": {"Id": "31773372", "PostTypeId": "2", "Body": "<p>According to [class.conv]/1 (emphasis mine): </p>\n<blockquote>\n<p id=\"so_31772588_31773372_0\">Type conversions of class objects can be specified by constructors and by conversion <strong>functions</strong>.</p>\n</blockquote>\n<p>Thus, both <code>::N::f</code> and <code>::N::A::operator int()</code> are functions. However, [namespace.memdef]/3 specifies (emphasis mine): </p>\n<blockquote>\n<p id=\"so_31772588_31773372_1\">If a friend declaration in a non-local class first declares a class, function, class template or function template 97 the friend is a member of the innermost enclosing namespace. <strong>The friend declaration does not by itself make the name visible to unqualified lookup</strong> (3.4.1) or qualified lookup (3.4.3).</p>\n</blockquote>\n<p>Since <code>::N::f</code> is out of the picture while looking up for names, the closest is <code>::f</code> which then becomes <code>::N::A::operator int()</code>.</p>\n<hr>\n<p>The following code should clarify things. Because it fails to compile (in clang), it shows that <code>::N::f</code> has preference over <code>::f</code> when <code>::N::f</code> is actually in the list of available names.</p>\n<pre><code>#include &lt;boost/type_index.hpp&gt;\n#include &lt;iostream&gt;\n\ntypedef int f;\nnamespace N {\nstruct A;\nvoid f( A &amp; )\n{\n    std::cout &lt;&lt; \"::N::f\\n\";\n}\nstruct A {\n    friend void f(A &amp;);\n    operator int() { std::cout &lt;&lt; \"Yes, I am a function\\n\"; return 5; }\n    void g(A a) {\n        int i = f(a); // f is the typedef, not the friend\n                      // function: equivalent to int(a)\n        std::cout &lt;&lt; boost::typeindex::type_id_with_cvr&lt;decltype(f(a))&gt;().pretty_name() &lt;&lt; '\\n';\n        std::cout &lt;&lt; i;\n    }\n};\n}\n\nint main()\n{\n    N::A a;\n    a.g( a );\n}\n</code></pre>\n<hr>\n<p><strong>Further explanation</strong></p>\n<p>The part</p>\n<pre><code>void f( A &amp; )\n{\n    std::cout &lt;&lt; \"::N::f\\n\";\n}\n</code></pre>\n<p>is both the declaration (and the definition) of <code>::N::f</code>. That is, it introduces the name <code>::N::f</code> in the list of names contained in <code>::N</code>. When evaluating the <code>f</code> in <code>int i = f(a)</code>, we look in the list available names and we find <code>::N::f</code> before <code>::f</code>. Hence <code>f(a)</code> is type void and the code above fails to compile with the message \"cannot initialize a type int with a type void\". That is, <code>int i = f(a)</code> calls <code>::N::f</code> when <code>::N::f</code> is available even in the presence of <code>::N::A::operator int</code>.</p>\n<p>On the other hand, if we remove the <code>::N::f</code> definition part, the name <code>::N::f</code> exists only as introduced by the friend declaration. Since such a name cannot be the result of a lookup, then the <code>f</code> in <code>f(a)</code> is the next available, which is the global typedef <code>::f</code>. Now that we know that the <code>f</code> in <code>f(a)</code> is int, we can call the function <code>::N::A::operator int</code>.</p>\n</hr></hr>", "LastEditorUserId": "2549876", "LastActivityDate": "2015-08-02T16:47:25.913", "Score": "0", "CreationDate": "2015-08-02T15:24:00.473", "ParentId": "31772588", "CommentCount": "5", "OwnerUserId": "2549876", "LastEditDate": "2015-08-02T16:47:25.913"}, "31775526": {"Id": "31775526", "PostTypeId": "2", "Body": "<p>There are a few things going on here.  As the note containing the example says (3.4/3):</p>\n<blockquote>\n<p id=\"so_31772588_31775526_0\">For purposes of determining (during parsing) whether an expression is a <em>postfix-expression</em> for a function call, the usual name lookup rules apply. The rules in 3.4.2 have no effect on the syntactic interpretation of an expression.</p>\n</blockquote>\n<p>So first we need to know whether <code>f</code> is a <em>simple-type-specifier</em> or a <em>postfix-expression</em>, using name lookup rules that <em>don't</em> include section 3.4.2.  And under these rules, the function <code>N::f</code> is not visible.</p>\n<p>7.3.1.2/3:</p>\n<blockquote>\n<p id=\"so_31772588_31775526_1\">If a <code>friend</code> declaration in a non-local class first declares a class, function, class template or function template the friend is a member of the innermost enclosing namespace.  The <code>friend</code> declaration does not by itself make the name visible to unqualified lookup (3.4.1) or qualified lookup (3.4.3).</p>\n</blockquote>\n<p>Therefore the unqualified lookup does not see any declaration of <code>N::f</code> at all, and finds only <code>::f</code>, which is a typename.  So the syntax is <em>simple-type-specifier</em> <code>(</code> <em>expression-list</em> <sub>opt</sub> <code>)</code> and not <em>postfix-expression</em> <code>(</code> <em>expression-list</em> <sub>opt</sub> <code>)</code>, and argument-dependent lookup (3.4.2) does not apply.</p>\n<p>( If the unqualified lookup had found a function name, 3.4.2 would apply and would be able to include <code>N::f</code> in the candidate list despite the lack of declaration.  If <code>N::f</code> had a previous declaration other than the <code>friend</code>  declaration, it would have won the unqualified lookup. )</p>\n", "LastActivityDate": "2015-08-02T19:04:42.920", "CommentCount": "1", "CreationDate": "2015-08-02T19:04:42.920", "ParentId": "31772588", "Score": "0", "OwnerUserId": "459640"}, "31774979": {"Id": "31774979", "PostTypeId": "2", "Body": "<p>Standard (n4296) says as 11.3 \u00a71 (Member access control / Friends) <em>A class specifies its friends, if any, by way of friend declarations. Such declarations give\nspecial access rights to the friends, but they do not make the nominated friends members of the befriending\nclass.</em></p>\n<p>And at 7.3.1.2 (Namespace member definitions) \u00a73 <em>The friend declaration does not by\nitself make the name visible to unqualified lookup or qualified lookup</em>\n.</p>\n<p>I slightly modified your example to make it simpler to see what actually happens:</p>\n<ol>\n<li><p>any try to declare <code>f</code> outside <code>N</code> (meaning at top level scope) gives an error <em>redefinition of 'f' as different kind of symbol</em>, be it before of after the <code>namespace N</code> block</p>\n<pre><code>typedef int f;\n\nnamespace N {\nstruct A {\n    friend int f(A &amp;);\n    operator int();\n    int g(A a) {\n        int i = f(a); // f is the typedef, not the friend\n                      // function: equivalent to int(a)\n        return i;\n    }\n    int i;\n    A(int i): i(i) {};\n};\n}\n\n\nint f(N::A&amp; a) {  // Error here\n    return 2*a.i;\n}\nN::A::operator int() {\n    return this-&gt;i;\n}\n</code></pre></li>\n<li><p>if <code>f</code> is declared (in namespace <code>N</code>) <strong>after</strong> <code>int i = f(a)</code> <code>f</code> is taken as the int conversion:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntypedef int f;\n\nnamespace N {\nstruct A {\n    friend int f(A &amp;);\n    operator int();\n    int g(A a) {\n        int i = f(a); // f is the typedef, not the friend\n                      // function: equivalent to int(a)\n        return i;\n    }\n    int i;\n    A(int i): i(i) {};\n};\n\nint f(A&amp; a) {\n    return 2*a.i;\n}\n}\n\nN::A::operator int() {\n    return this-&gt;i;\n}\n\nint main() {\n    N::A a(2);\n    std::cout &lt;&lt; a.g(a) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>outputs 2</p></li>\n<li><p>if <code>f</code> is declared <strong>before</strong> <code>int i = f(a)</code> the function declaration inside the namespace has precedence over int conversion:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntypedef int f;\n\nnamespace N {\nint f(struct A&amp;); // &lt;= simple DECLARATION here\nstruct A {\n    friend int f(A &amp;);\n    operator int();\n    int g(A a) {\n        int i = f(a); // f is the typedef, not the friend\n                      // function: equivalent to int(a)\n        return i;\n    }\n    int i;\n    A(int i): i(i) {};\n};\n\nint f(A&amp; a) {\n    return 2*a.i;\n}\n}\n\nN::A::operator int() {\n    return this-&gt;i;\n}\n\nint main() {\n    N::A a(2);\n    std::cout &lt;&lt; a.g(a) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>outputs 4</p></li>\n</ol>\n<p>TL/DR : The example on the standard assumes that there is no declaration of the function <code>f</code> before <code>int i = f(a);</code>. As a friend declaration in a class or in a namespace <strong>does not</strong> make the name visible to unqualified lookup or qualified lookup, the only declaration that is visible at that time is <code>typedef int f;</code>. So <code>f</code> is taken as the typedef.</p>\n<p>But if there is a declaration for the function <code>f</code> in the namespace, it will take precedence over the typedef, because in N scope it hides the top level declaration.</p>\n", "LastEditorUserId": "3545273", "LastActivityDate": "2015-08-02T22:23:56.473", "Score": "0", "CreationDate": "2015-08-02T18:07:49.270", "ParentId": "31772588", "CommentCount": "4", "OwnerUserId": "3545273", "LastEditDate": "2015-08-02T22:23:56.473"}, "31773124": {"Id": "31773124", "PostTypeId": "2", "Body": "<p>The statements around the quote are actually quite clear on why the example does not call the function <code>f</code>:</p>\n<blockquote>\n<p id=\"so_31772588_31773124_0\">Because the expression is not a function call, the argument-dependent name lookup (3.4.2) does not apply and the friend function f is not found.</p>\n</blockquote>\n<p>The actual question is <em>why</em> the argument-dependent look-up is not applies. It seems 5.2.3 [expr.type.conv] paragraph 1 applies:</p>\n<blockquote>\n<p id=\"so_31772588_31773124_1\">A <em>simple-type-specifier</em> (7.1.6.2) or <em>typename-specifier</em> (14.6) followed by a parenthesized <em>expression-list</em> constructs a value of the specified type given the expression list.</p>\n</blockquote>\n<p>Clearly, <code>f</code> is a <em>simple-type-specifier</em>: the <code>typedef int f;</code> arranges for that to be the case. Remove this <code>typedef</code> and <code>f</code> isn't a <em>simple-type-specifier</em> anymore resulting in <code>N::A::f</code> being found.</p>\n", "LastActivityDate": "2015-08-02T14:57:14.063", "CommentCount": "6", "CreationDate": "2015-08-02T14:57:14.063", "ParentId": "31772588", "Score": "0", "OwnerUserId": "1120273"}, "bq_ids": {"n4140": {"so_31772588_31773372_0": {"length": 9, "quality": 1.0, "section_id": 383}, "so_31772588_31773348_0": {"length": 46, "quality": 0.9583333333333334, "section_id": 7105}, "so_31772588_31773372_1": {"length": 28, "quality": 0.9032258064516129, "section_id": 5485}, "so_31772588_31775526_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 7089}, "so_31772588_31773124_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 7089}, "so_31772588_31773124_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 5999}, "so_31772588_31775526_1": {"length": 28, "quality": 0.9032258064516129, "section_id": 5485}}, "n3337": {"so_31772588_31773372_0": {"length": 9, "quality": 1.0, "section_id": 374}, "so_31772588_31773348_0": {"length": 46, "quality": 0.9583333333333334, "section_id": 6849}, "so_31772588_31773372_1": {"length": 20, "quality": 0.6451612903225806, "section_id": 5271}, "so_31772588_31775526_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 6833}, "so_31772588_31773124_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 6833}, "so_31772588_31773124_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 5767}, "so_31772588_31775526_1": {"length": 20, "quality": 0.6451612903225806, "section_id": 5271}}, "n4659": {"so_31772588_31773372_0": {"length": 9, "quality": 1.0, "section_id": 400}, "so_31772588_31773348_0": {"length": 46, "quality": 0.9583333333333334, "section_id": 8606}, "so_31772588_31773372_1": {"length": 28, "quality": 0.9032258064516129, "section_id": 6920}, "so_31772588_31775526_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 8590}, "so_31772588_31773124_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 8590}, "so_31772588_31773124_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 7499}, "so_31772588_31775526_1": {"length": 28, "quality": 0.9032258064516129, "section_id": 6920}}}, "31773348": {"Id": "31773348", "PostTypeId": "2", "Body": "<p>\"Type casting\" has nothing to do with this scenario. The rules for argument-dependent lookup include, from [basic.lookup.argdep]:</p>\n<blockquote>\n<p id=\"so_31772588_31773348_0\">Let X be the lookup set produced by unqualified lookup (3.4.1) and let Y be the lookup set produced by\n  argument dependent lookup (defined as follows). If X contains<br>\n  (3.1) \u2014 a declaration of a class member, or<br>\n  (3.2) \u2014 a block-scope function declaration that is not a using-declaration, or<br>\n  (3.3) \u2014 <strong>a declaration that is neither a function or a function template</strong><br>\n  then Y is empty. Otherwise Y is the set of declarations found in the namespaces associated with the argument types as described below. The set of declarations found by the lookup of the name is the union of\n  X and Y.</br></br></br></br></p>\n</blockquote>\n<p>The lookup set produced by unqualified lookup for <code>f</code> is:</p>\n<pre><code>typedef int f;\n</code></pre>\n<p>That declaration is neither a function nor a function template, therefore Y is empty. We do not consider the friend function <code>f</code>, since it is not visible to unqualified lookup.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-08-02T20:56:07.467", "Score": "2", "CreationDate": "2015-08-02T15:21:36.857", "ParentId": "31772588", "CommentCount": "5", "OwnerUserId": "2069064", "LastEditDate": "2015-08-02T20:56:07.467"}, "31772588": {"ViewCount": "213", "Body": "<p>I need an explanation on this example from standard [basic.lookup.unqual]/3:</p>\n<pre><code>typedef int f;\nnamespace N {\nstruct A {\n    friend void f(A &amp;);\n    operator int();\n    void g(A a) {\n        int i = f(a); // f is the typedef, not the friend\n                      // function: equivalent to int(a)\n    }\n};\n}\n</code></pre>\n<p>I would argue that <code>void N::f(A &amp;)</code> is closer than <code>int(a)</code> because it does not involve the type-cast operator. I cannot however be sure because the standard contains only one instance of \"type cast\".</p>\n<hr>\n<p>By the way, compiling that code fails in MSVC2015 (but it works in clang and g++).</p>\n<blockquote>\n<p id=\"so_31772588_31772588_0\">Error C2440   'initializing': cannot convert from 'void' to 'int'</p>\n</blockquote>\n<hr>\n<p><strong>UPDATE</strong>\nAddressing some of the comments.</p>\n<ol>\n<li><p>Type casting is formally known as \"type conversions\" and they are covered in (12.3) (thanks jefffrey).</p></li>\n<li><p>What I am looking for is a description of the syntax parsing. In particular, why <code>postfix-expression ( expression-list opt )</code> is trampled over by <code>simple-type-specifier ( expression-list opt )</code>. Since according to (5.2), both of those expression are evaluated left-to-right. Hence, out of the two candidates to be before the <code>(a)</code>, <code>::N::f</code> should be closer than <code>::f</code> when evaluating expressions in <code>::N::A::g</code>.</p></li>\n</ol>\n</hr></hr>", "AcceptedAnswerId": "31775526", "Title": "C++ name lookup - example from the standard", "CreationDate": "2015-08-02T13:55:59.277", "Id": "31772588", "CommentCount": "9", "LastEditDate": "2015-08-02T14:38:37.617", "PostTypeId": "1", "LastEditorUserId": "2549876", "LastActivityDate": "2015-08-02T22:23:56.473", "Score": "2", "OwnerUserId": "2549876", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "5"}});