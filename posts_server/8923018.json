post_cb({"8923018": {"CommentCount": "5", "AcceptedAnswerId": "8923103", "CreationDate": "2012-01-19T08:27:55.637", "LastActivityDate": "2012-01-19T10:40:30.820", "PostTypeId": "1", "ViewCount": "525", "FavoriteCount": "2", "Title": "What comes first - stack unwinding or copying of return values", "Id": "8923018", "Score": "15", "Body": "<p>Is the mutex used in method <code>GetValues()</code> released <strong>before</strong> or <strong>after</strong> copy constructing the <code>dummy</code> instance?</p>\n<pre><code>class Protect\n{};\n\nclass Test\n{\npublic:\n    Protect GetValues() const;\n\nprivate:\n    Protect m_protVal;\n    Mutex m_mutex;\n};\n\nProtect Test::GetValues() const\n{\n    CLockGuard lock(m_mutex);\n\n    return m_protVal;\n}\n\nint main(int argc, char** argv)\n{\n    Test myTestInstance;\n\n    Protect dummy = myTestInstance.GetValues();\n}\n</code></pre>\n<p>Let's assume <code>CLockGuard</code> and <code>Mutex</code> are standard classes provided with boost lib.</p>\n", "Tags": "<c++>", "OwnerUserId": "220636", "AnswerCount": "4"}, "8923731": {"ParentId": "8923018", "CommentCount": "0", "Body": "<p>Here is a small complete test programm (in addition to James Kanzes good explanation), which will show if the unlock is done <strong>before</strong> or <strong>after</strong> stack unwinding:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass PseudoLockGuard\n{\npublic:\n    enum LockState { IsStillLocked, IsUnlocked};\n\n    PseudoLockGuard(LockState&amp; value) : m_value(value) {};\n    ~PseudoLockGuard() { m_value = IsUnlocked; };\n\nprivate:\n    LockState&amp; m_value;\n};\n\nPseudoLockGuard::LockState Test()\n{\n    PseudoLockGuard::LockState indicator = PseudoLockGuard::IsStillLocked;\n\n    PseudoLockGuard lock(indicator);\n\n    return indicator;// Will return IsStillLocked or IsUnlocked?\n}\n\nint main(int , char** )\n{\n   PseudoLockGuard::LockState result = Test();\n\n   std::cout &lt;&lt; (result == PseudoLockGuard::IsStillLocked \n                 ? \"Return Value before Unlock\" \n                 : \"Return Value after Unlock\"); \n\n   // Outputs \"Return Value before Unlock\"\n\n   return 0;\n}\n</code></pre>\n", "OwnerUserId": "913577", "PostTypeId": "2", "Id": "8923731", "Score": "1", "CreationDate": "2012-01-19T09:32:44.777", "LastActivityDate": "2012-01-19T09:32:44.777"}, "8923200": {"ParentId": "8923018", "CommentCount": "0", "Body": "<p>As of Visual C++, using MSVC 9.0, the following code</p>\n<pre><code>int add(int x, int y)\n{\n    int z;\n    z = x + y;\n    return z;\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    add(10, 20);\n    return 0;\n}\n</code></pre>\n<p>results in assembly</p>\n<pre><code>int add(int x, int y)\n{\n013613A0  push        ebp  //save the frame pointer\n013613A1  mov         ebp,esp \n013613A3  sub         esp,0CCh \n013613A9  push        ebx  \n013613AA  push        esi  \n013613AB  push        edi  \n013613AC  lea         edi,[ebp-0CCh] \n013613B2  mov         ecx,33h \n013613B7  mov         eax,0CCCCCCCCh \n013613BC  rep stos    dword ptr es:[edi] \n    int z;\n    z = x + y;\n013613BE  mov         eax,dword ptr [x] //load x\n013613C1  add         eax,dword ptr [y] //add y to x\n013613C4  mov         dword ptr [z],eax //store the result to z\n    return z;\n013613C7  mov         eax,dword ptr [z] //store the return value in eax\n}\n013613CA  pop         edi  //unwind the stack\n013613CB  pop         esi  \n013613CC  pop         ebx  \n013613CD  mov         esp,ebp \n013613CF  pop         ebp  \n013613D0  ret\n\nint _tmain(int argc, _TCHAR* argv[])\n{    \n013613E0  push        ebp  \n013613E1  mov         ebp,esp \n013613E3  sub         esp,0C0h \n013613E9  push        ebx  \n013613EA  push        esi  \n013613EB  push        edi  \n013613EC  lea         edi,[ebp-0C0h] \n013613F2  mov         ecx,30h \n013613F7  mov         eax,0CCCCCCCCh \n013613FC  rep stos    dword ptr es:[edi] \n    add(10, 20);\n013613FE  push        14h  \n01361400  push        0Ah  \n01361402  call        add (136109Bh) \n01361407  add         esp,8 \n    return 0;\n0136140A  xor         eax,eax //store 0 to eax, the return value holder\n}\n0136140C  pop         edi  //unwind the stack\n0136140D  pop         esi  \n0136140E  pop         ebx  \n</code></pre>\n<p>This makes me say that return value is stored first and then the stack unwinding happens!</p>\n", "OwnerUserId": "524784", "PostTypeId": "2", "Id": "8923200", "Score": "2", "CreationDate": "2012-01-19T08:45:10.547", "LastActivityDate": "2012-01-19T08:45:10.547"}, "8923103": {"ParentId": "8923018", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Yes:-).  Formally, there are two \u201ccopies\u201d when returning a\nvalue: one to some special place used to actually return the value, and\nthe second after the return, to wherever the value must be finally\nplaced.  Either or both can be optimized out, however.  The destruction\nof local variables occurs after the first, but before the second.  (NRVO\nand RVO may lead to the first being optimized out, but they don't affect\nyour code, since you're not returning a local variable.) </p>\n", "OwnerUserId": "649665", "LastEditorUserId": "147192", "LastEditDate": "2012-01-19T10:40:30.820", "Id": "8923103", "Score": "11", "CreationDate": "2012-01-19T08:36:02.297", "LastActivityDate": "2012-01-19T10:40:30.820"}, "bq_ids": {"n4140": {"so_8923018_8923762_3": {"section_id": 378, "quality": 0.7647058823529411, "length": 13}, "so_8923018_8923762_4": {"section_id": 380, "quality": 0.9333333333333333, "length": 14}, "so_8923018_8923762_2": {"section_id": 3913, "quality": 0.90625, "length": 29}}, "n3337": {"so_8923018_8923762_3": {"section_id": 369, "quality": 0.7647058823529411, "length": 13}, "so_8923018_8923762_4": {"section_id": 371, "quality": 0.9333333333333333, "length": 14}, "so_8923018_8923762_2": {"section_id": 3773, "quality": 0.90625, "length": 29}}, "n4659": {"so_8923018_8923762_4": {"section_id": 395, "quality": 0.9333333333333333, "length": 14}, "so_8923018_8923762_3": {"section_id": 392, "quality": 0.7058823529411765, "length": 12}}}, "8923762": {"ParentId": "8923018", "CommentCount": "0", "Body": "<p>The standard is not particularly explicit on the matter as far as I can tell, but here's what I've managed to get together:</p>\n<blockquote>\n<p id=\"so_8923018_8923762_0\">Automatic storage duration objects are destroyed as per 6.7 when the block they\n  are declared in exits.\n  - 3.7.2</p>\n<p id=\"so_8923018_8923762_1\">On exit from a scope, destructors (12.4) are called for all automatic storage\n  duration (3.7.2) (named objects and temporaries) that are declared in that scope,\n  in reverse order of their declaration. \n  - 6.6</p>\n<p id=\"so_8923018_8923762_2\">A return statement with an expression of non-void type can be used only in functions\n  returning a value; the value of the expression is returned to the caller of the\n  function.  The expression is implicitly converted to the return type of the function\n  in which it appears.  A return statement can involve the construction and copy of a\n  temporary object (12.2).\n  - 6.6.3</p>\n<p id=\"so_8923018_8923762_3\">Even when the creation of the temporary object is avoided (12.6), all the semantic\n  restrictions must be respected as if the temporary object was created.\n  - 12.2</p>\n</blockquote>\n<p>This seems to generally confirm what James said:  on <code>return m_protVal;</code>, a temporary is created, and then destructors of all objects that must be destroyed are called in reverse order of their declaration (in this case, only the destructor of <code>lock</code> is called).  However, I am not entirely sure how to interpret the following:</p>\n<blockquote>\n<p id=\"so_8923018_8923762_4\">Temporary objects are destroyed as the last step in evaluating the full-expression (1.9)\n  that (lexically) contains the point where they were created.\n  - 12.2</p>\n</blockquote>\n<p>A <em>full-expression</em> is defined as \"as expression that is not a subexpression of another expression\".  I don't know what part of <code>return m_protVal</code> is the full expression: geordi says that this is a</p>\n<blockquote>\n<p id=\"so_8923018_8923762_5\">decl'ion-seq \u2192 decl'ion \u2192 func-def \u2192 func-body \u2192 compound-stmt \u2192 stmt-seq \u2192 stmt \u2192 jump-stmt</p>\n</blockquote>\n<p>while <code>i</code> by itself is a</p>\n<blockquote>\n<p id=\"so_8923018_8923762_6\">decl'ion-seq \u2192 decl'ion \u2192 func-def \u2192 func-body \u2192 compound-stmt \u2192 stmt-seq \u2192 stmt \u2192\n  jump-stmt \u2192 \u2026 \u2192 id-expr \u2192 unqual-id \u2192 ident</p>\n</blockquote>\n<p>This makes it unclear whether the temporary may be copied and destroyed prior to the rest of the destructors being called: I would say it may not, as <code>return m_protVal;</code> causes the end of the block to be reached, but I can't find anything in the standard that would confirm this.</p>\n<p>(On the other hand, I don't see any case where such behaviour would cause any breakage; nobody should have a pointer to the temporary so it being destroyed first is not an issue, and if the temporary had a pointer to a local variable, the problems come in when the temporary is destroyed later -- not that writing code like that is a good idea in any case.)</p>\n", "OwnerUserId": "559931", "PostTypeId": "2", "Id": "8923762", "Score": "2", "CreationDate": "2012-01-19T09:34:50.513", "LastActivityDate": "2012-01-19T09:34:50.513"}});