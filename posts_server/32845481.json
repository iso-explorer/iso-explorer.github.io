post_cb({"bq_ids": {"n4140": {"so_32845481_32847815_0": {"length": 36, "quality": 0.9, "section_id": 6049}, "so_32845481_32847815_1": {"length": 20, "quality": 1.0, "section_id": 6049}, "so_32845481_32847815_2": {"length": 27, "quality": 0.6585365853658537, "section_id": 6049}}, "n3337": {"so_32845481_32847815_1": {"length": 20, "quality": 1.0, "section_id": 5817}, "so_32845481_32847815_2": {"length": 27, "quality": 0.6585365853658537, "section_id": 5817}, "so_32845481_32847815_0": {"length": 36, "quality": 0.9, "section_id": 5817}}, "n4659": {"so_32845481_32847815_1": {"length": 20, "quality": 1.0, "section_id": 7548}, "so_32845481_32847815_2": {"length": 27, "quality": 0.6585365853658537, "section_id": 7548}, "so_32845481_32847815_0": {"length": 36, "quality": 0.9, "section_id": 7548}}}, "32845481": {"ViewCount": "597", "Body": "<p>I'm doing the following:</p>\n<ul>\n<li>Taking a member function pointer with <strong>3 params</strong> from a <strong>derived class</strong>.</li>\n<li>Casting it to a member function pointer from <strong>the base class</strong> with <strong>0 params</strong>.</li>\n<li>Casting it to <strong>the base class</strong> with <strong>the 3 params</strong> back.</li>\n<li>Calling it.</li>\n</ul>\n<p>It works fine (so far), but should i keep it?</p>\n<p>Description of current code:</p>\n<p>EventsWarehouse is used to store and invoke events:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;unordered_map&gt;\n\nclass EventsWarehouse\n{\npublic:\n    typedef std::tuple&lt;AView*, void (AView::*)()&gt;           box_t;\n    typedef std::unordered_multimap&lt;std::string, box_t&gt;     boxes_t;\n\n    void        storeEvent(std::string const &amp;event, AView *v, void (AView::*callback)())\n        {\n            this-&gt;_events.insert(std::make_pair(event, std::make_tuple(v, callback)));\n            return ;\n        }\n\n    template&lt;typename... Args&gt;\n    bool        fireEvent(std::string const &amp;event, Args... args)\n        {\n            auto                it = this-&gt;_events.find(event);\n            AView               *v;\n            void                (AView::*callback_)();\n            void                (AView::*callback)(Args...);\n\n            for (; it != this-&gt;_events.end(); it++)\n            {\n                v = std::get&lt;0&gt;(it-&gt;second);\n                callback_ = std::get&lt;1&gt;(it-&gt;second);\n                /*\n                ** CAST #2\n                ** &lt;void (AView::*)()&gt;\n                **  to\n                ** &lt;void (AView::*)(std::string, int, double)&gt;\n                **  before call\n                */\n                callback = reinterpret_cast&lt;void (AView::*)(Args...)&gt;(callback_);\n                (v-&gt;*callback)(args...);\n            }\n            return (true);\n        }\nprivate:\n    boxes_t         _events;\n\n};\n</code></pre>\n<p>View classes stored in the above class:</p>\n<pre><code>class AView\n{\nprotected:\n    AView(){}\n};\n\nclass DerivedView : public AView\n{\npublic:\n    void    fooCallback(std::string s, int i, double d)\n        {\n            std::cout &lt;&lt; \"DerivedView::fooCallback received \" &lt;&lt; s &lt;&lt; \", \" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; d &lt;&lt; std::endl;\n            return ;\n        }\n};\n</code></pre>\n<p>Main:</p>\n<pre><code>int                         main(void)\n    {\n        DerivedView     dv;\n        EventsWarehouse ewh;\n\n        /*\n        ** CAST #1\n        ** &lt;void (DerivedView::*)(std::string, int, double)&gt;\n        **  to\n        ** &lt;void (AView::*)()&gt;\n        **  for storing purpose\n        */\n        ewh.storeEvent(\"event 1\", &amp;dv, reinterpret_cast&lt;void (AView::*)()&gt;(&amp;DerivedView::fooCallback));\n        ewh.fireEvent(\"event 1\", std::string(\"Hello World\"), 42, 84.42);\n        return (0);\n    }\n</code></pre>\n", "AcceptedAnswerId": "32847815", "Title": "Member function pointer cast, from Derived to Base class", "CreationDate": "2015-09-29T13:37:33.013", "Id": "32845481", "CommentCount": "2", "LastEditDate": "2015-09-29T18:28:41.927", "PostTypeId": "1", "LastEditorUserId": "3545273", "LastActivityDate": "2015-09-29T18:28:41.927", "Score": "2", "OwnerUserId": "4952173", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "32847815": {"Id": "32847815", "PostTypeId": "2", "Body": "<p>According to draft n4296 for C++11 specification, 5.2.10 Reinterpret cast [expr.reinterpret.cast] \u00a710</p>\n<blockquote>\n<p id=\"so_32845481_32847815_0\">A prvalue of type \u201cpointer to member of X of type T1\u201d can be explicitly converted to a prvalue of a different type \u201cpointer to member of Y of type T2\u201d if T1 and T2 are both function types or both object types.72 The\n  null member pointer value (4.11) is converted to the null member pointer value of the destination type. The result of this conversion is unspecified, except in the following cases:</p>\n<p id=\"so_32845481_32847815_1\">\u2014 converting a prvalue of type \u201cpointer to member function\u201d to a different pointer to member function\n  type and back to its original type yields the original pointer to member value.</p>\n<p id=\"so_32845481_32847815_2\">\u2014 converting a prvalue of type \u201cpointer to data member of X of type T1\u201d to the type \u201cpointer to data\n  member of Y of type T2\u201d (where the alignment requirements of T2 are no stricter than those of T1)\n  and back to its original type yields the original pointer to member value.\n  the conversion to a pointer to member function with no parameters and back to a member functions with correct parameters should give back original pointer.</p>\n</blockquote>\n<p>IMHO, the problem is that <code>fooCallback</code> is only defined on <code>DerivedView</code> class, and as such it is <strong>not</strong> a member function of class <code>AView</code>.</p>\n<p>This would be correct:</p>\n<pre><code>void (AView::*p)() = reinterpret_cast&lt;void (AView::*)()&gt;(&amp;DerivedView::fooCallback);\nvoid (DerivedView::*callback)(std::string, int, double) =\n       reinterpret_cast&lt;void (DerivedView::*)(std::string, int, double)&gt;(p);\nv-&gt;callback(\"Hello World\"), 42, 84.42);\n</code></pre>\n<p>provided <code>v</code> is a <code>AView *</code> pointing to a <code>DerivedView</code></p>\n<p>But as you end converting a <code>void (DerivedView::*)(std::string, int, double)</code> to a <code>void (AView::*)(std::string, int, double)</code> they are different type so conversion is unspecified</p>\n<p>It works, because common implementation for non static non virtual member functions is simply a normal (non member) function with a hidden parameter being <code>this</code>. So the pointer to member just stores the address of that function and correctly calls it with a pointer to a <code>DerivedView</code> giving expected result. But a different implementation could also store the actual type and raise an exception (or do anything else).</p>\n<p>TL/DR: As you end with a conversion from <code>void (DerivedView::*)(std::string, int, double)</code> to <code>void (AView::*)(std::string, int, double)</code> you do not cast to pointer to member to its original type and invoke undefined behaviour.</p>\n", "LastActivityDate": "2015-09-29T15:19:13.943", "Score": "1", "CreationDate": "2015-09-29T15:19:13.943", "ParentId": "32845481", "CommentCount": "0", "OwnerUserId": "3545273"}});