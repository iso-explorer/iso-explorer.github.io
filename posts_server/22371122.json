post_cb({"bq_ids": {"n4140": {"so_22371122_22372936_2": {"length": 28, "quality": 0.875, "section_id": 6033}, "so_22371122_22372936_1": {"length": 39, "quality": 0.639344262295082, "section_id": 6046}, "so_22371122_22372936_3": {"length": 45, "quality": 0.9574468085106383, "section_id": 6039}}, "n3337": {"so_22371122_22372936_2": {"length": 28, "quality": 0.875, "section_id": 5801}, "so_22371122_22372936_1": {"length": 57, "quality": 0.9344262295081968, "section_id": 5814}, "so_22371122_22372936_3": {"length": 45, "quality": 0.9574468085106383, "section_id": 5807}}, "n4659": {"so_22371122_22372936_2": {"length": 28, "quality": 0.875, "section_id": 7532}, "so_22371122_22372936_1": {"length": 38, "quality": 0.6229508196721312, "section_id": 7545}, "so_22371122_22372936_3": {"length": 30, "quality": 0.6382978723404256, "section_id": 7536}}}, "22371913": {"Id": "22371913", "PostTypeId": "2", "Body": "<p>No.\nWell I have to type some umpteen characters here to satisfy SO sillyrules, but the answer's still the same. However, I might use this extra text to mention that of course the effective guaranteees you have can be more practical than what the holy C++ standard offers. But then, that's evident to anyone with a brain (as programmers are wont to have), so it might sound a bit patronizing to mention that, but on the third hand, this should be enough text for SO.</p>\n<hr>\n<p>Oh, now looking at your code, I think the first assertion should not hold (in general), because as I recall nothing is guaranteed about the memory order of base class sub-objects. You might want to check that. Also in practice by doing the same with other base class.</p>\n</hr>", "LastEditorUserId": "464581", "LastActivityDate": "2014-03-13T07:38:28.187", "Score": "1", "CreationDate": "2014-03-13T07:30:41.670", "ParentId": "22371122", "CommentCount": "0", "LastEditDate": "2014-03-13T07:38:28.187", "OwnerUserId": "464581"}, "22372936": {"Id": "22372936", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_22371122_22372936_0\">Does reinterpret_cast guarantee it will never change the value of its operand?</p>\n</blockquote>\n<p><strong>TL;DR</strong> I think <em>Yes</em>, under some conditions.</p>\n<p>The guarantee should hold <em>as long as</em> the destination type has an alignment requirement no stricter than the source type. Otherwise the effect of the conversion is unspecified.</p>\n<hr>\n<p>The simplest way is to ask the Standard, and specifically: <strong>\u00a75.2.10 [expr.reinterpret.cast]</strong></p>\n<blockquote>\n<p id=\"so_22371122_22372936_1\">7/ An object pointer can be explicitly converted to an object pointer of a different type.70 When a prvalue v of type \u201cpointer to T1\u201d is converted to the type \u201cpointer to <em>cv</em> T2\u201d, the result is <code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(v))</code> if both T1 and T2 are standard-layout types (3.9) and the alignment requirements of T2 are no stricter than those of T1, or if either type is <code>void</code>. Converting a prvalue of type \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than those of T1) and back to its original type yields the original pointer value. The result of any other such pointer conversion is unspecified.</p>\n</blockquote>\n<p>In your case <em>since there is no <code>virtual</code> method in this hierarchy</em>, the types are <em>standard-layout types</em>. And since indeed both have the same alignment requirements (as they contain the same values), then indeed we match the well-specified effects here and thus:</p>\n<pre><code>reinterpret_cast&lt;I2*&gt;(d)\n</code></pre>\n<p>is equivalent to:</p>\n<pre><code>static_cast&lt;I2*&gt;(static_cast&lt;void*&gt;(d))\n</code></pre>\n<hr>\n<p>Thus we need go back to <strong>\u00a75.2.9 [expr.static.cast]</strong>:</p>\n<blockquote>\n<p id=\"so_22371122_22372936_2\">7/ The inverse of any standard conversion sequence (Clause 4) not containing an lvalue-to-rvalue (4.1), array-to-pointer (4.2), function-to-pointer (4.3), null pointer (4.10), null member pointer (4.11), or boolean (4.12) conversion, can be performed explicitly using <code>static_cast</code>. A program is ill-formed if it uses <code>static_cast</code> to perform the inverse of an ill-formed standard conversion sequence.</p>\n</blockquote>\n<p><code>T*</code> to <code>void*</code> is a standard conversion sequence according to <strong>\u00a74.10 [conv.ptr]</strong>, paragraph 2; so I <em>suppose</em> this means that a <code>static_cast</code> from <code>void*</code> to <code>T*</code> should yield the same address (supposing it matches the alignment requirements of <code>T</code> in the first place).</p>\n<blockquote>\n<p id=\"so_22371122_22372936_3\">13/ A prvalue of type \u201cpointer to <em>cv1</em> void\u201d can be converted to a prvalue of type \u201cpointer to <em>cv2</em> T,\u201d where T is an object type and <em>cv2</em> is the same cv-qualification as, or greater cv-qualification than, <em>cv1</em>. The null pointer value is converted to the null pointer value of the destination type. A value of type pointer to object converted to \u201cpointer to <em>cv</em> <code>void</code>\u201d and back, possibly with different cv-qualification, shall have its original value. [ <em>Example:</em></p>\n<pre><code>T* p1 = new T;\nconst T* p2 = static_cast&lt;const T*&gt;(static_cast&lt;void*&gt;(p1));\nbool b = p1 == p2; // b will have the value true.\n</code></pre>\n<p id=\"so_22371122_22372936_4\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<p>Unfortunately, the example is off (compared to your case); so we don't get much from this. I just cited it for completeness since it was related.</p>\n</hr></hr>", "LastActivityDate": "2014-03-13T08:27:36.500", "Score": "3", "CreationDate": "2014-03-13T08:27:36.500", "ParentId": "22371122", "CommentCount": "0", "OwnerUserId": "147192"}, "22371122": {"ViewCount": "133", "Body": "<pre><code>#include &lt;cassert&gt;\n\nstruct A { int a; };\nstruct I1 : A { int a; };\nstruct I2 : A { int a; };\nstruct D : I1, I2 { int a; };\n\nusing namespace std;\n\nint main()\n{\n    auto d  = new D;\n\n    auto a = static_cast&lt;I2*&gt;(d);\n    assert((void*)(a) != (void*)(d)); // OK\n\n    auto b = reinterpret_cast&lt;I2*&gt;(d);\n    assert((void*)(b) == (void*)(d)); // OK under VC++. Is it guaranteed?\n}\n</code></pre>\n<p>Does <code>reinterpret_cast</code> guarantee it will never change the value of its operand?</p>\n", "AcceptedAnswerId": "22372936", "Title": "Does reinterpret_cast guarantee it will never change the value of its operand?", "CreationDate": "2014-03-13T06:48:30.560", "Id": "22371122", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-03-13T08:27:36.500", "Score": "1", "OwnerUserId": "508343", "Tags": "<c++><c++11><compiler-construction><type-conversion><portability>", "AnswerCount": "2"}});