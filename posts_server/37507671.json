post_cb({"bq_ids": {"n4140": {"so_37507671_37507825_0": {"length": 18, "quality": 1.0, "section_id": 466}, "so_37507671_37507807_1": {"length": 18, "quality": 1.0, "section_id": 468}, "so_37507671_37507807_0": {"length": 18, "quality": 1.0, "section_id": 466}}, "n3337": {"so_37507671_37507825_0": {"length": 18, "quality": 1.0, "section_id": 457}, "so_37507671_37507807_1": {"length": 18, "quality": 1.0, "section_id": 459}, "so_37507671_37507807_0": {"length": 18, "quality": 1.0, "section_id": 457}}, "n4659": {"so_37507671_37507825_0": {"length": 18, "quality": 1.0, "section_id": 489}, "so_37507671_37507807_1": {"length": 18, "quality": 1.0, "section_id": 491}, "so_37507671_37507807_0": {"length": 18, "quality": 1.0, "section_id": 489}}}, "37507671": {"ViewCount": "1150", "Body": "<p>I need to disable the copy assignment operator. This will work:</p>\n<pre><code>A&amp; operator=(const A&amp;);\n</code></pre>\n<p>Will it work if I don't specify exact parameters for <code>operator=</code>?<br>\nI mean something like this:</br></p>\n<pre><code>void operator=(void);\n</code></pre>\n<p>The returning value is right, I can write whatever I want, but what about the parameter type?<br>\nWill this override the default <code>operator=</code> for class?</br></p>\n", "AcceptedAnswerId": "37507807", "Title": "Does signature of custom assignment operator=() matter when I just want to disable it?", "CreationDate": "2016-05-29T08:16:13.177", "Id": "37507671", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-05-29T14:02:20.800", "LastEditorUserId": "4987285", "LastActivityDate": "2016-05-29T14:02:20.800", "Score": "11", "OwnerUserId": "4808130", "Tags": "<c++><operator-overloading><assignment-operator>", "AnswerCount": "3"}, "37507807": {"Id": "37507807", "PostTypeId": "2", "Body": "<p>From <a href=\"http://eel.is/c++draft/class.copy#17\">12.8p17</a> of the C++ standard draft:</p>\n<blockquote>\n<p id=\"so_37507671_37507807_0\">A user-declared\u00a0copy\u00a0assignment operator <code>X::operator=</code>\u00a0is a non-static non-template member function of class\u00a0<code>X</code>\u00a0with exactly one parameter of type\u00a0<code>X</code>, <code>X&amp;</code>, <code>const\u00a0X&amp;</code>, <code>volatile\u00a0X&amp;</code> or <code>const\u00a0volatile X&amp;</code>.</p>\n</blockquote>\n<p>I guess this replies better than any other test or sample code.  </p>\n<p>Note that something similar applies also to the move assignment operator, see <a href=\"http://eel.is/c++draft/class.copy#19\">12.8p19</a>:</p>\n<blockquote>\n<p id=\"so_37507671_37507807_1\">A user-declared move assignment operator X::operator=\u00a0is a non-static non-template member function of class\u00a0X\u00a0with exactly one parameter of type\u00a0X&amp;&amp;,\u00a0const X&amp;&amp;,\u00a0volatile X&amp;&amp;, or\u00a0const volatile X&amp;&amp;.</p>\n</blockquote>\n<p>These also confirm that, as you guessed, return value types don't matter.</p>\n", "LastEditorUserId": "4987285", "LastActivityDate": "2016-05-29T11:59:24.663", "Score": "13", "CreationDate": "2016-05-29T08:32:17.413", "ParentId": "37507671", "CommentCount": "0", "OwnerUserId": "4987285", "LastEditDate": "2016-05-29T11:59:24.663"}, "37507830": {"Id": "37507830", "PostTypeId": "2", "Body": "<p>There can be different kinds of assignments. Only <em>copy assignment</em> and <em>move assignment</em> are potentially generated by the compiler. They are generated if there is no copy/move assignment. So, if you want to disable copy and/or move assignment the argument type does matter although there is some flexibility as copy assignment can different argument types. The return type doesn't matter, though.</p>\n<pre><code>class A {\npublic:\n    void operator=() = delete; // not legal: assignment takes exactly one argument\n    void operator=(A) = delete; // OK: copy assignment disabled\n    void operator=(A&amp;) = delete; // OK: copy assignment disabled\n    void operator=(A const&amp;) = delete; // OK: copy assignment disabled\n    void operator=(A&amp;&amp;) = delete; // OK: move assignment disabled\n};\n</code></pre>\n<p>There are also variations replacing <code>const</code> by <code>volatile</code> or <code>const volatile</code> qualifying as copy/move assignments. When you disable a copy assignment, automatic generation of move assignment will be disabled, too. If you disable move assignment, I think copy assignment would still be generated. If you disable anything which cannot be a copy or move assignment, copy/move assignment are still generated.</p>\n", "LastActivityDate": "2016-05-29T08:34:46.447", "CommentCount": "0", "CreationDate": "2016-05-29T08:34:46.447", "ParentId": "37507671", "Score": "8", "OwnerUserId": "1120273"}, "37507825": {"Id": "37507825", "PostTypeId": "2", "Body": "<p>This is exact definition of an user-declared copy assignment operator from <a href=\"https://isocpp.org/files/papers/N3797.pdf\" rel=\"nofollow\">current standard</a> (\u00a7 12.8 p. 17):</p>\n<blockquote>\n<p id=\"so_37507671_37507825_0\">A user-declared copy assignment operator <code>X::operator=</code> is a non-static\n  non-template member function of <code>class X</code> with exactly one parameter of\n  type <code>X, X&amp;, const X&amp;, volatile X&amp;</code> or <code>const volatile X&amp;</code>. </p>\n</blockquote>\n<p>Notes: </p>\n<ul>\n<li>An overloaded assignment operator must be declared to have only one\nparameter; see 13.5.3. </li>\n<li>More than one form of copy assignment operator may be declared for a class.  </li>\n<li>If a class X only has a copy assignment operator with a parameter of type X&amp;, an expression of type const X cannot be assigned to an object of type X.</li>\n</ul>\n<p>Example:</p>\n<pre><code>struct X {\nX();\nX&amp; operator=(X&amp;);\n};\nconst X cx;\nX x;\nvoid f() {\nx = cx; // error: X::operator=(X&amp;) cannot assign cx into x\n}\n</code></pre>\n<p>Also, please, use <strong>delete</strong> from C++11 standard.</p>\n<p>You can now set functions as Defaulted or Deleted.</p>\n<p>You can now write directly that you would like to disable copying.</p>\n<pre><code>class A {\nA(const A&amp;) = delete;\nA&amp; operator=(const A&amp;) = delete;    // Disallow copying\n};\n</code></pre>\n<p>You can also explicitly inform compiler that you want default copy of a class. This way you can provide custom default constructor and still get default versions of other compiler-generated methods from compiler.</p>\n<pre><code>class B {\n    B(const Y&amp;) = default;\n    B&amp; operator=(const B&amp;) = default;   // default copy \n};\n</code></pre>\n", "LastEditorUserId": "210971", "LastActivityDate": "2016-05-29T09:00:44.037", "Score": "5", "CreationDate": "2016-05-29T08:34:30.927", "ParentId": "37507671", "CommentCount": "0", "OwnerUserId": "210971", "LastEditDate": "2016-05-29T09:00:44.037"}});