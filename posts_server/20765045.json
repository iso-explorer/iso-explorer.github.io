post_cb({"20765055": {"Id": "20765055", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_20765045_20765055_0\">Why exactly this will not compile if (a) b = c, d = e, return;?  </p>\n</blockquote>\n<p>This is because a comma (<code>,</code>) operator must have its left and right operands to be <strong>expressions</strong>. The <code>return</code> statement is not an expression. See the syntax defined for <code>,</code> operator by the C and C++ standard: </p>\n<h2>C11: 6.5.17 Comma operator</h2>\n<pre><code>Syntax\n      expression:\n             assignment-expression\n             expression , assignment-expression\n</code></pre>\n<p>The same syntax is defined by C++ standard  </p>\n<h2>C++: 5.18 Comma operator [expr.comma]</h2>\n<blockquote>\n<p id=\"so_20765045_20765055_1\">The comma operator groups left-to-right.  </p>\n<pre><code>      expression:\n             assignment-expression\n             expression , assignment-expression  \n</code></pre>\n<p id=\"so_20765045_20765055_2\"><strong>A pair of expressions</strong><sub>1</sub> separated by a comma is evaluated left-to-right;   </p>\n</blockquote>\n<p>Note that the standard says about <em>expressions</em> and <code>return</code> is not an expression.  </p>\n<hr>\n<p><sub>1.Emphasis is mine</sub></p>\n</hr>", "LastEditorUserId": "2455888", "LastActivityDate": "2013-12-25T00:38:02.870", "Score": "1", "CreationDate": "2013-12-24T18:03:46.487", "ParentId": "20765045", "CommentCount": "7", "OwnerUserId": "2455888", "LastEditDate": "2013-12-25T00:38:02.870"}, "20765111": {"Id": "20765111", "PostTypeId": "2", "Body": "<p>It can be done the following way</p>\n<pre><code>if (a) return ( b = c, d = e, 0 );\n</code></pre>\n<p>Oe if there is no return expression</p>\n<pre><code>if (a) return ( b = c, d = e, ( void )0 );\n</code></pre>\n", "LastActivityDate": "2013-12-24T18:09:53.250", "CommentCount": "0", "CreationDate": "2013-12-24T18:09:53.250", "ParentId": "20765045", "Score": "6", "OwnerUserId": "2877241"}, "20765105": {"Id": "20765105", "PostTypeId": "2", "Body": "<p>As already stated <code>return</code> is not an expression, it's a keyword. However, <code>b = c, d = e</code> <em>is</em> an expression. Therefore your intent is probably this:</p>\n<pre><code>if (a) return (b = c, d = e, 0);\n</code></pre>\n<p><code>b = c, d = e, return</code> doesn't really make any sense, as it would be inconsistent with how the comma operator works in other contexts. Imagine if you could do this:</p>\n<pre><code>for (int i = 0, j = 0, return; ...\n</code></pre>\n<p>That would make absolutely no sense. It would also be redundant if <code>return</code> meant something in this context as the comma operator already returns its last operand. There would also be no point because the comma operator already evaluates its operands, how would <code>return something</code> be beneficial in this case?</p>\n<p>Someone looking at your code might glance over it and say, \"this should be: <code>if (a) (b = c, d = e); return 0;</code>\", which is a trap because of the lack of braces. What they would really mean is <code>if (a) { (b = c, d = e); return 0; }</code>, but this problem would be avoided if you use the syntax mentioned at the top of this answer. It simply isn't readable as it makes no semantic sense.</p>\n<p>Regardless, this would only make sense if <code>b</code> and <code>d</code> were global variables, for example something like <code>errno</code>, allowing you to assign to the variable and return in one statement. </p>\n", "LastEditorDisplayName": "user1508519", "OwnerDisplayName": "user1508519", "LastActivityDate": "2013-12-24T18:43:48.350", "Score": "3", "CreationDate": "2013-12-24T18:09:15.747", "ParentId": "20765045", "CommentCount": "0", "LastEditDate": "2013-12-24T18:43:48.350"}, "20765069": {"Id": "20765069", "PostTypeId": "2", "Body": "<p>The \"comma\" operator is exactly that, an operator. It's left and right sides must be expressions, and <code>return</code> is not an expression.</p>\n<p>To elaborate, the comma operator evaluates its left-hand side first, and discards the value. Then, it evaluates its right-hand side, and the whole comma expression evaluates to the right-hand side's value.</p>\n<p>It's similar to this:</p>\n<pre><code>template &lt;typename T, typename U&gt;\nU operator,(T t, U u)\n{\n    return u;\n}\n</code></pre>\n<p>Therefore, you cannot put anything in a comma expression that is not an expression itself.</p>\n<p>If you're looking to simultaneously execute a series of statements and group them together, that's exactly what <code>;</code> and <code>{}</code> are for. There is no reason to duplicate that behavior in the comma operator.</p>\n", "LastEditorUserId": "640397", "LastActivityDate": "2013-12-24T19:30:40.163", "Score": "23", "CreationDate": "2013-12-24T18:04:33.517", "ParentId": "20765045", "CommentCount": "10", "OwnerUserId": "640397", "LastEditDate": "2013-12-24T19:30:40.163"}, "bq_ids": {"n4140": {"so_20765045_20765055_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 6182}, "so_20765045_20765055_1": {"length": 4, "quality": 0.8, "section_id": 6182}}, "n3337": {"so_20765045_20765055_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 5943}, "so_20765045_20765055_1": {"length": 4, "quality": 0.8, "section_id": 5943}}, "n4659": {"so_20765045_20765055_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 7684}, "so_20765045_20765055_1": {"length": 4, "quality": 0.8, "section_id": 7684}}}, "20765399": {"Id": "20765399", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_20765045_20765399_0\">I can understand in C but in C++ it could have been redesigned without\n  major compatibility loss with the existing C code.</p>\n</blockquote>\n<p>It <em>could</em> have been, but why would anyone, ever, want it to be? The language already contains a means to the end that you are looking for- braces. They are much more reliable and useful than abusing the comma operator like you have. For example, if you are using UDTs, then you are going to run into some nasty surprises when I overload the comma operator. Oops!</p>\n<p>More to the point, having <code>return</code> as an expression doesn't make sense, because the function has already, well, returned, when it is evaluated, so there's no way anyone could possibly use any hypothetical return value.</p>\n<p>Your entire question is predicated on your personal dislike of braces. Nobody else who designs the language really shares that feeling.</p>\n", "LastEditorUserId": "298661", "LastActivityDate": "2013-12-24T18:49:19.950", "Score": "0", "CreationDate": "2013-12-24T18:37:23.143", "ParentId": "20765045", "CommentCount": "0", "OwnerUserId": "298661", "LastEditDate": "2013-12-24T18:49:19.950"}, "20765722": {"Id": "20765722", "PostTypeId": "2", "Body": "<p>It may be open to question whether this answers the question the OP was really asking, but in case anybody cares about why the comma operator was designed the way it was, I think it goes back to BCPL.</p>\n<p>In BCPL, you could combine a series of assignments like:</p>\n<pre><code>L1 := R1\nL2 := R2\n</code></pre>\n<p>...into a single statement (command) like:</p>\n<pre><code>L1, L2 := R1, R2\n</code></pre>\n<p>Much like in C and C++, these were executed in order from left to right. Unlike C and C++, this \"comma operator\" didn't produce a single expression (at least as C uses the term). </p>\n<p>BCPL also had a <code>resultis</code> that let you make a block of statements into something almost like a function.</p>\n<p>At least to me, it looks like in C, Dennis<sup>1</sup> decided decided to sort of combine these two concepts into a single one that was rather simpler: a comma operator that would allow evaluation of a number of expressions in succession, and yield a single result.</p>\n<p>Reference: <a href=\"http://cm.bell-labs.com/who/dmr/bcpl.pdf\">BCPL Reference Manual</a></p>\n<hr>\n<ol>\n<li>I suppose in fairness I should mention the possibility that this decision was actually made by Ken Thomson in the design of B. Little enough documentation on B has survived that it's almost impossible to even guess about that.</li>\n</ol>\n</hr>", "LastActivityDate": "2013-12-24T19:09:46.137", "CommentCount": "0", "CreationDate": "2013-12-24T19:09:46.137", "ParentId": "20765045", "Score": "5", "OwnerUserId": "179910"}, "20765045": {"ViewCount": "754", "Body": "<p>I am addicted to \"braceless\" ifs, like this:</p>\n<pre><code>if (a) b++, c++, d = e; \n</code></pre>\n<p>But one annoying thing is that <code>return</code> cannot be a part of the last part. Intuitively I feel why is that, but can anyone explain in programming language terms why this will not compile?</p>\n<pre><code>main() {\n    int a, b, c, d, e;\n    if (a) b = c, d = e, return;\n}\n</code></pre>\n<p>If you care, please also explain why is that designed like that, it seems like a flaw to me. I can understand in C but in C++ it could have been redesigned without major compatibility loss with the existing C code.</p>\n<p>Just for comparison: these will compile and do exactly what expected:</p>\n<pre><code>while (a &lt; 10) a++, b--, c += 2;\n\nwhile (a &lt; 10) if (a == 5) half = a, save();\n</code></pre>\n", "AcceptedAnswerId": "20765069", "Title": "Why exactly this will not compile if (a) b = c, d = e, return;?", "CreationDate": "2013-12-24T18:02:48.787", "Id": "20765045", "CommentCount": "22", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-12-07T12:20:36.537", "LastEditorUserId": "2877241", "LastActivityDate": "2015-12-07T12:20:36.537", "Score": "7", "OwnerUserId": "1968972", "Tags": "<c++><compiler-errors><operators>", "AnswerCount": "6"}});