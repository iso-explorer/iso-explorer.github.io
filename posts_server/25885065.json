post_cb({"25885182": {"ParentId": "25885065", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Because <code>return</code> of certain expressions, such as <strong>local automatic variables</strong>, are explicitly defined to return a <em>moved</em> object, if the moving operator is available.</p>\n<p>So:</p>\n<pre><code>return p;\n</code></pre>\n<p>is more or less similar to:</p>\n<pre><code>return std::move(p);\n</code></pre>\n<p>But note that this will not work for example with a global variable.</p>\n<pre><code>std::unique_ptr&lt;int&gt; g(new int(3));\nstd::unique_ptr&lt;int&gt; ptr() {\n    return g;  //  error!!!\n}\n</code></pre>\n", "OwnerUserId": "865874", "LastEditorUserId": "865874", "LastEditDate": "2014-09-17T08:26:12.267", "Id": "25885182", "Score": "6", "CreationDate": "2014-09-17T07:56:25.970", "LastActivityDate": "2014-09-17T08:26:12.267"}, "25885065": {"CommentCount": "4", "AcceptedAnswerId": "25885212", "PostTypeId": "1", "ClosedDate": "2014-09-17T16:08:22.350", "LastEditorUserId": "1505939", "CreationDate": "2014-09-17T07:49:23.903", "LastActivityDate": "2014-09-17T08:26:12.267", "LastEditDate": "2014-09-17T08:10:53.040", "ViewCount": "9876", "FavoriteCount": "2", "Title": "How can a unique_ptr be returned by value without std::move?", "Id": "25885065", "Score": "9", "Body": "<pre><code>std::unique_ptr&lt;int&gt; ptr() {\n    std::unique_ptr&lt;int&gt; p(new int(3));\n    return p;  //  Why doesn't this require explicit move using std::move?\n}  // Why didn't the data pointed to by 'p' is not destroyed here though p is not moved?\n\nint main() {\n    std::unique_ptr&lt;int&gt; a = ptr();  // Why doesn't this require std::move? \n    std::cout &lt;&lt; *a; // Prints 3.\n}\n</code></pre>\n<p>In the above code, the function <code>ptr()</code> returns a copy of <code>p</code>. When <code>p</code> goes out of scope, the data '3' should get deleted. But how does the code work without any access violation? </p>\n", "Tags": "<c++><c++11><move-semantics><copy-elision>", "OwnerUserId": "3764066", "AnswerCount": "2"}, "25885212": {"ParentId": "25885065", "CommentCount": "0", "Body": "<p>This is set out in the C++11 standard, <strong>\u00a7 12.8/32</strong>:</p>\n<blockquote>\n<p id=\"so_25885065_25885212_0\">When the criteria for elision of a copy operation are met or would be\n  met save for the fact that the source object is a function parameter,\n  and the object to be copied is designated by an lvalue, <strong>overload\n  resolution to select the constructor for the copy is first performed\n  as if the object were designated by an rvalue</strong>....</p>\n</blockquote>\n<p>(emphasis mine). In plain english, it means that the lvalue <code>p</code> can be treated as an <code>rvalue</code> when it comes to overload resolution, because it is a candidate for <em>copy elision</em>. This in turn means the move constructor is picked up on overload resolution (in actual fact, the move copy is probably elided anyway.)</p>\n", "OwnerUserId": "661519", "PostTypeId": "2", "Id": "25885212", "Score": "14", "CreationDate": "2014-09-17T07:58:16.453", "LastActivityDate": "2014-09-17T07:58:16.453"}, "bq_ids": {"n4140": {"so_25885065_25885212_0": {"section_id": 481, "quality": 0.6896551724137931, "length": 20}}, "n3337": {"so_25885065_25885212_0": {"section_id": 472, "quality": 1.0, "length": 29}}, "n4659": {"so_25885065_25885212_0": {"section_id": 504, "quality": 0.5517241379310345, "length": 16}}}});