post_cb({"27238857": {"Id": "27238857", "PostTypeId": "2", "Body": "<p>The pointers are of the same range because they are both pointers. The problem is that they can both be indexed by [] but the step in bytes is different for int and char, which are 4 and 1.</p>\n<p>If you are passing an array the chars would have to be copied over to a int array so they are spaced like ints in memory.</p>\n<pre><code>void char_array_to_int_array(int *ints, char *chars, int length){\n     for(int i=0; i&lt;length; i++){\n       ints[i]=chars[i]; //Here the cast will happen\n     }\n }\n</code></pre>\n<p>Alternatively you could define the function again for char* as a parameter so the indexing can be calculated correctly.</p>\n<p>Actually I just realised your problem is polymorphism you want a template function like this:</p>\n<pre><code> template &lt;class T&gt;\n int average(T *array, int size){\n     int sum = 0;\n     for (int i = 0; i &lt;size; i++)\n     sum+=*(array+i);\n     return sum/size;\n }\n</code></pre>\n<p>Here the compiler will compile this function for every type  that it is called with in the program. I should of realised the actual problem sooner and not got involved with talking about types and casting.</p>\n<p>This can be called like normal.</p>\n<pre><code>char a[4] = {1,2,3,4};\nint i[4] = {1,2,3,4};\ncout &lt;&lt; \"The ints: \" &lt;&lt; average(i,4) &lt;&lt; endl;\ncout &lt;&lt; \"The chars: \" &lt;&lt; average(a,4) &lt;&lt; endl;\n</code></pre>\n", "LastEditorUserId": "4313365", "LastActivityDate": "2014-12-02T00:23:03.357", "Score": "1", "CreationDate": "2014-12-01T22:52:44.203", "ParentId": "27238670", "CommentCount": "0", "OwnerUserId": "4313365", "LastEditDate": "2014-12-02T00:23:03.357"}, "bq_ids": {"n4140": {"so_27238670_27238859_2": {"length": 41, "quality": 0.9318181818181818, "section_id": 41}, "so_27238670_27238859_0": {"length": 75, "quality": 0.9259259259259259, "section_id": 39}, "so_27238670_27238859_1": {"length": 39, "quality": 0.9512195121951219, "section_id": 40}}, "n3337": {"so_27238670_27238859_0": {"length": 73, "quality": 0.9012345679012346, "section_id": 36}, "so_27238670_27238859_2": {"length": 41, "quality": 0.9318181818181818, "section_id": 38}, "so_27238670_27238859_1": {"length": 26, "quality": 0.6341463414634146, "section_id": 37}}, "n4659": {"so_27238670_27238859_0": {"length": 75, "quality": 0.9259259259259259, "section_id": 39}, "so_27238670_27238859_2": {"length": 41, "quality": 0.9318181818181818, "section_id": 41}, "so_27238670_27238859_1": {"length": 22, "quality": 0.5365853658536586, "section_id": 43}}}, "27238739": {"Id": "27238739", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_27238670_27238739_0\">I thought unsigned char will be automatically casted to int?</p>\n</blockquote>\n<p>An <code>unsigned char</code> will be automatically cast to an <code>int</code> but <code>unsigned char*</code> will not be automatically cast to an <code>int*</code>.</p>\n<pre><code> unsigned char c = 'a';\n unsigned char* cp = &amp;a;\n\n int i = c;      // This is allowed  \n int* ip = cp;   // This is not allowed\n</code></pre>\n<p>If that were allowed, you could do:</p>\n<pre><code> *ip = INT_MAX;\n</code></pre>\n<p>but there isn't enough space at <code>&amp;c</code> to hold that number. You will end up accessing unauthorized memory, which will immediately lead to undefined behavior.</p>\n", "LastEditorUserId": "434551", "LastActivityDate": "2014-12-01T22:52:22.390", "Score": "6", "CreationDate": "2014-12-01T22:43:23.203", "ParentId": "27238670", "CommentCount": "0", "OwnerUserId": "434551", "LastEditDate": "2014-12-01T22:52:22.390"}, "27238859": {"Id": "27238859", "PostTypeId": "2", "Body": "<h2>tl;dr</h2>\n<p>Welcome to some sort of type safety. <code>const int</code> and <code>unsigned char</code> are profoundly different types. Implicit conversion between the two would be a huge flaw in the type system.</p>\n<h2>The allowed pointer conversions</h2>\n<p>There are only 3 type of valid pointer conversions, described in \u00a74.10 of the Standard:</p>\n<h3>Null pointer</h3>\n<p>From a null pointer prvalue to a pointer type. For example:</p>\n<pre><code>const int* ptr = nullptr;\n</code></pre>\n<p>and specifically:</p>\n<blockquote>\n<p id=\"so_27238670_27238859_0\">A null pointer constant is an integer literal (2.14.2) with value zero or a prvalue of type std::nullptr_t. A null pointer constant can be converted to a pointer type; the result is the null pointer value of that type and is distinguishable from every other value of object pointer or function pointer type. Such a conversion is called a null pointer conversion. Two null pointer values of the same type shall compare equal. The conversion of a null pointer constant to a pointer to cv-qualified type is a single conversion, and not the sequence of a pointer conversion followed by a qualification conversion (4.4). A null pointer constant of integral type can be converted to a prvalue of type std::nullptr_t. [ Note: The resulting prvalue is not a null pointer value. \u2014 end note ]</p>\n</blockquote>\n<h3>The special case of <code>void*</code></h3>\n<p>The reason I said \"some sort of type system\" is exactly this. <code>[const] void* [const]</code> can represent any pointer type, as long as it as the same constant qualifiers:</p>\n<pre><code>const int* x = ...;\nconst void* vx = x; // OK\n\nconst int* y = ...;\nvoid* vy = y; // Nope\n</code></pre>\n<p>This is specifically described as:</p>\n<blockquote>\n<p id=\"so_27238670_27238859_1\">A prvalue of type \u201cpointer to cv T,\u201d where T is an object type, can be converted to a prvalue of type \u201cpointer to cv void\u201d. The result of converting a non-null pointer value of a pointer to object type to a \u201cpointer to cv void\u201d represents the address of the same byte in memory as the original pointer value. The null pointer value is converted to the null pointer value of the destination type.</p>\n</blockquote>\n<h3>Polymorphic pointers</h3>\n<p>And finally, we have polymorphic pointers: pointers to base classes:</p>\n<pre><code>class B { ... };\nclass C : public B { ... };\nclass D : public B { ... };\n\n...\n\nC* c = new C();\nD* d = new D();\n\nB* b1 = c; // Yup\nB* b2 = d; // Yup\n\nD* dw = b1; // Nope. If you really want this UB you need to use `dynamic_cast`\n</code></pre>\n<p>Specifically:</p>\n<blockquote>\n<p id=\"so_27238670_27238859_2\">A prvalue of type \u201cpointer to cv D\u201d, where D is a class type, can be converted to a prvalue of type \u201cpointer to cv B\u201d, where B is a base class (Clause 10) of D. If B is an inaccessible (Clause 11) or ambiguous (10.2) base class of D, a program that necessitates this conversion is ill-formed. The result of the conversion is a pointer to the base class subobject of the derived class object. The null pointer value is converted to the null pointer value of the destination type.</p>\n</blockquote>\n", "LastActivityDate": "2014-12-01T22:52:54.693", "CommentCount": "0", "CreationDate": "2014-12-01T22:52:54.693", "ParentId": "27238670", "Score": "3", "OwnerUserId": "493122"}, "27238670": {"ViewCount": "4279", "Body": "<p>I'm writing a function to accept both unsigned char* and int*:</p>\n<pre><code>int foo(const int * a)\n</code></pre>\n<p>However when I pass unsigned char * a to foo(), it has this compiling error. I thought unsigned char will be automatically casted to int? ( a smaller range variable will be casted to a larger one). Does it work for array pointer also?</p>\n<p>Sample code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint average(const int * array, int size)\n{\n    int sum = 0;\n    for (int i = 0; i &lt;size; i++)\n    sum+=*(array+i);\n    return sum/size;\n}\n\nint main() {\n    unsigned char array[5] = {0,1,2,3,4};\n    std::cout &lt;&lt; average(array, 5);\n    return 0;\n}\n</code></pre>\n<p>What would be the best way to write a function that accepts both unsigned char* and int*?</p>\n", "Title": "error: cannot convert 'unsigned char*' to 'const int*'", "CreationDate": "2014-12-01T22:37:38.680", "Id": "27238670", "CommentCount": "5", "LastEditDate": "2014-12-01T22:45:11.777", "PostTypeId": "1", "LastEditorUserId": "1617352", "LastActivityDate": "2014-12-02T00:23:03.357", "Tags": "<c++>", "Score": "-1", "OwnerUserId": "1617352", "ClosedDate": "2014-12-02T01:31:03.670", "AnswerCount": "3"}});