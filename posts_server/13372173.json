post_cb({"13372224": {"ParentId": "13372173", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>When a function is declared to take a parameter of type <code>void</code>, as in <code>std::function&lt;void(void)&gt;</code>, that is really just a goofy way of saying that it takes zero parameters. But the way you've declared Type2 is as a <code>std::function</code> with a signature that returns nothing (void), but that takes 1 parameter.  void is not a type that can be used as a parameter, it is just a way of declaring that there are no parameters.  So it doesn't work with Type2, because that requires an actual type that can be used as a parameter.</p>\n", "OwnerUserId": "440119", "LastEditorUserId": "440119", "LastEditDate": "2012-11-14T02:41:17.657", "Id": "13372224", "Score": "3", "CreationDate": "2012-11-14T02:36:01.613", "LastActivityDate": "2012-11-14T02:41:17.657"}, "13372257": {"ParentId": "13372173", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I don't have an actual answer, only what I said in the comment: You can't have <code>void</code> as a function type, as in:</p>\n<pre><code>int foo(int, char, void, bool, void, void);     // nonsense!\n</code></pre>\n<p>I believe that <code>T(void)</code> is only allowed as a compatibility notation for C (which distinguishes <em>declarations</em> and <em>prototypes</em>, very differently from C++, and which needs to be able to say \"no arguments\").</p>\n<p>So, the solution should be variadic:</p>\n<pre><code>template &lt;typename ...Args&gt; using myType = std::function&lt;void(Args...)&gt;;\n</code></pre>\n<p>That way you can properly have <em>no arguments</em>:</p>\n<pre><code>myType&lt;&gt; f = []() { std::cout &lt;&lt; \"Boo\\n\"; }\n</code></pre>\n", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2013-11-07T18:18:51.777", "Id": "13372257", "Score": "10", "CreationDate": "2012-11-14T02:41:10.557", "LastActivityDate": "2013-11-07T18:18:51.777"}, "13372788": {"ParentId": "13372173", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The short answer is \"templates are not string substitution\".  <code>void f(void)</code> has meaning only so far as it is an alias for <code>void f()</code> in C++, in order to be backwards compatible with C.</p>\n<p>The first step is to use variadics, as noted elsewhere.</p>\n<p>The second step is figuring out how to map <code>void</code> returning functions to ... well, maybe something like <code>std::function&lt;void()&gt;</code>, or maybe something else.  I say maybe something else because unlike the other cases, you cannot call <code>std::function&lt;void()&gt; foo; foo( []()-&gt;void {} );</code> -- it isn't a true continuation.</p>\n<p>Something like this maybe:</p>\n<pre><code>template&lt;typename T&gt;\nstruct Continuation\n{\n  typedef std::function&lt;void(T)&gt; type;\n};\n\ntemplate&lt;&gt;\nstruct Continuation&lt;void&gt;\n{\n  typedef std::function&lt;void()&gt; type;\n};\n</code></pre>\n<p>then use it like this:</p>\n<pre><code>auto someFunc = []()-&gt;void {};\nContinuation&lt;decltype(someFunc())&gt;::type c;\n</code></pre>\n<p>which gives you the type you want.  You could even add in an apply to continuation:</p>\n<pre><code>template&lt;typename T&gt;\nstruct Continuation\n{\n  typedef std::function&lt;void(T)&gt; type;\n\n  template&lt;typename func, typename... Args&gt;\n  static void Apply( type const&amp; cont, func&amp;&amp; f, Args... args)\n  {\n    cont( f(args...) );\n  }\n};\n\ntemplate&lt;&gt;\nstruct Continuation&lt;void&gt;\n{\n  typedef std::function&lt;void()&gt; type;\n  template&lt;typename func, typename... Args&gt;\n  static void Apply( type const&amp; cont, func&amp;&amp; f, Args... args)\n  {\n    f(args...);\n    cont();\n  }\n};\n</code></pre>\n<p>which lets you apply a continuation to an execution of a function uniformly if the incoming type is a void or if it is a non-void type.</p>\n<p>However, I would ask \"why would you want to do this\"?</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "939250", "LastEditDate": "2016-08-12T23:15:16.740", "Id": "13372788", "Score": "9", "CreationDate": "2012-11-14T03:56:22.017", "LastActivityDate": "2016-08-12T23:15:16.740"}, "13372230": {"ParentId": "13372173", "CommentCount": "0", "Body": "<p>Void can be interpreted as an empty parameter if you pass it to a function. You're not using a void pointer after all so </p>\n<pre><code>void func (void)\n</code></pre>\n<p>becomes</p>\n<pre><code>void func ()\n</code></pre>\n", "OwnerUserId": "163231", "PostTypeId": "2", "Id": "13372230", "Score": "0", "CreationDate": "2012-11-14T02:37:05.810", "LastActivityDate": "2012-11-14T02:37:05.810"}, "13372173": {"CommentCount": "2", "CreationDate": "2012-11-14T02:27:59.240", "PostTypeId": "1", "AcceptedAnswerId": "13372788", "LastEditorUserId": "192102", "LastActivityDate": "2016-08-12T23:15:16.740", "LastEditDate": "2012-11-14T02:55:57.870", "ViewCount": "18350", "FavoriteCount": "5", "Title": "Using 'void' template arguments in C++", "Id": "13372173", "Score": "15", "Body": "<p>Take the following minimal example:</p>\n<pre><code>using Type1 = std::function&lt;void(void)&gt;;\n\ntemplate &lt;typename T&gt;\nusing Type2 = std::function&lt;void(T)&gt;;\n\nType1 whyDoesThisWork;\nType2&lt;void&gt; andYetThisDoesNot;\n</code></pre>\n<p>If the second type alias, I get the error \"Argument may not have 'void' type\". (I tested with Xcode 4.5, Clang/c++11/libc++, OS X 10.7.)</p>\n<p>I find this curious: I would have expected <code>Type1</code> and <code>Type2&lt;void&gt;</code> to behave identically. What's going on here? And is there a way to rewrite the second type alias so I <em>can</em> write <code>Type2&lt;void&gt;</code> and get <code>std::function&lt;void(void)&gt;</code> instead of an error?</p>\n<p><strong>Edit</strong> I should probably add that the reason I want this is to allow for something like the following:</p>\n<pre><code>template &lt;typename ... T&gt;\nusing Continuation = std::function&lt;void(T...)&gt;;\n\nauto someFunc = []() -&gt; void {\n  printf(\"I'm returning void!\\n\");\n};\n\nContinuation&lt;decltype(someFunc())&gt; c;\n</code></pre>\n<p><code>Continuation&lt;decltype(someFunc())&gt;</code> becomes <code>Continuation&lt;void&gt;</code> and I get the error.</p>\n", "Tags": "<c++><templates><c++11><std-function>", "OwnerUserId": "192102", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_13372173_13372928_0": {"section_id": 3240, "quality": 1.0, "length": 20}}, "n3337": {"so_13372173_13372928_0": {"section_id": 3113, "quality": 0.65, "length": 13}}, "n4659": {"so_13372173_13372928_0": {"section_id": 3996, "quality": 1.0, "length": 20}}}, "13372928": {"ParentId": "13372173", "CommentCount": "0", "Body": "<p>Several answers already explain the rationale.  To add to those answers, the specification says (C++11 \u00a78.3.5[dcl.func]/4):</p>\n<blockquote>\n<p id=\"so_13372173_13372928_0\">A parameter list consisting of a single unnamed parameter of non-dependent type <code>void</code> is\n  equivalent to an empty parameter list. Except for this special case, a parameter shall not have type <em>cv</em> <code>void</code>.</p>\n</blockquote>\n<p>In your <code>Type2</code> example, the <code>T</code> in <code>void(T)</code> is a <em>dependent type</em>--it depends on a template parameter.</p>\n", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "13372928", "Score": "5", "CreationDate": "2012-11-14T04:12:51.493", "LastActivityDate": "2012-11-14T04:12:51.493"}});