post_cb({"34803719": {"ParentId": "4010937", "CommentCount": "0", "Body": "<p>As Containers store objects and references are not objects. In case you are at c++ 11, you can use std::reference_wrapper to wrap things to assignable objects.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper</a></p>\n<p>std::reference_wrapper is a class template that wraps a reference in a copyable, assignable object. It is frequently used as a mechanism to store references inside standard containers (like std::vector) which cannot normally hold references.</p>\n", "OwnerUserId": "346963", "PostTypeId": "2", "Id": "34803719", "Score": "1", "CreationDate": "2016-01-15T03:03:09.590", "LastActivityDate": "2016-01-15T03:03:09.590"}, "19387707": {"ParentId": "4010937", "CommentCount": "1", "Body": "<p>Not directly relevant to the \"why\", but to give an answer to the implied desire to do this, I would mention that the c++11 standard library has a reference wrapper type to enable this. It is implicitly convertible to a reference and it is storable in standard containers.</p>\n", "OwnerUserId": "880984", "PostTypeId": "2", "Id": "19387707", "Score": "9", "CreationDate": "2013-10-15T17:48:09.273", "LastActivityDate": "2013-10-15T17:48:09.273"}, "4010943": {"ParentId": "4010937", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>Containers store <em>objects</em>.  References are not objects.</p>\n<p>The C++11 specification clearly states (\u00a723.2.1[container.requirements.general]/1):</p>\n<blockquote>\n<p id=\"so_4010937_4010943_0\">Containers are objects that store other objects.</p>\n</blockquote>\n", "OwnerUserId": "151292", "LastEditorUserId": "151292", "LastEditDate": "2012-11-01T05:31:04.600", "Id": "4010943", "Score": "34", "CreationDate": "2010-10-24T23:06:41.877", "LastActivityDate": "2012-11-01T05:31:04.600"}, "bq_ids": {"n4140": {"so_4010937_4010943_0": {"section_id": 702, "quality": 1.0, "length": 5}}, "n3337": {"so_4010937_4010943_0": {"section_id": 692, "quality": 1.0, "length": 5}}, "n4659": {"so_4010937_4010943_0": {"section_id": 731, "quality": 1.0, "length": 5}}}, "4010937": {"CommentCount": "5", "AcceptedAnswerId": "4010943", "PostTypeId": "1", "LastEditorUserId": "5752218", "CreationDate": "2010-10-24T23:05:12.680", "LastActivityDate": "2016-04-14T08:09:59.293", "LastEditDate": "2016-04-14T08:09:59.293", "ViewCount": "9482", "FavoriteCount": "4", "Title": "Why does storing references (not pointers) in containers in C++ not work?", "Id": "4010937", "Score": "16", "Body": "<p>In my program I have a STL set.</p>\n<pre><code>set&lt;string&gt; myStrings;\n</code></pre>\n<p>To improve the efficiency of my code I changed it to hold, only pointers. (I don't need actual string copies to be stored.)</p>\n<pre><code>set&lt;string*&gt; myStrings;\n</code></pre>\n<p>I have read that it is a good practice to substitute pointers with references when possible. (Of course, only if the actual functionality of a pointer is not needed.)</p>\n<pre><code>set&lt;string&amp;&gt; myStrings;\n</code></pre>\n<p>The latter one gives me a lot of compiler errors, though.\nWhy is it not possible to use references as container elements?</p>\n", "Tags": "<c++><stl><reference><containers>", "OwnerUserId": "271968", "AnswerCount": "3"}});