post_cb({"bq_ids": {"n4140": {"so_21461315_21461748_0": {"length": 11, "quality": 1.0, "section_id": 7070}}, "n3337": {"so_21461315_21461748_0": {"length": 11, "quality": 1.0, "section_id": 6814}}, "n4659": {"so_21461315_21461748_0": {"length": 11, "quality": 1.0, "section_id": 8568}}}, "21461315": {"ViewCount": "195", "Body": "<p>I caught myself \"inventing\" this simple construct lately when working with many templated classes and deriving from them. I am not sure if it is common practice, or am I tying a rope around my neck.</p>\n<p><code>template &lt;typename T&gt; class Base {};</code></p>\n<pre><code>template &lt;typename T&gt; class Derived : public Base&lt;T&gt;{\n  typedef Base&lt;T&gt; Base;\n};\n</code></pre>\n<p>I found it especially useful if the <code>Base</code> class has its own <code>typedef</code>s for some types. E.g:</p>\n<pre><code>template &lt;typename T&gt; class Base {\n  typedef T Scalar;\n  typedef Matrix&lt;Scalar&gt; Matrix;\n};\n</code></pre>\n<p>Then it's easy to \"import\" types into the <code>Derived</code>. It saves re-typing the template signature. E.g:</p>\n<pre><code>template &lt;typename T&gt; class Derived : public Base&lt;T&gt;{\n  typename Base&lt;T&gt;::Matrix yuck_yuck(); //that's what I am trying to simplify\n  typedef typename Base&lt;T&gt; Base;\n  typedef typename Base::Matrix Matrix;\n  Matrix much_fun(); //looks way better\n};\n</code></pre>\n<p>Also on of the big advantages is that, when you want to add another template parameter to the <code>Base</code> class. You don't have to go over a bunch of functions to change, just update the <code>typedef</code>. <code>much_fun</code> will have no problem if <code>Base</code> will be changed to <code>Base&lt;T,U&gt;</code> while <code>yuck_yuck</code> will need to have updated signatures (not sure if template parameter is formally included with the signature, so pardon me if I am making a formal error here, but I think it is).</p>\n<p>Is this a good practice or am I playing with a gun next to my vital parts? It looks like it makes code more readable, and simplifies it, but maybe I am missing something that can backfire.</p>\n<p>EDIT2: I got the working example. The <code>Base</code> class must be within its namespace or there will be conflicts with the same names within a scope, as the commenters pointed out. Below is the minimal example that embodies my real question.</p>\n<pre><code>namespace Fun {\ntemplate &lt;typename T&gt; class Base {\npublic:\n  typedef T Scalar;\n};\n}\n\ntemplate &lt;typename T&gt; \nclass Derived : public Fun::Base&lt;T&gt;{\npublic:\n  typedef typename Fun::Base&lt;T&gt; Base;\n  typedef typename Base::Scalar Scalar;\n  typename Fun::Base&lt;T&gt;::Scalar yuck_yuck();\n  Scalar much_fun();\n};\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    Derived&lt;double&gt; d;\n    return 0;\n}\n</code></pre>\n<p>With lots of stuff the code gets really bloated with <code>typenames</code>, and template parameters. But I already run into a trouble making up the example, by not placing <code>Base</code> in its own namespace. I wonder if there are any other caveats, that are actually killers to the idea.</p>\n", "AcceptedAnswerId": "21463425", "Title": "Is typedeffing templated base class to simplify the code a good practice?", "CreationDate": "2014-01-30T15:58:39.120", "Id": "21461315", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-01-30T16:31:04.783", "LastEditorUserId": "1133179", "LastActivityDate": "2014-01-30T17:35:10.853", "Score": "5", "OwnerUserId": "1133179", "Tags": "<c++><templates>", "AnswerCount": "2"}, "21461748": {"Id": "21461748", "PostTypeId": "2", "Body": "<p>I believe this is ill-formed, due to rule 2 of C++11 3.3.7/1</p>\n<blockquote>\n<p id=\"so_21461315_21461748_0\">A name N used in a class S shall refer to the same declaration in its context and when re-evaluated in the completed scope of S.</p>\n</blockquote>\n<p>meaning that you can't use the name <code>Base</code> to refer to both the template and the typedef within the class scope. Certainly, my compiler won't accept it:</p>\n<pre><code>error: declaration of \u2018typedef struct Base&lt;T&gt; Derived&lt;T&gt;::Base\u2019 [-fpermissive]\nerror: changes meaning of \u2018Base\u2019 from \u2018struct Base&lt;T&gt;\u2019 [-fpermissive]\n</code></pre>\n<p>(NOTE: this refers to the simplified example originally posted, and doesn't cover the updated question where the base class name is in a different scope.)</p>\n", "LastActivityDate": "2014-01-30T16:17:10.480", "Score": "5", "CreationDate": "2014-01-30T16:17:10.480", "ParentId": "21461315", "CommentCount": "8", "OwnerUserId": "204847"}, "21463425": {"Id": "21463425", "PostTypeId": "2", "Body": "<p>I actually consider it a helpful (and good) practice if the typedef is not exposed public or protected:</p>\n<pre><code>// No template, not Base, to avoid that discussion\nclass Derive : public SomeBaseClass \n{\n   private:\n   typedef SomeBaseClass Base;\n\n   public:\n   typedef Base::T T;\n\n   T f();\n}; \n\nclass MoreDerived : public Derived\n{\n   // Base is not accessible\n};\n</code></pre>\n", "LastEditorUserId": "2249683", "LastActivityDate": "2014-01-30T17:35:10.853", "Score": "1", "CreationDate": "2014-01-30T17:29:37.137", "ParentId": "21461315", "CommentCount": "0", "LastEditDate": "2014-01-30T17:35:10.853", "OwnerUserId": "2249683"}});