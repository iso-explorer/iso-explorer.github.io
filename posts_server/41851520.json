post_cb({"41851940": {"ParentId": "41851520", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_41851520_41851940_0\"><code>[C++11: 20.7.2.3.5]</code> </p>\n<p id=\"so_41851520_41851940_1\"><code>long use_count() const noexcept;</code></p>\n<p id=\"so_41851520_41851940_2\"><strong>1</strong> Returns: 0 if <code>*this</code> is <em>empty</em>; otherwise, the number of <code>shared_ptr</code> instances that <em>share ownership</em> with <code>*this</code>.<br>\n<strong>2</strong> <em>[ Note:</em> <code>use_count()</code> is not necessarily efficient. <em>\u2014end note ]</em></br></p>\n<p id=\"so_41851520_41851940_3\"><code>bool expired() const noexcept;</code></p>\n<p id=\"so_41851520_41851940_4\"><strong>3</strong> <em>Returns:</em> <code>use_count() == 0</code>.<br>\n<strong>4</strong> <em>[ Note:</em> expired() may be faster than use_count(). <em>\u2014end note ]</em></br></p>\n</blockquote>\n<p>Now, we have to piece a few bits together (and I shan't quote them all here), but the <code>weak_ptr</code> is only <em>empty</em> when constructed as such, so we're looking to decide whether or not \"the number of <code>shared_ptr</code> instances that <em>share ownership</em> with <code>*this</code>\" is already zero.</p>\n<p>The most relevant wording I can find as to whether the use count should be non-zero until after the managed object has been destroyed, is this:</p>\n<blockquote>\n<p id=\"so_41851520_41851940_5\"><code>[C++11: 20.7.2.2.2/2]:</code> <em>[ Note:</em> Since the destruction of <code>*this</code> decreases the number of instances that share ownership with <code>*this</code> by one, <strong>after <code>*this</code> has been destroyed all <code>shared_ptr</code> instances that shared ownership with <code>*this</code> will report a <code>use_count()</code> that is one less than its previous value</strong>. <em>\u2014end note ]</em></p>\n</blockquote>\n<p>Note the word \"after\".</p>\n<p>However, the wording is pretty fluffy, and doesn't really give any specific sequencing guarantees (i.e. it doesn't say \"<em>only</em> after\"), so your mileage may vary\u2026 particularly as my interpretation would identify your GCC's behaviour as a bug.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "41851940", "Score": "-1", "CreationDate": "2017-01-25T12:42:13.843", "LastActivityDate": "2017-01-25T12:42:13.843"}, "41852166": {"ParentId": "41851520", "CommentCount": "1", "Body": "<p>Not the standard itself but:</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/memory/weak_ptr/expired\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/memory/weak_ptr/expired</a></p>\n<blockquote>\n<p id=\"so_41851520_41852166_0\">Checks whether the managed object has already been deleted. Equivalent\n  to use_count() == 0.</p>\n</blockquote>\n<p>So it becomes a question of weather <code>use_count</code> is set to 0 before or after deletion. Now there's a not on this in a draft of the standard:\n<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf</a> [page 566 20.9.2.2.2]</p>\n<blockquote>\n<p id=\"so_41851520_41852166_1\"><code>~shared_ptr()</code>;</p>\n<p id=\"so_41851520_41852166_2\">Effects:</p>\n<ul>\n<li>If <code>*this</code> is empty or shares ownership with another <code>shared_ptr</code> instance (use_count() &gt; 1), there are no side effects.</li>\n<li>Otherwise, if <code>*this</code> owns an object <code>p</code> and a deleter <code>d</code>, <code>d(p)</code> is called.</li>\n<li>Otherwise, <code>*this</code> owns a pointer <code>p</code>, and <code>delete p</code> is called.</li>\n</ul>\n<p id=\"so_41851520_41852166_3\">[Note: Since the destruction of <code>*this</code> decreases the number of\n  instances that share ownership with <code>*this</code> by one, after <code>*this</code> has\n  been destroyed all <code>shared_ptr</code> instances that shared ownership with\n  <code>*this</code> will report a <code>use_count()</code>that is one less than its previous\n  value. \u2014 end note]</p>\n</blockquote>\n", "OwnerUserId": "2422450", "PostTypeId": "2", "Id": "41852166", "Score": "0", "CreationDate": "2017-01-25T12:55:03.240", "LastActivityDate": "2017-01-25T12:55:03.240"}, "bq_ids": {"n4140": {"so_41851520_41851940_5": {"section_id": 4413, "quality": 0.8333333333333334, "length": 25}, "so_41851520_41852166_3": {"section_id": 4413, "quality": 0.8571428571428571, "length": 24}, "so_41851520_41851940_1": {"section_id": 4431, "quality": 1.0, "length": 4}, "so_41851520_41851940_3": {"section_id": 4489, "quality": 1.0, "length": 4}}, "n3337": {"so_41851520_41851940_5": {"section_id": 4250, "quality": 0.8333333333333334, "length": 25}, "so_41851520_41852166_3": {"section_id": 4250, "quality": 0.8571428571428571, "length": 24}, "so_41851520_41851940_1": {"section_id": 4268, "quality": 1.0, "length": 4}, "so_41851520_41851940_3": {"section_id": 4320, "quality": 1.0, "length": 4}}, "n4659": {"so_41851520_41852166_3": {"section_id": 5672, "quality": 0.8571428571428571, "length": 24}, "so_41851520_41851940_5": {"section_id": 5672, "quality": 0.8333333333333334, "length": 25}, "so_41851520_41851940_1": {"section_id": 5695, "quality": 1.0, "length": 4}, "so_41851520_41851940_3": {"section_id": 5753, "quality": 1.0, "length": 4}}}, "41851520": {"CommentCount": "9", "ViewCount": "115", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2017-01-25T12:20:41.343", "LastActivityDate": "2017-01-25T12:55:03.240", "Title": "`weak_ptr::expired` behavior in the dtor of the object", "FavoriteCount": "1", "LastEditDate": "2017-01-25T12:29:06.073", "Id": "41851520", "Score": "2", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\nusing namespace std;\n\nclass T;\n\nstd::weak_ptr&lt;T&gt; wptr;\n\nclass T\n{\npublic:\n    T() {  }\n    ~T() {\n        std::cout &lt;&lt; \"in dtor\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; (wptr.expired() ? \"expired\" : \"not expired\") &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    {\n        auto ptr = std::make_shared&lt;T&gt;();\n        wptr = ptr;\n        std::cout &lt;&lt; (wptr.expired() ? \"expired\" : \"not expired\") &lt;&lt; std::endl;\n    }\n    return 0;\n}\n</code></pre>\n<p>In this code, I was trying to find out if <code>weak_ptr</code>s are expired in the objects destruction phase. It seems so. The output is:</p>\n<pre><code>not expired\nin dtor\nexpired\n</code></pre>\n<p>I used gcc-5.1 with <a href=\"http://ideone.com/ZSKXC2\" rel=\"nofollow noreferrer\">ideone</a>.</p>\n<p>Now, I have another problem. I couldn't find any documentation stating that this is the standard behavior. Is it guaranteed to work this way, <strong>always</strong>?</p>\n", "Tags": "<c++><c++11><c++14><shared-ptr><weak-ptr>", "OwnerUserId": "2604712", "AnswerCount": "2"}});