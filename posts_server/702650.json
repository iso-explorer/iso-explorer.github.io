post_cb({"bq_ids": {"n4140": {"so_702650_702701_0": {"length": 35, "quality": 0.875, "section_id": 5443}}, "n3337": {"so_702650_702701_0": {"length": 35, "quality": 0.875, "section_id": 5238}}, "n4659": {"so_702650_702701_0": {"length": 35, "quality": 0.875, "section_id": 6870}}}, "702650": {"ViewCount": "7459", "Body": "<p>Example:</p>\n<pre><code>template&lt;class T&gt;\nclass Base {\npublic:\n    Base();\n    friend class T;\n};\n</code></pre>\n<p>Now this doesn't work... Is there a way of doing this?</p>\n<p>I'm actually trying to make a general class sealer like this:</p>\n<pre><code>class ClassSealer {\nprivate:\n   friend class Sealed;\n   ClassSealer() {}\n};\nclass Sealed : private virtual ClassSealer\n{ \n   // ...\n};\nclass FailsToDerive : public Sealed\n{\n   // Cannot be instantiated\n};\n</code></pre>\n<p>I found this example on this site somewhere but I can't find it... (<a href=\"https://stackoverflow.com/questions/656224/when-should-i-use-c-private-inheritance/656523#656523\">here</a>)</p>\n<p>I know there are <a href=\"http://www.gamedev.net/reference/programming/features/cppseal/\" rel=\"nofollow noreferrer\">other ways</a> of doing this but just now I'm curious if you actually can do something like this.</p>\n", "AcceptedAnswerId": "702701", "Title": "Making a template parameter a friend?", "CreationDate": "2009-03-31T19:23:02.510", "Id": "702650", "CommentCount": "0", "FavoriteCount": "11", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:34:19.023", "LastEditorDisplayName": "dribeas", "OwnerDisplayName": "Bumhunter", "LastEditorUserId": "-1", "LastActivityDate": "2016-03-26T03:21:07.853", "Score": "30", "OwnerUserId": "75073", "Tags": "<c++><templates><friend>", "AnswerCount": "3"}, "5608542": {"Id": "5608542", "PostTypeId": "2", "Body": "<p>I found a simple trick to declare template parameters as friends: </p>\n<pre><code>template &lt; typename T&gt;\nstruct type_wrapper \n{ \n   typedef T type; \n}; \n\n\ntemplate &lt; typename T&gt; class foo \n{ \n  friend class type_wrapper &lt; T&gt;::type \n};   // type_wrapper&lt; T&gt;::type == T\n</code></pre>\n<p>However I do not know how this could help to define an alternative version of a class sealer.</p>\n", "LastEditorUserId": "377270", "LastActivityDate": "2011-04-10T00:36:58.767", "Score": "16", "CreationDate": "2011-04-09T23:04:48.823", "ParentId": "702650", "CommentCount": "3", "LastEditDate": "2011-04-10T00:36:58.767", "OwnerUserId": "700402"}, "702683": {"Id": "702683", "PostTypeId": "2", "Body": "<p>Do you really need to do this?\nIf you want to prevent someone from deriving from your class, just add a comment and make the destructor non-virtual.</p>\n", "OwnerDisplayName": "rlbond", "LastActivityDate": "2009-03-31T19:30:22.617", "Score": "3", "CreationDate": "2009-03-31T19:30:22.617", "ParentId": "702650", "CommentCount": "3", "OwnerUserId": "72631"}, "702701": {"Body": "<p>It is explicitly disallowed in the standard, even if some versions of VisualStudio do allow it.</p>\n<p>C++ Standard 7.1.5.3 Elaborated type specifiers, paragraph 2</p>\n<blockquote>\n<p id=\"so_702650_702701_0\">3.4.4 describes how name lookup proceeds for the identifier in an\n  elaborated-type-specifier. If the \n  identifier resolves to\n  a class-name or enum-name,\n  the elaborated-type-specifier introduces\n  it into the declaration the same\n  way a simple-type-specifier introduces\n  its type-name. If the identifier resolves\n  to a typedef-name or a\n  template type-parameter, \n  the elaborated-type-specifier is\n  ill-formed. [Note: this implies that, \n  within a class template with a\n  template type-parameter T, the\n  declaration  <em>friend class T</em>;  is\n  ill-formed. ]</p>\n</blockquote>\n<p>I recognize the code above as a pattern to seal (disallow the extension of) a class. There is another solution, that does not really block the extension but that will flag unadvertidly extending from the class. As seen in <a href=\"http://stlab.adobe.com/group__adobe__final.html\" rel=\"noreferrer\">ADOBE Source Library</a>:</p>\n<pre><code>namespace adobe { namespace implementation {\ntemplate &lt;class T&gt;\nclass final\n{\nprotected:\n   final() {}\n};\n}}\n#define ADOBE_FINAL( X ) private virtual adobe::implementation::final&lt;T&gt;\n</code></pre>\n<p>with the usage:</p>\n<pre><code>class Sealed : ADOBE_FINAL( Sealed )\n{//...\n};\n</code></pre>\n<p>While it allows extension if you really force it:</p>\n<pre><code>class SealBreaker : public Sealed, ADOBE_FINAL( Sealed )\n{\npublic:\n   SealBreaker() : adobe::implementation::final&lt;Sealed&gt;(), Sealed() {}\n};\n</code></pre>\n<p>It will restrict users from mistakenly do it.</p>\n<p><strong>EDIT</strong>: </p>\n<p>The upcoming C++11 standard does allow you to befriend a type argument with a slightly different syntax:</p>\n<pre><code>template &lt;typename T&gt;\nclass A {\n   // friend class T; // still incorrect: elaborate type specifier\n   friend T;          // correct: simple specifier, note lack of \"class\"\n};\n</code></pre>\n", "CreationDate": "2009-03-31T19:35:43.820", "ParentId": "702650", "CommentCount": "1", "LastEditDate": "2012-05-07T21:52:35.763", "PostTypeId": "2", "LastEditorDisplayName": "dribeas", "LastActivityDate": "2012-05-07T21:52:35.763", "LastEditorUserId": "36565", "Id": "702701", "OwnerDisplayName": "dribeas", "Score": "32", "OwnerUserId": "36565"}});