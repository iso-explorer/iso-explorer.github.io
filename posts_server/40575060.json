post_cb({"40575312": {"ParentId": "40575060", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>Do not use member function pointers, or get the types exactly right (no conversion).</p>\n<p>Really, decouple from member function pointers.  Store a tuple of <code>T*</code> consuming function objects (via private inheritance (enabling empty base optimization) if you care about a byte or few) without using <code>std::function</code>.</p>\n<p>So</p>\n<pre><code>template&lt;class T, class...Fs&gt;\n</code></pre>\n<p>we create <code>std::tuple&lt;Fs...&gt;</code>.  We execute by iterating over the tuple (there are many stack overflow questions about this, google can find them).</p>\n<p>We can use lambdas to describe calling the member function, or write a <code>template&lt;class U, void(U::*mem)()&gt;</code> stateless helper if you dislike having to actually pass the stateless object in.</p>\n<p>Here are some C++14 helpers:</p>\n<pre><code>template&lt;class=void,std::size_t...Is&gt;\nauto indexer( std::index_sequence&lt;Is...&gt; ) {\n  return [](auto&amp;&amp;f)-&gt;decltype(auto) {\n    return decltype(f)(f)( std::integral_constant&lt;std::size_t, Is&gt;{}... );\n  };\n}\n// takes a number N\n// returns a function object that, when passed a function object f\n// passes it compile-time values from 0 to N-1 inclusive.\ntemplate&lt;std::size_t N&gt;\nauto indexer() {\n  return indexer( std::make_index_sequence&lt;N&gt;{} );\n}\n// takes a function object f\n// returns a function object that takes any number of arguments\n// and invokes `f` on each of them\ntemplate&lt;class F&gt;\nauto for_each_arg(F&amp;&amp; f) {\n  return [f = std::forward&lt;F&gt;(f)](auto&amp;&amp;...args)-&gt;void {\n    // this is a bit insane.  We want to expand our parameter pack\n    // args... in a way that we do it from left to right.  As it happens,\n    // creating a C-style array is one of the legal ways to do this.\n    // So we create an anonymous C-style array, and discard it immediately\n    // The void stuff is a mixture of suppressing warnings and\n    // ensuring that if someone has a hostile `operator,` it doesn't cause\n    // any issues\n    // the result of this expression is an array of `int` full of `0`,\n    // plus the function `f` invokes on each of the `args...` in order:\n    using discard=int[];\n    (void)discard{0,(void(\n      f( decltype(args)(args) )\n    ),0)...};\n  };\n};\n</code></pre>\n<p>Given a tuple <code>bob</code> of lambdas, we can invoke them all on some pointer <code>p</code> like this:</p>\n<pre><code>// the pack 0 to N-1, where N is the size of bob:\nauto index = indexer&lt;std::tuple_size&lt;decltype(bob)&gt;{}&gt;();\n\n// From a compile time `i`, do what we want:\nauto invoker = [&amp;](auto i) {\n  std::get&lt;i&gt;(bob)(p);\n};\n\n// For each compile time integer from 0 to N-1,\n// call invoker:\nindex(for_each_arg(invoker));\n</code></pre>\n<p>All of this becomes much easier in C++17.</p>\n<p>The above code is full of micro-optimizations, some of which make it harder to understand.  If you want to understand more, find a SO question directly on this subject, or ask one if you cannot find one.</p>\n<hr>\n<p>Some of the above is C++14.  In C++11 we'll have to manually expand some of those lambdas.</p>\n<p>For example, the <code>indexer</code> becomes:</p>\n<pre><code>template&lt;std::size_t...Is&gt;\nstruct indexer_t {\n  template&lt;class F&gt;\n  auto operator()( F&amp;&amp; f ) const\n  -&gt; decltype(std::forward&lt;F&gt;(f)( std::integral_constant&lt;std::size_t, Is&gt;{}... ))\n  {\n    return std::forward&lt;F&gt;(f)( std::integral_constant&lt;std::size_t, Is&gt;{}... );\n  }\n};\n\ntemplate&lt;class=void,std::size_t...Is&gt;\nindexer_t&lt;Is...&gt; indexer( std::index_sequence&lt;Is...&gt; )\n{ return {}; }\ntemplate&lt;std::size_t N&gt;\nauto indexer()\n-&gt; decltype( indexer(std::make_index_sequence&lt;N&gt;{}) ) )\n{ return {}; }\n</code></pre>\n<p>or somesuch.</p>\n<p>Some nominally C++14 compiler may also need the above help (like MSVC2015), as they don't let you expand parameter packs from the enclosing context within a lambda.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/807196bb85af6287\" rel=\"nofollow noreferrer\">Live example #1</a> and <a href=\"http://coliru.stacked-crooked.com/a/5261e2a19c82ccd5\" rel=\"nofollow noreferrer\">Live example #2</a>.  I use <code>std::array</code> as it is tuple-like (supports get and element counting trait) yet less typing for 3 elements.</p>\n</hr>", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2016-11-14T21:24:03.010", "Id": "40575312", "Score": "3", "CreationDate": "2016-11-13T15:09:00.187", "LastActivityDate": "2016-11-14T21:24:03.010"}, "40575405": {"ParentId": "40575060", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_40575060_40575405_0\"><strong>[conv.mem]/2</strong> A prvalue of type \u201cpointer to member of <code>B</code> of type <em>cv</em> <code>T</code>\u201d, where <code>B</code> is a class type, can be converted to a prvalue of type \u201cpointer to member of <code>D</code> of type <em>cv</em> <code>T</code>\u201d, where <code>D</code> is a derived class (Clause 10) of <code>B</code>. If <code>B</code> is an inaccessible (Clause 11), ambiguous (10.2), or <strong>virtual</strong> (10.1) base class of <code>D</code>, or a base class of a virtual base class of <code>D</code>, a program that necessitates this conversion is <strong>ill-formed</strong>.</p>\n</blockquote>\n<p>Emphasis mine.</p>\n<blockquote>\n<p id=\"so_40575060_40575405_1\"><strong>[expr.unary.op]/3</strong> The result of the unary <code>&amp;</code> operator is a pointer to its operand. The operand shall be an lvalue or a <em>qualified-id</em>. If the operand is a <em>qualified-id</em> naming a non-static member <code>m</code> of some class <code>C</code> with type <code>T</code>, the result has type \u201cpointer to member of class <code>C</code> of type <code>T</code>\u201d and is a prvalue designating <code>C::m</code>... [ <em>Example:</em></p>\n<pre><code>struct A { int i; };\nstruct B : A { };\n... &amp;B::i ... // has type int A::*\n</code></pre>\n<p id=\"so_40575060_40575405_2\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<p>The second paragraph says <code>&amp;D12::b1</code> is of type <code>void (D1::*)()</code>, not <code>void (D12::*)()</code>, because <code>D12</code> doesn't itself have a member named <code>b1</code>. The first paragraph says a pointer of type <code>void (D1::*)()</code> is not convertible to <code>void (D12::*)()</code> because of virtual inheritance.</p>\n", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "40575405", "Score": "1", "CreationDate": "2016-11-13T15:19:24.547", "LastActivityDate": "2016-11-13T15:19:24.547"}, "bq_ids": {"n4140": {"so_40575060_40575405_1": {"section_id": 6066, "quality": 0.8620689655172413, "length": 25}, "so_40575060_40575405_0": {"section_id": 43, "quality": 0.9166666666666666, "length": 33}}, "n3337": {"so_40575060_40575405_1": {"section_id": 5834, "quality": 0.8620689655172413, "length": 25}, "so_40575060_40575405_0": {"section_id": 40, "quality": 0.9166666666666666, "length": 33}}, "n4659": {"so_40575060_40575405_1": {"section_id": 7562, "quality": 0.8620689655172413, "length": 25}, "so_40575060_40575405_0": {"section_id": 43, "quality": 0.9166666666666666, "length": 33}}}, "40575060": {"CommentCount": "2", "ViewCount": "77", "CreationDate": "2016-11-13T14:44:32.707", "LastActivityDate": "2016-11-14T21:24:03.010", "Title": "How to use multiple virtual function pointer from different inheritance-hierarchy levels as template argument?", "AcceptedAnswerId": "40575312", "PostTypeId": "1", "Id": "40575060", "Score": "1", "Body": "<p>I have a problem to use virtual function pointer as template arguments. The problem seems to be that the compiler do not look for all functions in base classes or can't see them as functions of derived class.</p>\n<pre><code>struct B1\n{\n    virtual void b1() = 0;\n    virtual ~B1() = default;\n};\n\nstruct B2\n{\n    virtual void b2() = 0;\n    virtual ~B2() = default;\n};\n\nstruct D1\n    : virtual public B1\n{\n    void b1() override {}\n};\n\nstruct D12\n    : virtual public D1\n    , virtual public B2\n{\n    void b2() override {}\n};\n</code></pre>\n<p>Helper class to execute a sequence of member function for a given instance.</p>\n<pre><code>template&lt;\n    typename T,\n    void(T::*...Fs)()&gt;\nstruct Executor\n{\n    static\n    void\n        execute(\n            T &amp; t)\n    {}\n};\n\ntemplate&lt;\n    typename T,\n    void(T::*F)(),\n    void(T::*...Fs)()&gt;\nstruct Executor&lt;\n    T, F, Fs...&gt;\n{\n    static\n    void\n        execute(\n            T &amp; t)\n    {\n        (t.*F)();\n        Executor&lt;T, Fs...&gt;::execute(t);\n    }\n};\n</code></pre>\n<p>Actual class for flexible executing of functions in given order</p>\n<pre><code>template&lt;\n    typename T,\n    void(T::*...Fs)()&gt;\nstruct FlexBind\n{\n    std::unique_ptr&lt;T&gt; t;\n    void b()\n    {\n        Executor&lt;T, Fs...&gt;::execute(*t);\n    }\n};\n</code></pre>\n<p>The use case for me is that I like to define the call order of functions statically (compile-time), but the object-instance those functions are called with is defined dynamically (runtime).</p>\n<pre><code>int main()\n{\n    FlexBind&lt;D12, D12::b1, D12::b2&gt; FB1;//compile error\n    FlexBind&lt;D12, D12::b2, D12::b1&gt; FB2;\n    FB1.t.reset(new D12());\n    FB1.b();\n    FB2.t.reset(new D12());\n    FB2.b();\n    return 0;\n}\n</code></pre>\n<p>The error I get is:  </p>\n<pre><code>error: '&amp;D1::b1' is not a valid template argument for type\n    'void (D12::*)()' because it is of type 'void (D1::*)()'\n</code></pre>\n<p>The compiler can not match <code>void (D12::*)()</code> and <code>void (D1::*)()</code><br>\nIf I add a function <code>b1</code> to <code>D12</code> calling <code>D1::b1</code> everything compiles and runs.</br></p>\n<pre><code>struct D12\n    : virtual public D1\n    , virtual public B2\n{\n    void b1() override {D1::b1();}//would solve the problem, but is not feasible\n    void b2() override {}\n};\n</code></pre>\n<p>Unfortunatly in my case I can't change the class <code>D12</code>, is there another possibility to get it running?<br>\nI think the compiler knows the inheritance hierarchy, so he should know which functions are known/accessible at which inheritance-level. But probably I'm missing something why it is not working?</br></p>\n", "Tags": "<c++><c++11><inheritance><variadic-templates><virtual-functions>", "OwnerUserId": "4838304", "AnswerCount": "2"}});