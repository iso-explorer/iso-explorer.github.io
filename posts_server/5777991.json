post_cb({"5779732": {"ParentId": "5777991", "CommentCount": "1", "Body": "<p><em>\"can\"</em> vs <em>\"may\"</em>.<br>\ncan denotes ability where may denotes permission.</br></p>\n<blockquote>\n<p id=\"so_5777991_5779732_0\">Is there a reason why you would not have permission to the start a user-defined literal suffix with _ followed by a digit?</p>\n</blockquote>\n<p>Permission implies coding standards or best-practices.  The examples you provides seem to show that <code>_\\d</code> would fine suffixes if used correctly (to denote numeric base).  Unfortunately your question can't have a well thought out answer as no one has experience with this new language feature yet.</p>\n<p>Just to be clear <code>user-defined literal suffixes</code> <strong>can</strong> start with <code>_\\d</code>.</p>\n", "OwnerUserId": "28817", "PostTypeId": "2", "Id": "5779732", "Score": "1", "CreationDate": "2011-04-25T15:04:28.103", "LastActivityDate": "2011-04-25T15:04:28.103"}, "5777991": {"CommentCount": "4", "ViewCount": "873", "CreationDate": "2011-04-25T11:43:56.287", "LastActivityDate": "2011-07-01T06:30:11.893", "Title": "User-defined Literals suffix, with *_digit...\"?", "AcceptedAnswerId": "5795857", "PostTypeId": "1", "Id": "5777991", "Score": "1", "Body": "<p>A <strong>user-defined literal suffix</strong> in C++0x should be an <strong>identifier</strong> that</p>\n<ul>\n<li>starts with <code>_</code> (underscore) (17.6.4.3.5)</li>\n<li>should <em>not</em> begin with <code>_</code> followed by uppercase letter (17.6.4.3.2)\n<blockquote>\n<p id=\"so_5777991_5777991_0\">Each name that [...] begins with an underscore followed by an uppercase letter is reserved to the implementation for any use.</p></blockquote></li>\n</ul>\n<p>Is there any reason, why such a suffix may not start <code>_</code> <strong>followed by a digit</strong>? I.E. <code>_4</code> or <code>_3musketeers</code>?</p>\n<pre><code>Musketeer dartagnan = \"d'Artagnan\"_3musketeers;\nint num = 123123_4; // to be interpreted in base4 system?\nstring s = \"gdDadndJdOhsl2\"_64; // base64decoder\n</code></pre>\n", "Tags": "<c++11><literals><identifier><user-defined-literals>", "OwnerUserId": "472245", "AnswerCount": "4"}, "6544399": {"ParentId": "5777991", "CommentCount": "0", "Body": "<p>I <strong>knew</strong> I had some papers on this subject:\n<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2281.html\" rel=\"nofollow\">Digital Separators</a> describes a proposal to use _ as a digit separator in numeric literals</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2747.html\" rel=\"nofollow\">Ambiguity and Insecurity with User-Defined literals</a> Describes the evolution of ideas about literal suffix naming and namespace reservation and efforts to deconflict user-defined literals against a future digit separator.</p>\n<p>It just doesn't look that good for the _ digit separator.</p>\n<p>I had an idea though: how about either a backslash or a backtick for digit separator?  It isn't as nice as _ but I don't think there would be any collision as long as the backslash was inside the stream of digits.  The backtick has no lexical use currently that I know of.</p>\n<pre><code>i = 123\\456\\789;\nj = 0xface\\beef;\n</code></pre>\n<p>or</p>\n<pre><code>i = 123`456`789;\nj = 0xface`beef;\n</code></pre>\n<p>This would leave _123 as a literal suffix.</p>\n", "OwnerUserId": "680359", "PostTypeId": "2", "Id": "6544399", "Score": "1", "CreationDate": "2011-07-01T06:30:11.893", "LastActivityDate": "2011-07-01T06:30:11.893"}, "5798919": {"ParentId": "5777991", "CommentCount": "4", "Body": "<p>An underscore followed by a digit is a legal user-defined literal suffix.\nThe function signature would be:\noperator\"\" _4();\nso it couldn;t get eaten by a placeholder.\nThe literal would be a <strong>single preprocessor token</strong>:\n123123_4;\nso the _4 would not get clobbered by a placeholder or a preprocessor symbol.</p>\n<p>My reading of 17.6.4.3.5 is that suffixes not containing a leading underscore risk collision with the implementation or future library additions.  They also collide with existing suffixes: F, L, ULL, etc.  One of the rationales for user-defined literals is that a new type (such as decimals for example) could be defined as a pure library extension including literals with suffuxes d, df, dl.</p>\n<p>Then there's the question of style and readability.  Personally, I think I would loose sight of the suffix 1234_3;  Maybe, maybe not.</p>\n<p>Finally, there was some idea that didn't make it into the standard (but I kind of like) to have _ be a literal separator for numbers like in Ada and Ruby.  So you could have 123_456_789 to visually separate thousands for example.  Your suffix would break if that ever went through.</p>\n", "OwnerUserId": "680359", "PostTypeId": "2", "Id": "5798919", "Score": "1", "CreationDate": "2011-04-27T03:11:14.350", "LastActivityDate": "2011-04-27T03:11:14.350"}, "5795857": {"ParentId": "5777991", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>The precedent for identifiers of the form <code>_&lt;number&gt;</code> is the function argument placeholder object mechanism in <code>std::placeholders</code> (\u00a720.8.9.1.3), which defines an implementation-defined number of such symbols.</p>\n<p>This is a good thing, because it means the user cannot <code>#define</code> any identifier of that form. \u00a717.6.4.3.1/1:</p>\n<blockquote>\n<p id=\"so_5777991_5795857_0\">A translation unit that includes a standard library header shall not #define or #undef names declared in any standard library header.</p>\n</blockquote>\n<p>The name of the user-defined literal function is <code>operator \"\" _123</code>, not simply <code>_123</code>, so there is no direct conflict between your name and the library name if presence of the <code>using namespace std::placeholders;</code>.</p>\n<p>My 2\u00a2, though, is that you would be better off with an <code>operator \"\" _baseconv</code> and encoding the base within the literal, <code>\"123123_4\"_baseconv</code>.</p>\n<p><strong>Edit:</strong> <strike>Looking at Johannes' (deleted) answer, there is</strike> There may be concern that <code>_123</code> could be used as a macro <em>by the implementation</em>. This is certainly the realm of theory, as the implementation would have little to gain by such preprocessor use. Furthermore, if I'm not mistaken, the reason for hiding these symbols in <code>std::placeholders</code>, not <code>std</code> itself, is that such names are <em>more</em> likely to be used by the user, such as by inclusion of Boost Bind (which does <em>not</em> hide them inside a named namespace).</p>\n<p>The tokens are not reserved for use by the implementation globally (17.6.4.3.2), and there is precedent for their use, so they are at least as safe as, say, <code>forward</code>.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2011-04-26T21:27:21.517", "Id": "5795857", "Score": "1", "CreationDate": "2011-04-26T20:10:19.193", "LastActivityDate": "2011-04-26T21:27:21.517"}, "bq_ids": {"n4140": {"so_5777991_5777991_0": {"section_id": 6307, "quality": 1.0, "length": 10}, "so_5777991_5795857_0": {"section_id": 6305, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_5777991_5777991_0": {"section_id": 6064, "quality": 1.0, "length": 10}, "so_5777991_5795857_0": {"section_id": 6062, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_5777991_5777991_0": {"section_id": 6756, "quality": 0.9, "length": 9}, "so_5777991_5795857_0": {"section_id": 7816, "quality": 0.8181818181818182, "length": 9}}}});