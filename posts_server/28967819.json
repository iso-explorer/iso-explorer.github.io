post_cb({"bq_ids": {"n4140": {"so_28967819_28969108_4": {"length": 13, "quality": 1.0, "section_id": 198}, "so_28967819_28969108_1": {"length": 13, "quality": 1.0, "section_id": 198}, "so_28967819_28968169_2": {"length": 17, "quality": 1.0, "section_id": 166}, "so_28967819_28968169_1": {"length": 17, "quality": 1.0, "section_id": 166}}, "n3337": {"so_28967819_28969108_4": {"length": 13, "quality": 1.0, "section_id": 192}, "so_28967819_28969108_1": {"length": 13, "quality": 1.0, "section_id": 192}, "so_28967819_28968169_2": {"length": 17, "quality": 1.0, "section_id": 160}, "so_28967819_28968169_1": {"length": 17, "quality": 1.0, "section_id": 160}}, "n4659": {"so_28967819_28969108_4": {"length": 13, "quality": 1.0, "section_id": 204}, "so_28967819_28969108_1": {"length": 13, "quality": 1.0, "section_id": 204}, "so_28967819_28968169_2": {"length": 17, "quality": 1.0, "section_id": 170}, "so_28967819_28968169_1": {"length": 17, "quality": 1.0, "section_id": 170}}}, "28968169": {"Id": "28968169", "PostTypeId": "2", "Body": "<h3>Introduction</h3>\n<p><code>Foo_t&lt;T&gt;::Bar</code> might look like a dependent-name, but it isn't since the <em>template-arguments</em> passed to the <em>alias-declaration</em> are not used when determining what the <em>qualified-id</em> <code>Bar</code> is referring to.</p>\n<p>The code is well-formed.</p>\n<hr>\n<hr>\n<h3>What does the Standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"noreferrer\">N3337</a>) say?</h3>\n<blockquote>\n<p id=\"so_28967819_28968169_0\"><em>14.5.7/2</em> <strong>Alias templates</strong> <code>[temp.alias]</code></p>\n<blockquote>\n<p id=\"so_28967819_28968169_2\">When a <em>template-id</em> refers to the specialization of an alias template, it is equivalent to the associated type\n    obtained by substitution of its <em>template-arguments</em> for the <em>template-parameters</em> in the <em>type-id</em> of the alias\n    template.</p>\n</blockquote>\n</blockquote>\n<p><sup></sup></p>\n<blockquote>\n<p id=\"so_28967819_28968169_3\"><em>A.6</em> <strong>Declarations</strong> <code>[gram.dcl]</code></p>\n<pre class=\"lang-none prettyprint-override\"><code>alias-declaration:\n  using identifier attribute-specifier-seq_opt = type-id ;\n</code></pre>\n</blockquote>\n<hr>\n<hr>\n<h3>What is the Standard <em>really</em> saying?</h3>\n<p>Since there are no <em>template-parameters</em> in the <em>type-id</em> of <code>Foo_t</code>, the <em>template alias-declaration</em> is always directly equivalent to <code>Foo</code>, no matter what <em>template-arguments</em> we pass to it.</p>\n<pre><code>template&lt;class... Ts&gt;\nusing Foo_t = Foo;\n//            ^--- \"Foo\" = type-id\n</code></pre>\n<hr>\n<p>Replacing the usage of <code>Foo_t&lt;T&gt;</code> with the equivalence of the <em>template alias-declaration</em> leaves us with the following:</p>\n<pre><code>template&lt;class T&gt;\nvoid f(){\n    Foo::Bar b; // ok, nothing here depends on `T`\n}\n</code></pre>\n</hr></hr></hr></hr></hr>", "LastEditorUserId": "1090079", "LastActivityDate": "2015-03-10T15:57:24.710", "Score": "15", "CreationDate": "2015-03-10T15:49:44.150", "ParentId": "28967819", "CommentCount": "5", "LastEditDate": "2015-03-10T15:57:24.710", "OwnerUserId": "1090079"}, "28969108": {"Id": "28969108", "PostTypeId": "2", "Body": "<p>With some more digging, this is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1390\" rel=\"noreferrer\">CWG issue 1390</a>.</p>\n<p>The issue description is</p>\n<blockquote>\n<p id=\"so_28967819_28969108_0\">According to 14.6.2.1 [temp.dep.type] paragraph 8, a type is dependent\n  (among other things) if it is</p>\n<blockquote>\n<p id=\"so_28967819_28969108_4\">a <em>simple-template-id</em> in which either the template name is a template\n    parameter or any of the template arguments is a dependent type or an\n    expression that is type-dependent or value-dependent</p>\n</blockquote>\n<p id=\"so_28967819_28969108_2\">This applies to alias template specializations, even if the resulting\n  type does not depend on the template argument:</p>\n<pre><code>struct B { typedef int type; };\ntemplate&lt;typename&gt; using foo = B;\ntemplate&lt;typename T&gt; void f() {\n  foo&lt;T&gt;::type * x;  //error: typename required\n}\n</code></pre>\n<p id=\"so_28967819_28969108_3\">Is a change to the rules for cases like this warranted?</p>\n</blockquote>\n<p>And there's a note in that issue:</p>\n<blockquote>\n<p id=\"so_28967819_28969108_5\"><strong>Notes from the October, 2012 meeting:</strong></p>\n<p id=\"so_28967819_28969108_6\">CWG agreed that no <code>typename</code> should be required in this case. In some\n  ways, an alias template specialization is like the current\n  instantiation and can be known at template definition time.</p>\n</blockquote>\n<p>The issue is still in \"drafting\" status, but it looks like the compiler vendors are already implementing the intended resolution.</p>\n", "LastActivityDate": "2015-03-10T16:30:25.400", "Score": "7", "CreationDate": "2015-03-10T16:30:25.400", "ParentId": "28967819", "CommentCount": "1", "OwnerUserId": "2756719"}, "28967819": {"ViewCount": "905", "Body": "<p>The following code compiles <a href=\"http://coliru.stacked-crooked.com/a/dfa72bbc9fc0b209\" rel=\"noreferrer\">using both Clang and GCC</a>, even though <code>Foo_t&lt;T&gt;::Bar</code> doesn't have <code>typename</code> in front of it:</p>\n<pre><code>struct Foo {\n    using Bar = int;\n};\n\ntemplate&lt;class...&gt;\nusing Foo_t = Foo;\n\ntemplate&lt;class T&gt;\nvoid f(){\n    Foo_t&lt;T&gt;::Bar b; // No typename!\n}\n\nint main(){\n    f&lt;int&gt;();\n}\n</code></pre>\n<p>Should it compile?</p>\n", "Title": "'typename' and alias templates", "CreationDate": "2015-03-10T15:35:30.353", "LastActivityDate": "2015-03-10T21:05:45.850", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-03-10T21:05:45.850", "LastEditorUserId": "63550", "Id": "28967819", "Score": "22", "OwnerUserId": "2756719", "Tags": "<c++><templates><c++11><language-lawyer>", "AnswerCount": "2"}});