post_cb({"bq_ids": {"n4140": {"so_20923800_20923847_0": {"length": 18, "quality": 1.0, "section_id": 3914}}, "n3337": {"so_20923800_20923847_0": {"length": 18, "quality": 1.0, "section_id": 3774}}}, "20923847": {"CommentCount": "7", "Body": "<p>That's allowed by the standard (\u00a76.6.3/3)</p>\n<blockquote>\n<p id=\"so_20923800_20923847_0\">A return statement with an expression of type void can be used only in functions with a return type of cv void; the expression is evaluated just before the function returns to its caller.</p>\n</blockquote>\n", "CreationDate": "2014-01-04T16:55:37.330", "ParentId": "20923800", "Id": "20923847", "LastActivityDate": "2014-01-04T16:55:37.330", "PostTypeId": "2", "Score": "11", "OwnerUserId": "635608"}, "20923800": {"CreationDate": "2014-01-04T16:52:03.877", "ViewCount": "394", "FavoriteCount": "1", "Id": "20923800", "AcceptedAnswerId": "20923847", "Score": "8", "Title": "Why is g++ allowing me to treat this void-function as anything but?", "LastEditorUserId": "34509", "CommentCount": "9", "Body": "<p>Why does the following compile in GCC 4.8 (<code>g++</code>)? Isn't it completely ill-formed?</p>\n<pre><code>void test(int x)\n{\n    return test(3);\n}\n\nint main() {}\n</code></pre>\n<ol>\n<li>I'm trying to use the result of calling <code>test</code>, which does not exist</li>\n<li>I'm trying to return a value from <code>test</code></li>\n</ol>\n<p>Both should be fundamentally impossible \u2014 not just UB, as far as I can recall \u2014 with a <code>void</code> return type.</p>\n<p>The only warning I get is about <code>x</code> being unused, not even anything about a non-standard implicit return type being added.</p>\n<h2><a href=\"http://coliru.stacked-crooked.com/a/26ef5111fe0abf9f\" rel=\"nofollow\">Live demo</a></h2>\n", "Tags": "<c++><gcc><c++11>", "LastEditDate": "2014-01-05T17:55:05.550", "LastActivityDate": "2014-01-05T17:55:05.550", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "560648"}, "20926814": {"LastActivityDate": "2014-01-05T04:21:57.327", "CommentCount": "0", "Body": "<p>As to why GCC allows it - sure because the Standard requires it to be valid. Building the transitive closure to the rationale of the rule in the Standard, I'm pretty sure that GCC allows this because it's useful in the event of templates</p>\n<pre><code>template&lt;typename F&gt;\ntypename std::result_of&lt;F()&gt;::type call(F f) {\n  return f();\n}\n\nint main() {\n   std::cout &lt;&lt; call([]{ return 42; }) &lt;&lt; std::endl;\n   call([]{ std::cout &lt;&lt; \"I'm just an outputtor!\" &lt;&lt; std::endl; });\n}\n</code></pre>\n<p>As you see, <code>call</code> did not need to do a special case for <code>void</code> in the return statement. Sort of similar to how <code>x.~T()</code> is allowed even if <code>T</code> ends up as <code>int</code>. </p>\n", "CreationDate": "2014-01-04T21:12:52.333", "LastEditDate": "2014-01-05T04:21:57.327", "ParentId": "20923800", "Id": "20926814", "LastEditorUserId": "34509", "PostTypeId": "2", "Score": "6", "OwnerUserId": "34509"}});