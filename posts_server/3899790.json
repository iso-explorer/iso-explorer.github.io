post_cb({"3899790": {"CommentCount": "9", "AcceptedAnswerId": "3900082", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-10-10T09:41:01.797", "LastActivityDate": "2016-10-03T10:04:03.483", "LastEditDate": "2017-05-23T12:26:29.903", "ViewCount": "11741", "FavoriteCount": "38", "Title": "shared_ptr magic :)", "Id": "3899790", "Score": "68", "Body": "<p><a href=\"https://stackoverflow.com/questions/3899688/default-virtual-dtor/3899726#3899726\">Mr. Lidstr\u00f6m and me had an argument</a> :)</p>\n<p>Mr. Lidstr\u00f6m's claim is that a construct <code>shared_ptr&lt;Base&gt; p(new Derived);</code> doesn't require Base to have a virtual destructor:</p>\n<blockquote>\n<p id=\"so_3899790_3899790_0\"><strong>Armen Tsirunyan</strong>: \"Really? Will the <em>shared_ptr</em> clean up correctly? Could you please in this case demonstrate how that effect could be implemented?\"</p>\n<p id=\"so_3899790_3899790_1\"><strong>Daniel Lidstr\u00f6m</strong>: \"The <em>shared_ptr</em> uses its own destructor to delete the Concrete instance. This is known as RAII within the C++ community. My advice is that you learn all you can about RAII. It will make your C++ coding so much easier when you use RAII in all situations.\"</p>\n<p id=\"so_3899790_3899790_2\"><strong>Armen Tsirunyan</strong>: \"I know about RAII, and I also know that eventually the <em>shared_ptr</em> destructor may delete the stored px when pn reaches 0. But if px had static type pointer to <code>Base</code> and dynamic type pointer to <code>Derived</code>, then unless <code>Base</code> has a virtual destructor, this will result in undefined behavior. Correct me if I am wrong.\"</p>\n<p id=\"so_3899790_3899790_3\"><strong>Daniel Lidstr\u00f6m</strong>: \"The <em>shared_ptr</em> knows the static type is Concrete. It knows this since I passed it in its constructor! Seems a bit like magic, but I can assure you it is by design and extremely nice.\"</p>\n</blockquote>\n<p>So, judge us. How is it possible (if it is) to implement <em>shared_ptr</em> without requiring polymorphic classes to have virtual destructor?\nThanks in advance</p>\n", "Tags": "<c++><destructor><smart-pointers>", "OwnerUserId": "469935", "AnswerCount": "3"}, "3899802": {"ParentId": "3899790", "CommentCount": "4", "CreationDate": "2010-10-10T09:46:02.953", "OwnerUserId": "66522", "PostTypeId": "2", "Id": "3899802", "Score": "13", "Body": "<p>Simply,</p>\n<p><code>shared_ptr</code> uses special deleter function that is created by constructor that always uses\nthe destructor of the given object and not the destructor of Base, this is a bit of work with template meta programming, but it works.</p>\n<p>Something like that</p>\n<pre><code>template&lt;typename SomeType&gt;\nshared_ptr(SomeType *p)\n{\n   this-&gt;destroyer = destroyer_function&lt;SomeType&gt;(p);\n   ...\n}\n</code></pre>\n", "LastActivityDate": "2010-10-10T09:46:02.953"}, "bq_ids": {"n4140": {"so_3899790_3900082_1": {"section_id": 4295, "quality": 0.6666666666666666, "length": 4}, "so_3899790_3900082_0": {"section_id": 4380, "quality": 0.75, "length": 12}, "so_3899790_3900082_3": {"section_id": 4412, "quality": 0.8095238095238095, "length": 17}}, "n3337": {"so_3899790_3900082_1": {"section_id": 4136, "quality": 0.6666666666666666, "length": 4}, "so_3899790_3900082_0": {"section_id": 4217, "quality": 0.75, "length": 12}, "so_3899790_3900082_3": {"section_id": 4249, "quality": 0.8095238095238095, "length": 17}}, "n4659": {"so_3899790_3900082_1": {"section_id": 5553, "quality": 0.6666666666666666, "length": 4}, "so_3899790_3900082_3": {"section_id": 5671, "quality": 0.9523809523809523, "length": 20}}}, "3900082": {"ParentId": "3899790", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2010-10-10T11:18:06.813", "Score": "63", "LastEditorUserId": "172531", "LastEditDate": "2016-10-03T10:04:03.483", "Id": "3900082", "OwnerUserId": "172531", "Body": "<p>Yes, it is possible to implement shared_ptr that way. Boost does and the C++11 standard also requires this behaviour. As an added flexibility shared_ptr manages more than just a reference counter. A so-called deleter is usually put into the same memory block that also contains the reference counters. But the fun part is that the type of this deleter is not part of the shared_ptr type. This is called \"type erasure\" and is basically the same technique used for implementing the \"polymorphic functions\" boost::function or std::function for hiding the actual functor's type. To make your example work, we need a templated constructor:</p>\n<pre><code>template&lt;class T&gt;\nclass shared_ptr\n{\npublic:\n   ...\n   template&lt;class Y&gt;\n   explicit shared_ptr(Y* p);\n   ...\n};\n</code></pre>\n<p>So, if you use this with your classes Base and Derived ...</p>\n<pre><code>class Base {};\nclass Derived : public Base {};\n\nint main() {\n   shared_ptr&lt;Base&gt; sp (new Derived);\n}\n</code></pre>\n<p>... the templated constructor with Y=Derived is used to construct the shared_ptr object. The constructor has thus the chance to create the appropriate deleter object and reference counters and stores a pointer to this control block as a data member. If the reference counter reaches zero, the previously created and Derived-aware deleter will be used to dispose of the object.</p>\n<p>The C++11 standard has the following to say about this constructor (20.7.2.2.1):</p>\n<blockquote>\n<p id=\"so_3899790_3900082_0\"><em>Requires:</em> <code>p</code> must be convertible to <code>T*</code>. <code>Y</code> shall be a complete type. <strong>The expression <code>delete p</code> shall be well formed, shall have well defined behaviour and shall not throw exceptions.</strong></p>\n<p id=\"so_3899790_3900082_1\"><em>Effects:</em> Constructs a <code>shared_ptr</code> object <strong>that <em>owns</em> the pointer <code>p</code>.</strong></p>\n<p id=\"so_3899790_3900082_2\">\u2026</p>\n</blockquote>\n<p>And for the destructor (20.7.2.2.2):</p>\n<blockquote>\n<p id=\"so_3899790_3900082_3\"><em>Effects:</em> If <code>*this</code> is <em>empty</em> or shares ownership with another <code>shared_ptr</code> instance (<code>use_count() &gt; 1</code>), there are no side effects.\n  Otherwise, if <code>*this</code> owns an object <code>p</code> and a deleter <code>d</code>, <code>d(p)</code> is called.\n  <strong>Otherwise, if <code>*this</code> owns a pointer <code>p</code>, and <code>delete p</code> is called.</strong></p>\n</blockquote>\n<p>(emphasis using bold font is mine).</p>\n", "LastActivityDate": "2016-10-03T10:04:03.483"}, "3899808": {"ParentId": "3899790", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2010-10-10T09:47:53.997", "Score": "26", "LastEditorUserId": "277176", "LastEditDate": "2010-10-10T10:41:09.843", "Id": "3899808", "OwnerUserId": "277176", "Body": "<p>When shared_ptr is created it stores a <em>deleter</em> object inside itself. This object is called when the shared_ptr is about to free the pointed resource. Since you know how to destroy the resource at the point of construction you can use shared_ptr with incomplete types. Whoever created the shared_ptr stored a correct deleter there.</p>\n<p>For example, you can create a custom deleter:</p>\n<pre><code>void DeleteDerived(Derived* d) { delete d; } // EDIT: no conversion needed.\n\nshared_ptr&lt;Base&gt; p(new Derived, DeleteDerived);\n</code></pre>\n<p>p will call DeleteDerived to destroy the pointed object. The implementation does this automatically.</p>\n", "LastActivityDate": "2010-10-10T10:41:09.843"}});