post_cb({"bq_ids": {"n4140": {"so_16575534_16576184_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 6185}, "so_16575534_16576184_2": {"length": 5, "quality": 1.0, "section_id": 87}, "so_16575534_16576184_0": {"length": 5, "quality": 1.0, "section_id": 87}}, "n3337": {"so_16575534_16576184_2": {"length": 5, "quality": 1.0, "section_id": 82}, "so_16575534_16576184_0": {"length": 5, "quality": 1.0, "section_id": 82}, "so_16575534_16576184_3": {"length": 7, "quality": 1.0, "section_id": 5946}}, "n4659": {"so_16575534_16576184_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 7690}}}, "16576184": {"Id": "16576184", "PostTypeId": "2", "Body": "<h3>Short version</h3>\n<p>A template non-type argument has to be a constant expression. <code>((timer_peripheral *) 0x40000000)</code> includes a <code>reinterpret_cast</code> to a pointer-type, therefore you cannot use it in a constant expression.</p>\n<hr>\n<h3>C++03</h3>\n<p>[temp.arg.nontype]/1</p>\n<blockquote>\n<p id=\"so_16575534_16576184_0\">A template-argument for a non-type, non-template template-parameter shall be one of:</p>\n<ul>\n<li>an integral constant-expression of integral or enumeration type; or</li>\n<li>[...]</li>\n<li>the address of an object or function with external linkage, including function templates and function\n  template-ids but excluding non-static class members, expressed as <code>&amp; id-expression</code> where the <code>&amp;</code> is optional if the name refers to a function or array, or if the corresponding template-parameter is a reference; or</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>So we have to use an integral constant expression.</p>\n<p>[expr.const]/1</p>\n<blockquote>\n<p id=\"so_16575534_16576184_1\">An integral constant-expression can involve only literals (2.13), enumerators, const variables or static data members of integral or enumeration types initialized with constant expressions (8.5), non-type template parameters of integral or enumeration types, and sizeof expressions. [...] <strong>Only type conversions to integral or enumeration types can be used.</strong></p>\n</blockquote>\n<p><code>((timer_peripheral *) 0x40000000)</code> includes a cast to a pointer type, therefore it cannot appear in an integral constant expression.</p>\n<hr>\n<h3>C++11</h3>\n<p>[temp.arg.nontype]/1</p>\n<blockquote>\n<p id=\"so_16575534_16576184_2\">A template-argument for a non-type, non-template template-parameter shall be one of:</p>\n<ul>\n<li>for a non-type template-parameter of integral or enumeration type, a converted constant expression (5.19) of the type of the template-parameter; or</li>\n<li>[...]</li>\n<li>a constant expression (5.19) that designates the address of an object with static storage duration and external or internal linkage or a function with external or internal linkage, including function templates and function template-ids but excluding non-static class members, expressed (ignoring parentheses) as <code>&amp; id-expression</code>, except that the <code>&amp;</code> may be omitted if the name refers to a function or array and shall be omitted if the corresponding template-parameter is a reference; or</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>We cannot use an constant expression \"that designes the adress...\", but could we use a converted constant expression?</p>\n<p>[expr.const]/2</p>\n<blockquote>\n<p id=\"so_16575534_16576184_3\">A conditional-expression is a core constant expression unless it involves one of the following [...]</p>\n<ul>\n<li>[...]</li>\n<li>a reinterpret_cast (5.2.10);</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>Nope. Not possible.</p>\n<hr>\n<h3>A workaround</h3>\n<p>Using a function template to return the pointer.</p>\n<pre><code>#include &lt;cstdint&gt;\n\n// Effectively supplied by chip manufacturer headers\nstruct timer_peripheral {\n    volatile uint32_t count;\n    // ... lots of other registers ...\n};\n\n#define TIM1 ((timer_peripheral *) 0x40000000)\n#define TIM2 ((timer_peripheral *) 0x40000400)\n\nenum TIMS { tim1, tim2 };\n\ntemplate &lt; TIMS tim &gt;\ninline timer_peripheral* get_timer_address()\n{\n    static_assert(tim &amp;&amp; false, \"unknown timer identifier\");\n    return nullptr;\n}\n  template &lt;&gt;\n  inline timer_peripheral* get_timer_address &lt; tim1 &gt;()\n  {\n      return TIM1;\n  }\n  template &lt;&gt;\n  inline timer_peripheral* get_timer_address &lt; tim2 &gt;()\n  {\n      return TIM2;\n  }\n\n// My templated class\ntemplate &lt; TIMS tim &gt;\nclass OpticalEncoderCounter {\n    static timer_peripheral* get() { return get_timer_address&lt;tim&gt;(); }\n\npublic:\n    OpticalEncoderCounter();\n};\n\ntemplate &lt; TIMS tim &gt;\nOpticalEncoderCounter&lt;tim&gt;::OpticalEncoderCounter()\n{\n}\n\nint main()\n{\n    OpticalEncoderCounter&lt;tim1&gt; encoder0;\n}\n</code></pre>\n</hr></hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2013-05-15T23:01:47.867", "Score": "1", "CreationDate": "2013-05-15T22:39:43.613", "ParentId": "16575534", "CommentCount": "0", "OwnerUserId": "420683", "LastEditDate": "2013-05-15T23:01:47.867"}, "16576031": {"Id": "16576031", "PostTypeId": "2", "Body": "<p>The template parameter has to be an integral type; I think the compiler is casting it to unsigned int.</p>\n<p>You could probably make this work by running with that, and explicitly casting it yourself inside the template calss, but I don't think you need to.  </p>\n<p>Unless there is some reason you really need this to be templated, I would just either (1) add methods to the struct; or (2) create a wrapper class that just holds a pointer to the struct.</p>\n", "LastActivityDate": "2013-05-15T22:26:44.393", "CommentCount": "2", "CreationDate": "2013-05-15T22:26:44.393", "ParentId": "16575534", "Score": "0", "OwnerUserId": "1689490"}, "16575534": {"ViewCount": "262", "Body": "<p>I'm using the hardware timers of an STM32 to interface with a number of optical encoders.  I want to create a templatized class which provides a convenient interface for interacting with the hardware timer.  The timer registers are memory mapped and their addresses are #defined in manufacturer supplied headers that match the device datasheet.  The template parameter would effectively be the base memory address of a timer peripheral.  Below is a minimal working example of what I'm currently trying to do:</p>\n<pre><code>#include &lt;cstdint&gt;\n\n// Effectively supplied by chip manufacturer headers\nstruct timer_peripheral {\n  volatile uint32_t count;\n  // ... lots of other registers ...\n};\n// Also supplied by chip manufacturer headers\n#define TIM1 ((timer_peripheral *) 0x40000000)\n#define TIM2 ((timer_peripheral *) 0x40000400)\n// My templated class\ntemplate &lt;timer_peripheral * Timer&gt;\nclass OpticalEncoderCounter {\n  OpticalEncoderCounter();\n};\n\ntemplate &lt;timer_peripheral * Timer&gt;\nOpticalEncoderCounter&lt;Timer&gt;::OpticalEncoderCounter()\n{\n}\n\nint main()\n{\n  // option 1\n  OpticalEncoderCounter&lt;TIM1&gt; encoder0;\n\n  // option 2\n  timer_peripheral * t = TIM2;\n  OpticalEncoderCounter&lt;t&gt; encoder1;\n}\n</code></pre>\n<p>However, when I compile, I get these errors with g++-4.7.2 -std=c++11:</p>\n<p>error| could not convert template argument \u20181073742848u\u2019 to \u2018timer_peripheral*\u2019</p>\n<p>error| \u2018t\u2019 is not a valid template argument because \u2018t\u2019 is a variable, not the address of a variable</p>\n<p>After reading around about non-type template parameters, I'm still not sure how to fix my problem and whether templates can be used the way I am thinking.  I tried static_cast and reinterpret_cast in option 1, but it didn't seem to make any difference.</p>\n", "Title": "non-type template parameters based on hardware registers", "CreationDate": "2013-05-15T21:46:27.163", "LastActivityDate": "2013-05-15T23:27:02.953", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "Id": "16575534", "Score": "3", "OwnerUserId": "947839", "Tags": "<c++><templates><stm32><non-type>", "AnswerCount": "3"}, "16576625": {"Id": "16576625", "PostTypeId": "2", "Body": "<p>Convert the pointers to constant integers using pointer arithmetic:</p>\n<pre><code>// My templated class\n\n\n#define TIM_BASE TIM1\n\nconst int TIM1_OFFSET = TIM1 - TIM_BASE;\n\ntemplate &lt;size_t timerOffset&gt;\nclass OpticalEncoderCounter {\npublic:\n  OpticalEncoderCounter();\n\n  timer_peripheral * getTimer() { return  TIM_BASE + timerOffset;}\n\n};\n\ntemplate &lt;size_t timerOffset&gt;\nOpticalEncoderCounter&lt;timerOffset&gt;::OpticalEncoderCounter()\n{\n\n}\n\n\nint main()\n{\n\n  OpticalEncoderCounter&lt;TIM1_OFFSET&gt; encoder0;\n\n}\n</code></pre>\n", "LastActivityDate": "2013-05-15T23:27:02.953", "CommentCount": "7", "CreationDate": "2013-05-15T23:27:02.953", "ParentId": "16575534", "Score": "0", "OwnerUserId": "540026"}});