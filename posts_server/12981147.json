post_cb({"bq_ids": {"n4140": {"so_12981147_12981183_0": {"length": 19, "quality": 0.7916666666666666, "section_id": 6057}}, "n3337": {"so_12981147_12981183_0": {"length": 19, "quality": 0.7916666666666666, "section_id": 5825}}, "n4659": {"so_12981147_12981183_0": {"length": 19, "quality": 0.7916666666666666, "section_id": 7555}}}, "12981147": {"ViewCount": "167", "Body": "<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n        const int a = 2;\n        const int *p = &amp;a;\n        int *p2 = const_cast&lt;int*&gt;(p);\n        *p2=5;\n        char *p3 = (char *)&amp;a;\n        cout &lt;&lt; \"p2 is\" &lt;&lt; *p2 &lt;&lt; endl;\n        cout &lt;&lt; \"p2 address \" &lt;&lt; p2 &lt;&lt; endl;\n        cout &lt;&lt; \"a is \" &lt;&lt; a &lt;&lt; endl;\n        cout &lt;&lt; \"a address \" &lt;&lt; &amp;a &lt;&lt; endl;\n\n        return 0;\n}\n</code></pre>\n<p>Hi all!</p>\n<p>According to the output, *p2 and a has different values, *p2 is 5 and a is 2.</p>\n<p>However, p2 and &amp;a are the same. I'm confused...</p>\n<p>Could you please help me understand where this is the case?</p>\n<p>Thank you very much!</p>\n", "AcceptedAnswerId": "12981183", "Title": "C++ Does Const_Cast induce new variable?", "CreationDate": "2012-10-19T19:28:46.690", "LastActivityDate": "2012-10-19T20:06:20.903", "CommentCount": "1", "LastEditDate": "2012-10-19T20:06:20.903", "PostTypeId": "1", "Tags": "<c++><const-cast>", "Id": "12981147", "AnswerCount": "2", "Score": "1", "OwnerUserId": "1582802", "ClosedDate": "2017-07-31T11:22:41.173", "LastEditorUserId": "1582802"}, "12981183": {"Id": "12981183", "PostTypeId": "2", "Body": "<p>Undefined behavior means that anything can happen. Including this. </p>\n<h3>5.2.11 Const cast [expr.const.cast]</h3>\n<blockquote>\n<p id=\"so_12981147_12981183_0\">7) [ Note: Depending on the type of the object, a write operation through the pointer, lvalue or pointer\n  to data member resulting from a <code>const_cast</code> that casts away a const-qualifier<sup>73</sup> may produce undefined\n  behavior (7.1.6.1). \u2014end note ]</p>\n</blockquote>\n<p>The underlying reason might be that the compiler, seeing how <code>a</code> is <code>const</code>, optimizes <code>cout &lt;&lt; \"a is \" &lt;&lt; a &lt;&lt; endl;</code> to a simple <code>cout &lt;&lt; \"a is \" &lt;&lt; 2 &lt;&lt; endl;</code>.</p>\n<p>For example, <strong>even in a debug build</strong>, I get:</p>\n<pre><code>        cout &lt;&lt; \"a is \" &lt;&lt; a &lt;&lt; endl;\n00CE1581  mov         esi,esp  \n00CE1583  mov         eax,dword ptr [__imp_std::endl (0CFD30Ch)]  \n00CE1588  push        eax  \n00CE1589  mov         edi,esp  \n//...\n00CE158B  push        2 \n//...\n00CE158D  push        offset string \"a is \" (0CE7840h)  \n00CE1592  mov         ecx,dword ptr [__imp_std::cout (0CFD308h)]  \n00CE1598  push        ecx  \n00CE1599  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (0CE1159h)  \n00CE159E  add         esp,8  \n00CE15A1  mov         ecx,eax  \n00CE15A3  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (0CFD304h)]  \n00CE15A9  cmp         edi,esp  \n00CE15AB  call        @ILT+415(__RTC_CheckEsp) (0CE11A4h)  \n00CE15B0  mov         ecx,eax  \n00CE15B2  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (0CFD300h)]  \n00CE15B8  cmp         esi,esp  \n00CE15BA  call        @ILT+415(__RTC_CheckEsp) (0CE11A4h)  \n</code></pre>\n<p>I highlighted the essential part - <code>2</code> is pushed directly on the argument stack of <code>operator&lt;&lt;</code>, instead of the value of <code>a</code> being read.</p>\n", "LastEditorUserId": "673730", "LastActivityDate": "2012-10-19T19:40:37.893", "Score": "6", "CreationDate": "2012-10-19T19:30:56.923", "ParentId": "12981147", "CommentCount": "4", "OwnerUserId": "673730", "LastEditDate": "2012-10-19T19:40:37.893"}, "12981286": {"Id": "12981286", "PostTypeId": "2", "Body": "<p>This is where you've gone astray:</p>\n<pre><code>int main() {\n        const int a = 2;\n        const int *p = &amp;a;\n        int *p2 = const_cast&lt;int*&gt;(p);\n        *p2=5;\n</code></pre>\n<p>On the last line here, you've assigned a variable thu a pointer that points to something that <em>is actually const</em>.  That is, <code>a</code> is <code>const</code>.  <code>p2</code> points to <code>a</code>.  You can't change the value of <code>a</code>, even through <code>p2</code>, without invoking Undefined Behavior.</p>\n", "LastActivityDate": "2012-10-19T19:37:26.557", "CommentCount": "1", "CreationDate": "2012-10-19T19:37:26.557", "ParentId": "12981147", "Score": "1", "OwnerUserId": "241536"}});