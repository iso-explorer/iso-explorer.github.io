post_cb({"bq_ids": {"n4140": {"so_16423702_16423702_0": {"length": 33, "quality": 0.9428571428571428, "section_id": 1171}}, "n3337": {"so_16423702_16423702_0": {"length": 33, "quality": 0.9428571428571428, "section_id": 1169}}}, "16423702": {"ViewCount": "575", "Body": "<p>C++11 [atomics.types.generic]p7:</p>\n<blockquote>\n<p id=\"so_16423702_16423702_0\">There shall be named types corresponding to the integral specializations of <code>atomic</code>, as specified in Table 145, and a named type <code>atomic_bool</code> corresponding to the specified <code>atomic&lt;bool&gt;</code>. Each named type is a either typedef to the corresponding specialization <strong>or a base class of the corresponding specialization</strong>. If it is a base class, it shall support the same member functions as the corresponding specialization.</p>\n</blockquote>\n<p>(emphasis added)</p>\n<p>What's the rationale for letting <code>std::atomic_char</code> not be identical to <code>std::atomic&lt;char&gt;</code>, and so on for all the other types?  What flexibility does this enable, and why is it useful?  At first glance I don't understand why these wouldn't be required to be typedefs to <code>std::atomic&lt;T&gt;</code> specializations directly.</p>\n<p>Note that <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html\">N2427</a> which proposed <code>&lt;atomic&gt;</code> says that the typedefs are to specializations exactly, and not possibly to base classes.</p>\n", "AcceptedAnswerId": "16442337", "Title": "Why are the std::atomic_{char,schar,etc.} typedefs allowed to be typedefs to a base class of std::atomic<T>, and not to atomic<T> only?", "CreationDate": "2013-05-07T16:08:30.907", "Id": "16423702", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-05-08T00:15:32.090", "LastEditorUserId": "115698", "LastActivityDate": "2013-05-08T13:43:25.423", "Score": "10", "OwnerUserId": "115698", "Tags": "<c++><c++11><stl><atomic><c++-standard-library>", "AnswerCount": "1"}, "16442337": {"PostTypeId": "2", "Body": "<p>It is probably there because someone already had an implementation of atomics using <code>std::atomic_*</code> types as base classes and complained enough/provided a good argument towards this approach.</p>\n<p>In <a href=\"http://connect.microsoft.com/VisualStudio/feedback/details/720151/c-11-unsupported-std-atomic-bool-constructor\" rel=\"nofollow\">MSVC</a> such an implementation is suggested. </p>\n<p>In <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3193.htm\" rel=\"nofollow\">this</a> it is stated that</p>\n<blockquote>\n<p id=\"so_16423702_16442337_0\">Remove the definional base-class relationship between atomic_.... named types and the corresponding specializations of the atomic template class. The base-class relationship is now implementation-dependent. This change ensures compatibility with C. Some member functions and operators, that were formerly inherited from the base class, must be hoisted from the named types to the specializations.</p>\n</blockquote>\n", "LastActivityDate": "2013-05-08T13:43:25.423", "Id": "16442337", "CommentCount": "1", "CreationDate": "2013-05-08T13:43:25.423", "ParentId": "16423702", "Score": "2", "OwnerUserId": "487362"}});