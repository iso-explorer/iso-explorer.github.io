post_cb({"bq_ids": {"n4140": {"so_36377758_36377968_0": {"length": 18, "quality": 1.0, "section_id": 3327}}, "n3337": {"so_36377758_36377968_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 3197}}, "n4659": {"so_36377758_36377968_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 4093}}}, "36411040": {"Id": "36411040", "PostTypeId": "2", "Body": "<p>After some thinking, I came up with a solution based on <code>mutable</code>. The other answer is still mostly correct, but one can create a proxy with a mutable member to get rid of the top-level <code>const</code>-ness and then move the elements from there. Methods taking an initializer list should therefore overload for a const-ref initializer list and an rvalue-ref version to know when they are allowed to move.</p>\n<p>Here's a working example, it might look arbitrary at first but in my real-world use-case, it solved the problem.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// to show which operations are called\nstruct my_string\n{\n    const char* s_;\n    my_string( const char* s ) : s_( s ) { std::cout &lt;&lt; \"my_string(const char*) \" &lt;&lt; s_ &lt;&lt; std::endl; }\n    my_string( const my_string&amp; m ) : s_( m.s_ ) { std::cout &lt;&lt; \"my_string(const my_string&amp;) \" &lt;&lt; s_ &lt;&lt; std::endl; }\n    my_string( my_string&amp;&amp; m ) noexcept : s_( m.s_ ) { std::cout &lt;&lt; \"my_string(my_string&amp;&amp;) \" &lt;&lt; s_ &lt;&lt; std::endl; }\n    ~my_string() { std::cout &lt;&lt; \"~my_string() \" &lt;&lt; s_ &lt;&lt; std::endl; }\n};\n\n// the proxy\nstruct my_string_proxy\n{\n    mutable my_string s_;\n\n    // add all ctors needed to initialize my_string\n    my_string_proxy( const char* s ) : s_( s ) {}\n};\n\n// functions/methods should be overloaded\n// for the initializer list versions\n\nvoid insert( std::vector&lt;my_string&gt;&amp; v, const std::initializer_list&lt;my_string_proxy&gt;&amp; il )\n{\n    for( auto&amp; e : il ) {\n        v.push_back( e.s_ );\n    }\n}\n\nvoid insert( std::vector&lt;my_string&gt;&amp; v, std::initializer_list&lt;my_string_proxy&gt;&amp;&amp; il )\n{\n    for( auto&amp; e : il ) {\n        v.push_back( std::move( e.s_ ) );\n    }\n}\n\nint main()\n{\n    std::vector&lt;my_string&gt; words;\n    insert( words, { {\"Hello\"}, {\"initializer\"}, {\"with\"}, {\"move\"}, {\"support\"} } );\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/954e158159d8654a\" rel=\"nofollow\"><strong>Live example</strong></a></p>\n", "LastActivityDate": "2016-04-04T19:16:15.353", "CommentCount": "0", "CreationDate": "2016-04-04T19:16:15.353", "ParentId": "36377758", "Score": "2", "OwnerUserId": "2073257"}, "36377968": {"Id": "36377968", "PostTypeId": "2", "Body": "<p>There is no way to avoid the copying from an <code>initializer_list&lt;string&gt;</code>, because the standard defines the invocation of a constructor taking an initializer list argument, from a curly braces initializer as actual argument, as follows (emphasis added):</p>\n<b>C++14 \u00a78.5.4/5</b>\n<blockquote>\n<p id=\"so_36377758_36377968_0\"><strong>\u201d</strong> An object of type <code>std::initializer_list&lt;E&gt;</code> is constructed from an initializer list as if the implementation allocated a temporary array of <code>N</code> elements of type <strong><code>const E</code></strong>, where <code>N</code> is the number of elements in the\n  initializer list</p>\n</blockquote>\n<p>IMHO this is really unfortunate.</p>\n<p>A workaround (for your own classes) is to accept <code>initializer_list&lt;char const*&gt;</code>.</p>\n<hr>\n<p>Here's an example of the workaround applied to <code>std::vector&lt;string&gt;</code>. For that, where you don't control the class' code, it involves declaring a data array (actually an <code>initializer_list</code>) explicitly. This is just as with C++03, which the initializer list mechanism was intended to avoid:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;initializer_list&gt;\n#include &lt;iostream&gt;\n#include &lt;iterator&gt;              // std::begin, std::end\nusing namespace std;\n\nstruct My_string\n{\n    char const* const ps;\n\n    My_string( char const* const s )\n        : ps( s )\n    {\n        cout &lt;&lt; \"  My_string(*) &lt;- '\" &lt;&lt; s &lt;&lt; \"'\" &lt;&lt; endl;\n    }\n\n    My_string( My_string const&amp; other )\n        : ps( other.ps )\n    {\n        cout &lt;&lt; \"  My_string(const&amp;) &lt;- '\" &lt;&lt; other.ps &lt;&lt; \"'\" &lt;&lt; endl;\n    };\n\n    My_string( My_string&amp;&amp; other )\n        : ps( other.ps )\n    {\n        cout &lt;&lt; \"  My_string(&amp;&amp;) &lt;- '\" &lt;&lt; other.ps &lt;&lt; \"'\" &lt;&lt; endl;\n    };\n};\n\nauto main() -&gt; int\n{\n    cout &lt;&lt; \"Making vector a.\" &lt;&lt; endl;\n    vector&lt;My_string&gt; const a   = {\"a1\", \"a2\", \"a3\"};\n    cout &lt;&lt; \"Making data for vector b.\" &lt;&lt; endl;\n    auto const b_data           = { \"b1\", \"b2\", \"b3\" };\n    cout &lt;&lt; \"Making vector b.\" &lt;&lt; endl;\n    vector&lt;My_string&gt; const b( begin( b_data ), end( b_data ) );\n}\n</code></pre>\n<p>Output:</p>\n<pre>\nMaking vector a.\n  My_string(*) &lt;- 'a1'\n  My_string(*) &lt;- 'a2'\n  My_string(*) &lt;- 'a3'\n  My_string(const&amp;) &lt;- 'a1'\n  My_string(const&amp;) &lt;- 'a2'\n  My_string(const&amp;) &lt;- 'a3'\nMaking data for vector b.\nMaking vector b.\n  My_string(*) &lt;- 'b1'\n  My_string(*) &lt;- 'b2'\n  My_string(*) &lt;- 'b3'\n</pre>\n</hr>", "LastEditorUserId": "464581", "LastActivityDate": "2016-04-02T20:57:24.300", "Score": "4", "CreationDate": "2016-04-02T19:46:41.873", "ParentId": "36377758", "CommentCount": "5", "OwnerUserId": "464581", "LastEditDate": "2016-04-02T20:57:24.300"}, "36377758": {"ViewCount": "375", "Body": "<p>Let's say you have a variable of type <code>std::vector&lt;std::string&gt;</code> and you initialize it with an initializer list:</p>\n<pre><code>using V = std::vector&lt;std::string&gt;;\nV v = { \"Hello\", \"little\", \"world\", \"of\", \"move\", \"semantics\" };\n</code></pre>\n<p>The compiler will create a temporary <code>std::string</code> for each string literal, create an initializer list over these and then call the ctor for <code>V</code> and create the vector. The ctor does not know that all those strings are temporaries, so it is <strong>copying</strong> each string.</p>\n<p>I haven't found anything in the standard which allows the vector ctor to move the elements when they are temporaries.</p>\n<p>Am I missing something or does using initializer lists lead to unnecessary copies? I am writing classes where this problem could lead to significantly inefficient code. Any technique to avoid unnecessary copies would be greatly appreciated.</p>\n", "AcceptedAnswerId": "36377968", "Title": "how to move elements of an initializer_list?", "CreationDate": "2016-04-02T19:22:48.170", "Id": "36377758", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2016-04-04T19:16:15.353", "Score": "10", "OwnerUserId": "2073257", "Tags": "<c++><c++11><move-semantics><initializer-list>", "AnswerCount": "2"}});