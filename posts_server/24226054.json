post_cb({"24226136": {"ParentId": "24226054", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-06-15T02:49:38.687", "Score": "5", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:45:00.027", "Id": "24226136", "OwnerUserId": "1708801", "Body": "<p>Your example just deals with different modes of initialization, no reassignment is happening here. What you are seeing is the effect of the constructors initializer list being preferred over the in class member initializer, we can see from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow noreferrer\">draft C++ standard</a> section <code>12.6.2</code> <em>Initializing bases and members</em> paragraph <em>9</em> which says:</p>\n<blockquote>\n<p id=\"so_24226054_24226136_0\">If a given non-static data member has both a\n  brace-or-equal-initializer and a mem-initializer, the initialization\n  specified by the mem-initializer is performed, and the non-static data\n  member\u2019s brace-or-equal-initializer is ignored. [ Example: Given</p>\n<pre><code>struct A {\nint i = / some integer expression with side effects / ;\nA(int arg) : i(arg) { }\n// ...\n};\n</code></pre>\n<p id=\"so_24226054_24226136_1\">the A(int) constructor will simply initialize i to the value of arg,\n  and the side effects in i\u2019s brace-orequal- initializer will not take\n  place. \u2014end example ]</p>\n</blockquote>\n<p>As discussed in <a href=\"https://stackoverflow.com/questions/24149924/has-the-new-c11-member-initialization-feature-at-declaration-made-initializati/24150137#24150137\">Has the new C++11 member initialization feature at declaration made initialization lists obsolete?</a> this is a useful features since it allows you to default member variables and then override those defaults based on the constructor that is called.</p>\n", "LastActivityDate": "2014-06-15T17:16:48.363"}, "24226054": {"CommentCount": "4", "ViewCount": "531", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2014-06-15T02:31:39.617", "LastActivityDate": "2014-06-15T17:16:48.363", "Title": "Why is a const variable declared as a class member still modifiable?", "LastEditDate": "2014-06-15T03:47:50.657", "Id": "24226054", "Score": "5", "Body": "<p>If a const variable which has been assigned can still be reassigned, then it's not a const? Take for instance:</p>\n<pre><code> struct ss\n {\n     const int m = 1024;\n\n     ss()\n     {\n     }\n\n     ss(int m) : m(m)\n     {\n     }\n };\n\n\n\nss sa;\nss sb(-1);\n\ncout &lt;&lt; sa.m &lt;&lt; endl;\ncout &lt;&lt; sb.m &lt;&lt; endl; \n</code></pre>\n<p><strong>Wow m is not constant after all!</strong></p>\n<blockquote id=\"so_24226054_24226054_0\">\n<pre><code>&gt; /* Ouput:\n&gt; \n&gt; 1024\n&gt; -1\n&gt; \n&gt; */\n</code></pre>\n</blockquote>\n", "Tags": "<c++><c++11><initialization><declaration>", "OwnerUserId": "3613229", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24226054_24226136_0": {"section_id": 436, "quality": 0.9444444444444444, "length": 17}, "so_24226054_24226136_1": {"section_id": 436, "quality": 0.75, "length": 12}}, "n3337": {"so_24226054_24226136_0": {"section_id": 428, "quality": 0.9444444444444444, "length": 17}, "so_24226054_24226136_1": {"section_id": 428, "quality": 0.75, "length": 12}}, "n4659": {"so_24226054_24226136_0": {"section_id": 455, "quality": 0.8333333333333334, "length": 15}, "so_24226054_24226136_1": {"section_id": 455, "quality": 0.8125, "length": 13}}}, "24226069": {"ParentId": "24226054", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2014-06-15T02:35:23.703", "Score": "11", "LastEditorUserId": "481267", "LastEditDate": "2014-06-15T04:15:36.333", "Id": "24226069", "OwnerUserId": "481267", "Body": "<pre><code> ss(int m) : m(m)\n {\n }\n</code></pre>\n<p>This says that when the class <code>ss</code> is initialized, its member <code>m</code> is initialized using the parameter <code>m</code>. The member <code>m</code> indeed cannot be modified, but it can be initialized, just like any other <code>const</code> object. Note that if we did instead</p>\n<pre><code> ss(int m)\n {\n     this-&gt;m = m;\n }\n</code></pre>\n<p>then we would have a problem, as <code>ss::m</code> needs to be initialized. And if <code>ss::m</code> were a class with a default constructor, then in</p>\n<pre><code> ss(FooClass m)\n {\n     this-&gt;m = m;\n }\n</code></pre>\n<p>it's OK to not initialize <code>ss::m</code> explicitly (as it will just be default-constructed), but the line in the body of the constructor would be rejected as it would modify <code>ss::m</code> after it has already been initialized.</p>\n<p><strong>Edit:</strong> Whoops, I didn't understand your original question.</p>\n<p>A <em>brace-or-equal-initializer</em> such as </p>\n<pre><code>const int m = 1024;\n</code></pre>\n<p>is only used if the member is not mentioned in the <em>ctor-initializer</em>. In other words, since the default constructor doesn't explicitly initialize <code>m</code>, the value 1024 is used. But <code>ss::ss(int)</code> does explicitly initialize <code>m</code>, so the <em>brace-or-equal-initializer</em> is ignored.</p>\n", "LastActivityDate": "2014-06-15T04:15:36.333"}});