post_cb({"bq_ids": {"n4140": {"so_11018810_11018810_2": {"length": 25, "quality": 1.0, "section_id": 579}, "so_11018810_11018810_1": {"length": 34, "quality": 1.0, "section_id": 579}, "so_11018810_11018810_0": {"length": 7, "quality": 1.0, "section_id": 579}}, "n3337": {"so_11018810_11018810_2": {"length": 25, "quality": 1.0, "section_id": 569}, "so_11018810_11018810_1": {"length": 34, "quality": 1.0, "section_id": 569}, "so_11018810_11018810_0": {"length": 7, "quality": 1.0, "section_id": 569}}, "n4659": {"so_11018810_11018810_2": {"length": 25, "quality": 1.0, "section_id": 602}, "so_11018810_11018810_1": {"length": 31, "quality": 0.9117647058823529, "section_id": 602}, "so_11018810_11018810_0": {"length": 7, "quality": 1.0, "section_id": 602}}}, "11023163": {"Id": "11023163", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_11018810_11023163_0\">Question #1: In C++03, is there was no way to specify a function conversion operator template? It appears there was no way to resolve the template arguments (i.e., name them in a deduced context) in an acceptable function pointer type.</p>\n</blockquote>\n<p>Yes, that is correct. </p>\n<blockquote>\n<p id=\"so_11018810_11023163_1\">Question #2: In C++11, can such a conversion be specified using a default template argument?</p>\n</blockquote>\n<p>It can, and you can also use alias templates, but you cannot use such a conversion function template for creating surrogate call functions. You can use it for converting your class object to function pointers in implicit conversions otherwise. </p>\n<blockquote>\n<p id=\"so_11018810_11023163_2\">We also have alias templates. It seems that alias substitution occurs before instantiation, given the example in \u00a714.5.7/2, where the declarations of process conflict. In GCC 4.7, this code at least instantiates the declaration, but then it produces a bizarre \"candidate expects 2 arguments, 2 provided\" error.</p>\n</blockquote>\n<p>Yes, this is <a href=\"https://groups.google.com/forum/?fromgroups#!topic/comp.std.c++/lXLFBcF_m3c\" rel=\"nofollow\">https://groups.google.com/forum/?fromgroups#!topic/comp.std.c++/lXLFBcF_m3c</a> (and caused closure of DR395), but even though such a conversion function template can work in cases like <code>void(&amp;p)() = yourClassObject</code>, it won't work for surrogate call functions, because there the conversion function needs to provide a fixed non-dependent type that the class object is converted to when the surrogate function is called, but a conversion function template does not provide such a type normally (weird things like <code>template&lt;typename = int&gt; operator Identity&lt;void(*)()&gt;();</code> aside...).</p>\n<p>I think that GCC may incorrectly generates the candidate <code>call-function(void (&amp;)( t ), t)</code> with the dependent types still there and try to call that candidate, thereby violating some invariant of it (which could explain the weird error message - possibly hitting an <code>} else { ... }</code> unexpectedly somewhere). </p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2012-06-13T21:02:18.187", "Score": "3", "CreationDate": "2012-06-13T20:56:59.110", "ParentId": "11018810", "CommentCount": "5", "OwnerUserId": "34509", "LastEditDate": "2012-06-13T21:02:18.187"}, "11018810": {"ViewCount": "941", "Body": "<p>Yay, another question title composed of a random sequence of C++ terms!</p>\n<p>Usually we make a class Callable by implementing <code>operator()</code>. But you can also do so by implementing a user-defined conversion to function pointer or reference type. Instead of using perfect forwarding, a conversion function can return a pointer to a function which is then called with the original argument list.</p>\n<pre><code>struct call_printf {\n    typedef int printf_t( char const *, ... );\n    operator printf_t &amp; () { return std::printf; }\n};\n</code></pre>\n<p><a href=\"http://ideone.com/kqrJz\" rel=\"nofollow\">http://ideone.com/kqrJz</a></p>\n<p>As far as I can tell, the <code>typedef</code> above is a syntactic necessity. The name of a conversion function is formed from a <em>type-specifier-seq</em>, which does not allow a construct like <code>int (*)()</code>. That would require an <em>abstract-declarator</em>. Presumably the reason is that such type names get complicated, and complex constructs used as object names are tough to parse.</p>\n<p>Conversion functions are also allowed to be templated, but the template arguments must be deduced, because there is nowhere to explicitly specify them. (That would defeat the whole point of implicit conversion.)</p>\n<hr>\n<p><strong>Question #1:</strong> In C++03, is there was no way to specify a function conversion operator template? It appears there was no way to resolve the template arguments (i.e., name them in a deduced context) in an acceptable function pointer type.</p>\n<p>Here is the equivalent reference from C++11, \u00a713.3.1.1.2/2 [over.call.object]. It's substantially the same from C++03:</p>\n<blockquote>\n<p id=\"so_11018810_11018810_0\">In addition, for each non-explicit conversion function declared in T of the form</p>\n<pre><code>operator conversion-type-id () cv-qualifier attribute-specifier-seqopt;\n</code></pre>\n<p id=\"so_11018810_11018810_1\">where <em>cv-qualifier</em> is the same cv-qualification as, or a greater cv-qualification than, <em>cv</em>, <strong>and where <em>conversion-type-id</em> denotes the type \u201cpointer to function of (P1,...,Pn) returning R\u201d,</strong> or the type \u201creference to pointer to function of (P1,...,Pn) returning R\u201d, or the type \u201creference to function of (P1,...,Pn) returning R\u201d, a surrogate call function with the unique name call-function and having the form</p>\n<pre><code>R call-function ( conversion-type-id F, P1 a1, ... ,Pn an) { return F (a1,... ,an); }\n</code></pre>\n<p id=\"so_11018810_11018810_2\">is also considered as a candidate function. Similarly, surrogate call functions are added to the set of candidate functions for each non-explicit conversion function declared in a base class of T provided the\n  function is not hidden within T by another intervening declaration.</p>\n</blockquote>\n<hr>\n<p><strong>Question #2:</strong> In C++11, can such a conversion be specified using a default template argument? This is useful for SFINAE. The only difference here from the above example is that the <em>conversion-type-id</em> only represents a function reference after instantiation, because it's a dependent type (despite invariance). This trips up GCC and it skips the member template.</p>\n<pre><code>enum { call_alternate = true; }\n\nstruct call_switch {\n    template&lt; bool en = call_alternate &gt;\n    operator typename std::enable_if&lt; en, decltype( fn_1 ) &amp; &gt;::type ()\n        { return fn_1; }\n\n    template&lt; bool en = ! call_alternate &gt;\n    operator typename std::enable_if&lt; en, decltype( fn_2 ) &amp; &gt;::type ()\n        { return fn_2; }\n};\n</code></pre>\n<p>We also have alias templates. It seems that alias substitution occurs before instantiation, given the example in \u00a714.5.7/2, where the declarations of <code>process</code> conflict. In GCC 4.7, this code at least instantiates the declaration, but then it produces a bizarre \"candidate expects 2 arguments, 2 provided\" error.</p>\n<pre><code>template&lt; typename t &gt;\nusing fn_t = void (&amp;)( t );\n\nstruct talk {\n    template&lt; typename t &gt;\n    operator fn_t&lt; t &gt;() { return fn; }\n};\n\nint main() {\n    talk()( 3 );\n}\n</code></pre>\n</hr></hr>", "AcceptedAnswerId": "11023163", "Title": "Templated conversion function to function pointer", "CreationDate": "2012-06-13T15:57:20.737", "Id": "11018810", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2012-06-13T21:02:18.187", "Score": "8", "OwnerUserId": "153285", "Tags": "<c++><templates><c++11><type-conversion><functor>", "AnswerCount": "1"}});