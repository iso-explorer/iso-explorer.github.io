post_cb({"40505121": {"ParentId": "40502357", "CommentCount": "0", "CreationDate": "2016-11-09T10:47:46.993", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "40505121", "Score": "1", "Body": "<p>The explanatory text before the associative container requirements table says:</p>\n<blockquote>\n<p id=\"so_40502357_40505121_0\"><code>kl</code> is a value such that <code>a</code> [<em>sic</em>] is partitioned ([alg.sorting])\n  with respect to <code>c(r, kl)</code>, with <code>r</code> the key value of <code>e</code> and <code>e</code> in\n  <code>a</code>; <code>ku</code> is a value such that <code>a</code> is partitioned with respect to\n  <code>!c(ku, r)</code>; <code>ke</code> is a value such that <code>a</code> is partitioned with respect\n  to <code>c(r, ke)</code> and <code>!c(ke, r)</code>, with <code>c(r, ke)</code> implying <code>!c(ke, r)</code>.</p>\n</blockquote>\n<p>And then describes the behavior of <code>a_tran.{find,count,equal_range}(ke)</code>, <code>a_tran.lower_bound(kl)</code> and <code>a_tran.upper_bound(ku)</code>. Therefore, the requirements are:</p>\n<ul>\n<li>For <code>find</code>, <code>count</code>, and <code>equal_range</code>:\n\n<ul>\n<li>The elements in the container must be partitioned with respect to <code>c(r, ke)</code> and <code>!c(ke, r)</code></li>\n<li><code>c(r, ke)</code> must imply <code>!c(ke, r)</code></li>\n</ul></li>\n<li>For <code>lower_bound</code>, the elements in the container must be partitioned with respect to <code>c(r, kl)</code>.</li>\n<li>For <code>upper_bound</code>, the elements in the container must be partitioned with respect to <code>!c(ku, r)</code>.</li>\n</ul>\n<p>Provided that you meet those requirements, there's nothing wrong with using heterogeneous lookup with something that's equivalent to multiple keys in the container. The motivating example in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3465.pdf\" rel=\"nofollow noreferrer\">the original proposal</a>, after all, is about looking up everyone whose family name is \"Smith\" in a <code>set</code> of names.</p>\n", "LastActivityDate": "2016-11-09T10:47:46.993"}, "bq_ids": {"n4140": {"so_40502357_40505121_0": {"section_id": 744, "quality": 0.9, "length": 18}}, "n4659": {"so_40502357_40505121_0": {"section_id": 802, "quality": 0.9, "length": 18}}}, "40502357": {"CommentCount": "5", "ViewCount": "162", "PostTypeId": "1", "LastEditorUserId": "1430927", "CreationDate": "2016-11-09T08:07:10.637", "LastActivityDate": "2016-11-09T10:47:46.993", "Title": "map or set with transparent comparator and non-unique elements in heterogeneous sense", "AcceptedAnswerId": "40505121", "LastEditDate": "2016-11-09T09:46:18.173", "Id": "40502357", "Score": "2", "Body": "<p>Given <code>std::set&lt; T, less &gt;</code> or <code>std::map&lt; T, less &gt;</code> container of unique elements. <code>less</code> is heterogeneous comparator. I.e. it can compare value of some another type <code>U</code> against a value of type <code>T</code>. Whereas all the values of type <code>T</code> are unique, there are (maybe) a plenty of values of type <code>T</code>, that compare equal to some particular value of type <code>U</code>. Is it undefined behaviour?</p>\n<p>Say, I want to find (one) element in the container, which have the key, equivalent to the value of type <code>U</code>. Any one: either first, last or middle of them if there more then one. I know, that there are more then one element in the container, which are equivalent to the value <code>u</code> of type <code>U</code>. Can I use <code>std::set::find</code> or <code>std::map::find</code> function for? Is it <em>undefined behaviour</em>?</p>\n<p>Example (here imprecise comparison with tolerance <code>0.2</code>):</p>\n<pre><code>#include &lt;set&gt;\n#include &lt;iostream&gt;\n\ndouble const eps = 0.2;\n\nstruct less\n{\n    bool operator () (double l, double r) const { return l &lt; r; }\n    using is_transparent = void;\n    bool operator () (int l, double r) const { return l + eps &lt; r; }\n    bool operator () (double l, int r) const { return l + eps &lt; r; }\n};\n\nint main()\n{\n    std::set&lt; double, less &gt; s{0.0, 0.9, 1.0, 1.1, 2.0};\n    for (auto it = s.find(1); it != std::end(s); it = s.find(1)) {\n        std::cout &lt;&lt; *it &lt;&lt; ' ';\n        s.erase(it);\n    }\n}\n</code></pre>\n<p>Output (order generally unspecified):</p>\n<blockquote>\n<p id=\"so_40502357_40502357_0\">0.9 1 1.1</p>\n</blockquote>\n<p>Is it UB to use associative ordered containers of unique elements as above?</p>\n<p>Should I use <code>std::multiset</code> and <code>std::multimap</code> instead?</p>\n", "Tags": "<c++><stl><containers><c++14><heterogeneous>", "OwnerUserId": "1430927", "AnswerCount": "1"}});