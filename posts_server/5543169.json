post_cb({"5553253": {"PostTypeId": "2", "ParentId": "5543169", "Body": "<p>It seems, that in your example trailing-return-type cannot be omitted. Here is excerpt from standard (5.1.2 Lambda expressions):</p>\n<blockquote>\n<p id=\"so_5543169_5553253_0\">If a lambda-expression does not\n  include a trailing-return-type, it is\n  as if the trailing-return-type denotes\n  the following type: \u2014 if the compound-statement is of the form { attribute-specifier-seq return expression ; } the type of the returned expression after lvalue-to-rvalue conversion (4.1), array-to-pointer conversion (4.2), and function-to-pointer conversion (4.3); \u2014 otherwise, void.</p>\n</blockquote>\n<p>Returned value in your example cannot be used for conversions mentioned above. Following code with explicitely added return type compiles in VS 2010:</p>\n<pre><code>auto adder = [] (int x) -&gt; std::function&lt;int (int)&gt; {\n  return [=]( int y ) {\n    return x + y;\n  };\n};\n</code></pre>\n", "CreationDate": "2011-04-05T14:11:34.890", "Score": "0", "CommentCount": "4", "Id": "5553253", "OwnerUserId": "102243", "LastActivityDate": "2011-04-05T14:11:34.890"}, "5543195": {"PostTypeId": "2", "ParentId": "5543169", "Body": "<p><em>(Edit: this certainly does not explain the ICE; I read the original question too hastily.)</em></p>\n<p><strike>The</strike> <em>One</em> problem in that code is that the lambdas returned from the <code>adder</code> function contain dangling references to the <code>x</code> variable that no longer exists. Capture by copy (<code>[=]</code> or <code>[i]</code>) instead of a reference (<code>[&amp;]</code>) and everything should work.</p>\n", "CreationDate": "2011-04-04T19:16:27.657", "Score": "2", "LastEditDate": "2011-04-05T22:29:48.273", "CommentCount": "5", "Id": "5543195", "OwnerUserId": "279597", "LastEditorUserId": "279597", "LastActivityDate": "2011-04-05T22:29:48.273"}, "5556692": {"PostTypeId": "2", "ParentId": "5543169", "Body": "<p>You're just completely missing the point. The need for <code>std::function</code> is very, very obvious.</p>\n<ol>\n<li>All lambdas have a unique type at compile-time</li>\n<li>You want the vector to hold any functional object at run-time.</li>\n<li>Therefore, some sort of type erasure is required, which is the job <code>std::function</code> does.</li>\n</ol>\n<p>How on earth could you ever create a vector that varies at run-time a compile-time fact, like the type contained within it? That's just logically impossible- unless you use an abstraction such as <code>std::function</code>.</p>\n<p>Of course, if you only ever want one lambda type within, then you don't need <code>std::function</code> at all. This is relatively rare though.</p>\n<pre><code>int main() {\n    auto adder = [](int x) {\n        return [=](int y) {\n            return x + y;\n        };\n    };\n    // alternatively- you MUST copy the argument as it will cease to exist\n    // but once it's in the lambda, you can use \"mutable\" to allow you to\n    // modify the copy that each lambda has.\n    /*\n    auto adder = [](int x) {\n        return [=](int y) mutable {\n            return x += y;\n        };\n    };\n    */\n    std::vector&lt;decltype(adder(0))&gt; adders;\n    adders.emplace_back(adder(0));\n    adders.emplace_back(adder(1));\n\n    std::for_each(adders.begin(), adders.end(), [](decltype(*adders.begin())&amp; ref) {\n        std::cout &lt;&lt; ref(33);\n    });\n    std::cin.get();\n}\n</code></pre>\n<p>MSVC won't actually compile this little snippet, but I think that's a bug and judging by the reports of your compiler, I expect that it will compile there and indeed work correctly.</p>\n", "CreationDate": "2011-04-05T18:32:45.043", "Score": "0", "CommentCount": "3", "Id": "5556692", "OwnerUserId": "298661", "LastActivityDate": "2011-04-05T18:32:45.043"}, "5543169": {"AcceptedAnswerId": "5543195", "Body": "<p>Consider the example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;     // std::function\n#include &lt;vector&gt;        // std::vector\n#include &lt;algorithm&gt;    // std::for_each\n\nint main(){\n\n    auto adder = [](int x) {\n        return [&amp;](int y) { \n            return x+=y; \n        }; \n    };\n\n    std::vector &lt; std::function&lt;int(int)&gt; &gt; vec;\n\n    vec.push_back(adder(1));\n    vec.push_back(adder(10));\n\n    std::for_each(vec.begin(), vec.end(), [](std::function&lt;int(int)&gt; f){std::cout &lt;&lt; f(33) &lt;&lt; \" \";});\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>\n<p>One expects the integers <strike> 34 and 43 </strike> <strong>43</strong> and <strong>76</strong>, but instead gcc 4.6.0 produces \"internal compiler error: Segmentation fault\". What is wrong with the code?</p>\n<p>Edit: Several other examples are discussed <a href=\"https://stackoverflow.com/questions/5566198/undefined-behavior-with-the-c0x-closure-ii\">here</a>.</p>\n", "LastEditorUserId": "-1", "Score": "4", "LastEditDate": "2017-05-23T12:19:55.500", "CommentCount": "1", "Title": "Undefined Behavior with the C++0x Closure: I", "LastEditorDisplayName": "user688992", "LastActivityDate": "2011-04-08T21:16:26.053", "PostTypeId": "1", "Tags": "<lambda><c++11><closures><pass-by-reference>", "AnswerCount": "3", "Id": "5543169", "OwnerDisplayName": "user688992", "ViewCount": "1037", "CreationDate": "2011-04-04T19:13:57.247"}, "bq_ids": {"n3337": {"so_5543169_5553253_0": {"quality": 0.96, "length": 24, "section_id": 5732}}}});