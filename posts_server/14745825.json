post_cb({"14745894": {"ParentId": "14745825", "CommentCount": "3", "Body": "<p>Because <code>unsigned char</code> cannot be represented by <code>char</code>. For example, if they're both 8 bits, and your unsigned char contains the value <code>255</code>, that overflows the <code>signed char</code> - and signed integer overflow invokes undefined behavior. Anyway, printable characters are generally expected to be stored in <code>char</code> and not <code>unsigned char</code> (and C strings are of type <code>char[]</code> and not <code>unsigned char[]</code>, etc.)</p>\n<p>So the promotion to <code>int</code> is necessary to represent values greater than <code>1 &lt;&lt; (CHAR_BIT - 1)</code>.</p>\n", "Id": "14745894", "PostTypeId": "2", "OwnerDisplayName": "user529758", "Score": "12", "CreationDate": "2013-02-07T07:31:38.870", "LastActivityDate": "2013-02-07T07:31:38.870"}, "14745825": {"CommentCount": "1", "ViewCount": "1361", "CreationDate": "2013-02-07T07:26:48.760", "LastActivityDate": "2013-02-07T08:49:31.040", "Title": "Unsigned char automatically promoted to int in function call, why?", "FavoriteCount": "3", "PostTypeId": "1", "Id": "14745825", "Score": "12", "Body": "<p>Why is an <code>unsigned char</code> automatically promoted to an <code>int</code> when calling a function? In the example below there is an <code>f(int)</code> and a <code>f(char)</code> function. It seemed more logical that the compiler would coerce an <code>unsigned char</code> argument to a <code>char</code> and call <code>f(char)</code> since they have the same number of bits. It is calling <code>f(int)</code> instead, even when that means promoting the argument to a type with more bits. Any pointers to where the rule is defined? Standard or compiler/platform specific?</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid f( int key )\n{\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n}\n\nvoid f( char key )\n{\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n}\n\nint main( int argc, char* argv[] )\n{\n    int a = 'a';\n    char b = 'b';\n    unsigned char c = 'c';\n\n    f(a);\n    f(b);\n    f(c);\n\n    return 0;\n}\n</code></pre>\n<p>Produces this output:</p>\n<pre><code>void f(int)\nvoid f(char)\nvoid f(int)\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "1971981", "AnswerCount": "4"}, "14746323": {"ParentId": "14745825", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I believe the correct derivation from the Standard is based on the paragraph below, which is found section 13.3.3 <em>Best viable functions</em>, i.e. it's part of the (very complicated) rules for function overload resolution.</p>\n<blockquote>\n<p id=\"so_14745825_14746323_0\">(\u00a713.3.3.2/4) Standard conversion sequences are ordered by their ranks: an Exact Match is a better conversion than a Promotion, which is a better conversion than a Conversion. Two conversion sequences with the same rank are indistinguishable unless one of the following rules applies: [...]</p>\n</blockquote>\n<p>Converting <code>unsigned char</code> to <code>int</code> is classified as <em>promotion</em> (defined in \u00a74.5; when reading the below, note that <code>(unsigned) char</code> is an <em>integer type</em>):</p>\n<blockquote>\n<p id=\"so_14745825_14746323_1\">\u00a74.5 Integral promotions<br>\n  [...]</br></p>\n<p id=\"so_14745825_14746323_2\">(\u00a74.5/2) A prvalue of an integer type other than bool, char16_t, char32_t, or wchar_t whose integer conversion rank (4.13) is less than the rank of int can be converted to a prvalue of type int if int can represent all the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type unsigned int.</p>\n</blockquote>\n<p>Whereas converting <code>unsigned char</code> to <code>char</code> is not classified as <em>promotion</em> because their ranks are identical:</p>\n<blockquote>\n<p id=\"so_14745825_14746323_3\">(\u00a74.13/1) [...] The rank of char shall equal the rank of signed char and unsigned char. [...]</p>\n</blockquote>\n<p>It is classified as <em>integral conversion</em> (\u00a74.7) instead, and, as described above, promotion is preferred over conversion during overload resolution.</p>\n", "OwnerUserId": "777186", "LastEditorUserId": "777186", "LastEditDate": "2013-02-07T08:09:21.153", "Id": "14746323", "Score": "7", "CreationDate": "2013-02-07T07:59:43.790", "LastActivityDate": "2013-02-07T08:09:21.153"}, "14747015": {"ParentId": "14745825", "CommentCount": "1", "Body": "<p>In C++ standard , <code>char</code> isn't defined to be unsigned or signed (though size is 1 byte) , so it's implementation defined. So in your implementation I believe it's signed char that's why it got promoted.</p>\n", "OwnerUserId": "962474", "PostTypeId": "2", "Id": "14747015", "Score": "3", "CreationDate": "2013-02-07T08:49:31.040", "LastActivityDate": "2013-02-07T08:49:31.040"}, "bq_ids": {"n4140": {"so_14745825_14746323_2": {"section_id": 21, "quality": 0.95, "length": 38}, "so_14745825_14746323_3": {"section_id": 45, "quality": 0.8, "length": 8}, "so_14745825_14746323_0": {"section_id": 640, "quality": 0.9259259259259259, "length": 25}}, "n3337": {"so_14745825_14746323_2": {"section_id": 18, "quality": 0.95, "length": 38}, "so_14745825_14746323_3": {"section_id": 42, "quality": 0.8, "length": 8}, "so_14745825_14746323_0": {"section_id": 630, "quality": 0.9259259259259259, "length": 25}}, "n4659": {"so_14745825_14746323_2": {"section_id": 21, "quality": 0.95, "length": 38}, "so_14745825_14746323_3": {"section_id": 46, "quality": 0.8, "length": 8}, "so_14745825_14746323_0": {"section_id": 668, "quality": 0.9259259259259259, "length": 25}}}, "14745985": {"ParentId": "14745825", "CommentCount": "3", "Body": "<p>int and char are just different in range in C and C++, if char it ranges from 0 to 255 and if int, it has its range like 65535 (range of int will vary with OS). So compiler just treat it as int.</p>\n", "OwnerUserId": "1926664", "PostTypeId": "2", "Id": "14745985", "Score": "-1", "CreationDate": "2013-02-07T07:36:54.703", "LastActivityDate": "2013-02-07T07:36:54.703"}});