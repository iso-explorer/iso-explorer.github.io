post_cb({"bq_ids": {"n4140": {"so_36517596_36517737_0": {"length": 37, "quality": 0.9487179487179487, "section_id": 5440}}, "n3337": {"so_36517596_36517737_0": {"length": 36, "quality": 0.9230769230769231, "section_id": 5235}}, "n4659": {"so_36517596_36517737_0": {"length": 37, "quality": 0.9487179487179487, "section_id": 6867}}}, "36517596": {"ViewCount": "190", "Body": "<p>I'm trying to have a better understanding of <strong><em>decltype</em></strong> to determine the type of an expression at compile-time. Let's say for example I do it with a double variable:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nint main(){\n    double a;\n    typedef decltype(a) a_type;\n    typedef decltype((a)) ref_a_type;\n    typedef decltype(a)&amp; o_ref_a_type;\n\n    a_type b;\n    ref_a_type c = b;\n    o_ref_a_type d = b;\n\n  if (std::is_same&lt;decltype(b), double&gt;::value) std::cout &lt;&lt; \"b is double\\n\";\n  if (std::is_same&lt;decltype(c), double&amp;&gt;::value) std::cout &lt;&lt; \"c is double&amp;\\n\";\n  if (std::is_same&lt;decltype(d), double&amp;&gt;::value) std::cout &lt;&lt; \"d is double&amp;\\n\";\n}\n</code></pre>\n<p>If I have understood correctly these points should be true:</p>\n<ol>\n<li><code>decltype(a)</code> returns <code>double&amp;</code> if <code>a</code> is a lvalue and <code>double</code> otherwise. </li>\n<li>decltype deduces the type of an expression, unless it is applied to a variable, in which case it deduces the type of that variable.</li>\n<li>If the variable is parenthesized, it becomes an lvalue expression.</li>\n</ol>\n<p>Thus, <code>decltype((a))</code> and <code>decltype(a)&amp;</code> are equivalent in this case, but not always equivalent, for example, if <code>a</code> is not a variable:</p>\n<pre><code>typedef decltype((5)) ref_a_type;\ntypedef decltype(5)&amp; o_ref_a_type;\n</code></pre>\n<p>then both types are not equivalent (<code>ref_a_type</code> is <code>int</code> and <code>o_ref_a_type</code> is <code>int&amp;</code>, since the extra parenthesis are useless in this case). Can someone give a better explanation of this? Should I use the first or the second way?\nIMO it seems more readable and understandable the second way than the first. </p>\n", "AcceptedAnswerId": "36517737", "Title": "decltype parenthesis syntax for a lvalue", "CreationDate": "2016-04-09T13:44:05.543", "Id": "36517596", "CommentCount": "1", "LastEditDate": "2016-04-09T14:03:44.550", "PostTypeId": "1", "LastEditorUserId": "2069064", "LastActivityDate": "2016-04-09T14:03:44.550", "Score": "4", "OwnerUserId": "5690687", "Tags": "<c++><c++11><typetraits><decltype>", "AnswerCount": "1"}, "36517737": {"Id": "36517737", "PostTypeId": "2", "Body": "<p>The rules for <code>decltype(e)</code> are, as far as the C++ standard goes, pretty clear, so I'll just copy them (from [dcl.type.simple]):</p>\n<blockquote>\n<p id=\"so_36517596_36517737_0\">For an expression <code>e</code>, the type denoted by <code>decltype(e)</code> is defined as follows:<br>\n  (4.1) \u2014 if <code>e</code> is an unparenthesized <em>id-expression</em> or an unparenthesized class member access (5.2.5), <code>decltype(e)</code>\n  is the type of the entity named by <code>e</code>. If there is no such entity, or if e names a set of overloaded functions,\n  the program is ill-formed;<br>\n  (4.2) \u2014 otherwise, if <code>e</code> is an xvalue, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where <code>T</code> is the type of <code>e</code>;<br>\n  (4.3) \u2014 otherwise, if <code>e</code> is an lvalue, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of e;<br>\n  (4.4) \u2014 otherwise, <code>decltype(e)</code> is the type of <code>e</code>.</br></br></br></br></p>\n</blockquote>\n<p>So going through your examples in order:</p>\n<ol>\n<li><code>decltype(a)</code>: <code>a</code> is an unparenthesized <em>id-expression</em>, so this is just the type of <code>a</code>: <code>double</code>.</li>\n<li><code>decltype((a))</code>: now it's parenthesized, so we skip the first bullet. <code>a</code> isn't an xvalue, it's an lvalue, so this is <code>double&amp;</code>.</li>\n<li><code>decltype(a)&amp;</code>: this is just the first case again, so it's <code>double&amp;</code>.</li>\n<li><code>decltype((5))</code>: this is neither an <em>id-expression</em> (parenthesized or otherwise), an xvalue, or an lvalue - so we drop to the last bullet to just get the type of the expression: <code>int</code>.</li>\n<li><code>decltype(5)&amp;</code>: same as the last point, except now you're explicitly adding a <code>&amp;</code>, so <code>int&amp;</code>.</li>\n</ol>\n<blockquote>\n<p id=\"so_36517596_36517737_1\">Should I use the first or the second way?</p>\n</blockquote>\n<p>It depends on what type you actually want to get. The two ways mean different things - you should use whichever one solves the direct problem you're trying to solve. </p>\n<p>More generally, <code>decltype(expr)&amp;</code> is <em>always</em> an lvalue reference due to reference collapsing rules. </p>\n<p><code>decltype((expr))</code> could be a non-reference (as with <code>decltype((5))</code>), an lvalue reference (as with <code>decltype((a))</code>), or an rvalue reference (as with <code>decltype((std::move(a)))</code>).</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-04-09T14:01:55.677", "Score": "2", "CreationDate": "2016-04-09T13:56:09.830", "ParentId": "36517596", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2016-04-09T14:01:55.677"}});