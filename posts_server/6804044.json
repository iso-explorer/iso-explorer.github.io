post_cb({"6804113": {"ParentId": "6804044", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>A Mutex is not simply just a binary semaphore, it also has the limitation that only the locking thread is allowed to unlock it.</p>\n<p>You are breaking that rule.</p>\n<p><em>Edit:</em></p>\n<p>From <a href=\"http://msdn.microsoft.com/en-us/library/ms685066\" rel=\"noreferrer\">MSDN</a>:</p>\n<blockquote>\n<p id=\"so_6804044_6804113_0\">The ReleaseMutex function fails if the calling thread does not own the\n  mutex object.</p>\n</blockquote>\n<p>From some site that google turned up for <a href=\"https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_unlock.txt\" rel=\"noreferrer\">pthread_mutex_unlock</a>: </p>\n<blockquote>\n<p id=\"so_6804044_6804113_1\">The pthread_mutex_unlock() function may fail if:</p>\n<p id=\"so_6804044_6804113_2\">EPERM  The current thread does not own the mutex.</p>\n</blockquote>\n<p>And you will find the same on other mutex implementations. It makes sense because a mutex is supposed to guard a thread's access to a resource, so another thread should not be able to unlock it.</p>\n", "OwnerUserId": "168683", "LastEditorUserId": "168683", "LastEditDate": "2011-07-24T00:18:51.510", "Id": "6804113", "Score": "10", "CreationDate": "2011-07-24T00:10:00.947", "LastActivityDate": "2011-07-24T00:18:51.510"}, "6804044": {"CommentCount": "3", "AcceptedAnswerId": "6804113", "PostTypeId": "1", "LastEditorUserId": "28817", "CreationDate": "2011-07-23T23:51:41.770", "LastActivityDate": "2012-11-26T20:41:06.230", "LastEditDate": "2012-11-26T20:41:06.230", "ViewCount": "4746", "FavoriteCount": "5", "Title": "Use a mutex as a semaphore?", "Id": "6804044", "Score": "11", "Body": "<p>I need two threads to progress in a <em>\"tick tock\"</em> pattern.  When implmented with a semaphore this looks fine:</p>\n<pre><code>Semaphore tick_sem(1);\nSemaphore tock_sem(0);\n\nvoid ticker( void )\n{\n   while( true )\n   {\n      P( tick_sem );\n      do_tick();\n      V( tock_sem );\n   }\n}\n\nvoid tocker( void )\n{\n   while( true )\n   {\n      P( tock_sem );\n      do_tock();\n      V( tick_sem );\n   }\n}\n</code></pre>\n<p>However, if I do the same thing with a mutex ( which is technically a binary semaphore ), it has an odd code smell.</p>\n<pre><code>std::mutex tick_mutex;\nstd::mutex tock_mutex;\ntock_mutex.lock();\n\nvoid ticker( void )\n{\n   while( true )\n   {\n      tick_mutex.lock();\n      do_tick();\n      tock_mutex.unlock();\n   }\n}\n\nvoid tocker( void )\n{\n   while( true )\n   {\n      tock_mutex.lock()\n      do_tock();\n      tick_mutex.unlock();\n   }\n}\n</code></pre>\n<p>I think the smell is that a mutex isn't meant to convey information to another thread.  (The c++11 standard committee added a spurious fail to try_lock to defeat unexpected information transfer; \u00a730.4.1/14.)  It seems like mutexes are meant to synchronize access to a variable, which can then convey information to another thread.</p>\n<p>Lastly, when implemented with a <code>std::condition_variable</code>, it looks correct but it's more complicated ( a tick_vs_tock variable, a mutex, and a condition variable).  I've omitted the implementation for brevity, but it's really straight forward.</p>\n<p>Is the mutex solution fine?  Or is there something subtly wrong with it?</p>\n<p>Is there a good pattern for solving my tick/tock problem that I haven't thought of?</p>\n", "Tags": "<c++><concurrency><c++11><mutex><semaphore>", "OwnerUserId": "28817", "AnswerCount": "2"}, "6804146": {"ParentId": "6804044", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Since you have a case to use a semaphore, I think the fix is to portably <a href=\"https://stackoverflow.com/questions/4792449/c0x-has-no-semaphores-how-to-synchronize-threads\">implement one using a mutex and a condition variable</a>.</p>\n<p>This might not be especially efficient (since it'll use a mutex/condvar pair per semaphore), but you can switch in an alternate implementation on systems that have their own semaphores (such as Posix and Windows).</p>\n<p>Apparently <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2043.html#SemaphoreTypes\" rel=\"nofollow noreferrer\">semaphores are \"too error-prone\"</a>. With all due respect to Boost, I think at least some of us can manage. Certainly you can tie yourself in knots <a href=\"http://research.microsoft.com/pubs/64242/ImplementingCVs.pdf\" rel=\"nofollow noreferrer\">trying to do complicated things with multiple semaphores</a>, and they are a pretty low-level tool. But when they're the right thing, no problem.</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:22:53.710", "Id": "6804146", "Score": "9", "CreationDate": "2011-07-24T00:15:54.510", "LastActivityDate": "2011-07-24T00:28:47.707"}, "bq_ids": {"n4140": {"so_6804044_6804113_2": {"section_id": 2754, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_6804044_6804113_2": {"section_id": 2715, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_6804044_6804113_2": {"section_id": 3492, "quality": 0.5714285714285714, "length": 4}}}});