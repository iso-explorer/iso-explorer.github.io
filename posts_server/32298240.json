post_cb({"bq_ids": {"n4140": {"so_32298240_32298411_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 1862}, "so_32298240_32298449_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 1861}, "so_32298240_32298449_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 1861}, "so_32298240_32298411_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 2232}, "so_32298240_32298449_2": {"length": 7, "quality": 0.5384615384615384, "section_id": 1855}, "so_32298240_32298411_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 1861}}, "n3337": {"so_32298240_32298411_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 1856}, "so_32298240_32298449_2": {"length": 7, "quality": 0.5384615384615384, "section_id": 1849}, "so_32298240_32298449_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 1855}, "so_32298240_32298411_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 2220}, "so_32298240_32298411_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 1855}, "so_32298240_32298449_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 1855}}, "n4659": {"so_32298240_32298411_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 2034}, "so_32298240_32298411_5": {"length": 5, "quality": 0.625, "section_id": 802}, "so_32298240_32298449_2": {"length": 7, "quality": 0.5384615384615384, "section_id": 2028}, "so_32298240_32298449_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 2033}, "so_32298240_32298411_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 2505}, "so_32298240_32298411_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 2033}, "so_32298240_32298449_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 2033}}}, "32298411": {"Id": "32298411", "PostTypeId": "2", "Body": "<p>The behavior of <code>getline</code> is explicitly documented in the standard (C++11 \u00a721.4.8.9 \u00b67-10), which is the only normative document about C++.</p>\n<p>The behavior your asked about in the first two questions is guaranteed, while the third one is a consequence of how your test rig is made.</p>\n<blockquote>\n<pre><code>template&lt;class charT, class traits, class Allocator&gt;\n  basic_istream&lt;charT,traits&gt;&amp;\n    getline(basic_istream&lt;charT,traits&gt;&amp; is,\n            basic_string&lt;charT,traits,Allocator&gt;&amp; str,\n            charT delim);\ntemplate&lt;class charT, class traits, class Allocator&gt;\n   basic_istream&lt;charT,traits&gt;&amp;\n   getline(basic_istream&lt;charT,traits&gt;&amp;&amp; is,\n           basic_string&lt;charT,traits,Allocator&gt;&amp; str,\n           charT delim);\n</code></pre>\n<p id=\"so_32298240_32298411_0\"><em>Effects:</em> Behaves as an unformatted input function (27.7.2.3), except that it does not affect the value\n  returned by subsequent calls to <code>basic_istream&lt;&gt;::gcount()</code>. After constructing a <code>sentry</code> object,\n  if the <code>sentry</code> converts to <code>true</code>, calls <code>str.erase()</code> and then extracts characters from <code>is</code> and appends\n  them to <code>str</code> as if by calling <code>str.append(1, c)</code> until any of the following occurs:</p>\n<ul>\n<li>end-of-file occurs on the input sequence (in which case, the <code>getline</code> function calls <code>is.setstate(ios_base::eofbit)</code>).</li>\n<li><code>traits::eq(c, delim)</code> for the next available input character <code>c</code> (in which case, <code>c</code> is extracted but\n  not appended) (27.5.5.4)</li>\n<li><code>str.max_size()</code> characters are stored (in which case, the function calls <code>is.setstate(ios_base::failbit</code>)) (27.5.5.4)</li>\n</ul>\n<p id=\"so_32298240_32298411_1\">The conditions are tested in the order shown. In any case, after the last character is extracted, the\n  sentry object <code>k</code> is destroyed.</p>\n<p id=\"so_32298240_32298411_2\">If the function extracts no characters, it calls <code>is.setstate(ios_base::failbit)</code> which may throw\n  <code>ios_base::failure</code> (27.5.5.4).</p>\n<p id=\"so_32298240_32298411_3\"><em>Returns:</em> <code>is</code>.</p>\n</blockquote>\n<p>Coming to your questions:</p>\n<blockquote>\n<p id=\"so_32298240_32298411_4\">delimiter is not found =&gt; then simply whole string/rest of it is returned</p>\n</blockquote>\n<p>That's a consequence of the first exit condition - when the input string terminates the string stream goes in end-of-file, so the extraction terminates (after having added all the preceding characters to the output string).</p>\n<blockquote>\n<p id=\"so_32298240_32298411_5\">there is delimiter but nothing before it =&gt; empty string is returned </p>\n</blockquote>\n<p>That's just a special case of the second point - the extraction terminates when the delimiter is found (<code>traits::eq(c, delim)</code> normally boils down to <code>c==delim</code>), even if no other character has been extracted before.</p>\n<blockquote>\n<p id=\"so_32298240_32298411_6\">getting something that isn't really there =&gt; returns the last thing that could be read with it</p>\n</blockquote>\n<p>It doesn't go exactly like this. If the stream is in an error condition (the <code>sentry</code> object does not convert to <code>true</code>, in the description above) - in your case you have an EOF -, <code>getline</code> leaves your string alone and returns. In your test code you see the last read data just because you are recycling the same string without clearing it between the various tests.</p>\n", "LastEditorUserId": "214671", "LastActivityDate": "2015-08-30T15:59:56.167", "Score": "2", "CreationDate": "2015-08-30T15:54:06.857", "ParentId": "32298240", "CommentCount": "3", "OwnerUserId": "214671", "LastEditDate": "2015-08-30T15:59:56.167"}, "32298240": {"ViewCount": "198", "Body": "<p>In C++ when you use <code>getline()</code> with delimiter on stringstream there are few things that I didn't found documented, but they have some non-error handy behaviour when:</p>\n<ul>\n<li>delimiter is not found =&gt; then simply whole string/rest of it is returned</li>\n<li>there is delimiter but nothing before it =&gt; empty string is returned </li>\n<li>getting something that isn't really there =&gt; returns the last thing that could be read with it</li>\n</ul>\n<p>Some test code (simplified):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\nusing namespace std;\n\nstring test(const string &amp;s, char delim, int parseIndex ){\n    stringstream ss(s);\n    string parsedStr = \"\";\n\n    for( int i = 0; i &lt; (parseIndex+1); i++ ) getline(ss, parsedStr, delim);\n\n    return parsedStr;\n}\n\nint main() {\n    stringstream ss(\"something without delimiter\");\n    string s1;\n    getline(ss,s1,';');\n    cout &lt;&lt; \"'\" &lt;&lt; s1  &lt;&lt; \"'\" &lt;&lt; endl; //no delim\n    cout &lt;&lt; endl;\n\n    string s2 = \"321;;123\";\n    cout &lt;&lt; \"'\" &lt;&lt; test(s2,';',0) &lt;&lt; \"'\" &lt;&lt; endl; //classic\n    cout &lt;&lt; \"'\" &lt;&lt; test(s2,';',1) &lt;&lt; \"'\" &lt;&lt; endl; //nothing before\n    cout &lt;&lt; \"'\" &lt;&lt; test(s2,';',2) &lt;&lt; \"'\" &lt;&lt; endl; //no delim at the end\n    cout &lt;&lt; \"'\" &lt;&lt; test(s2,';',3) &lt;&lt; \"'\" &lt;&lt; endl; //this shouldn't be there\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>Test code output:</p>\n<pre><code>'something without delimiter'\n\n'321'\n''\n'123'\n'123'\n</code></pre>\n<p>Test code fiddle: <a href=\"http://ideone.com/ZAuydR\" rel=\"nofollow\">http://ideone.com/ZAuydR</a></p>\n<h1>The Question</h1>\n<p>The question is - can this be relied on? If so, where is it documented - is it?</p>\n<p>Thanks for answers and clarifying :)</p>\n", "AcceptedAnswerId": "32298449", "Title": "C++ getline()'s undocumented behavior", "CreationDate": "2015-08-30T15:35:51.607", "Id": "32298240", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-08-30T15:59:56.167", "Score": "1", "OwnerUserId": "1835470", "Tags": "<c++><stream><getline><stringstream><istringstream>", "AnswerCount": "2"}, "32298449": {"Id": "32298449", "PostTypeId": "2", "Body": "<p>The behavior of C++ facilities is described by the ISO C++ standard. But, it's not the most readable resource. In this case, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/getline\" rel=\"nofollow\">cppreference.com</a> has good coverage.</p>\n<p>Here's what they have to say. The quote blocks are copy-pasted; I've interspersed explanations to your questions.</p>\n<blockquote>\n<p id=\"so_32298240_32298449_0\">Behaves as <code>UnformattedInputFunction</code>, except that <code>input.gcount()</code> is not affected. After constructing and checking the sentry object, performs the following:</p>\n</blockquote>\n<p>\"Constructing and checking the sentry\" means that if an error condition has been detected on the stream, the function will return without doing anything. This is why in #3 you observe the last valid input when \"nothing should be there.\"</p>\n<blockquote>\n<p id=\"so_32298240_32298449_1\">1) Calls str.erase()</p>\n</blockquote>\n<p>So, if nothing is subsequently found before the delimiter, you'll get an empty string.</p>\n<blockquote>\n<p id=\"so_32298240_32298449_2\">2) Extracts characters from input and appends them to str until one of the following occurs (checked in the order listed)</p>\n<p id=\"so_32298240_32298449_3\">a) end-of-file condition on input, in which case, getline sets <code>eofbit</code>.</p>\n</blockquote>\n<p>This is an error condition which causes the <code>string</code> local variable to be unchanged by subsequent <code>getline</code>s.</p>\n<p>It also allows you to observe the last segment of input before the end, so you may treat the end-of-file as a delimiter if you wish.</p>\n<blockquote>\n<p id=\"so_32298240_32298449_4\">b) the next available input character is delim, as tested by <code>Traits::eq(c, delim)</code>, in which case the delimiter character is extracted from input, but is not appended to str.</p>\n<p id=\"so_32298240_32298449_5\">c) str.max_size() characters have been stored, in which case getline sets failbit and returns.</p>\n<p id=\"so_32298240_32298449_6\">3) If no characters were extracted for whatever reason (not even the discarded delimiter), getline sets <code>failbit</code> and returns.</p>\n</blockquote>\n", "LastActivityDate": "2015-08-30T15:57:34.790", "CommentCount": "0", "CreationDate": "2015-08-30T15:57:34.790", "ParentId": "32298240", "Score": "1", "OwnerUserId": "153285"}});