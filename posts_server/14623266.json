post_cb({"14623266": {"CommentCount": "2", "CreationDate": "2013-01-31T10:13:50.900", "PostTypeId": "1", "AcceptedAnswerId": "14623406", "LastEditorUserId": "634821", "LastActivityDate": "2013-01-31T11:15:44.467", "LastEditDate": "2013-01-31T11:15:44.467", "ViewCount": "8374", "FavoriteCount": "1", "Title": "Why can't I reinterpret_cast uint to int?", "Id": "14623266", "Score": "6", "Body": "<p>Here's what I want to do:</p>\n<p><code>const int64_t randomIntNumber = reinterpret_cast&lt;int64_t&gt; (randomUintNumber);</code></p>\n<p>Where randomUintNumber is of type <code>uint64_t</code>.</p>\n<p>The error is (MSVC 2010): </p>\n<blockquote>\n<p id=\"so_14623266_14623266_0\">error C2440: 'reinterpret_cast' : cannot convert from 'const uint64_t'\n  to 'int64_t' 1&gt;          Conversion is a valid standard conversion,\n  which can be performed implicitly or by use of static_cast, C-style\n  cast or function-style cast</p>\n</blockquote>\n<p>Why doesn't it compile? both types have the same bit length, isn't it what reinterpret_cast is intended for?</p>\n", "Tags": "<c++><type-conversion><reinterpret-cast>", "OwnerUserId": "634821", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_14623266_14623461_0": {"section_id": 6040, "quality": 1.0, "length": 15}, "so_14623266_14623381_0": {"section_id": 6040, "quality": 1.0, "length": 7}, "so_14623266_14623433_1": {"section_id": 6169, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_14623266_14623461_0": {"section_id": 5808, "quality": 1.0, "length": 15}, "so_14623266_14623381_0": {"section_id": 5808, "quality": 1.0, "length": 7}, "so_14623266_14623433_1": {"section_id": 5930, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_14623266_14623461_0": {"section_id": 7539, "quality": 1.0, "length": 15}, "so_14623266_14623381_0": {"section_id": 7539, "quality": 1.0, "length": 7}, "so_14623266_14623433_1": {"section_id": 8719, "quality": 0.6666666666666666, "length": 4}}}, "14623488": {"ParentId": "14623266", "CommentCount": "1", "Body": "<p><code>reinterpret_cast</code> is used for reinterpreting the storage of the object as a different object. If you don't want to go through standard wording, you can find all that <code>reinterpret_cast</code> can do <a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast\" rel=\"nofollow\">here</a>. Generally you can remember you have to work with pointer types.</p>\n<p>So, if you really want to reinterpret the bits used for your <code>uint64_t</code> as <code>int64_t</code>, then do this:</p>\n<pre><code>int64_t randomIntNumber = reinterpret_cast&lt;int64_t&amp;&gt; (randomUintNumber);\n</code></pre>\n<p>However if you just want to convert the object, preserving its value if possible ... just do what the compiler suggests and use <code>static_cast</code> instead.</p>\n", "OwnerUserId": "546632", "PostTypeId": "2", "Id": "14623488", "Score": "1", "CreationDate": "2013-01-31T10:25:13.893", "LastActivityDate": "2013-01-31T10:25:13.893"}, "14623294": {"ParentId": "14623266", "CommentCount": "0", "Body": "<p>Use <code>static_cast</code> in these cases.  I suppose the language designers in all their wisdom decided that it's not considered \"unsafe enough\" to warrant a <code>reinterpret_cast</code>.</p>\n", "OwnerUserId": "2015270", "PostTypeId": "2", "Id": "14623294", "Score": "2", "CreationDate": "2013-01-31T10:14:56.973", "LastActivityDate": "2013-01-31T10:14:56.973"}, "14623461": {"ParentId": "14623266", "CommentCount": "0", "Body": "<p>From C++11 Standard(N3376) 5.2.10.1:</p>\n<blockquote>\n<p id=\"so_14623266_14623461_0\">Conversions that can be performed explicitly using reinterpret_cast are listed below. No\n  other conversion can be performed explicitly using reinterpret_cast.</p>\n</blockquote>\n<p>The only conversion from integral type to integral type allowed is infact if the types are identical.</p>\n<p>Others involve pointers.</p>\n", "OwnerUserId": "1520364", "PostTypeId": "2", "Id": "14623461", "Score": "1", "CreationDate": "2013-01-31T10:23:14.307", "LastActivityDate": "2013-01-31T10:23:14.307"}, "14623406": {"ParentId": "14623266", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Because that's not what <code>reinterpret_cast</code> is for. All the permitted conversions with <code>reinterpret_cast</code> involve pointers or references, with the exception that an integer or enum type can be <code>reinterpret_cast</code> to itself. This is all defined in the standard, <code>[expr.reinterpret.cast]</code>.</p>\n<p>I'm not certain what you're trying to achieve here, but if you want <code>randomIntNumber</code> to have the same value as <code>randomUintNumber</code>, then do</p>\n<pre><code>const int64_t randomIntNumber = randomUintNumber;\n</code></pre>\n<p>If that results in a compiler warning, or if you just want to be more explicit, then:</p>\n<pre><code>const int64_t randomIntNumber = static_cast&lt;int64_t&gt;(randomUintNumber);\n</code></pre>\n<p>The result of the cast has the same value as the input if <code>randomUintNumber</code> is less than 2<sup>63</sup>. Otherwise the result is implementation-defined, but I expect all known implementations that have <code>int64_t</code> will define it to do the obvious thing: the result is equivalent to the input modulo 2<sup>64</sup>.</p>\n<hr/>\n<p>If you want <code>randomIntNumber</code> to have the same bit-pattern as <code>randomUintNumber</code>, then you can do this:</p>\n<pre><code>int64_t tmp;\nstd::memcpy(&amp;tmp, &amp;randomUintNumber, sizeof(tmp));\nconst int64_t randomIntNumber = tmp;\n</code></pre>\n<p>Since <code>int64_t</code> is guaranteed to use two's complement representation, you would <em>hope</em> that the implementation defines <code>static_cast</code> to have the same result as this for out-of-range values of <code>uint64_t</code>. But it's not actually guaranteed in the standard AFAIK.</p>\n<p>Even if <code>randomUintNumber</code> is a compile-time constant, unfortunately here <code>randomIntNumber</code> is <em>not</em> a compile-time constant. But then, how \"random\" is a compile-time constant? ;-)</p>\n<p>If you need to work around that, and you don't trust the implementation to be sensible about converting out-of-range unsigned values to signed types, then something like this:</p>\n<pre><code>const int64_t randomIntNumber = \n    randomUintNumber &lt;= INT64_MAX ? \n        (int64_t) randomUintNumber :\n        (int64_t) (randomUintNumber - INT64_MAX - 1) + INT64_MIN;\n</code></pre>\n<p>Now, I'm in favour of writing truly portable code where possible, but even so I think this verges on paranoia.</p>\n<hr/>\n<p>Btw, you might be tempted to write this:</p>\n<pre><code>const int64_t randomIntNumber = reinterpret_cast&lt;int64_t&amp;&gt;(randomUintNumber);\n</code></pre>\n<p>or equivalently:</p>\n<pre><code>const int64_t randomIntNumber = *reinterpret_cast&lt;int64_t*&gt;(&amp;randomUintNumber);\n</code></pre>\n<p>This isn't quite guaranteed to work, because although where they exist <code>int64_t</code> and <code>uint64_t</code> are guaranteed to be a signed type and an unsigned type of the same size, they aren't actually guaranteed to be the signed and unsigned versions of a standard integer type. So it is implementation-specific whether or not this code violates strict aliasing. Code that violates strict aliasing has undefined behavior. The following does <em>not</em> violate strict aliasing, and is OK provided that the bit pattern in <code>randomUintNumber</code> is a valid representation of a value of <code>long long</code>:</p>\n<pre><code>unsigned long long x = 0;\nconst long long y = reinterpret_cast&lt;long long &amp;&gt;(x);\n</code></pre>\n<p>So on implementations where <code>int64_t</code> and <code>uint64_t</code> are typedefs for <code>long long</code> and <code>unsigned long long</code>, then my <code>reinterpret_cast</code> is OK. And as with the implementation-defined conversion of out-of-range values to signed types, you would <em>expect</em> that the sensible thing for implementations to do is to make them corresponding signed/unsigned types. So like the <code>static_cast</code> and the implicit conversion, you expect it to work in any sensible implementation but it is not actually guaranteed.</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2013-01-31T11:09:25.393", "Id": "14623406", "Score": "19", "CreationDate": "2013-01-31T10:20:29.470", "LastActivityDate": "2013-01-31T11:09:25.393"}, "14623433": {"ParentId": "14623266", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_14623266_14623433_0\">Why doesn't it compile?</p>\n</blockquote>\n<p>Because neither type is a pointer.</p>\n<blockquote>\n<p id=\"so_14623266_14623433_1\">both types have the same bit length,</p>\n</blockquote>\n<p>Why would that matter? If they were pointers, maybe it would matter that they pointed to things of the same size, but they're not pointers.</p>\n<blockquote>\n<p id=\"so_14623266_14623433_2\">isn't it what reinterpret_cast is intended for?</p>\n</blockquote>\n<p>No, <code>reinterpret_cast</code> is for pointer casts. You could do what you want by putting an <code>&amp;</code> inside the cast and a <code>*</code> outside it. That's what reinterpret cast is for.</p>\n", "OwnerUserId": "721269", "PostTypeId": "2", "Id": "14623433", "Score": "0", "CreationDate": "2013-01-31T10:21:32.130", "LastActivityDate": "2013-01-31T10:21:32.130"}, "14623381": {"ParentId": "14623266", "CommentCount": "4", "Body": "<p>No, it is not. <code>reinterpret_cast</code> is mostly intended to reinterpret an existing bit of storage as a different type than it is. A lot of these interpretations is implementation dependent, and the standard lists a specific (rather long to quote here) list of things that can be done with a <code>reinterpret_cast</code> (mostly casting between different pointer/reference types), but says:</p>\n<blockquote>\n<p id=\"so_14623266_14623381_0\">No other conversion can be performed explicitly using\n  reinterpret_cast.</p>\n</blockquote>\n<p>In your case, you probably want a conversion of types, not a reinterpretation of existing storage. Use <code>static_cast</code> for this purpose.</p>\n", "OwnerUserId": "833362", "PostTypeId": "2", "Id": "14623381", "Score": "3", "CreationDate": "2013-01-31T10:19:07.093", "LastActivityDate": "2013-01-31T10:19:07.093"}});