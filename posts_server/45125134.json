post_cb({"bq_ids": {"n4140": {"so_45125134_45125235_1": {"length": 54, "quality": 0.9642857142857143, "section_id": 986}}, "n3337": {"so_45125134_45125235_1": {"length": 42, "quality": 0.75, "section_id": 971}}, "n4659": {"so_45125134_45125235_1": {"length": 54, "quality": 0.9642857142857143, "section_id": 1049}}}, "45125134": {"ViewCount": "257", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/container/vector/emplace\" rel=\"noreferrer\">According to cppreference.com</a>, std::vector::emplace() offers the strong exception guarantee unconditionally:</p>\n<blockquote>\n<p id=\"so_45125134_45125134_0\">If an exception is thrown (e.g. by the constructor), the container is left unmodified, as if this function was never called (strong exception guarantee).</p>\n</blockquote>\n<p>However, this doesn't seem to be the case in practice with GCC 7.1.1.  The following program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstruct ugly\n{\n  int i;\n\n  ugly(int i) : i{i} { }\n\n  ugly(const ugly&amp; other) = default;\n\n  ugly&amp; operator=(ugly&amp;&amp; other) {\n    if (other.i == 3) {\n      throw other.i;\n    }\n    i = other.i;\n    return *this;\n  }\n\n  ugly&amp; operator=(const ugly&amp; other) = default;\n};\n\nint main() {\n  std::vector&lt;ugly&gt; vec;\n  vec.reserve(6);\n  vec.emplace_back(0);\n  vec.emplace_back(1);\n  vec.emplace_back(2);\n  vec.emplace_back(4);\n  vec.emplace_back(5);\n\n  try {\n    vec.emplace(vec.begin() + 3, 3);\n  } catch (int i) {\n  }\n\n  for (const auto&amp; u : vec) {\n    std::cout &lt;&lt; u.i &lt;&lt; \"\\n\";\n  }\n\n  return 0;\n}\n</code></pre>\n<p>prints</p>\n<blockquote id=\"so_45125134_45125134_1\">\n<pre><code>0\n1\n2\n4\n4\n5\n</code></pre>\n</blockquote>\n<p>In fact, I have a hard time seeing how emplace() could possibly provide the strong guarantee if copying/moving is allowed to throw.  To emplace in the middle, we have to move a bunch of elements out of the way first, then construct the new element in its place.  If any of that throws, we'd have to move all the other elements back where they were, but those moves can throw too!</p>\n<p>So who's wrong, cppreference or gcc?</p>\n", "AcceptedAnswerId": "45125235", "Title": "Does std::vector::emplace() really offer the strong exception guarantee in the face of a throwing move constructor/assignment operator?", "CreationDate": "2017-07-16T04:53:41.620", "Id": "45125134", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-07-16T05:09:54.223", "Score": "6", "OwnerUserId": "502399", "Tags": "<c++><c++11><vector><libstdc++>", "AnswerCount": "1"}, "45125235": {"Id": "45125235", "PostTypeId": "2", "Body": "<p>According to the <code>C++14</code> standard the strong exception guarantee only holds if the type you insert itself has a strong exception guarantee.</p>\n<p>Here:</p>\n<blockquote>\n<p id=\"so_45125134_45125235_0\"><strong>23.3.6.5</strong> vector modifiers <strong>[</strong> vector.modifiers <strong>]</strong></p>\n<pre><code>iterator insert(const_iterator position, const T&amp; x);\niterator insert(const_iterator position, T&amp;&amp; x);\niterator insert(const_iterator position, size_type n, const T&amp; x);\ntemplate &lt;class InputIterator&gt;\niterator insert(const_iterator position, InputIterator first, InputIterator last);\niterator insert(const_iterator position, initializer_list&lt;T&gt;);\ntemplate &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args);\ntemplate &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);\nvoid push_back(const T&amp; x);\nvoid push_back(T&amp;&amp; x);\n</code></pre>\n<p id=\"so_45125134_45125235_1\"><strong>1</strong> <em>Remarks:</em> Causes reallocation if the new size is greater than the old capacity. If no reallocation happens, all the iterators and references before the insertion point remain valid. If an exception is thrown <strong>other than by the copy constructor, move constructor, assignment operator, or move assignment operator of T or by any InputIterator operation</strong> there are no effects. If an exception is thrown while inserting a single element at the end and T is CopyInsertable or is_nothrow_move_constructible::value is true, there are no effects. Otherwise, if an exception is thrown by the move constructor of a non-CopyInsertable T, the effects are unspecified.</p>\n</blockquote>\n<p>So it looks like <a href=\"http://en.cppreference.com/w/\" rel=\"noreferrer\">cppreference.com</a> is wrong.</p>\n", "LastActivityDate": "2017-07-16T05:09:54.223", "CommentCount": "3", "CreationDate": "2017-07-16T05:09:54.223", "ParentId": "45125134", "Score": "6", "OwnerUserId": "3807729"}});