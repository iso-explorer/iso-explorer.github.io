post_cb({"bq_ids": {"n4140": {"so_40193008_40193715_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 3321}, "so_40193008_40193715_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 3321}, "so_40193008_40193546_0": {"length": 24, "quality": 0.96, "section_id": 3321}, "so_40193008_40193715_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 3321}}, "n3337": {"so_40193008_40193715_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 3191}, "so_40193008_40193715_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 3191}, "so_40193008_40193546_0": {"length": 24, "quality": 0.96, "section_id": 3191}, "so_40193008_40193715_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 3191}}, "n4659": {"so_40193008_40193715_2": {"length": 12, "quality": 1.0, "section_id": 4087}, "so_40193008_40193715_1": {"length": 12, "quality": 1.0, "section_id": 4087}, "so_40193008_40193546_0": {"length": 25, "quality": 1.0, "section_id": 4087}, "so_40193008_40193715_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 4087}}}, "40193715": {"Id": "40193715", "PostTypeId": "2", "Body": "<p>The correct question should sound as \"<strong>Why a const volatile reference cannot be bound to an rvalue</strong>?\"</p>\n<p>The following code doesn't compile either, although no rvalue references are directly involved:</p>\n<pre><code>const volatile int&amp; cvr = 0;\n</code></pre>\n<p><a href=\"https://stackoverflow.com/a/28048551/6394138\">This answer</a> to a related question cites the relevant section of the standard:</p>\n<blockquote>\n<p id=\"so_40193008_40193715_0\">Per <strong>[dcl.init.ref]</strong>/5, for a reference to be initialized by binding to an rvalue, the reference must be a <code>const</code> non-<code>volatile</code> lvalue reference, or an rvalue reference:</p>\n<blockquote>\n<p id=\"so_40193008_40193715_2\">\u2014 Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e., <em>cv1</em> shall be <code>const</code>), or the reference shall be an rvalue reference.</p>\n</blockquote>\n</blockquote>\n<p>My guess is that this restriction has historical roots in the C++98 standard where rvalues were limited to temporaries, that were fully managed by the compiler. The compiler can place the temporary at any address or register of its choice, and treating it as a volatile object with observable reads doesn't make sense. In the new standard an lvalue reference can be converted to an rvalue reference with <code>std::move()</code>, however as a result it gets the old properties assumed for rvalues, i.e. that their exact memory address is insignificant, and thus cannot have the volatile attribute assigned to it.</p>\n<p>Technically this restriction is not a very limiting one, since you can effectively bind a <code>const volatile</code> reference to an rvalue through an extra level of indirection:</p>\n<pre><code>// This doesn't compile\n// const volatile int&amp; cvr = 0;\n\n// This does compile\nconst int&amp; cr = 0;\nconst volatile int&amp; cvr = cr;\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-10-22T17:24:04.397", "Score": "7", "CreationDate": "2016-10-22T15:16:05.150", "ParentId": "40193008", "CommentCount": "3", "LastEditDate": "2017-05-23T12:00:37.957", "OwnerUserId": "6394138"}, "40193546": {"Id": "40193546", "PostTypeId": "2", "Body": "<p>The literal reason is that [dcl.init.ref] forbids such a declaration:</p>\n<blockquote>\n<p id=\"so_40193008_40193546_0\">A reference to type \u201ccv1 T1\u201d is initialized by an expression of type \u201ccv2 T2\u201d as follows:<br>\n  - If the reference is an lvalue reference and the initializer expression [...]<br>\n  - Otherwise, the reference <strong>shall be an lvalue reference to a non-volatile const type</strong> (i.e., cv1 shall be const), or the reference shall be an rvalue reference. </br></br></p>\n</blockquote>\n<p>The next level reason is just a guess (and a problem with asking why questions): such a declaration makes no sense. The purpose of <code>volatile</code> is to make all reads and writes observable behavior. If you're initializing a reference to <code>const volatile</code> from a temporary, you're now the owner of the lifetime of this object. But you can't write to it. And neither can anyone else. So what does <code>volatile</code> convey?</p>\n", "LastActivityDate": "2016-10-22T14:56:21.217", "CommentCount": "19", "CreationDate": "2016-10-22T14:56:21.217", "ParentId": "40193008", "Score": "4", "OwnerUserId": "2069064"}, "40193008": {"ViewCount": "280", "Body": "<p>I would like to understand why a const volatile reference cannot be bound to an rvalue reference?\nWhat is the rational reason to prohibit such a conversion?</p>\n<p>In the following code I comment out lines that do not compile:</p>\n<pre><code>int main(){\n int i=1;\n //const volatile int&amp; cvi2=std::move(i); -&gt; ERROR: why?\n const volatile int i2=0;\n //const volatile int&amp; cvi3=std::move(i2);// -&gt; ERROR: why?\n}\n</code></pre>\n<p>Here a more realistic scenario, that fails to compile for a similar reason:</p>\n<pre><code>#include&lt;iostream&gt;\ntemplate&lt;class T&gt; void g(const T&amp; b){\n  //do usefull things\n}\ntemplate&lt;class T,class F&gt; void f(T&amp; a,F a_func){\n  //do usefull things with a\n  a_func(std::move(a));\n}\nint main(){\n   int i=0;\n   volatile int vi=1;\n   f(i,g&lt;int&gt;); //OK no error;\n   f(vi,g&lt;volatile int&gt;);//ERROR: can not convert volatile int to\n                                 //const volatile int &amp;\n }\n</code></pre>\n<p>In this code, I would have expected that <code>g&lt;volatile int&gt;(const volatile&amp;)</code> accept any argument.</p>\n<p>An other edit, for a more concret example:</p>\n<pre><code>#include &lt;vector&gt;\nusing usefull_type=int;\nvoid set_communication_channel_to(volatile usefull_type* g,size_t n);\nint main(){\n  auto vect=\n    std::vector&lt;volatile usefull_type&gt;(10,usefull_type{42});//-&gt;ERROR no known conversion\n                                                      // from int to const volatile int &amp;\n  set_communication_channel_to(vect.data(),vect.size());\n  //... \n  //...\n }\n</code></pre>\n<p>There must have a good reason for this limitation no?</p>\n", "AcceptedAnswerId": "40193715", "Title": "Why a const volatile reference cannot be bound to an rvalue reference?", "CreationDate": "2016-10-22T13:57:29.497", "Id": "40193008", "CommentCount": "13", "LastEditDate": "2016-10-23T08:50:58.847", "PostTypeId": "1", "LastEditorUserId": "5632316", "LastActivityDate": "2016-10-23T08:50:58.847", "Score": "9", "OwnerUserId": "5632316", "Tags": "<c++><c++11>", "AnswerCount": "2"}});