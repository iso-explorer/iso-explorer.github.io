post_cb({"41981075": {"ParentId": "41978949", "CommentCount": "1", "Body": "<p>I don't understand your confusion. The innermost enclosing namespace scope is that of the <a href=\"http://eel.is/c++draft/basic.scope.namespace#3\" rel=\"nofollow noreferrer\">global namespace</a>; the first and second declarations match in type and name, and hence the outer block-scope declaration just inherits the global declaration's linkage (which is internal due to the <code>static</code> specifier). The second block-scope declaration is associated with the first one; you get the idea.</p>\n", "OwnerUserId": "3647361", "PostTypeId": "2", "Id": "41981075", "Score": "0", "CreationDate": "2017-02-01T13:31:22.183", "LastActivityDate": "2017-02-01T13:31:22.183"}, "41978949": {"CommentCount": "8", "ViewCount": "152", "PostTypeId": "1", "LastEditorUserId": "4884487", "CreationDate": "2017-02-01T11:42:53.513", "LastActivityDate": "2017-02-08T12:50:46.043", "Title": "Linkage of function declared as `extern` in block scope according to the C++17 standard draft", "LastEditDate": "2017-02-08T12:50:46.043", "Id": "41978949", "Score": "3", "Body": "<p>From the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">C++17 Standard Draft</a> <code>\u00a7 3.5.6</code>: </p>\n<blockquote>\n<p id=\"so_41978949_41978949_0\">The name of a function declared in block scope and the name of a variable declared by a block scope extern\n  declaration have linkage. <em>If there is a visible declaration of an entity with linkage having the same name and\n  type</em>, ignoring entities declared outside the innermost enclosing namespace scope, <em>the block scope declaration\n  declares that same entity and receives the linkage of the previous declaration. If there is more than one such\n  matching entity, the program is ill-formed</em>. Otherwise, if no matching entity is found, the block scope entity\n  receives external linkage</p>\n</blockquote>\n<p>Additionally there is an example provided in the standard: </p>\n<pre><code>static void f();\nstatic int i = 0;              // #1\nvoid g() {\n    extern void f();          // internal linkage\n    int i;                    // #2 i has no linkage\n    {\n        extern void f();      // internal linkage\n        extern int i;         // #3 external linkage\n    }\n}\n</code></pre>\n<p>Does the third function declaration <code>extern void f()</code> receives:  </p>\n<ul>\n<li><code>external</code> linkage ( due to the preceding <code>extern void f()</code> declaration )</li>\n<li><code>internal</code> linkage ( since the second declaration of <code>f()</code> in the block scope above receives internal linkage from the declaration of <code>f()</code>in the <code>::</code> global namespace )</li>\n<li>Or is it ill-formed because there are more \" more than one such matching\nentity\" ?</li>\n</ul>\n<hr>\n<p><strong>EDIT</strong> </p>\n<p><strong>main.cpp</strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nextern void g();\nvoid f() { std::cout &lt;&lt; \"main f() called\" &lt;&lt; std::endl; }\n\nint main(){\n    g(); \n    return 0; \n}  \n</code></pre>\n<p><strong>test.cpp</strong>: </p>\n<pre><code>#include &lt;iostream&gt;\n\nstatic void f() { std::cout &lt;&lt; \" test f() called\" &lt;&lt; std::endl; }\nvoid g() {\n    extern void f(); \n    {\n        extern void f(); \n        f(); \n    }\n}\n</code></pre>\n<p><code>g()</code> is called in the <code>main()</code> function in <code>main.cpp</code>.<br>\nCompiled with <code>gcc 5.4.0</code></br></p>\n<blockquote>\n<p id=\"so_41978949_41978949_1\">g++ -std=c++14 -Wall main.cpp test.cpp </p>\n</blockquote>\n<p>Prints: </p>\n<blockquote>\n<p id=\"so_41978949_41978949_2\">main f() called</p>\n</blockquote>\n<p>Thus, gcc obviously treats the call of <code>f()</code> from within <code>g()</code> with <code>external</code> linkage ( calling the definition provided in the <code>main.cpp</code> file ). Either the comment in the example from the standard is wrong ( the function declaration of <code>#3</code> has not interal linkage ) or its a compiler bug from <code>gcc</code>.</p>\n</hr>", "Tags": "<c++><language-lawyer><iso><c++1z><linkage>", "OwnerUserId": "4884487", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_41978949_41978949_0": {"section_id": 7139, "quality": 0.9833333333333333, "length": 59}}, "n3337": {"so_41978949_41978949_0": {"section_id": 6883, "quality": 0.9833333333333333, "length": 59}}, "n4659": {"so_41978949_41978949_0": {"section_id": 8640, "quality": 0.9833333333333333, "length": 59}}}});