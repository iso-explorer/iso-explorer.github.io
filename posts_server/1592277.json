post_cb({"1592292": {"ParentId": "1592277", "CommentCount": "0", "Body": "<p>You can safely convert an <code>unsigned char*</code> to a <code>char *</code> as the function you are calling will be expecting the behavior from a char pointer, but, if your char value goes over 127 then you will get a result that will not be what you expected, so just make certain that what you have in your unsigned array is valid for a signed array.</p>\n", "OwnerUserId": "67566", "PostTypeId": "2", "Id": "1592292", "Score": "0", "CreationDate": "2009-10-20T03:28:57.040", "LastActivityDate": "2009-10-20T03:28:57.040"}, "1592296": {"ParentId": "1592277", "CommentCount": "0", "Body": "<p>Safe if you are dealing with only ASCII data.</p>\n", "OwnerUserId": "182285", "PostTypeId": "2", "Id": "1592296", "Score": "0", "CreationDate": "2009-10-20T03:30:14.873", "LastActivityDate": "2009-10-20T03:30:14.873"}, "1592372": {"ParentId": "1592277", "CommentCount": "0", "Body": "<p>Casting changes the type, but does not affect the bit representation. Casting from unsigned char to signed char does not change the value at all, but it affects the meaning of the value.</p>\n<p>Here is an example:</p>\n<pre><code>#include &lt;stdio.h&gt;\nint main(int args, char** argv) {\n\n  /* example 1 */\n  unsigned char a_unsigned_char = 192;\n  signed char b_signed_char = b_unsigned_char;\n  printf(\"%d, %d\\n\", a_signed_char, a_unsigned_char); //192, -64\n\n  /* example 2 */\n  unsigned char b_unsigned_char = 32; \n  signed char a_signed_char = a_unsigned_char;\n  printf(\"%d, %d\\n\", b_signed_char, b_unsigned_char); //32, 32\n\n  return 0;\n}\n</code></pre>\n<p>In the first example, you have an unsigned char with value 192, or 110000000 in binary. After the cast to signed char, the value is still 110000000, but that happens to be the <a href=\"http://en.wikipedia.org/wiki/Two's_complement\" rel=\"nofollow noreferrer\">2s-complement</a> representation of -64. Signed values are stored in 2s-complement representation.</p>\n<p>In the second example, our unsigned initial value (32) is less than 128, so it seems unaffected by the cast. The binary representation is 00100000, which is still 32 in 2s-complement representation.</p>\n<p>To \"safely\" cast from unsigned char to signed char, ensure the value is less than 128.</p>\n", "OwnerUserId": "31092", "PostTypeId": "2", "Id": "1592372", "Score": "1", "CreationDate": "2009-10-20T04:03:38.003", "LastActivityDate": "2009-10-20T04:03:38.003"}, "1592284": {"ParentId": "1592277", "CommentCount": "2", "Body": "<p>The conversion should be safe, as all you're doing is converting from one type of character to another, which should have the same size. Just be aware of what sort of data your code is expecting when you dereference the pointer, as the numeric ranges of the two data types are different. (i.e. if your number pointed by the pointer was originally positive as unsigned, it might become a negative number once the pointer is converted to a signed char* and you dereference it.)</p>\n", "OwnerUserId": "69783", "PostTypeId": "2", "Id": "1592284", "Score": "1", "CreationDate": "2009-10-20T03:26:31.603", "LastActivityDate": "2009-10-20T03:26:31.603"}, "1592293": {"ParentId": "1592277", "CommentCount": "2", "Body": "<p>I've seen it go wrong in a few ways, converting to a signed char from an unsigned char.</p>\n<p>One, if you're using it as an index to an array, that index could go negative.</p>\n<p>Secondly, if inputted to a switch statement, it may result in a negative input which often is something the switch isn't expecting.</p>\n<p>Third, it has different behavior on an arithmetic right shift</p>\n<pre><code>int x = ...;\nchar c = 128\nunsigned char u = 128\n\nc &gt;&gt; x;\n</code></pre>\n<p>has a different result than</p>\n<pre><code>u &gt;&gt; x;\n</code></pre>\n<p>Because the former is sign-extended and the latter isn't.</p>\n<p>Fourth, a signed character causes underflow at a different point than an unsigned character.</p>\n<p>So a common overflow check,</p>\n<pre><code>(c + x &gt; c)\n</code></pre>\n<p>could return a different result than</p>\n<pre><code>(u + x &gt; u)\n</code></pre>\n", "OwnerUserId": "97235", "PostTypeId": "2", "Id": "1592293", "Score": "0", "CreationDate": "2009-10-20T03:29:33.903", "LastActivityDate": "2009-10-20T03:29:33.903"}, "1592290": {"ParentId": "1592277", "CommentCount": "0", "Body": "<p>It depends on how you are going to use the pointer. You are just converting the pointer type.</p>\n", "OwnerUserId": "57005", "PostTypeId": "2", "Id": "1592290", "Score": "0", "CreationDate": "2009-10-20T03:28:42.520", "LastActivityDate": "2009-10-20T03:28:42.520"}, "1593006": {"ParentId": "1592277", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The access is well-defined, you are allowed to access an object through a pointer to signed or unsigned type corresponding to the dynamic type of the object (3.10/15).</p>\n<p>Additionally, <code>signed char</code> is guaranteed not to have any trap values and as such you can safely read through the <code>signed char</code> pointer no matter what the value of the original <code>unsigned char</code> object was.</p>\n<p>You can, of course, expect that the values you read through one pointer will be different from the values you read through the other one.</p>\n<p>Edit: regarding sellibitze's comment, this is what 3.9.1/1 says.</p>\n<blockquote>\n<p id=\"so_1592277_1593006_0\">A char, a signed char, and an unsigned char occupy the same amount of storage and have the same alignment requirements (3.9); that is, they have the same object representation. For character types, all bits of the object representation participate in the value representation. For unsigned character types, all possible bit patterns of the value representation represent numbers.</p>\n</blockquote>\n<p>So indeed it seems that <code>signed char</code> may have trap values. Nice catch!</p>\n", "OwnerUserId": "89847", "LastEditorUserId": "89847", "LastEditDate": "2009-10-20T08:25:04.140", "Id": "1593006", "Score": "2", "CreationDate": "2009-10-20T07:36:58.620", "LastActivityDate": "2009-10-20T08:25:04.140"}, "1593070": {"ParentId": "1592277", "CommentCount": "0", "Body": "<p>I'm astonished it hasn't been mentioned yet: <a href=\"http://www.boost.org/doc/libs/1_40_0/libs/numeric/conversion/doc/html/boost_numericconversion/improved_numeric_cast__.html\" rel=\"nofollow noreferrer\">Boost numeric cast</a> should do the trick - but only for the data of course.</p>\n<p>Pointers are always pointers. By casting them to a different type, you only change the way the compiler interprets the data pointed to.</p>\n", "OwnerUserId": "79996", "PostTypeId": "2", "Id": "1593070", "Score": "0", "CreationDate": "2009-10-20T07:57:49.200", "LastActivityDate": "2009-10-20T07:57:49.200"}, "bq_ids": {"n4140": {"so_1592277_1593006_0": {"section_id": 7210, "quality": 0.95, "length": 38}}, "n3337": {"so_1592277_1593006_0": {"section_id": 6954, "quality": 0.95, "length": 38}}, "n4659": {"so_1592277_1593006_0": {"section_id": 8719, "quality": 0.85, "length": 34}}}, "1592277": {"CommentCount": "5", "ViewCount": "1507", "PostTypeId": "1", "LastEditorUserId": "60777", "CreationDate": "2009-10-20T03:22:30.437", "LastActivityDate": "2009-10-20T08:25:04.140", "Title": "Conversion from unsigned to signed type safety?", "AcceptedAnswerId": "1593006", "LastEditDate": "2009-10-20T03:31:55.363", "Id": "1592277", "Score": "1", "Body": "<p>Is it safe to convert, say, from an <code>unsigned char *</code> to a <code>signed char *</code> (or just a <code>char *</code>?</p>\n", "Tags": "<c++><unsigned>", "OwnerUserId": "187543", "AnswerCount": "8"}});