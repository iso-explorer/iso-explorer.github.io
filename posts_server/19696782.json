post_cb({"19696833": {"ParentId": "19696782", "LastEditDate": "2013-10-31T01:35:04.053", "CommentCount": "6", "CreationDate": "2013-10-31T01:23:01.547", "OwnerUserId": "1120273", "LastEditorUserId": "1120273", "PostTypeId": "2", "Id": "19696833", "Score": "6", "Body": "<p>The problem is that the functions inherited from the C standard library like, e.g., the <code>&lt;cmath&gt;</code> functions are somewhat funny beasts: they are made to look as if they live in namespace <code>std</code> but really they are <code>extern \"C\"</code> functions living in the global namespace. Basically calling <code>std::sqrt(x)</code> effectively calls <code>::sqrt(x)</code> which happens to be the function you just defined!</p>\n<p>I haven't checked what the C++ standard says about these names in the global namespace but I'd be fairly certain that it classifies them as reserved names. That is, you'd better not define <code>::sqrt</code> in any shape or form. Define the function in a suitable namespace and you'll be fine.</p>\n<p>OK, I checked. The relevant clause is 17.3.24 [defns.reserved.function]:</p>\n<blockquote>\n<p id=\"so_19696782_19696833_0\"><strong>reserved function</strong></p>\n<p id=\"so_19696782_19696833_1\">a function, specified as part of the C++ standard library, that must be defined by the implementation [ Note: If a C++ program provides a definition for any reserved function, the results are undefined. \u2014end note ]</p>\n</blockquote>\n<p>... and 17.6.4.3.3 [extern.names] paragraph 3 and 4:</p>\n<blockquote>\n<p id=\"so_19696782_19696833_2\">Each name from the Standard C library declared with external linkage is reserved to the implementation for use as a name with <code>extern \"C\"</code> linkage, both in namespace <code>std</code> and in the global namespace.</p>\n<p id=\"so_19696782_19696833_3\">Each function signature from the Standard C library declared with external linkage is reserved to the implementation for use as a function signature with both <code>extern \"C\"</code> and <code>extern \"C++\"</code> linkage, or as a name of namespace scope in the global namespace.</p>\n</blockquote>\n", "LastActivityDate": "2013-10-31T01:35:04.053"}, "19696845": {"ParentId": "19696782", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_19696782_19696845_0\"><strong>17.6.4.3.3/2</strong> Each global function signature declared with external linkage in a header is reserved to the implementation to designate that function signature with external linkage.<br>\n<strong>17.6.4.3.3/3</strong> Each name from the Standard C library declared with external linkage is reserved to the implementation for use as a name with <code>extern \"C\"</code> linkage, both in namespace <code>std</code> and in the global namespace.<br>\n<strong>17.6.4.3.3/4</strong> Each function signature from the Standard C library declared with external linkage is reserved to the implementation for use as a function signature with both <code>extern \"C\"</code> and <code>extern \"C++\"</code> linkage, or as a name of namespace scope in the global namespace.</br></br></p>\n</blockquote>\n", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "19696845", "Score": "6", "CreationDate": "2013-10-31T01:24:06.073", "LastActivityDate": "2013-10-31T01:24:06.073"}, "bq_ids": {"n4140": {"so_19696782_19696833_2": {"section_id": 6310, "quality": 0.9444444444444444, "length": 17}, "so_19696782_19696833_3": {"section_id": 6311, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_19696782_19696833_2": {"section_id": 6067, "quality": 0.9444444444444444, "length": 17}, "so_19696782_19696833_3": {"section_id": 6068, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_19696782_19696833_1": {"section_id": 7709, "quality": 0.8125, "length": 13}, "so_19696782_19696833_2": {"section_id": 7820, "quality": 0.9444444444444444, "length": 17}, "so_19696782_19696833_3": {"section_id": 7821, "quality": 0.9545454545454546, "length": 21}}}, "19696782": {"CommentCount": "1", "ViewCount": "364", "LastActivityDate": "2013-10-31T01:35:04.053", "Body": "<p>I have the following C++ test program called test.cpp:</p>\n<pre><code>#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n\ndouble sqrt(double d) { return std::sqrt(d); }\n\nint main()\n{\n    std::cout &lt;&lt; \"sqrt(4): \" &lt;&lt; sqrt(4) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This is some pretty contrived code, and as you might have guessed I'm just trying to do an exercise out of Stroustrup. He declared double sqrt(double), and wants the reader to define it.</p>\n<p>I compiled the above code using g++ 4.8 (from the MINGW release of Qt 5.1):</p>\n<pre><code>C:\\Windows\\Temp&gt;g++ -o test.exe -g test.cpp\n</code></pre>\n<p>When I ran the resulting executable, Windows 7 said \"test.exe has stopped working\".</p>\n<p>To see what went wrong, I ran test.exe in the GNU debugger. Debugger commands and output:</p>\n<pre><code>C:\\Windows\\Temp&gt;gdb -q test.exe\nReading symbols from C:\\Windows\\Temp\\test.exe...done.\n(gdb) b main\nBreakpoint 1 at 0x401625: file test.cpp, line 8.\n(gdb) run\nStarting program: C:\\Windows\\Temp\\test.exe\n[New Thread 12080.0x2ba0]\n\nBreakpoint 1, main () at test.cpp:8\n8           std::cout &lt;&lt; \"sqrt(4): \" &lt;&lt; sqrt(4) &lt;&lt; std::endl;\n(gdb) s\nsqrt (d=4) at test.cpp:4\n4       double sqrt(double d) { return std::sqrt(d); }\n(gdb) s\nsqrt (d=4) at test.cpp:4\n4       double sqrt(double d) { return std::sqrt(d); }\n(gdb) s\nsqrt (d=4) at test.cpp:4\n4       double sqrt(double d) { return std::sqrt(d); }\n(gdb) s\nsqrt (d=4) at test.cpp:4\n4       double sqrt(double d) { return std::sqrt(d); }\n(gdb) q\nA debugging session is active.\n\n        Inferior 1 [process 12080] will be killed.\n\nQuit anyway? (y or n) y\n\nC:\\Windows\\Temp&gt;\n</code></pre>\n<p>From the behavior and warning, I infer that std::sqrt must be calling sqrt from the global namespace -- which causes my function to be repeatedly invoked.</p>\n<p>It would be easy enough to work around the unwanted recursion by changing the name of my sqrt function, or by putting it inside a namespace. But I would like to understand why std::sqrt is implemented in such a way that ::sqrt is called. I thought the whole point of the std namespace was to prevent name clashes with unqualified names in user code.</p>\n<p>I took a peek at the source code for the <a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-3.4/cmath-source.html\">GNU implementation of &lt;cmath&gt;</a>. However, I lost the trail after following a few #includes in the chain. Maybe you can make more sense of it:</p>\n<pre><code>00052 #include &lt;math.h&gt;\n00053 \n00054 // Get rid of those macros defined in &lt;math.h&gt; in lieu of real functions.\n....\n00076 #undef sqrt\n....\n00081 namespace std\n00082 {\n....\n00393   using ::sqrt;\n00394 \n00395   inline float\n00396   sqrt(float __x)\n00397   { return __builtin_sqrtf(__x); }\n00398 \n00399   inline long double\n00400   sqrt(long double __x)\n00401   { return __builtin_sqrtl(__x); }\n00402 \n00403   template&lt;typename _Tp&gt;\n00404     inline typename __enable_if&lt;double, __is_integer&lt;_Tp&gt;::_M_type&gt;::_M_type\n00405     sqrt(_Tp __x)\n00406     { return __builtin_sqrt(__x); }\n....\n00437 }\n</code></pre>\n<p>Incidentally, this is not just a GNU puzzle. Compiling with the Visual C++ compiler instead of g++ yields the following warning:</p>\n<pre><code>C:\\Windows\\Temp&gt;cl /nologo /EHsc test.cpp\ntest.cpp\nc:\\windows\\temp\\test.cpp(4) : warning C4717: 'sqrt' : recursive on all control\npaths, function will cause runtime stack overflow\n</code></pre>\n<p>I guess that makes this a fair question to ask on StackOverflow. :)</p>\n<p>Running the resulting executable leads to the expected outcome: \"test.exe has stopped working\".</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "19696833", "FavoriteCount": "1", "Title": "Why is my non-recursive sqrt function recursive?", "Id": "19696782", "Score": "5", "CreationDate": "2013-10-31T01:16:09.583", "Tags": "<c++><visual-c++><g++><sqrt><cmath>", "OwnerUserId": "1705833", "AnswerCount": "2"}});