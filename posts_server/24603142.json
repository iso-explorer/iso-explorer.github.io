post_cb({"24603522": {"ParentId": "24603142", "LastEditDate": "2014-07-07T05:39:34.873", "CommentCount": "5", "CreationDate": "2014-07-07T05:25:36.200", "OwnerUserId": "410767", "LastEditorUserId": "410767", "PostTypeId": "2", "Id": "24603522", "Score": "5", "Body": "<p><code>::operator new[]</code> and ~<code>delete[]</code> facilitate memory usage debugging, being a central point to audit allocation and deallocation operations; you can then ensure the array form is used for both or neither.</p>\n<p>There are also lots of plausible if highly unusual/crude tuning uses:</p>\n<ul>\n<li><p>allocate arrays from a separate pool, perhaps because that crucially improved average cache hits for small single-object dynamically-allocated objects,</p></li>\n<li><p>different memory access hints (ala <a href=\"http://man7.org/linux/man-pages/man2/madvise.2.html\" rel=\"noreferrer\"><code>madvise</code></a>) for array/non-array data</p></li>\n</ul>\n<p>All that's a bit weird and outside the day-to-day concerns of 99.999% of programmers, but why prevent it being possible?</p>\n", "LastActivityDate": "2014-07-07T05:39:34.873"}, "24603518": {"ParentId": "24603142", "LastEditDate": "2014-07-08T03:04:04.640", "CommentCount": "0", "CreationDate": "2014-07-07T05:25:06.450", "OwnerUserId": "383045", "LastEditorUserId": "383045", "PostTypeId": "2", "Id": "24603518", "Score": "2", "Body": "<p>I'm sure there are proper use-cases out there that require separate <code>new[]</code> and <code>new</code>, but I haven't encountered one yet that is uniquely possible with this separation and nothing else.</p>\n<p>However, I see it like this: since the user calls different versions of operator <code>new</code>, the C++ standard would have been guilty of wantonly and deliberately <em>losing information</em> if they'd defined just one <code>operator new</code> and had both <code>new</code> and <code>new[]</code> forward there. There is (literally) one bit of information here, that <em>might</em> be useful to <em>somebody</em>, and I don't think people on the committee could have thrown it out in good conscience!</p>\n<p>Besides, having to implement the extra <code>new[]</code> is a very very minor inconvenience to the rest of us, if at all, so the trade off of preserving a single bit of information wins against having to implement a single simple function in a small fraction of our programs.</p>\n", "LastActivityDate": "2014-07-08T03:04:04.640"}, "24603742": {"ParentId": "24603142", "LastEditDate": "2014-07-07T05:54:13.103", "CommentCount": "5", "CreationDate": "2014-07-07T05:45:49.880", "OwnerUserId": "153285", "LastEditorUserId": "153285", "PostTypeId": "2", "Id": "24603742", "Score": "12", "Body": "<p>I think <code>::operator new[]</code> may have been useful for fairly specialized systems where \"big but few\" arrays might be allocated by a different allocator than \"small but numerous\" objects. However, it's currently something of a relic.</p>\n<p><code>operator new</code> can reasonably expect that an object will be constructed at the exact address returned, but <code>operator new[]</code> cannot. The first bytes of the allocation block might be used for a size \"cookie\", the array might be sparsely initialized, etc. The distinction becomes more meaningful for member <code>operator new</code>, which may be specialized for its particular class.</p>\n<p>In any case, <code>::operator new[]</code> cannot be very essential, because <code>std::vector</code> (via <code>std::allocator</code>), which is currently the most popular way to obtain dynamic arrays, ignores it.</p>\n<p>In modern C++, custom allocators are generally a better choice than customized <code>operator new</code>. Actually, <code>new</code> expressions should be avoided entirely in favor of container (or smart-pointer, etc) classes, which provide more exception safety.</p>\n", "LastActivityDate": "2014-07-07T05:54:13.103"}, "24603142": {"CommentCount": "7", "AcceptedAnswerId": "24603742", "PostTypeId": "1", "LastEditorUserId": "508343", "CreationDate": "2014-07-07T04:39:37.383", "LastActivityDate": "2014-07-14T08:44:44.010", "LastEditDate": "2014-07-07T04:55:03.220", "ViewCount": "1373", "FavoriteCount": "9", "Title": "Why is ::operator new[] necessary when ::operator new is enough?", "Id": "24603142", "Score": "22", "Body": "<p>As we know, the C++ standard defines two forms of global allocation functions:</p>\n<pre><code>void* operator new(size_t);\nvoid* operator new[](size_t);\n</code></pre>\n<p>And also, the draft C++ standard (18.6.1.2 n3797) says:</p>\n<blockquote>\n<p id=\"so_24603142_24603142_0\">227) It is not the direct responsibility of operator\n  new or operator delete to note the repetition\n  count or element size of the array. Those operations are performed\n  elsewhere in the array new and delete expressions. The array new\n  expression, may, however, increase the size argument to operator\n  new to obtain space to store supplemental information.</p>\n</blockquote>\n<p>What makes me confused is:</p>\n<p>What if we remove <code>void* operator new[](size_t);</code> from the standard, and just use <code>void* operator new(size_t)</code> instead? What's the rationale to define a redundant global allocation function?</p>\n", "Tags": "<c++><memory-management><overloading><standards><new-operator>", "OwnerUserId": "508343", "AnswerCount": "5"}, "24608484": {"ParentId": "24603142", "LastEditDate": "2014-07-08T04:05:10.653", "CommentCount": "8", "CreationDate": "2014-07-07T10:29:27.910", "OwnerUserId": "1105562", "LastEditorUserId": "1105562", "PostTypeId": "2", "Id": "24608484", "Score": "7", "Body": "<p>The standard (n3936) makes it clear that these two operators serve different but related purposes.</p>\n<p><code>operator new</code> calls the function <code>void* operator new(std::size_t)</code>. The first argument must be identical to the argument to the operator. It returns a block of storage suitably aligned, and which may be somewhat larger than required.</p>\n<p><code>operator new[]</code> calls the function <code>void* operator new[](std::size_t)</code>. The first argument may be larger than the argument supplied to the operator, to provide extra storage space if required for array indexing. The default implement for both is to simply call malloc().</p>\n<p>The purpose of <code>operator new[]</code> is to support specialised array indexing, if available. It has nothing to do with memory pools or anything else. In a conforming implementation that made use of this feature, the implementation would set up specialised tables in the extra space and the compiler would generate code for instructions or calls to library library support routines that made use of those tables. C++ code using arrays and failing to use new[] would fail on those platforms.</p>\n<p>I am not personally aware of any such implementation, but it resembles the kind of features required for the support of certain mainframes (CDC, IBM, etc) which have an architecture quite unlike the Intel or RISC chips we know and love.</p>\n<p>In my opinion, the accepted answer is incorrect.</p>\n<hr>\n<p>Just for completeness, the standard (n3936 mostly in S5.3.4) contains the following.</p>\n<ol>\n<li>A distinction between allocating an 'array object' or a 'non-array object'</li>\n<li>References to 'array allocation overhead', with the implication that extra storage might be needed and it might (somehow) be used for a repetition count or element size.</li>\n</ol>\n<p>There is no reference to memory pools or any hint that this might be a consideration.</p>\n</hr>", "LastActivityDate": "2014-07-08T04:05:10.653"}, "24615283": {"ParentId": "24603142", "LastEditDate": "2014-07-14T08:44:44.010", "CommentCount": "4", "CreationDate": "2014-07-07T16:23:09.770", "OwnerUserId": "53870", "LastEditorUserId": "53870", "PostTypeId": "2", "Id": "24615283", "Score": "-1", "Body": "<p><em>The C++ Programming Language: Special Edition</em> p 423 says</p>\n<p>_The <code>operator new()</code> and <code>operator delete()</code> functions allow a user to take over allocation and deallocation of individual objects; <code>operator new[]()</code> and <code>operator delete[]()</code> serve exactly the same role for the allocation and deallocation of arrays.</p>\n<p>Thanks Tony D for correcting my misunderstanding of this nuance.</p>\n<p>Wow, it's not often I'm caught out on something in C++ I'm so certain about - I must have been spending too much time in Objective-C!</p>\n<p><strong>original wrong answer</strong></p>\n<p>It's simple - the new[] form <a href=\"http://www.cplusplus.com/reference/new/operator%20new%5B%5D/\" rel=\"nofollow\">invokes the constructor</a> on every element of a classic C array.</p>\n<p>So it first allocates the space for all the objects, then iterates calling the constructor for each slot.</p>\n", "LastActivityDate": "2014-07-14T08:44:44.010"}, "bq_ids": {"n4140": {"so_24603142_24603142_0": {"section_id": 6836, "quality": 0.8648648648648649, "length": 32}}, "n3337": {"so_24603142_24603142_0": {"section_id": 6586, "quality": 0.8648648648648649, "length": 32}}, "n4659": {"so_24603142_24603142_0": {"section_id": 8328, "quality": 0.9459459459459459, "length": 35}}}});