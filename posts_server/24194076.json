post_cb({"24218798": {"Id": "24218798", "PostTypeId": "2", "Body": "<h1>There is no clear case for Undefined Behavior here</h1>\n<p>Sure, an argument leading to UB can be given, as I indicated in the question, and which has been repeated in the answers given so far. However this involves a strict reading of 5.17:7 that is both <em>self-contradictory</em> and <em>in contradiction with explicit statements in 5.17:1</em> about compound assignment. With a weaker reading of 5.17:7 the contradictions disappear, as does the argument for UB. Whence my conclusion is <em>neither</em> that there is UB here, <em>nor</em> that there is clearly defined behaviour, but the <strong>the text of the standard is inconsistent, and should be modified to make clear which reading prevails</strong> (and I suppose this means a defect report should be written). Of course one might invoke here the fall-back clause in the standard (the note in 1.3.24) that evaluations for which the standard fails to define the behavior [unambiguously and self-consistently] are Undefined Behavior, but that would make any use of compound assignments (including prefix increment/decrement operators) into UB, something that might appeal to certain implementors, but certainly not to programmers.</p>\n<p>Instead of arguing for the given problem, let me present a slightly modified example that brings out the inconsistency more clearly. Assume one has defined</p>\n<pre><code>int&amp; f (int&amp; a) { return a; }\n</code></pre>\n<p>a function that does nothing and returns its (lvalue) argument. Now modify the example to</p>\n<pre><code>n += f(++n) + 1;\n</code></pre>\n<p>Note that while some extra conditions about sequencing of function calls are given in the standard, this would at first glance not seem to effect the example, since there are no side effect at all from the function call (not even locally inside the function), as the incrementation happens in the argument expression for <code>f</code>, whose evaluation is not subject to those extra conditions. Indeed, let us apply the Crucial Argument for Undefined Behavior (CAUB), namely 5.17:7 which says that the behavior of such a compound assignment is equivalent to that of (in this case)</p>\n<pre><code>n = n + f(++n) + 1;\n</code></pre>\n<p>except that <code>n</code> is evaluated only once (an exception that makes no difference here). The evaluation of the statement I just wrote <strong>clearly has UB</strong> (the value computation of the first (prvalue) <code>n</code> in the RHS is unsequenced w.r.t. the side effect of the <code>++</code> operation, which involves the same scalar object (1.9:15) and you're dead).</p>\n<p>So the evaluation of <code>n += f(++n) + 1</code> has undefined behavior, right? <strong>Wrong!</strong> Read  in 5.17:1 that</p>\n<blockquote>\n<p id=\"so_24194076_24218798_0\">With respect to an indeterminately-sequenced function call, the operation of a compound assignment is a single evaluation. [ <em>Note</em>: Therefore, a function call shall not intervene between the lvalue-to-rvalue conversion and the side effect associated with any single compound assignment operator. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>This language is far from as precise as I would like it to be, but I don't think it is a stretch to assume that \"indeterminately-sequenced\" should mean \"with respect to that operation of a compound assignment\". The (non normative, I know) note makes it clear that the lvalue-to-rvalue conversion is part of the operation of the compound assignment. Now is the call of <code>f</code> indeterminately-sequenced with respect to the operation of the compound assignment of <code>+=</code>? I'm unsure, because the 'sequenced' relation is defined for individual value computations and side effects, not complete evaluations of operators, which may involve both. In fact the evaluation of a compound assignment operator involves <em>three</em> items: the lvalue-to-rvalue conversion of its left operand, the side effect (the assignment proper), and the value computation of the compound assignment (which is sequenced after the side effect, and returns the original left operand as lvalue). Note that the existence of the lvalue-to-rvalue conversion is never explicitly mentioned in the standard <em>except in the note cited above</em>; in particular, the standard makes no (other) statement at all regarding its sequencing relative to other evaluations. It is pretty clear that in the example the call of <code>f</code> is sequenced <em>before</em> the side effect and value computation of <code>+=</code> (since the call occurs in the value computation of the right operand to <code>+=</code>), but it might be indeterminately-sequenced with respect to the lvalue-to-rvalue conversion part. I recall from my question that since the left operand of <code>+=</code> is an lvalue (and necessarily so), one cannot construe the lvalue-to-rvalue conversion to have occurred as part of the value computation of the left operand.</p>\n<p>However, by the principle of the excluded middle, the call to <code>f</code> must either be indeterminately-sequenced with respect to the operation of the compound assignment of <code>+=</code>, or not indeterminately-sequenced with respect to it; in the latter case it must be sequenced <em>before</em> it because it cannot possibly be sequenced after it (the call of <code>f</code> being sequenced before the side effect of <code>+=</code>, and the relation being anti-symmetric). So first assume it <em>is</em> indeterminately-sequenced with respect to the operation. Then the cited clause says that w.r.t. the call of <code>f</code> the evaluation of <code>+=</code> is a single operation, and the note explains that it means the call should not intervene between the lvalue-to-rvalue conversion and the side effect associated with <code>+=</code>; it should either be sequenced before both, or after both. But being sequenced after the side effect is not possible, so it should be before both. This makes (by transitivity) the side effect of <code>++</code> sequenced before the lvalue-to-rvalue conversion, exit UB. Next assume the call of <code>f</code> is sequenced before the operation of <code>+=</code>. Then it is in particular sequenced before the lvalue-to-rvalue conversion, and again by transitivity so is the side effect of <code>++</code>; no UB in this branch either.</p>\n<p>Conclusion: 5.17:1 contradicts 5.17:7 if the latter is taken (CAUB) to be normative for questions of UB resulting from unsequenced evaluations by 1.9:15. As I said CAUB is self-contradictory as well (by arguments indicated in the question), but this answer is getting to long, so I'll leave it at this for now.</p>\n<h2>Three problems, and two proposals for resolving them</h2>\n<p>Trying to understand what the standard writes about these matters, I distinguish three aspects in which the text is hard to interpret; they all are of a nature that the text is insufficiently clear about what model its statements are referring to. (I cite the texts at the end of the numbered items, since I do not know the markup to resume a numbered item after a quote)</p>\n<ol>\n<li><p>The text of 5.17:7 is of an apparent simplicity that, although the intention is easy to grasp, gives us little hold when applied to difficult situations. It makes a sweeping claim (equivalent behavior, apparently in all aspects) but whose application is thwarted by the exception clause. What if the behavior of <code>E1 = E1</code> <em>op</em> <code>E2</code> is undefined? Well then that of <code>E1</code> <em>op</em> <code>= E2</code> should be as well. But what if the UB was <strong>due to</strong> <code>E1</code> being evaluated twice in <code>E1 = E1</code> <em>op</em> <code>E2</code>? Then evaluating <code>E1</code> <em>op</em> <code>= E2</code> should presumably not be UB, but if so, then defined as what? This is like saying \"the youth of the second twin was exactly like that of the first, except that he did not die at childbirth.\" Frankly, I think this text, which has little evolved since the C version \"A <em>compound assignment</em> of the the form <em><code>E1 op = E2</code></em> differs from the simple assignment expression <em><code>E1 = E1 op E2</code></em> only in that the lvalue <em><code>E1</code></em> is evaluated only once.\" might be adapted to match the changes in the standard.</p>\n<blockquote>\n<p id=\"so_24194076_24218798_1\">(5.17) 7 The behavior of an expression of the form <code>E1</code> <em>op</em> <code>= E2</code> is equivalent to\n  <code>E1 = E1</code> <em>op</em> <code>E2</code> except that <code>E1</code> is evaluated only once.[...]</p>\n</blockquote></li>\n<li><p>It is not so clear what precisely the actions (evaluations) are between which the 'sequenced' relation is defined. It is said (1.9:12) that evaluation of an expression <em>includes</em> value computations and initiation of side effects. Though this appears to say that an evaluation may have multiple (atomic) components, the sequenced relation is actually mostly defined (e.g. in 1.9:14,15) for individual components, so that it might be better to read this as that the <em>notion</em> of \"evaluation\" encompasses both value computations and (initiation of) side effects. However in some cases the 'sequenced' relation is defined for the (entire) execution of an expression of statement (1.9:15) or for a function call (5.17:1), even though a passage in 1.9:15 avoids the latter by referring directly to executions in the body of a called function.</p>\n<blockquote>\n<p id=\"so_24194076_24218798_2\">(1.9) 12 <em>Evaluation</em> of an expression (or a sub-expression) in general includes\n  both value computations (...) and initiation of side effects. [...] 13 <em>Sequenced before</em> is an asymmetric, transitive, pair-wise relation between evaluations executed by a single thread [...] 14 Every value computation and side effect associated with a full-expression is sequenced before every value computation and side effect associated with the next full-expression to be evaluated. [...] 15 When calling a function (whether or not the function is inline), every value computation and side effect\n  associated with any argument expression, or with the postfix expression designating the called function, is\n  sequenced before execution of every expression or statement in the body of the called function. [...] Every evaluation in the calling function (including other function calls) ... is indeterminately sequenced with\n  respect to the execution of the called function [...] (5.2.6, 5.17) 1 ... With respect to an indeterminately-sequenced function call, ...</p>\n</blockquote></li>\n<li><p>The text should more clearly acknowledge that a compound assignment involves, in contrast to a simple assignment, the action of fetching the value previously assigned to its left operand; this action is like lvalue-to-rvalue conversion, but does not happen as part of the value computation of that left operand, since it is not a prvalue; indeed it is a problem that 1.9:12 only acknowledges such action <em>for  prvalue evaluation</em>. In particular the text should be more clear about which 'sequenced' relations are given for that action, if any.</p>\n<blockquote>\n<p id=\"so_24194076_24218798_3\">(1.9) 12 <em>Evaluation</em> of an expression... includes... value computations (including determining the identity of an object for glvalue evaluation and fetching a value previously assigned to an object for prvalue evaluation)</p>\n</blockquote></li>\n</ol>\n<p>The second point is the least directly related to our concrete question, and I think it can be solved simply by choosing a clear point of view and reformulating pasages that seem to indicate a different point of view. Given that one of the main purposes of the old sequence points, and now the 'sequenced' relation, was to make clear that the side effect of postfix-increment operators is unsequenced w.r.t. to actions sequenced after the value computation of that operator (thus giving e.g. <code>i = i++</code> UB), the point of view must be that <em>individual</em> value computations and (initiation of) individual side effects are \"evaluations\" for which \"sequenced before\" may be defined. For pragmatic reasons I would also include two more kinds of (trivial) \"evaluations\": function entry (so that the language of 1.9:15 may be simplified to: \"When calling a function..., every value computation and side effect associated with any of its argument expressions, or with the postfix expression designating the called function, is sequenced before entry of that function\") and function exit (so that any action in the function body gets by transitivity sequenced before anything that requires the function value; this used to be guaranteed by a sequence point, but the C++11 standard seems to have lost such guarantee; this might make calling a function ending with <code>return i++;</code> potentially UB where this is not intended, and used to be safe). Then one can also be clear about the \"indeterminately sequenced\" relation of functions calls: for every function call, and every evaluation that is not (directly or indirectly) part of evaluating that call, that evaluation shall be sequenced (either before or after) w.r.t. both entry and exit of that function call, <em>and it shall have the same relation in both cases</em> (so that in particular such external actions cannot be sequenced after function entry but before function exit, as is clearly desirable within a single thread).</p>\n<p>Now to resolve points 1. and 3., I can see two paths (each affecting both points), which have different consequences for the defined or not behavior of our example:</p>\n<h1>Compound assignments with two operands, and three evaluations</h1>\n<p>Compound operations have thier two usual operands, an lvalue left operand and a prvalue right operand. To settle the unclarity of 3., it is included in 1.9:12 that fetching the value previously assigned to an object also may occur in compound assignments (rather than only for prvalue evaluation). The semantics of compount assignments are defined by changing 5.17:7 to</p>\n<blockquote>\n<p id=\"so_24194076_24218798_4\">In a compound assignment <em>op</em><code>=</code>, the value previously assigned to the object referred to by the left operand is fetched, the operator <em>op</em> is applied with this value as left operand and the right operand of <em>op</em><code>=</code> as right operand, and the resulting value replaces that of the object referred to by the left operand.</p>\n</blockquote>\n<p>(That gives two evaluations, the fetch and the side effect; a third evaluation is the trivial value computation of the compound operator, sequenced after both other evaluations.)</p>\n<p>For clarity, state clearly in 1.9:15 that value computations in operands are sequenced before <em>all</em> value computations associated with the operator (rather than just those <em>for the result of the operator</em>), which ensures that evaluating the lvalue left operand is sequenced before fetching its value (one can hardly imagine otherwise), and also sequences the value computation of the <em>right</em> operand before that fetch, thus excluding UB in our example. While at it, I see no reason not to also sequence value computations in operands before any <em>side effects</em> associated with the operator (as they clearly must); this would make mentioning this explicitly for (compound) assignments in 5.17:1 superfluous. On the other hand do mention there that the value fetching in a compound assignment is sequenced before its side effect.</p>\n<h1>Compound assignments with three operands, and two evaluations</h1>\n<p>In order to obtain that the fetch in a compount assignment will be unsequenced with respect to the value computation of the right operand, making our example UB, the clearest way seems to be to give compound operators an implicit third (middle) <em>operand</em>, a prvalue, not represented by a separate expression, but obtained by lvalue-to-rvalue conversion from the left operand (this three-operand nature corresponds to the expanded form of compound assignments, but by obtaining the middle operand from the left operand, it is ensured that the value is fetched from the same object to which the result will be stored, a crucial guarantee that is only vaguely and implicitly given in the current formulation through the \"except that <code>E1</code> is evaluated only once\" clause). The difference with the previous solution is that the fetch is now a genuine lvalue-to-rvalue conversion (since the middle operand is a prvalue) and is performed <em>as part of the value computation of the operands to the compound assignment</em>, which makes it naturally unsequenced with the value computation of the right operand. It should be stated somewhere (in a new clause that describes this implicit operand) that the value computation of the left operand is sequenced before this lvalue-to-rvalue conversion (it clearly must). Now 1.9:12 can be left as it is, and in place of 5.17:7 I propose</p>\n<blockquote>\n<p id=\"so_24194076_24218798_5\">In a compound assignment <em>op</em><code>=</code> with left operand <code>a</code> (an lvalue), and midlle and right operands <code>b</code>respectively <code>c</code> (both prvalues), the operator <em>op</em> is applied with <code>b</code> as left operand and <code>c</code>  as right operand, and the resulting value replaces that of the object referred to by <code>a</code>.</p>\n</blockquote>\n<p>(That gives one evaluation, the side effect, with as second evaluation the trivial value computation of the compound operator, sequenced after it.)</p>\n<p>The still applicable changes to 1.9:15 and 5.17:1 suggested in the previous solution could still apply, but would not give our original example defined behavior. However the modified example at the top of this answer would still have defined behavior, unless the part 5.17:1 \"compound assignment is a single operation\" is scrapped or modified (there is a similar passage in 5.2.6 for postfix increment/decrement). The existence of those passages would suggest that detaching the fecth and store operations within a single compound assignement or postfix increment/decrement was <em>not</em> the intention of those who wrote the current standard (and by extension making our example UB), but this of course is mere guesswork.</p>\n", "LastEditorUserId": "1436796", "LastActivityDate": "2014-06-18T12:56:00.547", "Score": "0", "CreationDate": "2014-06-14T10:07:36.267", "ParentId": "24194076", "CommentCount": "14", "OwnerUserId": "1436796", "LastEditDate": "2014-06-18T12:56:00.547"}, "24194076": {"ViewCount": "2977", "Body": "<p>This question came up while I was reading (the answers to)  <a href=\"https://stackoverflow.com/q/14005508/1436796\">So why is i = ++i + 1 well-defined in C++11?</a></p>\n<p>I gather that the subtle explanation is that (1) the expression <code>++i</code> returns an lvalue but <code>+</code> takes prvalues as operands, so a conversion from lvalue to prvalue must be performed; this involves obtaining the current value of that lvalue (rather than one more than the old value of <code>i</code>) and must therefore be sequenced <em>after</em> the side effect from the increment (i.e., updating <code>i</code>) (2) the LHS of the assignment is also an lvalue, so its value evaluation does not involve fetching the current value of <code>i</code>; while this value computation is unsequenced w.r.t. the value computation of the RHS, this poses no problem (3) the value computation of the assignment itself involves updating <code>i</code> (again), but is sequenced after the value computation of its RHS, and hence after the prvious update to <code>i</code>; no problem.</p>\n<p>Fine, so there is no UB there. Now my question is what if one changed the assigment operator from <code>=</code> to <code>+=</code> (or a similar operator).</p>\n<blockquote>\n<p id=\"so_24194076_24194076_0\">Does the evaluation of the expression <code>i += ++i + 1</code> lead to undefined behavior?</p>\n</blockquote>\n<p>As I see it, the standard seems to contradict itself here. Since the LHS of <code>+=</code> is still an lvalue (and its RHS still a prvalue), the same reasoning as above applies as far as (1) and (2) are concerned; there is no undefined behavior in the evalutation of the operands on <code>+=</code>. As for (3), the operation of the compound assignment <code>+=</code> (more precisely the side effect of that operation; its value computation, if needed, is in any case sequenced after its side effect) now must <em>both</em> fetch the current value of <code>i</code>, <em>and then</em> (obviously sequenced after it, even if the standard does not say so explicitly, or otherwise the evaluation of such operators would <em>always</em> invoke undefined behavior) add the RHS and store the result back into <code>i</code>. Both these operations would have given undefined behavior if they were unsequenced w.r.t. the side effect of the <code>++</code>, but as argued above (the side effect of the <code>++</code> is sequenced before the value computation of <code>+</code> giving the RHS of the <code>+=</code> operator, which value computation is sequenced before the operation of that compound assignment), that is not the case.</p>\n<p>But on the other hand the standard also says that <code>E += F</code> is equivalent to <code>E = E + F</code>, except that (the lvalue) E is evaluated only once. Now in our example the value computation of <code>i</code> (which is what <code>E</code> is here) <em>as lvalue</em> does not involve anything that needs to be sequenced w.r.t. other actions, so doing it once or twice makes no difference; our expression should be strictly equivalent to <code>E = E + F</code>. But here's the problem; it is pretty obvious that evaluating <code>i = i + (++i + 1)</code> would give undefined behaviour! What gives? Or is this a defect of the standard?</p>\n<p><strong>Added.</strong> I have slightly modified my discussion above, to do more justice to the proper distinction between side effects and value computations, and using \"evaluation\" (as does the standard) of an expression to encompass both. I think my main interrogation is not just about whether behavior is defined or not in this example, but how one must read the standard in order to decide this. Notably, should one take the equivalence of <code>E op= F</code> to <code>E = E op F</code> as the ultimate authority for the semantics of the compound assignment operation (in which case the example clearly has UB), or merely as an indication of what mathematical operation is involved in determining the value to be assigned (namely the one identified by <code>op</code>, with the lvalue-to-rvalue converted LHS of the compound assignment operator as left operand and its RHS as right operand). The latter option makes it much harder to argue for UB in this example, as I have tried to explain. I admit that it is tempting to make the equivalence authoritative (so that compound assignments become a kind of second-class primitives, whose meaning is given by rewriting in term of first-class primitives; thus the language definition would be simplified), but there are rather strong arguments against this:</p>\n<ul>\n<li><p>The equivalence is not absolute, because of the \"<code>E</code> is evaluated only once\" exception. Note that this exception is essential to avoid making any use where the evaluation of <code>E</code> involves a side effect undefined behavior, for instance in the fairly common <code>a[i++] += b;</code> usage. If fact I think no absolutely equivalent rewriting to eliminate compound assignments is possible; using a fictive <code>|||</code> operator to designate unsequenced evaluations, one might try to define <code>E op= F;</code> (with <code>int</code> operands for simplicity) as equivalent to <code>{ int&amp; L=E ||| int R=F; L = L + R; }</code>, but then the example no longer has UB. In any case the standard gives us no rewriitng recipe.</p></li>\n<li><p>The standard does not treat compound assignments as second-class primitives for which no separate definition of semantics is necessary. For instance in 5.17 (emphasis mine)</p>\n<blockquote>\n<p id=\"so_24194076_24194076_1\">The assignment operator (=) and the compound assignment operators all group right-to-left. [...] <strong>In all cases</strong>, the assignment is sequenced after the value\n  computation of the right and left operands, and before the value computation of the assignment expression. With respect to an indeterminately-sequenced function call, <strong>the operation of a compound assignment is a single evaluation</strong>.</p>\n</blockquote></li>\n<li>If the intention were to let compound assignments be mere shorthands for simple assignments, there would be no reason to include them explicitly in this description. The final phrase even directly contradicts what would be the case if the equivalence was taken to be authoritative.</li>\n</ul>\n<p>If one admits that compound assignments have a semantics of their own, then the point arises that their evaluation involves (apart from the mathematical operation) more than  just a side effect (the assignment) and a value evaluation (sequenced after the assignment), but also an unnamed operation of fetching the (previous) value of the LHS. This would normally be dealt with under the heading of \"lvalue-to-rvalue conversion\", but doing so here is hard to justify, since there is no operator present that takes the LHS <em>as an rvalue</em> operand (though there is one in the expanded \"equivalent\" form). It is precisely this unnamed operation whose potential unsequenced relation with the side effect of <code>++</code> would cause UB, but this unsequenced relation is nowhere explicitly stated in the standard, because the unnamed operation is not. It is hard to justify UB using an operation whose very existence is only implicit in the standard.</p>\n", "AcceptedAnswerId": "24218798", "Title": "In C++11, does `i += ++i + 1` exhibit undefined behavior?", "CreationDate": "2014-06-12T21:17:28.613", "Id": "24194076", "CommentCount": "19", "FavoriteCount": "16", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:52:56.563", "LastEditorUserId": "-1", "LastActivityDate": "2016-08-01T11:33:52.113", "Score": "47", "OwnerUserId": "1436796", "Tags": "<c++><c++11><language-lawyer><undefined-behavior>", "AnswerCount": "5"}, "24196478": {"Id": "24196478", "PostTypeId": "2", "Body": "<p>The expression:</p>\n<pre><code>i += ++i + 1\n</code></pre>\n<p>does invoke undefined behavior. The language lawyer method requires us to go back to the defect report that results in:</p>\n<pre><code>i = ++i + 1 ;\n</code></pre>\n<p>becoming well defined in C++11, which is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#637\" rel=\"nofollow\">defect report 637. Sequencing rules and example disagree </a>, it starts out saying:</p>\n<blockquote>\n<p id=\"so_24194076_24196478_0\">In 1.9 [intro.execution] paragraph 16, the following expression is\n  still listed as an example of undefined behavior:</p>\n<pre><code>i = ++i + 1;\n</code></pre>\n<p id=\"so_24194076_24196478_1\">However, it appears that the new sequencing rules make this expression\n  well-defined</p>\n</blockquote>\n<p>The logic used in the report is as follows:</p>\n<ol>\n<li><p>The assignment side-effect is required to be sequenced after the value computations of both its LHS and RHS (5.17 [expr.ass] paragraph 1).</p></li>\n<li><p>The LHS (i) is an lvalue, so its value computation involves computing the address of i.</p></li>\n<li><p>In order to value-compute the RHS (++i + 1), it is necessary to first value-compute the lvalue expression ++i and then do an lvalue-to-rvalue conversion on the result. This guarantees that the incrementation side-effect is sequenced before the computation of the addition operation, which in turn is sequenced before the assignment side effect. In other words, it yields a well-defined order and final value for this expression.</p></li>\n</ol>\n<p>So in this question our problem changes the <code>RHS</code> which goes from:</p>\n<pre><code>++i + 1\n</code></pre>\n<p>to:</p>\n<pre><code>i + ++i + 1\n</code></pre>\n<p>due to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++11 standard</a> section <code>5.17</code> <em>Assignment and compound assignment operators</em> which says:</p>\n<blockquote>\n<p id=\"so_24194076_24196478_2\">The behavior of an expression of the form E1 op = E2 is equivalent to\n  E1 = E1 op E2 except that E1 is evaluated only once. [...]</p>\n</blockquote>\n<p>So now we have a situation where the computation of <code>i</code> in the <code>RHS</code> is not sequenced relative to <code>++i</code> and so we then have undefined behavior. This follows from section <code>1.9</code> paragraph <em>15</em> which says:</p>\n<blockquote>\n<p id=\"so_24194076_24196478_3\">Except where noted, evaluations of operands of individual operators\n  and of subexpressions of individual expressions are unsequenced. [\n  Note: In an expression that is evaluated more than once during the\n  execution of a program, unsequenced and indeterminately sequenced\n  evaluations of its subexpressions need not be performed consistently\n  in different evaluations. \u2014end note ] The value computations of the\n  operands of an operator are sequenced before the value computation of\n  the result of the operator. If a side effect on a scalar object is\n  unsequenced relative to either another side effect on the same scalar\n  object or a value computation using the value of the same scalar\n  object, the behavior is undefined.</p>\n</blockquote>\n<p>The pragmatic way to show this would be to use <code>clang</code> to test the code, which generates the following warning (<em><a href=\"http://coliru.stacked-crooked.com/a/341a1293c0bf4e3d\" rel=\"nofollow\">see it live</a></em>):</p>\n<pre><code>warning: unsequenced modification and access to 'i' [-Wunsequenced]\ni += ++i + 1 ;\n  ~~ ^\n</code></pre>\n<p>for this code:</p>\n<pre><code>int main()\n{\n    int i = 0 ;\n\n    i += ++i + 1 ;\n}\n</code></pre>\n<p>This is further bolstered by this explicit test example in <code>clang's</code> test suite for <a href=\"https://github.com/llvm-mirror/clang/blob/master/test/SemaCXX/warn-unsequenced.cpp\" rel=\"nofollow\">-Wunsequenced</a>:</p>\n<pre><code> a += ++a; \n</code></pre>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-06-14T06:35:15.353", "Score": "5", "CreationDate": "2014-06-13T01:37:47.193", "ParentId": "24194076", "CommentCount": "11", "OwnerUserId": "1708801", "LastEditDate": "2014-06-14T06:35:15.353"}, "24206844": {"Id": "24206844", "PostTypeId": "2", "Body": "<h2>Yes, it is UB!</h2>\n<p>The evaluation of your expression</p>\n<pre><code>i += ++i + 1\n</code></pre>\n<p>proceeds in the following steps:</p>\n<p>5.17p1 (C++11) states (emphases mine):</p>\n<blockquote>\n<p id=\"so_24194076_24206844_0\">The assignment operator (=) and the compound assignment operators all group right-to-left. All require a modifiable lvalue as their left operand and return an lvalue referring to the left operand. The result in all cases is a bit-field if the left operand is a bit-field. <strong>In all cases, the assignment is sequenced after the value computation of the right and left operands, and before the value computation of the assignment expression.</strong></p>\n</blockquote>\n<h3>What does \"value computation\" mean?</h3>\n<p>1.9p12 gives the answer:</p>\n<blockquote>\n<p id=\"so_24194076_24206844_1\">Accessing an object designated by a volatile glvalue (3.10), modifying an object, calling a library I/O function, or calling a function that does any of those operations are all side effects, which are changes in the state of the execution environment. <strong><em>Evaluation</em> of an expression (or a sub-expression) in general includes both value computations (including determining the identity of an object for glvalue evaluation and fetching a value previously assigned to an object for prvalue evaluation) and initiation of side effects.</strong></p>\n</blockquote>\n<p>Since your code uses a <em>compound assignment operator</em>, 5.17p7 tells us, how this operator behaves:</p>\n<blockquote>\n<p id=\"so_24194076_24206844_2\">The behavior of an expression of the form <code>E1 op= E2</code> is equivalent to <code>E1 = E1 op E2 except that</code>E1 is evaluated only once.</p>\n</blockquote>\n<p>Hence the evaluation of the expression <code>E1 ( == i)</code> involves both, determining the identity of the object designated by <code>i</code> and an <em>lvalue-to-rvalue</em> conversion to fetch the value stored in that object. But the evaluation of the two operands <code>E1</code> and <code>E2</code> are not sequenced with respect to each other. Thus we get <em>undefined behavior</em> since the evaluation of <code>E2 ( == ++i + 1)</code> initiates a side effect (updating <code>i</code>).</p>\n<p>1.9p15:</p>\n<blockquote>\n<p id=\"so_24194076_24206844_3\">... <strong>If a side effect on a scalar object is unsequenced relative to</strong> either another side effect on the same scalar object or <strong>a value computation using the value of the same scalar object, the behavior is undefined.</strong></p>\n</blockquote>\n<hr>\n<p>The following statements in your question/comments seem to be the root of your misunderstanding:</p>\n<blockquote>\n<p id=\"so_24194076_24206844_4\">(2) the LHS of the assignment is also an lvalue, so its value evaluation does not involve fetching the current value of <code>i</code></p>\n<p id=\"so_24194076_24206844_5\">fetching a value can be part of a prvalue evaluation. But in E += F the only prvalue is F so fetching the value of E is not part of the evaluation of the (lvalue) subexpression E</p>\n</blockquote>\n<p>If an expression is an lvalue or rvalue doesn't tell anything about how this expression is to be evaluated. Some operators require lvalues as their operands some others require rvalues.</p>\n<p>Clause 5p8:</p>\n<blockquote>\n<p id=\"so_24194076_24206844_6\">Whenever a glvalue expression appears as an operand of an operator that expects a prvalue for that operand, the lvalue-to-rvalue (4.1), array-to-pointer (4.2), or function-to-pointer (4.3) standard conversions are applied to convert the expression to a prvalue.</p>\n</blockquote>\n<p>In a simple assignment the evaluation of of the LHS only requires determining the identity of the object. But in a compound assignment such as <code>+=</code> the LHS must be a modifiable lvalue, but the evaluation of the LHS in this case consists of determining the identity of the object and an lvalue-to-rvalue conversion. It is the result of this conversion (which is a prvalue) that is added to the result (also a prvalue) of the evaluation of the RHS.</p>\n<h3>\"But in E += F the only prvalue is F so fetching the value of E is not part of the evaluation of the (lvalue) subexpression E\"</h3>\n<p>That's not true as I explained above. In your example <code>F</code> is a prvalue expression, but <code>F</code> may as well be an lvalue expression. In that case, the lvalue-to-rvalue conversion is also applied to <code>F</code>. 5.17p7 as cited above tells us, what the semantics of the compound assignment operators are. The standard states that the <strong>behavior</strong> of <code>E += F</code> is the same as of <code>E = E + F</code> but <code>E</code> is only evaluated once. Here, the evaluation of <code>E</code> includes the lvalue-to-rvalue conversion, because the binary operator <code>+</code> requires it operands to be rvalues.</p>\n</hr>", "LastEditorUserId": "1770418", "LastActivityDate": "2014-06-13T16:40:22.730", "Score": "1", "CreationDate": "2014-06-13T13:45:19.060", "ParentId": "24194076", "CommentCount": "4", "OwnerUserId": "1770418", "LastEditDate": "2014-06-13T16:40:22.730"}, "24651521": {"Id": "24651521", "PostTypeId": "2", "Body": "<p>From the compiler writer's perspective, they don't care about <code>\"i += ++i + 1\"</code>, because whatever the compiler does, the programmer may not get the correct result, but they surely get what they deserve. And nobody writes code like that. What the compiler writer cares about is</p>\n<pre><code>*p += ++(*q) + 1;\n</code></pre>\n<p>The code must read <code>*p</code> and <code>*q</code>, increase <code>*q</code> by 1, and increase <code>*p</code> by some amount that is calculated. Here the compiler writer cares about restrictions on the order of read and write operations. Obviously if p and q point to different objects, the order makes no difference, but if <code>p == q</code> then it will make a difference. Again, <code>p</code> will be different from <code>q</code> unless the programmer writing the code is insane. </p>\n<p>By making the code undefined, the language allows the compiler to produce the fastest possible code without caring for insane programmers. By making the code defined, the language forces the compiler to produce code that conforms to the standard even in insane cases, which may make it run slower. Both compiler writers and sane programmers don't like that. </p>\n<p>So even if the behaviour is defined in C++11, it would be very dangerous to use it, because (a) a compiler might not be changed from C++03 behaviour, and (b) it might be undefined behaviour in C++14, for the reasons above. </p>\n", "LastEditorUserId": "2982874", "LastActivityDate": "2015-07-24T09:40:55.713", "Score": "0", "CreationDate": "2014-07-09T10:42:14.647", "ParentId": "24194076", "CommentCount": "0", "OwnerUserId": "3255455", "LastEditDate": "2015-07-24T09:40:55.713"}, "bq_ids": {"n4140": {"so_24194076_24218798_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 6179}, "so_24194076_24194590_8": {"length": 22, "quality": 1.0, "section_id": 5811}, "so_24194076_24206844_0": {"length": 42, "quality": 0.9545454545454546, "section_id": 6173}, "so_24194076_24196478_3": {"length": 61, "quality": 0.9384615384615385, "section_id": 5811}, "so_24194076_24194076_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 6185}, "so_24194076_24206844_1": {"length": 44, "quality": 0.9361702127659575, "section_id": 5808}, "so_24194076_24218798_2": {"length": 54, "quality": 0.6067415730337079, "section_id": 5811}, "so_24194076_24218798_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 5808}, "so_24194076_24206844_6": {"length": 17, "quality": 1.0, "section_id": 5942}, "so_24194076_24194590_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 446}, "so_24194076_24206844_3": {"length": 22, "quality": 1.0, "section_id": 5811}, "so_24194076_24194076_1": {"length": 32, "quality": 0.9411764705882353, "section_id": 6173}, "so_24194076_24206844_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 6179}, "so_24194076_24196478_2": {"length": 7, "quality": 0.875, "section_id": 6179}, "so_24194076_24218798_0": {"length": 23, "quality": 0.8518518518518519, "section_id": 6173}}, "n3337": {"so_24194076_24218798_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 5940}, "so_24194076_24194590_8": {"length": 22, "quality": 1.0, "section_id": 5584}, "so_24194076_24206844_0": {"length": 42, "quality": 0.9545454545454546, "section_id": 5934}, "so_24194076_24196478_3": {"length": 61, "quality": 0.9384615384615385, "section_id": 5584}, "so_24194076_24206844_1": {"length": 44, "quality": 0.9361702127659575, "section_id": 5581}, "so_24194076_24218798_2": {"length": 53, "quality": 0.5955056179775281, "section_id": 5584}, "so_24194076_24218798_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 5581}, "so_24194076_24206844_6": {"length": 17, "quality": 1.0, "section_id": 5713}, "so_24194076_24194590_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 437}, "so_24194076_24206844_3": {"length": 22, "quality": 1.0, "section_id": 5584}, "so_24194076_24194076_1": {"length": 32, "quality": 0.9411764705882353, "section_id": 5934}, "so_24194076_24206844_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 5940}, "so_24194076_24196478_2": {"length": 7, "quality": 0.875, "section_id": 5940}, "so_24194076_24218798_0": {"length": 23, "quality": 0.8518518518518519, "section_id": 5934}}, "n4659": {"so_24194076_24218798_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 7681}, "so_24194076_24194590_8": {"length": 16, "quality": 0.7272727272727273, "section_id": 7272}, "so_24194076_24206844_0": {"length": 42, "quality": 0.9545454545454546, "section_id": 7675}, "so_24194076_24196478_3": {"length": 55, "quality": 0.8461538461538461, "section_id": 7272}, "so_24194076_24194076_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 7687}, "so_24194076_24206844_1": {"length": 43, "quality": 0.9148936170212766, "section_id": 7269}, "so_24194076_24218798_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 7269}, "so_24194076_24206844_6": {"length": 17, "quality": 1.0, "section_id": 7426}, "so_24194076_24194590_6": {"length": 4, "quality": 0.6666666666666666, "section_id": 468}, "so_24194076_24206844_3": {"length": 16, "quality": 0.7272727272727273, "section_id": 7272}, "so_24194076_24194076_1": {"length": 32, "quality": 0.9411764705882353, "section_id": 7675}, "so_24194076_24206844_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 7681}, "so_24194076_24196478_2": {"length": 7, "quality": 0.875, "section_id": 7681}, "so_24194076_24218798_0": {"length": 23, "quality": 0.8518518518518519, "section_id": 7675}}}, "24194590": {"Body": "<h3>About the description of <code>i = ++i + 1</code></h3>\n<blockquote>\n<p id=\"so_24194076_24194590_0\">I gather that the subtle explanation is that</p>\n<p id=\"so_24194076_24194590_1\">(1) the expression <code>++i</code> returns an lvalue but <code>+</code> takes prvalues as operands, so a conversion from lvalue to prvalue must be performed;</p>\n</blockquote>\n<p>Probably, see <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_active.html#1642\" rel=\"nofollow\">CWG active issue 1642</a>.</p>\n<blockquote>\n<p id=\"so_24194076_24194590_2\">this involves obtaining the\n  current value of that lvalue (rather than one more than the old value\n  of <code>i</code>) and must therefore be sequenced after the side effect from the\n  increment (i.e., updating <code>i</code>)</p>\n</blockquote>\n<p>The sequencing here is defined for the increment (indirectly, via <code>+=</code>, see <sup>(a)</sup>):\nThe side effect of <code>++</code> (the modification of <code>i</code>) is sequenced before the value computation of the whole expression <code>++i</code>. The latter refers to <em>computing the result of <code>++i</code></em>, not to <em>loading the value of <code>i</code></em>.</p>\n<blockquote>\n<p id=\"so_24194076_24194590_3\">(2) the LHS of the assignment is also an\n  lvalue, so its value evaluation does not involve fetching the current\n  value of <code>i</code>;\n  while this value computation is unsequenced w.r.t. the\n  value computation of the RHS, this poses no problem</p>\n</blockquote>\n<p>I don't think that's properly defined in the Standard, but I'd agree.</p>\n<blockquote>\n<p id=\"so_24194076_24194590_4\">(3) the value\n  computation of the assignment itself involves updating <code>i</code> (again),</p>\n</blockquote>\n<p>The value computation of <code>i = expr</code> is only required when you use the result, e.g. <code>int x = (i = expr);</code> or <code>(i = expr) = 42;</code>. The value computation itself does not modify <code>i</code>.</p>\n<p>The modification of <code>i</code> in the expression <code>i = expr</code> that happens because of the <code>=</code> is called the <em>side effect</em> of <code>=</code>. This side effect is sequenced before value computation of <code>i = expr</code> -- or rather <em>the value computation of <code>i = expr</code> is sequenced after the side effect of the assignment in <code>i = expr</code></em>.</p>\n<p>In general, the value computation of the operands of an expression are sequenced before the side effect of that expression, of course.</p>\n<blockquote>\n<p id=\"so_24194076_24194590_5\">but is sequenced after the value computation of its RHS, and hence after\n  the previous update to <code>i</code>; no problem.</p>\n</blockquote>\n<p>The <em>side effect</em> of the assignment <code>i = expr</code> is sequenced after the value computation of the operands <code>i</code> (A) and <code>expr</code> of the assignment.</p>\n<p>The <code>expr</code> in this case is a <code>+</code>-expression: <code>expr1 + 1</code>. The value computation of this expression is sequenced after the value computations of its operands <code>expr1</code> and <code>1</code>.</p>\n<p>The <code>expr1</code> here is <code>++i</code>. The value computation of <code>++i</code> is sequenced after the side effect of <code>++i</code> (the modification of <code>i</code>) (B)</p>\n<p><strong>That's why <code>i = ++i + 1</code> is safe</strong>: There's a chain of <em>sequenced before</em> between the value computation in (A) and the side effect on the same variable in (B).</p>\n<hr>\n<p><sup>(a)</sup> The Standard defines <code>++expr</code> in terms of <code>expr += 1</code>, which is defined as <code>expr = expr + 1</code> with <code>expr</code> being evaluated only once.</p>\n<p>For this <code>expr = expr + 1</code>, we therefore have only one value computation of <code>expr</code>. The side effect of <code>=</code> is sequenced before the value computation of the whole <code>expr = expr + 1</code>, and it's sequenced after the value computation of the operands <code>expr</code> (LHS) and <code>expr + 1</code> (RHS).</p>\n<p>This corresponds to my claim that for <code>++expr</code>, the side effect is sequenced before the value computation of <code>++expr</code>.</p>\n<hr>\n<h3>About <code>i += ++i + 1</code></h3>\n<blockquote>\n<p id=\"so_24194076_24194590_6\">Does the value computation of <code>i += ++i + 1</code> involve undefined behavior?</p>\n<p id=\"so_24194076_24194590_7\">Since the\n  LHS of <code>+=</code> is still an lvalue (and its RHS still a prvalue), the same\n  reasoning as above applies as far as (1) and (2) are concerned;\n  as for\n  (3) the value computation of the <code>+=</code> operator now must both fetch the\n  current value of <code>i</code>, and then (obviously sequenced after it, even if\n  the standard does not say so explicitly, or otherwise the execution of\n  such operators would always invoke undefined behavior) perform the\n  addition of the RHS and store the result back into <code>i</code>.</p>\n</blockquote>\n<p>I think here's the problem: The addition of <code>i</code> in the LHS of <code>i +=</code> to the result of <code>++i + 1</code> requires knowing the value of <code>i</code> - a value computation (which can mean loading the value of <code>i</code>). This value computation is unsequenced with respect to the modification performed by <code>++i</code>. This is essentially what you say in your alternative description, following the rewrite mandated by the Standard <code>i += expr</code> -&gt; <code>i = i + expr</code>. Here, the value computation of <code>i</code> within <code>i + expr</code> is unsequenced with respect to the value computation of <code>expr</code>. <strong>That's where you get UB</strong>.</p>\n<p>Please note that a value computation can have two results: The \"address\" of an object, or the value of an object. In an expression <code>i = 42</code>, the value computation of the lhs \"produces the address\" of <code>i</code>; that is, the compiler needs to figure out where to store the rhs (under the rules of observable behaviour of the abstract machine). In an expression <code>i + 42</code>, the value computation of <code>i</code> produces the value. In the above paragraph, I was referring to the second kind, hence [intro.execution]p15 applies:</p>\n<blockquote>\n<p id=\"so_24194076_24194590_8\">If a side effect on a scalar object is unsequenced relative to either\n  another side effect on the same scalar object or a value computation\n  using the value of the same scalar object, the behavior is undefined.</p>\n</blockquote>\n<hr>\n<h3>Another approach for <code>i += ++i + 1</code></h3>\n<blockquote>\n<p id=\"so_24194076_24194590_9\">the value computation of the <code>+=</code> operator now must both fetch the\n  current value of <code>i</code>, <strong>and <em>then</em> [...] perform the addition of the RHS</strong></p>\n</blockquote>\n<p>The RHS being <code>++i + 1</code>. Computing the result of this expression (the value computation) is unsequenced with respect to the value computation of <code>i</code> from the LHS. So the word <em>then</em> in this sentence is misleading: Of course, it must first load <code>i</code> and then add the result of the RHS to it. But there's no order between the side-effect of the RHS and the value computation to get the value of the LHS. For example, you could get for the LHS either the old or the new value of <code>i</code>, as modified by the RHS.</p>\n<p><strong>In general a store and a \"concurrent\" load is a data race, which leads to Undefined Behaviour.</strong></p>\n<hr>\n<h2>Addressing the addendum</h2>\n<blockquote>\n<p id=\"so_24194076_24194590_10\">using a fictive <code>|||</code> operator to designate unsequenced evaluations, one might try to define <code>E op= F;</code> (with int operands for simplicity) as equivalent to <code>{ int&amp; L=E ||| int R=F; L = L + R; }</code>, but then the example no longer has UB.</p>\n</blockquote>\n<p>Let <code>E</code> be <code>i</code> and <code>F</code> be <code>++i</code> (we don't need the <code>+ 1</code>). Then, for <code>i = ++i</code></p>\n<pre><code>int* lhs_address;\nint lhs_value;\nint* rhs_address;\nint rhs_value;\n\n    (         lhs_address = &amp;i)\n||| (i = i+1, rhs_address = &amp;i, rhs_value = *rhs_address);\n\n*lhs_address = rhs_value;\n</code></pre>\n<p>On the other hand, for <code>i += ++i</code></p>\n<pre><code>    (         lhs_address = &amp;i, lhs_value = *lhs_address)\n||| (i = i+1, rhs_address = &amp;i, rhs_value = *rhs_address);\n\nint total_value = lhs_value + rhs_value;\n*lhs_address = total_value;\n</code></pre>\n<p>This is intended to represent my understanding of the sequencing guarantees. Note that the <code>,</code> operator sequences all value computations and side effects of the LHS before those of the RHS. Parentheses do not affect sequencing. In the second case, <code>i += ++i</code>, we have a modification of <code>i</code> unsequenced wrt an lvalue-to-rvalue conversion of <code>i</code> =&gt; UB.</p>\n<blockquote>\n<p id=\"so_24194076_24194590_11\">The standard does not treat compound assignments as second-class primitives for which no separate definition of semantics is necessary.</p>\n</blockquote>\n<p>I would say that's a redundancy. The rewrite from <code>E1 op = E2</code> to <code>E1 = E1 op E2</code> also includes which expression types and value categories are required (on the rhs, 5.17/1 says something about the lhs), what happens to pointer types, the required conversions etc. The sad thing is that the sentence about \"With respect to an..\" in 5.17/1 is not in 5.17/7 as an exception of that equivalence.</p>\n<p>In any way, I think we should compare the guarantees and requirements for compound assignment vs. simple assignment plus the operator, and see if there's any contradiction.</p>\n<p>Once we put that \"With respect to an..\" also in the list of exceptions in 5.17/7, I don't think there's a contradiction.</p>\n<p>As it turns out, as you can see in the discussion of Marc van Leeuwen's answer, this sentence leads to the following interesting observation:</p>\n<pre><code>int i; // global\nint&amp; f() { return ++i; }\nint main() {\n    i  = i + f(); // (A)\n    i +=     f(); // (B)\n}\n</code></pre>\n<p>It seems that (A) has an two possible outcomes, since the evaluation of the body of <code>f</code> is indeterminately sequenced with the value computation of the <code>i</code> in <code>i + f()</code>.</p>\n<p>In (B), on the other hand, the evaluation of the body of <code>f()</code> is sequenced before the value computation of <code>i</code>, since <code>+=</code> must be seen as a single operation, and <code>f()</code> certainly needs to be evaluated before the assignment of <code>+=</code>.</p>\n</hr></hr></hr></hr>", "CreationDate": "2014-06-12T21:59:47.193", "ParentId": "24194076", "CommentCount": "22", "LastEditDate": "2016-08-01T11:33:52.113", "Id": "24194590", "PostTypeId": "2", "LastActivityDate": "2016-08-01T11:33:52.113", "LastEditorUserId": "420683", "CommunityOwnedDate": "2014-06-12T21:59:47.193", "Score": "16", "OwnerUserId": "420683"}});