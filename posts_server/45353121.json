post_cb({"45700164": {"ParentId": "45353121", "CommentCount": "2", "Body": "<p>Here's a minified version of the problem, that reproduces on <a href=\"https://godbolt.org/g/xnYN7h\" rel=\"nofollow noreferrer\">all compilers I threw at it</a>.</p>\n<pre><code>#include &lt;stddef.h&gt;\n\nstruct myString\n{\n    operator char *( );\n    char&amp; operator[]( unsigned ptrdiff_t );\n};\n\nint main()\n{\n    myString str;\n    if( str[(ptrdiff_t) 0] == 'a' ) return 0; //error, multiple valid overloads\n}\n</code></pre>\n<p>Basically, you have two candidate functions to get the <code>char</code> for <code>bool operator==(char,char)</code>: <a href=\"http://eel.is/c++draft/over.match.oper#3\" rel=\"nofollow noreferrer\">[over.match.oper]/3</a></p>\n<ul>\n<li><code>char&amp; myString::operator[]( unsigned ptrdiff_t )</code> (<a href=\"http://eel.is/c++draft/over.match.oper#3.1\" rel=\"nofollow noreferrer\">[over.match.oper]/3.1</a> =&gt; <a href=\"http://eel.is/c++draft/over.sub\" rel=\"nofollow noreferrer\">[over.sub]</a>)</li>\n<li><code>char&amp; operator[]( char*, ptrdiff_t)</code> (<a href=\"http://eel.is/c++draft/over.match.oper#3.3\" rel=\"nofollow noreferrer\">[over.match.oper]/3.3</a> =&gt; <a href=\"http://eel.is/c++draft/over.built#14\" rel=\"nofollow noreferrer\">[over.built]/14</a>)</li>\n</ul>\n<p>Note that if <code>myString::operator[]</code> took a <code>ptrdiff_t</code> instead of an <code>unsigned ptrdiff_t</code>, then it would have hidden the built-in operator per <a href=\"http://eel.is/c++draft/over.built#1\" rel=\"nofollow noreferrer\">[over.built]/1</a>. So if all you want to do is avoid issues like this, simply ensure any <code>operator[]</code> overload that takes an integral value, takes a <code>ptrdiff_t</code>.</p>\n<p>I'll skip the viability check <a href=\"http://eel.is/c++draft/over.match.viable\" rel=\"nofollow noreferrer\">[over.match.viable]</a>, and go straight to conversion ranking.</p>\n<h1><code>char&amp; myString::operator[]( unsigned ptrdiff_t )</code></h1>\n<p>For overloading, this is considered to have a leading implicit object paramter, so the signature to be matched is\n<code>(myString&amp;, unsigned ptrdiff_t)</code></p>\n<h2><code>myString&amp;</code> =&gt; <code>myString&amp;</code></h2>\n<p>Standard conversion sequence: <strong><a href=\"http://eel.is/c++draft/over.ics.ref#1\" rel=\"nofollow noreferrer\">Identity</a></strong> (Rank: <em>Exact match</em>) - directly bound reference</p>\n<h2><code>ptrdiff_t</code> =&gt; <code>unsigned ptrdiff_t</code></h2>\n<p>Standard conversion sequence: <strong><a href=\"http://eel.is/c++draft/conv.lval\" rel=\"nofollow noreferrer\">Lvalue Transformation</a> -&gt; <a href=\"http://eel.is/c++draft/conv.integral\" rel=\"nofollow noreferrer\">Integral conversion</a></strong> (Rank: <em>Conversion</em>) - signed lvalue to unsigned prvalue</p>\n<h1><code>char&amp; operator[]( char*, ptrdiff_t)</code></h1>\n<h2><code>myString&amp;</code> =&gt; <code>char*</code></h2>\n<p><a href=\"http://eel.is/c++draft/over.ics.user\" rel=\"nofollow noreferrer\">User-defined conversion sequence</a>: <strong><a href=\"http://eel.is/c++draft/over.ics.ref#1\" rel=\"nofollow noreferrer\">Identity</a></strong> + <a href=\"http://eel.is/c++draft/class.conv.fct\" rel=\"nofollow noreferrer\"><code>operator char*(myString&amp;)</code></a></p>\n<p>Note that per <a href=\"http://eel.is/c++draft/over.match.oper#7\" rel=\"nofollow noreferrer\">[over.match.oper]/7</a> we don't get a second standard conversion sequence.</p>\n<h2><code>ptrdiff_t</code> =&gt; <code>ptrdiff_t</code></h2>\n<p>Standard conversion sequence: <strong>Identity</strong> (Rank: <em>Exact match</em>)</p>\n<h1><a href=\"http://eel.is/c++draft/over.match.best\" rel=\"nofollow noreferrer\">Best viable function</a></h1>\n<h2>First argument</h2>\n<p>Standard Conversion Sequence is better than User-defined conversion sequence (<a href=\"http://eel.is/c++draft/over.ics.rank#2.1\" rel=\"nofollow noreferrer\">[over.ics.rank]/2.1</a>)</p>\n<h2>Second argument</h2>\n<p>Rank Conversion is worse than Rank Exact Match (<a href=\"http://eel.is/c++draft/over.ics.rank#3.2.2\" rel=\"nofollow noreferrer\">[over.ics.rank]/3.2.2</a>)</p>\n<h1>Result</h1>\n<p>We cannot satisfy the <a href=\"http://eel.is/c++draft/over.match.best#1\" rel=\"nofollow noreferrer\">requirement</a></p>\n<blockquote>\n<p id=\"so_45353121_45700164_0\">if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2)</p>\n</blockquote>\n<p>so neither function is a better function.</p>\n<p>Hence, per <a href=\"http://eel.is/c++draft/over.match.best#2\" rel=\"nofollow noreferrer\">[over.match.best]/2</a> it's <strong>ambiguous</strong>.</p>\n<hr>\n<h1>How to fix this?</h1>\n<p>Well, the easiest solution is to <strong>never</strong> let the parameter to an <code>operator[]</code> overload be something that could be converted to from <code>ptrdiff_t</code> by something other than an <em>Exact Match</em>-ranked conversion. Looking at <a href=\"http://eel.is/c++draft/over.best.ics#tab:over.conversions\" rel=\"nofollow noreferrer\">the conversions table</a> that appears to mean that you should always declare your <code>operator[]</code> member function as <code>X&amp; T::operator[]( ptrdiff_t )</code>. That covers the usual use-case of \"Act like an array\". As noted above, using precisely <code>ptrdiff_t</code> will suppress even <em>searching</em> for an <code>operator T*</code> candidate by taking the built-in subscript operator off the table.</p>\n<p>The other option is to not have both <code>T1 operator[]</code> and <code>operator T2*</code> defined for the class, where <code>T1</code> and <code>T2</code> may both fulfill the same parameter of a (possibly implicit) function call. That covers cases where you are using <code>operator[]</code> for clever syntactic things, and end up with things like <a href=\"http://gameangst.com/?p=107\" rel=\"nofollow noreferrer\"><code>T T::operator[](X)</code></a>. If <code>X::operator ptrdiff_t()</code> exists for example, and so does <code>T::operator T*()</code>, then you're ambiguous again.</p>\n<p>The only use-case for <code>T::operator T*()</code> I can imagine is if you want your type to implicitly convert into a pointer to itself, like a function. <strong>Don't do that...</strong></p>\n</hr>", "OwnerUserId": "166389", "PostTypeId": "2", "Id": "45700164", "Score": "1", "CreationDate": "2017-08-15T19:30:42.810", "LastActivityDate": "2017-08-15T19:30:42.810"}, "45353121": {"CommentCount": "12", "ViewCount": "73", "PostTypeId": "1", "LastEditorUserId": "2294936", "CreationDate": "2017-07-27T14:02:25.347", "LastActivityDate": "2017-08-15T19:30:42.810", "Title": "c++ overload resolution and constness", "AcceptedAnswerId": "45700164", "LastEditDate": "2017-07-27T14:18:34.700", "Id": "45353121", "Score": "3", "Body": "<p>(all tests are performed on Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24215.1 for x86)</p>\n<p>consider this minimal example:</p>\n<pre><code>struct myString\n{\n    operator const char *( ) const { return &amp;dummy; }\n    char&amp; operator[]( unsigned int ) { return dummy; }\n    const char&amp; operator[]( unsigned int ) const { return dummy; }\n\n    char dummy;\n};\n\nint main()\n{\n    myString str;\n    const char myChar = 'a';\n\n    if( str[(int) 0] == myChar ) return 0; //error, multiple valid overloads\n}\n</code></pre>\n<p>according to overload resolution rules (from cppreference)</p>\n<blockquote>\n<p id=\"so_45353121_45353121_0\">F1 is determined to be a better function than F2 if implicit\n  conversions for all arguments of F1 are not worse than the implicit\n  conversions for all arguments of F2, and </p>\n<p id=\"so_45353121_45353121_1\">1) there is at least one\n  argument of F1 whose implicit conversion is better than the\n  corresponding implicit conversion for that argument of F2 </p>\n<p id=\"so_45353121_45353121_2\">2) or. if\n  not that, (only in context of non-class initialization by conversion),\n  the standard conversion sequence from the return type of F1 to the\n  type being initialized is better than the standard conversion sequence\n  from the return type of F2</p>\n</blockquote>\n<p><code>char&amp; operator[]( unsigned int )</code> should be better, according to 1). </p>\n<p>Of the two arguments (this = myString) do not need to be converted at all while <code>operator const char *( ) const</code> converts it to const char* and <code>const char&amp; operator[]( unsigned int ) const</code> converts it to const myString, therefore there is one argument without any implicit conversion, which happens to be the best conversion</p>\n<p>However my compiler yells the following error:</p>\n<pre><code>1&gt;  [///]\\sandbox\\sandbox\\sandbox.cpp(29): error C2666: 'myString::operator []': 3 overloads have similar conversions\n1&gt;  [///]\\sandbox\\sandbox\\sandbox.cpp(19): note: could be 'const char &amp;myString::operator [](unsigned int) const'\n1&gt;  [///]\\sandbox\\sandbox\\sandbox.cpp(18): note: or       'char &amp;myString::operator [](unsigned int)'\n1&gt;  [///]\\sandbox\\sandbox\\sandbox.cpp(29): note: while trying to match the argument list '(myString, int)'\n</code></pre>\n<p>also note that using <code>if( str[0u] == myChar ) return 0;</code> or removing <code>operator const char *( ) const</code> resolve the error</p>\n<p>why is there an error here and what am I getting wrong about overload resolution rules?</p>\n<p>edit: it might be a visual C++ bug in this version, any definitive confirmation on this?</p>\n", "Tags": "<c++><language-lawyer><overload-resolution>", "OwnerUserId": "2294936", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_45353121_45353121_2": {"section_id": 603, "quality": 0.9411764705882353, "length": 16}, "so_45353121_45700164_0": {"section_id": 603, "quality": 0.75, "length": 6}}, "n3337": {"so_45353121_45353121_2": {"section_id": 593, "quality": 0.9411764705882353, "length": 16}, "so_45353121_45700164_0": {"section_id": 593, "quality": 0.75, "length": 6}}, "n4659": {"so_45353121_45353121_2": {"section_id": 629, "quality": 0.9411764705882353, "length": 16}, "so_45353121_45353121_1": {"section_id": 660, "quality": 0.5384615384615384, "length": 7}, "so_45353121_45700164_0": {"section_id": 629, "quality": 0.75, "length": 6}}}});