post_cb({"bq_ids": {"n4140": {"so_46933091_46933478_0": {"length": 5, "quality": 0.625, "section_id": 5451}}, "n4659": {"so_46933091_46933478_0": {"length": 8, "quality": 1.0, "section_id": 6887}}}, "46933478": {"Id": "46933478", "PostTypeId": "2", "LastEditDate": "2017-10-25T15:47:26.157", "CommentCount": "10", "LastEditorUserId": "598696", "LastActivityDate": "2017-10-25T15:47:26.157", "CreationDate": "2017-10-25T13:15:51.097", "ParentId": "46933091", "Score": "15", "Body": "<p>In <a href=\"http://eel.is/c++draft/dcl.type.auto.deduct#:deduction,placeholder_type\" rel=\"noreferrer\">[dcl.type.auto.deduct]</a>: </p>\n<blockquote>\n<p id=\"so_46933091_46933478_0\">A type <code>T</code> containing a placeholder type, and a corresponding initializer <code>e</code>, are determined as follows:</p>\n<ul>\n<li>for a non-type template parameter declared with a type that contains a placeholder type, <code>T</code> is the declared type of the non-type template parameter and <code>e</code> is the corresponding template argument.</li>\n</ul>\n</blockquote>\n<p>This seems to suggest that the deduced type would be <code>decltype(Enum1::Value)</code>, and the value would be <code>Enum1::Value</code>.</p>\n<hr>\n<p>Is <code>decltype(Enum1::Value)</code> equal to <code>decltype(Enum2::Value)</code>? This code...</p>\n<pre><code>static_assert(std::is_same_v&lt;decltype(Enum1::Value), decltype(Enum2::Value)&gt;);\n</code></pre>\n<p>...fails to compile with both <strong>clang++ 6</strong> and <strong>g++ 8</strong>. </p>\n<hr>\n<p>I <em>think</em> that you <em>might</em> have exposed a bug in gcc. As <a href=\"https://stackoverflow.com/users/34509/johannes-schaub-litb\">Johannes Schaub</a> pointed out in the comments, there's also a <a href=\"http://eel.is/c++draft/temp.type\" rel=\"noreferrer\">paragraph in favour of gcc's behavior</a>.</p>\n<p>There's a bug report open: <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=79092\" rel=\"noreferrer\"><strong>#79092</strong></a>.</p>\n<hr>\n<p>Also note that the following code is accepted by both compilers:</p>\n<pre><code>template &lt;typename T, T&gt; struct Foo;\ntemplate &lt;&gt; struct Foo&lt;decltype(Enum1::Value), Enum1::Value&gt; { };\ntemplate &lt;&gt; struct Foo&lt;decltype(Enum2::Value), Enum2::Value&gt; { };\n</code></pre>\n<p><code>template &lt;auto&gt;</code> behaving differently from that would be (IMHO) suprising and undesired.</p>\n</hr></hr></hr>", "OwnerUserId": "598696"}, "46933091": {"ViewCount": "349", "LastEditDate": "2017-10-25T13:52:13.263", "AcceptedAnswerId": "46933478", "Title": "Is it allowed to specialize a template with enums with the same integral value?", "CreationDate": "2017-10-25T12:56:15.097", "LastActivityDate": "2017-10-25T15:47:26.157", "CommentCount": "0", "Body": "<p>Look at this simple snippet:</p>\n<pre><code>enum class Enum1 { Value };\nenum class Enum2 { Value };\ntemplate &lt;auto&gt; struct Foo;\ntemplate &lt;&gt; struct Foo&lt;Enum1::Value&gt; { };\ntemplate &lt;&gt; struct Foo&lt;Enum2::Value&gt; { };\n</code></pre>\n<p>Clang compiles this, but gcc-7.2 fails:</p>\n<blockquote>\n<p id=\"so_46933091_46933091_0\">x.cpp:5:20: error: redefinition of \u2018struct Foo&lt;(Enum1)0&gt;\u2019  template &lt;&gt;\n  struct Foo { };</p>\n</blockquote>\n<p>This error message seems invalid, as at line 5, <code>Enum2::Value</code> is written.</p>\n<p>Which compiler is correct? Is this conforming code?</p>\n", "PostTypeId": "1", "LastEditorUserId": "598696", "Id": "46933091", "AnswerCount": "1", "Score": "16", "OwnerUserId": "8157187", "Tags": "<c++><language-lawyer><c++1z>", "FavoriteCount": "3"}});