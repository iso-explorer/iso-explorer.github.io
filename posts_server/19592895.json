post_cb({"19593095": {"ParentId": "19592895", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>First, </p>\n<blockquote>\n<p id=\"so_19592895_19593095_0\">fffffffe in hexadecimal which is basically 2^32</p>\n</blockquote>\n<p>is wrong.  FFFFFFFE = 4294967294, which is 2^32 - 2 (for unsigned integers), or -2 (for 32-bit signed integers in 2's complement).</p>\n<p>Second, <code>printf(\"%x\", ...)</code> will print an unsigned hexadecimal integer (that is an <code>unsigned int</code>), which is 32-bits on most modern systems.  <code>long long a = 2 &lt;&lt; 32</code> requires a 64-bit integer to properly store it (or, more precisely, at least a 33-bit integer), so when you use <code>cout &lt;&lt; a</code>, you are calling <code>ostream&amp; operator&lt;&lt;(ostream&amp;, long long)</code>, which has the proper type.  That is, you are running into an overflow issue because of the type used by the printf specifier vs the strong type used by the C++ <code>operator&lt;&lt;</code> overload.</p>\n", "OwnerUserId": "529761", "LastEditorUserId": "529761", "LastEditDate": "2013-10-25T14:56:46.853", "Id": "19593095", "Score": "1", "CreationDate": "2013-10-25T14:51:20.253", "LastActivityDate": "2013-10-25T14:56:46.853"}, "19592975": {"ParentId": "19592895", "CommentCount": "0", "Body": "<p><code>%x</code> formats the output to show the value in hexadecimal, so you should pass <code>std::hex</code> to <code>cout</code> to do a same thing:</p>\n<pre><code>std::cout &lt;&lt; std:::hex &lt;&lt; (-1&lt;&lt;1) &lt;&lt; endl;\n             ^^^^^^^^^\n</code></pre>\n", "OwnerUserId": "952747", "PostTypeId": "2", "Id": "19592975", "Score": "0", "CreationDate": "2013-10-25T14:46:26.247", "LastActivityDate": "2013-10-25T14:46:26.247"}, "19593012": {"ParentId": "19592895", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The <code>printf</code> format flag <code>%x</code> means to print an integral value in hexadecimal.</p>\n<p>There is a stream manipulator to accomplish this as well (<code>std::hex</code>), but you're not using that. When you output an integral value to a stream with no manipulators, it outputs in base 10.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/io/c/fprintf\" rel=\"nofollow\">See here</a> for more information about the <code>printf</code> format flags, <a href=\"http://en.cppreference.com/w/cpp/io/manip\" rel=\"nofollow\">and here</a> for information about stream manipulators.</p>\n<p>The shift operator <code>&lt;&lt;</code> works as described in the C++03 Standard (14882:2003):</p>\n<h2>5.8 Shift operators</h2>\n<blockquote>\n<p id=\"so_19592895_19593012_0\">1/ The shift operators &lt;&lt; and &gt;&gt; group left-to-right.\n      shift-expression:\n          additive-expression\n          shift-expression &lt;&lt; additive-expression\n          shift-expression &gt;&gt; additive-expression</p>\n<p id=\"so_19592895_19593012_1\">The operands shall be of integral or enumeration type and integral\n  promotions are performed. The type of the result is that of the\n  promoted left operand. The behavior is undefined if the right operand\n  is negative, or greater than or equal to the length in bits of the\n  promoted left operand.</p>\n<p id=\"so_19592895_19593012_2\">2/ The value of E1 &lt;&lt; E2 is E1 (interpreted as a bit pattern)\n  left-shifted E2 bit positions; vacated bits are zero-filled. If E1 has\n  an unsigned type, the value of the result is E1 multiplied by the\n  quantity 2 raised to the power E2, reduced modulo ULONG_MAX+1 if E1\n  has type unsigned long, UINT_MAX+1 otherwise.</p>\n<p id=\"so_19592895_19593012_3\">[Note: the constants ULONG_MAX and UINT_MAX are defined in the header\n  ). ]</p>\n</blockquote>\n<p>In your case, the value <code>-1</code> in binary is all <code>1</code>s in every bit.  For a 32 bit value, then:</p>\n<pre><code>11111111 11111111 11111111 11111111 \n</code></pre>\n<p>If you shift this left 1 bit using <code>&lt;&lt;</code>, you get:</p>\n<pre><code>11111111 11111111 11111111 11111110 \n</code></pre>\n<p>Which in base 10 is -2.  Since the operation <code>-1&lt;&lt;1</code> uses a negative number for the LHS, the entire expression is of a signed (not unsigned) type.</p>\n", "OwnerUserId": "241536", "LastEditorUserId": "241536", "LastEditDate": "2013-10-25T15:15:25.503", "Id": "19593012", "Score": "4", "CreationDate": "2013-10-25T14:48:14.150", "LastActivityDate": "2013-10-25T15:15:25.503"}, "19593043": {"ParentId": "19592895", "CommentCount": "0", "Body": "<p>%x is hex where as the cout are just outputting the numbers (int) directly\n-1 is 0xFFFFFFFF shift that to the left you have to add in a 0 \nie so the last F (in binary is 1111 becomes 1110 ie E\nThe other guys answer your points clearer I think....</p>\n", "OwnerUserId": "246659", "PostTypeId": "2", "Id": "19593043", "Score": "0", "CreationDate": "2013-10-25T14:49:03.220", "LastActivityDate": "2013-10-25T14:49:03.220"}, "19593037": {"ParentId": "19592895", "CommentCount": "0", "Body": "<p>This will produce the correct same answer as you need to tell it to print in hex</p>\n<pre><code>cout &lt;&lt; hex&lt;&lt;(-1&lt;&lt;1)&lt;&lt;endl;\nprintf(\"%x\",-1&lt;&lt;1);\n</code></pre>\n", "OwnerUserId": "2724573", "PostTypeId": "2", "Id": "19593037", "Score": "0", "CreationDate": "2013-10-25T14:48:54.810", "LastActivityDate": "2013-10-25T14:48:54.810"}, "19593334": {"ParentId": "19592895", "CommentCount": "0", "Body": "<p>The first case is valid: <code>pow(2,32)</code> returns the exact value 2<sup>32</sup> as a <code>double</code>, which remains exact when you convert it to <code>long long</code> (I'm assuming that's what the mystery <code>ll</code> type is). Printing this with <code>cout</code> is perfectly valid.</p>\n<p>In the case of <code>(-1&lt;&lt;1)</code>, left-shifting a negative number yields undefined behavior. Even if the compiler does define it as -2 (most will), it's also undefined behavior to pass a negative number for use with <code>printf</code>'s <code>%x</code> specifier (which requires an unsigned type).</p>\n", "OwnerUserId": "379897", "PostTypeId": "2", "Id": "19593334", "Score": "0", "CreationDate": "2013-10-25T15:01:49.383", "LastActivityDate": "2013-10-25T15:01:49.383"}, "19593367": {"ParentId": "19592895", "PostTypeId": "2", "CommentCount": "15", "Body": "<p>This code invokes <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow\">undefined behavior</a> since you are trying to <em>left shift</em> a negative number, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">the draft C++11 Standard</a>  section <code>5.8</code> <em>Shift operators</em> says(<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_19592895_19593367_0\">The value of E1 &lt;&lt; E2 is E1 left-shifted E2 bit positions; vacated\n  bits are zero-filled. If E1 has an unsigned type, the value of the\n  result is E1 \u00d7 2E2, reduced modulo one more than the maximum value\n  representable in the result type. Otherwise, if <strong>E1 has a signed type\n  and non-negative value</strong>, and E1\u00d72E2 is representable in the result\n  type, then that is the resulting value; otherwise, <strong>the behavior is\n  undefined</strong>.</p>\n</blockquote>\n<p>This is also the same for the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"nofollow\">draft C99 standard</a> section <code>6.5.7</code> <em>Bitwise shift operators</em></p>\n<p>It is also <em>undefined behavior</em> to specify an <em>invalid</em> conversion specifier to <code>printf</code>, you are specifying <code>%x</code> which expect an <em>unsigned int</em> but the result is <em>signed</em>. The <em>C99 draft</em> in section <code>7.19.6.1</code> <em>The fprintf function</em> paragraph <em>9</em> says:</p>\n<blockquote>\n<p id=\"so_19592895_19593367_1\">If a conversion specification is invalid, the behavior is undefined.248) If any argument is not the correct type for the corresponding conversion specification, the behavior is\n  undefined.</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2013-10-25T16:19:05.723", "Id": "19593367", "Score": "1", "CreationDate": "2013-10-25T15:03:45.327", "LastActivityDate": "2013-10-25T16:19:05.723"}, "19592895": {"CommentCount": "3", "AcceptedAnswerId": "19593012", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2013-10-25T14:43:20.707", "LastActivityDate": "2013-10-29T19:23:19.657", "LastEditDate": "2013-10-29T19:23:19.657", "ViewCount": "447", "FavoriteCount": "0", "Title": "Why does printf and cout gives different output for this code?", "Id": "19592895", "Score": "-1", "Body": "<pre><code>int main(){\n    ll a=pow(2,32);\n    cout &lt;&lt;a&lt;&lt;endl;\n    cout &lt;&lt; (-1&lt;&lt;1)&lt;&lt;endl;\n    printf(\"%x\",-1&lt;&lt;1);\n}\n</code></pre>\n<p>For the above code, I am getting following output:</p>\n<pre><code>4294967296\n-2\nfffffffe\n</code></pre>\n<p><code>4294967296</code> in decimal is equal to <code>fffffffe</code> in hexadecimal which is basically <code>2^32</code>. Why is printf and cout behaving differently? And how exactly does this shift works?</p>\n", "Tags": "<c++><bit-shift>", "OwnerUserId": "1425223", "AnswerCount": "8"}, "bq_ids": {"n4140": {"so_19592895_19593012_1": {"section_id": 6146, "quality": 0.8928571428571429, "length": 25}, "so_19592895_19593012_2": {"section_id": 6147, "quality": 0.5925925925925926, "length": 16}, "so_19592895_19593367_0": {"section_id": 6147, "quality": 0.9210526315789473, "length": 35}, "so_19592895_19593012_0": {"section_id": 6146, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_19592895_19593012_1": {"section_id": 5909, "quality": 0.8928571428571429, "length": 25}, "so_19592895_19593012_2": {"section_id": 5910, "quality": 0.5555555555555556, "length": 15}, "so_19592895_19593367_0": {"section_id": 5910, "quality": 0.9210526315789473, "length": 35}, "so_19592895_19593012_0": {"section_id": 5909, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_19592895_19593012_1": {"section_id": 7642, "quality": 0.8928571428571429, "length": 25}, "so_19592895_19593012_2": {"section_id": 7643, "quality": 0.5925925925925926, "length": 16}, "so_19592895_19593367_0": {"section_id": 7643, "quality": 0.9210526315789473, "length": 35}, "so_19592895_19593012_0": {"section_id": 7642, "quality": 0.8181818181818182, "length": 9}}}, "19593235": {"ParentId": "19592895", "CommentCount": "0", "Body": "<p>For the sake of readbility let's use a signed 8bit integer:</p>\n<pre><code>-1 bitwise is 11111111\n</code></pre>\n<p>now doing a left-shift by 1:</p>\n<pre><code>-1 &lt;&lt; 1\n</code></pre>\n<p>you get:</p>\n<pre><code>11111110 which is -2\n</code></pre>\n<p>However using the the conversion specifier <code>%x</code> tells <code>printf()</code> to tread <code>11111111</code> as <strong>un</strong>-signed so it prints out <code>fe</code>.</p>\n", "OwnerUserId": "694576", "PostTypeId": "2", "Id": "19593235", "Score": "0", "CreationDate": "2013-10-25T14:56:59.170", "LastActivityDate": "2013-10-25T14:56:59.170"}});