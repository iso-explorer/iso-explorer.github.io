post_cb({"bq_ids": {"n4140": {"so_31129781_31163087_1": {"length": 7, "quality": 1.0, "section_id": 7114}, "so_31129781_31163087_2": {"length": 5, "quality": 1.0, "section_id": 7114}}, "n3337": {"so_31129781_31163087_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 574}, "so_31129781_31163087_2": {"length": 5, "quality": 1.0, "section_id": 6858}}, "n4659": {"so_31129781_31163087_1": {"length": 7, "quality": 1.0, "section_id": 8615}, "so_31129781_31163087_2": {"length": 5, "quality": 1.0, "section_id": 8615}}}, "31129781": {"ViewCount": "280", "Body": "<p>I have a templated base class that takes an N amount of types:  </p>\n<pre><code>template &lt;typename... Ts&gt;\nclass Base{};\n</code></pre>\n<p>When using protected inheritance on that base class,</p>\n<pre><code>template &lt;typename... Ts&gt;\nclass Derived : protected Base&lt;Ts...&gt;{\n   //like so...\n};\n</code></pre>\n<p>I would like to additionally include the public constructors of the base class:  </p>\n<pre><code>template &lt;typename... Ts&gt;\nclass Derived : protected Base&lt;Ts...&gt;{\n\n   //create an alias\n   using Parent = Base&lt;Ts...&gt;;\n\n   //get all constructors as well\n   using Parent::Parent; \n};\n</code></pre>\n<p>This works.<br>\nHowever, why must I include the <code>Parent</code> alias?  </br></p>\n<p>Is doesn't seem as though I can get the constructors without it.  The following attempt does not work:  </p>\n<pre><code>template &lt;typename... Ts&gt;\nclass Derived : protected Base&lt;Ts...&gt;{\n\n   //get all constructors as well\n   using Base&lt;Ts...&gt;::Base&lt;Ts...&gt;; \n};\n</code></pre>\n<p><strong>error:</strong></p>\n<pre><code>clang++ -std=c++1z -o main v.cpp\nerror: expected ';' after using declaration\n       using Base&lt;Ts...&gt;::Base&lt;Ts...&gt;; \n                              ^\n                              ;\n1 error generated.\n</code></pre>\n<p>I can cut off the template part, and it compiles, but this does not appear to be correct:   </p>\n<pre><code>template &lt;typename... Ts&gt;\nclass Derived : protected Base&lt;Ts...&gt;{\n\n   //get all constructors as well\n   using Base&lt;Ts...&gt;::Base; \n};\n</code></pre>\n<p>The reason I don't think it is correct is because it does not appear to work on vector.<br>\n<strong>does not compile:</strong> </br></p>\n<pre><code>template &lt;typename... Ts&gt;\nclass Derived : protected std::vector&lt;Ts...&gt;{\n\n   //get all constructors as well\n   using std::vector&lt;Ts...&gt;::std::vector; \n};\n</code></pre>\n<p>However, using an alias does work.<br>\n<strong>compiles:</strong> </br></p>\n<pre><code>template &lt;typename... Ts&gt;\nclass Derived : protected std::vector&lt;Ts...&gt;{\n\n   //create an alias\n   using Parent = std::vector&lt;Ts...&gt;;\n\n   //get all constructors as well\n   using Parent::Parent; \n};\n</code></pre>\n<p><strong>Question:</strong><br>\nDo I have to use an alias to get the same functionally, or is there a way to inline this without creating a new name for the base type?  </br></p>\n", "AcceptedAnswerId": "31129937", "Title": "Why must I create a type alias when using a variadic constructor function?", "CreationDate": "2015-06-30T04:47:47.850", "Id": "31129781", "CommentCount": "6", "LastEditDate": "2015-06-30T04:51:55.013", "PostTypeId": "1", "LastEditorUserId": "908939", "LastActivityDate": "2015-07-01T16:34:43.770", "Score": "4", "OwnerUserId": "908939", "Tags": "<c++><templates><inheritance><variadic-templates><c++14>", "AnswerCount": "3"}, "31160676": {"Id": "31160676", "PostTypeId": "2", "Body": "<p>You don't need a type alias. The problem is that the constuctor of <code>Base&lt;Ts...&gt;</code> is not called <code>Base&lt;Ts...&gt;</code>. It's called <code>Base</code>.</p>\n<p>This works:</p>\n<pre><code>template&lt;class...Ts&gt;\nstruct Base {\n\n};\n\ntemplate&lt;class...Ts&gt;\nstruct Derived : Base&lt;Ts...&gt;\n{\n    using Base&lt;Ts...&gt;::Base;\n};\n</code></pre>\n<p>In addition, the name of <code>std::vector&lt;...&gt;</code>'s constructor is not <code>std::vector</code>, it is <code>vector</code></p>\n<p>This also works:</p>\n<pre><code>template&lt;class...Ts&gt;\nstruct Derived : std::vector&lt;Ts...&gt;\n{\n    using std::vector&lt;Ts...&gt;::vector;\n};\n</code></pre>\n<p>However, <em>don't derive from std:: containers!</em> Encapsulate them.</p>\n", "LastEditorUserId": "2015579", "LastActivityDate": "2015-07-01T12:04:25.643", "Score": "4", "CreationDate": "2015-07-01T11:59:27.817", "ParentId": "31129781", "CommentCount": "3", "OwnerUserId": "2015579", "LastEditDate": "2015-07-01T12:04:25.643"}, "31129937": {"Id": "31129937", "PostTypeId": "2", "Body": "<p>In your example <code>Base</code> does not have a template constructor so <code>using Base&lt;Ts...&gt;::Base&lt;Ts...&gt;;</code> is trying to find a constructor that does not exist.</p>\n<p>Imagine I had a class <em>like</em> yours</p>\n<pre><code>class Base{\n    public:\n        Base(){}\n\n        template&lt;typename ... Ts&gt;\n        Base(){}\n};\n</code></pre>\n<p>Which constructor would <code>using Base&lt;Ts...&gt;::Base&lt;Ts...&gt;</code> choose?</p>\n<p>The reason that <code>using Parent = Base&lt;Ts...&gt;</code> works is because when you write <code>using Parent::Parent</code> you are trying to find a constructor of <code>Parent</code> that is <em>not</em> templated. It expands to <code>using Base&lt;Ts...&gt;::Base;</code>.</p>\n", "LastActivityDate": "2015-06-30T05:03:51.487", "CommentCount": "4", "CreationDate": "2015-06-30T05:03:51.487", "ParentId": "31129781", "Score": "2", "OwnerUserId": "2297448"}, "31163087": {"Id": "31163087", "PostTypeId": "2", "Body": "<p><code>using Base&lt;Ts...&gt;::Base&lt;Ts...&gt;;</code> is illegal because of a very general rule in [namespace.udecl]p5:</p>\n<blockquote>\n<p id=\"so_31129781_31163087_0\">A <em>using-declaration</em> shall not name a <em>template-id</em>.</p>\n</blockquote>\n<p>This is very similar to the fact that you cannot name a specific overload in using-declarations. However, I do not know the rationale for this rule.</p>\n<hr>\n<p>The relation between constructors and names... is complicated:</p>\n<ul>\n<li>\"Constructors do not have names.\" <sup>[class.ctor]p1</sup></li>\n<li>\"The point of declaration of a <em>using-declaration</em> that does not name a constructor [...]\" <sup>[class.ctor]p4</sup></li>\n</ul>\n<p>So while constructors do not <em>have names</em>, they can <em>be named</em>. To me, this seems similar to anonymous types:</p>\n<pre><code>struct { int m; } x;\ndecltype(x) // refers to the type of `x` which has no name\n</code></pre>\n<p>A <em>using-declaration</em> that shall inherit constructors must <em>name a constructor</em>.</p>\n<hr>\n<p>[class.qual]p2 specifies how a constructor can be named in qualified-ids (consisting of a <em>nested-name-specifier</em> and an <em>unqualified-id</em>):</p>\n<blockquote>\n<p id=\"so_31129781_31163087_1\">In a lookup in which function names are not ignored and the\n  <em>nested-name-specifier</em> nominates a class <code>C</code>:</p>\n<ul>\n<li>(2.1) if the name specified after the <em>nested-name-specifier</em>, when looked up in <code>C</code>, is the <em>injected-class-name</em> of <code>C</code>, or</li>\n<li>(2.2) in a <em>using-declaration</em> that is a <em>member-declaration</em>, if the name specified after the <em>nested-name-specifier</em> is the same as\n  the <em>identifier</em> or the <em>simple-template-id</em>\u2019s <em>template-name</em> in the last\n  component of the <em>nested-name-specifier</em>,</li>\n</ul>\n<p id=\"so_31129781_31163087_2\">the name is instead considered to name the constructor of class <code>C</code>.</p>\n</blockquote>\n<p>To address/comment some other answers, I'll digress a bit..</p>\n<p>One can argue that (2.1) does not apply in the OP: while <code>Base</code> contains an <em>injected-class-name</em>, this name is <code>Base</code> and not <code>Base&lt;Ts...&gt;</code>. The name specified after the <em>nested-name-specifier</em> is <code>Base&lt;Ts...&gt;</code>, which is not the <em>injected-class-name</em>.</p>\n<p>Note that the <em>injected-class-name</em> of a dependent base class is not known until instantiation time. Consider</p>\n<pre><code>template&lt;typename T&gt;\nstruct foo : T {\n    using T::name;\n    void name(double);\n};\n\nstruct name { name(int); };\nstruct bar { void name(int); };\n\nfoo&lt;name&gt; // constructor inheritance?\nfoo&lt;bar&gt;  // makes a function visible?\n</code></pre>\n<p>clang++ rejects this example, while g++ accepts it. This is <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_active.html#2070\" rel=\"nofollow\">CWG 2070</a></p>\n<p>We do know however at the point of definition that <code>Base</code> in the OP is a class, and therefore could <em>infer</em> the <em>injected-class-name</em>. This would require a distinction between types whose name is know at the point of definition and those where it is not. Alias templates can hide this, so this is not a trivial distinction of the <em>form</em> of the qualified-id in the using-declaration.</p>\n<p>In any case, the bullet point (2.2) does not apply to <code>Base&lt;Ts...&gt;::Base&lt;Ts...&gt;</code>: Its <em>nested-name-specifier</em> is <code>Base&lt;Ts...&gt;</code>. The <em>template-name</em> of this is <code>Base</code>. The name after the <em>nested-name-specifier</em> is <code>Base&lt;Ts...&gt;</code>.</p>\n<hr>\n<p>[class.qual]p2.2 allows using <code>Base&lt;Ts...&gt;::Base</code> and <code>parent::parent</code>, simply <em>by looking at the identifiers used within the qualified-id</em>. No actual name lookup needs to be performed here. The form itself is sufficient to name a constructor.</p>\n</hr></hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2015-07-01T16:34:43.770", "Score": "1", "CreationDate": "2015-07-01T13:42:02.193", "ParentId": "31129781", "CommentCount": "0", "OwnerUserId": "420683", "LastEditDate": "2015-07-01T16:34:43.770"}});