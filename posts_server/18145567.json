post_cb({"bq_ids": {"n4140": {"so_18145567_18146631_5": {"length": 20, "quality": 0.8333333333333334, "section_id": 6185}, "so_18145567_18146631_0": {"length": 11, "quality": 1.0, "section_id": 5986}, "so_18145567_18146631_2": {"length": 19, "quality": 0.95, "section_id": 6064}, "so_18145567_18146631_3": {"length": 18, "quality": 0.9473684210526315, "section_id": 5952}, "so_18145567_18146631_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 11}, "so_18145567_18146631_6": {"length": 12, "quality": 0.9230769230769231, "section_id": 6185}}, "n3337": {"so_18145567_18146631_5": {"length": 15, "quality": 0.625, "section_id": 5946}, "so_18145567_18146631_0": {"length": 11, "quality": 1.0, "section_id": 5754}, "so_18145567_18146631_2": {"length": 19, "quality": 0.95, "section_id": 5832}, "so_18145567_18146631_3": {"length": 18, "quality": 0.9473684210526315, "section_id": 5722}, "so_18145567_18146631_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 8}, "so_18145567_18146631_6": {"length": 13, "quality": 1.0, "section_id": 5946}}, "n4659": {"so_18145567_18146631_3": {"length": 10, "quality": 0.5263157894736842, "section_id": 7438}, "so_18145567_18146631_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 7486}, "so_18145567_18146631_2": {"length": 18, "quality": 0.9, "section_id": 7560}, "so_18145567_18146631_5": {"length": 17, "quality": 0.7083333333333334, "section_id": 7687}, "so_18145567_18146631_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 12}, "so_18145567_18146631_6": {"length": 12, "quality": 0.9230769230769231, "section_id": 7687}}}, "18145630": {"Id": "18145630", "PostTypeId": "2", "Body": "<p>C++11 <code>constexpr</code> is used to enable an expression be evaluated at compile time, unlike <code>const</code> keyword.</p>\n<p><code>constexpr int ys[]{1, 2, 3};</code> is evaluated at compile time, so no error</p>\n<p>when <code>ys[0]</code> is used.</p>\n<p>Also, notice C++11 uniform initialization is used here with <code>{}</code></p>\n<p>Other example :</p>\n<pre><code>constexpr int multipletwo(int x)\n{\nreturn 2*x;\n}\n\nint num_array[multipletwo(3)]; //No error since C++11, num_array has 6 elements.\n</code></pre>\n", "LastEditorUserId": "1870232", "LastActivityDate": "2013-08-09T11:33:39.830", "Score": "0", "CreationDate": "2013-08-09T11:24:30.357", "ParentId": "18145567", "CommentCount": "0", "OwnerUserId": "1870232", "LastEditDate": "2013-08-09T11:33:39.830"}, "18146631": {"Body": "<p>A longer comment as community wiki.</p>\n<hr>\n<p>The expression <code>xs[0]</code> is defined in [expr.sub]/1 as <code>*((xs)+(0))</code>. (See below for the parantheses.)</p>\n<blockquote>\n<p id=\"so_18145567_18146631_0\">One of the expressions shall have the type \u201cpointer to <code>T</code>\u201d and the other shall have unscoped enumeration or integral type.</p>\n</blockquote>\n<p>Therefore, the array-to-pointer conversion [conv.array] is applied:</p>\n<blockquote>\n<p id=\"so_18145567_18146631_1\">An lvalue or rvalue of type \u201carray of <code>N T</code>\u201d or \u201carray of unknown bound of <code>T</code>\u201d can be converted to a prvalue of type \u201cpointer to <code>T</code>\u201d. The result is a pointer to the first element of the array.</p>\n</blockquote>\n<p>Note it can operate on an lvalue and the result is a <em>prvalue</em>, <code>0</code> as an integer literal is a prvalue as well. The addition is defined in [expr.add]/5. As both are <em>prvalues</em>, no lvalue-to-rvalue conversion is required.</p>\n<pre><code>int arr[3];\nconstexpr int* p = arr;  // allowed and compiles\n</code></pre>\n<p>The crucial step now seems to be the indirection <code>*</code> [expr.unary.op]/1</p>\n<blockquote>\n<p id=\"so_18145567_18146631_2\">The unary <code>*</code> operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points.</p>\n</blockquote>\n<p>So, the result of <code>xs[0]</code> is an lvalue referring to the first element of the <code>xs</code> array, and is of type <code>int const</code>.</p>\n<hr>\n<p>N.B. [expr.prim.general]/6</p>\n<blockquote>\n<p id=\"so_18145567_18146631_3\">A parenthesized expression is a primary expression whose type and value are identical to those of the enclosed expression. The presence of parentheses does not affect whether the expression is an lvalue.</p>\n</blockquote>\n<hr>\n<p>If we now look at the bullets in [expr.const]/2 which disallow certain expressions and conversions to appear in constant expressions, the only bullet that could apply (AFAIK) is the lvalue-to-rvalue conversion:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_18145567_18146631_4\">an lvalue-to-rvalue conversion (4.1) unless it is applied to</p>\n<ul>\n<li><p id=\"so_18145567_18146631_5\">a non-volatile glvalue of integral or enumeration type that refers to a non-volatile const object with a preceding initialization, initialized with a constant expression [Note: a string literal (2.14.5) corresponds to an array of such objects. \u2014end note ], or</p></li>\n<li><p id=\"so_18145567_18146631_6\">a non-volatile glvalue of literal type that refers to a non-volatile object defined with <code>constexpr</code>, or that refers to a sub-object of such an object, or</p></li>\n</ul></li>\n</ul>\n<p id=\"so_18145567_18146631_7\">[...]</p>\n</blockquote>\n<p>But the only true lvalue-to-rvalue conversion as per (4.1) (not 4.2, which is array-to-pointer) that appears in the evaluation of <code>xs[0]</code> is the conversion from the resulting lvalue referring to the first element.</p>\n<p>For the example in the OP:</p>\n<pre><code>int const xs[]{1, 2, 3};\nint as[xs[0]];  // error.\n</code></pre>\n<p>This element <code>xs[0]</code> has non-volatile const integral type, its initialization precedes the constant expression where it occurs, and it has been initialized with a constant expression.</p>\n<hr>\n<p>By the way, the added \"Note\" in the quoted passage of [expr.const]/2 <a href=\"https://stackoverflow.com/a/7436323/420683\">has been added to clarify</a> that this is legal:</p>\n<pre><code>constexpr char c = \"hello\"[0];\n</code></pre>\n<p>Note that a string literal is an lvalue as well.</p>\n<hr>\n<p>It would be great if someone (could change this to) explain why <code>xs[0]</code> is not allowed to appear in a constant expression.</p>\n</hr></hr></hr></hr></hr>", "CreationDate": "2013-08-09T12:25:28.863", "ParentId": "18145567", "CommentCount": "4", "LastEditDate": "2017-05-23T12:01:49.547", "Id": "18146631", "PostTypeId": "2", "LastActivityDate": "2013-08-09T12:42:28.187", "LastEditorUserId": "-1", "CommunityOwnedDate": "2013-08-09T12:25:28.863", "Score": "5", "OwnerUserId": "420683"}, "18145567": {"ViewCount": "2332", "Body": "<p>Why is there a difference between <code>const</code> and <code>constexpr</code> when used with arrays?</p>\n<pre><code>int const xs[]{1, 2, 3};\nconstexpr int ys[]{1, 2, 3};\n\nint as[xs[0]];  // error.\nint bs[ys[0]];  // fine.\n</code></pre>\n<p>I would expect both <code>xs[0]</code> and <code>ys[0]</code> to be constant expressions but only the latter is treated as such.</p>\n", "AcceptedAnswerId": "18146631", "Title": "Difference between const and constexpr arrays", "CreationDate": "2013-08-09T11:21:13.680", "Id": "18145567", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-08-09T12:42:28.187", "Score": "10", "OwnerUserId": "2491746", "Tags": "<c++><arrays><c++11><const><constexpr>", "AnswerCount": "2"}});