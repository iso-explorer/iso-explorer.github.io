post_cb({"24181310": {"Id": "24181310", "PostTypeId": "2", "Body": "<p>As far as the structure of the buffer is concerned, there is no difference: in both cases you get an element size of one byte, mandated by the standard.</p>\n<p>Perhaps the most important difference that you get is the behavior that you see when accessing the individual elements of the buffer, for example, for printing. With <code>char</code> you get implementation-defined signed or unsigned behavior; with <code>unsigned char</code> you always see unsigned behavior. This becomes important if you want to print the individual bytes of your \"raw data\" buffer.</p>\n<p>Another good alternative for use for buffers is the exact-width integer <code>uint8_t</code>. It is guaranteed to have the same width as <code>unsigned char</code>, its name requires less typing, and it tells the reader that you are not intended to use the individual elements of the buffer as character-based information.</p>\n", "LastActivityDate": "2014-06-12T09:47:57.920", "CommentCount": "0", "CreationDate": "2014-06-12T09:47:57.920", "ParentId": "24181172", "Score": "4", "OwnerUserId": "335858"}, "24181172": {"ViewCount": "1483", "Body": "<p>When need to buffer in memory some raw data, for example from a stream, is it better to use an array of char or of unsigned char? I always used char but at work are saying it is better unsigned char and I don't know why...</p>\n", "AcceptedAnswerId": "24181368", "Title": "Is it better to use char or unsigned char array for storing raw data?", "CreationDate": "2014-06-12T09:40:36.567", "Id": "24181172", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-11-10T12:36:54.030", "Score": "5", "OwnerUserId": "2668038", "Tags": "<c++><c>", "AnswerCount": "7"}, "24181642": {"Id": "24181642", "PostTypeId": "2", "Body": "<p>If you use unsigned char then it will take only valid ASCII characters as its range will become -127 to +127.</p>\n<p>and you can find complete difference between char and unsigned char details in this question.</p>\n<p><a href=\"https://stackoverflow.com/questions/4337217/difference-between-signed-unsigned-char\">diff bet char and unsigned char</a></p>\n<p>and you can see the table here.</p>\n<p><a href=\"http://ascii.cl/\" rel=\"nofollow noreferrer\">ASCII table </a></p>\n<p><a href=\"http://www.simotime.com/asc2ebc1.htm\" rel=\"nofollow noreferrer\">complete tables of raw characters</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-12T10:02:12.183", "Score": "0", "CreationDate": "2014-06-12T10:02:12.183", "ParentId": "24181172", "CommentCount": "0", "OwnerUserId": "3404637", "LastEditDate": "2017-05-23T12:32:20.053"}, "24181220": {"Id": "24181220", "PostTypeId": "2", "Body": "<p>Internally, it is exactly the same: Each element is a byte. The difference is given when you operate with those values.</p>\n<p>If your values range is [0,255] you should use <code>unsigned char</code> but if it is [-128,127] then you should use <code>signed char</code>.</p>\n<p>Suppose you are use the first range (<code>signed char</code>), then you can perform the operation <code>100+100</code>. Otherwise that operation will overflow and give you an unexpected value.</p>\n<p>Depending on your compiler or machine type, <code>char</code> may be unsigned or signed by default:\n<a href=\"https://stackoverflow.com/questions/2054939/is-char-signed-or-unsigned-by-default\">Is char signed or unsigned by default?</a>\nThus having <code>char</code> the ranges described for the cases above.</p>\n<p>If you are using this buffer just to store binary data without operating with it, there is no difference between using <code>char</code> or <code>unsigned char</code>.</p>\n<p><strong>EDIT</strong></p>\n<p>Note that you can even <a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/C-Dialect-Options.html\" rel=\"nofollow noreferrer\">change the default</a> <code>char</code> for the same machine and compiler using compiler's flags:</p>\n<blockquote>\n<p id=\"so_24181172_24181220_0\">-funsigned-char\n  Let the type char be unsigned, like unsigned char.</p>\n<p id=\"so_24181172_24181220_1\">Each kind of machine has a default for what char should be. It is either likeunsigned char by default or like signed char by default.\n  Ideally, a portable program should always use signed char or unsigned char when it depends on the signedness of an object. But many\n  programs have been written to use plain char and expect it to be\n  signed, or expect it to be unsigned, depending on the machines they\n  were written for. This option, and its inverse, let you make such a\n  program work with the opposite default.</p>\n<p id=\"so_24181172_24181220_2\">The type char is always a distinct type from each of signed char or unsigned char, even though its behavior is always just like one of\n  those two.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-12T11:44:38.900", "Score": "3", "CreationDate": "2014-06-12T09:43:29.000", "ParentId": "24181172", "CommentCount": "3", "OwnerUserId": "1893995", "LastEditDate": "2017-05-23T12:32:20.053"}, "24181276": {"Id": "24181276", "PostTypeId": "2", "Body": "<p>It is usually better to use <code>char</code> but it makes so little difference it does not matter. It's raw data so you should be simply passing it around as such rather than trying to work with it via <code>char</code> pointers of one type or another. Since <code>char</code> is the native data type it makes most sense to use this rather than imagining you are forcing your data into one type or another.</p>\n", "LastActivityDate": "2014-06-12T09:46:07.807", "CommentCount": "0", "CreationDate": "2014-06-12T09:46:07.807", "ParentId": "24181172", "Score": "0", "OwnerUserId": "1502345"}, "bq_ids": {"n4140": {"so_24181172_24181220_0": {"length": 5, "quality": 0.625, "section_id": 45}}, "n3337": {"so_24181172_24181220_0": {"length": 5, "quality": 0.625, "section_id": 42}}, "n4659": {"so_24181172_24181220_0": {"length": 5, "quality": 0.625, "section_id": 46}}}, "24181650": {"Id": "24181650", "PostTypeId": "2", "Body": "<p>As @Pablo said in his answer, the key reason is that if you're doing arithmetic on the bytes, you'll get the 'right' answers if you declare the bytes as <code>unsigned char</code>: you want (in Pablo's example) 100 + 100 to add to 200; if you do that sum with <code>signed char</code> (which you might do by accident if <code>char</code> on your compiler is signed) there's no guarantee of that \u2013 you're asking for trouble.</p>\n<p>Another important reason is that it can help document your code, if you're explicit about what datatypes are what.  It's useful to declare</p>\n<pre><code>typedef unsigned char byte\n</code></pre>\n<p>or even better</p>\n<pre><code>#include &lt;stdint.h&gt;\ntypedef uint8_t byte\n</code></pre>\n<p>Using <code>byte</code> thereafter makes it that little bit clearer what your program's intent is.  Depending on how paranoid your compiler is (<code>-Wall</code> is your friend), this <em>might</em> even cause a type warning if you give a <code>byte*</code> argument to a <code>char*</code> function argument, thus prompting you to think slightly more carefully about whether you're doing the right thing.</p>\n<p>A 'character' is fundamentally a pretty different thing from a 'byte'.  C happens to blur the distinction (because at C's level, in a mostly ASCII world, the distinction doesn't matter in many cases).  This blurring isn't always helpful, but it's at least good intellectual hygiene to keep the difference clear in your head.</p>\n", "LastActivityDate": "2014-06-12T10:02:34.073", "CommentCount": "0", "CreationDate": "2014-06-12T10:02:34.073", "ParentId": "24181172", "Score": "1", "OwnerUserId": "375147"}, "47164635": {"Id": "47164635", "PostTypeId": "2", "Body": "<p>If you are able to work with C++17 there is a std::byte type that is more appropriate for working with raw data. It only has bitwise logic operators defined for it.</p>\n", "LastActivityDate": "2017-11-07T18:03:57.583", "CommentCount": "0", "CreationDate": "2017-11-07T18:03:57.583", "ParentId": "24181172", "Score": "0", "OwnerUserId": "5680070"}, "24181368": {"Id": "24181368", "PostTypeId": "2", "Body": "<p>UPDATE: C++17 introduced <a href=\"http://en.cppreference.com/w/cpp/types/byte\" rel=\"nofollow noreferrer\"><code>std::byte</code></a>, which is more suited to \"raw\" data buffers than using any manner of <code>char</code>.</p>\n<p>For earlier C++ versions:</p>\n<ul>\n<li><p><code>unsigned char</code> emphasises that the data is not \"just\" text</p></li>\n<li><p>if you've got what's effectively \"byte\" data from e.g. a compressed stream, a database table backup file, an executable image, a jpeg... then <code>unsigned</code> is appropriate for the binary-data connotation mentioned above</p>\n<ul>\n<li><p><code>unsigned</code> works better for some of the operations you might want to do on binary data, e.g. there are undefined and implementation defined behaviours for some bit operations on signed types, and <code>unsigned</code> values can be used directly as indices in arrays</p></li>\n<li><p>you can't accidentally pass an <code>unsigned char*</code> to a function expecting <code>char*</code> and have it operated on as presumed text</p></li>\n<li><p>in these situations it's usually more natural to think of the values as being in the range 0..255, after all - why should the \"sign\" bit have a different kind of significance to the other bits in the data?</p></li>\n</ul></li>\n<li><p>if you're storing \"raw data\" that - at an application logic/design level happens to be 8-bit numeric data, then by all means choose either <code>unsigned</code> or <em>explicitly</em> <code>signed</code> <code>char</code> as appropriate to your needs</p></li>\n</ul>\n", "LastEditorUserId": "410767", "LastActivityDate": "2017-11-10T12:36:54.030", "Score": "8", "CreationDate": "2014-06-12T09:50:22.293", "ParentId": "24181172", "CommentCount": "0", "OwnerUserId": "410767", "LastEditDate": "2017-11-10T12:36:54.030"}});