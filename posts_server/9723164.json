post_cb({"bq_ids": {"n4140": {"so_9723164_9723448_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 599}, "so_9723164_9723448_2": {"length": 20, "quality": 1.0, "section_id": 599}, "so_9723164_9723448_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 599}}, "n3337": {"so_9723164_9723448_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 589}, "so_9723164_9723448_2": {"length": 20, "quality": 1.0, "section_id": 589}, "so_9723164_9723448_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 589}}, "n4659": {"so_9723164_9723448_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 622}, "so_9723164_9723448_2": {"length": 20, "quality": 1.0, "section_id": 622}, "so_9723164_9723448_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 622}}}, "9723448": {"Id": "9723448", "PostTypeId": "2", "Body": "<p>Yes, this behaviour is intended, according to \u00a713.3.1.7 Initialization by list-initialization</p>\n<blockquote>\n<p id=\"so_9723164_9723448_0\">When objects of non-aggregate class type T are list-initialized\n  (8.5.4), overload resolution selects the constructor in two phases:</p>\n<p id=\"so_9723164_9723448_1\">\u2014 Initially, the candidate functions are the initializer-list\n  constructors (8.5.4) of the class <code>T</code> and the argument list consists of\n  the initializer list as a single argument.</p>\n<p id=\"so_9723164_9723448_2\">\u2014 If no viable\n  initializer-list constructor is found, overload resolution is\n  performed again, where the candidate functions are all the\n  constructors of the class <code>T</code> and the argument list consists of the\n  elements of the initializer list.</p>\n</blockquote>\n<p>As to \"the whole purpose of uniform intialization\"... \"Uniform initialization\" is a marketing term, and not a very good description. The standard has all the usual forms of initialization <em>plus</em> list-initialization, but no \"uniform initialization\". List initialization is not meant to be the ultimate form of initialization, it's just another tool in the utility belt.</p>\n", "LastEditorUserId": "46642", "LastActivityDate": "2012-03-15T16:24:02.867", "Score": "20", "CreationDate": "2012-03-15T15:56:57.400", "ParentId": "9723164", "CommentCount": "5", "OwnerUserId": "46642", "LastEditDate": "2012-03-15T16:24:02.867"}, "9724310": {"Id": "9724310", "PostTypeId": "2", "Body": "<p>Uniform initialization doesn't mean what you think it does.  It was added to make initialization more uniform amongst the types in C++.  The reasoning is this:</p>\n<pre><code>typedef struct dog_ {\n   float height;\n   int weight;\n} dog;\nint main() { \n    dog Spot = { 25.6, 45};\n    dog Data[3] = { Spot, {6.5, 7} };\n    std::array&lt;dog, 2&gt; data = { { Spot, {6.5, 7} } }; //only in C++ obviously\n    return 0;\n}\n</code></pre>\n<p>This is <a href=\"http://ideone.com/wuyb9\">valid C and C++ code</a>, and <em>has been for many many years</em>.  It was <em>really</em> convenient, but you had to remember that this only worked with POD types.  People have complained for a long time that there is no way to do <code>std::vector&lt;int&gt; data = { 3, 7, 4, 1, 8};</code>, but some classes (<code>std::array</code>) were written in weird ways to allow initializer list constructors.</p>\n<p>So for C++11, the committee made it so that we could make vector and other cool classes do this too.  This made construction of all types more uniform, so that we can use <code>{}</code> to initialize via constructors, and also from value lists.  The problem you are running into, is that the constructor overload with an <code>std::initializer_list&lt;int&gt;</code> is the best match, and will be selected first.  As such, <code>std::vector&lt;int&gt; b{2};</code> does not mean call the constructor that takes an <code>int</code>, instead it means create a <code>vector</code> from this list of <code>int</code> values.  In that light, it makes perfect sense that it would create a <code>vector</code> containing a single value of <code>2</code>.  To call a different constructor, you'll have to use the <code>()</code> syntax so C++ knows you don't want to initialize from a list.</p>\n", "LastEditorUserId": "845092", "LastActivityDate": "2012-03-15T17:03:00.767", "Score": "5", "CreationDate": "2012-03-15T16:47:37.560", "ParentId": "9723164", "CommentCount": "10", "OwnerUserId": "845092", "LastEditDate": "2012-03-15T17:03:00.767"}, "9723400": {"Id": "9723400", "PostTypeId": "2", "Body": "<p>The standard states that the initializer list constructor takes precedence over the others. This is just one case where it isn't possible do just replace <code>()</code> with <code>{}</code>. There are others, for example <code>{}</code> initialization does not allow narrowing conversions.</p>\n", "LastActivityDate": "2012-03-15T15:54:12.890", "CommentCount": "3", "CreationDate": "2012-03-15T15:54:12.890", "ParentId": "9723164", "Score": "2", "OwnerUserId": "661519"}, "9723164": {"ViewCount": "4298", "Body": "<p>I've been playing around with C++11 for the past few days, and I came up with something strange.</p>\n<p>If I want to uniformly initialize an int:</p>\n<pre><code>int a{5};\n</code></pre>\n<p>But if I do the same thing to a std::vector:</p>\n<pre><code>std::vector&lt;int&gt; b{2};\n</code></pre>\n<p>Does not construct a two element array, but rather an array with one element of value two.  It seems like to get that effect one would need to be more explicit about it:</p>\n<pre><code>std::vector&lt;int&gt; c{{2}};\nstd::vector&lt;int&gt; d = {2};\n</code></pre>\n<p>But not like the declaration of b - this seems inconsistent.  I have seen some other stuff to the same effect.  What I'm asking - is this behavior in the final C++11 standard, or is it just in a draft that was implemented early?  If so, why did the standards committee include this behavior?  It seems like it defeats the whole purpose of uniform initialization, as one has to remember which classes have initializer list constructors, and to use the old () syntax instead of {} with just those classes.  Or one forgoes uniform initialization altogether.</p>\n<p>This seems like a big \"gotcha\".  But there might be advantages to it that I am not aware of.</p>\n<p>Edit:  this code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; a{2};\n    for (auto x: a) {\n        std::cout &lt;&lt; x &lt;&lt; std::endl;\n    }\n    return 0;\n}\n</code></pre>\n<p>outputs \"2\" on gcc 4.6.2</p>\n", "AcceptedAnswerId": "9723448", "Title": "Why does 'std::vector<int> b{2};' create a 1-element vector, and not a 2-element one?", "CreationDate": "2012-03-15T15:42:29.770", "Id": "9723164", "CommentCount": "11", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2012-11-05T20:14:14.770", "LastEditorUserId": "500104", "LastActivityDate": "2012-11-05T20:14:14.770", "Score": "21", "OwnerUserId": "251860", "Tags": "<c++><c++11><initializer-list><uniform-initialization>", "AnswerCount": "3"}});