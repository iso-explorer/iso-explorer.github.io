post_cb({"25815147": {"Body": "<p>This doesn't work because </p>\n<ol>\n<li>you are not returning pointers or references, which is required for covariant returns to work; and</li>\n<li><code>Foo&lt;B&gt;</code> and <code>Foo&lt;B&gt;</code> have no inheritance relationship regardless of <code>Foo</code>, <code>A</code> and <code>B</code> (unless there's a specialization that makes it so).</li>\n</ol>\n<p>But we can work around that. First, note that <code>std::vector&lt;A*&gt;</code> and <code>std::vector&lt;B*&gt;</code> are not substitutable for each other, regardless of any language restrictions, simply because <code>std::vector&lt;B*&gt;</code> cannot support adding an <code>A*</code> element to it. So you cannot even write a custom adapter that makes <code>std::vector&lt;B*&gt;</code> a substitute of <code>std::vector&lt;A*&gt;</code></p>\n<p>But a <em>read-only</em> container of <code>B*</code> can be adapted to look like a read-only container of <code>A*</code>. This is a multi-step process.</p>\n<p>Create an abstract class template that exports a readonly container-like interface</p>\n<pre><code>template &lt;class ApparentElemType&gt;\nstruct readonly_vector_view_base\n{\n    struct iter\n    {\n        virtual std::unique_ptr&lt;iter&gt; clone() const = 0;\n\n        virtual ApparentElemType operator*() const = 0;\n        virtual iter&amp; operator++() = 0;\n        virtual iter&amp; operator--() = 0;\n        virtual bool operator== (const iter&amp; other) const = 0;\n        virtual bool operator!= (const iter&amp; other) const = 0;\n        virtual ~iter(){}\n    };\n\n    virtual std::unique_ptr&lt;iter&gt; begin() = 0;\n    virtual std::unique_ptr&lt;iter&gt; end() = 0;\n\n    virtual ~readonly_vector_view_base() {}\n};\n</code></pre>\n<p>It return pointers to iterators, not iterators themselves, but\ndon't worry, this class will be only used by an STL-like wrapper anyway.</p>\n<p>Now create a concrete wrapper for <code>readonly_vector_view_base</code> and its iterator, so that it contains a pointer to, and delegate its operations to, a <code>readonly_vector_view_base</code>.</p>\n<pre><code>template &lt;class ApparentElemType&gt;\nclass readonly_vector_view\n{\n  public:\n    readonly_vector_view(const readonly_vector_view&amp; other) : pimpl(other.pimpl) {}\n    readonly_vector_view(std::shared_ptr&lt;readonly_vector_view_base&lt;ApparentElemType&gt;&gt; pimpl_) : pimpl(pimpl_) {}\n\n    typedef typename readonly_vector_view_base&lt;ApparentElemType&gt;::iter iter_base;\n    class iter\n    {\n      public:\n        iter(std::unique_ptr&lt;iter_base&gt; it_) : it(it_-&gt;clone()) {}\n        iter(const iter&amp; other) : it(other.it-&gt;clone()) {}\n        iter&amp; operator=(iter&amp; other) { it = other.it-&gt;clone(); return *this; }\n\n        ApparentElemType operator*() const { return **it; }\n</code></pre>\n<p>(*it)-&gt;operator-&gt;(); }\n            iter&amp; operator++() { ++*it; return *this; }\n            iter&amp; operator--() { --*it; return *this; }\n            iter operator++(int) { iter n(*this); ++*it; return n; }\n            iter operator--(int) { iter n(*this); --*it; return n; }\n            bool operator== (const iter&amp; other) const { return *it == *other.it; }\n            bool operator!= (const iter&amp; other) const { return *it != *other.it; }\n          private:\n            std::unique_ptr it;\n        };</p>\n<pre><code>    iter begin() { return iter(pimpl-&gt;begin()); }\n    iter end() { return iter(pimpl-&gt;end()); }\n  private:\n    std::shared_ptr&lt;readonly_vector_view_base&lt;ApparentElemType&gt;&gt; pimpl;\n};\n</code></pre>\n<p>Now create a templatized implementation for <code>readonly_vector_view_base</code> that looks at a vector of a differently typed elements:</p>\n<p>template \nstruct readonly_vector_view_impl : readonly_vector_view_base\n{\n    typedef typename readonly_vector_view_base::iter iter_base;</p>\n<pre><code>readonly_vector_view_impl(std::shared_ptr&lt;std::vector&lt;ElemType&gt;&gt; vec_) : vec(vec_) {}\n\nstruct iter : iter_base\n{\n    std::unique_ptr&lt;iter_base&gt; clone() const { std::unique_ptr&lt;iter_base&gt; x(new iter(it)); return x; }\n\n    iter(typename std::vector&lt;ElemType&gt;::iterator it_) : it(it_) {}\n\n    ApparentElemType operator*() const { return *it; }\n</code></pre>\n<p>it.operator-&gt;(); }\n        iter&amp; operator++() { ++it; return *this; }\n        iter&amp; operator--() { ++it; return *this; }</p>\n<pre><code>    bool operator== (const iter_base&amp; other) const {\n        const iter* real_other = dynamic_cast&lt;const iter*&gt;(&amp;other);\n        return (real_other &amp;&amp; it == real_other-&gt;it);\n    }\n    bool operator!= (const iter_base&amp; other) const { return ! (*this == other); }\n\n    typename std::vector&lt;ElemType&gt;::iterator it;\n};\n\nstd::unique_ptr&lt;iter_base&gt; begin() {\n    iter* x (new iter(vec-&gt;begin()));\n    std::unique_ptr&lt;iter_base&gt; y(x);\n    return y;\n}\nstd::unique_ptr&lt;iter_base&gt; end() {\n    iter* x (new iter(vec-&gt;end()));;\n    std::unique_ptr&lt;iter_base&gt; y(x);\n    return y;\n}\n\nstd::shared_ptr&lt;std::vector&lt;ElemType&gt;&gt; vec;\n</code></pre>\n<p>};</p>\n<p>OK, as long as we have two types where one is convertible to another, such as <code>A*</code> and <code>B*</code>, we can view a vector of <code>B*</code> as if it's a vector of <code>A*</code>.</p>\n<p>But what does it buy us? <code>readonly_vector_view&lt;A*&gt;</code> is still unrelated to <code>readonly_vector_view&lt;B*&gt;</code>! Read on...</p>\n<p>It turns out that the covariant return types are not really necessary, they are a syntactic sugar to what is available in C++ otherwise. Suppose C++ doesn't have covariant return types, can we simulate them? It's actually pretty easy:</p>\n<pre><code>class Base\n{\n   virtual Base* clone_Base() { ... actual impl ... }\n   Base* clone() { return clone_Base(); } // note not virtual \n};\n\nclass Derived : public Base\n{\n   virtual Derived* clone_Derived() { ... actual impl ... }\n   virtual Base* clone_Base() { return clone_Derived(); }\n   Derived* clone() { return clone_Derived(); } // note not virtual \n\n};\n</code></pre>\n<p>It's actually pretty easy <em>and there's no requirement for the return type to be pointers or references, or have an inheritance relationship</em>. It is enough that there is a conversion:</p>\n<pre><code>class Base\n{\n   virtual shared_ptr&lt;Base&gt; clone_Base() { ... actual impl ... }\n   shared_ptr&lt;Base&gt; clone() { return clone_Base(); } \n};\n\nclass Derived : public Base\n{\n   virtual shared_ptr&lt;Derived&gt; clone_Derived() { ... actual impl ... }\n   virtual shared_ptr&lt;Base&gt; clone_Base() { return clone_Derived(); }\n   shared_ptr&lt;Derived&gt; clone() { return clone_Derived(); } \n};\n</code></pre>\n<p>In a similar fashion, we can arrange <code>A::test()</code> to return a <code>readonly_vector_view&lt;A*&gt;</code>, and <code>B::test()</code> to return a <code>readonly_vector_view&lt;B*&gt;</code>. Since these functions are now not virtual, there is no requirement for their return types to be in any relationship. One just hides the other. But inside they call a virtual function that creates (say) a <code>readonly_vector_view&lt;A*&gt;</code> implemented in terms of <code>readonly_vector_view_impl&lt;B*, A*&gt;</code> which is implemented in terms of <code>vector&lt;B*&gt;</code>, and everything works just as if they were real covariant return types.</p>\n<pre><code>struct A\n{\n    readonly_vector_view&lt;A*&gt; test() { return test_A(); }\n    virtual readonly_vector_view&lt;A*&gt; test_A() = 0;\n};\n\nstruct B : A\n{\n    std::shared_ptr&lt;std::vector&lt;B*&gt;&gt; bvec;\n\n    readonly_vector_view&lt;B*&gt; test() { return test_B(); }\n\n    virtual readonly_vector_view&lt;A*&gt; test_A() {\n        return readonly_vector_view&lt;A*&gt;(std::make_shared&lt;readonly_vector_view_impl&lt;B*, A*&gt;&gt;(bvec));\n    }\n    virtual readonly_vector_view&lt;B*&gt; test_B() {\n        return readonly_vector_view&lt;B*&gt;(std::make_shared&lt;readonly_vector_view_impl&lt;B*, B*&gt;&gt;(bvec));\n    }\n};\n</code></pre>\n<p>Piece of cake! <a href=\"http://ideone.com/yD1eWK\" rel=\"nofollow\">Live demo</a> Totally worth the effort!</p>\n", "CreationDate": "2014-09-12T19:07:23.660", "ParentId": "25813435", "CommentCount": "1", "LastEditDate": "2014-09-12T21:48:03.203", "Id": "25815147", "PostTypeId": "2", "LastActivityDate": "2014-09-12T21:48:03.203", "LastEditorUserId": "775806", "CommunityOwnedDate": "2014-09-12T19:07:23.660", "Score": "0", "OwnerUserId": "775806"}, "25814061": {"Id": "25814061", "PostTypeId": "2", "Body": "<p>Covariance only happens when you are returning a pointer or a reference to a class, and the classes are related by inheritance.</p>\n<p>This is clearly not happening, both because <code>std::vector&lt;?&gt;</code> is not a pointer nor reference, and because two <code>std::vector&lt;?&gt;</code>s have no parent/child relationship.</p>\n<p>Now, we can make this work.</p>\n<p>Step 1, create an <code>array_view</code> class.  It has a <code>begin</code> and <code>end</code> pointer and methods and a <code>size</code> method and all you might expect.</p>\n<p>Step 2, create an <code>shared_array_view</code>, which is an array view that also owns a <code>shared_ptr&lt;void&gt;</code> with a custom deleter: it is otherwise identical.  This class also insures that the data it is viewing lasts long enough to be viewed.</p>\n<p>Step 3, create a <code>range_view</code>, which is a pair of iterators and dressing on it.  Do the same with a <code>shared_range_view</code> with an ownership token.  Modify your <code>array_view</code> to be a <code>range_view</code> with some extra guarantees (contiguous iterators mainly).</p>\n<p>Step 4, write a converting iterator.  This is a type that stores an iterator over <code>value_type_1</code> which either calls a function, or implicitly converts to a const_iterator over <code>value_type_2</code>.</p>\n<p>Step 5, Write a <code>range_view&lt; implicit_converting_iterator&lt; T*, U* &gt; &gt;</code> returning function for when <code>T*</code> can be implicitly converted to <code>U*</code>.</p>\n<p>Step 6, write type erasers for the above</p>\n<pre><code>class A {\n  owning_array_view&lt;A*&gt; test_() { /* do something */ }\n  virtual type_erased_range_view&lt;A*&gt; test() { return test_(); };\n};\n\nclass B: public A {\n  owning_array_view&lt;B*&gt; test_() { /* do something */ };\n  virtual type_erased_range_view&lt;A*&gt; test() override {\n    return convert_range_to&lt;A*&gt;(test_());\n  }\n};\n</code></pre>\n<p>Most of what I describe has been done by boost.</p>\n", "LastActivityDate": "2014-09-12T17:55:06.090", "CommentCount": "2", "CreationDate": "2014-09-12T17:55:06.090", "ParentId": "25813435", "Score": "0", "OwnerUserId": "1774667"}, "25813596": {"Id": "25813596", "PostTypeId": "2", "Body": "<p>The standard defines covariance for C++ purposes in \u00a710.3 [class.virtual]/p7:</p>\n<blockquote>\n<p id=\"so_25813435_25813596_0\">The return type of an overriding function shall be either identical to\n  the return type of the overridden function or <em>covariant</em> with the\n  classes of the functions. If a function <code>D::f</code> overrides a function\n  <code>B::f</code>, the return types of the functions are covariant if they\n  satisfy the following criteria:</p>\n<ul>\n<li>both are pointers to classes, both are lvalue references to classes, or both are rvalue references to classes<sup>113</sup></li>\n<li>the class in the return type of <code>B::f</code> is the same class as the class in the return type of <code>D::f</code>, or is an unambiguous and\n  accessible direct or indirect base class of the class in the return\n  type of <code>D::f</code></li>\n<li>both pointers or references have the same cv-qualification and the class type in the return type of <code>D::f</code> has the same cv-qualification\n  as or less cv-qualification than the class type in the return type of\n  <code>B::f</code>.</li>\n</ul>\n<p id=\"so_25813435_25813596_1\"><sup>113</sup>Multi-level pointers to classes or references to multi-level pointers to classes are not allowed.</p>\n</blockquote>\n<p>Your functions fail on the first point, and, even if you bypass it, fails on the second - <code>std::vector&lt;A*&gt;</code> is not a base of <code>std::vector&lt;B*&gt;</code>.</p>\n", "LastActivityDate": "2014-09-12T17:22:33.203", "CommentCount": "1", "CreationDate": "2014-09-12T17:22:33.203", "ParentId": "25813435", "Score": "1", "OwnerUserId": "2756719"}, "25813536": {"Id": "25813536", "PostTypeId": "2", "Body": "<p>Covariant return types allow overridden virtual member functions in a derived class to return a different type of object, as long as it can be used in all the same ways as the base class's return type.  Computer scientists have (ever since Barbara Liskov) a theoretical definition of \"can be used in the same ways\": <em>substitutability</em>.</p>\n<p>No, <code>std::vector&lt;B*&gt;</code> is not a subtype of <code>std::vector&lt;A*&gt;</code>, nor should it be.</p>\n<p>For example, <code>std::vector&lt;B*&gt;</code> doesn't support the <code>push_back(A*)</code> operation, so it is not substitutable.</p>\n<p>C++ doesn't try to infer subtype relationships for templates at all.  The relationship will only exist if you actually specialize one and specify a base class.  One reason for this, even on interfaces which are theoretically covariant (basically, read-only), is that C++'s version is actually stronger than Liskov substitution -- in C++ the compatibility has to exist at a binary level.  Since the memory layout of collections of related objects may not match subobject placement, this binary compatibility isn't achieved.  The restriction of covariant return types to be only pointers or references is also a consequence of the binary compatibility issue.  A derived object probably wouldn't fit in the space reserved for the base instance... but its pointer will.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2014-09-12T17:55:39.953", "Score": "4", "CreationDate": "2014-09-12T17:17:37.390", "ParentId": "25813435", "CommentCount": "3", "OwnerUserId": "103167", "LastEditDate": "2014-09-12T17:55:39.953"}, "25813541": {"Id": "25813541", "PostTypeId": "2", "Body": "<p>An apple is a fruit.</p>\n<p>A bag of apples is not a bag of fruit. That's because you can put a pear in a bag of fruit.</p>\n", "LastActivityDate": "2014-09-12T17:17:51.567", "Score": "1", "CreationDate": "2014-09-12T17:17:51.567", "ParentId": "25813435", "CommentCount": "9", "OwnerUserId": "775806", "CommunityOwnedDate": "2014-09-12T17:17:51.567"}, "bq_ids": {"n4140": {"so_25813435_25813596_0": {"length": 24, "quality": 0.96, "section_id": 7008}, "so_25813435_25813596_1": {"length": 7, "quality": 0.875, "section_id": 7008}}, "n3337": {"so_25813435_25813596_0": {"length": 24, "quality": 0.96, "section_id": 6754}, "so_25813435_25813596_1": {"length": 7, "quality": 0.875, "section_id": 6754}}, "n4659": {"so_25813435_25813596_0": {"length": 23, "quality": 0.92, "section_id": 8505}, "so_25813435_25813596_1": {"length": 7, "quality": 0.875, "section_id": 8505}}}, "25813575": {"Id": "25813575", "PostTypeId": "2", "Body": "<p>The C++ FAQ answers this directly in <a href=\"http://www.parashift.com/c++-faq-lite/proper-inheritance.html#faq-21.3\" rel=\"nofollow noreferrer\">[21.3] Is a parking-lot-of-Car a kind-of parking-lot-of-Vehicle? </a>  (\"You don't have to like it. But you do have to accept it.\")</p>\n<p>SO question <a href=\"https://stackoverflow.com/questions/114819/getting-a-vectorderived-into-a-function-that-expects-a-vectorbase\">Getting a vector into a function that expects a vector</a> is asking the same thing.  And the answer is that while it seems safe at first to allow covariance of generic types, in particular containers of a derived type being treated as containers of the base type, it is quite unsafe.</p>\n<p>Consider this code:</p>\n<pre><code>class Vehicle {};\nclass Car : public Vehicle {};\nclass Boat : public Vehicle {};\n\nvoid add_boat(vector&lt;Vehicle*&gt;&amp; vehicles) { vehicles.push_back(new Boat()); }\n\nint main()\n{\n  vector&lt;Car*&gt; cars;\n  add_boat(cars);\n  // Uh oh, if that worked we now have a Boat in our Cars vector.\n  // Fortunately it is not legal to convert vector&lt;Car*&gt; as a vector&lt;Vehicle*&gt; in C++.\n}\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-09-12T19:06:09.077", "Score": "1", "CreationDate": "2014-09-12T17:21:08.780", "ParentId": "25813435", "CommentCount": "0", "OwnerUserId": "994153", "LastEditDate": "2017-05-23T11:45:57.150"}, "25813435": {"ViewCount": "419", "Body": "<p>I get a compile error when I try to do this:</p>\n<pre><code>class A\n{\n    virtual std::vector&lt;A*&gt; test() { /* do something */ };\n}\n\nclass B: public A\n{\n    virtual std::vector&lt;B*&gt; test() { /* do something */ };\n}\n</code></pre>\n<p>I assume that A and B are covariant types, and hence A* and B* should also be (Correct?) By inference, I would have expected that <code>std::vector&lt;A*&gt;</code> and <code>std::vector&lt;B*&gt;</code> should be covariant as well, but this does not seem to be the case. Why?</p>\n", "Title": "What exactly are covariant return types in C++?", "CreationDate": "2014-09-12T17:10:52.127", "LastActivityDate": "2014-09-12T21:48:03.203", "CommentCount": "2", "LastEditDate": "2014-09-12T17:13:10.833", "PostTypeId": "1", "LastEditorUserId": "845092", "Id": "25813435", "Score": "1", "OwnerUserId": "3697176", "Tags": "<c++><inheritance><vector><virtual><covariant>", "AnswerCount": "7"}, "25813528": {"Id": "25813528", "PostTypeId": "2", "Body": "<p>Templates do not \"inherit\" covariance, because different template specializations may be completely 100% unrelated:</p>\n<pre><code>template&lt;class T&gt; struct MD;\n\n//pets\ntemplate&lt;&gt; struct MD&lt;A*&gt; \n{\n    std::string pet_name;\n    int pet_height;\n    int pet_weight;\n    std::string pet_owner;\n};\n\n//vehicles\ntemplate&lt;&gt; struct MD&lt;B*&gt;\n{\n    virtual ~MD() {}\n    virtual void fix_motor();\n    virtual void drive();\n    virtual bool is_in_the_shop()const;\n}\n\nstd::vector&lt;MD&lt;A*&gt;&gt; get_pets();\n</code></pre>\n<p>How would you feel if <code>get_pets</code> returned a vector where some of those were actually vehicles instead?  It seems to defeat the point of the type system right?</p>\n", "LastActivityDate": "2014-09-12T17:17:03.947", "CommentCount": "2", "CreationDate": "2014-09-12T17:17:03.947", "ParentId": "25813435", "Score": "1", "OwnerUserId": "845092"}});