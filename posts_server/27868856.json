post_cb({"27868856": {"CommentCount": "8", "ViewCount": "55", "CreationDate": "2015-01-09T20:38:46.147", "LastActivityDate": "2015-01-09T21:09:02.177", "Title": "I'm trying to insert to a set of a class", "FavoriteCount": "0", "PostTypeId": "1", "Id": "27868856", "Score": "0", "Body": "<p>I have 2 classes: Item and Customer, and I want to insert an item into the set of item (the set of items is in the customer).\nThe problem is that I want to change the count in the item and I have trouble with it because the iterator won't work with non-const functions such as setCount... so this doesn't compile:</p>\n<pre><code>void Customer::insertItem(Item *newItem)\n{\n    std::set&lt;Item&gt;::iterator it;\n    if (newItem-&gt;getCount() == 0)\n    {\n        _items.insert(*newItem);\n    }\n    for (it = _items.begin(); it != _items.end(); it++)\n    {\n        if (_items.find(*newItem) != _items.end()&amp;&amp;it-&gt;getName()==newItem-&gt;getName())\n        {\n            it-&gt;setCount(it-&gt;getCount() + 1);\n        }\n    }\n}\n</code></pre>\n<p>but if i put const in the setCount it won't compile either because i cant change the value of count. </p>\n<p>Does anyone have an idea what to do?</p>\n<p>Thanks in advance</p>\n", "Tags": "<c++><stl><compilation><set><const>", "OwnerUserId": "4331521", "AnswerCount": "1"}, "27869252": {"ParentId": "27868856", "CommentCount": "0", "Body": "<p>You simply cannot call non-<code>const</code> methods on objects that you put in a <code>set</code>, as per \u00a723.2.4/5-6 (in N3797, emphasis mine):</p>\n<blockquote>\n<p id=\"so_27868856_27869252_0\">(5) For <code>set</code> and <code>multiset</code> the value type is the same as the key type.</p>\n<p id=\"so_27868856_27869252_1\">(6) <code>iterator</code> of an associative container is of the bidirectional iterator category. For associative containers where the value type is the same as the key type, <strong>both <code>iterator</code> and <code>const_iterator</code> are constant iterators.</strong></p>\n</blockquote>\n<p>So when you try to do:</p>\n<pre><code>it-&gt;setCount(it-&gt;getCount() + 1);\n</code></pre>\n<p>That can't work, since the object <code>it</code> points to is <code>const</code>. If you still want to store the count internally to the object AND in a set, you can make whatever the count member variable is <code>mutable</code> and still mark <code>setCount()</code> to be <code>const</code>. </p>\n<p>Far more likely though, the container you want is something like <code>std::map&lt;std::string, Item&gt;</code>, where your logic would be:</p>\n<pre><code>void Customer::insertItem(const Item&amp; newItem)\n{\n    auto it = _items.find(newItem.getName());\n    if (it == _items.end()) {\n        // absent, insert it\n        it = _items.insert(std::make_pair(newItem.getName(), newItem)).first;\n    }\n\n    // now increment the count\n    // it-&gt;first is a const Key, but it-&gt;second is just Value, so it's mutable\n    it-&gt;second.setCount(it-&gt;second.getCount() + 1);\n}\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "27869252", "Score": "2", "CreationDate": "2015-01-09T21:09:02.177", "LastActivityDate": "2015-01-09T21:09:02.177"}, "bq_ids": {"n4140": {"so_27868856_27869252_0": {"section_id": 741, "quality": 0.875, "length": 7}, "so_27868856_27869252_1": {"section_id": 742, "quality": 0.95, "length": 19}}, "n3337": {"so_27868856_27869252_0": {"section_id": 730, "quality": 0.875, "length": 7}, "so_27868856_27869252_1": {"section_id": 731, "quality": 0.95, "length": 19}}, "n4659": {"so_27868856_27869252_0": {"section_id": 799, "quality": 0.875, "length": 7}, "so_27868856_27869252_1": {"section_id": 800, "quality": 0.95, "length": 19}}}});