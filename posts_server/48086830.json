post_cb({"48087390": {"PostTypeId": "2", "Body": "<h1>Converting \u201c7.63918e-313\u201d</h1>\n<p>The C++ standard allows conversions of strings to <code>double</code> to report underflow if the result is in the subnormal range even though it is representable.</p>\n<p>7.63918\u202210<sup>-313</sup> is within the range of <code>double</code>, but it is in the subnormal range. The C++ standard says <code>stod</code> calls <code>strtod</code> and then defers to the C standard to define <code>strtod</code>. The C standard indicates that <code>strtod</code> may underflow, about which it says \u201cThe result underflows if the magnitude of the mathematical result is so small that the mathematical result cannot be represented, without extraordinary roundoff error, in an object of the specified type.\u201d That is awkward phrasing, but it refers to the rounding errors that occur when subnormal values are encountered. (Subnormal values are subject to large relative errors than normal values, so their rounding errors might be said to be extraordinary.)</p>\n<p>Thus, a C++ implementation is allowed by the C++ standard to underflow for subnormal values even though they are representable.</p>\n<h1>Converting std::numeric_limits::min()</h1>\n<p>Regarding your observation that <code>std::numeric_limits&lt;double&gt;::min()</code> \u201ccannot be parsed\u201d either (I presume you mean it also reports underflow), this may be due to the fact that you converted <code>std::numeric_limits&lt;double&gt;::min()</code> to a string containing a decimal numeral, and that decimal numeral was not an exact representation of <code>std::numeric_limits&lt;double&gt;::min()</code>. If it was rounded down, it is slightly less than <code>min()</code>, and hence it is also in the subnormal range. Thus, attempting to convert that decimal numeral back to a <code>double</code> may correctly report it is below the normal range.</p>\n<h1>std::numeric_limits::min() is not the minimum double</h1>\n<p>Regarding your observation that <code>std::numeric_limits&lt;double&gt;::min()</code> is not the minimum <code>double</code>, that is correct. <code>std::numeric_limits&lt;double&gt;::min()</code> is specified by the C++ standard to be the minimum positive normal value. There may be subnormal values below it.</p>\n<h1>Normal and subnormal values</h1>\n<p>For IEEE-754 64-bit binary floating-point, the normal range is from 2<sup>-1022</sup> to 2<sup>1024</sup>-2<sup>971</sup>. Within this range, every number is represented with a signficand (the fraction portion of the floating-point representation) that has a leading 1 bit followed by 52 additional bits, and so the error that occurs when rounding any real number in this range to the nearest representable value is at most 2<sup>-53</sup> times the position value of the leading bit.</p>\n<p>In additional to this normal range, there is a subnormal range from 2<sup>-1074</sup> to 2<sup>-1022</sup>-2<sup>-1074</sup>. In this interval, the exponent part of the floating-point format has reached its smallest value and cannot be decreased any more. To represent smaller and smaller numbers in this interval, the significand is reduced below the normal minimum of 1. It starts with a 0 and is followed by 52 additional bits. In this interval, the error that occurs when rounding a real number to the nearest representable value may be larger than 2<sup>-53</sup> times the position value of the leading bit. Since the exponent cannot be decreased any further, numbers in this interval have increasing numbers of leading 0 bits as they get smaller and smaller. Thus the relative errors involved with using these numbers grows.</p>\n<p>For whatever reasons, the C++ has said that implementations may report underflow in this interval. (The IEEE-754 standard defines underflow in complicated ways and also allows implementations some choices.)</p>\n", "LastActivityDate": "2018-01-04T01:42:22.773", "LastEditorUserId": "298225", "Score": "3", "Id": "48087390", "CreationDate": "2018-01-04T01:12:15.973", "ParentId": "48086830", "CommentCount": "0", "OwnerUserId": "298225", "LastEditDate": "2018-01-04T01:42:22.773"}, "48086966": {"PostTypeId": "2", "Body": "<p>The value you are trying to read as a double, <code>7.63918e-313</code>, is smaller than the minimal value that is representable by a double on your architecture.  On my architecture this is <code>2.22507e-308</code> and can be obtained using <code>std::numeric_limits&lt;double&gt;::min()</code>.</p>\n<p>From the standard: <a href=\"http://eel.is/c++draft/string.conversions#6\" rel=\"nofollow noreferrer\">[string.conversions]</a></p>\n<blockquote>\n<p id=\"so_48086830_48086966_0\">Throws out_\u00adof_\u00adrange if <code>strtof</code>, <code>strtod</code>, or <code>strtold</code> sets <code>errno</code> to <code>ERANGE</code> or if the converted value is outside the range of representable values for the return type.</p>\n</blockquote>\n<p>That is to say, mapping doubles back on forth to string is possible using <code>std::to_string</code> and <code>std::stod</code> (or stringstreams) given that they are representable.</p>\n<hr>\n<p>Instead you could use <a href=\"http://www.boost.org/libs/lexical_cast/\" rel=\"nofollow noreferrer\">Boost.Lexical_Cast</a> for parsing which does not seem to have these limitations.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;boost/lexical_cast.hpp&gt;\n\nint main() {\n    double d = boost::lexical_cast&lt;double&gt;(\"7.63918e-313\");\n    std::cout &lt;&lt; d &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p><kbd><a href=\"https://wandbox.org/permlink/qPyrxqhVZMd2QhTm\" rel=\"nofollow noreferrer\">Live example</a></kbd></p>\n<p>Another alternative is <a href=\"https://ciere.com/cppnow15/x3_docs/\" rel=\"nofollow noreferrer\">Boost.Spirit</a>.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;boost/spirit/home/x3.hpp&gt;\n\nnamespace x3 = boost::spirit::x3;\n\nint main() {\n    double d = 0;\n    std::string input = \"7.63918e-313\";\n    x3::parse(input.begin(), input.end(), x3::double_, d);\n    std::cout &lt;&lt; d &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p><kbd><a href=\"https://wandbox.org/permlink/DvFMs8TJMdjXyXwv\" rel=\"nofollow noreferrer\">Live example</a></kbd></p>\n</hr>", "LastActivityDate": "2018-01-04T00:47:34.257", "LastEditorUserId": "1944004", "Score": "1", "Id": "48086966", "CreationDate": "2018-01-04T00:10:26.443", "ParentId": "48086830", "CommentCount": "8", "OwnerUserId": "1944004", "LastEditDate": "2018-01-04T00:47:34.257"}, "bq_ids": {"n4140": {"so_48086830_48086966_0": {"length": 15, "quality": 0.9375, "section_id": 1871}}, "n4659": {"so_48086830_48086966_0": {"length": 16, "quality": 1.0, "section_id": 2043}}}, "48086830": {"ViewCount": "98", "LastEditDate": "2018-01-04T00:36:36.680", "AcceptedAnswerId": "48087390", "Title": "std::stod throws out_of_range error for a string that should be valid", "CreationDate": "2018-01-03T23:55:34.723", "LastActivityDate": "2018-01-04T01:45:02.920", "CommentCount": "8", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;sstream&gt;\nusing namespace std;\n\nint main(){\n    stringstream ss;\n    double ad = 7.63918e-313;\n    ss &lt;&lt; ad;\n    cout&lt;&lt;ss.str()&lt;&lt;endl;\n    //you will see that the above double is valid, and maps to the specified string\n\n    //but stod cannot map it back\n    stod(\"7.63918e-313\");\n    //terminate called after throwing an instance of 'std::out_of_range'\n}\n</code></pre>\n<p>Run it here: <a href=\"https://onlinegdb.com/Sy1MT1iQM\" rel=\"nofollow noreferrer\">https://onlinegdb.com/Sy1MT1iQM</a></p>\n<p>\"7.63918e-313\" will result from serializing a double, but stod cannot deserialize it. What's going on here? The smallest possible double is supposedly around 10^\u2212324.</p>\n<p>Is there a pair of functions somewhere in the stdlib that can reliably map doubles back and forth from stringification? Shouldn't there be?</p>\n<p>The plot thickens. We have two bizarre observations.</p>\n<ul>\n<li><p><code>std::numeric_limits&lt;double&gt;::min()</code> cannot be parsed by stod either.</p></li>\n<li><p><code>std::numeric_limits&lt;double&gt;::min()</code> is not the minimum double. Our double is smaller, and I find we can get smaller doubles by simply dividing min, so it's not that my double is anomalous or anything <a href=\"https://onlinegdb.com/rJvilljQz\" rel=\"nofollow noreferrer\">https://onlinegdb.com/rJvilljQz</a></p></li>\n</ul>\n<p>I am very concerned.</p>\n", "PostTypeId": "1", "LastEditorUserId": "1085128", "Id": "48086830", "Score": "1", "OwnerUserId": "1085128", "Tags": "<c++><floating-point>", "AnswerCount": "3"}, "48087119": {"PostTypeId": "2", "Body": "<p>According to the specification of <code>strtod</code> (which is referred from the specification of <code>std::strod</code>), if the conversion <em>underflows</em>, the function is allowed, but not required to set <code>errno</code> to <code>ERANGE</code>. It is implementation-defined whether <code>errno</code> is set in this case.</p>\n<p>In your example the conversion does underflow. Apparently, in your implementation <code>strtod</code> sets <code>errno</code> to <code>ERANGE</code> and <code>std::stod</code> unconditionally throws <code>std::out_of_range</code> when it sees that <code>ERANGE</code> in <code>errno</code>.</p>\n<p>In a different implementation <code>strtod</code> might not set <code>errno</code> to <code>ERANGE</code> in this case, and <code>std::stod</code> would not throw.</p>\n<p>Basically, C++ standard library is not guaranteed to properly convert underflowing values. Even if <code>strtod</code> decides not to set <code>errno</code>, it is still allowed to return the smallest normalized value as a result in this case, instead of your original value.</p>\n", "LastActivityDate": "2018-01-04T01:45:02.920", "LastEditorUserId": "187690", "Score": "1", "Id": "48087119", "CreationDate": "2018-01-04T00:34:01.740", "ParentId": "48086830", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2018-01-04T01:45:02.920"}});