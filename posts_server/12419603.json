post_cb({"12419603": {"CommentCount": "10", "ViewCount": "1248", "PostTypeId": "1", "LastEditorUserId": "777186", "CreationDate": "2012-09-14T07:01:01.243", "LastActivityDate": "2012-09-15T12:35:15.883", "Title": "Is partial-order, in contrast to total-order, enough to build a heap?", "AcceptedAnswerId": "12419851", "LastEditDate": "2012-09-15T12:35:15.883", "Id": "12419603", "Score": "1", "Body": "<p>C++ std::priority_queue just need a partial order. But if its implementation is a <strong>binary heap</strong>, how does it works?\nFor example: assume we have a partially ordered set <code>( {a, b, c, x}, {c &lt; b, b &lt; a, c &lt; a} )</code>, <code>x</code> has nothing to do with <code>a</code>, <code>b</code>, <code>c</code>. Then a max-heap is:</p>\n<pre><code>layer 1:    x\nlayer 2:  b   x\nlayer 3: x x a c\n</code></pre>\n<p>After a pop operation, in a way commonly seen in text books, i.e. replace the root with <code>c</code> and decrease the size by 1. Then we need to heapify the tree below, at the root:</p>\n<pre><code>layer 1:    c\nlayer 2:  b   x\nlayer 3: x x a\n</code></pre>\n<p>We will swap <code>c</code> and <code>b</code> as <code>c &lt; b</code>, won't we? And what? We still don't have a valid heap since <code>b &lt; a</code>. But <code>b</code> cannot \"see\" <code>a</code>.</p>\n", "Tags": "<c++><algorithm><stl><std>", "OwnerUserId": "851835", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_12419603_12419851_4": {"section_id": 1396, "quality": 1.0, "length": 8}, "so_12419603_12419851_2": {"section_id": 1396, "quality": 0.8888888888888888, "length": 8}, "so_12419603_12419851_1": {"section_id": 1396, "quality": 1.0, "length": 4}, "so_12419603_12419851_0": {"section_id": 1396, "quality": 0.9090909090909091, "length": 30}, "so_12419603_12419851_5": {"section_id": 1396, "quality": 0.5555555555555556, "length": 5}}, "n3337": {"so_12419603_12419851_4": {"section_id": 1390, "quality": 1.0, "length": 8}, "so_12419603_12419851_2": {"section_id": 1390, "quality": 0.8888888888888888, "length": 8}, "so_12419603_12419851_1": {"section_id": 1390, "quality": 1.0, "length": 4}, "so_12419603_12419851_0": {"section_id": 1390, "quality": 0.9090909090909091, "length": 30}, "so_12419603_12419851_5": {"section_id": 1390, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_12419603_12419851_4": {"section_id": 1514, "quality": 1.0, "length": 8}, "so_12419603_12419851_2": {"section_id": 1514, "quality": 0.8888888888888888, "length": 8}, "so_12419603_12419851_1": {"section_id": 1514, "quality": 1.0, "length": 4}, "so_12419603_12419851_5": {"section_id": 1514, "quality": 0.5555555555555556, "length": 5}, "so_12419603_12419851_0": {"section_id": 1514, "quality": 0.9090909090909091, "length": 30}}}, "12419851": {"ParentId": "12419603", "CommentCount": "6", "Body": "<p>The requirement for <code>priority_queue</code> is (\u00a723.6.4 of the C++ Standard) that the comparator defines a <em>strict, weak ordering</em>. The latter is defined in \u00a725.4/4 as follows:</p>\n<blockquote>\n<p id=\"so_12419603_12419851_0\">The term strict refers to the requirement of an irreflexive relation (!comp(x, x) for all x), and the term weak to requirements that are not as strong as those for a total ordering, but stronger than those for a partial ordering. If we define equiv(a, b) as !comp(a, b) &amp;&amp; !comp(b, a), then the requirements are that comp and equiv both be transitive relations:</p>\n<p id=\"so_12419603_12419851_1\">\u2014 comp(a, b) &amp;&amp; comp(b, c) implies comp(a, c)</p>\n<p id=\"so_12419603_12419851_2\">\u2014 equiv(a, b) &amp;&amp; equiv(b, c) implies equiv(a, c) [ Note: Under these conditions, it can be shown that</p>\n<p id=\"so_12419603_12419851_3\">i) equiv is an equivalence relation</p>\n<p id=\"so_12419603_12419851_4\">ii) comp induces a well-defined relation on the equivalence classes determined by equiv</p>\n<p id=\"so_12419603_12419851_5\">iii) The induced relation is a strict total ordering. \u2014 end note ]</p>\n</blockquote>\n<p>In other words, the comparator-defined relation does not have to be total, but it must be total with respect to the equivalence classes defined by a hypothetical relation <code>equiv</code>, which defines all elements as equal that are not less-than or greater-than each other.</p>\n<p><strong>To put it in even simpler terms, any elements not covered by the comparator relation will be treated as equal.</strong></p>\n", "OwnerUserId": "777186", "PostTypeId": "2", "Id": "12419851", "Score": "7", "CreationDate": "2012-09-14T07:20:55.690", "LastActivityDate": "2012-09-14T07:20:55.690"}});