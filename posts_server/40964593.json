post_cb({"40964593": {"CommentCount": "1", "AcceptedAnswerId": "40964747", "PostTypeId": "1", "LastEditorUserId": "5960850", "CreationDate": "2016-12-04T22:42:47.790", "LastActivityDate": "2016-12-04T23:06:21.860", "LastEditDate": "2016-12-04T22:51:29.943", "ViewCount": "298", "FavoriteCount": "1", "Title": "Does typedef-ing a template type instantiate it?", "Id": "40964593", "Score": "3", "Body": "<p>If I use <code>typedef</code> to rename a specialization of a template class (or struct), will that instantiate the template of that type in the assembly codegen? For example:</p>\n<pre><code>template&lt;class T&gt; struct Key\n{\n    float _time = 0.0f;\n    T _value = T();\n};\ntypedef Key&lt;glm::vec3&gt; VectorKey;\ntypedef Key&lt;glm::quat&gt; QuatKey;\n</code></pre>\n<p>Will this create the <code>Key&lt;glm::vec3&gt;</code> and <code>Key&lt;glm::quat&gt;</code> structs in my file so that I now have (essentially)</p>\n<pre><code>template&lt;class T&gt; struct Key\n{\n    float _time = 0.0f;\n    T _value = T();\n};\nstruct VectorKey\n{\n    float _time = 0.0f;\n    glm::vec3 _value = glm::vec3();\n};\nstruct QuatKey\n{\n    float _time = 0.0f;\n    glm::quat _value = glm::quat();\n};\n</code></pre>\n<p>I'm wondering if it's a bad idea to include a <code>typedef</code> in the header because if this happened, any files that included this header would then have more code included that is unnecessary.</p>\n", "Tags": "<c++><templates><typedef>", "OwnerUserId": "5960850", "AnswerCount": "1"}, "40964747": {"ParentId": "40964593", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>No, typedefs are purely syntactical. Templates are only instantiated when actually used.</p>\n<p>As per the C++14 standard (well, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">the November draft</a> because I can't link directly to the ISO spec) (emphasis mine)</p>\n<blockquote>\n<p id=\"so_40964593_40964747_0\">7.1.3 The <code>typedef</code> specifier<br>\n  [...]<br>\n  A name declared with the <code>typedef</code> specifier becomes a <em>typedef-name</em>. Within the scope of its declaration, a <em>typedef-name</em> is syntactically equivalent to a keyword and names the type associated with the identifier in the way described in Clause 8. A <em>typedef-name</em> is thus a synonym for another type. <strong>A <em>typedef-name</em> does not introduce a new type the way a class declaration (9.1) or enum declaration does</strong>.</br></br></p>\n</blockquote>\n<p>Whereas the term \"instantiating a template\" is the same thing as \"introducing a new type\".</p>\n<p>Imagine that during compilation that each new class/type definition encountered adds it to a \"list-of-types\". Whenever a template is encountered it is not added to the \"list-of-types\" until instantiated.</p>\n", "OwnerUserId": "159145", "LastEditorUserId": "159145", "LastEditDate": "2016-12-04T23:06:21.860", "Id": "40964747", "Score": "3", "CreationDate": "2016-12-04T23:01:16.507", "LastActivityDate": "2016-12-04T23:06:21.860"}, "bq_ids": {"n4140": {"so_40964593_40964747_0": {"section_id": 5407, "quality": 0.9512195121951219, "length": 39}}, "n3337": {"so_40964593_40964747_0": {"section_id": 5202, "quality": 0.9512195121951219, "length": 39}}, "n4659": {"so_40964593_40964747_0": {"section_id": 6829, "quality": 0.9512195121951219, "length": 39}}}});