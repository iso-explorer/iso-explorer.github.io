post_cb({"bq_ids": {"n4140": {"so_34478737_34480149_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6001}}, "n3337": {"so_34478737_34480149_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 5769}}}, "34478954": {"CommentCount": "1", "Body": "<p>My thoughts it's a bug in VS2015, because if you specify user defined copy constructor:</p>\n<pre><code>F(const F&amp;);\n</code></pre>\n<p>or make variable <code>a</code> non-const code will be compiled successfully.</p>\n<p>Looks like object's constness from <code>a</code> transferred into newly created object.</p>\n", "CreationDate": "2015-12-27T08:52:44.897", "ParentId": "34478737", "Id": "34478954", "LastActivityDate": "2015-12-27T08:52:44.897", "PostTypeId": "2", "Score": "0", "OwnerUserId": "3240681"}, "34480149": {"LastActivityDate": "2016-01-11T13:33:50.723", "CommentCount": "4", "Body": "<p>Visual Studio 2015 is not producing the correct result for:</p>\n<pre><code>F{a}\n</code></pre>\n<p>The result should be a prvalue(<em>gcc and clang both have this result</em>) but it is producing an lvalue. I am using the following modified version of the OP's code to produce this result:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass F {\npublic:\n    F(int n, int d) :n_(n), d_(d) {};\n    F(const F&amp;) = default ;\n    F&amp; operator *= (const F&amp;){return *this; }\n    F&amp; operator *= (int) { return *this; }\n    int n() const { return n_ ; }\n    int d() const { return d_ ; }\n    int n_, d_ ;\n};\n\ntemplate&lt;typename T&gt;\nstruct value_category {\n    static constexpr auto value = \"prvalue\";\n};\n\ntemplate&lt;typename T&gt;\nstruct value_category&lt;T&amp;&gt; {\n    static constexpr auto value = \"lvalue\";\n};\n\ntemplate&lt;typename T&gt;\nstruct value_category&lt;T&amp;&amp;&gt; {\n    static constexpr auto value = \"xvalue\";\n};\n\n#define VALUE_CATEGORY(expr) value_category&lt;decltype((expr))&gt;::value\n\nint main()\n{\n  const F a{3, 7};\n  const F b{5, 10};   \n  std::cout &lt;&lt; \"\\n\" &lt;&lt;  VALUE_CATEGORY( F{a} ) &lt;&lt;  \"\\n\";\n}\n</code></pre>\n<p>Hat tip to <a href=\"https://stackoverflow.com/a/16638081/1708801\">Luc Danton for the VALUE_CATEGORY() code</a>.</p>\n<p>Visual Studio using <a href=\"http://webcompiler.cloudapp.net/\" rel=\"nofollow noreferrer\">webcompiler</a> which has a relatively recent version produces:</p>\n<pre><code>lvalue\n</code></pre>\n<p>which must be <em>const</em> in this case to produce the error we are seeing. While both gcc and clang (<em><a href=\"http://melpon.org/wandbox/permlink/FAim3ir6V3qHQWn9\" rel=\"nofollow noreferrer\">see it live</a></em>) produce:</p>\n<pre><code>prvalue\n</code></pre>\n<p>This may be related to equally puzzling Visual Studio bug <a href=\"https://stackoverflow.com/q/34160614/1708801\">std::move of string literal - which compiler is correct?</a>. </p>\n<p>Note we can get the same issue with gcc and clang using a <em>const F</em>:</p>\n<pre><code>using cF = const F ;\nauto result = cF{a} *= b; \n</code></pre>\n<p>so not only is Visual Studio giving us the wrong value category but it also arbitrarily adding a cv-qualifier.</p>\n<p>As Hans noted in his comments to your question using <code>F(a)</code> produces the expected results since it correctly produces a prvalue.</p>\n<p>The relevant section of the draft C++ standard is section <code>5.2.3</code> <em>[expr.type.conv]</em> which says:</p>\n<blockquote>\n<p id=\"so_34478737_34480149_0\">Similarly, a simple-type-specifier or typename-specifier followed by a braced-init-list creates a temporary\n  object of the specified type direct-list-initialized (8.5.4) with the specified braced-init-list, and <strong>its value is\n  that temporary object as a prvalue.</strong></p>\n</blockquote>\n<p>Note, as far as I can tell this is not the <a href=\"https://stackoverflow.com/a/26508755/1708801\">\"old MSVC lvalue cast bug\"</a>. The solution to that issue is to use <code>/Zc:rvalueCast</code> which does not fix this issue. This issue also differs in the incorrect addition of a cv-qualifier which as far as I know does not happen with the previous issue.</p>\n", "CreationDate": "2015-12-27T11:55:36.103", "LastEditDate": "2017-05-23T11:51:59.660", "ParentId": "34478737", "Id": "34480149", "LastEditorUserId": "-1", "PostTypeId": "2", "Score": "8", "OwnerUserId": "1708801"}, "34482489": {"CommentCount": "1", "Body": "<p>Visual C++ has had a bug for some time where an identity cast doesn't produce a temporary, but refers to the original variable.</p>\n<p>Bug report here: <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/615622/identity-cast-to-non-reference-type-violates-standard\" rel=\"nofollow\">identity cast to non-reference type violates standard </a></p>\n", "CreationDate": "2015-12-27T16:40:24.023", "ParentId": "34478737", "Id": "34482489", "LastActivityDate": "2015-12-27T16:40:24.023", "PostTypeId": "2", "Score": "0", "OwnerUserId": "103167"}, "34478737": {"CreationDate": "2015-12-27T08:17:27.973", "ViewCount": "341", "FavoriteCount": "2", "Id": "34478737", "Score": "14", "Title": "Should a C++ temporary be constant?", "LastEditorUserId": "1708801", "CommentCount": "10", "Body": "<p>I have a C++ class that has the following interface:</p>\n<pre><code>class F {\npublic:\n    F(int n, int d);\n    // no other constructors/assignment constructors defined\n    F&amp; operator *= (const F&amp;);\n    F&amp; operator *= (int);\n    int n() const;\n    int d() const;\n};\n</code></pre>\n<p>And I have the following code:</p>\n<pre><code>const F a{3, 7};\nconst F b{5, 10};\nauto result = F{a} *= b; // How does this compile?\n</code></pre>\n<p>Under Visual Studio (VS) 2013, the commented line compiles without error. Under VS2015 , error C2678 is produced:</p>\n<pre><code>error C2678: binary '*=': no operator found \n    which takes a left-hand operand of type 'const F' \n    (or there is no acceptable conversion)\nnote: could be 'F &amp;F::operator *=(const F &amp;)'\nnote: or       'F &amp;F::operator *=(int)'\nnote: while trying to match the argument list '(const F, const F)'\n</code></pre>\n<p>My expectation was that <code>F{a}</code> would create a non-const temporary copy of <code>a</code> to which <code>operator *= (b)</code> would be applied, after which the temporary object would be assigned to <code>result</code>. I did not expect the temporary to be a constant. Interestingly: <code>auto result = F(a) *= b;</code> compiles without error in VS2015, which I thought should be semantically the same.</p>\n<p>My question is: which behaviour is correct VS2015 or VS2013 &amp; why? </p>\n<p>Many thanks</p>\n", "Tags": "<c++><visual-studio-2013><visual-studio-2015><language-lawyer>", "LastEditDate": "2015-12-28T00:51:39.857", "LastActivityDate": "2016-01-11T13:33:50.723", "PostTypeId": "1", "AnswerCount": "4", "OwnerUserId": "5719369"}, "34483683": {"CommentCount": "0", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/language/copy_elision\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/copy_elision</a>:</p>\n<blockquote>\n<p id=\"so_34478737_34483683_0\">Under the following circumstances, the compilers are permitted to omit the \n  copy- and move-constructors of class objects even if copy/move constructor \n  and the destructor have observable side-effects.</p>\n<p id=\"so_34478737_34483683_1\">.......</p>\n<p id=\"so_34478737_34483683_2\">When a <strong>nameless temporary</strong>, not bound to any references, would be moved or \n  copied into an object of the same type (<strong>ignoring top-level cv-</strong>\n<strong>qualification</strong>), the copy/move is omitted. When that temporary is \n  constructed, it is constructed directly in the storage where it would \n  otherwise be moved or copied to. When the nameless temporary is the \n  argument of a return statement, this variant of copy elision is known as \n  RVO, \"return value optimization\".</p>\n</blockquote>\n<p>So the compiler has the option to ignore the copy (which in this case would act as an implicit cast to non-const type).</p>\n", "CreationDate": "2015-12-27T18:50:23.580", "ParentId": "34478737", "Id": "34483683", "LastActivityDate": "2015-12-27T18:50:23.580", "PostTypeId": "2", "Score": "0", "OwnerUserId": "1219722"}});