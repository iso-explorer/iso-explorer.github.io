post_cb({"38853231": {"ParentId": "38851469", "CommentCount": "0", "Body": "<p>GCC is right here. C++14 standard <strong>[basic.type.qualifier]</strong>:</p>\n<blockquote>\n<p id=\"so_38851469_38853231_0\">\u2014 A const object is an object of type const T or a non-mutable subobject of such an object.</p>\n</blockquote>\n<p>So, in your example Z is non-const and therefore cannot be used in a constant expression, just like GCC said:</p>\n<pre><code>error: mutable 'Point::Z' is not usable in a constant expression\n</code></pre>\n", "OwnerUserId": "1989995", "PostTypeId": "2", "Id": "38853231", "Score": "2", "CreationDate": "2016-08-09T14:14:16.803", "LastActivityDate": "2016-08-09T14:14:16.803"}, "38851469": {"CommentCount": "2", "ViewCount": "409", "PostTypeId": "1", "LastEditorUserId": "264325", "CreationDate": "2016-08-09T12:59:25.590", "LastActivityDate": "2016-08-09T15:14:11.673", "Title": "constexpr object with mutable member", "AcceptedAnswerId": "38853754", "LastEditDate": "2016-08-09T14:18:12.793", "Id": "38851469", "Score": "6", "Body": "<p>I came up with this class:</p>\n<pre><code>class Point\n{\npublic:\n    int X, Y;\n    mutable int Z;\n\n    constexpr Point(int x, int y) :X (x), Y(y), Z(0)\n    { }\n\n    constexpr int GetX() const\n    {\n        // Z++; // Wont compile, but following expression is valid!\n        return X+Z;\n    }\n\n    int GetY() const\n    {\n        Z++;\n        return Y;\n    }\n\n    void FoolConst() const\n    {\n        Z++;\n    }\n};\n</code></pre>\n<p>And here is usage:</p>\n<pre><code>template&lt;int S&gt;\nvoid foo()\n{\n    std::cout &lt;&lt; S &lt;&lt; std::endl;\n}\n\nint main()\n{   \n    constexpr Point pt(10, 20);\n\n    pt.FoolConst();\n\n    char arr[pt.GetX()]; // Both compile, but GCC is using extended `new`\n\n    foo&lt;pt.GetX()&gt;(); // GCC fails, VC compiles\n\n    std::cout &lt;&lt; sizeof(arr); // 10 (MSVC), 11 (GCC)\n    std::cout &lt;&lt; pt.GetX();  // 11 (MSVC), 11(GCC)\n}\n</code></pre>\n<p>Questions:</p>\n<ul>\n<li>Why <code>GetX</code> is compiling well with <code>X+Z</code> as return expression (Z is not constexpr).</li>\n<li>How can I call <code>FoolConst</code> and <code>GetY</code> methods out of <code>constexpr</code> object (<code>pt</code>) ? </li>\n<li>The behaviour of <code>GetX</code> in <code>main</code> is different in compilers. MSVC compiles fine with a <code>int</code> as template argument, while GCC (<a href=\"http://ideone.com/mWUu8C\" rel=\"nofollow\">IdeOne</a>) won't compile it.</li>\n</ul>\n<p>For one compiler <code>constexpr GetX</code> is truly <code>constexpr</code>, but for other it is not if <code>X+Z</code> is involved. If I remove <code>+Z</code> and simply <code>return X</code> GCC is okay.</p>\n<p>My question is very basic: If object is <code>constexpr</code> how can it call a non-constexpr method? </p>\n", "Tags": "<c++><c++11><c++14><language-lawyer><constexpr>", "OwnerUserId": "264325", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_38851469_38853356_0": {"section_id": 6185, "quality": 0.9285714285714286, "length": 13}, "so_38851469_38853356_2": {"section_id": 5421, "quality": 0.9259259259259259, "length": 25}, "so_38851469_38853231_0": {"section_id": 7225, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_38851469_38853356_2": {"section_id": 5216, "quality": 0.5925925925925926, "length": 16}, "so_38851469_38853231_0": {"section_id": 750, "quality": 0.6666666666666666, "length": 6}}, "n4659": {"so_38851469_38853356_0": {"section_id": 7687, "quality": 0.7857142857142857, "length": 11}, "so_38851469_38853356_2": {"section_id": 6843, "quality": 0.7407407407407407, "length": 20}, "so_38851469_38853231_0": {"section_id": 8735, "quality": 0.8888888888888888, "length": 8}}}, "38853356": {"ParentId": "38851469", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>A constant expression cannot access a mutable sub-object. This is in <strong>[expr.const]</strong>/2:</p>\n<blockquote>\n<p id=\"so_38851469_38853356_0\">A conditional-expression <code>e</code> is a core constant expression unless the evaluation of e, following the rules of the\n  abstract machine (1.9), would evaluate one of the following expressions: [...]</p>\n<ul>\n<li>an lvalue-to-rvalue conversion (4.1) unless it is applied to [...]\n  \n  <ul>\n<li>a non-volatile glvalue that refers to a non-volatile object defined with constexpr, or that refers\n  to a <strong>non-mutable</strong> sub-object of such an object [...]</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>So <code>GetX</code> cannot be used within a constant expression, e.g. as a template parameter <code>foo&lt;pt.GetX()&gt;()</code>.</p>\n<p>In answer to your specific questions:</p>\n<blockquote id=\"so_38851469_38853356_1\">\n<ul>\n<li>Why GetX is compiling well with X+Y as return expression (Z is not constexpr).</li>\n</ul>\n</blockquote>\n<p>A compiler is not required to check that constexpr functions (incl. member functions) are fully valid when they are <em>defined</em>, only when they are <em>used</em>. It does have to check a few things, like not using <code>goto</code> <strong>[dcl.constexpr]</strong>/3, but it doesn't have to check which objects the definition accesses. This is because whether the constexpr function can be used within a constant expression can depend on the values of its arguments.</p>\n<p>In fact, because <code>GetX</code> unconditionally accesses <code>Z</code>, your program strictly has undefined behavior per <strong>[dcl.constexpr]</strong>/5:</p>\n<blockquote>\n<p id=\"so_38851469_38853356_2\">For a non-template, non-defaulted constexpr function or a non-template, non-defaulted, non-inheriting\n  constexpr constructor, if no argument values exist such that an invocation of the function or constructor\n  could be an evaluated subexpression of a core constant expression (5.19), the program is ill-formed; no\n  diagnostic required.</p>\n</blockquote>\n<p>\"Ill-formed; no diagnostic required\" is another way of saying that the behavior of your program is undefined.</p>\n<blockquote id=\"so_38851469_38853356_3\">\n<ul>\n<li>How can I call FoolConst and GetY methods out of constexpr object (pt) ?</li>\n</ul>\n</blockquote>\n<p>That's absolutely fine; an object declared <code>constexpr</code> is just a <code>const</code> object from the point of view of non-<code>constexpr</code> member functions of that object.</p>\n<blockquote id=\"so_38851469_38853356_4\">\n<ul>\n<li>The behaviour of GetX in main is different in compilers. MSVC compiles fine with a int as template argument, while GCC (IdeOne) won't compile it.</li>\n</ul>\n</blockquote>\n<p>Unfortunately, both compilers are correct; your program has undefined behavior in the definition of <code>GetX</code>, so there is no single correct behavior for the compiler.</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2016-08-09T15:14:11.673", "Id": "38853356", "Score": "4", "CreationDate": "2016-08-09T14:20:01.077", "LastActivityDate": "2016-08-09T15:14:11.673"}, "38853754": {"ParentId": "38851469", "CommentCount": "1", "Body": "<p>Answers:</p>\n<ul>\n<li>Why GetX is compiling well with X+Y as return expression (Z is not constexpr).</li>\n<li><ul>\n<li>Because whole object is constant after having been declared with <code>constexpr</code>. Const-ness of the object is always derived by all members, except when the member is declared <code>mutable</code>.</li>\n</ul></li>\n<li>How can I call FoolConst and GetY methods out of constexpr object (pt) ?\nThe behaviour of GetX in main is different in compilers. MSVC compiles fine with a int as template argument, while GCC (IdeOne) won't compile it.</li>\n<li><ul>\n<li>It works for me, with gcc 4.8.3. Everything is fine, as long as you don't use <code>Z</code> in <code>GetX()</code> because the use of <code>mutable</code> field destroys <code>constexpr</code> (OTOH the behavior of gcc is a little bit misleading because it should report the error already in the definition of <code>GetX()</code>: either that it must be defined or otherwise can't be <code>constexpr</code>, or when defined it cannot use mutable fields or variables defined outside the class).</li>\n</ul></li>\n<li><ul>\n<li>If you have a compiler that compiles fine passing the result of <code>GetX()</code> as template argument, which refers to a <code>mutable</code> field, it surely breaks the standard and this behavior is actually undefined because it should produce the same result (due to the fact that it's resolved in compile time) no matter what happened to the runtime value of Z.</li>\n</ul></li>\n</ul>\n", "OwnerUserId": "657412", "PostTypeId": "2", "Id": "38853754", "Score": "1", "CreationDate": "2016-08-09T14:36:24.160", "LastActivityDate": "2016-08-09T14:36:24.160"}});