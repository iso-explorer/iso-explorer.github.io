post_cb({"20828970": {"ParentId": "20828907", "LastEditDate": "2014-01-16T15:02:04.183", "CommentCount": "9", "CreationDate": "2013-12-29T19:07:04.137", "OwnerUserId": "150634", "LastEditorUserId": "150634", "PostTypeId": "2", "Id": "20828970", "Score": "87", "Body": "<p>A defaulted default constructor is specifically defined as being the same as a user-defined default constructor with no initialization list and an empty compound statement.</p>\n<blockquote>\n<p id=\"so_20828907_20828970_0\"><em>\u00a712.1/6 [class.ctor]</em> A default constructor that is defaulted and not defined as deleted is implicitly defined when it is odr-used to create an object of its class type or when it is explicitly defaulted after its first declaration. The implicitly-defined default constructor performs the set of initializations of the class that would be performed by a user-written default constructor for that class with no ctor-initializer (12.6.2) and an empty compound-statement. [...]</p>\n</blockquote>\n<p>However, while both constructors will behave the same, providing an empty implementation does affect some properties of the class. Giving a user-defined constructor, even though it does nothing, makes the type not an <em>aggregate</em> and also not <em>trivial</em>. If you want your class to be an aggregate or a trivial type (or by transitivity, a POD type), then you need to use <code>= default</code>.</p>\n<blockquote>\n<p id=\"so_20828907_20828970_1\"><em>\u00a78.5.1/1 [dcl.init.aggr]</em> An aggregate is an array or a class with no user-provided constructors, [and...]</p>\n</blockquote>\n<blockquote>\n<p id=\"so_20828907_20828970_2\"><em>\u00a712.1/5 [class.ctor]</em> A default constructor is trivial if it is not user-provided and [...]</p>\n<p id=\"so_20828907_20828970_3\"><em>\u00a79/6 [class]</em> A trivial class is a class that has a trivial default constructor and [...]</p>\n</blockquote>\n<p>To demonstrate:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nstruct X {\n    X() = default;\n};\n\nstruct Y {\n    Y() { };\n};\n\nint main() {\n    static_assert(std::is_trivial&lt;X&gt;::value, \"X should be trivial\");\n    static_assert(std::is_pod&lt;X&gt;::value, \"X should be POD\");\n\n    static_assert(!std::is_trivial&lt;Y&gt;::value, \"Y should not be trivial\");\n    static_assert(!std::is_pod&lt;Y&gt;::value, \"Y should not be POD\");\n}\n</code></pre>\n<p>Additionally, explicitly defaulting a constructor will make it <code>constexpr</code> if the implicit constructor would have been and will also give it the same exception specification that the implicit constructor would have had. In the case you've given, the implicit constructor would not have been <code>constexpr</code> (because it would leave a data member uninitialized) and it would also have an empty exception specification, so there is no difference. But yes, in the general case you could manually specify <code>constexpr</code> and the exception specification to match the implicit constructor.</p>\n<p>Using <code>= default</code> does bring some uniformity, because it can also be used with copy/move constructors and destructors. An empty copy constructor, for example, will not do the same as a defaulted copy constructor (which will perform member-wise copy of its members). Using the <code>= default</code> (or <code>= delete</code>) syntax uniformly for each of these special member functions makes your code easier to read by explicitly stating your intent.</p>\n", "LastActivityDate": "2014-01-16T15:02:04.183"}, "20829116": {"ParentId": "20828907", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2210.html\" rel=\"nofollow noreferrer\">n2210</a> provides some reasons:</p>\n<blockquote>\n<p id=\"so_20828907_20829116_0\">The management of defaults has several problems:</p>\n<ul>\n<li>Constructor definitions are coupled; declaring any constructor suppresses the default constructor.</li>\n<li>The destructor default is inappropriate to polymorphic classes, requiring an explicit definition.</li>\n<li>Once a default is suppressed, there is no means to resurrect it.</li>\n<li>Default implementations are often more efficient than manually specified implementations.</li>\n<li>Non-default implementations are non-trivial, which affects type semantics, e.g. makes a type non-POD.</li>\n<li>There is no means to prohibit a special member function or global operator without declaring a (non-trivial) substitute.</li>\n</ul>\n</blockquote>\n<hr/>\n<blockquote>\n<pre><code>type::type() = default;\ntype::type() { x = 3; }\n</code></pre>\n<p id=\"so_20828907_20829116_1\">In some cases, the class body can change without requiring a change in member function definition because the default changes with\n  declaration of additional members.</p>\n</blockquote>\n<p>See <a href=\"https://stackoverflow.com/questions/4782757/rule-of-three-becomes-rule-of-five-with-c11\">Rule-of-Three becomes Rule-of-Five with C++11?</a>:</p>\n<blockquote>\n<p id=\"so_20828907_20829116_2\">Note that move constructor and move assignment operator won't be\n  generated for a class that explicitly declares any of the other\n  special member functions, that copy constructor and copy assignment\n  operator won't be generated for a class that explicitly declares a\n  move constructor or move assignment operator, and that a class with a\n  explicitly declared destructor and implicitly defined copy constructor\n  or implicitly defined copy assignment operator is considered\n  deprecated</p>\n</blockquote>\n", "Id": "20829116", "LastEditDate": "2017-05-23T12:26:15.373", "OwnerDisplayName": "user1508519", "Score": "9", "CreationDate": "2013-12-29T19:18:54.000", "LastActivityDate": "2013-12-29T19:18:54.000", "LastEditorUserId": "-1"}, "bq_ids": {"n4140": {"so_20828907_20828970_1": {"section_id": 369, "quality": 0.5714285714285714, "length": 4}, "so_20828907_20828970_0": {"section_id": 370, "quality": 0.8780487804878049, "length": 36}, "so_20828907_20828970_3": {"section_id": 369, "quality": 0.7142857142857143, "length": 5}, "so_20828907_20828970_2": {"section_id": 369, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_20828907_20828970_1": {"section_id": 359, "quality": 0.5714285714285714, "length": 4}, "so_20828907_20828970_3": {"section_id": 5620, "quality": 0.8571428571428571, "length": 6}, "so_20828907_20828970_0": {"section_id": 360, "quality": 0.8780487804878049, "length": 36}, "so_20828907_20828970_2": {"section_id": 359, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_20828907_20828970_1": {"section_id": 4063, "quality": 0.5714285714285714, "length": 4}, "so_20828907_20828970_3": {"section_id": 484, "quality": 0.7142857142857143, "length": 5}, "so_20828907_20828970_0": {"section_id": 384, "quality": 0.8780487804878049, "length": 36}}}, "20863581": {"ParentId": "20828907", "CommentCount": "0", "Body": "<p>It's a matter of semantics in some cases.  It's not very obvious with default constructors, but it becomes obvious with other compiler-generated member functions.</p>\n<p>For the default constructor, it would have been possible to make any default constructor with an empty body be considered a candidate for being a trivial constructor, same as using <code>=default</code>.  After all, the old empty default constructors were <em>legal C++</em>.</p>\n<pre><code>struct S { \n  int a; \n  S() {} // legal C++ \n};\n</code></pre>\n<p>Whether or not the compiler understands this constructor to be trivial is irrelevant in most cases outside of optimizations (manual or compiler ones).</p>\n<p>However, this attempt to treat empty function bodies as \"default\" breaks down entirely for other types of member functions.  Consider the copy constructor:</p>\n<pre><code>struct S { \n  int a; \n  S() {}\n  S(const S&amp;) {} // legal, but semantically wrong\n};\n</code></pre>\n<p>In the above case, the copy constructor written with an empty body is now <em>wrong</em>.  It's no longer actually copying anything.  This is a very different set of semantics than the default copy constructor semantics.  The desired behavior requires you to write some code:</p>\n<pre><code>struct S { \n  int a; \n  S() {}\n  S(const S&amp; src) : a(src.a) {} // fixed\n};\n</code></pre>\n<p>Even with this simple case, however, it's becoming much more of a burden for the compiler to verify that the copy constructor is identical to the one it would generate itself or for it to see that the copy constructor is <em>trivial</em> (equivalent to a <code>memcpy</code>, basically).  The compiler would have to check each member initializer expression and ensure it's identical to the expression to access the source's corresponding member and nothing else, make sure no members are left with non-trivial default construction, etc.  It's backwards in a way of the process the compiler would use to verify that it's own generated versions of this function is trivial.</p>\n<p>Consider then the copy assignment operator which can get even hairier, especially in the non-trivial case.  It's a ton of boiler-plate that you don't want to have to write for many classes but you're be forced to anyway in C++03:</p>\n<pre><code>struct T { \n  std::shared_ptr&lt;int&gt; b; \n  T(); // the usual definitions\n  T(const T&amp;);\n  T&amp; operator=(const T&amp; src) {\n    if (this != &amp;src) // not actually needed for this simple example\n      b = src.b; // non-trivial operation\n    return *this;\n};\n</code></pre>\n<p>That is a simple case, but it's already more code than you would ever want to be forced to write for such a simple type as <code>T</code> (especially once we toss move operations into the mix).  We can't rely on an empty body meaning \"fill in the defaults\" because the empty body is already perfectly valid and has a clear meaning.  In fact, if the empty body were used to denote \"fill in the defaults\" then there'd be no way to explicitly make a no-op copy constructor or the like.</p>\n<p>It's again a matter of consistency.  The empty body means \"do nothing\" but for things like copy constructors you really don't want \"do nothing\" but rather \"do all the things you'd normally do if not suppressed.\"  Hence <code>=default</code>.  It's <em>necessary</em> for overcoming suppressed compiler-generated member functions like copy/move constructors and assignment operators.  It's then just \"obvious\" to make it work for the default constructor as well.</p>\n<p>It might have been nice to make default constructor with empty bodies and trivial member/base constructors also be considered trivial just as they would have been with <code>=default</code> if only to make older code more optimal in some cases, but most low-level code relying on trivial default constructors for optimizations also relies on trivial copy constructors.  If you're going to have to go and \"fix\" all your old copy constructors, it's really not much of a stretch to have to fix all your old default constructors, either.  It's also much clearer and more obvious using an explicit <code>=default</code> to denote your intentions.</p>\n<p>There are a few other things that compiler-generated member functions will do that you'd have to explicitly make changes to support, as well.  Supporting <code>constexpr</code> for default constructors is one example.  It's just easier mentally to use <code>=default</code> than having to mark up functions with all the other special keywords and such that are implied by <code>=default</code> and that was one of the themes of C++11: make the language easier.  It's still got plenty of warts and back-compat compromises but it's clear that it's a big step forward from C++03 when it comes to ease-of-use.</p>\n", "OwnerUserId": "720860", "PostTypeId": "2", "Id": "20863581", "Score": "2", "CreationDate": "2013-12-31T21:53:48.000", "LastActivityDate": "2013-12-31T21:53:48.000"}, "20828907": {"CommentCount": "4", "ViewCount": "25955", "LastActivityDate": "2014-01-16T15:02:04.183", "Body": "<p>I don't understand why would I ever do this:</p>\n<pre><code>struct S { \n    int a; \n    S(int aa) : a(aa) {} \n    S() = default; \n};\n</code></pre>\n<p>Why not just say:</p>\n<pre><code>S() {} // instead of S() = default;\n</code></pre>\n<p>why bring in a new keyword for that?</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "20828970", "FavoriteCount": "30", "Title": "The new keyword =default in C++11", "Id": "20828907", "Score": "75", "CreationDate": "2013-12-29T19:01:59.383", "Tags": "<c++><c++11>", "OwnerUserId": "3111311", "AnswerCount": "3"}});