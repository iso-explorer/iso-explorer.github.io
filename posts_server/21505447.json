post_cb({"21505558": {"CommentCount": "0", "Body": "<p>The end iterator of a vector does not point to anything. As long as you don't dereference it, it should be fine. It is why the range is considered to be <code>[first, last)</code>. This is why when you do this:</p>\n<pre><code>int a[5] = {1,2,3,4,5};\nstd::vector&lt;int&gt; v(&amp;a[0], &amp;a[0] + 5);\n</code></pre>\n<p>You put <code>5</code> and not <code>4</code>.</p>\n<p>If the vector is empty, then <code>vector.end() == vector.end()</code>, and you shouldn't dereference <code>vector.begin()</code>.</p>\n", "CreationDate": "2014-02-02T00:31:17.407", "OwnerDisplayName": "user1508519", "ParentId": "21505447", "Id": "21505558", "LastActivityDate": "2014-02-02T00:31:17.407", "PostTypeId": "2", "Score": "0"}, "21505491": {"CommentCount": "3", "Body": "<p>Quoth the Standard (emphasis mine),</p>\n<blockquote>\n<p id=\"so_21505447_21505491_0\"><strong>For the purposes of these operators, a pointer to a nonarray object behaves the same as a pointer to the first element of an array of length one with the type of the object as its element type.</strong> When an expression that has integral type is added to or subtracted from a pointer, the result has the type\n  of the pointer operand. If the pointer operand points to an element of an array object, and the array is\n  large enough, the result points to an element offset from the original element such that the difference of\n     the subscripts of the resulting and original array elements equals the integral expression. In other words, if\n    the expression P points to the i-th element of an array object, the expressions (P)+N (equivalently, N+(P))\n   and (P)-N (where N has the value n) point to, respectively, the i + n-th and i \u2212 n-th elements of the array\n    object, provided they exist. <strong>Moreover, if the expression P points to the last element of an array object,\n   the expression (P)+1 points one past the last element of the array object</strong>, and if the expression Q points\n  one past the last element of an array object, the expression (Q)-1 points to the last element of the array\n  object. If both the pointer operand and the result point to elements of the same array object, or one past\n  the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is\n   undefined.</p>\n</blockquote>\n<p>(ISO/IEC 14882:2011 \u00a75.7 Additive operators [expr.add] paragraphs 4-5)</p>\n<p>So yes, this is perfectly kosher, just like it would be if you were using an array with one element. The <em>meaning</em> of <code>&amp;c + 1</code> is just like it says: \"one past the last element\". It doesn't point to any object you're allowed to access, but it's valid to use otherwise.</p>\n", "CreationDate": "2014-02-02T00:21:21.910", "ParentId": "21505447", "Id": "21505491", "LastActivityDate": "2014-02-02T00:21:21.910", "PostTypeId": "2", "Score": "4", "OwnerUserId": "481267"}, "21505521": {"CommentCount": "0", "Body": "<p>Technically, every pointer is a random access iterator and every random access iterator is an input iterator which is what you need to construct a <code>std::vector</code> from a range.</p>\n<p>So this is perfectly legal.</p>\n<p>Since you can compare input iterators, wrapping would not be a problem because you can just implement the constructor like</p>\n<pre><code>for (auto i = InputFirst; i != InputLast; ++i)\n    //construct the vector\n</code></pre>\n<p>If <code>&amp;c+1</code> wraps, so does <code>++i</code> and then <code>i==&amp;c+1</code>, so no problem.</p>\n", "CreationDate": "2014-02-02T00:26:16.163", "ParentId": "21505447", "Id": "21505521", "LastActivityDate": "2014-02-02T00:26:16.163", "PostTypeId": "2", "Score": "1", "OwnerUserId": "3002139"}, "21505447": {"CreationDate": "2014-02-02T00:14:50.343", "ViewCount": "78", "Id": "21505447", "AcceptedAnswerId": "21505491", "Score": "1", "Title": "Valid iterator range from char on stack", "LastEditorUserId": "710408", "CommentCount": "1", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main()\n{\n    char c = 'c';\n    std::vector&lt;char&gt; v(&amp;c, &amp;c + 1);\n\n    std::cout &lt;&lt; v.size() &lt;&lt; '\\n'; // 1\n\n    return 0;\n\n}\n</code></pre>\n<p>Compiler says this program is OK. Does this mean that the pair <code>&amp;c, &amp;c + 1</code> are a valid iterator range? Is there not an edge case where <code>&amp;c + 1</code> wraps? (I cannot really imagine it being possible that &amp;c + 1 would wrap but it is troubling me what it means!)</p>\n", "Tags": "<c++>", "LastEditDate": "2014-02-02T00:20:10.180", "LastActivityDate": "2014-02-02T00:31:17.407", "PostTypeId": "1", "AnswerCount": "3", "OwnerUserId": "710408"}, "bq_ids": {"n4140": {"so_21505447_21505491_0": {"length": 106, "quality": 0.8346456692913385, "section_id": 6142}}, "n3337": {"so_21505447_21505491_0": {"length": 106, "quality": 0.8346456692913385, "section_id": 5906}}}});