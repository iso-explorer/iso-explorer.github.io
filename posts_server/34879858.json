post_cb({"bq_ids": {"n4140": {"so_34879858_34912703_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 7239}, "so_34879858_34912703_4": {"length": 5, "quality": 0.7142857142857143, "section_id": 416}, "so_34879858_34912703_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 416}, "so_34879858_34880264_3": {"length": 29, "quality": 0.90625, "section_id": 7201}, "so_34879858_34880264_1": {"length": 39, "quality": 0.9512195121951219, "section_id": 7200}, "so_34879858_34912703_6": {"length": 9, "quality": 0.8181818181818182, "section_id": 7239}, "so_34879858_34912703_8": {"length": 8, "quality": 0.8, "section_id": 7239}, "so_34879858_34880264_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 7200}, "so_34879858_34880264_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 7200}, "so_34879858_34912703_7": {"length": 22, "quality": 0.9565217391304348, "section_id": 7239}, "so_34879858_34912703_9": {"length": 4, "quality": 0.8, "section_id": 45}, "so_34879858_34912703_5": {"length": 8, "quality": 0.8888888888888888, "section_id": 7239}}, "n3337": {"so_34879858_34912703_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 6983}, "so_34879858_34912703_4": {"length": 5, "quality": 0.7142857142857143, "section_id": 407}, "so_34879858_34912703_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 407}, "so_34879858_34880264_3": {"length": 29, "quality": 0.90625, "section_id": 6945}, "so_34879858_34880264_1": {"length": 39, "quality": 0.9512195121951219, "section_id": 6944}, "so_34879858_34912703_6": {"length": 9, "quality": 0.8181818181818182, "section_id": 6983}, "so_34879858_34912703_8": {"length": 8, "quality": 0.8, "section_id": 6983}, "so_34879858_34880264_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 6944}, "so_34879858_34880264_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 6944}, "so_34879858_34912703_7": {"length": 22, "quality": 0.9565217391304348, "section_id": 6983}, "so_34879858_34912703_9": {"length": 4, "quality": 0.8, "section_id": 42}, "so_34879858_34912703_5": {"length": 8, "quality": 0.8888888888888888, "section_id": 6983}}, "n4659": {"so_34879858_34912703_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 8748}, "so_34879858_34912703_4": {"length": 5, "quality": 0.7142857142857143, "section_id": 434}, "so_34879858_34912703_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 434}, "so_34879858_34880264_3": {"length": 29, "quality": 0.90625, "section_id": 8710}, "so_34879858_34880264_1": {"length": 36, "quality": 0.8780487804878049, "section_id": 8709}, "so_34879858_34912703_6": {"length": 9, "quality": 0.8181818181818182, "section_id": 8748}, "so_34879858_34912703_8": {"length": 8, "quality": 0.8, "section_id": 8748}, "so_34879858_34880264_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 8709}, "so_34879858_34880264_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 8709}, "so_34879858_34912703_7": {"length": 22, "quality": 0.9565217391304348, "section_id": 8748}, "so_34879858_34912703_9": {"length": 4, "quality": 0.8, "section_id": 46}, "so_34879858_34912703_5": {"length": 8, "quality": 0.8888888888888888, "section_id": 8748}}}, "34880264": {"Id": "34880264", "PostTypeId": "2", "Body": "<p>Quoting from N4140 (roughly C++14):</p>\n<blockquote>\n<p id=\"so_34879858_34880264_0\"><strong>3.9 Types [basic.types]</strong></p>\n<p id=\"so_34879858_34880264_1\">2 For any object (other than a base-class subobject) of trivially copyable type <code>T</code>, whether or not the object holds a valid value of type <code>T</code>, the underlying bytes (1.7) making up the object can be copied into an array of <code>char</code> or <code>unsigned char</code>.<sup>42</sup> If the content of the array of <code>char</code> or <code>unsigned char</code> is copied back into the object, the object shall subsequently hold its original value.</p>\n<p id=\"so_34879858_34880264_2\">42) By using, for example, the library functions (17.6.1.2) <code>std::memcpy</code> or <code>std::memmove</code>.</p>\n<p id=\"so_34879858_34880264_3\">3 For any trivially copyable type <code>T</code>, if two pointers to <code>T</code> point to distinct <code>T</code> objects <code>obj1</code> and <code>obj2</code>, where neither <code>obj1</code> nor <code>obj2</code> is a base-class subobject, if the underlying bytes (1.7) making up <code>obj1</code> are copied\n  into <code>obj2</code>,<sup>43</sup> <code>obj2</code> shall subsequently hold the same value as <code>obj1</code>. [ <em>Example:</em> ... ]</p>\n<p id=\"so_34879858_34880264_4\">43) By using, for example, the library functions (17.6.1.2) <code>std::memcpy</code> or <code>std::memmove</code>.</p>\n</blockquote>\n<p>This does, in principle, allow assignment directly to <code>s[2]</code> if you take the position that assignment to <code>s[2]</code> is indirectly required to be equivalent to copying all of some other <code>Blob</code> into an array that just happens to be bytewise identical except for the third byte, and copying it into your <code>Blob</code>: you're not assigning to <code>s[0]</code>, <code>s[1]</code>, etc. For trivially copyable types including <code>char</code>, that is equivalent to setting them to the exact value they already have, which also has no observable effect.</p>\n<p>However, if the only way to get <code>s[2] == 'A'</code> is by memory manipulation, then a valid argument could also be made that what you're copying back into your <code>Blob</code> <em>isn't</em> the underlying bytes that made up any previous <code>Blob</code>. In that case, technically, the behaviour would be undefined by omission.</p>\n<p>I do strongly suspect, especially given the \"whether or not the object holds a valid value of type <code>T</code>\" comment, that it's intended to be allowed.</p>\n", "LastEditorUserId": "743382", "LastActivityDate": "2016-01-19T15:46:26.160", "Score": "5", "CreationDate": "2016-01-19T15:09:42.843", "ParentId": "34879858", "CommentCount": "1", "OwnerUserId": "743382", "LastEditDate": "2016-01-19T15:46:26.160"}, "34879858": {"ViewCount": "203", "Body": "<p>Let's consider following piece of code:</p>\n<pre><code>struct Blob {\n    double x, y, z;\n} blob;\n\nchar* s = reinterpret_cast&lt;char*&gt;(&amp;blob);\ns[2] = 'A';\n</code></pre>\n<p>Assuming that sizeof(double) is 8, does this code trigger undefined behaviour?</p>\n", "Title": "Pointer arithmetics on non-array types", "CreationDate": "2016-01-19T14:51:27.760", "LastActivityDate": "2016-01-20T23:32:42.847", "CommentCount": "11", "LastEditDate": "2016-01-19T15:30:26.640", "PostTypeId": "1", "LastEditorUserId": "819272", "Id": "34879858", "Score": "7", "OwnerUserId": "5245033", "Tags": "<c++><language-lawyer><type-punning><char-pointer>", "AnswerCount": "2"}, "34912703": {"Id": "34912703", "PostTypeId": "2", "Body": "<p>Chapter 3.10 of the standard seems to allow for that specific case, assuming that \"access the stored value\" means \"read or write\", which is unclear.</p>\n<blockquote>\n<p id=\"so_34879858_34912703_0\">3.10-10</p>\n<p id=\"so_34879858_34912703_1\">If a program attempts to <strong>access the stored value of an object through\n  a glvalue of other than one of the following types the behavior is\n  unde\ufb01ned</strong>:</p>\n<p id=\"so_34879858_34912703_2\">\u2014(10.1) the dynamic type of the object, </p>\n<p id=\"so_34879858_34912703_3\">\u2014(10.2) a cv-quali\ufb01ed version of the dynamic type of the object, </p>\n<p id=\"so_34879858_34912703_4\">\u2014(10.3) a type similar (as de\ufb01ned in 4.4) to the dynamic type of the\n  object, </p>\n<p id=\"so_34879858_34912703_5\">\u2014(10.4) a type that is the signed or unsigned type corresponding to\n  the dynamic type of the object, </p>\n<p id=\"so_34879858_34912703_6\">\u2014(10.5) a type that is the signed or unsigned type corresponding to a\n  cv-quali\ufb01ed version of the dynamic type of the object, </p>\n<p id=\"so_34879858_34912703_7\">\u2014(10.6) an aggregate or union type that includes one of the\n  aforementioned types among its elements or nonstatic data members\n  (including, recursively, an element or non-static data member of a\n  subaggregate or contained union), </p>\n<p id=\"so_34879858_34912703_8\">\u2014(10.7) a type that is a (possibly cv-quali\ufb01ed) base class type of the\n  dynamic type of the object, </p>\n<p id=\"so_34879858_34912703_9\">\u2014(10.8) <strong>a char or unsigned char type</strong>.</p>\n</blockquote>\n", "LastActivityDate": "2016-01-20T23:32:42.847", "CommentCount": "0", "CreationDate": "2016-01-20T23:32:42.847", "ParentId": "34879858", "Score": "0", "OwnerUserId": "5695504"}});