post_cb({"bq_ids": {"n4140": {"so_18102156_18285077_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7225}, "so_18102156_18285077_1": {"length": 39, "quality": 0.9512195121951219, "section_id": 41}}, "n3337": {"so_18102156_18285077_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6969}, "so_18102156_18285077_1": {"length": 39, "quality": 0.9512195121951219, "section_id": 38}}, "n4659": {"so_18102156_18285077_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 8735}, "so_18102156_18285077_1": {"length": 39, "quality": 0.9512195121951219, "section_id": 41}}}, "18102909": {"Id": "18102909", "PostTypeId": "2", "Body": "<p>I think that in your equation you are expecting <code>const</code> to play a bigger role than what it really has.</p>\n<p><code>const</code> is a qualifier, and simply put, its role is to regulate the way you access a type or a variable.</p>\n<p>The main point is if the language itself, without even considering what is <code>const</code> or not, already regulates a given behaviour, your specific case is not that different from the one reported by that FAQ.</p>\n<p>You are in a really simple situation, and you should probably think in much simpler terms.</p>\n", "LastActivityDate": "2013-08-07T12:04:40.750", "CommentCount": "1", "CreationDate": "2013-08-07T12:04:40.750", "ParentId": "18102156", "Score": "0", "OwnerUserId": "2485710"}, "18102156": {"ViewCount": "508", "Body": "<p>Please read my question before linking parashift, I can google search, this is slightly different case.</p>\n<p>This isn't allowed</p>\n<pre><code>Child **cc;\nBase ** bb = cc;\n</code></pre>\n<p>Because you could do</p>\n<pre><code>*bb = new OtherChild;\n</code></pre>\n<p>But if we have</p>\n<pre><code>Child **cc;\nconst Base *const *const bb = cc;\n</code></pre>\n<p>I don't think all those const are necessary for my example, but just to be sure..</p>\n<p>I think the minimum which should work is </p>\n<pre><code>Base *const *bb = cc;\n</code></pre>\n<p>Then you can't do this</p>\n<pre><code>*bb = new OtherChild;\n</code></pre>\n<p>So it should be safe. But why isn't it allowed?</p>\n", "AcceptedAnswerId": "18285077", "Title": "Conversion from Derived** to Base*const*", "CreationDate": "2013-08-07T11:26:06.053", "Id": "18102156", "CommentCount": "18", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-08-07T11:39:29.230", "LastEditorUserId": "2068573", "LastActivityDate": "2013-08-19T10:19:46.773", "Score": "9", "OwnerUserId": "2068573", "Tags": "<c++>", "AnswerCount": "3"}, "18284656": {"Id": "18284656", "PostTypeId": "2", "Body": "<p>This is a constraint imposed by the C++ language, because implicit conversion of pointer types is based on inheritance rules (with the exception of implicit conversion to <code>void *</code>).</p>\n<p>That is, given the following program, the assignment is only allowed if <code>T</code> is a base of <code>U</code>:</p>\n<pre><code>T const *x;\nU *y;\nx = y;\n</code></pre>\n<p>However, in your case:</p>\n<pre><code>typedef Base *T;\ntypedef Child *U;\n</code></pre>\n<p>The relationship between <code>Base</code> and <code>Child</code> does not transfer to their pointer types. So, there is no inheritance relationship between \"pointer to <code>Base</code>\" and \"pointer to <code>Child</code>\" to allow the direct assignment you desire.</p>\n", "LastActivityDate": "2013-08-17T02:54:01.620", "CommentCount": "0", "CreationDate": "2013-08-17T02:54:01.620", "ParentId": "18102156", "Score": "1", "OwnerUserId": "315052"}, "18285077": {"Id": "18285077", "PostTypeId": "2", "Body": "<p>You're confusing two cases:</p>\n<ul>\n<li>The addition of <code>const</code></li>\n<li>Upcasts</li>\n</ul>\n<p>While formally (in computer science theory) both of these deal with subclassing, the reality is that the C++ rules for these are different, because the representation of <code>const T</code> and <code>T</code> are guaranteed to be the same, while the representations of <code>Base*</code> and <code>Derived*</code> often differ by an offset (but may be radically different when virtual inheritance is involved).</p>\n<p>In 3.9.3, the Standard declares that</p>\n<blockquote>\n<p id=\"so_18102156_18285077_0\">The <em>cv-qualified</em> or <em>cv-unqualified</em> versions of a type are distinct types; however, they shall have the same representation and alignment requirements</p>\n</blockquote>\n<p>Given:</p>\n<pre><code>struct Base {};\nstruct Derived : Base {};\nDerived* pd = nullptr;\nBase* pb = pd;\n</code></pre>\n<p><code>const</code> can indeed by added in the way you suggest.</p>\n<pre><code>Base const* const* const cpcpcb = &amp;pb;\nBase* const* pcpb = &amp;pb; // legal, pointer can't be changed\nBase const* * ppcb = &amp;pb; // illegal, one could try to rebind the pointer\n                          // to a truly const object, then\n                          // use pb to mutate the const object\n</code></pre>\n<p>But there is no is-a relationship between <code>Derived*</code> and <code>Base*</code>.  A conversion exists, but the <code>Derived*</code> variable does not necessarily contain the address of a <code>Base</code> object (the <code>Base</code> subobject within the <code>Derived</code> object may have a different address).  And therefore <strong>both the line you're complaining about, and the line your question assumed was valid, are illegal</strong>:</p>\n<pre><code>Base const* const* const cpcpcd = &amp;pd; // error, there's no address of a Base\n                                       // to be found in pd\nBase* const* pcpd = &amp;pd; // error: again, there's no address of a Base\n                         // stored in pd\n</code></pre>\n<p>Formally, the Standard describes this in 4.10:</p>\n<blockquote>\n<p id=\"so_18102156_18285077_1\">A prvalue of type \"pointer to cv <code>D</code>\u201d, where <code>D</code> is a class type, can be converted to a prvalue of type \"pointer to cv <code>B</code>\", where <code>B</code> is a base class of <code>D</code>. If <code>B</code> is an inaccessible or ambiguous base class of <code>D</code>, a program that necessitates this conversion is ill-formed. The result of the conversion is a pointer to the base class subobject of the derived class object. The null pointer value is converted to the null pointer value of the destination type.</p>\n</blockquote>\n<p>The result of the conversion is a prvalue, it doesn't have an address, and you can't create a pointer to it.</p>\n", "LastEditorUserId": "509868", "LastActivityDate": "2013-08-19T10:19:46.773", "Score": "6", "CreationDate": "2013-08-17T04:22:58.487", "ParentId": "18102156", "CommentCount": "8", "OwnerUserId": "103167", "LastEditDate": "2013-08-19T10:19:46.773"}});