post_cb({"2386850": {"Id": "2386850", "PostTypeId": "2", "Body": "<p>When using floating point numbers you cannot trust that your local tests will be exactly the same as the tests that are done on the server side. The environment and the compiler are probably different on you local system and where the final tests are run. I have seen this problem many times before in some TopCoder competitions especially if you try to compare two floating point numbers.</p>\n", "LastActivityDate": "2010-03-05T13:00:57.617", "CommentCount": "0", "CreationDate": "2010-03-05T13:00:57.617", "ParentId": "2386772", "Score": "3", "OwnerUserId": "285151"}, "46054661": {"Id": "46054661", "PostTypeId": "2", "Body": "<p>Unlike an <code>int</code> (whole number), a <code>float</code> have a decimal point, and so can a <code>double</code>.\nBut the difference between the two is that a <code>double</code> is twice as detailed as a <code>float</code>, meaning that it can have double the amount of numbers after the decimal point.</p>\n", "LastActivityDate": "2017-09-05T12:10:09.353", "CommentCount": "1", "CreationDate": "2017-09-05T12:10:09.353", "ParentId": "2386772", "Score": "0", "OwnerUserId": "8337783"}, "2388838": {"Id": "2388838", "PostTypeId": "2", "Body": "<p>Given a quadratic equation: <em>x</em><sup>2</sup>\u00a0\u2212\u00a04.0000000\u00a0<em>x</em>\u00a0+\u00a03.9999999\u00a0=\u00a00, the exact roots to 10 significant digits are, <em>r</em><sub>1</sub>\u00a0=\u00a02.000316228 and <em>r</em><sub>2</sub>\u00a0=\u00a01.999683772.</p>\n<p>Using <code>float</code> and <code>double</code>, we can write a test program:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nvoid dbl_solve(double a, double b, double c)\n{\n    double d = b*b - 4.0*a*c;\n    double sd = sqrt(d);\n    double r1 = (-b + sd) / (2.0*a);\n    double r2 = (-b - sd) / (2.0*a);\n    printf(\"%.5f\\t%.5f\\n\", r1, r2);\n}\n\nvoid flt_solve(float a, float b, float c)\n{\n    float d = b*b - 4.0f*a*c;\n    float sd = sqrtf(d);\n    float r1 = (-b + sd) / (2.0f*a);\n    float r2 = (-b - sd) / (2.0f*a);\n    printf(\"%.5f\\t%.5f\\n\", r1, r2);\n}   \n\nint main(void)\n{\n    float fa = 1.0f;\n    float fb = -4.0000000f;\n    float fc = 3.9999999f;\n    double da = 1.0;\n    double db = -4.0000000;\n    double dc = 3.9999999;\n    flt_solve(fa, fb, fc);\n    dbl_solve(da, db, dc);\n    return 0;\n}  \n</code></pre>\n<p>Running the program gives me:</p>\n<pre><code>2.00000 2.00000\n2.00032 1.99968\n</code></pre>\n<p>Note that the numbers aren't large, but still you get cancellation effects using <code>float</code>.</p>\n<p>(In fact, the above is not the best way of solving quadratic equations using either single- or double-precision floating-point numbers, but the answer remains unchanged even if one uses a <a href=\"http://en.wikipedia.org/wiki/Quadratic_equation#Floating_point_implementation\" rel=\"noreferrer\">more stable method</a>.)</p>\n", "LastActivityDate": "2010-03-05T17:57:25.627", "CommentCount": "0", "CreationDate": "2010-03-05T17:57:25.627", "ParentId": "2386772", "Score": "21", "OwnerUserId": "226621"}, "5228616": {"Id": "5228616", "PostTypeId": "2", "Body": "<p>Type float, 32 bits long, has a precision of 7 digits. While it may store values with very large or very small range (+/- 3.4 * 10^38 or * 10^-38), it has only 7 significant digits.</p>\n<p>Type double, 64 bits long, has a bigger range (*10^+/-308) and 15 digits precision.</p>\n<p>Type long double is nominally 80 bits, though a given compiler/OS pairing may store it as 12-16 bytes for alignment purposes. The long double has an exponent that just ridiculously huge and should have 19 digits precision. Microsoft, in their infinite wisdom, limits long double to 8 bytes, the same as plain double.</p>\n<p>Generally speaking, just use type double when you need a floating point value/variable. Literal floating point values used in expressions will be treated as doubles by default, and most of the math functions that return floating point values return doubles. You'll save yourself many headaches and typecastings if you just use double.</p>\n", "LastEditorUserId": "63550", "LastActivityDate": "2017-11-17T23:29:38.873", "Score": "8", "CreationDate": "2011-03-08T05:13:27.817", "ParentId": "2386772", "CommentCount": "1", "OwnerUserId": "538789", "LastEditDate": "2017-11-17T23:29:38.873"}, "2386808": {"Id": "2386808", "PostTypeId": "2", "Body": "<p>Here is what the standard C99 (ISO-IEC 9899 6.2.5 \u00a710) or C++2003 (ISO-IEC 14882-2003 3.1.9 \u00a78) standards say:</p>\n<blockquote>\n<p id=\"so_2386772_2386808_0\">There are three floating point types: <code>float</code>, <code>double</code>, and <code>long double</code>. The type <code>double</code> provides at least as much precision as <code>float</code>, and the type <code>long double</code> provides at least as much precision as <code>double</code>. The set of values of the type <code>float</code> is a subset of the set of values of the type <code>double</code>; the set of values of the type <code>double</code> is a subset of the set of values of the type <code>long double</code>.</p>\n</blockquote>\n<p>The C++ standard adds:</p>\n<blockquote>\n<p id=\"so_2386772_2386808_1\">The value representation of floating-point types is implementation-defined.</p>\n</blockquote>\n<p>I would suggest having a look at the excellent <a href=\"http://docs.sun.com/source/806-3568/ncg_goldberg.html\" rel=\"noreferrer\">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a> that covers the IEEE floating-point standard in depth. You'll learn about the representation details and you'll realize there is a tradeoff between magnitude and precision. The precision of the floating point representation increases as the magnitude decreases, hence floating point numbers between -1 and 1 are those with the most precision.</p>\n", "LastEditorUserId": "216063", "LastActivityDate": "2010-03-06T17:29:32.293", "Score": "44", "CreationDate": "2010-03-05T12:54:51.520", "ParentId": "2386772", "CommentCount": "0", "OwnerUserId": "216063", "LastEditDate": "2010-03-06T17:29:32.293"}, "bq_ids": {"n4140": {"so_2386772_2386808_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 7217}, "so_2386772_2386808_0": {"length": 43, "quality": 0.9555555555555556, "section_id": 7217}}, "n3337": {"so_2386772_2386808_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 6961}, "so_2386772_2386808_0": {"length": 43, "quality": 0.9555555555555556, "section_id": 6961}}, "n4659": {"so_2386772_2386808_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 8726}, "so_2386772_2386808_0": {"length": 41, "quality": 0.9111111111111111, "section_id": 8726}}}, "33229855": {"Id": "33229855", "PostTypeId": "2", "Body": "<p>I just ran into a error that took me forever to figure out and potentially can give you a good example of float precision.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nint main(){\n  for(float t=0;t&lt;1;t+=0.01){\n     std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; t &lt;&lt; std::endl;\n  }\n}\n</code></pre>\n<p>The output is</p>\n<pre><code>0.000000\n0.010000\n0.020000\n0.030000\n0.040000\n0.050000\n0.060000\n0.070000\n0.080000\n0.090000\n0.100000\n0.110000\n0.120000\n0.130000\n0.140000\n0.150000\n0.160000\n0.170000\n0.180000\n0.190000\n0.200000\n0.210000\n0.220000\n0.230000\n0.240000\n0.250000\n0.260000\n0.270000\n0.280000\n0.290000\n0.300000\n0.310000\n0.320000\n0.330000\n0.340000\n0.350000\n0.360000\n0.370000\n0.380000\n0.390000\n0.400000\n0.410000\n0.420000\n0.430000\n0.440000\n0.450000\n0.460000\n0.470000\n0.480000\n0.490000\n0.500000\n0.510000\n0.520000\n0.530000\n0.540000\n0.550000\n0.560000\n0.570000\n0.580000\n0.590000\n0.600000\n0.610000\n0.620000\n0.630000\n0.640000\n0.650000\n0.660000\n0.670000\n0.680000\n0.690000\n0.700000\n0.710000\n0.720000\n0.730000\n0.740000\n0.750000\n0.760000\n0.770000\n0.780000\n0.790000\n0.800000\n0.810000\n0.820000\n0.830000\n0.839999\n0.849999\n0.859999\n0.869999\n0.879999\n0.889999\n0.899999\n0.909999\n0.919999\n0.929999\n0.939999\n0.949999\n0.959999\n0.969999\n0.979999\n0.989999\n0.999999\n</code></pre>\n<p>As you can see after 0.83, the precision runs down significantly.</p>\n<p>However, if I set up t as double, such an issue won't happen.</p>\n<p>It took me five hours to realize this minor error, which ruined my program.</p>\n", "LastEditorUserId": "63550", "LastActivityDate": "2017-11-18T18:41:30.753", "Score": "2", "CreationDate": "2015-10-20T06:51:04.713", "ParentId": "2386772", "CommentCount": "2", "OwnerUserId": "4230724", "LastEditDate": "2017-11-18T18:41:30.753"}, "2386882": {"Id": "2386882", "PostTypeId": "2", "Body": "<p>Huge difference.</p>\n<p>As the name implies, a <a href=\"http://en.wikipedia.org/wiki/Double_precision_floating-point_format\" rel=\"noreferrer\"><code>double</code></a> has 2x the precision of <a href=\"http://en.wikipedia.org/wiki/Single_precision_floating-point_format\" rel=\"noreferrer\"><code>float</code></a><sup>[1]</sup>. In general a <code>double</code> has 15 decimal digits of precision, while <code>float</code> has 7.</p>\n<p>Here's how the number of digits are calculated:</p>\n<blockquote>\n<p id=\"so_2386772_2386882_0\"><code>double</code> has 52 mantissa bits + 1 hidden bit: log(2<sup>53</sup>)\u00f7log(10) = 15.95 digits</p>\n<p id=\"so_2386772_2386882_1\"><code>float</code> has 23 mantissa bits + 1 hidden bit: log(2<sup>24</sup>)\u00f7log(10) = 7.22 digits</p>\n</blockquote>\n<p>This precision loss could lead to truncation errors much easier to float up, e.g.</p>\n<pre><code>    float a = 1.f / 81;\n    float b = 0;\n    for (int i = 0; i &lt; 729; ++ i)\n            b += a;\n    printf(\"%.7g\\n\", b);   // prints 9.000023\n</code></pre>\n<p>while</p>\n<pre><code>    double a = 1.0 / 81;\n    double b = 0;\n    for (int i = 0; i &lt; 729; ++ i)\n            b += a;\n    printf(\"%.15g\\n\", b);   // prints 8.99999999999996\n</code></pre>\n<p>Also, the maximum value of float is about <code>3e38</code>, but double is about <code>1.7e308</code>, so using <code>float</code> can hit Infinity much more easily than double for something simple e.g. computing 60 factorial.</p>\n<p>Maybe their test case contains these huge numbers which causes your program to fail.</p>\n<hr>\n<p>Of course sometimes even <code>double</code> isn't accurate enough, hence we sometimes have <code>long double</code><sup>[1]</sup> (the above example gives 9.000000000000000066 on Mac), but all floating point types suffer from round-off errors, so if precision is very important (e.g. money processing) you should use <code>int</code> or a fraction class.</p>\n<hr>\n<p>BTW, don't use <code>+=</code> to sum lots of floating point numbers as the errors accumulate quickly. If you're using Python, use <code>fsum</code>. Otherwise, try to implement the <a href=\"http://en.wikipedia.org/wiki/Kahan_summation_algorithm\" rel=\"noreferrer\">Kahan summation algorithm</a>.</p>\n<hr>\n<p><sup>[1]: The C and C++ standards do not specify the representation of <code>float</code>, <code>double</code> and <code>long double</code>. It is possible that all three are implemented as IEEE double-precision. Nevertheless, for most architectures (gcc, MSVC; x86, x64, ARM) <code>float</code> <em>is</em> indeed a IEEE single-precision floating point number (binary32), and <code>double</code> <em>is</em> a IEEE double-precision floating point number (binary64).</sup></p>\n</hr></hr></hr>", "LastEditorUserId": "198536", "LastActivityDate": "2016-10-31T20:43:22.007", "Score": "345", "CreationDate": "2010-03-05T13:06:43.593", "ParentId": "2386772", "CommentCount": "11", "OwnerUserId": "224671", "LastEditDate": "2016-10-31T20:43:22.007"}, "2386807": {"Id": "2386807", "PostTypeId": "2", "Body": "<p>Floats have less precision than doubles. Although you already know, read <a href=\"http://docs.sun.com/source/806-3568/ncg_goldberg.html\" rel=\"noreferrer\"> What WE Should Know About Floating-Point Arithmetic</a> for better understanding.</p>\n", "LastEditorUserId": "280730", "LastActivityDate": "2010-03-05T13:09:51.770", "Score": "8", "CreationDate": "2010-03-05T12:54:45.763", "ParentId": "2386772", "CommentCount": "2", "OwnerUserId": "280730", "LastEditDate": "2010-03-05T13:09:51.770"}, "8411893": {"Id": "8411893", "PostTypeId": "2", "Body": "<p>The built-in comparison operations differ as in when you compare 2 numbers with floating point, the difference in data type (i.e. float or double) may result in different outcomes.</p>\n", "LastEditorUserId": "1690429", "LastActivityDate": "2012-11-05T01:35:45.000", "Score": "1", "CreationDate": "2011-12-07T07:40:27.383", "ParentId": "2386772", "CommentCount": "0", "OwnerUserId": "1085090", "LastEditDate": "2012-11-05T01:35:45.000"}, "2386794": {"Id": "2386794", "PostTypeId": "2", "Body": "<ul>\n<li>A double is 64 and single precision\n(float) is 32 bits.</li>\n<li>The double has a bigger mantissa (the integer bits of the real number).</li>\n<li>Any inaccuracies will be smaller in the double.</li>\n</ul>\n", "LastActivityDate": "2010-03-05T12:53:20.800", "CommentCount": "0", "CreationDate": "2010-03-05T12:53:20.800", "ParentId": "2386772", "Score": "17", "OwnerUserId": "342"}, "2386772": {"ViewCount": "663327", "Body": "<p>I know, I've read about the difference between double precision and single precision, etc. But they should give the same results on most cases right?</p>\n<p>I was solving a problem on a programming contest and there were calculations with floating point numbers that were not really big, so I decided to use float instead of double, and I checked it - I was getting the correct results. But when I send the solution, it said only 1 of 10 tests was correct. I checked again and again, until I found that using float is not the same using double. I put double for the calculations and double for the output, and the program gave the SAME results, but this time it passed all the 10 tests correctly.</p>\n<p>I repeat, the output was the SAME, the results were the SAME, but putting float didn't work - only double. The values were not so big too, and the program gave the same results on the same tests both with float and double, but the online judge accepted only the double-provided solution.</p>\n<p>Why? What is the difference?</p>\n", "AcceptedAnswerId": "2386882", "Title": "Difference between float and double", "CreationDate": "2010-03-05T12:48:32.230", "Id": "2386772", "CommentCount": "5", "FavoriteCount": "122", "PostTypeId": "1", "LastEditDate": "2013-04-12T19:42:24.723", "LastEditorUserId": "63550", "LastActivityDate": "2017-11-18T18:41:30.753", "Score": "284", "OwnerUserId": "281619", "Tags": "<c++><c><floating-point><double-precision>", "AnswerCount": "11"}, "2386876": {"Id": "2386876", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_2386772_2386876_0\">\"there were calculations with floating\n  point numbers that were not really\n  big\"</p>\n</blockquote>\n<p>The size of the numbers is irrelevant. It's the calculation that is being performed that is relevant. </p>\n<p>In essence if you're performing a calculation and the result is an irrational number or recurring decimal then there will be rounding errors when that number is squashed into the finite size datastructure you're using. Since double is twice the size of float then the rounding error will be a lot smaller.</p>\n<p>The online test probably specifically used numbers which would cause this kind of error and therefore tested that you'd used the appropriate type in your code.</p>\n", "LastEditorUserId": "63550", "LastActivityDate": "2017-11-18T18:05:18.377", "Score": "9", "CreationDate": "2010-03-05T13:05:56.283", "ParentId": "2386772", "CommentCount": "0", "OwnerUserId": "227865", "LastEditDate": "2017-11-18T18:05:18.377"}});