post_cb({"bq_ids": {"n4140": {"so_43011737_43011792_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 2511}, "so_43011737_43011752_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 4906}, "so_43011737_43011752_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 2572}}, "n3337": {"so_43011737_43011752_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 4701}, "so_43011737_43011752_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 2537}}, "n4659": {"so_43011737_43011792_3": {"length": 14, "quality": 0.8235294117647058, "section_id": 3241}, "so_43011737_43011792_2": {"length": 9, "quality": 1.0, "section_id": 3240}, "so_43011737_43011792_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 3239}, "so_43011737_43011792_9": {"length": 11, "quality": 0.6875, "section_id": 6315}, "so_43011737_43011752_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 3239}, "so_43011737_43011752_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 3308}, "so_43011737_43011752_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 3308}}}, "43011792": {"Id": "43011792", "PostTypeId": "2", "Body": "<p><strong>Looking at code:</strong></p>\n<pre><code>Using assert.h   // Compatible with C language standard\n---------------\n#include &lt;assert.h&gt;\n\nint main() {\n    assert(true == true); // Execution continues\n    assert(true == false); // Execution will abort with false value assert!\n    return 0;\n}\n\nUsing cassert    // Not compatible with C language standard\n--------------\n#include &lt;cassert&gt;\n\nint main() {\n    assert(true == true); // Execution continues\n    assert(true == false); // Execution will abort with false value assert!\n    return 0;\n}\n</code></pre>\n<p><strong>They both work!</strong></p>\n<hr>\n<p><strong>Which one is better in C++11?</strong></p>\n<p><strong>Regarding <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"noreferrer\">C++11</a>'s and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4660.pdf\" rel=\"noreferrer\">C++17</a>'s specification:</strong></p>\n<blockquote>\n<p id=\"so_43011737_43011792_0\"><strong>C.5.1</strong> (section from C++17 document)<br>\n<strong>Modifications to headers [diff.mods.to.headers]</strong></br></p>\n<ol>\n<li><p id=\"so_43011737_43011792_1\">For compatibility with the C standard library, the C++ standard library provides the C headers enumerated in D.5, but their use is\n  deprecated in C++.</p></li>\n<li><p id=\"so_43011737_43011792_2\">There are no C++ headers for the C headers , <code>&lt;stdnoreturn.h&gt;</code>, and <code>&lt;threads.h&gt;</code>, nor are the C headers themselves\n  part of C++.</p></li>\n<li><p id=\"so_43011737_43011792_3\">The C++ headers  (D.4.1) and  (D.4.4), as well as their corresponding C headers  and , do not\n  contain any of the content from the C standard library and instead\n  merely include other headers from the C++ standard library.</p></li>\n</ol>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_43011737_43011792_4\"><strong>D.5</strong>\n<strong>C standard library headers [depr.c.headers]</strong> \n  1. For compatibility with the C standard library, the C++ standard  library provides the C headers shown in Table 141.</p>\n</blockquote>\n<p><a href=\"https://i.stack.imgur.com/WaaPa.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/WaaPa.png\"/></a></p>\n<p>Both <strong>C++11</strong> and <strong>C++17</strong> standard specifications documents state the use of <code>&lt;X.h&gt;</code> remains for compatibility with the C standard, although their use is regarded as <strong>deprecated</strong>.</p>\n<hr>\n<p><strong>Regarding the <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0619r0.html#3.5\" rel=\"noreferrer\">C++ 20 standard proposal</a></strong></p>\n<p>They are reviewing <strong>\"undeprecating\"</strong> the use of the C library headers in C++20. <code>&lt;X.h&gt;</code> appear highlighted in green. C++11 and C++17 deprecation, as of now, is stated as a <strong>\"weak recommendation\"</strong> and a \"tweak\" for keeping the \"<strong>C standard library headers (c.headers)</strong>\" is displayed below:</p>\n<blockquote>\n<p id=\"so_43011737_43011792_5\"><strong>\"The basic C library headers are an essential compatibility feature, and not going anywhere anytime soon.\"</strong> (from <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0619r0.html#3.5\" rel=\"noreferrer\">C++ 20 review document</a>)</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_43011737_43011792_6\"><strong>D.5 C standard</strong><br>\n<strong>library headers [depr.c.headers]</strong></br></p>\n<p id=\"so_43011737_43011792_7\"><strong>Weak recommendation:</strong> In addition to the above, also remove the\n  corresponding C headers from the C++ standard, much as we have no\n  corresponding <code>&lt;stdatomic.h&gt;</code>, <code>&lt;stdnoreturn.h&gt;</code>, or <code>&lt;threads.h&gt;</code>, headers.\n  As above, but with the following tweaks:\n  20.5.5.2.1 C standard library headers [c.headers]</p>\n<p id=\"so_43011737_43011792_8\">For compatibility with the C standard library, the C++ standard\n  library provides the C headers shown in Table 141. Table 141 \u2014 C\n  headers</p>\n</blockquote>\n<pre><code> &lt;assert.h&gt;  &lt;inttypes.h&gt;   &lt;signal.h&gt;      &lt;stdio.h&gt;   &lt;wchar.h&gt;\n &lt;complex.h&gt; &lt;iso646.h&gt;     &lt;stdalign.h&gt;    &lt;stdlib.h&gt;  &lt;wctype.h&gt;\n &lt;ctype.h&gt;   &lt;limits.h&gt;     &lt;stdarg.h&gt;      &lt;string.h&gt;  \n &lt;errno.h&gt;   &lt;locale.h&gt;     &lt;stdbool.h&gt;     &lt;tgmath.h&gt;\n &lt;fenv.h&gt;    &lt;math.h&gt;       &lt;stddef.h&gt;      &lt;time.h&gt;\n &lt;float.h&gt;   &lt;setjmp.h&gt;     &lt;stdint.h&gt;      &lt;uchar.h&gt;\n</code></pre>\n<blockquote>\n<p id=\"so_43011737_43011792_9\">The header <code>&lt;complex.h&gt;</code>\n  behaves as if it simply includes the header . \n  The header <code>&lt;tgmath.h&gt;</code> behaves as if it simply includes the headers <code>&lt;complex&gt;</code> and <code>&lt;cmath&gt;</code>.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_43011737_43011792_10\"><strong><a href=\"http://www.stroustrup.com/compat_short.pdf\" rel=\"noreferrer\">Bjarne Stroustrup</a></strong> recommends <strong>maximising inter-operability</strong> between\n  the <strong>C and C++ languages</strong>, by <strong>reducing imcompatibilities</strong> as much as\n  possible. Others argue otherwise, as it complicates things.</p>\n</blockquote>\n<p>So, it seems <code>&lt;X.h&gt;</code> aren't <strong>going anywhere</strong>. Ultimately, you can use both.  Personally, I would make the decision of which one I would use boil  down to having your code <strong>backwards compatible with C code</strong> or not.</p>\n</hr></hr></hr></hr></hr>", "LastEditorUserId": "3022583", "LastActivityDate": "2017-03-27T20:18:36.877", "Score": "6", "CreationDate": "2017-03-25T02:18:59.380", "ParentId": "43011737", "CommentCount": "6", "OwnerUserId": "3022583", "LastEditDate": "2017-03-27T20:18:36.877"}, "43011752": {"Id": "43011752", "PostTypeId": "2", "Body": "<p>The contents of <code>&lt;cassert&gt;</code> are the same as the C standard library header <code>&lt;assert.h&gt;</code>, except that a macro named <code>static_assert</code> is not defined.<sup>1</sup></p>\n<p>Prefer <code>&lt;cassert&gt;</code>.</p>\n<p>All of the <code>&lt;xxx.h&gt;</code> C headers (including <code>&lt;assert.h&gt;</code>) are deprecated:</p>\n<p><strong>D.5 C standard library headers [depr.c.headers]</strong></p>\n<p><strong>Update regarding the <code>static_assert</code> macro from C</strong></p>\n<p>In D.5 [depr.c.headers], the C++ standard refers to the <code>&lt;xxx.h&gt;</code> headers as \"the <em>C headers</em>:</p>\n<blockquote>\n<p id=\"so_43011737_43011752_0\">1 For compatibility with the C standard library, the C++ standard library provides the <em>C headers</em> shown in Table 141.</p>\n</blockquote>\n<p>In C++14, the specification referenced C99 (ISO/IEC 9899:1999).  C99 did not define the macro <code>static_assert</code> (in any header).  C++14 had this to say about <code>&lt;cassert&gt;</code> in 19.3 [assertions]:</p>\n<blockquote>\n<p id=\"so_43011737_43011752_1\">2 The contents are the same as the Standard C library header <code>&lt;assert.h&gt;</code>.</p>\n</blockquote>\n<p>C++17 references C11 (SO/IEC 9899:2011) which <em>does</em> define <code>static_assert</code> in <code>&lt;assert.h&gt;</code>, and has this to say about <code>&lt;cassert&gt;</code> in 22.3.1 [cassert.syn]:</p>\n<blockquote>\n<p id=\"so_43011737_43011752_2\">1 The contents are the same as the C standard library header <code>&lt;assert.h&gt;</code>, except that a macro named <code>static_assert</code> is not defined.</p>\n</blockquote>\n<p>Both C++14 and C++17 define <code>&lt;assert.h&gt;</code> only by reference to their respective C specifications, and also by this:</p>\n<blockquote>\n<p id=\"so_43011737_43011752_3\">See also: ISO C 7.2.</p>\n</blockquote>\n<p>(which is the C section that specifies <code>&lt;assert.h&gt;</code>)</p>\n<p>The way I read this, <em>techincally</em> <code>&lt;assert.h&gt;</code>, when compiled with a C++17 compiler, actually <em>does</em> define a macro named <code>static_assert</code>.  However doing so would be pointless, and I can't imagine that any implementation actually bothers to do so.</p>\n<p>In any event, I stand by my recommendation above:</p>\n<blockquote>\n<p id=\"so_43011737_43011752_4\">Prefer <code>&lt;cassert&gt;</code>.</p>\n</blockquote>\n<p>It's just the C++ way to do things.  And at least in C++98/03/11/14/17, it avoids depending on deprecated functionality.  Who knows what C++20 will bring.  But C++20 definitely will not deprecate <code>&lt;cassert&gt;</code>.</p>\n<hr>\n<p><sup>1</sup> <strong>22.3.1 Header  synopsis [cassert.syn]</strong></p>\n<p><sup>2</sup> <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"noreferrer\">Link to the C++11 specification.</a></p>\n<p><sup>3</sup> <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4660.pdf\" rel=\"noreferrer\">Link to the C++17 specification.</a></p>\n</hr>", "LastEditorUserId": "576911", "LastActivityDate": "2017-03-26T03:07:51.180", "Score": "27", "CreationDate": "2017-03-25T02:12:09.127", "ParentId": "43011737", "CommentCount": "9", "OwnerUserId": "576911", "LastEditDate": "2017-03-26T03:07:51.180"}, "43011737": {"ViewCount": "2417", "Body": "<p>Using C++11, is it better to <code>#include</code> <code>&lt;cassert&gt;</code> or <code>&lt;assert.h&gt;</code>?  Or is there no difference?</p>\n<p>Edit:</p>\n<p>It seems <a href=\"https://stackoverflow.com/questions/13889467/should-i-include-xxxx-h-or-cxxxx-in-c-programs\">Should I include &lt;xxxx.h&gt; or &lt;cxxxx&gt; in C++ programs?</a> argues that it comes down to polluting the global namespace.  Is this a special case because <code>assert</code> is a macro and there is no <code>std::assert</code>?</p>\n", "AcceptedAnswerId": "43011752", "Title": "Is it better to include <cassert> or <assert.h>?", "CreationDate": "2017-03-25T02:07:32.663", "Id": "43011737", "CommentCount": "8", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:32:24.550", "LastEditorUserId": "-1", "LastActivityDate": "2017-03-27T20:18:36.877", "ClosedDate": "2017-03-25T14:53:23.337", "Score": "25", "OwnerUserId": "2383730", "Tags": "<c++><c++11>", "AnswerCount": "2"}});