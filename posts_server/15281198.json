post_cb({"15281198": {"CommentCount": "0", "ViewCount": "146", "CreationDate": "2013-03-07T20:34:20.993", "LastActivityDate": "2013-03-07T21:01:23.800", "Title": "What's it called when I define a subclass just to abstract away the details of the base class's constructor?", "PostTypeId": "1", "Id": "15281198", "Score": "0", "Body": "<p>I'm writing a library that provides the ability for two clients to communicate using  ZeroMQ PUB/SUB sockets. Each client application instantiates either a broadcaster endpoint or a receiver endpoint, and those endpoint classes have a Connection member:</p>\n<pre><code>class Connection {\n    Connection(const char* address, int outgoingPort, int incomingPort);\n};\n</code></pre>\n<p>A Connection has a couple of sockets and is configured to connect to the given address over the respective ports. However, I don't care to expose these details in the classes where the Connection is actually instantiated. The base connection object has a incoming port and an outgoing port, but this detail doesn't need to seep through the rest of the program. In those higher-level layers, it'd be more sensible to think in terms of two designated ports, the data port and the control port. So I have two subclasses which implement constructors to define which port is the incoming port, and which is the outgoing port for that particular type of connection.</p>\n<pre><code>class BroadcasterConnection : public Connection {\n    BroadcasterConnection(int dataPort, int controlPort)\n    :Connection(\"*\", dataPort, controlPort) {}\n};\nclass ReceiverConnection : public Connection {\n    ReceiverConnection(const char* hostAddress, int dataPort, int controlPort)\n    :Connection(hostAddress, controlPort, dataPort) {}\n};\n</code></pre>\n<p>Additionally, the broadcaster binds to its ports as a stable endpoint, so it needs to use <code>\"*\"</code> in lieu of an actual remote address. Again, classes that instantiate and use a broadcaster connection should not need to concern themselves with this detail, so the BroadcasterConnection constructor takes care of it.</p>\n<p>As another example, I do the same thing with the classes that wrap ZeroMQ sockets. I have a base Socket class, and the subclass constructors simply pass the appropriate value (ZMQ_PUB or ZMQ_SUB) from the ZeroMQ headers to the underlying socket. Since we can't have clients using values from ZeroMQ directly, we need to codify the distinction between a PUB socket and a SUB socket in some formal way, and providing a single subclass constructor seemed like a transparent and sensible way of doing that.</p>\n<pre><code>class Socket:\n    Socket(void* context, const char* address, int port, int socketType);\n\nclass PublishSocket : public Socket:\n    PublishSocket(void* context, const char* address, int port)\n    :Socket(context, address, port, ZMQ_PUB) {}\n\nclass SubscribeSocket : public Socket:\n    SubscribeSocket(void* context, const char* address, int port)\n    :Socket(context, address, port, ZMQ_SUB) {}\n</code></pre>\n<p>These subclasses don't do anything fancy at all, but I hope you'll agree that they're a useful and healthy addition in the service of abstraction. But I'm not aware of a common name for this simple idiom. When I define a subclass that <em>only</em> implements a constructor, solely for the purpose of constructing an object with a more specialized set of parameters, what am I doing?</p>\n<p>The key point here is that these subclasses <em>do not define any additional methods or data</em>. Here's another example, where there's a base Tag class that identifies any entity of any type. The subclasses are used to create tags for individual types of entities based on some domain-specific parameters, but they all boil down to Tag objects in the end.</p>\n<pre><code>Tag(char typeIdentifier, int entityIdentifier);\n\nLightTag(int lightIndex):Tag('L', lightIndex) {}\nSkeletonTag(const char* skeletonName):Tag('S', hash(skeletonName)) {}\nCameraTag():Tag('C', 0) {}\n</code></pre>\n<p>So, a few questions:</p>\n<ol>\n<li><p>Is there a commonly-used, Googleable name for this idiom?</p></li>\n<li><p>If I write <code>Connection c = BroadcasterConnection(40001, 40002);</code>, the copy constructor is invoked. Since <code>BroadcasterConnection</code> doesn't define any additional data, the two classes should be interchangeable (RTTI notwithstanding), and we should be able to downcast without any worries of object slicing, right? Is there a similarly convenient syntax for constructing objects in this way that avoids the copy? This seems to happen even in constructor initializer lists.</p></li>\n<li><p>This is a less practical example, but suppose I write <code>Connection* c = new BroadcasterConnection(40001, 40002);</code> and then <code>delete c;</code>. Connection doesn't have a virtual destructor, but it doesn't have any virtual functions to begin with (so no vtable). Since BroadcasterConnection is a direct subclass of Connection that defines no additional data, would this operation be safe? What if BroadcasterConnection added some member data? Would it then cause memory leaks?</p></li>\n<li><p>Is there any way to explicitly codify the fact that a particular subclass is constructor-only in the way described above, so that the compiler won't allow it to contain any additional data?</p></li>\n</ol>\n<p>And, of course, if there's a fundamentally better way of solving the same problem, I'd love to hear it.</p>\n", "Tags": "<c++><constructor><subclass><copy-constructor>", "OwnerUserId": "1072221", "AnswerCount": "1"}, "15281308": {"ParentId": "15281198", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-03-07T20:42:36.937", "Score": "3", "LastEditorUserId": "1774667", "LastEditDate": "2013-03-07T21:01:23.800", "Id": "15281308", "OwnerUserId": "1774667", "Body": "<p>Be careful.  You invoked undefined behavior.</p>\n<p><strong>5.3.5</strong></p>\n<blockquote>\n<p id=\"so_15281198_15281308_0\">3) In the first alternative (delete object ), if the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand\u2019s dynamic type and the static type shall have a virtual destructor or the behavior is undefined. [...]</p>\n</blockquote>\n<p>I suspect that it will almost always work, but you are invoking undefined behavior, and as such asked the compiler to email the contents of your hard drive to a photo printer, and use your credit card to pay for it.  Or whatever else it feels like.</p>\n<p>In practice, it will probably just call the base class destructor.</p>\n<p>Note that most of the above utility can be handled via functions that return copies of base class objects with the names of the derived classes.  Ie, instead of a class called SubscribeSocket, you have a function called <code>SubscribeSocket</code> that returns a <code>Socket</code>.  Between move semantics (you do have a fast move on <code>Socket</code>, right?) and RVO (assuming you are willing to expose the implementation of <code>SubscribeSocket</code>), this will be efficient.</p>\n<p>One advantage your scheme has is that you can type your <code>Socket</code>s if required.  An approach that works which doesn't invoke undefined behavior (but does have a few quirks) is to define a <code>SubscribeSocket</code> class that is unrelated to <code>Socket</code>, which owns a <code>Socket</code>, forwards its constructor to it, and has <code>operator Socket&amp;()</code> and <code>operator Socket const&amp;() const</code>, allowing it to be passed to an API that requires <code>Sockets</code>.  Throw in a <code>.GetSocket()</code> method for when you need it explicitly.  Avoid <code>operator=(Socket const&amp;)</code> and you now block slicing.  Maybe have an explicit \"create-from-socket\" type function that does checks in debug...</p>\n", "LastActivityDate": "2013-03-07T21:01:23.800"}, "bq_ids": {"n4140": {"so_15281198_15281308_0": {"section_id": 6107, "quality": 0.88, "length": 22}}, "n3337": {"so_15281198_15281308_0": {"section_id": 5873, "quality": 0.88, "length": 22}}, "n4659": {"so_15281198_15281308_0": {"section_id": 7604, "quality": 0.88, "length": 22}}}});