post_cb({"35148992": {"ParentId": "24816557", "LastEditDate": "2016-02-02T09:10:34.267", "CommentCount": "0", "CreationDate": "2016-02-02T09:05:01.397", "Score": "3", "LastEditorUserId": "1422197", "PostTypeId": "2", "Id": "35148992", "OwnerUserId": "1422197", "Body": "<p>This expands on my comment to Brian answer above. In C++14 with the library fundamentals TS you can:</p>\n<pre><code>template&lt;class... T&gt;\nauto pack(T... t)\n{\n    return [ts = std::make_tuple(std::move(t)...)](auto&amp;&amp; f){\n        std::experimental::apply(f, ts);\n    };\n};\n</code></pre>\n<p>Supposing you want to generically capture a parameter pack by move and use it within a lambda you can write the code in a lambda within a lambda, and then apply the arguments on it:</p>\n<pre><code>[ts = std::make_tuple(std::move(t)...)](/* args */){\n    auto lambda = [&amp;](auto&amp;&amp;... args) {\n      // - args is the original parameter pack that one wanted to \n      //   capture by move\n      // - the other arguments can be used by reference\n    };\n    return std::experimental::apply(lambda, ts);\n};\n</code></pre>\n", "LastActivityDate": "2016-02-02T09:10:34.267"}, "24816772": {"ParentId": "24816557", "LastEditDate": "2017-05-23T12:25:01.363", "CommentCount": "4", "CreationDate": "2014-07-18T03:27:50.183", "Score": "15", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "24816772", "OwnerUserId": "481267", "Body": "<p>My draft of C++14 says ([expr.prim.lambda]/24):</p>\n<blockquote>\n<p id=\"so_24816557_24816772_0\">A <em>simple-capture</em> followed by an ellipsis is a pack expansion (14.5.3). An <em>init-capture</em> followed by an ellipsis is ill-formed.</p>\n</blockquote>\n<p>So it looks like there is no way to do a variadic generalized capture. A possible workaround is to just capture the arguments in a tuple and then use one of the solutions suggested here: <a href=\"https://stackoverflow.com/questions/7858817/unpacking-a-tuple-to-call-a-matching-function-pointer\">\"unpacking\" a tuple to call a matching function pointer</a></p>\n<pre><code>auto pack(T... t)\n{\n    return [args=make_tuple(std::move(t)...)](auto&amp;&amp; f){\n               // find a way to call f with args\n           };\n};\n</code></pre>\n", "LastActivityDate": "2014-07-18T03:27:50.183"}, "bq_ids": {"n4140": {"so_24816557_24816772_0": {"section_id": 5983, "quality": 0.9, "length": 9}}, "n4659": {"so_24816557_24816772_0": {"section_id": 7480, "quality": 0.9, "length": 9}}}, "24816557": {"CommentCount": "4", "ViewCount": "1517", "CreationDate": "2014-07-18T02:53:16.647", "LastActivityDate": "2016-02-02T09:10:34.267", "PostTypeId": "1", "AcceptedAnswerId": "24816772", "FavoriteCount": "4", "Title": "Generalized lambda capture on param-pack?", "Id": "24816557", "Score": "12", "Body": "<p>In C++14, generalized lambda capture let us do:</p>\n<pre><code>template&lt;class T&gt;\nauto pack(T t)\n{\n    return [t=std::move(t)](auto&amp;&amp; f){f(t);};\n};\n</code></pre>\n<p>But it doesn't play with param-pack:</p>\n<pre><code>template&lt;class... T&gt;\nauto pack(T... t)\n{\n    return [t=std::move(t)...](auto&amp;&amp; f){f(t...);};\n};\n</code></pre>\n<p>Is there any special syntax or further standard proposal to address this?</p>\n", "Tags": "<c++><lambda><c++14><variadic-functions>", "OwnerUserId": "2969631", "AnswerCount": "3"}, "24837449": {"ParentId": "24816557", "CommentCount": "0", "CreationDate": "2014-07-19T06:29:30.640", "OwnerUserId": "2969631", "PostTypeId": "2", "Id": "24837449", "Score": "3", "Body": "<p>As a follow-up, I came to this workaround:</p>\n<pre><code>template&lt;class T&gt;\nstruct mover\n{\n    mover(T const&amp; val) : val(val) {}\n\n    mover(T&amp;&amp; val) : val(std::move(val)) {}\n\n    mover(mover const&amp; other) = default;\n\n    mover(mover&amp;&amp; other) = default; \n\n    mover(mover&amp; other) : val(std::move(other.val)) {}\n\n    operator T const&amp;() const\n    {\n        return val; \n    }\n\n    T val;\n};\n\ntemplate&lt;class T&gt;\nusing wrap_t = typename std::conditional\n    &lt;\n        std::is_move_constructible&lt;T&gt;::value\n    &amp;&amp; !std::is_trivially_copy_constructible&lt;T&gt;::value\n      , mover&lt;T&gt;\n      , T\n    &gt;::type;\n\ntemplate&lt;class... Ts&gt;\nauto pack_impl(wrap_t&lt;Ts&gt;... ts)\n{\n    return [=](auto&amp;&amp; f)-&gt;decltype(auto)\n    {\n        return f(static_cast&lt;Ts const&amp;&gt;(ts)...);\n    };\n}\n\nauto pack = [](auto&amp;&amp;... ts)\n{\n    return pack_impl&lt;std::decay_t&lt;decltype(ts)&gt;...&gt;(static_cast&lt;decltype(ts)&gt;(ts)...);\n};\n</code></pre>\n<p>It utilizes <code>mover</code> as a proxy, which allows lambda to capture it by move (it's a bit hacky). And <code>wrap_t</code> decides when is needed or beneficial to apply <code>mover</code>.</p>\n<p>Now we can test it:</p>\n<pre><code>struct A\n{\n    A() = default;\n\n    A(A&amp;&amp;)\n    {\n        std::cout &lt;&lt; \"move\\n\";\n    }\n\n    A(A const&amp;)\n    {\n        std::cout &lt;&lt; \"copy\\n\";\n    }\n};\n\nA a;\nstd::cout &lt;&lt;\"p1------------\\n\";\nauto p1 = pack(std::move(a));\nstd::cout &lt;&lt;\"p2------------\\n\";\nauto p2 = std::move(p1);\nstd::cout &lt;&lt;\"p3------------\\n\";\nauto p3 = p2;\n</code></pre>\n<p>Will print:</p>\n<pre><code>p1------------\nmove\nmove\np2------------\nmove\np3------------\ncopy\n</code></pre>\n", "LastActivityDate": "2014-07-19T06:29:30.640"}});