post_cb({"bq_ids": {"n4140": {"so_27671276_27671997_0": {"section_id": 434, "quality": 1.0, "length": 15}}, "n3337": {"so_27671276_27671997_0": {"section_id": 426, "quality": 1.0, "length": 15}}, "n4659": {"so_27671276_27671997_0": {"section_id": 452, "quality": 1.0, "length": 15}}}, "27771709": {"ParentId": "27671276", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2015-01-04T23:57:58.687", "Score": "3", "LastEditorUserId": "420683", "LastEditDate": "2017-01-03T13:44:15.653", "Id": "27771709", "OwnerUserId": "420683", "Body": "<p>I have recently found a workaround that does not need virtual inheritance (see below).</p>\n<p>Basically, the language requires the use of <em>virtual</em> inheritance in this case to solve the problem directly since you inherit multiple times from the same class. Without virtual inheritance, you'll end up with this:</p>\n<pre>\nInterface0  Interface0  Interface0\n    ^           ^           ^______\n    |           |                  \\\nInterface1  Interface1              Impl0\n    ^           ^__________________   ^\n    |                              \\  |\nInterface2                          Impl1\n    ^______________________________   ^\n                                   \\  |\n                                    Impl2\n</pre>\n<p>There are multiple \"instances\" of the <code>InterfaceX</code> base class, which are independent. Consider the <code>Interface0</code> instance from the path <code>Impl1 -&gt; Interface1 -&gt; Interface0</code>. The <code>Impl0</code> class does not inherit from <em>that</em> instance of <code>Interface0</code>, hence it does not implement its virtual functions. Note that this is useful if all these interface classes were stateful classes (with data members) instead of pure interfaces.</p>\n<p>But in this particular situation, where you only inherit from an <em>interface</em>, virtual inheritance isn't required <em>in theory</em>. We want to get to the following picture:</p>\n<pre>\nInterface0 _\n    ^     |\\\n    |       \\\nInterface1 _ Impl0\n    ^     |\\   ^\n    |       \\  |\nInterface2 _ Impl1\n          |\\   ^\n            \\  |\n             Impl2\n</pre>\n<p>Theoretically, <code>Impl1</code> could define one single vtable with the entries from <code>Impl0</code> implementing the virtual functions from <code>Interface0</code>, and the functions from <code>Impl1</code> implementing the virtual functions from <code>Interface1</code>. The result would be a single vtable with no offset computations required (hence no need for virtual inheritance).</p>\n<p>But, alas, the language doesn't define inheritance this way -- it doesn't make a difference between abstract classes and pure interfaces. It lets you only override virtual functions through sideway-inheritance (<code>Impl0</code> overriding virtual functions of <code>Impl1 -&gt; Interface1 -&gt; Interface0</code>) if you inherit them via virtual inheritance. By inheriting virtually, you specify that you indeed inherit only <em>once</em> from <code>Interface0</code>, so both paths from <code>Impl1</code> to <code>Interface0</code> (direct inheritance and via <code>Impl0</code>) yield <em>the same</em> class.</p>\n<p>Virtual inheritance has several drawbacks, since it must allow cases where the location of the base class (relative to a subobject) can only be determined at run-time. <strong>However</strong>, there's a workaround that doesn't need virtual inheritance.</p>\n<p>It is often more useful to write a class first self-contained, and then adapt it to an interface. The interface is typically defined by the surrounding architecture, and hence not necessarily general for that class. By separating the interface from the implementation, you allow reuse of the implementation with a different interface.</p>\n<p>If we put this together: We cannot use multiple inheritance to implement virtual functions side-ways, and we want to separate interface from implementation. We end up with: Either, we don't let our implementation derive from anything (this leads to boilerplate code) or we derive linearly, the only inheritance from an interface at the top.</p>\n<p>By writing our implementation classes as class templates, we can derive linearly and pass the top interface to be derived from up to the base implementation class:</p>\n<pre><code>struct Interface0 {\n    virtual void fun0() = 0;\n};\n\nstruct Interface1 : Interface1 {\n    virtual void fun1() = 0;\n};\n\nstruct Interface2 : Interface0 {\n    virtual void fun2() = 0;\n};\n\n\ntemplate&lt;typename Interface = Interface0&gt;\nstruct Impl0 : Interface {\n    void fun0() {}\n};\n\ntemplate&lt;typename Interface = Interface1&gt;\nstruct Impl1 : Impl0&lt;Interface&gt; {\n    void fun1() {}\n};\n\ntemplate&lt;typename Interface = Interface2&gt;\nstruct Impl2 : Impl1&lt;Interface&gt; {\n    void fun2() {}\n};\n\n\nint main()\n{\n    auto x = Impl2&lt;Interface2&gt;(); // or simply: Impl2&lt;&gt;()\n    Interface2* p = &amp;x;\n}\n</code></pre>\n<p>Note that we use inheritance for both: implementing <code>Impl1</code> in terms of <code>Impl0</code>, and passing the extended interface to our base class.</p>\n<p>The case in <code>main</code>, <code>Impl2&lt;&gt;</code>:</p>\n<pre>\nInterface0\n    ^\n    |\nInterface1\n    ^\n    |\nInterface2 _\n          |\\\n            \\\n             Impl0&lt;Interface2&gt;\n               ^\n               |\n             Impl1&lt;Interface2&gt;\n               ^\n               |\n             Impl2&lt;Interface2&gt;\n</pre>\n<p>Another case, <code>Impl1&lt;&gt;</code>:</p>\n<pre>\nInterface0\n    ^\n    |\nInterface1 _\n          |\\\n            \\\n             Impl0&lt;Interface1&gt;\n               ^\n               |\n             Impl1&lt;Interface1&gt;\n</pre>\n", "LastActivityDate": "2017-01-03T13:44:15.653"}, "27671997": {"ParentId": "27671276", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-12-27T22:25:11.890", "Score": "2", "LastEditorUserId": "3959454", "LastEditDate": "2014-12-27T22:40:28.260", "Id": "27671997", "OwnerUserId": "3959454", "Body": "<p>You have to initialize virtual base classes in all derived class constructors. Thus, if you had</p>\n<pre><code>class ClassDerived : public virtual Class, public virtual IClassDerived {\n//                          ^^^^^^^\n</code></pre>\n<p>Then in the constructors of <code>ClassDerived2</code> and <code>ClassDerived3</code> you would have to initialize <code>Class</code> despite that it seems to be initialized in the constructor of <code>ClassDerived</code>:</p>\n<pre><code>ClassDerived2(int commonValue) : Class(commonValue), ClassDerived(commonValue)  {}\nClassDerived3(int commonValue) : Class(commonValue), ClassDerived2(commonValue) {}\n</code></pre>\n<p>The reason for this is <code>[class.base.init]/7</code>:</p>\n<blockquote>\n<p id=\"so_27671276_27671997_0\">A <em>mem-initializer</em> where the <em>mem-initializer-id</em> denotes a virtual base class is ignored during execution of a constructor of any class that is not the most derived class.</p>\n</blockquote>\n<hr>\n<p>Regarding whether there is a better way, personally I'd rather use aggregation and no virtual inheritance, though it requires writing some boilerplate forwarding code:</p>\n<pre><code>class IClass {\npublic:\n    virtual int commonMethod() const = 0;\n};\n\nclass Class : public IClass {\nprotected:\n    int commonValue;\n\npublic:\n    Class(int commonValue) : commonValue(commonValue) {}\n\n    virtual int commonMethod() const {\n        return commonValue;\n    }\n};\n\n\nclass IClassDerived : public IClass {\npublic:\n    virtual void specialMethod() = 0;\n};\n\nclass ClassDerived : public IClassDerived { // no inheritance from Class\npublic:\n    ClassDerived(int commonValue) : m_class(commonValue) {}\n\n    virtual int commonMethod() const {\n        return m_class.commonMethod();\n    }\n\n    virtual void specialMethod() {\n        // do something\n    }\n\nprivate:\n    Class m_class;\n};\n\n// and so on\n</code></pre>\n</hr>", "LastActivityDate": "2014-12-27T22:40:28.260"}, "27671276": {"CommentCount": "3", "ViewCount": "1386", "CreationDate": "2014-12-27T20:40:40.577", "LastActivityDate": "2017-01-03T13:44:15.653", "Title": "Virtual inheritance: Why does it work when only one base class has \"virtual\" keyword? Is there a better way?", "PostTypeId": "1", "Id": "27671276", "Score": "1", "Body": "<p>I want to implement a class hierarchy in C++:</p>\n<ul>\n<li>I need interfaces so I can provide multiple implementations.</li>\n<li>I need common methods in all the classes. But I need to be able to override specific methods.</li>\n<li>Constructors all take at least one parameter.</li>\n</ul>\n<p>Simplified I have this code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass IClass {\npublic:\n    virtual int commonMethod() const = 0;\n};\n\nclass Class : public virtual IClass {\nprotected:\n    int commonValue;\n\npublic:\n    Class(int commonValue) : commonValue(commonValue) {}\n\n    virtual int commonMethod() const {\n        return commonValue;\n    }\n};\n\n\nclass IClassDerived : public virtual IClass {\npublic:\n    virtual void specialMethod() = 0;\n};\n\nclass ClassDerived : public Class, public virtual IClassDerived {\npublic:\n    ClassDerived(int commonValue) : Class(commonValue) {}\n\n    virtual void specialMethod() {\n        // do something\n    }\n};\n\n\nclass IClassDerived2 : public virtual IClassDerived {\npublic:\n    virtual void specialMethod2() = 0;\n};\n\nclass ClassDerived2 : public ClassDerived, public virtual IClassDerived2 {\npublic:\n    ClassDerived2(int commonValue) : ClassDerived(commonValue) {}\n\n    virtual void specialMethod2() {\n        specialMethod();\n    }\n};\n\n\nclass IClassDerived3 : public virtual IClassDerived2 {\npublic:\n    virtual int commonMethod() const override = 0;\n};\n\nclass ClassDerived3 : public ClassDerived2, public virtual IClassDerived3 {\npublic:\n    ClassDerived3(int commonValue) : ClassDerived2(commonValue) {}\n\n    virtual int commonMethod() const override {\n        return 4711;\n    }\n};\n\n\nint main() {\n    ClassDerived foo(1);\n    ClassDerived2 foo2(2);\n    ClassDerived3 foo3(3);\n\n    std::cout &lt;&lt; foo.commonMethod() &lt;&lt; \" \" &lt;&lt; foo2.commonMethod() &lt;&lt; \" \" &lt;&lt; foo3.commonMethod() &lt;&lt; \" \" &lt;&lt; std::endl;\n    // 1 2 4711\n\n    return 0;\n}\n</code></pre>\n<p>I now have two questions:</p>\n<ul>\n<li>Why does this work at all? \n<ul>\n<li>If I try without virtual inheritance I get errors \"\u2018specialMethod\u2019 is ambiguous\" and \"...  because the following virtual functions are pure within \u2018ClassDerived\u2019: virtual int IClass::commonMethod() const\". Because of the two base classes every member is there two times which results in these errors. Ok.</li>\n<li>If I do virtual inheritance and specify both base classes with \"public virtual\" I get \"no matching function for call to \u2018Class::Class()\u2019\". Researching showed me that in case of virtual inheritance I need a default constructor for the base classes.</li>\n<li>By trial-and-error I found the solution above. But I don't understand why it works so far. What happens when only one base class is \"virtual\" but not the other one?</li>\n</ul></li>\n<li>Is there a better way? I managed to get this little example to compile but in reality my classes are complexer and I am afraid this only works in this little snippet and I am not seeing future problems this could bring up...</li>\n</ul>\n", "Tags": "<c++><inheritance>", "OwnerUserId": "2992323", "AnswerCount": "2"}});