post_cb({"35352257": {"ParentId": "35352168", "CommentCount": "0", "Body": "<p>You cannot apply const to a reference, like const(ref(type)).</p>\n<p>But you can have a reference to a const type, like ref(const(type)).</p>\n", "OwnerUserId": "5128211", "PostTypeId": "2", "Id": "35352257", "Score": "1", "CreationDate": "2016-02-11T23:40:23.130", "LastActivityDate": "2016-02-11T23:40:23.130"}, "35352168": {"CommentCount": "2", "AcceptedAnswerId": "35352325", "CreationDate": "2016-02-11T23:32:33.807", "LastActivityDate": "2016-02-11T23:46:23.273", "PostTypeId": "1", "ViewCount": "479", "FavoriteCount": "1", "Title": "Cannot apply const to typedef reference", "Id": "35352168", "Score": "2", "Body": "<p>The following code works when applying <code>const</code> to a return value reference of <code>value_type&amp;</code> but errors if I use a typedef of the same type.</p>\n<p>As an example:</p>\n<pre><code>class T {\n};\n\nclass A {\npublic:\n    typedef T value_type;\n    typedef value_type&amp; reference;\n\n    // Not working\n    const reference operator*() const;\n\n    // But this works?\n    //const value_type&amp; operator*() const;\n};\n\n// Error!\nconst typename A::reference A::operator*() const {\n}\n\nint main() {\n    return 0;\n}\n</code></pre>\n<p>g++ will error with:</p>\n<pre><code>'const' qualifiers cannot be applied\n</code></pre>\n<p>My actual code uses templates but I've removed for the example and substituted class <code>T</code> instead. This has no bearing on the error.</p>\n<p>I don't see why this won't work if specifying <code>value_type&amp;</code> instead compiles fine.</p>\n", "Tags": "<c++><const><const-correctness>", "OwnerUserId": "1762276", "AnswerCount": "2"}, "35352325": {"ParentId": "35352168", "CommentCount": "4", "Body": "<p>There are two different issues here.</p>\n<p>First, in:</p>\n<pre><code>typedef T* pointer;\ntypedef const pointer const_pointer;\n</code></pre>\n<p>the type of <code>const_pointer</code> is actually <code>T* const</code>, not <code>const T*</code>. The constness attaches to the pointer, not to the type pointed to.</p>\n<p>Now references obey the same logic: if you make a typedef for the reference type, and try to attach <code>const</code> to it, it will try to apply the <code>const</code> to the reference type, not the referenced type. But references, unlike pointers, are not allowed to have top-level cv-qualification. If you try to mention <code>T&amp; const</code>, it's a compilation error. But if you try to attach the cv-qualification through a typedef, it's just ignored.</p>\n<blockquote>\n<p id=\"so_35352168_35352325_0\">Cv-qualified references are ill-formed except when the cv-qualifiers are introduced\n  through the use of a <em>typedef-name</em> (7.1.3, 14.1) or *decltype-specifier *(7.1.6.2), in which case the cv-qualifiers\n  are ignored.</p>\n</blockquote>\n<p>([dcl.ref]/1)</p>\n<p>So the second issue is that GCC thinks this is an error, whereas the standard clearly states that it should not be an error, it should just ignore the <code>const</code>. I think this is a bug in GCC. Clang does not produce an error: <a href=\"http://coliru.stacked-crooked.com/a/5b5c105941066708\">http://coliru.stacked-crooked.com/a/5b5c105941066708</a></p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "35352325", "Score": "6", "CreationDate": "2016-02-11T23:46:23.273", "LastActivityDate": "2016-02-11T23:46:23.273"}, "bq_ids": {"n4140": {"so_35352168_35352325_0": {"section_id": 3218, "quality": 0.8235294117647058, "length": 14}}, "n3337": {"so_35352168_35352325_0": {"section_id": 3092, "quality": 0.7058823529411765, "length": 12}}, "n4659": {"so_35352168_35352325_0": {"section_id": 3975, "quality": 0.8235294117647058, "length": 14}}}});