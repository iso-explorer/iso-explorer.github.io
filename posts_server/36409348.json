post_cb({"36409348": {"CommentCount": "9", "AcceptedAnswerId": "36411098", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2016-04-04T17:42:17.637", "LastActivityDate": "2016-04-05T19:11:29.173", "LastEditDate": "2016-04-04T21:24:14.370", "ViewCount": "257", "FavoriteCount": "4", "Title": "Variadic templates and functions' pointers: what compiler is right?", "Id": "36409348", "Score": "13", "Body": "<p><sub>I've not been able to find a better title, but feel free to modify it if you have the right idea. As it is, it's better than <em>GCC vs clang</em> anyway.</sub></p>\n<hr>\n<p>I'm trying to figure out what's wrong in this code:</p>\n<pre><code>template &lt;typename... T&gt;\nstruct S;\n\ntemplate &lt;typename T, typename... U&gt;\nstruct S&lt;T, U...&gt;: S&lt;U...&gt; {\n    using S&lt;U...&gt;::f;\n\n    template&lt;void(*F)(const T &amp;)&gt;\n    void f() { }\n};\n\ntemplate&lt;&gt;\nstruct S&lt;&gt; {\n    void f();\n};\n\ntemplate&lt;typename... T&gt;\nstruct R: S&lt;T...&gt; {\n    using S&lt;T...&gt;::f;\n\n    template&lt;typename U, void(*F)(const U &amp;)&gt;\n    void g() {\n        this-&gt;template f&lt;F&gt;();\n    }\n};\n\nvoid h(const double &amp;) { }\n\nint main() {\n    R&lt;int, double&gt; r;\n    r.g&lt;double, h&gt;();\n}\n</code></pre>\n<p>It compiles with <em>GCC 4.9</em> (see <a href=\"https://godbolt.org/g/LvMSfI\" rel=\"nofollow\">here</a>), but it doesn't compile with <em>clang 3.8.0</em> (see <a href=\"https://godbolt.org/g/yoTWR3\" rel=\"nofollow\">here</a>).</p>\n<p>Which compiler is right and why?<br>\nMoreover, what could I do to see the code compiling with both the compilers?</br></p>\n</hr>", "Tags": "<c++><templates><gcc><clang><variadic-templates>", "OwnerUserId": "4987285", "AnswerCount": "2"}, "36411262": {"ParentId": "36409348", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>After @barry - changing the definition of <code>f</code> in <code>S</code> specialization to:</p>\n<pre><code>template &lt;typename T, typename... U&gt;\nstruct S&lt;T, U...&gt;: S&lt;U...&gt; {\n    using S&lt;U...&gt;::f;\n\n\n    template&lt;void(*F)(const T &amp;)&gt;\n    void f(T *= nullptr) { }\n};\n</code></pre>\n<p>Makes also clang working with your code.</p>\n<p><strong>Edit:</strong></p>\n<p>To make the code even simpler you could change the specializations to:</p>\n<pre><code>template &lt;typename T, typename... U&gt;\nstruct S&lt;T, U...&gt;: S&lt;T&gt;, S&lt;U...&gt; {\n};\n\ntemplate&lt;typename T&gt;\nstruct S&lt;T&gt; {\n    template&lt;void(*F)(const T &amp;)&gt;\n    void f() { }\n}\n</code></pre>\n<p>And then invoke your <code>f</code> method in <code>g</code> using:</p>\n<pre><code>S&lt;U&gt;::template f&lt;F&gt;();\n</code></pre>\n<p>Using this option you can go a step further and as @barry suggested use a tag dispatching but in template parameter rather than as a paramter of a function:</p>\n<pre><code>template &lt;typename... T&gt;\nstruct S;\n\ntemplate &lt;typename T&gt;\nstruct footag { };\n\ntemplate &lt;typename T, typename... U&gt;\nstruct S&lt;T, U...&gt;: S&lt;footag&lt;T&gt;&gt;, S&lt;U...&gt; {\n};\n\ntemplate&lt;typename T&gt;\nstruct S&lt;T&gt;:S&lt;footag&lt;T&gt;&gt; {\n};\n\ntemplate&lt;typename T&gt;\nstruct S&lt;footag&lt;T&gt;&gt; {\n    template &lt;void (*F)(const T&amp;)&gt;\n    void f() { }\n};\n\ntemplate&lt;typename V, typename... T&gt;\nstruct R: S&lt;V, T...&gt; {\n    template&lt;typename U, void(*F)(const U &amp;)&gt;\n    void g() {\n        S&lt;footag&lt;U&gt;&gt;::template f&lt;F&gt;();\n    }\n};\n\nvoid h(const float &amp;) { }\n\nint main() {\n    R&lt;int, float, double&gt; r;\n    r.g&lt;float, h&gt;();\n}\n</code></pre>\n", "OwnerUserId": "4324224", "LastEditorUserId": "4324224", "LastEditDate": "2016-04-05T19:11:29.173", "Id": "36411262", "Score": "3", "CreationDate": "2016-04-04T19:28:54.590", "LastActivityDate": "2016-04-05T19:11:29.173"}, "36411098": {"ParentId": "36409348", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>I believe that clang is correct here and this is a gcc bug. First, let's start with a simplified example:</p>\n<pre><code>struct U {\n    template&lt;int &gt; void foo() { }\n};\n\nstruct X : U {\n    using U::foo;\n    template&lt;void* &gt; void foo() { }\n};\n\nint main() {\n    X{}.foo&lt;1&gt;(); // gcc ok, clang error\n}\n</code></pre>\n<p>From <a href=\"http://eel.is/c++draft/basic.namespace#namespace.udecl-15\" rel=\"noreferrer\">[namespace.udecl]</a>:</p>\n<blockquote>\n<p id=\"so_36409348_36411098_0\">When a <em>using-declaration</em> brings declarations from a base class into a derived class, member functions and\n  member function templates in the derived class override and/or hide member functions and member function\n  templates with the same name, parameter-type-list (8.3.5), cv-qualification, and ref-qualifier (if any) in a\n  base class (rather than conflicting). Such hidden or overridden declarations are excluded from the set of\n  declarations introduced by the <em>using-declaration</em>.</p>\n</blockquote>\n<p><code>U::foo</code> and <code>X::foo</code> have the same name, parameter-type-list (none<sup>\u2020</sup>), cv-qualification (none), and ref qualifier (none). Hence, <code>X::foo</code> <strong>hides</strong> <code>U::foo</code> rather than overloading it and we're definitely passing the wrong type into <code>X::foo</code>.</p>\n<p>Simply overloading on different function pointer types (rather than taking them as template parameters) works fine:</p>\n<pre><code>template &lt;typename T, typename... U&gt;\nstruct S&lt;T, U...&gt; : S&lt;U...&gt; {\n    using S&lt;U...&gt;::f;\n\n    void f(void (*F)(const T&amp;)) { }\n};\n</code></pre>\n<p>Or if you really need the function pointers as template arguments, could still overload by wrap them in a tag type:</p>\n<pre><code>template &lt;class T&gt;\nusing fptr = void(*)(const T&amp;);\n\ntemplate &lt;class T, fptr&lt;T&gt; F&gt;\nusing func_constant = std::integral_constant&lt;fptr&lt;T&gt;, F&gt;;\n</code></pre>\n<p>and propagate that through:</p>\n<pre><code>template &lt;typename T, typename... U&gt;\nstruct S&lt;T, U...&gt;: S&lt;U...&gt; {\n    using S&lt;U...&gt;::f;\n\n    template &lt;fptr&lt;T&gt; F&gt;\n    void f(func_constant&lt;T, F&gt; ) { }\n};\n</code></pre>\n<p>and:</p>\n<pre><code>template &lt;class U, fptr&lt;U&gt; F&gt;\nvoid g() {\n    this-&gt;f(func_constant&lt;U, F&gt;{});\n}\n</code></pre>\n<p><sup>\u2020</sup>The definition of <a href=\"http://eel.is/c++draft/dcl.fct#5\" rel=\"noreferrer\">parameter-type-list</a> doesn't mention template parameters.</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2016-04-04T20:38:58.570", "Id": "36411098", "Score": "9", "CreationDate": "2016-04-04T19:20:38.617", "LastActivityDate": "2016-04-04T20:38:58.570"}, "bq_ids": {"n4140": {"so_36409348_36411098_0": {"section_id": 5504, "quality": 0.75, "length": 33}}, "n3337": {"so_36409348_36411098_0": {"section_id": 5290, "quality": 0.75, "length": 33}}, "n4659": {"so_36409348_36411098_0": {"section_id": 6938, "quality": 0.9318181818181818, "length": 41}}}});