post_cb({"30480820": {"ParentId": "30479923", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>There is \u00a713.3.1.4/(1.2), only appertaining to (copy-)initialization of objects of class type, that specifies how candidate conversion functions for your first case are found:</p>\n<blockquote>\n<p id=\"so_30479923_30480820_0\">Under the conditions specified in 8.5, as part of a\n  copy-initialization of an object of class type, a user-defined\n  conversion can be invoked to convert an initializer expression to the\n  type of the object being initialized. Overload resolution is used to\n  select the user-defined conversion to be invoked. [\u2026] Assuming that\n  \u201ccv1 <code>T</code>\u201d is the type of the object being initialized, with <code>T</code> a class\n  type, the candidate functions are selected as follows:</p>\n<ul>\n<li><p id=\"so_30479923_30480820_1\">The converting constructors (12.3.1) of <code>T</code> are candidate\n  functions.</p></li>\n<li><p id=\"so_30479923_30480820_2\">When the type of the initializer expression is a class type\n  \u201c<em>cv</em> <code>S</code>\u201d, the non-explicit conversion functions of <code>S</code> and its base\n  classes are considered. When initializing a temporary to be bound to\n  the first parameter of a constructor where the parameter is of type\n  \u201creference to possibly cv-qualified <code>T</code>\u201d and the constructor is called\n  with a single argument in the context of direct-initialization of an\n  object of type \u201c<em>cv2</em> <code>T</code>\u201d, explicit conversion functions are also\n  considered. <strong>Those that are not hidden within <code>S</code> and yield a type\n  whose cv-unqualified version is the same type as <code>T</code> or is a derived\n  class thereof are candidate functions.</strong> [\u2026] Conversion functions that return \u201creference to <code>X</code>\u201d return lvalues or xvalues,\n  depending on the type of reference, of type X and are therefore considered to yield <code>X</code> for this process of selecting candidate functions. </p></li>\n</ul>\n</blockquote>\n<p>I.e. <code>operator const char*</code> is, though being considered, not included in the candidate set, since <code>const char*</code> is clearly not similar to <code>A</code> in any respect. However, in your second snippet, <code>operator=</code> is called as an ordinary member function, which is why this restriction doesn't apply anymore; Once both conversion functions are in the candidate set, overload  resolution will clearly result in an ambiguity.</p>\n<p>Note that for direct-initialization, the above rule doesn't apply either. </p>\n<pre><code>B x;\nA y(x);\n</code></pre>\n<p>Is ill-formed.</p>\n<p>A more general form of this result is that <strong>there can never be two user-defined conversions in one conversion sequence during overload resolution</strong>. Consider \u00a713.3.3.1/4:</p>\n<blockquote>\n<p id=\"so_30479923_30480820_3\">However, if the target is</p>\n<ul>\n<li>the first parameter of a constructor or [\u2026]</li>\n</ul>\n<p id=\"so_30479923_30480820_4\">and the constructor [\u2026] is a candidate\n  by</p>\n<ul>\n<li>13.3.1.3, when the argument is the temporary in the second step of a class copy-initialization, or</li>\n<li>13.3.1.4, 13.3.1.5, or 13.3.1.6 (in all cases),</li>\n</ul>\n<p id=\"so_30479923_30480820_5\">user-defined conversion sequences are not considered. <strong>[<em>Note</em>: These\n  rules prevent more than one user-defined conversion from being applied\n  during overload resolution, thereby avoiding infinite recursion. \u2014 end\n  <em>note</em> ]</strong></p>\n</blockquote>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-05-27T13:12:49.140", "Id": "30480820", "Score": "4", "CreationDate": "2015-05-27T11:12:51.807", "LastActivityDate": "2015-05-27T13:12:49.140"}, "bq_ids": {"n4140": {"so_30479923_30480820_5": {"section_id": 609, "quality": 0.8260869565217391, "length": 19}, "so_30479923_30480820_0": {"section_id": 593, "quality": 0.972972972972973, "length": 36}, "so_30479923_30480820_2": {"section_id": 593, "quality": 0.9142857142857143, "length": 64}, "so_30479923_30480820_1": {"section_id": 593, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_30479923_30480820_1": {"section_id": 583, "quality": 0.6666666666666666, "length": 4}, "so_30479923_30480820_0": {"section_id": 583, "quality": 0.972972972972973, "length": 36}, "so_30479923_30480820_2": {"section_id": 583, "quality": 0.8857142857142857, "length": 62}}, "n4659": {"so_30479923_30480820_1": {"section_id": 616, "quality": 0.6666666666666666, "length": 4}, "so_30479923_30480820_0": {"section_id": 616, "quality": 0.972972972972973, "length": 36}, "so_30479923_30480820_2": {"section_id": 616, "quality": 0.9714285714285714, "length": 68}, "so_30479923_30480820_5": {"section_id": 635, "quality": 0.8260869565217391, "length": 19}}}, "30481103": {"ParentId": "30479923", "CommentCount": "2", "Body": "<p>There is a difference between initialization and assignment.</p>\n<p>In initialization, that is:</p>\n<pre><code>A y = x;\n</code></pre>\n<p>The actual call depends on the type of <code>x</code>. If it is the same type of <code>y</code>, then it will be like:</p>\n<pre><code>A y(x);\n</code></pre>\n<p>If not, as in your example, it will be like:</p>\n<pre><code>A y(static_cast&lt;const A&amp;&gt;(x));\n</code></pre>\n<p>And that compiles fine, because there is no ambiguity any more.</p>\n<p>In the assignment there is no such special case, so no automatic resolution of the ambiguity.</p>\n<p>It is worth noting that:</p>\n<pre><code>A y(x);\n</code></pre>\n<p>is also ambiguous in your code.</p>\n", "OwnerUserId": "865874", "PostTypeId": "2", "Id": "30481103", "Score": "5", "CreationDate": "2015-05-27T11:26:03.877", "LastActivityDate": "2015-05-27T11:26:03.877"}, "30479923": {"CommentCount": "1", "AcceptedAnswerId": "30481103", "CreationDate": "2015-05-27T10:32:16.683", "LastActivityDate": "2015-05-27T13:12:49.140", "PostTypeId": "1", "ViewCount": "409", "FavoriteCount": "4", "Title": "Ambiguous assignment operator", "Id": "30479923", "Score": "12", "Body": "<p>I have two classes, one of which, say, represents a string, and the other can be converted to a string:</p>\n<pre><code>class A {\npublic:\n  A() {}\n  A(const A&amp;) {}\n  A(const char*) {}\n\n  A&amp; operator=(const A&amp;) { return *this; }\n  A&amp; operator=(const char*) { return *this; }\n\n  char* c;\n};\nclass B {\npublic:\n  operator const A&amp;() const {\n    return a;\n  }\n  operator const char*() const {\n    return a.c;\n  }\n\n  A a;\n};\n</code></pre>\n<p>Now, if I do</p>\n<pre><code>B x;\nA y = x;\n</code></pre>\n<p>It triggers copy constructor, which compiles fine. But if I do</p>\n<pre><code>A y;\ny = x;\n</code></pre>\n<p>It complains about ambiguous assignment, and can't choose between <code>=(A&amp;)</code> and <code>=(char*)</code>. Why the difference?</p>\n", "Tags": "<c++>", "OwnerUserId": "1537403", "AnswerCount": "2"}});