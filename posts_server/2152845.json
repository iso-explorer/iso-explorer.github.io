post_cb({"2152845": {"ViewCount": "1995", "Body": "<p>I am trying to do the following: Obtain the address of a member function from a class that was locally defined within a function.</p>\n<pre><code>class ConnectionBase\n{\n};\n\ntemplate class&lt;EventType, SinkType&gt;\nclass ConnectionImpl : public ConnectionBase\n{\npublic:\ntypedef void (SinkType::*EventCallback)(EventType const&amp;);\n};\n\n\ntemplate&lt;class EventType&gt;\nclass Source\n{\n    template &lt;class SinkType&gt;\n    boost::shared_ptr&lt;ConnectionBase&gt; setupCallback(typename ConnectionImpl&lt;EventType, SinkType&gt;::EventCallback func, SinkType* sink)\n    {\n    // do the actual connecting.\n    }\n};\n\nclass SomeClass\n{\npublic:\n    void someFunction(int const&amp; event){}\n}\n\nclass SomeUnitTest\n{\npublic:\n    void someTest()\n    {\n        class NestedClass \n        {\n        public:\n            void someFunction(int const&amp; event){}\n        };\n\n       NestedClass nc;\n\n       //Try#1 - This does not work\n       setupCallback&lt;int, NestedClass&gt;(&amp;NestedClass::someFunction, &amp;nc);\n\n       //Try #2 - This also does not work\n       setupCallback&lt;int, NestedClass&gt;(&amp;SomeUnitTest::someTest::NestedClass::someFunction, &amp;nc);\n\n       //Try #3 - Following the GCC error output, I tried this\n       setupCallback&lt;int, NestedClass&gt;(&amp;SomeUnitTest::someTest()::NestedClass::someFunction, &amp;nc);\n\n       SomeClass sc;\n\n       //This works fine, as expected\n       setupCallback&lt;int, SomeClass&gt;(&amp;SomeClass::someFunction, &amp;sc);\n\n    }\n};\n</code></pre>\n<p>Try #2 and #3 utterly confuse GCC, it has no idea what I am trying to do.\nTry #1 produces a more helpful error message saying no setupCallback exists that takes the form \"setupCallback(void (SomeUnitTest::someTest()::NestedClass::SomeFunction::*), etc)\nWhich is how try #3 was born.</p>\n<p>I can't really find a lot of information about classes defined inside a function, does anyone know the correct syntax for this, and maybe have a resource that discusses this topic?</p>\n<p>Ok, it appears this is settled, as both posters have pointed out, local classes have no linkage, it can't work. Now knowing this, I found this article that discusses this, for anyone else that runs into this problem and stumbles across this question: <a href=\"http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=420\" rel=\"nofollow noreferrer\">http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=420</a></p>\n<p>Edit:\nClarification of setupCallback(), working example with a more regular class<br>\nEdit #2:\nUpdated wording to change \"nested\" to \"local\". Added more detail for setupCallback.<br>\nEdit #3: Added links to furhter information. Thanks everyone. </br></br></p>\n", "AcceptedAnswerId": "2152910", "Title": "How to get address of member function for local class defined in function (C++)", "CreationDate": "2010-01-28T07:05:05.943", "Id": "2152845", "CommentCount": "4", "LastEditDate": "2010-01-28T18:42:34.530", "PostTypeId": "1", "LastEditorUserId": "236419", "LastActivityDate": "2010-01-28T18:42:34.530", "Score": "3", "OwnerUserId": "236419", "Tags": "<c++><member-function-pointers><local-class>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_2152845_2152910_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 7141}, "so_2152845_2152910_1": {"length": 6, "quality": 1.0, "section_id": 5882}}, "n3337": {"so_2152845_2152910_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 6885}, "so_2152845_2152910_1": {"length": 6, "quality": 1.0, "section_id": 5653}}, "n4659": {"so_2152845_2152910_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 8642}, "so_2152845_2152910_1": {"length": 6, "quality": 1.0, "section_id": 7365}}}, "2152910": {"Id": "2152910", "PostTypeId": "2", "Body": "<p>I don't know about the syntax problem, the usual access rules should apply - but there is another problem here if that would work as these member functions have no linkage.<br>\nTo accept local types at all, <code>setupCallback()</code> would have to be a template function - but template type arguments with no linkage are not allowed.</br></p>\n<p><em>\u00a73.5/8</em> says:</p>\n<blockquote>\n<p id=\"so_2152845_2152910_0\">Names not covered by these rules have\n  no linkage. Moreover, except as noted,\n  a name declared in a local scope\n  (3.3.2) has no linkage.</p>\n</blockquote>\n<p>Members of local classes are not covered there. <em>\u00a79.3/3</em> clarifies that:</p>\n<blockquote>\n<p id=\"so_2152845_2152910_1\">Member functions of a local class\n  (9.8) have no linkage.</p>\n</blockquote>\n<p>Long story cut short: don't use member functions of a local class as callbacks, use a non-local class instead.</p>\n", "LastEditorUserId": "168225", "LastActivityDate": "2010-01-28T09:27:06.613", "Score": "4", "CreationDate": "2010-01-28T07:20:32.413", "ParentId": "2152845", "CommentCount": "13", "OwnerUserId": "168225", "LastEditDate": "2010-01-28T09:27:06.613"}, "2153014": {"Id": "2153014", "PostTypeId": "2", "Body": "<p>You fist variant is the correct one as long as the specific matter of taking the address is considered. There are no restrictions on taking the address of member functions of local classes. The proper syntax is the usual</p>\n<pre><code>&amp;NestedClass::someFunction\n</code></pre>\n<p>ans that's it. You can try saving it in an intermediate pointer in your code </p>\n<pre><code>void (NestedClass::*ptr)() = &amp;NestedClass::someFunction;\n</code></pre>\n<p>and I'm sure your compiler will accept it.</p>\n<p>However, the problem I suspect exists in your code has absolutely nothing to do with the proper way of taking the address of a member function. It is rather about the way the first parameter of <code>setupCallback</code> is declared. Since you say it works with <code>&amp;SomeClass::someFunction</code> as the first argument, I'd expect <code>setupCallback</code> to be declared as</p>\n<pre><code>void setupCallback(void (SomeClass::*cb)(), SomeClass *p); // one possibility\n</code></pre>\n<p>i.e. it is <em>hardcoded</em> to expect a pointer to a member of <code>SomeClass</code> specifically. You cannot supply a pointer to a member of <code>NestedClass</code> instead. <code>NestedClass</code> is completely unrelated to <code>SomeClass</code> and pointers to members of <code>NestedClass</code> are completely incompatible with pointers to members of <code>SomeClass</code>. This is why it won't compile.</p>\n<p>Unless there's something you are not showing us (like <code>setupCallback</code> being a function template maybe? Or overloaded for different parameter types?), what you are trying to do is simply impossible to achieve regardless of how you take the member address, as long as <code>NestedClass</code> remains unrelated to <code>SomeClass</code>. Function <code>setupCallback</code> is designed to work with <code>SomeClass</code> and <code>SomeClass</code> only.</p>\n<p>Provide more information about <code>setupCallback</code>. How is it declared?</p>\n<p>Note that if the <code>setupCallback</code> is declared as a function template parametrized by class type, as in</p>\n<pre><code>template &lt;class T&gt; void setupCallback(void (T::*cb)(), T* p);\n</code></pre>\n<p>then you won't be able to use the local class <code>NestedClass</code> as template argument for parameter <code>T</code>. In this case the fact that your <code>NestedClass</code> has no linkage does indeed come into play. But, again, it has nothing to do with taking the member address, but rather caused by the fact that classes with no linkage cannot be used as template arguments in C++.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2010-01-28T08:45:33.827", "Score": "4", "CreationDate": "2010-01-28T07:47:10.497", "ParentId": "2152845", "CommentCount": "2", "OwnerUserId": "187690", "LastEditDate": "2010-01-28T08:45:33.827"}});