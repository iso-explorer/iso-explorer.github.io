post_cb({"340316": {"Id": "340316", "PostTypeId": "2", "Body": "<p>That's undefined behaviour, the result will vary depending on the compiler you use. See, for example, <a href=\"http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.15\" rel=\"nofollow noreferrer\">C++ FAQ Lite</a>.</p>\n", "OwnerDisplayName": "Claymore", "LastActivityDate": "2008-12-04T11:47:18.203", "Score": "16", "CreationDate": "2008-12-04T11:47:18.203", "ParentId": "340282", "CommentCount": "0", "OwnerUserId": "7510"}, "bq_ids": {"n4140": {"so_340282_341246_3": {"length": 49, "quality": 0.7777777777777778, "section_id": 5768}}, "n3337": {"so_340282_341246_3": {"length": 49, "quality": 0.7777777777777778, "section_id": 5541}}, "n4659": {"so_340282_341246_3": {"length": 49, "quality": 0.7777777777777778, "section_id": 7225}}}, "341246": {"Body": "<p>In some of the answers/comments there has been a discussion about the meaning of 'undefined behavior' and whether that makes the program invalid. So I'm posting this rather long answer detailing exactly what the standard says with some notes.  I hope it's not too boring...</p>\n<p>The quoted bits of the standard come from the current C++ standard (ISO/IEC 14882:2003).  There's similar wording in the C standard.</p>\n<p>According to the C++ standard, modifying a value more than once within a set of sequence points results in undefined behavior (section 5 Paragraph 4):</p>\n<blockquote>\n<p id=\"so_340282_341246_0\">Except where noted, the order of\n  evaluation of operands of individual\n  operators and subexpressions of\n  individual expressions, and the order\n  in which side effects take place, is\n  unspecified.53) Between the previous\n  and next sequence point a scalar\n  object shall have its stored value\n  modified at most once by the\n  evaluation of an expression.\n  Furthermore, the prior value shall be\n  accessed only to determine the value\n  to be stored. The requirements of this\n  paragraph shall be met for each\n  allowable ordering of the\n  subexpressions of a full expression;\n  otherwise the behavior is undefined.\n  [Example:</p>\n<pre><code>i = v[i++]; // the behavior is unspecified\ni = 7, i++, i++; // i becomes 9\ni = ++i + 1; // the behavior is unspecified\ni = i + 1; // the value of i is incremented\n</code></pre>\n<p id=\"so_340282_341246_1\">\u2014end example]</p>\n</blockquote>\n<p>Note that the second example, \"<code>i = 7, i++, i++;</code>\" is defined since the comma operator is a sequence point.</p>\n<p>Here's what the C++ standard says 'undefined behavior' means:</p>\n<blockquote>\n<p id=\"so_340282_341246_2\">1.3.12 undefined behavior [defns.undefined]</p>\n<p id=\"so_340282_341246_3\">behavior, such as might arise upon use of an erroneous program construct or erroneous data, for which this\n  International Standard imposes no requirements. Undefined behavior may also be expected when this\n  International Standard omits the description of any explicit definition of behavior. [Note: permissible undefined\n  behavior ranges from ignoring the situation completely with unpredictable results, to behaving during\n  translation or program execution in a documented manner characteristic of the environment (with or without\n  the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a\n  diagnostic message). Many erroneous program constructs do not engender undefined behavior; they are required to be diagnosed. ]</p>\n</blockquote>\n<p>In other words, the compiler is free to do whatever it wants, including</p>\n<ol>\n<li>spitting out an error message, </li>\n<li>doing something implementation defined &amp; documented,</li>\n<li>having completely unpredictable results</li>\n</ol>\n<p>The second item covers language extensions which most compilers have, but of course are not defined  in the standard.</p>\n<p>So I guess that strictly speaking something that exhibits undefined behavior is not 'illegal', but in my experience whenever there's been something in a C/C++ program that exhibits 'undefined behavior' (unless it's an extension) - it's a bug.  I think that calling such a construct illegal is not confusing, misleading, or misguided.</p>\n<p>Also, I think trying to explain what the compiler is doing to reach the value 14 is not particularly helpful, as that misses the point.  The compiler could be doing almost anything; in fact, it's likely that the compiler may reach a different result when it's run using differing optimization options (or may produce code that crashes - who knows?).</p>\n<p>For those who want some additional references or an appeal to authority, here are some pointers:</p>\n<p>Steve Summit's (maintainer of the comp.lang.c Frequently Asked Questions) long, long answer on this topic from 1995:</p>\n<ul>\n<li><a href=\"http://www.eskimo.com/~scs/readings/undef.950321.html\" rel=\"nofollow noreferrer\">http://www.eskimo.com/~scs/readings/undef.950321.html</a></li>\n</ul>\n<p>Here's what Bjarne Stroustrup has to say on the matter:</p>\n<ul>\n<li><a href=\"http://www.research.att.com/~bs/bs_faq2.html#evaluation-order\" rel=\"nofollow noreferrer\">http://www.research.att.com/~bs/bs_faq2.html#evaluation-order</a></li>\n</ul>\n<hr>\n<p><em>Footnote</em>:  the C++ standard uses the word 'illegal' exactly once - when describing a difference between C++ and Standard C regarding the use of <code>static</code> or <code>extern</code> with type declarations.</p>\n</hr>", "CreationDate": "2008-12-04T16:40:09.907", "ParentId": "340282", "CommentCount": "4", "LastEditDate": "2008-12-04T22:02:07.853", "PostTypeId": "2", "LastEditorDisplayName": "Mike B", "LastActivityDate": "2008-12-04T22:02:07.853", "LastEditorUserId": "12711", "Id": "341246", "OwnerDisplayName": "Mike B", "Score": "12", "OwnerUserId": "12711"}, "340305": {"Body": "<p>The order of side effects is undefined in C++. Additionally, modifying a variable twice in a single expression has no defined behavior (See the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf\" rel=\"nofollow noreferrer\">C++ standard</a>, \u00a75.0.4, physical page 87 / logical page 73).</p>\n<p>Solution: Don't use side effects in complex expression, don't use more than one in simple ones. And it does not hurt to enable all the warnings the compiler can give you: Adding <code>-Wall</code>(gcc) or <code>/Wall /W4</code>(Visual C++) to the command line yields a fitting warning:</p>\n<pre><code>test-so-side-effects.c: In function 'main':\ntest-so-side-effects.c:5: warning: operation on 'i' may be undefined\ntest-so-side-effects.c:5: warning: operation on 'i' may be undefined\n</code></pre>\n<p>Obviously, the code compiles to:</p>\n<pre><code>i = i + 1;\ni = i + 1;\ni = i + i;\n</code></pre>\n", "CreationDate": "2008-12-04T11:44:17.587", "ParentId": "340282", "CommentCount": "7", "LastEditDate": "2013-07-03T08:16:30.970", "PostTypeId": "2", "LastEditorDisplayName": "Martin York", "LastActivityDate": "2013-07-03T08:16:30.970", "LastEditorUserId": "35070", "Id": "340305", "OwnerDisplayName": "phihag", "Score": "45", "OwnerUserId": "35070"}, "343859": {"Id": "343859", "PostTypeId": "2", "Body": "<p>I think that when looking at the problem from the sight of the syntax tree, the answer to the problem becomes clearer:</p>\n<p>i<br>\n|<br>\n=<br>\n|<br>\n+<br>\n|<br>\nunary expression - unary expression<br>\n<br>\nunary expression: unary operator expression<br>\n<br>\nIn our case expression boils down to the variable i.<br>\n<br>\nNow what happens is that both unary expression modify the same operand, so the code does two times ++i when evaluating the unary expressions before adding the results of both unary expressions.<br>\n<br>\nSo what the code does is indeed<br>\n<br>\n++i;<br>\n++i;<br>\ni = i + i;<br>\n<br>\nFor i = 5 that means<br>\n<br>\ni = i + 1; //i &lt;- 6<br>\ni = i + 1; //i &lt;- 7<br>\ni = i + i; //i &lt;- 14<br/></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></p>\n", "OwnerDisplayName": "karx11erx", "LastActivityDate": "2008-12-05T13:39:34.577", "Score": "1", "CreationDate": "2008-12-05T13:39:34.577", "ParentId": "340282", "CommentCount": "0", "OwnerUserId": "43614"}, "340315": {"Id": "340315", "PostTypeId": "2", "Body": "<p>Simple... you compiler is evaluating <strong>BOTH</strong> increments before performing the sum, without caching the intermediate results. This means that when you add i twice, it now has the value of 7.</p>\n<p>If you do </p>\n<pre><code>int j=++i; \nint k=++i;\n\ni = j+k;\n</code></pre>\n<p>you'll see 13 as expected. </p>\n", "OwnerDisplayName": "bgoncalves", "LastActivityDate": "2008-12-04T11:47:15.710", "Score": "3", "CreationDate": "2008-12-04T11:47:15.710", "ParentId": "340282", "CommentCount": "2", "OwnerUserId": "280"}, "340282": {"ViewCount": "2023", "Body": "<p>Can someone explain to me why this code prints 14? I was just asked by another student and couldn't figure it out.</p>\n<pre><code>int i = 5;\ni = ++i + ++i;\ncout&lt;&lt;i;\n</code></pre>\n", "AcceptedAnswerId": "340305", "Title": "C++ Mystery", "CreationDate": "2008-12-04T11:35:55.903", "Id": "340282", "CommentCount": "8", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2008-12-04T17:02:28.367", "LastEditorDisplayName": "Marcin", "OwnerDisplayName": "Alexander Stolz", "LastEditorUserId": "22724", "LastActivityDate": "2013-07-03T08:16:30.970", "Score": "15", "OwnerUserId": "2450", "Tags": "<c++><puzzle><operator-precedence>", "AnswerCount": "9"}, "340306": {"Id": "340306", "PostTypeId": "2", "Body": "<p>On your particular compiler, it's choosing to do both of the ++ operations first, then the addition.  It's interpreting the code as:</p>\n<pre><code>int i = 5;\n++i;\n++i;\ni = i + i;\ncout &lt;&lt; i;\n</code></pre>\n<p>That's perfectly valid.</p>\n", "OwnerDisplayName": "Mr Fooz", "LastActivityDate": "2008-12-04T11:44:52.080", "Score": "2", "CreationDate": "2008-12-04T11:44:52.080", "ParentId": "340282", "CommentCount": "3", "OwnerUserId": "25050"}, "340299": {"Id": "340299", "PostTypeId": "2", "Body": "<p>Because the prefix increment has precedence:</p>\n<pre><code>int i = 5;\ni = i+1; // First ++i, i is now 6\ni = i+1; // Second ++i, i is now 7\ni = i + i // i = 7 + 7\ncout &lt;&lt; i // i = 14\n</code></pre>\n", "OwnerDisplayName": "Gonzalo Quero", "LastActivityDate": "2008-12-04T11:43:24.517", "Score": "-1", "CreationDate": "2008-12-04T11:43:24.517", "ParentId": "340282", "CommentCount": "7", "OwnerUserId": "40996"}, "341442": {"Id": "341442", "PostTypeId": "2", "Body": "<p>A better question would be, is it always going to be <code>14</code>?</p>\n<pre><code>int i = 5;\ni = ++i + ++i;\ncout&lt;&lt;i;\n\ni = ++i   + ++i   ;\ni = ++(5) + ++(5) ;\ni =    6  +    6  ;\ni = 12;\n\ni = ++i   + ++i   ;\ni = ++i   + ++(5) ;\ni = ++i   +   (6) ;\ni = ++(6) +    6  ;\ni =   (7) +    6  ;\ni = 13;\n\ni = ++i   + ++i   ;\ni = ++i   + ++(5) ;\ni = ++(6) +   (6) ;\ni =   (7) +   (7) ;\ni = 14;\n</code></pre>\n<p>In all likelihood it will probably be <code>14</code>, because it makes <em>slightly</em> more sense.</p>\n", "OwnerDisplayName": "Brad Gilbert", "LastActivityDate": "2008-12-04T17:31:18.730", "Score": "1", "CreationDate": "2008-12-04T17:31:18.730", "ParentId": "340282", "CommentCount": "0", "OwnerUserId": "1337"}, "340464": {"Id": "340464", "PostTypeId": "2", "Body": "<pre><code> i = i++ + i; //11  \n\n i = i++ + i++; //12\n\n i = i++ + ++i; //13\n\n i = ++i + i++; //13\n\n i = ++i + ++i; //14    \n</code></pre>\n", "OwnerDisplayName": "plan9assembler", "LastActivityDate": "2008-12-04T12:43:24.240", "Score": "-1", "CreationDate": "2008-12-04T12:43:24.240", "ParentId": "340282", "CommentCount": "0", "OwnerUserId": "1710672"}});