post_cb({"bq_ids": {"n4140": {"so_8629835_8629868_2": {"length": 23, "quality": 1.0, "section_id": 6045}, "so_8629835_8629868_0": {"length": 9, "quality": 1.0, "section_id": 6045}, "so_8629835_8629868_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 6045}}, "n3337": {"so_8629835_8629868_2": {"length": 23, "quality": 1.0, "section_id": 5813}, "so_8629835_8629868_0": {"length": 9, "quality": 1.0, "section_id": 5813}, "so_8629835_8629868_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 5813}}, "n4659": {"so_8629835_8629868_2": {"length": 23, "quality": 1.0, "section_id": 7544}, "so_8629835_8629868_0": {"length": 9, "quality": 1.0, "section_id": 7544}, "so_8629835_8629868_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 7544}}}, "8629868": {"Id": "8629868", "PostTypeId": "2", "Body": "<p>You cannot directly assign a <code>double(*)(double)</code> to <code>double(*)(...)</code>, but you could <code>reinterpret_cast</code> it. The cast is explicitly allowed by \u00a75.2.10[expr.reinterpret.cast]/6, but calling the casted function pointer will cause undefined behavior:</p>\n<blockquote>\n<p id=\"so_8629835_8629868_0\">A function pointer <strong>can</strong> be explicitly converted to a function pointer of a different type. </p>\n<p id=\"so_8629835_8629868_1\">The effect of calling a function through a pointer to a function type that is not the same as the type used in the definition of the function is <strong>undefined</strong>. </p>\n<p id=\"so_8629835_8629868_2\">Except that converting a prvalue of type \u201cpointer to <code>T1</code>\u201d to the type \u201cpointer to <code>T2</code>\u201d (where <code>T1</code> and <code>T2</code> are function types) and back to its original type yields the <strong>original</strong> pointer value, the result of such a pointer conversion is unspecified. </p>\n</blockquote>\n<p>It is easy to see why it leads to UB \u2014 what if we call <code>generalized(1.0, 2.0, 3.0)</code>? This will likely corrupt the call stack. But it is fine if you cast the <code>generalized</code> back to a <code>double(*)(double)</code> before you call it.</p>\n", "LastEditorUserId": "224671", "LastActivityDate": "2011-12-25T13:52:58.327", "Score": "3", "CreationDate": "2011-12-25T13:47:34.420", "ParentId": "8629835", "CommentCount": "2", "LastEditDate": "2011-12-25T13:52:58.327", "OwnerUserId": "224671"}, "8629835": {"ViewCount": "237", "Body": "<p>I'm wondering if it's safe to cast a <code>double (*)(double)</code> to <code>double(*)(...)</code>, this is going to be used to generalize a code which may have pointers to multiple functions.</p>\n<p>so far I've stored every thing that is going to be passed to the function in a vector, and I'm wondering if there is a way to call a function (while passing the correct number of arguments) in a generalized code? I mean something this:</p>\n<pre><code>//while initializing\nmFunction = sin;\n//later in code\ndouble (*generalized)(...) = mFunction;\nfor(i=0;i&lt;args.size();i++)\n    pusharg(args[i]);\ncall(generalized);\n</code></pre>\n<p><strong>--edit--</strong></p>\n<p>if there is not a valid way to do it using c++ is it possible to saftly call the function using assembly?</p>\n", "AcceptedAnswerId": "8629868", "Title": "c++: is it safe to cast pointer to functions?", "CreationDate": "2011-12-25T13:39:03.350", "Id": "8629835", "CommentCount": "1", "LastEditDate": "2011-12-25T17:49:15.860", "PostTypeId": "1", "LastEditorUserId": "651687", "LastActivityDate": "2013-03-02T09:26:08.707", "Score": "1", "OwnerUserId": "651687", "Tags": "<c++><assembly><casting><function-pointers>", "AnswerCount": "3"}, "15172875": {"Id": "15172875", "PostTypeId": "2", "Body": "<p>Making <code>generalized</code> volatile will require the compiler to follow the ABI specification. Due to a desire to support non-declared C functions this is safe on most ABIs (including x86 and x86-32) if one does not call a function that excepts a variable number of arguments though a pointer to function with a fixed number of arguments.</p>\n", "LastActivityDate": "2013-03-02T09:26:08.707", "CommentCount": "0", "CreationDate": "2013-03-02T09:26:08.707", "ParentId": "8629835", "Score": "0", "OwnerUserId": "904148"}, "8629886": {"Id": "8629886", "PostTypeId": "2", "Body": "<p>Yes, the casting itself is allowed. To call it with a wrong signature is not, though. Note that if you want a generic function pointer, better use <code>void (*)()</code>, it's like <code>void*</code> for function pointers (no implicit conversion to it, though).</p>\n<p>Or even better, since you apperently provide specific arguments, use <code>std::function</code> and <code>std::bind</code> (if your compiler supports C++11 libraries), or their Boost equivalents.</p>\n", "LastActivityDate": "2011-12-25T13:50:56.243", "CommentCount": "3", "CreationDate": "2011-12-25T13:50:56.243", "ParentId": "8629835", "Score": "1", "OwnerUserId": "500104"}});