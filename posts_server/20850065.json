post_cb({"bq_ids": {"n4140": {"so_20850065_20850142_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 2293}}, "n3337": {"so_20850065_20850142_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 2280}}, "n4659": {"so_20850065_20850142_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 2566}}}, "20850142": {"Id": "20850142", "PostTypeId": "2", "Body": "<h2>What the declaration means.</h2>\n<p>The formal argument \u2026</p>\n<pre><code>ostream&amp; (*pf)(ostream&amp;)\n</code></pre>\n<p>declares an argument named <code>pf</code> which is a pointer, to which you can apply an argument parenthesis with an <code>ostream&amp;</code> argument, which constitutes a call that returns an <code>ostream&amp;</code> as its result.</p>\n<p>It can be simplified to just  \u2026</p>\n<pre><code>ostream&amp; pf(ostream&amp;)\n</code></pre>\n<p>where you can more easily see that it's a function.</p>\n<p>The drawback is that this form is seldom used, so not everybody is aware that it decays to the first form (much the same as e.g. <code>int x[43]</code> as a formal argument type is effectively the same as just <code>int x[]</code> because both these forms decay to just <code>int* x</code> in the function type, so that in the function body you can even increment that <code>x</code>).</p>\n<hr>\n<h2>What it\u2019s used for.</h2>\n<p>A function of the above form is usually an output stream <strong>manipulator</strong>. That means, you can pass it to the <code>&lt;&lt;</code> output operator. What happens then is just that <code>&lt;&lt;</code> calls that function, with the stream as argument, as specified by C++11 \u00a727.7.3.6.3/1 and 2:</p>\n<blockquote>\n<p id=\"so_20850065_20850142_0\"><code>basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;</code>\n<code>(basic_ostream&lt;charT,traits&gt;&amp; (*pf)(basic_ostream&lt;charT,traits&gt;&amp;))</code> </p>\n<ol>\n<li><p id=\"so_20850065_20850142_1\">Effects: None. Does not behave as a formatted output function (as described in 27.7.3.6.1).  </p></li>\n<li><p id=\"so_20850065_20850142_2\">Returns: <code>pf(*this)</code>.</p></li>\n</ol>\n</blockquote>\n<p>There is also an overload of <code>&lt;&lt;</code> that takes a similar function, but with <code>std::basic_ios&amp;</code> argument and result, and one that takes a function with <code>std::ios_base</code> argument and result.</p>\n<p>Class <code>std::ios_base</code> is the base of the iostreams class hierarchy and the standard manipulators defined at that level are \u2026:</p>\n<ul>\n<li><p><em>Format flag manipulators:</em><br>\n<code>boolalpha</code>, <code>noboolalpha</code>, <code>showbase</code>, <code>noshowbase</code>, <code>showpoint</code>, <code>noshowpoint</code>, <code>showpos</code>, <code>noshowpos</code>, <code>skipws</code>, <code>noskipws</code>, <code>uppercase</code>, <code>nouppercase</code>, <code>unitbut</code> and <code>nounitbuf</code>.</br></p></li>\n<li><p><em>Adjustment field manipulators:</em><br>\n<code>internal</code>, <code>left</code> and <code>right</code>.</br></p></li>\n<li><p><em>Numeral system base manipulators:</em><br>\n<code>dec</code>, <code>hex</code> and <code>oct</code>.</br></p></li>\n<li><p><em>Floating point number presentation manipulators:</em><br>\n<code>fixed</code>, <code>scientific</code>, <code>hexfloat</code> and <code>defaultfloat</code>.</br></p></li>\n</ul>\n<p>Manipulators that take user arguments don\u2019t follow this form and those that the standard provides are in a separate header called <code>&lt;iomanip&gt;</code>.</p>\n<h2>Example: a user-defined manipulator.</h2>\n<p>Code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n// With Visual C++, if necessary define __func__ as __FUNCTION__.\nusing namespace std;\n\nclass Logger\n{\nprivate:\n    string  funcname_;\n    static int call_level;\n\n    auto\n    static indent( ostream&amp; stream )\n        -&gt; ostream&amp;\n    { return (stream &lt;&lt; string( 4*call_level, ' ' )); }\n\npublic:\n    Logger( string const&amp; funcname )\n        : funcname_( funcname )\n    {\n        clog &lt;&lt; indent &lt;&lt; \"-&gt; \" &lt;&lt; funcname_ &lt;&lt; endl;\n        ++call_level;\n    }\n\n    ~Logger()\n    {\n        --call_level;\n        clog &lt;&lt; indent &lt;&lt; \"&lt;- \" &lt;&lt; funcname_ &lt;&lt; endl;\n    }\n};\n\nint Logger::call_level = 0;\n\n#define WITH_LOGGING Logger logging( __func__ )\n\nvoid c() { WITH_LOGGING; }\nvoid b() { WITH_LOGGING; c(); }\nvoid a() { WITH_LOGGING; b(); }\n\nauto main() -&gt; int { a(); }\n</code></pre>\n<p>Output, which shows the calls and returns, nicely indented:</p>\n<pre>\n-&gt; a\n    -&gt; b\n        -&gt; c\n        &lt;- c\n    &lt;- b\n&lt;- a\n</pre>\n</hr>", "LastEditorUserId": "464581", "LastActivityDate": "2013-12-31T02:55:42.157", "Score": "2", "CreationDate": "2013-12-31T01:07:41.250", "ParentId": "20850065", "CommentCount": "6", "OwnerUserId": "464581", "LastEditDate": "2013-12-31T02:55:42.157"}, "20850462": {"Id": "20850462", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_20850065_20850462_0\">I don't understand what this ostream function declaration means:</p>\n</blockquote>\n<pre><code>ostream&amp; operator&lt;&lt; (ostream&amp; (*pf)(ostream&amp;));\n</code></pre>\n<p>Have you seen functions like <code>std::endl</code>, <code>std::flush</code>, <code>std::hex</code>, <code>std::dec</code>, <code>std::setw</code>...?  They can all be \"sent\" to a stream using \"&lt;&lt;\", then they get called with the stream as a function argument and do their magic on the stream.  They actually match the <code>ostream&amp; (*pf)(ostream&amp;)</code> argument above, and that operator's the one that lets them be used.  If we look at the Visual C++ implementation...</p>\n<pre><code> _Myt&amp; operator&lt;&lt;(_Myt&amp; (__cdecl *_Pfn)(_Myt&amp;))\n {\n      return ((*_Pfn)(*this));\n }\n</code></pre>\n<p>...you can see if just calls the function, passing the stream it's used on as an argument.  The functions are expected to return a reference to the same stream argument, so that further <code>&lt;&lt;</code> operations may be chained, or the stream may be implicitly converted to <code>bool</code> as a test of stream state.</p>\n<p>See <a href=\"http://en.cppreference.com/w/cpp/io/manip\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/io/manip</a> for more information about io manipulators.</p>\n<p>You wanted help with:</p>\n<pre><code>void print(ostream&amp; os){\n    cout &lt;&lt; os;\n}\n</code></pre>\n<p>The issue here is that you're sending the <code>ostream</code> argument to another stream - <code>cout</code> - and it doesn't know what you want it to do with it.</p>\n<p>To send the current <em>content</em> of <code>os</code> to <code>cout</code>, try:</p>\n<pre><code>void print(ostream&amp; os){\n    cout &lt;&lt; os.rdbuf();\n}\n</code></pre>\n<p>Or if you want to print some actual data to the stream represented by the argument:</p>\n<pre><code>void print(ostream&amp; os){\n    os &lt;&lt; \"show this!\\n\";\n}\n\nprint(std::cout);   // to write \"show this!\\n\" to `std::cout`\nprint(std::cerr);   // to write \"show this!\\n\" to `std::cerr`\n</code></pre>\n", "LastEditorUserId": "410767", "LastActivityDate": "2014-01-01T07:17:03.987", "Score": "2", "CreationDate": "2013-12-31T01:44:02.400", "ParentId": "20850065", "CommentCount": "3", "OwnerUserId": "410767", "LastEditDate": "2014-01-01T07:17:03.987"}, "20850065": {"ViewCount": "812", "Body": "<p>I don't understand what this ostream function declaration means:</p>\n<pre><code>ostream&amp; operator&lt;&lt; (ostream&amp; (*pf)(ostream&amp;));\n</code></pre>\n<p>(specifically, the <code>(*pf)(ostream&amp;)</code> part). I want to do something like:</p>\n<pre><code>void print(ostream&amp; os){\n    cout &lt;&lt; os;\n}\n</code></pre>\n<p>but I get the error:</p>\n<pre><code> Invalid operands to binary expression ('ostream' . . . and 'ostream')\n</code></pre>\n", "AcceptedAnswerId": "20850462", "Title": "C++ - Send data in one ostream to another ostream", "CreationDate": "2013-12-31T00:57:29.073", "Id": "20850065", "CommentCount": "4", "LastEditDate": "2014-01-01T07:18:54.387", "PostTypeId": "1", "LastEditorUserId": "410767", "LastActivityDate": "2014-01-01T07:18:54.387", "Score": "1", "OwnerUserId": "1454316", "Tags": "<c++><iostream>", "AnswerCount": "3"}, "20850137": {"Id": "20850137", "PostTypeId": "2", "Body": "<p>The parameter portion of the declaration:</p>\n<pre><code>ostream&amp; operator&lt;&lt; (ostream&amp; (*pf)(ostream&amp;));\n</code></pre>\n<p>is a <em>function pointer</em> syntax.</p>\n<p>The expression:</p>\n<pre><code>ostream&amp; (*pf)(ostream&amp;)\n</code></pre>\n<p>Declares a pointer to a function, pf, that takes an <code>ostream&amp;</code> parameter and returns a reference to an <code>ostream</code>.</p>\n<p>If I declare a function:</p>\n<pre><code>ostream&amp; my_function(ostream&amp; output);\n</code></pre>\n<p>Then I can pass a pointer to the function as the parameter:</p>\n<pre><code>operator&lt;&lt; (my_function);\n</code></pre>\n<p>Read up on function pointer syntax.  Search the web and stackoverflow.  </p>\n", "LastActivityDate": "2013-12-31T01:07:14.833", "CommentCount": "0", "CreationDate": "2013-12-31T01:07:14.833", "ParentId": "20850065", "Score": "1", "OwnerUserId": "225074"}});