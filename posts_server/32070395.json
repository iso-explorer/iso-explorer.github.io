post_cb({"32071549": {"Id": "32071549", "PostTypeId": "2", "Body": "<p><strong>First answer</strong>: In your example you are trying to force compiler to do something which can be interpreted like this</p>\n<pre><code>const_cast&lt;int*&gt;(i1)=10; //int* = int: assign address to pointer\nconst_cast&lt;int*&gt;(*i1)=l; //const_cast&lt;int*&gt;(int): cast the value under pointer to pointer\n*i1=const_cast&lt;int&gt;(l); //const_casting from const values is forbidden\n*i1=const_cast&lt;int*&gt;(10); //10 is an rvalue\n</code></pre>\n<p>What you really want to do here is to dereference a pointer that is non-const anymore. That's why you need to do it like this:</p>\n<pre><code>int j = 9;\nint *k = &amp;j;\nconst int* i1 = 0;\ni1 = k;\n*(const_cast&lt;int*&gt;(i1)) = 10;\n</code></pre>\n<p>which is equivalent to</p>\n<pre><code>int j = 9;\nint *k = &amp;j;\nconst int* i1 = 0;\ni1 = k;\nint* temp = const_cast&lt;int*&gt;(i1); //you get rid of 'const'...\n*temp = 10; //...and now you assign value as you wanted to - this operation became available\n</code></pre>\n<hr>\n<p><strong>Second answer</strong>: It is forbidden to <code>const_cast</code> const values as it leads to undefined behavior. You are only allowed to remove constness from pointers or references that points to something that is not really <code>const</code> in the end and only the pointer disallows you to modify its value.</p>\n<p>This issue is awesomely described in <a href=\"https://stackoverflow.com/questions/19554841/how-to-use-const-cast\">this</a> answer.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-08-18T11:46:43.513", "Score": "2", "CreationDate": "2015-08-18T11:46:43.513", "ParentId": "32070395", "CommentCount": "1", "OwnerUserId": "1390260", "LastEditDate": "2017-05-23T12:08:28.667"}, "bq_ids": {"n4140": {"so_32070395_32071868_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 6051}, "so_32070395_32071868_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 5433}}, "n3337": {"so_32070395_32071868_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 5819}, "so_32070395_32071868_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 5228}}, "n4659": {"so_32070395_32071868_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 7550}, "so_32070395_32071868_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 6861}}}, "32071868": {"Id": "32071868", "PostTypeId": "2", "Body": "<p><code>const_cast</code> is applied to <em>expressions</em>, not objects, and itself is an <em>expression</em> as well:</p>\n<p>\u00a7 5.2.11 [expr.const.cast]/p1:</p>\n<blockquote>\n<p id=\"so_32070395_32071868_0\">The result of the expression <code>const_cast&lt;T&gt;(v)</code> is of type <code>T</code>. If <code>T</code> is an lvalue reference to object type, the\n  result is an lvalue; if <code>T</code> is an rvalue reference to object type, the result is an xvalue; otherwise, the result\n  is a prvalue and the lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard\n  conversions are performed on the expression <code>v</code></p>\n</blockquote>\n<ol>\n<li><code>const_cast&lt;int*&gt;(i)=m;</code></li>\n</ol>\n<p>This call is invalid, because the left side of the assignment has a <em>prvalue</em> value-category, and an <code>int*</code> prvalue doesn't support an assignment. The correct syntax would be <code>const_cast&lt;int*&amp;&gt;(i)=m;</code>, but since <code>i</code> in your example was declared <code>const</code>, it would invoke undefined behavior <sup>\u2020</sup>.</p>\n<ol start=\"2\">\n<li><code>const_cast&lt;int*&gt;(*i1)=l;</code></li>\n</ol>\n<p>Dereferencing a pointer of type <code>int*</code> creates an expression of an lvalue value-category, and because the cast expression is on the left side of the assignment, it should be a cast to an lvalue reference type, namely <code>const_cast&lt;int&amp;&gt;(*i1)=10;</code> (provided that whatever <code>i1</code> points to was not declared <code>const</code>).</p>\n<ol start=\"3\">\n<li><code>const_cast&lt;int&gt;(a)=b;</code></li>\n</ol>\n<p>The <code>const_cast&lt;int&gt;(a)</code> part itself is valid, in particular you can apply a const_cast to an expression representing an object which is not of a pointer type neither of a reference type. But since it's on the left side of the assigment it won't compile. And even if you change it to <code>const_cast&lt;int&amp;&gt;(a)=b;</code> it will trigger undefined behavior, because <code>a</code> is declared <code>const</code> <sup>\u2020</sup>.</p>\n<hr>\n<p><sup>\u2020</sup> \u00a7 7.1.6.1 [dcl.type.cv]/p4:</p>\n<blockquote>\n<p id=\"so_32070395_32071868_1\">Except that any class member declared mutable (7.1.1) can be modified, any attempt to modify a const\n  object during its lifetime (3.8) results in undefined behavior.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2015-08-18T12:01:18.247", "CommentCount": "0", "CreationDate": "2015-08-18T12:01:18.247", "ParentId": "32070395", "Score": "2", "OwnerUserId": "3953764"}, "32070395": {"ViewCount": "2564", "Body": "<p>No. This question in NOT duplicate of \n<a href=\"https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used\">When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?</a></p>\n<p>The question asked here is no ways similar to the link described as duplicate.</p>\n<p><strong>First question :</strong> \nI am using const_cast below for two cases. one of it works. the other doesn't.</p>\n<p><strong>1.</strong> <strong>int* const</strong>     //Works.</p>\n<p>In this syntax the address to which the variable would point to cannot be changed. So i used const_cast as below and it works:</p>\n<pre><code>`\nint j=3;\nint *k=&amp;j;\nint *m=&amp;j;\nint* const i=k; \nconst_cast&lt;int*&gt;(i)=m; //OK: since i=m would not work so cast is necessary`\n</code></pre>\n<p><strong>2.</strong> <strong>const int*</strong>  //Doesn't work.</p>\n<p>The address being pointed to can be changed however the value cannot be changed(though can be changed by making the variable point to different address). The const_cast i am using doesn't seem to work here:</p>\n<pre><code>`\nint j=9;\nint *k=&amp;j;\nconst int* i1=0;\ni1=k; //OK\n//*i1=10;//ERROR.`\n</code></pre>\n<p>So i tried to typecast as below through various ways but nothing works:</p>\n<pre><code>const_cast&lt;int*&gt;(i1)=10;\nconst_cast&lt;int*&gt;(*i1)=l;\n*i1=const_cast&lt;int&gt;(l);\n*i1=const_cast&lt;int*&gt;(10);\n</code></pre>\n<p><strong>Second question:</strong>\nAre all the casts available only for pointers and references?\nIs the following example not valid where no pointer or reference is in picture?</p>\n<pre><code>const int a=9;\nint b=4;\nconst_cast&lt;int&gt;(a)=b; //cannot convert from 'int' to 'int'. why is compiler\n                      //trying to convert from int to int anyways or fails         \n                      //when both the types are same.\n</code></pre>\n", "Title": "casting away the constness using const_cast", "CreationDate": "2015-08-18T10:52:35.723", "LastActivityDate": "2015-08-18T12:01:18.247", "CommentCount": "12", "LastEditDate": "2017-05-23T11:52:29.317", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "32070395", "Score": "2", "OwnerUserId": "3083195", "Tags": "<c++><const-char>", "AnswerCount": "2"}});