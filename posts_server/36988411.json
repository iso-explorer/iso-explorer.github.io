post_cb({"bq_ids": {"n4140": {"so_36988411_36988544_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 4114}}, "n3337": {"so_36988411_36988544_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 3957}}, "n4659": {"so_36988411_36988544_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 5379}}}, "36988626": {"Id": "36988626", "PostTypeId": "2", "Body": "<p>Take a look at the constructors of <code>std::bitset</code>. As you'll find out, it has no constructor accepting a signed integer. The only integral constructor is the one accepting an <code>unsigned long</code>.</p>\n<p>So, when you pass an integer, it is first converted to unsigned. What happens, is the converted value will be a positive value, same as the signed one modulo the maximum value of the unsigned type.</p>\n", "LastActivityDate": "2016-05-02T17:56:46.887", "CommentCount": "0", "CreationDate": "2016-05-02T17:56:46.887", "ParentId": "36988411", "Score": "0", "OwnerUserId": "2079303"}, "36988544": {"Id": "36988544", "PostTypeId": "2", "Body": "<p><code>bitset</code> doesn't handle signed-ness itself. The constructor you're calling takes an <code>unsigned</code> integer. From [bitset.cons]:</p>\n<blockquote>\n<pre><code>constexpr bitset(unsigned long long val) noexcept;\n</code></pre>\n<p id=\"so_36988411_36988544_0\"><em>Effects</em>: Constructs an object of class <code>bitset&lt;N&gt;</code>, initializing the first <code>M</code> bit positions to the corresponding\n  bit values in val. <code>M</code> is the smaller of <code>N</code> and the number of bits in the value representation (3.9) of\n  unsigned long long. If <code>M &lt; N</code>, the remaining bit positions are initialized to zero.</p>\n</blockquote>\n<p>So if you call it with <code>-5</code>, that gets converted to <code>unsigned long long</code> as <code>0xfffffffffffffffb</code>. The bottom 10 bits of that are <code>0x3fb</code>, which is the set you get. But it's unsigned. Both conversion functions give you back an unsigned value (from [bitset.members]):</p>\n<pre><code>unsigned long to_ulong() const;\nunsigned long long to_ullong() const;\n</code></pre>\n<p>All of which is to say - a <code>bitset</code> is a set of bits. It doesn't have a sign. The first bit isn't special - it's just another bit. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-05-02T17:54:23.367", "Score": "2", "CreationDate": "2016-05-02T17:51:51.180", "ParentId": "36988411", "CommentCount": "4", "OwnerUserId": "2069064", "LastEditDate": "2016-05-02T17:54:23.367"}, "36988411": {"ViewCount": "340", "Body": "<p>I am using <code>std::bitset</code> to convert a decimal value to its binary representation, but I am not sure if <code>bitset</code> handles signed values or not.</p>\n<p>For example, <code>bitset&lt;10&gt;(5)</code> gives you <code>0000000101</code>. But what if its <code>bitset&lt;10&gt;(-5)</code>?</p>\n<p>Here is my code in specific:</p>\n<pre><code>while (getline(ss, token, ',')){\n    ss.ignore();\n    myString.push_back(token);\n}\nmyString[0].erase(0, 1);\nmyString[1].erase(0, 1);\nrt = bitset&lt;7&gt;(stoi(myString[0])).to_string();\nra = bitset&lt;7&gt;(stoi(myString[1])).to_string();\ni10 = bitset&lt;10&gt;(stoi(myString[2])).to_string();\n</code></pre>\n<p>and the <code>i10</code> should be signed. Will my current code handle signed values? myString will hold the decimal representation that is input by a user, but i need to do some concatenating and writing to a file so im converting to strings for ease.</p>\n", "AcceptedAnswerId": "36988544", "Title": "Bitset and signed values", "CreationDate": "2016-05-02T17:44:26.453", "Id": "36988411", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-05-02T17:56:46.887", "Score": "1", "OwnerUserId": "4266707", "Tags": "<c++><binary><signed><bitset>", "AnswerCount": "3"}, "36988537": {"Id": "36988537", "PostTypeId": "2", "Body": "<p>Bitset will return the binary representation. Since negative numbers are stored using the two's complement, you will get their representation in the twos complement. For example:</p>\n<pre><code>cout &lt;&lt; bitset&lt;12&gt;(-5).to_string();\n// Prints 111111111011\n</code></pre>\n", "LastActivityDate": "2016-05-02T17:51:26.900", "CommentCount": "1", "CreationDate": "2016-05-02T17:51:26.900", "ParentId": "36988411", "Score": "1", "OwnerUserId": "1608816"}});