post_cb({"2749667": {"ParentId": "2749263", "CommentCount": "6", "Body": "<blockquote>\n<p id=\"so_2749263_2749667_0\">What about this code?</p>\n</blockquote>\n<pre><code>void f(std::string &amp;&amp;); //NB: No const string &amp; overload supplied\n\nvoid g2(const std::string &amp; arg)\n{\n    f(arg);\n}\n</code></pre>\n<blockquote>\n<p id=\"so_2749263_2749667_1\">...However, GCC and MSVC both reject g2 because of clause 13.3.3.1.4/3, which prohibits lvalues from binding to rvalue ref arguments. I understand the rationale behind this - it is explained in N2831 \"Fixing a safety problem with rvalue references\". I also think that GCC is probably implementing this clause as intended by the authors of that paper, because the original patch to GCC was written by one of the authors (Doug Gregor)....</p>\n</blockquote>\n<p>No, that's only half of the reason why both compilers reject your code. The other reason is that you can't initialize a reference to non-const with an expression referring to a const object. So, even before N2831 this didn't work. There is simply no need for a conversion because a string is a already a string. It seems you want to use <code>string&amp;&amp;</code> like <code>string</code>. Then, simply write your function <code>f</code> so that it takes a string by value. If you want the compiler to create a temporary copy of a const string lvalue just so you can invoke a function taking a <code>string&amp;&amp;</code>, there wouldn't be a difference between taking the string by value or by rref, would it?</p>\n<p>N2831 has little to do with this scenario.</p>\n<blockquote>\n<p id=\"so_2749263_2749667_2\">If you have a function that accepts a number of potentially-moveable arguments, and would move them if it can (e.g. a factory function/constructor: Object create_object(string, vector, string) or the like), and want to move or copy each argument as appropriate, you quickly start writing a lot of code.</p>\n</blockquote>\n<p>Not really. Why would you want to write a lot of code? There is little reason to clutter all your code with <code>const&amp;</code>/<code>&amp;&amp;</code> overloads. You can still use a single function with a mix of pass-by-value and pass-by-ref-to-const -- depending on what you want to do with the parameters. As for factories, the idea is to use perfect forwarding:</p>\n<pre><code>template&lt;class T, class... Args&gt;\nunique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args)\n{\n    T* ptr = new T(std::forward&lt;Args&gt;(args)...);\n    return unique_ptr&lt;T&gt;(ptr);\n}\n</code></pre>\n<p>...and all is well. A special template argument deduction rule helps differentiating between lvalue and rvalue arguments and std::forward allows you to create expressions with the same \"value-ness\" as the actual arguments had. So, if you write something like this:</p>\n<pre><code>string foo();\n\nint main() {\n   auto ups = make_unique&lt;string&gt;(foo());\n}\n</code></pre>\n<p>the string that foo returned is automatically moved to the heap.</p>\n<blockquote>\n<p id=\"so_2749263_2749667_3\">So if lvalues did bind to rvalues via an implicit copy, then you could write just one overload like create_object(legacy_string &amp;&amp;, legacy_vector &amp;&amp;, legacy_string &amp;&amp;) and it would more or less work like providing all the combinations of rvalue/lvalue reference overloads...</p>\n</blockquote>\n<p>Well, and it would be pretty much equivalent to a function taking the parameters by value. No kidding.</p>\n<blockquote>\n<p id=\"so_2749263_2749667_4\">Is this a significant enough improvement that it would be worth making e.g. an experimental patch for GCC?</p>\n</blockquote>\n<p>There's no improvement.</p>\n", "OwnerUserId": "172531", "PostTypeId": "2", "Id": "2749667", "Score": "4", "CreationDate": "2010-05-01T11:02:20.583", "LastActivityDate": "2010-05-01T11:02:20.583"}, "2749263": {"CommentCount": "1", "AcceptedAnswerId": "2749643", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-05-01T08:09:53.523", "LastActivityDate": "2011-10-02T10:45:41.510", "LastEditDate": "2017-05-23T11:48:25.527", "ViewCount": "4109", "FavoriteCount": "4", "Title": "C++0x rvalue references - lvalues-rvalue binding", "Id": "2749263", "Score": "16", "Body": "<p>This is a follow-on question to \n<a href=\"https://stackoverflow.com/questions/2748866/c0x-rvalue-references-and-temporaries\">C++0x rvalue references and temporaries</a></p>\n<p>In the previous question, I asked how this code should work:</p>\n<pre><code>void f(const std::string &amp;); //less efficient\nvoid f(std::string &amp;&amp;); //more efficient\n\nvoid g(const char * arg)\n{\n    f(arg);\n}\n</code></pre>\n<p>It seems that the move overload should probably be called because of the implicit temporary, and this happens in GCC but not MSVC (or the EDG front-end used in MSVC's Intellisense).</p>\n<p>What about this code?</p>\n<pre><code>void f(std::string &amp;&amp;); //NB: No const string &amp; overload supplied\n\nvoid g1(const char * arg)\n{\n     f(arg);\n}\nvoid g2(const std::string &amp; arg)\n{\n    f(arg);\n}\n</code></pre>\n<p>It seems that, based on the answers to my previous question that function <code>g1</code> is legal (and is accepted by GCC 4.3-4.5, but not by MSVC). However, GCC and MSVC both reject <code>g2</code> because of clause 13.3.3.1.4/3, which prohibits lvalues from binding to rvalue ref arguments. I understand the rationale behind this - it is explained in N2831 \"Fixing a safety problem with rvalue references\". I also think that GCC is probably implementing this clause as intended by the authors of that paper, because the original patch to GCC was written by one of the authors (Doug Gregor).</p>\n<p>However, I don't this is quite intuitive. To me, (a) a <code>const string &amp;</code> is conceptually closer to a <code>string &amp;&amp;</code> than a <code>const char *</code>, and (b) the compiler could create a temporary string in <code>g2</code>, as if it were written like this:</p>\n<pre><code>void g2(const std::string &amp; arg)\n{\n    f(std::string(arg));\n}\n</code></pre>\n<p>Indeed, sometimes the copy constructor is considered to be an implicit conversion operator. Syntactically, this is suggested by the form of a copy constructor, and the standard even mentions this specifically in clause 13.3.3.1.2/4, where the copy constructor for derived-base conversions is given a higher conversion rank than other user-defined conversions:</p>\n<blockquote>\n<p id=\"so_2749263_2749263_0\">A conversion of an expression of class type to the same class type is given Exact Match rank, and a conversion\n  of an expression of class type to a base class of that type is given Conversion rank, in spite of the fact that\n  a copy/move constructor (i.e., a user-defined conversion function) is called for those cases.</p>\n</blockquote>\n<p>(I assume this is used when passing a derived class to a function like <code>void h(Base)</code>, which takes a base class by value.)</p>\n<h2>Motivation</h2>\n<p>My motivation for asking this is something like the question asked in <a href=\"https://stackoverflow.com/questions/2696156/how-to-reduce-redundant-code-when-adding-new-c0x-rvalue-reference-operator-over\">How to reduce redundant code when adding new c++0x rvalue reference operator overloads</a> (\"How to reduce redundant code when adding new c++0x rvalue reference operator overloads\"). </p>\n<p>If you have a function that accepts a number of potentially-moveable arguments, and would move them if it can (e.g. a factory function/constructor: <code>Object create_object(string, vector&lt;string&gt;, string)</code> or the like), and want to move or copy each argument as appropriate, you quickly start writing a <em>lot</em> of code.</p>\n<p>If the argument types are movable, then one could just write one version that accepts the arguments by value, as above.  But if the arguments are (legacy) non-movable-but-swappable classes a la C++03, and you can't change them, then writing rvalue reference overloads is more efficient.</p>\n<p>So if lvalues did bind to rvalues via an implicit copy, then you could write just one overload like <code>create_object(legacy_string &amp;&amp;, legacy_vector&lt;legacy_string&gt; &amp;&amp;, legacy_string &amp;&amp;)</code> and it would more or less work like providing all the combinations of rvalue/lvalue reference overloads - actual arguments that were lvalues would get copied and then bound to the arguments, actual arguments that were rvalues would get directly bound.</p>\n<p><b>Clarification/edit:</b> I realize this is virtually identical to accepting arguments by value for movable types, like C++0x std::string and std::vector (save for the number of times the move constructor is conceptually invoked). However, it is not identical for copyable, but non-movable types, which includes all C++03 classes with explicitly-defined copy constructors. Consider this example:</p>\n<pre><code>class legacy_string { legacy_string(const legacy_string &amp;); }; //defined in a header somewhere; not modifiable.\n\nvoid f(legacy_string s1, legacy_string s2); //A *new* (C++0x) function that wants to move from its arguments where possible, and avoid copying\nvoid g() //A C++0x function as well\n{\n    legacy_string x(/*initialization*/);\n    legacy_string y(/*initialization*/);\n\n    f(std::move(x), std::move(y));\n}\n</code></pre>\n<p>If <code>g</code> calls <code>f</code>, then <code>x</code> and <code>y</code> would be copied - I don't see how the compiler can move them. If <code>f</code> were instead declared as taking <code>legacy_string &amp;&amp;</code> arguments, it could avoid those copies where the caller explicitly invoked <code>std::move</code> on the arguments. I don't see how these are equivalent.</p>\n<h2>Questions</h2>\n<p>My questions are then:</p>\n<ol>\n<li>Is this a valid interpretation of the standard? It seems that it's not the conventional or intended one, at any rate.</li>\n<li>Does it make intuitive sense?</li>\n<li>Is there a problem with this idea that I\"m not seeing? It seems like you could get copies being quietly created when that's not exactly expected, but that's the status quo in places in C++03 anyway. Also, it would make some overloads viable when they're currently not, but I don't see it being a problem in practice.</li>\n<li>Is this a significant enough improvement that it would be worth making e.g. an experimental patch for GCC?</li>\n</ol>\n", "Tags": "<c++><c++11><rvalue-reference><lvalue>", "OwnerUserId": "51305", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_2749263_2749263_0": {"section_id": 623, "quality": 0.967741935483871, "length": 30}}, "n3337": {"so_2749263_2749263_0": {"section_id": 613, "quality": 1.0, "length": 31}}, "n4659": {"so_2749263_2749263_0": {"section_id": 649, "quality": 0.967741935483871, "length": 30}}}, "2749643": {"ParentId": "2749263", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2010-05-01T10:54:04.027", "Score": "3", "LastEditorUserId": "34509", "LastEditDate": "2011-08-27T18:15:59.410", "Id": "2749643", "OwnerUserId": "34509", "Body": "<p>I don't quite see your point in this question. If you have a class that is movable, then you just need a <code>T</code> version:</p>\n<pre><code>struct A {\n  T t;\n  A(T t):t(move(t)) { }\n};\n</code></pre>\n<p>And if the class is traditional but has an efficient <code>swap</code> you can write the swap version or you can fallback to the <code>const T&amp;</code> way</p>\n<pre><code>struct A {\n  T t;\n  A(T t) { swap(this-&gt;t, t); }\n};\n</code></pre>\n<p>Regarding the swap version, I would rather go with the <code>const T&amp;</code> way instead of that swap. The main advantage of the swap technique is exception safety and is to move the copy closer to the caller so that it can optimize away copies of temporaries. But what do you have to <em>save</em> if you are just constructing the object anyway? And if the constructor is small, the compiler can look into it and can optimize away copies too. </p>\n<pre><code>struct A {\n  T t;\n  A(T const&amp; t):t(t) { }\n};\n</code></pre>\n<p>To me, it doesn't seem right to automatically convert a string lvalue to a rvalue copy of itself just to bind to a rvalue reference. An rvalue reference says it binds to rvalue. But if you try binding to an lvalue of the same type it better fails. Introducing hidden copies to allow that doesn't sound right to me, because when people see a <code>X&amp;&amp;</code> and you pass a <code>X</code> lvalue, I bet most will expect that there is no copy, and that binding is directly, if it works at all. Better fail out straight away so the user can fix his/her code. </p>\n", "LastActivityDate": "2011-08-27T18:15:59.410"}});