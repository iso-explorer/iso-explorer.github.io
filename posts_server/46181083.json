post_cb({"bq_ids": {"n4140": {"so_46181083_46181498_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 444}, "so_46181083_46181083_1": {"length": 12, "quality": 0.7058823529411765, "section_id": 7193}}, "n3337": {"so_46181083_46181498_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 435}, "so_46181083_46181083_1": {"length": 12, "quality": 0.7058823529411765, "section_id": 6937}}, "n4659": {"so_46181083_46181498_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 467}, "so_46181083_46181083_1": {"length": 12, "quality": 0.7058823529411765, "section_id": 8702}}}, "46181083": {"ViewCount": "206", "Body": "<p>Suppose I have a class that may run some code asynchronously, and that asynchronous code uses that class instance to do things like call member functions, read data members, etc.  Obviously the class instance must outlive the background thread in order for those accesses to be safe.  It is sufficient to ensure this by joining the background thread in the destructor?  For example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;thread&gt;\n\nclass foo final\n{\npublic:\n    foo() = default;\n\n    void bar() {\n        std::cout &lt;&lt; \"Hopefully there's nothing wrong with using \" &lt;&lt; this &lt;&lt; \"\\n\";\n    }\n\n    void bar_async() {\n        if (!m_thread.joinable()) {\n            m_thread = std::thread{&amp;foo::bar, this};\n        }\n    }\n\n    ~foo() {\n        if (m_thread.joinable()) {\n            std::cout &lt;&lt; \"Waiting for \" &lt;&lt; m_thread.get_id() &lt;&lt; \"\\n\";\n            m_thread.join();\n        }\n    }\n\nprivate:\n    std::thread m_thread;\n};\n\nint main() {\n    foo f;\n    f.bar_async();\n}\n</code></pre>\n<p>Specifically, I'm worried about <a href=\"http://en.cppreference.com/w/cpp/language/lifetime\" rel=\"noreferrer\">object lifetime rules</a>:</p>\n<blockquote>\n<p id=\"so_46181083_46181083_0\">For any object of class types whose destructor is not trivial, lifetime ends when the execution of the destructor begins.</p>\n<p id=\"so_46181083_46181083_1\">... after the lifetime of an object has ended and before the storage which the object occupied is reused or released, the following uses of the glvalue expression that identifies that object are undefined: ...</p>\n<ul>\n<li>Access to a non-static data member or a call to a non-static member function.</li>\n</ul>\n</blockquote>\n<p>But to me, a strict reading of the above would also imply that calling <code>this-&gt;bar()</code> from inside <code>~foo()</code> directly is undefined, which is \"obviously\" not the case.</p>\n", "AcceptedAnswerId": "46181498", "Title": "Is it safe to wait for asynchronous work by joining in the destructor?", "CreationDate": "2017-09-12T16:07:45.477", "Id": "46181083", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2017-09-12T16:30:42.790", "Score": "6", "OwnerUserId": "502399", "Tags": "<c++><multithreading><c++11><thread-safety><object-lifetime>", "AnswerCount": "2"}, "46181297": {"Id": "46181297", "PostTypeId": "2", "Body": "<p>My intuition is no. This is because thread::join can throw an exception and you don't want exceptions escaping your destructor. It may be okay if you wrap it in a try catch and handle the exception properly though.</p>\n", "LastActivityDate": "2017-09-12T16:19:35.473", "CommentCount": "2", "CreationDate": "2017-09-12T16:19:35.473", "ParentId": "46181083", "Score": "0", "OwnerUserId": "2339855"}, "46181498": {"Id": "46181498", "PostTypeId": "2", "Body": "<p>cppreference is right but it is talking about accessing the members from the object, not from inside the destructor. If we look at [class.cdtor]/1 we see that</p>\n<blockquote>\n<p id=\"so_46181083_46181498_0\">For an object with a non-trivial constructor, referring to any non-static member or base class of the object before the constructor begins execution results in undefined behavior. For an object with a non-trivial destructor, <strong>referring to any non-static member or base class of the object after the destructor finishes execution results in undefined behavior</strong>.</p>\n</blockquote>\n<p><sup>emphasis mine</sup></p>\n<p>So, as long as we are in the destructor we can still work with the member objects as those are not destroyed until the scope of the destructor ends.</p>\n<p>So, calling <code>join</code> on the thread is fine here.  If you think about it if it wasn't then things like lock guards would be useless if accessing the mutex they refer to was undefined behavior.</p>\n", "LastActivityDate": "2017-09-12T16:30:42.790", "CommentCount": "5", "CreationDate": "2017-09-12T16:30:42.790", "ParentId": "46181083", "Score": "3", "OwnerUserId": "4342498"}});