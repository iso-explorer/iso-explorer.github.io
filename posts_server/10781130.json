post_cb({"10781727": {"ParentId": "10781130", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_10781130_10781727_0\"><strong>In C++, if a class has a reference data member the default assignment operator is not synthesized by compiler. Why?</strong> </p>\n</blockquote>\n<p>What an copy assignment should do is defined in:</p>\n<p><strong>C++03 Standard 12.8/13:</strong></p>\n<blockquote>\n<p id=\"so_10781130_10781727_1\">Each subobject is assigned in the manner appropriate to its type:</p>\n<ul>\n<li><p id=\"so_10781130_10781727_2\">if the subobject is of class type, the copy assignment operator for the class is used (as if by explicit qualification; that is, ignoring any possible virtual overriding functions in more derived classes); </p></li>\n<li><p id=\"so_10781130_10781727_3\">if the subobject is an array, each element is assigned, in the manner appropriate to the element type;</p></li>\n<li><p id=\"so_10781130_10781727_4\">if the subobject is of scalar type, the built-in assignment operator is used. </p></li>\n</ul>\n</blockquote>\n<p>In short It implies that <strong><em>each of the member should assigned in an appropriate manner</em></strong><br>\nwhich raises the question,<br>\n<strong><em>What should be the behavior for assignment of a reference member in class?</em></strong><br>\nConsider the following about references:       </br></br></br></p>\n<ol>\n<li>References are inherently non assignable, they keep referring the same referrant to which they were initialized<sup>[Ref 1]</sup>.</li>\n<li>By virtue of <code>#1</code> assigning to an reference doesn't reassign the reference, it changes the value of the referrant which is non-intuitive behavior.      </li>\n</ol>\n<p>There is no default correct behavior to be enforced here but a rather situational one.So the C++ Standard mandates that designer of the class is in best position to determine this behavior and hence the decision that default assignment operator should not be synthesized by compiler if a class has a reference data member.</p>\n<p>This decision is specified in:<br>\n<strong>C++03 Standard 12.8/12:</strong> </br></p>\n<blockquote>\n<p id=\"so_10781130_10781727_5\">An implicitly-declared copy assignment operator is implicitly defined when an object of its class type is assigned a value of its class type or a value of a class type derived from its class type. A program is ill formed if the class for which a copy assignment operator is implicitly defined has:<br>\n   .......<br>\n   \u2014 a nonstatic data member of reference type, or<br>\n   .......</br></br></br></p>\n</blockquote>\n<hr>\n<p><sup>[Ref 1]</sup><br>\n<strong>C++03 Standard 8.5.3/2:</strong> </br></p>\n<blockquote>\n<p id=\"so_10781130_10781727_6\"><strong>A reference cannot be changed to refer to another object after initialization</strong>. Note that initialization of a reference is treated very differently from assignment to it. Argument passing (5.2.2) and function value return (6.6.3) are initializations.</p>\n</blockquote>\n</hr>", "OwnerUserId": "452307", "LastEditorUserId": "452307", "LastEditDate": "2012-05-28T09:26:58.107", "Id": "10781727", "Score": "6", "CreationDate": "2012-05-28T08:43:49.563", "LastActivityDate": "2012-05-28T09:26:58.107"}, "10781145": {"ParentId": "10781130", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Saw the discussion on a member-only forum. Since the answer is not well-known to most programmers, would like to post the answer and share it here. </p>\n<p>From C++ standard draft N3337 \u00a712.8.23:</p>\n<blockquote>\n<p id=\"so_10781130_10781145_0\">A defaulted copy/move assignment operator for class X is defined as deleted if X has:</p>\n<ul>\n<li>a variant member with a non-trivial corresponding assignment operator and X is a \n  union-like class, or</li>\n<li>a non-static data member of const non-class type (or array thereof), or</li>\n<li>a non-static data member of reference type, or</li>\n<li>a non-static data member of class type M (or array thereof) that cannot be \n  copied/moved because overload resolution (13.3), as applied to M\u2019s corresponding \n  assignment operator, results in an ambiguity or a function that is deleted or \n  inaccessible from the defaulted assignment operator, or</li>\n<li>a direct or virtual base class B that cannot be copied/moved because overload \n  resolution (13.3), as applied to B\u2019s corresponding assignment operator, results in \n  an ambiguity or a function that is deleted or inaccessible from the defaulted \n  assignment operator, or</li>\n<li>for the move assignment operator, a non-static data member or direct base class \n  with a type that does not have a move assignment operator and is not trivially \n  copyable, or any direct or indirect virtual base class. </li>\n</ul>\n</blockquote>\n", "OwnerUserId": "362754", "LastEditorUserId": "635608", "LastEditDate": "2012-05-28T07:55:52.313", "Id": "10781145", "Score": "3", "CreationDate": "2012-05-28T07:53:29.933", "LastActivityDate": "2012-05-28T07:55:52.313"}, "bq_ids": {"n4140": {"so_10781130_10781727_4": {"section_id": 477, "quality": 1.0, "length": 6}, "so_10781130_10781727_3": {"section_id": 477, "quality": 1.0, "length": 9}, "so_10781130_10781727_6": {"section_id": 3318, "quality": 0.9130434782608695, "length": 21}, "so_10781130_10781727_1": {"section_id": 477, "quality": 1.0, "length": 7}, "so_10781130_10781727_0": {"section_id": 5914, "quality": 0.6, "length": 6}, "so_10781130_10781145_0": {"section_id": 472, "quality": 1.0, "length": 7}, "so_10781130_10781727_2": {"section_id": 477, "quality": 0.8235294117647058, "length": 14}}, "n3337": {"so_10781130_10781727_4": {"section_id": 468, "quality": 1.0, "length": 6}, "so_10781130_10781727_3": {"section_id": 468, "quality": 1.0, "length": 9}, "so_10781130_10781727_6": {"section_id": 3188, "quality": 0.9130434782608695, "length": 21}, "so_10781130_10781727_1": {"section_id": 468, "quality": 1.0, "length": 7}, "so_10781130_10781727_0": {"section_id": 463, "quality": 0.6, "length": 6}, "so_10781130_10781145_0": {"section_id": 463, "quality": 1.0, "length": 7}, "so_10781130_10781727_2": {"section_id": 468, "quality": 0.8235294117647058, "length": 14}}, "n4659": {"so_10781130_10781727_4": {"section_id": 500, "quality": 1.0, "length": 6}, "so_10781130_10781727_3": {"section_id": 500, "quality": 1.0, "length": 9}, "so_10781130_10781727_6": {"section_id": 4084, "quality": 0.6521739130434783, "length": 15}, "so_10781130_10781727_1": {"section_id": 500, "quality": 1.0, "length": 7}, "so_10781130_10781727_0": {"section_id": 495, "quality": 0.6, "length": 6}, "so_10781130_10781145_0": {"section_id": 495, "quality": 1.0, "length": 7}, "so_10781130_10781727_2": {"section_id": 500, "quality": 0.8235294117647058, "length": 14}}}, "10781130": {"CommentCount": "2", "AcceptedAnswerId": "10781727", "CreationDate": "2012-05-28T07:51:58.700", "LastActivityDate": "2012-05-28T09:26:58.107", "PostTypeId": "1", "ViewCount": "1075", "FavoriteCount": "1", "Title": "Why a default assignment operator not synthesis by compiler if a class has a reference data member", "Id": "10781130", "Score": "5", "Body": "<p>In C++, if a class has a reference data member the default assignment operator is not synthesized by compiler. Why? </p>\n", "Tags": "<c++>", "OwnerUserId": "362754", "AnswerCount": "2"}});