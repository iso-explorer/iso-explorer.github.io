post_cb({"bq_ids": {"n4140": {"so_12919474_12919474_2": {"length": 13, "quality": 0.6190476190476191, "section_id": 6857}, "so_12919474_12919474_3": {"length": 4, "quality": 1.0, "section_id": 652}, "so_12919474_12919474_1": {"length": 17, "quality": 0.7727272727272727, "section_id": 6857}}, "n3337": {"so_12919474_12919474_2": {"length": 13, "quality": 0.6190476190476191, "section_id": 6603}, "so_12919474_12919474_3": {"length": 4, "quality": 1.0, "section_id": 642}, "so_12919474_12919474_1": {"length": 17, "quality": 0.7727272727272727, "section_id": 6603}}, "n4659": {"so_12919474_12919474_2": {"length": 13, "quality": 0.6190476190476191, "section_id": 8349}, "so_12919474_12919474_1": {"length": 17, "quality": 0.7727272727272727, "section_id": 8349}, "so_12919474_12919474_3": {"length": 4, "quality": 1.0, "section_id": 680}}}, "12919474": {"ViewCount": "722", "Body": "<p>We know from c++ 11(also true in c++98/03 standard) standard(see below), we cannot try to replace the operator new function - placement form in global space as it has already been defined.</p>\n<blockquote>\n<p id=\"so_12919474_12919474_0\"><strong>18.6.1.3 Placement forms [new.delete.placement]</strong> </p>\n<p id=\"so_12919474_12919474_1\">These functions are reserved, a C++ program may not define functions that displace the\n  versions in the Standard C++ library (17.6.4). The provisions of\n  (3.7.4) do not apply to these reserved placement forms of operator new\n  and operator delete.</p>\n</blockquote>\n<p>This has been proven by point 2&gt; in the snippet below, compile error as expected.</p>\n<p>But I can still override the placement new in class level,that works fine, see point (2) in snippet below. Why is that? Shouldn't compile should try to prevent (2) as well according to standard ???</p>\n<p>See my snippet below:</p>\n<pre><code>class Test\n{\npublic:\n    Test(int i):m_i(i) { cout &lt;&lt; \"Test::Test()\" &lt;&lt; endl; }\n    ~Test() { cout &lt;&lt; \"Test::~Test()\" &lt;&lt; endl; }\n\n    //(1)class level override placement new\n    void* operator new (std::size_t size) throw (std::bad_alloc) {\n        cout &lt;&lt; \"My class level new\" &lt;&lt; endl;\n        return malloc(size);\n    }\n\n    //(2)class level override placement new\n    void* operator new (std::size_t size, void* ptr) throw() {\n        cout &lt;&lt; \"My class level non-throwing placement new\" &lt;&lt; endl;\n        return ptr;\n    }\nprivate:\n    int m_i;\n\n};\n\n//&lt;1&gt;global replacement for operator new - single object form\nvoid* operator new (std::size_t size) throw (std::bad_alloc) {\n    cout &lt;&lt; \"My global new\" &lt;&lt; endl;\n    return malloc(size);\n}\n\n\n//&lt;2&gt;global replacement for operator new - replcement  form\n//NB. This is a attempt that definitely fails according to c++ stadnard:\n//does get compile error: error: redefinition of 'void* operator new(std::size_t, void*)'\n/*\nvoid* operator new (std::size_t size, void* ptr) throw() {\n    cout &lt;&lt; \"My global non-throwing placement new\" &lt;&lt; endl;\n    return ptr;\n}\n*/\n\nint main() {\n    Test* p = new Test(1);\n    delete p;\n\n    cout &lt;&lt; \"\" &lt;&lt; endl;\n    void* mem = operator new(sizeof(Test));\n    Test* p2 = new(mem) Test(1);\n    p2-&gt;~Test();\n    operator delete (mem);\n\n    return 0;\n}\n</code></pre>\n<p>Below is output as expected:</p>\n<pre><code>My class level new\nMy global new\nTest::Test()\nTest::~Test()\n\nMy global new\nMy class level non-throwing placement new\nTest::Test()\nTest::~Test()\n</code></pre>\n<p>==================================================================================\n<strong>Further clarification for my question:</strong></p>\n<blockquote>\n<p id=\"so_12919474_12919474_2\"><strong>18.6.1.3 Placement forms</strong> These functions are reserved, a C++ program may not define functions that displace the versions in the\n  <strong>Standard</strong> C++ library (17.6.4). The provisions of (3.7.4) do not apply to these reserved placement forms</p>\n<p id=\"so_12919474_12919474_3\">of operator new and operator delete.</p>\n</blockquote>\n<p>This explains the expected compile error at point &lt;2&gt; in my snippet, so this one is ok.</p>\n<p>But why I can displace the placement forms in the class level at point (2) inside the class clarification?</p>\n", "AcceptedAnswerId": "12937428", "Title": "Why operator new function - placement form ok in class level?", "CreationDate": "2012-10-16T16:40:21.337", "Id": "12919474", "CommentCount": "0", "LastEditDate": "2012-10-18T10:35:49.803", "PostTypeId": "1", "LastEditorUserId": "833538", "LastActivityDate": "2012-10-18T10:35:49.803", "Score": "3", "OwnerUserId": "833538", "Tags": "<c++><placement-new>", "AnswerCount": "1"}, "12937428": {"Id": "12937428", "PostTypeId": "2", "Body": "<p>\u00a718.6.1.3 lists the following forms:</p>\n<pre><code>void* operator new(std::size_t size, void* ptr) noexcept;\nvoid* operator new[](std::size_t size, void* ptr) noexcept;\nvoid operator delete(void* ptr, void*) noexcept;\nvoid operator delete[](void* ptr, void*) noexcept;\n</code></pre>\n<p>The rule that \"a C++ program may not define functions that displace the versions in the Standard C++ library\" applies only to these four function declarations, which are not in any namespace. If you make your own version in a class or a namespace, that's fine.</p>\n<p>In fact, sometimes you <em>have</em> to provide your own placement new. If you declare a normal <code>operator new</code> in your class, it will hide the placement new provided by the standard library, and you'll need to add your own placement new in the class if you ever want to use the <code>new (ptr) T(...)</code> syntax.</p>\n<p>This simply provides a guarantee that the call <code>::new (ptr) T(...)</code> is <em>guaranteed</em> to behave like the standard placement new. (Note the <code>::</code> prefix.)</p>\n", "LastActivityDate": "2012-10-17T15:06:59.993", "CommentCount": "8", "CreationDate": "2012-10-17T15:06:59.993", "ParentId": "12919474", "Score": "2", "OwnerUserId": "5696"}});