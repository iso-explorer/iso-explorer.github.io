post_cb({"31543319": {"Id": "31543319", "PostTypeId": "2", "Body": "<p>Your code is correct; out-of-class implicitly instantiated class template member class template partial specializations are intended to be allowed by the Standard, as long as they are defined early enough.</p>\n<p>First, let's try for a minimal example - noting by the way that there's nothing here that requires C++11:</p>\n<pre><code>template&lt;class T&gt; struct A {\n  template&lt;class T2&gt; struct B { };\n};\n// implicitly instantiated class template member class template partial specialization\ntemplate&lt;&gt; template&lt;class T2&gt;\n  struct A&lt;short&gt;::B&lt;T2*&gt; { };\nA&lt;short&gt;::B&lt;int*&gt; absip;    // uses partial specialization?\n</code></pre>\n<p>As noted elsewhere MSVC and ICC use the partial specialization as expected; clang selects the partial specialization but messes up its type parameters, aliasing <code>T2</code> to <code>short</code> instead of <code>int</code>; and gcc ignores the partial specialization entirely.</p>\n<h3>Why out-of-class implicitly instantiated class template member class template partial specialization is allowed</h3>\n<p>Put simply, none of the language that permits other forms of class template member class template definitions excludes out-of-class implicitly instantiated class template member class template partial specialization. In <strong>[temp.mem]</strong>, we have:</p>\n<blockquote>\n<p id=\"so_31393530_31543319_0\">1 - A template can be declared within a class or class template; such a template is called a member template. A\n  member template can be defined within or outside its class definition or class template definition. [...]</p>\n</blockquote>\n<p>A class template partial specialization is a template declaration (<strong>[temp.class.spec]</strong>/1). In the same paragraph, there is an example of out-of-class nonspecialized class template member class template partial specialization (<strong>[temp.class.spec]</strong>/5):</p>\n<pre><code>template&lt;class T&gt; struct A {\n  struct C {\n    template&lt;class T2&gt; struct B { };\n  };\n};\n// partial specialization of A&lt;T&gt;::C::B&lt;T2&gt;\ntemplate&lt;class T&gt; template&lt;class T2&gt;\n  struct A&lt;T&gt;::C::B&lt;T2*&gt; { };\nA&lt;short&gt;::C::B&lt;int*&gt; absip; // uses partial specialization\n</code></pre>\n<p>There is nothing here to indicate that the enclosing scope cannot be an implicit specialization of the enclosing class template.</p>\n<p>Similarly, there are examples of in-class class template member class template partial specialization and out-of-class implicitly instantiated class template member class template full specialization (<strong>[temp.class.spec.mfunc]</strong>/2):</p>\n<pre><code>template&lt;class T&gt; struct A {\n  template&lt;class T2&gt; struct B {}; // #1\n  template&lt;class T2&gt; struct B&lt;T2*&gt; {}; // #2\n};\ntemplate&lt;&gt; template&lt;class T2&gt; struct A&lt;short&gt;::B {}; // #3\nA&lt;char&gt;::B&lt;int*&gt; abcip; // uses #2\nA&lt;short&gt;::B&lt;int*&gt; absip; // uses #3\nA&lt;char&gt;::B&lt;int&gt; abci; // uses #1\n</code></pre>\n<p>(clang (as of 3.7.0-svn235195) gets the second example wrong; it selects #2 instead of #3 for <code>absip</code>.)</p>\n<p>While this does not explicitly mention out-of-class implicitly instantiated class template member class template partial specialization, it does not exclude it either; the reason it isn't here is that it's irrelevant for the particular point being made, which is about <em>which</em> primary template or partial template specializations are considered for a particular specialization.</p>\n<p>Per <strong>[temp.class.spec]</strong>:</p>\n<blockquote>\n<p id=\"so_31393530_31543319_1\">6 - [...] when the primary\n  template name is used, any previously-declared partial specializations of the primary template are also\n  considered.</p>\n</blockquote>\n<p>In the above minimal example, <code>A&lt;short&gt;::B&lt;T2*&gt;</code> is a partial specialization of the primary template <code>A&lt;short&gt;::B</code> and so should be considered.</p>\n<h3>Why it might not be allowed</h3>\n<p>In other discussion we've seen mention that implicit instantiation (of the enclosing class template) could result in implicit instantiation of the definition of the primary template specialization to take place, resulting in an ill-formed program NDR i.e. UB; <strong>[templ.expl.spec]</strong>:</p>\n<blockquote>\n<p id=\"so_31393530_31543319_2\">6 - If a template, a member template or a member of a class template is explicitly specialized then that specialization\n  shall be declared before the first use of that specialization that would cause an implicit instantiation\n  to take place, in every translation unit in which such a use occurs; no diagnostic is required. [...]</p>\n</blockquote>\n<p>However, here the class template member class template is not used before it is instantiated.</p>\n<h3>What other people think</h3>\n<p>In <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1755\">DR1755 (active)</a>, the example given is:</p>\n<pre><code>template&lt;typename A&gt; struct X { template&lt;typename B&gt; struct Y; };\ntemplate struct X&lt;int&gt;;\ntemplate&lt;typename A&gt; template&lt;typename B&gt; struct X&lt;A&gt;::Y&lt;B*&gt; { int n; };\nint k = X&lt;int&gt;::Y&lt;int*&gt;().n;\n</code></pre>\n<p>This is considered problematic only from the point of view of the existence of the second line instantiating the enclosing class. There was no suggestion from the submitter (Richard Smith) or from CWG that this might be invalid even in the absence of the second line.</p>\n<p>In <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4090.pdf\">n4090</a>, the example given is:</p>\n<pre><code>template&lt;class T&gt; struct A {\n  template&lt;class U&gt; struct B {int i; }; // #0\n  template&lt;&gt; struct B&lt;float**&gt; {int i2; }; // #1\n  // ...\n};\n// ...\ntemplate&lt;&gt; template&lt;class U&gt; // #6\nstruct A&lt;char&gt;::B&lt;U*&gt;{ int m; };\n// ...\nint a2 = A&lt;char&gt;::B&lt;float**&gt;{}.m; // Use #6 Not #1\n</code></pre>\n<p>Here the question raised is of precedence between an in-class class template member class template full specialization and an out-of-class class template instantiation member class template partial specialization; there is no suggestion that <code>#6</code> would not be considered at all.</p>\n", "LastActivityDate": "2015-07-21T15:25:11.357", "Score": "8", "CreationDate": "2015-07-21T15:25:11.357", "ParentId": "31393530", "CommentCount": "4", "OwnerUserId": "567292"}, "bq_ids": {"n4140": {"so_31393530_31543319_2": {"length": 29, "quality": 1.0, "section_id": 268}, "so_31393530_31543319_1": {"length": 10, "quality": 1.0, "section_id": 140}, "so_31393530_31543319_0": {"length": 24, "quality": 1.0, "section_id": 110}}, "n3337": {"so_31393530_31543319_2": {"length": 29, "quality": 1.0, "section_id": 259}, "so_31393530_31543319_1": {"length": 10, "quality": 1.0, "section_id": 134}, "so_31393530_31543319_0": {"length": 24, "quality": 1.0, "section_id": 105}}, "n4659": {"so_31393530_31543319_2": {"length": 29, "quality": 1.0, "section_id": 275}, "so_31393530_31543319_1": {"length": 10, "quality": 1.0, "section_id": 144}, "so_31393530_31543319_0": {"length": 24, "quality": 1.0, "section_id": 114}}}, "31393530": {"ViewCount": "794", "Body": "<p>While writing a small template metaprogramming library for personal use, I came across an interesting problem. </p>\n<p>Since I was reusing a few partial specializations for some metafunctions, I decided I would put them under a common template class and use tags along with nested partial specialization to provide the differences in behaviour. </p>\n<p>The problem is I am getting nonsensical (to me) results. Here is a minimal example that showcases what I am trying to do:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cxxabi.h&gt;\n#include &lt;typeinfo&gt;\n\ntemplate &lt;typename T&gt;\nconst char * type_name()\n{\n    return abi::__cxa_demangle(typeid(T).name(), nullptr, nullptr, nullptr);\n}\n\ntemplate &lt;typename... Args&gt;\nstruct vargs {};\n\nnamespace details   \n{\n    template &lt;typename K&gt;\n    struct outer\n    {\n        template &lt;typename Arg&gt;\n        struct inner\n        {\n            using result = Arg;\n        };\n    };\n}\n\nstruct tag {};\n\nnamespace details\n{\n    template &lt;&gt;\n    template &lt;typename Arg, typename... Args&gt;\n    struct outer&lt;tag&gt;::inner&lt;vargs&lt;Arg, Args...&gt;&gt;\n    {\n        using result = typename outer&lt;tag&gt;::inner&lt;Arg&gt;::result;\n    };\n}\n\ntemplate &lt;typename T&gt;\nusing test_t = typename details::outer&lt;tag&gt;::inner&lt;T&gt;::result;\n\nint main()\n{\n    using t = test_t&lt;vargs&lt;char, int&gt;&gt;;\n    std::cout &lt;&lt; type_name&lt;t&gt;() &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>\n<p>I am getting <code>vargs&lt;char, int&gt;</code> as output when using the 5.1.0 version of gcc and <code>tag</code> when using the 3.6.0 version of clang. My intention was for the above piece of code to print <code>char</code> so I am pretty baffled by these results.</p>\n<p>Is the above piece of code legal or does it exhibit undefined behavior?\nIf it's legal what is the expected behavior according to the standard?</p>\n", "AcceptedAnswerId": "31543319", "Title": "Weird nested class partial specialization results on both gcc and clang", "CreationDate": "2015-07-13T21:08:38.097", "Id": "31393530", "CommentCount": "10", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2015-07-21T09:21:51.307", "LastEditorUserId": "3024983", "LastActivityDate": "2015-07-21T15:25:11.357", "Score": "24", "OwnerUserId": "3024983", "Tags": "<c++><templates><c++11><language-lawyer><template-meta-programming>", "AnswerCount": "1"}});