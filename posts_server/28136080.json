post_cb({"bq_ids": {"n4140": {"so_28136080_28139567_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 822}, "so_28136080_28136248_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 822}, "so_28136080_28139567_2": {"length": 22, "quality": 0.9166666666666666, "section_id": 989}}, "n3337": {"so_28136080_28139567_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 811}, "so_28136080_28136248_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 811}, "so_28136080_28139567_2": {"length": 22, "quality": 0.9166666666666666, "section_id": 974}}, "n4659": {"so_28136080_28139567_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 881}, "so_28136080_28136248_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 881}, "so_28136080_28139567_2": {"length": 21, "quality": 0.875, "section_id": 1052}}}, "28139567": {"Id": "28139567", "PostTypeId": "2", "Body": "<p>Table 100 -- Sequence container requirements in section 23.2.3 [sequence.reqmts] says:</p>\n<pre><code>a.erase(q)\n</code></pre>\n<blockquote>\n<p id=\"so_28136080_28139567_0\"><em>Requires:</em> For <code>vector</code> and <code>deque</code>, <code>T</code> shall be <code>MoveAssignable</code>.</p>\n</blockquote>\n<p>This means that the implementation can call no operations on <code>T</code> except to destruct it or move assign it.  Note that if the implementation move assigns <code>T</code> that doesn't guarantee that a move assignment operator will be called.  For example <code>T</code> may not have a move assignment operator, and so in that case a copy assignment operator could be called.  However the implementation is not allowed to copy assign the <code>T</code>, only move assign it.</p>\n<pre><code>*i = std::move(*j);  // implementation can do this\n*i = *j;             // implementation can not do this\n</code></pre>\n<p>Furthermore 23.3.6.5 vector modifiers [vector.modifiers] says the following:</p>\n<pre><code>iterator erase(const_iterator position);\niterator erase(const_iterator first, const_iterator last);\n</code></pre>\n<blockquote>\n<p id=\"so_28136080_28139567_1\"><em>Throws:</em> Nothing unless an exception is thrown by the copy constructor, move constructor, assignment operator, or move assignment\n  operator of <code>T</code>.</p>\n</blockquote>\n<p>I must admit I sighed when I read this.  There is clearly a minor defect here.  This operation is not allowed to form any expressions that would directly construct a <code>T</code>.  Perhaps one is constructed as an implementation detail inside an assignment operator of <code>T</code>, but that is of no concern to this specification.  The concern is does this expression throw or not:</p>\n<pre><code>*i = std::move(*j);  // implementation can do this. Will it throw?\n</code></pre>\n<p>If that expression (where <code>i</code> and <code>j</code> are iterators referring to a <code>T</code>) does not throw, then <code>vector::erase</code> has the no-throw guarantee.  Otherwise <code>vector::erase</code> has the basic exception safety guarantee.</p>\n<p>Note that for this operation, the implementation is not allowed to fall back to copy assignment if <code>is_nothrow_move_assignable&lt;T&gt;::value</code> is false.  Such logic is present in other <code>vector</code> operations such as <code>push_back</code>, but not here.</p>\n<p>Also note the Complexity specification of this same section:</p>\n<blockquote>\n<p id=\"so_28136080_28139567_2\"><em>Complexity:</em> The destructor of <code>T</code> is called the number of times equal to the number of the elements erased, but the move assignment\n  operator of <code>T</code> is called the number of times equal to the number of\n  elements in the vector after the erased elements.</p>\n</blockquote>\n<p>Restated:  If you erase a range of elements that end with the end of the vector, <strong>zero</strong> move assignments will be performed, and move assignment is the only thing that might throw.  So you get back the no-throw guarantee if you are erasing at the end, even if <code>is_nothrow_move_assignable&lt;T&gt;::value</code> is false.</p>\n", "LastActivityDate": "2015-01-25T17:56:17.243", "CommentCount": "0", "CreationDate": "2015-01-25T17:56:17.243", "ParentId": "28136080", "Score": "3", "OwnerUserId": "576911"}, "28136248": {"Id": "28136248", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_28136080_28136248_0\">23.3.6.5 Throws: Nothing unless an exception is thrown by the copy constructor, move constructor, assignment operator, or move assignment operator of T.</p>\n</blockquote>\n<p>Provided your implementation conforms to this, it may implement the erase as it sees fit. There is no implicit exception safety guarantee as far as I can tell.</p>\n", "LastActivityDate": "2015-01-25T12:13:55.857", "CommentCount": "0", "CreationDate": "2015-01-25T12:13:55.857", "ParentId": "28136080", "Score": "1", "OwnerUserId": "2015579"}, "28136080": {"ViewCount": "428", "Body": "<p>I have read that std::vector erase method use move operations only if type is known to not emit exceptions due to strong exception safety. Other comments are that erase method guarantee basic or no throw exception safety depending on that if element constructor throws or not. I wasn't able to clarify that in my C++11 draft. I did test and it shows basic exception safety guarantee, it also used move constructor which was not marked as noexcept. Did I overlook something ? What is right ?  </p>\n", "AcceptedAnswerId": "28139567", "Title": "std::vector::erase exception safety", "CreationDate": "2015-01-25T11:55:14.610", "Id": "28136080", "CommentCount": "2", "LastEditDate": "2015-01-25T12:18:55.773", "PostTypeId": "1", "LastEditorUserId": "3712972", "LastActivityDate": "2015-01-25T17:56:17.243", "Score": "0", "OwnerUserId": "3712972", "Tags": "<c++><c++11><vector>", "AnswerCount": "2"}});