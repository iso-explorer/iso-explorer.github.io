post_cb({"bq_ids": {"n4140": {"so_42409152_49160697_1": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_42409152_49160697_3": {"length": 6, "quality": 1.0, "section_id": 3321}, "so_42409152_49160697_4": {"length": 6, "quality": 0.6666666666666666, "section_id": 3321}, "so_42409152_49160697_0": {"length": 15, "quality": 0.6818181818181818, "section_id": 3321}, "so_42409152_49160697_2": {"length": 5, "quality": 1.0, "section_id": 3321}}, "n3337": {"so_42409152_49160697_4": {"length": 6, "quality": 0.6666666666666666, "section_id": 3191}, "so_42409152_49160697_3": {"length": 6, "quality": 1.0, "section_id": 3191}, "so_42409152_49160697_1": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_42409152_49160697_0": {"length": 15, "quality": 0.6818181818181818, "section_id": 3191}, "so_42409152_49160697_2": {"length": 5, "quality": 1.0, "section_id": 3191}}, "n4659": {"so_42409152_49160697_4": {"length": 6, "quality": 0.6666666666666666, "section_id": 4087}, "so_42409152_49160697_3": {"length": 6, "quality": 1.0, "section_id": 4087}, "so_42409152_49160697_1": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_42409152_49160697_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 4086}, "so_42409152_49160697_2": {"length": 5, "quality": 1.0, "section_id": 4087}}}, "49160697": {"Id": "49160697", "PostTypeId": "2", "Body": "<p>See \u00a78.5.3\u00b64 in the C++11 standard:</p>\n<blockquote>\n<p id=\"so_42409152_49160697_0\">Given types \u201ccv1 T1\u201d and \u201ccv2 T2,\u201d \u201ccv1 T1\u201d is reference-related to \u201ccv2 T2\u201d if T1 is the same type as T2, or T1 is a base class of T2. \u201ccv1 T1\u201d is reference-compatible with \u201ccv2 T2\u201d if T1 is reference-related to T2 and cv1 is the same cv-qualification as, or greater cv-qualification than, cv2.</p>\n</blockquote>\n<p>In your case, <code>std::exception</code> is a base class of <code>std::runtime_exception</code>, making <code>ref</code> reference-related to <code>ex</code>. Since neither <code>ex</code> nor <code>ref</code> are <code>const</code> or <code>volatile</code>, they have the same cv-qualification, and <code>ref</code> is reference-compatible with <code>ex</code>.</p>\n<p>\u00a78.5.3\u00b65:</p>\n<blockquote>\n<p id=\"so_42409152_49160697_1\">A reference to type \u201ccv1 T1\u201d is initialized by an expression of type \u201ccv2 T2\u201d as follows:</p>\n<p id=\"so_42409152_49160697_2\">\u2014 If the reference is an lvalue reference and the initializer expression</p>\n<p id=\"so_42409152_49160697_3\">\u00a0 \u2014 is an lvalue (but is not a bit-field), and \u201ccv1 T1\u201d is reference-compatible with \u201ccv2 T2,\u201d (...)</p>\n</blockquote>\n<p><code>ref</code> is an lvalue reference, the initializer expression <code>ex</code> is an lvalue, and we already established that <code>ref</code> is reference-compatible with <code>ex</code>.</p>\n<p>Also relevant is the final sentence in \u00a78.5.3\u00b65</p>\n<blockquote>\n<p id=\"so_42409152_49160697_4\">In [the case I quoted above] the reference is said to bind directly to the initializer expression.</p>\n</blockquote>\n", "LastActivityDate": "2018-03-07T20:31:16.810", "Score": "1", "CreationDate": "2018-03-07T20:31:16.810", "ParentId": "42409152", "CommentCount": "0", "OwnerUserId": "7084"}, "42409152": {"ViewCount": "72", "Body": "<p>c++ standard says standard conversions include</p>\n<pre><code> A standard conversion sequence is a sequence of standard conversions in the following order:\n(1.1) \u2014 Zero or one conversion from the following set: lvalue-to-rvalue conversion, array-to-pointer conversion,\nand function-to-pointer conversion.\n(1.2) \u2014 Zero or one conversion from the following set: integral promotions, floating point promotion, integral\nconversions, floating point conversions, floating-integral conversions, pointer conversions, pointer to\nmember conversions, and boolean conversions.\n(1.3) \u2014 Zero or one qualification conversion.\n</code></pre>\n<p>But it hasn't metioned reference conversion.\nWhich is used widespreadly in c++; like:</p>\n<pre><code>auto ex = std::runtime_exception();\nstd::exception&amp; ref = ex; //reference conversion\n\n\n//reference to Derived converion to reference to Base in\n// operator = call in object slicing\nclass B{};\nclass D : public B\n{};\nB b = d;\n</code></pre>\n<p>I don't know why?</p>\n", "Title": "is reference conversion is the standard conversion", "CreationDate": "2017-02-23T07:08:11.113", "LastActivityDate": "2018-03-07T20:31:16.810", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-02-23T07:18:56.820", "LastEditorUserId": "2756517", "Id": "42409152", "Score": "1", "OwnerUserId": "6198112", "Tags": "<c++><language-lawyer>", "AnswerCount": "1"}});