post_cb({"40369314": {"ParentId": "40368535", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I guess it is due to <a href=\"http://eel.is/c++draft/class#mem-6\" rel=\"nofollow\">[class.mem]/6</a>.<br>\nIt states that:</br></p>\n<blockquote>\n<p id=\"so_40368535_40369314_0\">A class is considered a completely-defined object type ([basic.types]) (or complete type) at the closing\u00a0}\u00a0of the\u00a0class-specifier. [...]</p>\n</blockquote>\n<p>Note the last statement for your specific case:</p>\n<blockquote>\n<p id=\"so_40368535_40369314_1\">[...] Otherwise it is regarded as incomplete within its own class member-specification.</p>\n</blockquote>\n<p>Alias declarations are considered part of the member-specification and are not mentioned in the (let me say) exceptions to the rule:</p>\n<blockquote>\n<p id=\"so_40368535_40369314_2\">[...] Within the class\u00a0member-specification, the class is regarded as complete within function bodies, default arguments, exception-specifications, and default member initializers (including such things in nested classes).\u00a0[...]</p>\n</blockquote>\n<p>By reducing a bit further your example, we have this:</p>\n<pre><code>struct S {\n    auto f() {}\n    using T = decltype(f());\n};\n\nint main() {}\n</code></pre>\n<p>The error is more or less the same.</p>\n<p>At the using declaration, as mentioned above, the class is not considered a completely-defined type, thus are not its member functions.<br>\nBecause of that, deduction for the return type of the member function can't take place and the using declaration cannot be satisfied.<br>\nNote that to deduce the return type the compiler must <em>look</em> at the definition of the function, that is at its body.</br></br></p>\n<p>In other terms, it's not (conceptually) far from doing this:</p>\n<pre><code>auto f();\nusing T = decltype(f());\nint main() {}\n</code></pre>\n<p>How can you evaluate the return type of a function that has not been defined yet?<br>\nYou cannot and the code above doesn't work indeed.</br></p>\n<p>The fact that the member function is a <code>constexpr</code> one doesn't change anything in this case.</p>\n<hr>\n<p>As mentioned in the comments to the question, you can explicitly specify the return type by means of a trailing return type to work around the issue.<br>\nIn that case, a definition is no longer required and you can get the return type out of the declaration. Actually, there will be no deduction at all for the return type.</br></p>\n</hr>", "OwnerUserId": "4987285", "LastEditorUserId": "4987285", "LastEditDate": "2016-11-01T22:40:32.783", "Id": "40369314", "Score": "4", "CreationDate": "2016-11-01T21:59:52.823", "LastActivityDate": "2016-11-01T22:40:32.783"}, "bq_ids": {"n4140": {"so_40368535_40369314_1": {"section_id": 5862, "quality": 1.0, "length": 8}, "so_40368535_40369314_2": {"section_id": 5862, "quality": 0.85, "length": 17}, "so_40368535_40369314_0": {"section_id": 5862, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_40368535_40369314_1": {"section_id": 5632, "quality": 1.0, "length": 8}, "so_40368535_40369314_2": {"section_id": 5632, "quality": 0.85, "length": 17}, "so_40368535_40369314_0": {"section_id": 5632, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_40368535_40369314_1": {"section_id": 7345, "quality": 1.0, "length": 8}, "so_40368535_40369314_2": {"section_id": 7345, "quality": 0.95, "length": 19}, "so_40368535_40369314_0": {"section_id": 7345, "quality": 0.8888888888888888, "length": 8}}}, "40368535": {"CommentCount": "4", "ViewCount": "216", "PostTypeId": "1", "LastEditorUserId": "4987285", "CreationDate": "2016-11-01T20:58:16.263", "LastActivityDate": "2016-11-01T22:40:32.783", "Title": "Unable to get type of function returning constexpr auto", "AcceptedAnswerId": "40369314", "LastEditDate": "2016-11-01T22:13:28.267", "Id": "40368535", "Score": "3", "Body": "<p>I'm trying to use a property system in a class.</p>\n<p>A property has the corresponding member pointer, a name and an int (from an enum) to uniquely identify it.</p>\n<p>Here is the code that defines a property:</p>\n<pre><code>template&lt;typename Class, typename T&gt;\nstruct MemberProperty\n{\n    constexpr MemberProperty(T Class::*aMember, const char* aName, int aId)\n    : member(aMember), name(aName), id(aId)\n    {}\n\n    T Class::*member;\n    const char* name;\n    int id;\n};\n</code></pre>\n<p>I create properties by calling this function:</p>\n<pre><code>template &lt;typename Class, typename T&gt;\nconstexpr auto makeProperty(T Class::*member, const char* name, int id) {\n    return MemberProperty&lt;Class, T&gt;{member, name, id};\n}\n</code></pre>\n<p>My goal is to define properties for a class like this:</p>\n<pre><code>class User\n{\npublic:\n    enum PropertiesEnum\n    {\n        Property_Name\n    };\n\n    string m_name;\n\n    static constexpr auto Properties() {\n        return std::make_tuple(\n            makeProperty(&amp;User::m_name, \"name\", User::Property_Name)\n        );\n    }\n\n    using PropertiesType = decltype(Properties());\n\n    //PropertyManager&lt;PropertiesType&gt; m_propertyManager;\n};\n</code></pre>\n<p>I would like to be able to uncomment the line that declares <code>m_propertyManager</code>.\nThe problem is that this doesn't compile. In g++, I get:</p>\n<blockquote>\n<p id=\"so_40368535_40368535_0\">error: use of 'static constexpr auto User::Properties()' before deduction of 'auto'</p>\n</blockquote>\n<p>In Visual Studio 2015, I get:</p>\n<blockquote>\n<p id=\"so_40368535_40368535_1\">error C3779: 'User::UserProperties': a function that returns 'auto' cannot be used before it is defined</p>\n</blockquote>\n<p>How can I make this work? It looks like a circulary dependency but I can't find how to make it work.\nHere is the example:</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/24e7f5ea7f83da6f\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/24e7f5ea7f83da6f</a></p>\n", "Tags": "<c++>", "OwnerUserId": "384126", "AnswerCount": "1"}});