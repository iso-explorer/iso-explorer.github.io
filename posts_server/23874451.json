post_cb({"23874604": {"ParentId": "23874451", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The type of <code>this</code> depends on the cv-qualifier of the member function: <code>Avenger*</code> or <code>const Avenger*</code></p>\n<p>But not on its <em>ref-qualifier</em>. The <em>ref-qualifier</em> is used only to determine the function to be called.</p>\n<p>Thus, the type of <code>*this</code> is <code>Avenger&amp;</code> or <code>const Avenger&amp;</code>, no matter if you use the <code>&amp;&amp;</code> or not. The difference is that the overload with <code>&amp;&amp;</code> will be used then the called object is a r-value, while the <code>&amp;</code> will not.</p>\n<p>Note that rvalue-ness is a property of the expression, not the object. For example:</p>\n<pre><code>void foo(Avenger &amp;x)\n{\n    foo(x); //recursive call\n}\nvoid foo(Avenger &amp;&amp;x)\n{\n    foo(x); //calls foo(Avenger &amp;)!\n}\n</code></pre>\n<p>That is, although in the second <code>foo()</code>, <code>x</code> is defined as an r-value reference, any use of the expression <code>x</code> is still an l-value. The same is true for <code>*this</code>.</p>\n<p>So, if you want to move out the object, <code>return std::move(*this)</code> is The Right Way.</p>\n<p>Could things have been different had <code>this</code> been defined as a reference value instead of as a pointer? I'm not sure, but I think that considering <code>*this</code> as an r-value could lead to some insane situations...</p>\n<p>I didn't hear of anything changing about this in C++14, but I may be mistaken...</p>\n", "OwnerUserId": "865874", "LastEditorUserId": "865874", "LastEditDate": "2014-05-26T16:53:52.410", "Id": "23874604", "Score": "10", "CreationDate": "2014-05-26T16:48:18.363", "LastActivityDate": "2014-05-26T16:53:52.410"}, "24234973": {"ParentId": "23874451", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>It is <strong>NOT ok</strong> to return <code>std::move(*this)</code> on a member overloaded for the <code>&amp;&amp;</code> qualifier. The problem here is not with the <code>std::move(*this)</code> (which other answers correctly show that it is ok)  but with the return type. The problem is very subtle and it was almost done by the c++11 standardization committee. It is explained by <strong>Stephan T. Lavavej</strong> in his presentation <a href=\"http://channel9.msdn.com/Events/GoingNative/2013/Don-t-Help-the-Compiler\" rel=\"nofollow noreferrer\">Don\u2019t Help the Compiler</a> during <code>Going Native 2013</code>. His example can be found at around minute 42 in the linked video. His example is slightly different and doesn\u2019t involve <code>*this</code> and uses overload by parameter reference type rather than by method ref qualifiers but the principle is still the same.</p>\n<p>So what is wrong with the code?</p>\n<p>Short introduction: a reference bound to a temporary object prolongs the lifetime of the temporary object for the lifetime of the reference. That is what makes code like this be ok:</p>\n<pre><code>void foo(std::string const &amp; s) {\n  //\n}\n\nfoo(\"Temporary std::string object constructed from this char * C-string\");\n</code></pre>\n<p>The important part here is that this property is not transitive, meaning that for the reference to prolong the lifetime of the temporary object, it must bind <strong>directly</strong> to the temporary object, and not to a reference to it.</p>\n<p>Returning to my example:</p>\n<p>For completness let\u2019s add a function that takes only a const lvalue reference to <code>Avenger</code> (no rvalue reference overload):</p>\n<pre><code>void doInjustice(Avenger const &amp;) {};\n</code></pre>\n<p>the next two calls result in UB if referencing the parameter inside the functions:</p>\n<pre><code>doInjustice(Avenger{} &lt;&lt; 24); // calls `void doInustice(Avenger const &amp;) {};`\ndoJustice(Avenger{} &lt;&lt; 24); // calls `void doJustice(Avenger &amp;&amp;) {};` \n</code></pre>\n<p>The temporary objects constructed at parameter evaluation are destroyed as soon as the function are called for the reasons exposed above and the parameters are dangling references. Referencing them inside the functions will result in UB.</p>\n<hr>\n<p>The <strong>correct</strong> way is to return by value:</p>\n<pre><code>class Avenger {\n  public:\n    Avenger&amp; operator&lt;&lt;(int) &amp; {\n      return *this;\n    }\n    Avenger operator&lt;&lt;(int) &amp;&amp; {\n      return std::move(*this);\n    }\n};\n</code></pre>\n<p>A copy is still eluded with the move semantics, and the return is a temporary, meaning that it will call the correct overload, but we avoid this subtle but nasty silent bug.</p>\n<hr>\n<p>The example of <code>Stephan T. Lavavej</code>: <a href=\"http://channel9.msdn.com/Events/GoingNative/2013/Don-t-Help-the-Compiler\" rel=\"nofollow noreferrer\">Don\u2019t Help the Compiler</a> (42m\u201345m)</p>\n<pre><code>string&amp;&amp; join(string&amp;&amp; rv, const char * ptr) {\n  return move(rv.append(\", \").append(ptr));\n}\nstring meow() { return \"meow\"; }\n\nconst string&amp; r = join(meow(), \"purr\");\n// r refers to a destroyed temporary!\n\n//Fix:\nstring join(string&amp;&amp; rv, const char * ptr) {\n  return move(rv.append(\", \").append(ptr));\n}\n</code></pre>\n<p>Posts on SO explaining the prolonging of life of temporary objects through references:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/2784262/does-a-const-reference-prolong-the-life-of-a-temporary\">Does a const reference prolong the life of a temporary?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/21045518/initializing-a-reference\">Initializing a reference</a></li>\n</ul>\n</hr></hr>", "OwnerUserId": "2805305", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:44:24.167", "Id": "24234973", "Score": "1", "CreationDate": "2014-06-15T23:16:43.167", "LastActivityDate": "2014-06-15T23:16:43.167"}, "23874451": {"CommentCount": "2", "AcceptedAnswerId": "24234973", "PostTypeId": "1", "LastEditorUserId": "2805305", "CreationDate": "2014-05-26T16:36:05.907", "LastActivityDate": "2017-11-14T15:02:00.293", "LastEditDate": "2014-06-15T23:18:42.700", "ViewCount": "1344", "FavoriteCount": "5", "Title": "Correct way to return an rvalue reference to this", "Id": "23874451", "Score": "15", "Body": "<p>The code below results in <strong>Undefined Behaviour</strong>. Be sure to read ALL the answers for completeness.</p>\n<hr>\n<p>When chaining an object via the <code>operator&lt;&lt;</code> I want to preserve the lvalue-ness / rvalue-ness of the object:</p>\n<pre><code>class Avenger {\n  public:\n    Avenger&amp; operator&lt;&lt;(int) &amp; {\n      return *this;\n    }\n    Avenger&amp;&amp; operator&lt;&lt;(int) &amp;&amp; {\n      return *this; // compiler error cannot bind lvalue to rvalue\n      return std::move(*this);\n    }\n};\nvoid doJustice(const Avenger &amp;) {};\nvoid doJustice(Avenger &amp;&amp;) {};\n\nint main() {\n  Avenger a;\n  doJustice(a &lt;&lt; 24); // parameter should be Avenger&amp;\n  doJustice(Avenger{} &lt;&lt; 24); // parameter should be Avenger&amp;&amp;\n\n  return 0;\n}\n</code></pre>\n<p>I cannot simply return <code>*this</code> which implies that the type of <code>*this</code> of an <code>rvalue</code> object is still an <code>lvalue reference</code>. I would have expected to be an <code>rvalue reference</code>.</p>\n<ul>\n<li>Is it correct / recommended to return <code>std::move(*this)</code> on an member overloaded for the <code>&amp;&amp;</code> qualifier, or should other method be used? I know that <code>std::move</code> is just a cast, so I think it\u2019s ok, I just want to double check.</li>\n<li>What is the reason/explanation that <code>*this</code> of an <code>rvalue</code> is an <code>lvalue reference</code> and not an <code>rvalue reference</code>?</li>\n<li>I remember seeing in C++14 something about move semantics of <code>*this</code>. Is that related to this? Will any of the above change in C++14?</li>\n</ul>\n</hr>", "Tags": "<c++><c++11><c++14><rvalue>", "OwnerUserId": "2805305", "AnswerCount": "5"}, "23874799": {"ParentId": "23874451", "PostTypeId": "2", "CommentCount": "5", "Body": "<p><code>std::move</code> is perhaps better called <code>rvalue_cast</code>.</p>\n<p>But it is not called that.  Despite its name, it is nothing but an rvalue cast: <code>std::move</code> does not move.</p>\n<p>All named values are lvalues, as are all pointer dereferences, so using <code>std::move</code> or <code>std::forward</code> (aka conditional rvalue cast) to turn a named value that is an rvalue reference at point of declaration (or other reasons) into an rvalue at a particular point is kosher.</p>\n<p>Note, however, that you rarely want to return an rvalue reference.  If your type is cheap to move, you usually want to return a literal.  Doing so uses the same <code>std::move</code> in the method body, but now it actually triggers moving into the return value.  And now if you capture the return value in a reference (say <code>auto&amp;&amp; foo = expression;</code>), reference lifetime extension works properly.  About the only good time to return an rvalue reference is in an rvalue cast: which sort of makes the fact that <code>move</code> is an rvalue cast somewhat academic.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2014-05-27T10:40:50.523", "Id": "23874799", "Score": "7", "CreationDate": "2014-05-26T17:03:55.103", "LastActivityDate": "2014-05-27T10:40:50.523"}, "24235562": {"ParentId": "23874451", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>This answer is in response to <a href=\"https://stackoverflow.com/users/2805305/bolov\">bolov</a>'s comment to me under his answer to his question.</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Avenger\n{\n    bool constructed_ = true;\n\n  public:\n    Avenger() = default;\n\n    ~Avenger()\n    {\n        constructed_ = false;\n    }\n\n    Avenger(Avenger const&amp;) = default;\n    Avenger&amp; operator=(Avenger const&amp;) = default;\n    Avenger(Avenger&amp;&amp;) = default;\n    Avenger&amp; operator=(Avenger&amp;&amp;) = default;\n\n    Avenger&amp; operator&lt;&lt;(int) &amp;\n    {\n      return *this;\n    }\n\n    Avenger&amp;&amp; operator&lt;&lt;(int) &amp;&amp;\n    {\n      return std::move(*this);\n    }\n\n    bool alive() const {return constructed_;}\n};\n\nvoid\ndoJustice(const Avenger&amp; a)\n{\n    std::cout &lt;&lt; \"doJustice(const Avenger&amp; a): \" &lt;&lt; a.alive() &lt;&lt; '\\n';\n};\n\nvoid\ndoJustice(Avenger&amp;&amp; a)\n{\n    std::cout &lt;&lt; \"doJustice(Avenger&amp;&amp; a): \" &lt;&lt; a.alive() &lt;&lt; '\\n';\n};\n\nint main()\n{\n  Avenger a;\n  doJustice(a &lt;&lt; 24); // parameter should be Avenger&amp;\n  doJustice(Avenger{} &lt;&lt; 24); // &lt;--- this one\n  // Avenger&amp;&amp; dangling = Avenger{} &lt;&lt; 24;\n  // doJustice(std::move(dangling));\n}\n</code></pre>\n<p>This will portably output:</p>\n<pre><code>doJustice(const Avenger&amp; a): 1\ndoJustice(Avenger&amp;&amp; a): 1\n</code></pre>\n<p>What the above output demonstrates is that a temporary <code>Avenger</code> object will not be destructed until the sequence point demarcated by the ';' just before the comment \"// &lt;--- this one\" above.</p>\n<p>I've removed all undefined behavior from this program.  This is a fully conforming and portable program.</p>\n", "OwnerUserId": "576911", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:22:56.913", "Id": "24235562", "Score": "4", "CreationDate": "2014-06-16T01:19:35.170", "LastActivityDate": "2014-06-16T14:30:08.773"}, "47288940": {"ParentId": "23874451", "CommentCount": "0", "Body": "<p>My git copy of the C++ Standard (page 290, section15.2, point 6) says:</p>\n<blockquote>\n<p id=\"so_23874451_47288940_0\">\"The exceptions to this lifetime rule [of a reference binding to a<br>\n  temporary extending the lifetime of that temporary] are:</br></p>\n<p id=\"so_23874451_47288940_1\">sub 9 - A temporary object bound to a reference parameter in a\n             function call persists until the completion of the\n             full-expression containing the call.</p>\n<p id=\"so_23874451_47288940_2\">sub 10 - The lifetime of a temporary bound to the returned value\n             in a function return statement (9.6.3) is not extended;\n             the temporary is destroyed at the end of the\n             full-expression in the return statement.  [...]\"</p>\n</blockquote>\n<p>Therefore, the implicit this `parameter' passed to</p>\n<pre><code>Avenger&amp;&amp; operator&lt;&lt;(int) &amp;&amp;\n{\n      return std::move(*this);\n}\n</code></pre>\n<p>ends its life at the ; of the statement that calls operator&lt;&lt; on a temporary object, <strong>even</strong> if a reference is bound to it. So this fails:</p>\n<pre><code>Avenger &amp;&amp;dangler = Avenger{} &lt;&lt; 24; // destructor already called\ndangler &lt;&lt; 1; // Operator called on dangling reference\n</code></pre>\n<p>If OTOH the return is by value:</p>\n<pre><code>Avenger operator&lt;&lt;(int) &amp;&amp;\n{\n      return std::move(*this);\n}\n</code></pre>\n<p>then none of that misery happens, and there is often no extra cost in terms of copying. And indeed, if you don't offer the compiler to create that return value by move-constructing from *this, then it 'll make a copy.\nSo snatch *this from the brink of oblivion, and have the best of both worlds.</p>\n", "OwnerUserId": "7119540", "PostTypeId": "2", "Id": "47288940", "Score": "1", "CreationDate": "2017-11-14T15:02:00.293", "LastActivityDate": "2017-11-14T15:02:00.293"}, "bq_ids": {"n4140": {"so_23874451_47288940_1": {"section_id": 382, "quality": 0.9285714285714286, "length": 13}, "so_23874451_47288940_2": {"section_id": 382, "quality": 0.8333333333333334, "length": 15}}, "n3337": {"so_23874451_47288940_1": {"section_id": 373, "quality": 0.9285714285714286, "length": 13}, "so_23874451_47288940_2": {"section_id": 373, "quality": 0.8333333333333334, "length": 15}}, "n4659": {"so_23874451_47288940_2": {"section_id": 397, "quality": 0.8333333333333334, "length": 15}, "so_23874451_47288940_1": {"section_id": 397, "quality": 0.9285714285714286, "length": 13}}}});