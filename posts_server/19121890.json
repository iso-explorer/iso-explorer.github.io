post_cb({"19122919": {"ParentId": "19121890", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The expressions <code>int()</code> and <code>int{}</code> are both constant expression prvalues of integer type that evaluate to zero, and are therefore interchangeable with the literal <code>0</code> in any context that requires an integral constant expression prvalue of integer type which evaluates to zero.</p>\n<p>Both expressions satisfy the requirements for a constant expression as specified in <em>5.19 Constant Expressions [expr.const]</em>.</p>\n<p>Regarding <code>X&lt;int()&gt;</code>, the standard specifies that <code>int()</code> is not interpreted as an expression in this context:</p>\n<blockquote>\n<h3>14.3 Template arguments [temp.arg]</h3>\n<p id=\"so_19121890_19122919_0\">In a <em>template-argument</em>, an ambiguity between a <em>type-id</em> and an <em>expression</em> is resolved to a <em>type-id</em>, regardless of the form of the corresponding <em>template-parameter</em>.</p>\n</blockquote>\n<p>Regarding pointer conversions:</p>\n<blockquote>\n<h3>4.10 Pointer conversions [conv.ptr]</h3>\n<p id=\"so_19121890_19122919_1\">A null pointer constant is an integral constant expression (5.19) prvalue of integer type that evaluates to zero\n  or a prvalue of type <code>std::nullptr_t</code>.</p>\n</blockquote>\n<p>Based on the above paragraph, both <code>int()</code> and <code>int{}</code> are null pointer constant expressions. This points to a (very minor) compiler bug, although there is an open Defect Report (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html\" rel=\"noreferrer\">903</a>) which may lead to this paragraph changing:</p>\n<blockquote>\n<p id=\"so_19121890_19122919_2\">There was a strong consensus among the CWG that only the literal 0 should be considered a null pointer constant, not any arbitrary zero-valued constant expression as is currently specified.</p>\n</blockquote>\n<p>The following wording deals with the value of the expression <code>int()</code>:</p>\n<blockquote>\n<h3>8.5 Initializers [dcl.init]</h3>\n<p id=\"so_19121890_19122919_3\"><strong>To zero-initialize an object or reference of type T means:</strong></p>\n<p id=\"so_19121890_19122919_4\">[<em>omitted clauses which don't apply</em>]</p>\n<p id=\"so_19121890_19122919_5\">\u2014 <strong>if T is a scalar type (3.9), the object is set to the value 0 (zero), taken as an integral constant expression,\n  converted to T</strong></p>\n<p id=\"so_19121890_19122919_6\">[...]</p>\n<p id=\"so_19121890_19122919_7\"><strong>To value-initialize an object of type T means:</strong></p>\n<p id=\"so_19121890_19122919_8\">\u2014 if T is a (possibly cv-qualified) class type (Clause 9) with a user-provided constructor (12.1), then the\n  default constructor for T is called (and the initialization is ill-formed if T has no accessible default\n  constructor);</p>\n<p id=\"so_19121890_19122919_9\">[<em>omitted clauses which don't apply</em>]</p>\n<p id=\"so_19121890_19122919_10\">\u2014 <strong>otherwise, the object is zero-initialized.</strong></p>\n<p id=\"so_19121890_19122919_11\"><strong>An object whose initializer is an empty set of parentheses, i.e., (), shall be value-initialized.</strong></p>\n</blockquote>\n<p>And for the value of <code>int{}</code>:</p>\n<blockquote>\n<h3>8.5.4 List-initialization [dcl.init.list]</h3>\n<p id=\"so_19121890_19122919_12\"><strong>List-initialization of an object or reference of type T is defined as follows:</strong></p>\n<p id=\"so_19121890_19122919_13\">\u2014 If the initializer list has no elements and T is a class type with a default constructor, the object is\n  value-initialized.</p>\n<p id=\"so_19121890_19122919_14\">[<em>omitted clauses which don't apply</em>]</p>\n<p id=\"so_19121890_19122919_15\">\u2014 <strong>Otherwise, if the initializer list has no elements, the object is value-initialized.</strong></p>\n</blockquote>\n<p>All quotes from C++ Working Draft Standard N3337.</p>\n", "OwnerUserId": "1690864", "LastEditorUserId": "1690864", "LastEditDate": "2013-10-01T18:20:48.400", "Id": "19122919", "Score": "5", "CreationDate": "2013-10-01T18:04:36.223", "LastActivityDate": "2013-10-01T18:20:48.400"}, "bq_ids": {"n4140": {"so_19121890_19122919_7": {"section_id": 3287, "quality": 1.0, "length": 4}, "so_19121890_19122919_13": {"section_id": 3325, "quality": 1.0, "length": 9}, "so_19121890_19122919_12": {"section_id": 3325, "quality": 1.0, "length": 6}, "so_19121890_19122919_5": {"section_id": 6143, "quality": 0.5454545454545454, "length": 6}, "so_19121890_19122919_11": {"section_id": 3290, "quality": 1.0, "length": 7}, "so_19121890_19122919_15": {"section_id": 3325, "quality": 1.0, "length": 6}, "so_19121890_19122919_0": {"section_id": 77, "quality": 1.0, "length": 11}, "so_19121890_19122919_3": {"section_id": 3285, "quality": 1.0, "length": 5}, "so_19121890_19122919_8": {"section_id": 3286, "quality": 0.7058823529411765, "length": 12}}, "n3337": {"so_19121890_19122919_13": {"section_id": 3195, "quality": 1.0, "length": 9}, "so_19121890_19122919_12": {"section_id": 3195, "quality": 1.0, "length": 6}, "so_19121890_19122919_1": {"section_id": 36, "quality": 0.8666666666666667, "length": 13}, "so_19121890_19122919_7": {"section_id": 3157, "quality": 1.0, "length": 4}, "so_19121890_19122919_11": {"section_id": 3160, "quality": 1.0, "length": 7}, "so_19121890_19122919_15": {"section_id": 3195, "quality": 1.0, "length": 6}, "so_19121890_19122919_5": {"section_id": 3155, "quality": 1.0, "length": 11}, "so_19121890_19122919_0": {"section_id": 72, "quality": 1.0, "length": 11}, "so_19121890_19122919_3": {"section_id": 3155, "quality": 1.0, "length": 5}, "so_19121890_19122919_8": {"section_id": 3157, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_19121890_19122919_13": {"section_id": 4091, "quality": 1.0, "length": 9}, "so_19121890_19122919_3": {"section_id": 653, "quality": 0.8, "length": 4}, "so_19121890_19122919_11": {"section_id": 4052, "quality": 1.0, "length": 7}, "so_19121890_19122919_15": {"section_id": 4091, "quality": 1.0, "length": 6}, "so_19121890_19122919_0": {"section_id": 79, "quality": 1.0, "length": 11}, "so_19121890_19122919_12": {"section_id": 4091, "quality": 1.0, "length": 6}, "so_19121890_19122919_8": {"section_id": 4049, "quality": 0.6470588235294118, "length": 11}}}, "19121890": {"CommentCount": "13", "AcceptedAnswerId": "19122919", "PostTypeId": "1", "LastEditorUserId": "415784", "CreationDate": "2013-10-01T16:59:28.060", "LastActivityDate": "2013-10-01T18:20:48.400", "LastEditDate": "2013-10-01T17:07:34.720", "ViewCount": "249", "FavoriteCount": "1", "Title": "What are the differences between 0, int() and int{}?", "Id": "19121890", "Score": "5", "Body": "<p>As <code>int()</code> and <code>int{}</code> are <strong>constant</strong> expressions of value equal to <code>0</code>, I thought they are equivalent and interchangeable, thus compilers must treat them equally. For example,</p>\n<pre><code> int a[0];      //error: zero-sized array not allowed in ISO C++\n int b[int()];  //error: zero-sized array not allowed in ISO C++\n int c[int{}];  //error: zero-sized array not allowed in ISO C++\n</code></pre>\n<p>But it seems there are some corner cases where they're not interchangeable. </p>\n<ul>\n<li><p>When initializing a pointer:</p>\n<pre><code>int *p = 0;     //ok\nint *q = int(); //error - by clang only\nint *r = int{}; //error - by gcc and clang both\n</code></pre>\n<p>See <a href=\"http://coliru.stacked-crooked.com/a/9a1002b40490e5ff\">GCC</a> and <a href=\"http://coliru.stacked-crooked.com/a/bf1763fd8bbbd64a\">Clang</a> messages. I suspect this is a bug in both compilers, as I expect them to be interchangeable in this context, but I would be glad to be proven wrong. :-)</p></li>\n<li><p>When passing to class template:</p>\n<pre><code>template&lt;int N&gt; struct X{};\n\nX&lt;0&gt;      x1; //ok\nX&lt;int{}&gt;  x2; //ok (same as X&lt;0&gt;)\nX&lt;int()&gt;  x3; //error  \n</code></pre>\n<p>See <a href=\"http://coliru.stacked-crooked.com/a/ec2356bb1af66581\">GCC</a> and <a href=\"http://coliru.stacked-crooked.com/a/4de0ee8be98d8251\">Clang</a> messages.</p>\n<p>I find the syntax <code>X&lt;int()&gt;</code> quite familiar as I've seen (and probably used) the similar syntax before, such as in <code>std::function&lt;int()&gt;</code>, the template argument <code>int()</code> is expected to be <em>function type</em>  (instead of <code>0</code>) taking no argument and returning <code>int</code>. But I want to know the section of the spec which says in this context <code>int()</code> is to be treated as function <em>type</em> and is not equivalent to <code>int{}</code> which is always <code>0</code>.</p></li>\n</ul>\n", "Tags": "<c++><gcc><clang><zero><compile-time-constant>", "OwnerUserId": "415784", "AnswerCount": "1"}});