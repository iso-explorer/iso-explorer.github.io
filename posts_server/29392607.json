post_cb({"29392607": {"CommentCount": "4", "ViewCount": "164", "PostTypeId": "1", "LastEditorUserId": "2692339", "CreationDate": "2015-04-01T13:50:59.343", "LastActivityDate": "2015-04-01T15:11:59.453", "Title": "Why is digits10 for reference to integer type 0?", "LastEditDate": "2015-04-01T14:57:18.233", "Id": "29392607", "Score": "5", "Body": "<p>The following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;cstdint&gt;\n\nint main() \n{\n    std::cout &lt;&lt; std::numeric_limits&lt;std::uint64_t&gt;::digits10 &lt;&lt; \"\\n\" \n              &lt;&lt; std::numeric_limits&lt;std::uint64_t&amp;&gt;::digits10 &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>outputs </p>\n<blockquote>\n<p id=\"so_29392607_29392607_0\">19<br>\n  0</br></p>\n</blockquote>\n<p>I would expect <code>std::uint64_t&amp;</code> to have same value as <code>std::uint64_t</code>: Is there a reason for this discrepancy?</p>\n", "Tags": "<c++>", "OwnerUserId": "700825", "AnswerCount": "3"}, "29393566": {"ParentId": "29392607", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2015-04-01T14:31:44.040", "Score": "2", "LastEditorUserId": "251738", "LastEditDate": "2015-04-01T15:11:59.453", "Id": "29393566", "OwnerUserId": "251738", "Body": "<p>18.3.2.1/2:</p>\n<blockquote>\n<p id=\"so_29392607_29393566_0\">Specializations shall be provided for each arithmetic type, both\n  floating point and integer, including bool. The member is_specialized\n  shall be true for all such specializations of numeric_limits.</p>\n</blockquote>\n<p>So we know that specializations will exist for for these non-reference types. Then 18.3.2.3/1:</p>\n<blockquote>\n<p id=\"so_29392607_29393566_1\">The default numeric_limits template shall have all members, but\n  with 0 or false values.</p>\n</blockquote>\n<p>I suspect it was done this way because you can always static_assert on <code>is_specialized</code> to force a compile error, but there could possibly be some template application where 0 would be an ok default value for one or more of the limits. If you want to be able to test references just run it through <code>std::remove_reference</code>.</p>\n<p>I'm not sure if it's legal to specialize <code>numeric_limits</code> for your own types. The standard in 18.3.2.1/4 says:</p>\n<blockquote>\n<p id=\"so_29392607_29393566_2\">Non-arithmetic standard types, such as complex (26.4.2), shall not\n  have specializations.</p>\n</blockquote>\n<p>I personally read this qute as \"the standard will not provide specializations for non-arithmetic standard libray types, but it's perfectly legal to specialize for a user type\". You could just as easily read this as totally forbidding any non-provided specializations.</p>\n", "LastActivityDate": "2015-04-01T15:11:59.453"}, "29394166": {"ParentId": "29392607", "CommentCount": "0", "CreationDate": "2015-04-01T14:57:29.320", "OwnerUserId": "2692339", "PostTypeId": "2", "Id": "29394166", "Score": "0", "Body": "<p><code>std::numeric_limits</code> is expected to be specialized for fundamental arithmetic data types (integers and floating points). A reference -of any kind- does not belong to them and that's why the non-specialized template is chosen, which has all its members to <code>false</code> (<code>0</code>).  </p>\n<blockquote>\n<p id=\"so_29392607_29394166_0\">I would expect std::uint64_t&amp; to have same value as std::uint64_t: Is\n  there a reason for this discrepancy?</p>\n</blockquote>\n<p>Although <code>std::uint64_t</code> is an arithmetic type, <code>std::uint64_t&amp;</code> is a compound type and has a different meaning. You have a few options:</p>\n<ul>\n<li>Always consider the base type by removing the reference, pointer or both.</li>\n<li><code>static_assert( is_arithmetic&lt;&gt; )</code> </li>\n<li>check <code>std::numeric_limits&lt;T&gt;::is_specialized</code></li>\n</ul>\n", "LastActivityDate": "2015-04-01T14:57:29.320"}, "bq_ids": {"n4140": {"so_29392607_29393566_0": {"section_id": 6714, "quality": 0.9473684210526315, "length": 18}, "so_29392607_29393566_2": {"section_id": 6716, "quality": 0.7142857142857143, "length": 5}, "so_29392607_29393566_1": {"section_id": 6717, "quality": 0.8, "length": 8}}, "n3337": {"so_29392607_29393566_0": {"section_id": 6469, "quality": 0.9473684210526315, "length": 18}, "so_29392607_29393566_2": {"section_id": 6471, "quality": 0.7142857142857143, "length": 5}, "so_29392607_29393566_1": {"section_id": 6472, "quality": 0.8, "length": 8}}, "n4659": {"so_29392607_29393566_0": {"section_id": 8209, "quality": 0.8421052631578947, "length": 16}, "so_29392607_29393566_2": {"section_id": 8211, "quality": 0.7142857142857143, "length": 5}, "so_29392607_29393566_1": {"section_id": 8208, "quality": 0.8, "length": 8}}}, "29392828": {"ParentId": "29392607", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-04-01T14:00:40.640", "Score": "1", "LastEditorUserId": "69083", "LastEditDate": "2015-04-01T14:25:01.877", "Id": "29392828", "OwnerUserId": "69083", "Body": "<p>The type <code>uint64&amp;</code> is a reference, so it's not one of the arithmetic types that the <code>numeric_limits</code> template should be used for.</p>\n<p>For any other types than the arithmetic types defined, the default definition is used which contains:</p>\n<pre><code>static const int  digits10 = 0;\n</code></pre>\n<p>Reference: <a href=\"http://www.cplusplus.com/reference/limits/numeric_limits/\" rel=\"nofollow\">http://www.cplusplus.com/reference/limits/numeric_limits/</a></p>\n", "LastActivityDate": "2015-04-01T14:25:01.877"}});