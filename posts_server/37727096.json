post_cb({"37729915": {"Id": "37729915", "PostTypeId": "2", "Body": "<p>You know the standards better than I, but going on the information you've provided, the standard defines a trivial destructor, but it doesn't define an empty destructor, which would make this question kind of misleading.  A trivial destructor is then a special case that compilers can optimize to, and while an  empty constructor makes sense to us, it's not something compiler writers have to consider.</p>\n<p>Browsing a few SO links:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/10303288/why-does-default-user-defined-destructors-in-c-increases-execution-time?rq=1\">Why Does Default user defined destructors in C++ increases execution time?</a> shows a case where a compiler does act differently for trivial vs. empty destructors.  The answer there implies one difference is in exception handling.  It doesn't look for an empty constructor because it's not required to, and so handles exceptions as if there was valid code inside the dtor.</li>\n<li><a href=\"https://stackoverflow.com/questions/1025313/will-an-empty-constructor-or-destructor-do-the-same-thing-as-the-generated-one\">Will an 'empty' constructor or destructor do the same thing as the generated one?</a> seems to be such a close match to your question that it might be a duplicate.  It's better to read it on your own instead of relying on my interpretation, but it makes mention of Microsoft compilers not being able to inline empty destructors, and all compilers wanting a working base class destructor (and it being a very bad programming practice for the base dtor not to be virtual).</li>\n</ul>\n<p>To answer your second question, as soon as your ctor is non-empty, it isn't trivial.  The closest you get to trivial is an empty ctor/dtor, and your careful reading of the standard already tells you that that's not defined to be trivial.</p>\n<p><strong>TL;DR:</strong> The standard defines a trivial dtor, but not an empty one.  Smart compilers can choose to notice that it's user-defined empty and treat it as trivial, but the standard doesn't require any such consideration.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-06-09T15:13:53.803", "Score": "0", "CreationDate": "2016-06-09T15:13:53.803", "ParentId": "37727096", "CommentCount": "0", "OwnerUserId": "1404311", "LastEditDate": "2017-05-23T10:28:54.850"}, "bq_ids": {"n4140": {"so_37727096_37727096_2": {"length": 5, "quality": 1.0, "section_id": 7189}, "so_37727096_37727096_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 7189}, "so_37727096_37727096_1": {"length": 7, "quality": 0.875, "section_id": 7189}}, "n3337": {"so_37727096_37727096_2": {"length": 5, "quality": 1.0, "section_id": 6933}, "so_37727096_37727096_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 6933}, "so_37727096_37727096_1": {"length": 7, "quality": 0.875, "section_id": 6933}}, "n4659": {"so_37727096_37727096_2": {"length": 5, "quality": 1.0, "section_id": 8701}, "so_37727096_37727096_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 8697}, "so_37727096_37727096_1": {"length": 7, "quality": 0.875, "section_id": 8697}}}, "37730506": {"Id": "37730506", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_37727096_37730506_0\">In what way a user defined empty ctor/dtor can or cannot be considered as a trivial-like ctor/dtor regarding compiler code generation, optimizations, trade-offs, ...</p>\n</blockquote>\n<p>If the constructor/destructor are not inlined, then the compiler may (depending on link-time optimizations) have to issue a call to them, even though they're no-ops.</p>\n<p>For example, the following code:</p>\n<pre><code>struct Struct {\n  Struct();\n  ~Struct();\n};\n\nint main() {\n  Struct s;\n}\n</code></pre>\n<p>Is compiled to (with optimizations turned on):</p>\n<pre><code>main:\n        subq    $24, %rsp\n        leaq    15(%rsp), %rdi\n        call    Struct::Struct()\n        leaq    15(%rsp), %rdi\n        call    Struct::~Struct()\n        xorl    %eax, %eax\n        addq    $24, %rsp\n        ret\n</code></pre>\n<p>Notice that there is still a call to the constructor and destructor, even though in a separate file I could have defined them to just be empty functions.</p>\n<p>If, however, you've inlined the definitions:</p>\n<pre><code>struct Struct {\n  Struct() {}\n  ~Struct() {}\n};\n\nStruct foo() {\n  return Struct{};\n}\n</code></pre>\n<p>Then the compiler can (and will if it doesn't totally suck) treat them just like trivial constructors/destructors:</p>\n<pre><code>foo():\n        movq    %rdi, %rax\n        ret\n</code></pre>\n<p>In that sample, any constructor/destructor calls are completely optimized away, and the generated code is the same as if <code>Struct</code>'s definition were simple <code>struct Struct {};</code>.</p>\n<blockquote>\n<p id=\"so_37727096_37730506_1\">Same question with user defined non-empty ctor/dtor; what rules should follow a code implemented in ctor/dtor to consider them as trivial-like.</p>\n</blockquote>\n<p>This kind of depends. Again, if the constructor/destructor are not inlined, then the compiler might still have to issue calls to them, in which case they're not at all trivial-like.</p>\n<p>However, inline non-empty constructors/destructors might still be \"trivial-like\" if the optimizer can completely optimize them away (for example, if they only contain <code>for (int x = 0; x &lt; 1000; ++x);</code>, then that is useless code that can be optimized away) to the point that they're effectively empty.</p>\n<p>But if they do useful work that can't just be optimized away, then they won't be trivial-like at all. They'll be run. They have to.</p>\n", "LastActivityDate": "2016-06-09T15:39:18.900", "CommentCount": "0", "CreationDate": "2016-06-09T15:39:18.900", "ParentId": "37727096", "Score": "1", "OwnerUserId": "1287251"}, "37727096": {"ViewCount": "1239", "Body": "<p>The C++ standard defines some very specific behaviors when a class has a trivial constructor and/or a trivial destructor.</p>\n<p>As an example, as per \u00a73.8/1 of the standard:</p>\n<blockquote>\n<p id=\"so_37727096_37727096_0\">The lifetime of an object of type <code>T</code> ends when:</p>\n<p id=\"so_37727096_37727096_1\">\u2014 if <code>T</code> is a class type with a non-trivial destructor (12.4), the destructor call starts, or</p>\n<p id=\"so_37727096_37727096_2\">\u2014 the storage which the object occupies is reused or released.</p>\n</blockquote>\n<p>So,</p>\n<ul>\n<li>if an object is not trivialy destructible, any attempt to access members of the object after the destructor is called is UB.</li>\n<li>if an object is trivialy destructible, attempt to access members of the object after the destructor is called is safe and not UB.</li>\n</ul>\n<p>Although this example may not be the best one, it shows that the difference in behavior maybe crucial (UB/non-UB) whether an object is trivialy destructible or not.</p>\n<p>\u00a712.4/3 of the Standard states that (to sumerize) a destructor of a class <code>T</code> is trivial if it is <strong>implicitely defined</strong>, not virtual, and if all base classes and members of class <code>T</code> are trivially destructible.</p>\n<p>In my (modest) experience, I never saw any difference, in terms of code generated by the compiler, between :</p>\n<ul>\n<li>a class with a trivial default ctor and/or a trivial dtor, and</li>\n<li>a class with a <strong>user defined empty</strong> ctor and/or a non-virtual <strong>user defined empty</strong> dtor (as long as the class, its base classes and members classes also have non-virtual dtor user defined empty or trivial)</li>\n</ul>\n<p>So, my questions are:</p>\n<ul>\n<li>In what way a user defined empty ctor/dtor can or cannot be considered as a trivial-like ctor/dtor regarding compiler code generation, optimizations, trade-offs, ...</li>\n<li>Same question with user defined non-empty ctor/dtor; what rules should follow a code implemented in ctor/dtor to consider them as trivial-like.</li>\n</ul>\n<p>My question is not related to standard (please, do not answer the standard states what is a trivial ctor/dtor, so user defined ctor/dtor is not) but to the way compilers deal with user defined ctor/dtor and in what way the behavior of a compiled code may change (or not) compared to trivial ctor/dtor.</p>\n", "Title": "What is the difference between a trivial ctor (or dtor) and a user defined empty ctor (or dtor)", "CreationDate": "2016-06-09T13:16:28.497", "LastActivityDate": "2016-06-09T15:39:18.900", "CommentCount": "0", "LastEditDate": "2016-06-09T13:21:41.303", "PostTypeId": "1", "LastEditorUserId": "4801801", "Id": "37727096", "Score": "10", "OwnerUserId": "4801801", "Tags": "<c++><constructor><destructor>", "AnswerCount": "2"}});