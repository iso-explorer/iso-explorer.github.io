post_cb({"38680647": {"ParentId": "38680504", "CommentCount": "0", "CreationDate": "2016-07-31T04:02:14.700", "OwnerUserId": "1094101", "PostTypeId": "2", "Id": "38680647", "Score": "0", "Body": "<p>On most implementation the allocator would hold previously free'd memory, you would not expect to always get contiguous memory.</p>\n<p>Think about this case: <code>Test1</code> is a large object, <code>Test2</code> is small one, <code>Test3</code> is a mid size.</p>\n<p>When you allocate for <code>Test1</code>, the current memory pool don't have large enough reusable memory, so it request to extend the heap and allocate from there.\nThen you do for the small <code>Test2</code>, it's just a tiny object that there is reusable memory from previously free'd one, so you get <code>Test2</code> from that pool.</p>\n<p>For <code>Test3</code> its similar to <code>Test2</code>, but for performance the allocator would hold multiple pool for different size-range, so <code>Test3</code> may not go after <code>Test2</code>.</p>\n<p>NOTE: All these are not mandatory from the specification, it's up to the implementation and what suggested here is just one of the usual implementation (further reading: Buddy memory allocation).</p>\n", "LastActivityDate": "2016-07-31T04:02:14.700"}, "38680532": {"ParentId": "38680504", "LastEditDate": "2016-07-31T03:45:21.970", "CommentCount": "0", "CreationDate": "2016-07-31T03:38:22.197", "Score": "3", "LastEditorUserId": "464581", "PostTypeId": "2", "Id": "38680532", "OwnerUserId": "464581", "Body": "<p>Sequential <code>new</code> expressions do not necessarily allocate sequential blocks of memory.</p>\n<p>But C++14 has special support for such a sequence of <code>new</code> expressions, where under certain conditions they can be replaced with a single <code>new</code> expression (that necessarily allocates a sufficiently large chunk of contiguous memory), and where the corresponding <code>delete</code> expressions are replaced with a single <code>delete</code> expression.</p>\n<i>C++14 (N3936 draft) \u00a75.3.4/10:</i>\n<blockquote>\n<p id=\"so_38680504_38680532_0\"><strong>\u201d</strong> An implementation is allowed to omit a call to a replaceable global allocation function (18.6.1.1, 18.6.1.2). When it does so, the storage is instead provided by the implementation or provided by extending the allocation of another <code>new</code>-expression. The implementation may extend the allocation of a <code>new</code>-expression <code>e1</code> to provide storage for a <code>new</code>-expression <code>e2</code> if the following would be true were the allocation not extended:<br>\n  \u2014 the evaluation of <code>e1</code> is sequenced before the evaluation of <code>e2</code>, and<br>\n  \u2014 <code>e2</code> is evaluated whenever <code>e1</code> obtains storage, and<br>\n  \u2014 both <code>e1</code> and <code>e2</code> invoke the same replaceable global allocation function, and<br>\n  \u2014 if the allocation function invoked by <code>e1</code> and <code>e2</code> is throwing, any exceptions thrown in the evaluation of either <code>e1</code> or <code>e2</code> would be first caught in the same handler, and<br>\n  \u2014 the pointer values produced by <code>e1</code> and <code>e2</code> are operands to evaluated <code>delete</code>-expressions, and<br>\n  \u2014 the evaluation of <code>e2</code> is sequenced before the evaluation of the <code>delete</code>-expression whose operand is the pointer value produced by <code>e1</code>.</br></br></br></br></br></br></p>\n</blockquote>\n", "LastActivityDate": "2016-07-31T03:45:21.970"}, "38680504": {"CommentCount": "0", "ViewCount": "78", "PostTypeId": "1", "LastEditorUserId": "3314069", "CreationDate": "2016-07-31T03:32:20.637", "LastActivityDate": "2016-07-31T04:02:14.700", "Title": "Does sequential 'new' operators make contiguous allocated memory?", "AcceptedAnswerId": "38680532", "LastEditDate": "2016-07-31T03:41:02.370", "Id": "38680504", "Score": "0", "Body": "<p>I heard std::vector is good because it guarantee contiguous allocated memory (cache-friendly). Then how about sequential 'new' operator like this?</p>\n<pre><code>{\n    new Test1();\n    new Test2();\n    new Test3();\n}\n</code></pre>\n<p>Does not it make contiguous allocated memory on heap?</p>\n", "Tags": "<c++>", "OwnerUserId": "3314069", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_38680504_38680532_0": {"section_id": 6091, "quality": 0.9625, "length": 77}}, "n4659": {"so_38680504_38680532_0": {"section_id": 7587, "quality": 0.9625, "length": 77}}}, "38680562": {"ParentId": "38680504", "CommentCount": "0", "CreationDate": "2016-07-31T03:44:27.940", "OwnerUserId": "3264977", "PostTypeId": "2", "Id": "38680562", "Score": "0", "Body": "<p>Memory management is really up to the operating system - at runtime, this is equivalent to calling the C <code>malloc</code> function several times in a row, i.e. contiguous allocation is not guaranteed (though likely). To guarantee that the objects are stored in a continuous memory block, they should be kept in an array.</p>\n<p>I'm not sure what application you're going for, but in most cases the speed-up from the cache-friendliness is far outweighed by the overhead of passing around objects. cache-friendliness only speeds up programs that are operating on large databases (e.g. mergesort of a long array) because the CPU doesn't need to shuffle the array into and out of cache rapidly - however, for small numbers of objects, you don't have to worry about the cache because its effect will be so tiny. If you're declaring each vector individually, and not as a block in an array, I'm guessing there aren't that many of them, so putting them into an array is not needed and will not speed up your program.</p>\n", "LastActivityDate": "2016-07-31T03:44:27.940"}});