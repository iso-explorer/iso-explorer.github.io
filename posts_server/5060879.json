post_cb({"5061030": {"ParentId": "5060879", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_5060879_5061030_0\">I believe the following are valid because complex_base is POD</p>\n</blockquote>\n<p>You are wrong. <code>d[0]</code> does not refer to the first member of a <code>complex_base</code> object. Its alignment may therefor not be good enough for a <code>complex_base</code> object, therefor such a cast is not safe (and not allowed by the text you quote). </p>\n<blockquote>\n<p id=\"so_5060879_5061030_1\">Does the following complete a valid cast to complex even though complex is NOT POD?</p>\n</blockquote>\n<p><code>cb1</code> and <code>cb2</code> do not point to subobjects of an object of type <code>complex</code>, therefor the <code>static_cast</code> produces undefined behavior. Refer to 5.2.9p5 of C++03</p>\n<blockquote>\n<p id=\"so_5060879_5061030_2\">If the lvalue of type \"cv1 B\" is actually a sub-object of an object of type D, the lvalue refers to the enclosing object of type D. Otherwise, the result of the cast is undefined. </p>\n</blockquote>\n<p>It's not enough if merely the types involved fit together. The text talks about a pointer pointing to a POD-struct object and about an lvalue referring to a certain subobject.\noth complex and complex_base are standard-layout objects. The C++0x spec says, instead of the text you quoted:</p>\n<h3>Is POD-ness requirement too strict?</h3>\n<p>This is a different question, not regarding your example code. Yes, requiring POD-ness is too strict. In C++0x this was recognized, and a new requirement which is more loose, \"standard-layout\" is given. I do think that both <code>complex</code> <em>and</em> <code>complex_base</code> are standard-layout classes, by the C++0x definition. The C++0x spec says, instead of the text you quoted:</p>\n<blockquote>\n<p id=\"so_5060879_5061030_3\">A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. </p>\n</blockquote>\n<p>I interpret that as allowing to cast a pointer to a <code>double</code>, which actually points to a <code>complex</code> member (member by inheritance), to be casted to a <code>complex*</code>. A Standard-layout class is one that either has no base classes containing non-static data, or has only one base-class containing non-static data. Thus there is an unique \"initial member\". </p>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2011-02-21T00:10:39.870", "Id": "5061030", "Score": "5", "CreationDate": "2011-02-20T23:58:59.360", "LastActivityDate": "2011-02-21T00:10:39.870"}, "5060879": {"CommentCount": "1", "ViewCount": "864", "PostTypeId": "1", "LastEditorUserId": "498253", "CreationDate": "2011-02-20T23:31:01.713", "LastActivityDate": "2011-02-21T16:52:38.637", "Title": "reinterpret_cast for almost pod data (is layout-compatibility enough)", "AcceptedAnswerId": "5061030", "LastEditDate": "2011-02-21T16:52:38.637", "Id": "5060879", "Score": "8", "Body": "<p>I am trying to learn about <code>static_cast</code> and <code>reinterpret_cast</code>.</p>\n<p>If I am correct the standard (9.2.18) says that <code>reinterpret_cast</code> for pod data is safe:</p>\n<blockquote>\n<p id=\"so_5060879_5060879_0\">A pointer to a POD-struct object,\n  suitably converted using a\n  <code>reinterpret_cast</code>, points to its\n  initial member (or if that member is a\n  bit-field, then to the unit in which\n  it resides) and vice versa. [ Note: There might therefore be unnamed\n  padding within a POD-struct object, but not at its beginning, as necessary to achieve \n  appropriate alignment. \u2014 end\n  note ]</p>\n</blockquote>\n<p><strong>My question is how strictly to interpret this.</strong> Is, for example, layout-compatibility enough? and if not, why not?</p>\n<p>To me, the following example shows an example where a strict 'only POD is valid' interpretation seems to be wrong.</p>\n<pre><code>class complex_base  // a POD-class (I believe)\n{\npublic:  \n  double m_data[2];\n};\n\nclass complex : public complex_base\n{  //Not a POD-class (due to constructor and inheritance)\npublic:\n  complex(const double real, const double imag); \n}\n\ndouble* d = new double[4];\n//I believe the following are valid because complex_base is POD\ncomplex_base&amp; cb1 = reinterpret_cast&lt;complex_base&amp;&gt;(d[0]);  \ncomplex_base&amp; cb2 = reinterpret_cast&lt;complex_base&amp;&gt;(d[2]);\n//Does the following complete a valid cast to complex even though complex is NOT POD?\ncomplex&amp; c1 = static_cast&lt;complex&amp;&gt;(cb1);\ncomplex&amp; c2 = static_cast&lt;complex&amp;&gt;(cb2);\n</code></pre>\n<p>Also, what can possibly break if <code>complex_base::m_data</code> is protected (meaning that <code>complex_base</code> is not pod)? [EDIT: and how do I protect myself/detect such breakages]</p>\n<p>It seems to me that layout-compatibility should be enough - but this does not seem to be what the standard says.</p>\n<p>EDIT: \nThanks for the answers.  They also helped me find this,\n<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2342.htm\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2342.htm</a></p>\n", "Tags": "<c++><reinterpret-cast><static-cast>", "OwnerUserId": "498253", "AnswerCount": "2"}, "5061027": {"ParentId": "5060879", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>What can break is that non-POD class instances may have vtable pointers, in order to implement virtual dispatch, if they have any virtual functions, including the virtual dtor. The vtbl pointer will typicaly be the first member of the non-POD class. </p>\n<p>(Technically, virtual dispatch doesn't have to implemented this way; practically it is. That's why the Standard has to be so strict about what qualifies as a POD type.)</p>\n<p>I'm honestly not sure why just having a ctor (\"8.5.1(1): \"An aggregate is an array or class (clause 9) with no user-declared constructors (12.1)\") disqualifies something from being a POD. But, it does.</p>\n<p>In the particular case you have here, of course, there's no need for a reinterpret cast. Instead, just add a conversion operator to the base class:</p>\n<pre><code>class complex_base  // a POD-class (I believe)\n{\npublic:  \n  double m_data[2];\n  operator double*() {\n    return m_data;\n  }\n};\n\n\ncomplex_base b; // create a complex_base\ndouble* p = b; \n</code></pre>\n<p>Since a complex_base isn't a double*, the C++ compiler will apply one (and only one) user-defined conversion operator in order to assign b to p. That means that <code>p = b</code> invokes the conversion operator, yielding <code>p = b.operator double*()</code> (and note that that's actually legal syntax -- you can directly call conversion operators, not that you should), which of course does whatever it does, in this case return m_data.</p>\n<p>Note that this is questionable, as we now have direct access to b's internals. In practice, we might return a const double*, or a copy, or a smart copy-on-write \"pointer\" or ....</p>\n<p>Of course, in this case, m_data is public anyway, so we're not worse off than if we just wrote:</p>\n<pre><code> double* p = b.m_data;\n</code></pre>\n<p>We are a bit better off, actually, because clients of complex_base don't need to know <em>how</em> to convert it to a double.</p>\n", "OwnerUserId": "85931", "LastEditorUserId": "85931", "LastEditDate": "2011-02-21T04:04:43.070", "Id": "5061027", "Score": "1", "CreationDate": "2011-02-20T23:58:49.660", "LastActivityDate": "2011-02-21T04:04:43.070"}, "bq_ids": {"n4140": {"so_5060879_5061030_2": {"section_id": 6028, "quality": 0.75, "length": 12}}, "n3337": {"so_5060879_5060879_0": {"section_id": 5650, "quality": 0.8611111111111112, "length": 31}, "so_5060879_5061030_2": {"section_id": 5796, "quality": 0.875, "length": 14}, "so_5060879_5061030_3": {"section_id": 5650, "quality": 1.0, "length": 19}}, "n4659": {"so_5060879_5061030_2": {"section_id": 7527, "quality": 0.75, "length": 12}}}});