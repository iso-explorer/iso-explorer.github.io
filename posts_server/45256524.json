post_cb({"45256525": {"ParentId": "45256524", "CommentCount": "0", "Body": "<h1>TL;DR</h1>\n<p>The global version of the operator is called when the allocated array has a length of 0. The compiler can't know the size of the array in advance (it's dynamic, after all), so it emits a check for 0 length just in case.</p>\n<h1>Digging in</h1>\n<p>To answer this, we'll have to dig into the disassembly. Here's the relevant bit (kindly generated by the <a href=\"https://godbolt.org/g/eaudRe\" rel=\"nofollow noreferrer\">Compiler Explorer</a> with version 19.10.25017 of the Visual C++ compiler), with some extra annotations:</p>\n<pre class=\"lang-none prettyprint-override\"><code>        ; Bail if we're deleting nullptr\n        test     rbx, rbx\n        je       SHORT $LN6@main\n\n        ; Subtract sizeof(size_t) from the pointer and compare to 0.\n        ; If 0, jump to the label below.\n        lea      rcx, QWORD PTR [rbx-8]\n        cmp      QWORD PTR [rcx], 0\n        je       SHORT $LN5@main\n\n        ; Load the vtbl address from the first element\n        mov      rax, QWORD PTR [rbx]\n\n        ; Set the second parameter to be some flags\n        mov      edx, 3\n\n        ; Set the first parameter to be the pointer\n        mov      rcx, rbx\n\n        ; Call destructor through the vtbl\n        call     QWORD PTR [rax]\n\n        ; All done\n        jmp      SHORT $LN6@main\n\n$LN5@main:\n        call     ??_V@YAXPEAX@Z   ; operator delete[]\n\n$LN6@main:\n        ; Function epilogue...\n</code></pre>\n<p>As can be seen from the disassembly, the global <code>operator delete[]</code> is called only when the number stored immediately before the array is 0. It's a pretty safe bet that this number is either the size of the allocation or the number of elements, but we can confirm this by looking at the disassembly once again:</p>\n<pre class=\"lang-none prettyprint-override\"><code>        ; Allocate 100 * sizeof(Derived) + sizeof(size_t)\n        mov      ecx, 808\n        call     malloc\n\n        ; ...\n\n        mov      r8d, 100\n\n        ; ...\n\n        mov      QWORD PTR [rax], r8\n</code></pre>\n<p>It's also clear why this check is necessary - if we allocated a 0-length array we can't dereference the first element to call the destructor. Changing the sample to allocate an empty array yields a call to the global <code>operator new[]</code>, so everything matches up.</p>\n<p>So there you have it. I don't know whether the call to the global operator can be avoided, but at least now we know the reason it's there.</p>\n<h1>Further exploration</h1>\n<p>Still, the situation feels a little off. Couldn't this have been implemented with a call to the class' <code>operator new[]</code>, eliminating the problem altogether? And another thing: where is the call to the class' <code>operator delete[]</code> in the non-0-length case?</p>\n<p>Let's answer the second question first. The call occurs inside <code>Derived::`vector deleting destructor'</code>, which is a wrapper around the user-defined destructor. Looking at the disassembly we can see that it either:</p>\n<ol>\n<li>Directly calls the \"real\" destructor of the object immediately followed by the class' <code>operator delete</code>, or</li>\n<li>Iterates over the array, calling the destructor for each element, and then calls the class' <code>operator delete[]</code>.</li>\n</ol>\n<p>(The determination whether destruction is being performed on a single object or on an array is made using the flags passed to the destructor.)</p>\n<p>Okay, so this is what makes it possible to call the correct version of the deallocation function in the presence of dynamic polymorphism (since the function is declared as <code>static</code>). From \u00a712.5.4 of the C++14 Standard:</p>\n<blockquote>\n<p id=\"so_45256524_45256525_0\">... If the <em>delete-expression</em> is used to deallocate a class object\n  whose static type has a virtual destructor, the deallocation function\n  is the one selected at the point of definition of the dynamic type's\n  virtual destructor ...</p>\n</blockquote>\n<p>However, in \u00a75.3.5.3 it says:</p>\n<blockquote>\n<p id=\"so_45256524_45256525_1\">... In the second alternative (<em>delete array</em>) if the dynamic type of the\n  object to be deleted differs from its static type, the behavior is\n  undefined.</p>\n</blockquote>\n<p>It would appear that Microsoft's implementation allows for polymorphic deletion of arrays, which is perfectly valid under UB.</p>\n<p>Clang and GCC, on the other hand, do pretty much what you'd expect from reading the Standard. Here's the output from GCC 7.1:</p>\n<pre class=\"lang-none prettyprint-override\"><code>.L13:\n        ; Loop over the array and call destructors\n        cmp     rbx, QWORD PTR [rbp-40]\n        je      .L12\n        sub     rbx, 8\n        mov     rax, QWORD PTR [rbx]\n        mov     rax, QWORD PTR [rax]\n        mov     rdi, rbx\n        call    rax\n        jmp     .L13\n.L12:\n        ; Call the class' operator delete[]\n        mov     rax, QWORD PTR [rbp-40]\n        sub     rax, 8\n        mov     rdi, rax\n        call    Base::operator delete[](void*)\n</code></pre>\n<p>This code is from <code>main</code>, not from any destructor wrapper. Since the compiler can assume that the program does not invoke UB, it can generate code that directly iterates over the array (since the size of each object is known at compile-time) and calls the correct version of <code>operator delete[]</code>. Of course, if we were to store the result of <code>new</code> in a <code>Base*</code> variable, the deletion would've segfaulted.</p>\n<p>And so, it is possible to implement array deletion using just the class version of the deallocation function. I do not know why Microsoft chose to implement array deletion the way they did, but because of this implementation we are now forced to supply global allocation and deallocation functions, or find other ways to allocate arrays.</p>\n", "OwnerUserId": "851560", "PostTypeId": "2", "Id": "45256525", "Score": "4", "CreationDate": "2017-07-22T16:00:57.507", "LastActivityDate": "2017-07-22T16:00:57.507"}, "45256524": {"CommentCount": "0", "ViewCount": "42", "CreationDate": "2017-07-22T16:00:57.507", "LastActivityDate": "2017-07-22T16:00:57.507", "Title": "Global operator delete[] referenced when class version is available", "AcceptedAnswerId": "45256525", "PostTypeId": "1", "Id": "45256524", "Score": "2", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;cstdlib&gt;\n\nclass Base\n{\npublic:\n    virtual ~Base() noexcept = default;\n\n    void* operator new[](size_t count) { return std::malloc(count); }\n    void operator delete[](void* ptr) { std::free(ptr); }\n};\n\nclass Derived : public Base\n{\n};\n\nint main()\n{\n    auto ptr = new Derived[100];\n    delete[] ptr;\n}\n</code></pre>\n<p>Compiling this with a recent version of MSVC in an environment which does not have a C++ runtime implementation (such as with the <code>/NODEFAULTLIB</code> switch) throws an unresolved external error for the global <code>operator delete[]</code>, even though a class version is available:</p>\n<pre><code>error LNK2019: unresolved external symbol \"void __cdecl operator delete[](void *)\" (??_V@YAXPEAX@Z) referenced in function main\n</code></pre>\n<p>However, when compiled <em>with</em> the C++ runtime, the class version of the operator is called as expected.</p>\n<p>What is going on here?</p>\n", "Tags": "<c++><visual-c++><c++14>", "OwnerUserId": "851560", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_45256524_45256525_0": {"section_id": 416, "quality": 1.0, "length": 19}, "so_45256524_45256525_1": {"section_id": 6107, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_45256524_45256525_0": {"section_id": 407, "quality": 1.0, "length": 19}, "so_45256524_45256525_1": {"section_id": 5873, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_45256524_45256525_0": {"section_id": 434, "quality": 1.0, "length": 19}, "so_45256524_45256525_1": {"section_id": 7604, "quality": 0.9285714285714286, "length": 13}}}});