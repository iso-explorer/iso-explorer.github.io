post_cb({"bq_ids": {"n4140": {"so_39704088_39704263_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 1861}, "so_39704088_39704263_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 2182}}, "n3337": {"so_39704088_39704263_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 1855}, "so_39704088_39704263_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 2170}}, "n4659": {"so_39704088_39704263_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 2033}, "so_39704088_39704263_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 2455}}}, "39707940": {"Id": "39707940", "PostTypeId": "2", "Body": "<p>Your code works.</p>\n<p>However, you may try seeking the stream and test the last character only or discard the characters read:</p>\n<pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;sstream&gt;\n\nbool StreamEndsWithNewline(std::basic_istream&lt;char&gt;&amp; stream) {\n    const auto Unlimited = std::numeric_limits&lt;std::streamsize&gt;::max();\n    bool result = false;\n    if(stream) {\n        if(std::basic_ios&lt;char&gt;::traits_type::eof() != stream.peek()) {\n            if(stream.seekg(-1, std::ios::end)) {\n                char c;\n                result = (stream.get(c) &amp;&amp; c == '\\n');\n                stream.ignore(Unlimited);\n            }\n            else {\n                stream.clear();\n                while(stream &amp;&amp; stream.ignore(Unlimited, '\\n')) {}\n                result = (stream.gcount() == 0);\n            }\n        }\n        stream.clear();\n    }\n    return result;\n}\n\nint main() {\n    std::cout &lt;&lt; \"empty\\n\";\n    std::istringstream empty;\n    assert(StreamEndsWithNewline(empty) == false);\n\n    std::cout &lt;&lt; \"empty_line\\n\";\n    std::istringstream empty_line(\"\\n\");\n    assert(StreamEndsWithNewline(empty_line) == true);\n\n    std::cout &lt;&lt; \"line\\n\";\n    std::istringstream line(\"Line\\n\");\n    assert(StreamEndsWithNewline(line) == true);\n\n    std::cout &lt;&lt; \"unterminated_line\\n\";\n    std::istringstream unterminated_line(\"Line\");\n    assert(StreamEndsWithNewline(unterminated_line) == false);\n\n    std::cout &lt;&lt; \"Please enter ctrl-D: (ctrl-Z on Windows)\";\n    std::cout.flush();\n    assert(StreamEndsWithNewline(std::cin) == false);\n    std::cout &lt;&lt; '\\n';\n\n    std::cout &lt;&lt; \"Please enter Return and ctrl-D (ctrl-Z on Windows): \";\n    std::cout.flush();\n    assert(StreamEndsWithNewline(std::cin) == true);\n    std::cout &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2016-09-26T16:32:07.387", "CommentCount": "0", "CreationDate": "2016-09-26T16:32:07.387", "ParentId": "39704088", "Score": "1", "OwnerUserId": "2249683"}, "39704088": {"ViewCount": "438", "Body": "<p>I want to check whether a stream (in practice an ifstream) ends with a newline. I have come up with this:</p>\n<pre><code>bool StreamEndsWithNewline(std::basic_istream&lt;char&gt; &amp; the_stream)\n{\n    if (the_stream.peek() == EOF) {\n        the_stream.clear(); //clear flags set by peek()\n        return false;\n    }\n    std::string line = \"blah\";\n    while (std::getline(the_stream, line)) {\n       // ...\n    }\n    return line.empty();\n}\n</code></pre>\n<p>The idea being that if the last line of the stream has a <code>\\n</code> ending character, the while loop will do one additional iteration (because eof has not been reached) in which the empty string will be assigned to the line argument.</p>\n<p>The special case of an \"empty\" stream has to be treated separately.</p>\n<p>It seems to work on windows (vs2010). Can I do it this way in general?</p>\n", "AcceptedAnswerId": "39704263", "Title": "Check if a stream ends with a newline", "CreationDate": "2016-09-26T13:22:51.337", "Id": "39704088", "CommentCount": "8", "LastEditDate": "2016-09-26T14:25:22.643", "PostTypeId": "1", "LastEditorUserId": "4573031", "LastActivityDate": "2016-09-26T16:32:07.387", "Score": "3", "OwnerUserId": "4573031", "Tags": "<c++><stream><ifstream><eof>", "AnswerCount": "2"}, "39704263": {"Id": "39704263", "PostTypeId": "2", "Body": "<p>tldr; Yes, this is guaranteed to work, unless the stream is initially empty. </p>\n<hr/>\n<p>There are two bits to consider: the <code>fail</code> bit and the <code>eof</code> bit. <code>std::getline</code> does, from [string.io]:</p>\n<blockquote>\n<p id=\"so_39704088_39704263_0\">After constructing a <code>sentry</code> object, if the\n  sentry converts to true, calls <code>str.erase()</code> and then extracts characters from is and appends them to <code>str</code> as if by calling <code>str.append(1, c)</code> [...] If the function extracts no characters, it calls <code>is.setstate(ios::failbit)</code></p>\n</blockquote>\n<p>And <code>sentry</code> does, from [istream::sentry]:</p>\n<blockquote>\n<p id=\"so_39704088_39704263_1\">Effects: If <code>is.good()</code> is <code>false</code>, calls <code>is.setstate(failbit)</code>. Otherwise, prepares for formatted or unformatted input. [...] If <code>is.rdbuf()-&gt;sbumpc()</code>\n  or <code>is.rdbuf()-&gt;sgetc()</code> returns <code>traits::eof()</code>, the function calls <code>setstate(failbit | eofbit)</code></p>\n</blockquote>\n<p>So given all of that, let's walk through two examples:</p>\n<hr/>\n<p>Case 1: <code>\"hello\\n\"</code>. The first call to <code>getline()</code>, <code>the_stream.good()</code> is true, we extract characters up through the <code>\\n</code>, the stream is still <code>good()</code>, and we enter the body of the loop with <code>line</code> set to <code>\"hello\"</code>. </p>\n<p>The second call to <code>getline()</code>, the stream is still <code>good()</code>, so the <code>sentry</code> object converts to true, and we call <code>str.erase()</code>. Attempting to extract subsequent characters fails, since we're done with the stream, so the <code>failbit</code> is set. This causes the return <code>getline()</code> to convert to false so we don't enter the body of the loop a second time. At the end of the loop, <code>line</code> is empty.</p>\n<hr/>\n<p>Case 2: <code>\"goodbye\"</code>, no newline. The first call to <code>getline()</code>, <code>the_stream.good()</code> is true, we extract characters until we hit <code>eof()</code>. The stream <code>failbit</code> isn't set yet, so we still enter the body of the loop, with line set to <code>\"goodbye\"</code>. </p>\n<p>The second call to <code>getline()</code>, the construction of the <code>sentry</code> object fails because <code>is.good()</code> is false (<code>is.good()</code> checks both the <code>eofbit</code> and the <code>failbit</code>). Because of this failure, we don't go into the first step of <code>getline()</code> which calls <code>str.erase()</code>. And because of this failure, the <code>failbit</code> is set so we again do not enter the body of the loop. </p>\n<p>At the end of the loop, <code>line</code> is still <code>\"goodbye\"</code>.</p>\n<hr/>\n<p>Case 3: <code>\"\"</code>. Here, <code>getline()</code> will extract no characters, so the <code>failbit</code> is set and the loop is never entered, and <code>line</code> is always empty. There are several ways to differentiate this case from case 1:</p>\n<ul>\n<li>You could, up front, <a href=\"http://en.cppreference.com/w/cpp/io/basic_istream/peek\" rel=\"nofollow\"><code>peek()</code></a> to see if the first character is <code>traits::eof()</code> before doing anything else. </li>\n<li>You could count how many times you enter the loop and check that it's nonzero.</li>\n<li>You could initialize <code>line</code> to some sentinel non-empty value. At the end of the loop, the line will only be empty if the stream ends with the delimeter. </li>\n</ul>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-09-26T14:11:04.180", "Score": "1", "CreationDate": "2016-09-26T13:30:44.423", "ParentId": "39704088", "CommentCount": "8", "OwnerUserId": "2069064", "LastEditDate": "2016-09-26T14:11:04.180"}});