post_cb({"bq_ids": {"n4140": {"so_43954667_43954745_2": {"section_id": 440, "quality": 0.8648648648648649, "length": 32}, "so_43954667_43954745_1": {"section_id": 440, "quality": 0.9, "length": 9}, "so_43954667_43954745_0": {"section_id": 429, "quality": 1.0, "length": 15}}, "n3337": {"so_43954667_43954745_2": {"section_id": 431, "quality": 0.8648648648648649, "length": 32}, "so_43954667_43954745_1": {"section_id": 431, "quality": 0.9, "length": 9}, "so_43954667_43954745_0": {"section_id": 421, "quality": 1.0, "length": 15}}, "n4659": {"so_43954667_43954745_1": {"section_id": 460, "quality": 0.9, "length": 9}, "so_43954667_43954745_2": {"section_id": 460, "quality": 0.8648648648648649, "length": 32}, "so_43954667_43954745_0": {"section_id": 447, "quality": 1.0, "length": 15}}}, "43954728": {"ParentId": "43954667", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Yes, this is a false positive: constructor parameters take precedence over members when evaluating expressions for member initialization list; at the same time, constructor parameters do not participate in the resolution process of member names, so everything works exactly the way you expect.</p>\n<p>Your point about this being a bad practice is perfectly valid as well.</p>\n", "OwnerUserId": "335858", "LastEditorUserId": "335858", "LastEditDate": "2017-05-13T15:17:45.667", "Id": "43954728", "Score": "2", "CreationDate": "2017-05-13T15:16:07.587", "LastActivityDate": "2017-05-13T15:17:45.667"}, "43954745": {"ParentId": "43954667", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is pretty valid, because they're in different scopes. For the member initializer list <code>A(A)</code>, the 1st <code>A</code> is in the scope of the class, then the data member <code>A</code> will be found; the 2nd <code>A</code> (which is putted in the parentheses) is in the scope of the constructor, then the parameter <code>A</code> will be found (and hide the data member with the same name).</p>\n<p>Quotes from the standard, </p>\n<p><a href=\"http://eel.is/c++draft/class.base.init#2\" rel=\"nofollow noreferrer\">$15.6.2/2 Initializing bases and members [class.base.init]</a>:</p>\n<blockquote>\n<p id=\"so_43954667_43954745_0\">In a mem-initializer-id an initial unqualified identifier is looked up in the scope of the constructor's class and, if not found in that scope, it is looked up in the scope containing the constructor's definition.</p>\n</blockquote>\n<p>and <a href=\"http://eel.is/c++draft/class.base.init#15\" rel=\"nofollow noreferrer\">$15.6.2/15 Initializing bases and members [class.base.init]</a>:</p>\n<blockquote>\n<p id=\"so_43954667_43954745_1\">Names in the expression-list or braced-init-list of a mem-initializer\n  are evaluated in the scope of the constructor for which the\n  mem-initializer is specified. [\u2009Example:</p>\n<pre><code>class X {\n  int a;\n  int b;\n  int i;\n  int j;\npublic:\n  const int&amp; r;\n  X(int i): r(a), b(i), i(i), j(this-&gt;i) { }\n};\n</code></pre>\n<p id=\"so_43954667_43954745_2\">initializes <code>X\u200b::\u200br</code> to refer to <code>X\u200b::\u200ba</code>, initializes <code>X\u200b::\u200b</code>b with the\n  value of the constructor parameter <code>i</code>, initializes <code>X\u200b::\u200bi</code> with the\n  value of the constructor parameter <code>i</code>, and initializes <code>X\u200b::\u200bj</code> with the\n  value of <code>X\u200b::\u200bi</code>; this takes place each time an object of class X is\n  created. \u2014\u2009end example\u2009] [\u2009Note: Because the mem-initializer are\n  evaluated in the scope of the constructor, the <code>this</code> pointer can be\n  used in the expression-list of a mem-initializer to refer to the\n  object being initialized. \u2014\u2009end note\u2009]</p>\n</blockquote>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2017-05-13T15:44:11.043", "Id": "43954745", "Score": "2", "CreationDate": "2017-05-13T15:18:21.903", "LastActivityDate": "2017-05-13T15:44:11.043"}, "43954705": {"ParentId": "43954667", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>They would be initialized correctly, as instructed in the initialization list.</p>\n<p>Indeed, compiling the code, gives:</p>\n<pre><code>Georgioss-MacBook-Pro:~ gsamaras$ g++ -Wall main.cpp\nmain.cpp:6:9: warning: private field 'A' is not used [-Wunused-private-field]\n    int A;\n        ^\nmain.cpp:7:9: warning: private field 'B' is not used [-Wunused-private-field]\n    int B;\n        ^\nmain.cpp:8:9: warning: private field 'C' is not used [-Wunused-private-field]\n    int C;\n        ^\n3 warnings generated.\n</code></pre>\n<p>where these warnings, are of course, irrelevant.</p>\n<hr>\n<p>Further reading: <a href=\"https://stackoverflow.com/questions/6185020/initializing-member-variables-using-the-same-name-for-constructor-arguments-as-f/6185043#6185043\">Initializing member variables using the same name for constructor arguments as for the member variables allowed by the C++ standard?</a></p>\n<hr>\n<blockquote>\n<p id=\"so_43954667_43954705_0\">I know that this is not good practice.</p>\n</blockquote>\n<p>It's not a bad one either. The trade off is that you do not introduce new names (such as the capital/lowercase thing one usually sees). I think it's a matter of opinion.</p>\n</hr></hr>", "OwnerUserId": "2411320", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:55:04.370", "Id": "43954705", "Score": "2", "CreationDate": "2017-05-13T15:13:14.053", "LastActivityDate": "2017-05-13T15:20:52.067"}, "43954667": {"CommentCount": "2", "ViewCount": "298", "PostTypeId": "1", "ClosedDate": "2017-05-13T15:21:03.690", "LastEditorUserId": "2411320", "CreationDate": "2017-05-13T15:09:58.720", "LastActivityDate": "2017-05-13T15:44:11.043", "Title": "Constructor argument and member with the same name", "LastEditDate": "2017-05-13T15:16:42.123", "Id": "43954667", "Score": "4", "Body": "<p>I'm curious if the following code is valid. Static analysis is giving an error on this constructor. </p>\n<blockquote>\n<p id=\"so_43954667_43954667_0\">Summary: Member variable 'A' is initialized by itself.</p>\n<p id=\"so_43954667_43954667_1\">Summary: Member variable 'B' is initialized by itself.</p>\n<p id=\"so_43954667_43954667_2\">Summary: Member variable 'C' is initialized by itself.</p>\n</blockquote>\n<pre><code>class Foo\n{\npublic:\n    Foo(int A, int B, int C);\nprivate:\n    int A;\n    int B;\n    int C;\n}\n\nFoo::Foo(int A, int B, int C) : \nA(A),\nB(B),\nC(C)\n{}\n</code></pre>\n<p>I know that this is not good practice and should probably be changed, however I would like to know if the static analysis warning is a false positive and the member variables would be initialized correctly. </p>\n", "Tags": "<c++><oop><language-lawyer><initialization-list>", "OwnerUserId": "1020484", "AnswerCount": "3"}});