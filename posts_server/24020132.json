post_cb({"24020132": {"CommentCount": "2", "ViewCount": "60", "CreationDate": "2014-06-03T16:20:11.187", "LastActivityDate": "2014-06-03T17:02:45.797", "Title": "Problems with the conversion operator and function lookup", "AcceptedAnswerId": "24020751", "PostTypeId": "1", "Id": "24020132", "Score": "1", "Body": "<p>I have a class, let's call it <code>Wrapper</code>, that wraps a given type, let's say <code>MyClass</code>.\nIn reality, <code>Wrapper</code> is a class template, but I think that's not relevant here.</p>\n<p><code>Wrapper</code> exposes the wrapped <code>MyClass</code> by means of a conversion operator (just for reading).</p>\n<p>When I create an operator for <code>MyClass</code> as free function (in my example a unary minus operator), this works as expected, I can use the operator also on the <code>Wrapper</code> class.</p>\n<p>If I, however, implement the operator as a member function, the compiler complains: <code>error: no match for \u2018operator-\u2019</code>.</p>\n<p>I thought the free function and the member function are equivalent in this case, why aren't they?</p>\n<p>Is there a way to change the <code>Wrapper</code> class that a member operator or <code>MyClass</code> works?</p>\n<p>If there isn't, does this suggest that it is in general preferable to implement an operator as free function instead of as member function?</p>\n<p>Here's some code to illustrate the problem.</p>\n<pre><code>struct MyClass {\n  // This doesn't work:\n  void operator-() const {}\n};\n\n// It works with this instead of the member operator:\n//void operator-(const MyClass&amp;) {}\n\nstruct Wrapper {\n  operator MyClass() const { return MyClass(); }\n};\n\nint main() {\n  -Wrapper();\n}\n</code></pre>\n<p>Here's a live example: <a href=\"http://ideone.com/nY6JzR\" rel=\"nofollow\">http://ideone.com/nY6JzR</a></p>\n", "Tags": "<c++><type-conversion>", "OwnerUserId": "500098", "AnswerCount": "2"}, "24020803": {"ParentId": "24020132", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_24020132_24020803_0\">I thought the free function and the member function are equivalent in\n  this case, why aren't they?</p>\n</blockquote>\n<p>Lets see what happens when a conversion operator is used.</p>\n<p>Essentially, there is a global operator function, which has a parameter of type <code>MyClass</code>. Now, since Wrapper has a conversion operator, the call <code>operator-( Wrapper() )</code> will be inspected by overload resolution to find the best match - and overload resolution finds that there is a global operator function with parameter <code>MyClass const&amp;</code> (or similiar). Then it tries to convert the <code>Wrapper</code> prvalue to <code>MyClass const&amp;</code> and sees that there is a user-defined conversion sequence: One that uses the conversion operator to convert the Wrapper-object to a <code>MyClass</code> object, which then can be used to (copy-)initialize the reference.</p>\n<p>If the operator function is a member instead, there is a problem: A global function call of the form <code>operator-( Wrapper() )</code> does obviously not yield any viable functions. But the one that assumes the operator function is a member doesn't yield anything either - because <code>operator-</code> is not a member of <code>Wrapper</code>, therefore <code>Wrapper().operator-()</code> doesn't work and doesn't yield any viable functions either. </p>\n<p>Remember: A class with a conversion operator does not inherit the members of the target type. If you wanted that, you should have inherited <code>MyClass</code>.</p>\n<blockquote>\n<p id=\"so_24020132_24020803_1\">For a unary operator <code>@</code> with an operand of a type whose cv-unqualified\n  version is <code>T1</code> [...] three sets of candidate functions, designated\n  <em>member candidates</em>, <em>non-member candidates</em> and <em>built-in candidates</em>, are\n  constructed as follows:</p>\n<ul>\n<li>If T1 is a complete class type, the set of member candidates is the\n  result of the qualified lookup of <code>T1::operator@</code> (13.3.1.1.1);\n  otherwise, the set of member candidates is empty.</li>\n<li>The set of non-member candidates is the result of the unqualified lookup of\n  <code>operator@</code> in the context of the expression according to the usual\n  rules for name lookup in unqualified function calls (3.4.2) except\n  that all member functions are ignored. [...]</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2014-06-03T17:01:45.953", "Id": "24020803", "Score": "1", "CreationDate": "2014-06-03T16:56:10.317", "LastActivityDate": "2014-06-03T17:01:45.953"}, "24020751": {"ParentId": "24020132", "PostTypeId": "2", "CommentCount": "3", "Body": "<p><strong>Question</strong> I thought the free function and the member function are equivalent in this case, why aren't they?</p>\n<p><strong>Answer</strong></p>\n<p>In order for <code>-Wrapper()</code> to work correctly, the compiler has to perform a lookup for <code>operator-</code>. It looks for the name <code>operator-</code> in the default namespace, in the class <code>Wrapper</code>, and the namespace where <code>Wrapper</code> is defined. It doesn't look at other classes and namespaces for the name.</p>\n<p>That explains the compiler error when the <code>operator-()</code> is moved to <code>MyClass</code> and why it succeeds when it is defined as a non-member function.</p>\n<p><strong>Question</strong> Is there a way to change the <code>Wrapper</code> class that a member operator or <code>MyClass</code> works?</p>\n<p><strong>Answer</strong> There are two ways to resolve this.</p>\n<ol>\n<li><p>Make the operator functions for <code>MyClass</code> non-member functions.</p></li>\n<li><p>Create operator functions in <code>MyClass</code> as well as <code>Wrapper</code>, with the implementations in <code>Wrapper</code> being simple pass through functions. The good thing about this is that then you don't have to care whether the operator functions in <code>MyClass</code> are member functions or non-member functions.</p></li>\n</ol>\n<p><strong>Question</strong> If there isn't, does this suggest that it is in general preferable to implement an operator as free function instead of as member function?</p>\n<p><strong>Answer</strong> This can be a policy decision based on the choice you make to the previous answer. </p>\n", "OwnerUserId": "434551", "LastEditorUserId": "434551", "LastEditDate": "2014-06-03T17:02:45.797", "Id": "24020751", "Score": "1", "CreationDate": "2014-06-03T16:53:23.513", "LastActivityDate": "2014-06-03T17:02:45.797"}, "bq_ids": {"n4140": {"so_24020132_24020803_1": {"section_id": 584, "quality": 0.8095238095238095, "length": 17}}, "n3337": {"so_24020132_24020803_1": {"section_id": 574, "quality": 0.8095238095238095, "length": 17}}, "n4659": {"so_24020132_24020803_1": {"section_id": 607, "quality": 0.8095238095238095, "length": 17}}}});