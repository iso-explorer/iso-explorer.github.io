post_cb({"6362324": {"ViewCount": "282", "Body": "<p>lets say I have </p>\n<pre><code>class : foo\n{\n  public:\n  static const foo Invalidfoo;\n  foo();\n  foo(int, string);\n  private:\n  int number;\n  std::string name;\n};\n</code></pre>\n<p>Is it safe or prone to any problem?  </p>\n<p>EDIT :</p>\n<p>I want to use this to have an invalid object to return as a reference to launch errors.</p>\n", "AcceptedAnswerId": "6362830", "Title": "Can a static member of a class as the same type as the class it is member of in C++", "CreationDate": "2011-06-15T18:13:26.557", "Id": "6362324", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-06-15T18:36:59.550", "LastEditorUserId": "256138", "LastActivityDate": "2011-06-16T08:46:54.553", "Score": "1", "OwnerUserId": "261842", "Tags": "<c++><class><static>", "AnswerCount": "6"}, "6362830": {"Id": "6362830", "PostTypeId": "2", "Body": "<p>It is perfectly legal, but the following is better:</p>\n<pre><code>class foo:\n{\npublic:\n    static const&amp; foo Invalidfoo()\n    {\n        static foo Invalidfoo_;\n        return Invalidfoo_;\n    }\n\nprivate:\n      foo();\n};\n</code></pre>\n<p>This way you are guaranteed that the object is initialized the first time it is used.</p>\n<p>Edit: But no matter how you do it, you still have a global object, and that can be a cause of problem. The best solution may be to call the default constructor each time you need a default constructed object. In terms of efficiency, the difference is probably negligable.</p>\n", "LastEditorUserId": "763305", "LastActivityDate": "2011-06-16T08:46:54.553", "Score": "3", "CreationDate": "2011-06-15T18:57:58.503", "ParentId": "6362324", "CommentCount": "0", "OwnerUserId": "763305", "LastEditDate": "2011-06-16T08:46:54.553"}, "6362357": {"Id": "6362357", "PostTypeId": "2", "Body": "<p>It is just acting like a global variable or singleton. It's prone to the problems relating to those.</p>\n", "LastActivityDate": "2011-06-15T18:15:46.007", "CommentCount": "0", "CreationDate": "2011-06-15T18:15:46.007", "ParentId": "6362324", "Score": "1", "OwnerUserId": "23528"}, "6362354": {"Id": "6362354", "PostTypeId": "2", "Body": "<p>It's legal.  </p>\n<p>It's actually widely used in the <a href=\"http://en.wikipedia.org/wiki/Singleton_pattern\" rel=\"nofollow\"><strong>singleton pattern</strong></a></p>\n<p>Singletons multi threading access and creation problems. </p>\n<p>A nice article about this:</p>\n<p><a href=\"http://erdani.com/publications/DDJ_Jul_Aug_2004_revised.pdf\" rel=\"nofollow\"><strong>C++ and the Perils of Double-Checked Locking</strong></a></p>\n", "LastActivityDate": "2011-06-15T18:15:43.807", "CommentCount": "0", "CreationDate": "2011-06-15T18:15:43.807", "ParentId": "6362324", "Score": "3", "OwnerUserId": "536086"}, "bq_ids": {"n4140": {"so_6362324_6362427_0": {"length": 15, "quality": 0.9375, "section_id": 5906}}, "n3337": {"so_6362324_6362427_0": {"length": 15, "quality": 0.9375, "section_id": 5678}}, "n4659": {"so_6362324_6362427_0": {"length": 15, "quality": 0.9375, "section_id": 7388}}}, "6362427": {"Id": "6362427", "PostTypeId": "2", "Body": "<p>That is perfectly valid code. It doesn't have any reason to cause any problem, because static data members don't contribute to the size of the class. No matter how many static data members you define in a class, it doesn't change its size by even one byte!</p>\n<pre><code>struct A\n{\n   int i;\n   char c;\n};\n\nstruct B\n{\n   int i;\n   char c;\n   static A a;\n   static B b;\n};\n</code></pre>\n<p>In above code, <code>sizeof(A) == sizeof(B)</code> will always be true. See this demo:</p>\n<ul>\n<li><a href=\"http://www.ideone.com/nsiNL\" rel=\"nofollow noreferrer\">http://www.ideone.com/nsiNL</a></li>\n</ul>\n<p>Its supported by the section $9.4.2/1 from the C++ Standard (2003),</p>\n<blockquote>\n<p id=\"so_6362324_6362427_0\">A static data member <strong>is not part of</strong>\n  the subobjects of a class. There <strong>is\n  only one copy of</strong> a static data member\n  shared by all the objects of the\n  class.</p>\n</blockquote>\n<p>You cannot define <em>non-static</em> data member of the enclosing class type, because non-static members are parts of the object, and so they do contribute to the size of the class. It causes problem when calculating the size of the class, due to recursive nature of the data members.</p>\n<hr>\n<p>See this topic:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/4640989/how-do-static-member-variables-affect-object-size\">How do static member variables affect object size?</a></li>\n</ul>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2011-06-15T18:34:19.300", "Score": "1", "CreationDate": "2011-06-15T18:21:10.097", "ParentId": "6362324", "CommentCount": "0", "OwnerUserId": "415784", "LastEditDate": "2017-05-23T12:15:47.903"}, "6362447": {"Id": "6362447", "PostTypeId": "2", "Body": "<p>It's legal. Terrible code from a practical/style point of view, but it is legal, and technically, it can be made to work. Better than Singleton because it's immutable.</p>\n", "LastActivityDate": "2011-06-15T18:22:31.503", "CommentCount": "0", "CreationDate": "2011-06-15T18:22:31.503", "ParentId": "6362324", "Score": "0", "OwnerUserId": "298661"}, "6363932": {"Id": "6363932", "PostTypeId": "2", "Body": "<p>This is actually how a singleton is implemented, except your static member would be a pointer.  So yes, you're safe.</p>\n", "LastActivityDate": "2011-06-15T20:28:04.240", "CommentCount": "0", "CreationDate": "2011-06-15T20:28:04.240", "ParentId": "6362324", "Score": "0", "OwnerUserId": "647242"}});