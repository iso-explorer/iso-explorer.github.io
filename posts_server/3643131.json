post_cb({"3643131": {"AcceptedAnswerId": "3643158", "Tags": "<c++>", "AnswerCount": "1", "OwnerUserId": "426051", "Body": "<p>I saw below thing about switch statement in c++ standard $6.4.2.</p>\n<p>Switch statement can take a condition.</p>\n<blockquote>\n<p id=\"so_3643131_3643131_0\">The condition shall be of integral type, enumeration type, or of a class type for which a single conversion function to\n  integral or enumeration type exists (12.3). If the condition is of class type, the condition is converted by calling that\n  conversion function, and the result of the conversion is used in place of the original condition for the remainder of this\n  section</p>\n</blockquote>\n<p>I tried below code which is working fine.</p>\n<pre><code>class Test\n{\npublic:\n    operator int() { return 1; }\n};\n\nint main()\n{\n     Test obj;\n     switch(obj)\n     {\n        case 1: cout&lt;&lt;\"Test class object\";\n        break;\n     }\n}\n</code></pre>\n<p>Is this a better way compared to using a typeid operator to find the object type ? </p>\n<p>In switch case way, the overhead is each class should have a unique integer id which will be returned by conversion function.</p>\n<p>In typeid way, if we use like typeid(obj) == typeid(Test), if else chain will be lengthy when we have many class types. Code readability decreases. May be its slower as well compared to switch case, as switch case may be implemented like a jump table by Compiler</p>\n<p>So, which way is better to find the object type at runtime ?</p>\n<p>EDIT: corrected question considering Andrey's comments.</p>\n", "CommentCount": "5", "PostTypeId": "1", "CreationDate": "2010-09-04T16:40:12.977", "ViewCount": "12001", "LastActivityDate": "2013-06-10T23:59:52.183", "Id": "3643131", "LastEditorUserId": "426051", "Title": "Using class type in switch statement: is it better than using typeid operator?", "Score": "3", "LastEditDate": "2010-09-04T17:20:59.930"}, "bq_ids": {"n3337": {"so_3643131_3643131_0": {"section_id": 3750, "quality": 0.9354838709677419, "length": 29}}}, "3643158": {"LastActivityDate": "2013-06-10T23:59:52.183", "LastEditorUserId": "187690", "ParentId": "3643131", "LastEditDate": "2013-06-10T23:59:52.183", "Id": "3643158", "Score": "7", "Body": "<p>Where did you get the idea that \"string comparison has to be performed\"? In order to determine if two <code>type_info</code> objects designate the same type, you need to compare these <code>type_info</code> objects directly, as in <code>typeid(obj) == typeid(Test)</code>. </p>\n<p>In fact, you <em>cannot</em> do the same tings by comparing the strings returned by <code>type_info::name()</code> member simply because the language makes no guarantees about these strings at all. More specifically, it makes no guarantees about the uniqueness of these strings for each given type. They all can return <code>\"Hello World!\"</code> for all types. Or they can return an empty string for all types. Usually the implementations behave nicer than that, but in any case the <code>name()</code> member is there for some potential debugging/informational purposes. You cannot meaningfully rely on <code>type_info::name()</code> in the actual functionality of your code.</p>\n<p>Also, the language standard says that <code>type_info</code> objects are lvalue objects with static storage duration. I'd expect these <code>type_info</code> object to maintain their \"address identity\" for each specific type (although I'm not sure the standard actually guarantees that). I.e. I'd expect that <code>&amp;typeid(type) == &amp;typeid(type)</code> is always true (i.e. every time you invoke <code>typeid</code> for the same type, you get the same lvalue as the result). If so, you can compare the <em>addresses</em> of <code>type_info</code> objects instead of comparing them using the <code>==</code> operator. You can also use the addresses to build some more complicated data structure for type matching, like an associative array. You can't use <code>switch/case</code> with it though. (And again, I'm not sure my assumption about stable address identity of <code>type_info</code> is valid). In fact it is not. As Johannes Schaub noted in the comments, the correct way to put <code>type_info</code>s into an ordered container is to use the <code>type_info::before()</code> to establish ordering.</p>\n<p>Of course, in your specific case using a manually implemented integer identifier for the class  (if you really really need to go that way) might be much more efficient. It also allows you a greater flexibility to implement your intent better. For example, <code>typeid(Test) == typeid(const Test)</code> will evaluate to <code>false</code>, which might not be what you want. However, highjacking the conversion operator to such a basic type as <code>int</code> for that purpose is definitely not a good idea. If you really need it, make it a named method and return something named, not a \"magic constant\".</p>\n", "CommentCount": "2", "PostTypeId": "2", "OwnerUserId": "187690", "CreationDate": "2010-09-04T16:47:19.550"}});