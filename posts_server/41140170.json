post_cb({"bq_ids": {"n4140": {"so_41140170_41149207_1": {"length": 6, "quality": 0.75, "section_id": 4394}, "so_41140170_41149207_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 6276}}, "n3337": {"so_41140170_41149207_1": {"length": 6, "quality": 0.75, "section_id": 4231}, "so_41140170_41149207_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 6036}}, "n4659": {"so_41140170_41149207_1": {"length": 5, "quality": 0.625, "section_id": 4289}, "so_41140170_41149207_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 7783}, "so_41140170_41149207_2": {"length": 6, "quality": 0.5454545454545454, "section_id": 5664}}}, "41140170": {"ViewCount": "137", "Body": "<p>Given that <code>a</code> and <code>b</code> are of type <code>T</code>, and we have either move construction (<code>T b(move(a));</code>) or move assignment (<code>b = move(a)</code>). In what cases do we know what the value of <code>a</code> will be?</p>\n<p>The only one that I know of for sure is <code>unique_ptr</code>, in which <code>a</code> will become an empty pointer. Is this also guaranteed for <code>shared_ptr</code>? Are there any other classes for which the standard guarantees a known value?</p>\n", "AcceptedAnswerId": "41149207", "Title": "C++: For which objects, being \"moved\" implies more than \"staying valid\"?", "CreationDate": "2016-12-14T10:24:12.730", "Id": "41140170", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-12-14T18:42:43.930", "LastEditorUserId": "734069", "LastActivityDate": "2016-12-14T18:42:43.930", "ClosedDate": "2016-12-14T18:43:22.980", "Score": "4", "OwnerUserId": "1964342", "Tags": "<c++11><shared-ptr><move-semantics><c++-standard-library>", "AnswerCount": "1"}, "41149207": {"Id": "41149207", "PostTypeId": "2", "Body": "<p><strong>Standard library types</strong></p>\n<p>From the standard N4296,\u00a717.6.3.1, let's <code>rv</code> be an rvalue of type <code>T</code>,\nin Table 20, MoveConstructible requirement and Table 22 MoveAssignable requirement.</p>\n<p>After operations:</p>\n<pre><code>T(rv);\nT u =rv;\nu = rv;\n</code></pre>\n<blockquote>\n<p id=\"so_41140170_41149207_0\">rv\u2019s state is unspecified [ Note:rv must still meet the requirements of the library component that is using it. The operations listed in those requirements must work as specified\n  whether rv has been moved from or not. \u2014 end note ]</p>\n</blockquote>\n<p>It means that at least your moved object is still in a valid state and can be used as any object of its type. But nothing more is required as a library wide requirement. You have to read specific documentation.</p>\n<p>For shared_ptr specificaly :</p>\n<pre><code>shared_ptr(shared_ptr&amp;&amp; r) noexcept;\ntemplate&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;\n</code></pre>\n<blockquote>\n<p id=\"so_41140170_41149207_1\">Remark: The second constructor shall not participate in overload resolution unless Y* is convertible\n  to T*.</p>\n<p id=\"so_41140170_41149207_2\">Effects: Move-constructs a shared_ptr instance from r.\n  Postconditions: *this shall contain the old value of r. r shall be empty. r.get() == nullptr.</p>\n</blockquote>\n<p><strong>Fundamental types and trivially copyables</strong></p>\n<p>The moved object should be unchanged. I am looking for the confirmation in the standard...</p>\n<p><strong>Other types</strong></p>\n<p>At least the programmer of a class shall ensures that an object of this class is destructible after it has been moved!</p>\n", "LastEditorUserId": "5632316", "LastActivityDate": "2016-12-14T18:38:19.227", "Score": "1", "CreationDate": "2016-12-14T18:03:57.103", "ParentId": "41140170", "CommentCount": "0", "OwnerUserId": "5632316", "LastEditDate": "2016-12-14T18:38:19.227"}});