post_cb({"24656212": {"CommentCount": "1", "ViewCount": "329", "PostTypeId": "1", "LastEditorUserId": "508343", "CreationDate": "2014-07-09T14:18:49.023", "LastActivityDate": "2014-07-09T14:43:40.783", "Title": "Why does gcc complain \"error: type 'intT' of template argument '0' depends on a template parameter\"?", "AcceptedAnswerId": "24656420", "LastEditDate": "2014-07-09T14:43:21.427", "Id": "24656212", "Score": "2", "Body": "<p>My compiler is gcc 4.9.0. The following code cannot be compiled: </p>\n<pre><code>template&lt;typename T, T i&gt;\nstruct value {};\n\ntemplate&lt;typename T&gt;\nstruct value&lt;T, 0&gt; {};\n// error: type 'T' of template argument '0' depends on a template parameter\n</code></pre>\n<p>What is the cause? and, how to solve this issue?</p>\n", "Tags": "<c++><templates><c++11><variadic-templates><template-meta-programming>", "OwnerUserId": "508343", "AnswerCount": "1"}, "24656420": {"ParentId": "24656212", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>GCC is right, this is explicitly forbidden by C++11 [temp.class.spec] \u00a78:</p>\n<blockquote>\n<p id=\"so_24656212_24656420_0\">8 Within the argument list of a class template partial specialization, the following restrictions apply:</p>\n<ul>\n<li><p id=\"so_24656212_24656420_1\">A partially specialized non-type argument expression shall not involve a template parameter of the\n  partial specialization except when the argument expression is a simple <em>identifier.</em> [ <em>Example:</em></p>\n<pre><code>template &lt;int I, int J&gt; struct A {};\ntemplate &lt;int I&gt; struct A&lt;I+5, I*2&gt; {}; // error\ntemplate &lt;int I, int J&gt; struct B {};\ntemplate &lt;int I&gt; struct B&lt;I, I&gt; {}; // OK\n</code></pre>\n<p id=\"so_24656212_24656420_2\"><em>\u2014end example</em> ]</p></li>\n<li><p id=\"so_24656212_24656420_3\">The type of a template parameter corresponding to a specialized non-type argument shall not be\n  dependent on a parameter of the specialization. [ <em>Example:</em></p>\n<pre><code>template &lt;class T, T t&gt; struct C {};\ntemplate &lt;class T&gt; struct C&lt;T, 1&gt;; // error\ntemplate&lt; int X, int (*array_ptr)[X] &gt; class A {};\nint array[5];\ntemplate&lt; int X &gt; class A&lt;X,&amp;array&gt; { }; // error\n</code></pre>\n<p id=\"so_24656212_24656420_4\"><em>\u2014end example</em> ]</p></li>\n<li><p id=\"so_24656212_24656420_5\">...</p></li>\n</ul>\n</blockquote>\n<p>I believe point 2 is the most relevant one here.</p>\n<hr>\n<p>Regarding the question of \"how to solve this issue.\" In the form the question stands now, there is no workaround, I am afraid.</p>\n<p>As for the original vesion with making integer sequences, I <em>believe</em> that you could make it work with using <code>uintmax_t</code> for the type of the non-type template parameter, and only convert it to <code>intT</code> in the final definition.</p>\n</hr>", "OwnerUserId": "1782465", "LastEditorUserId": "1782465", "LastEditDate": "2014-07-09T14:43:40.783", "Id": "24656420", "Score": "7", "CreationDate": "2014-07-09T14:27:36.640", "LastActivityDate": "2014-07-09T14:43:40.783"}, "bq_ids": {"n4140": {"so_24656212_24656420_3": {"section_id": 142, "quality": 0.8333333333333334, "length": 10}, "so_24656212_24656420_0": {"section_id": 142, "quality": 1.0, "length": 10}, "so_24656212_24656420_1": {"section_id": 142, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_24656212_24656420_3": {"section_id": 136, "quality": 0.8333333333333334, "length": 10}, "so_24656212_24656420_0": {"section_id": 136, "quality": 1.0, "length": 10}, "so_24656212_24656420_1": {"section_id": 136, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_24656212_24656420_3": {"section_id": 146, "quality": 0.8333333333333334, "length": 10}, "so_24656212_24656420_0": {"section_id": 146, "quality": 1.0, "length": 10}}}});