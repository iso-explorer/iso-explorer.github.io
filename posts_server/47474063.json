post_cb({"bq_ids": {"n4140": {"so_47474063_47475066_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 715}}, "n3337": {"so_47474063_47475066_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 704}}, "n4659": {"so_47474063_47475066_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 745}}}, "47475066": {"Id": "47475066", "PostTypeId": "2", "Body": "<p>According to the <a href=\"http://en.cppreference.com/w/cpp/container/vector/push_back\" rel=\"nofollow noreferrer\">documentation</a>, <code>push_back</code> requires the value type to be either <code>CopyInsertable</code> or <code>MoveInsertable</code>. Let's see the <a href=\"http://en.cppreference.com/w/cpp/concept/CopyInsertable\" rel=\"nofollow noreferrer\">definition</a>:</p>\n<blockquote>\n<p id=\"so_47474063_47475066_0\">The type T is <strong>CopyInsertable</strong> into the container <strong>X</strong> whose value_type is identical to <strong>T</strong> if <strong>T</strong> is MoveInsertable into X, and, given [...] the following expression is well-formed:</p>\n<pre><code>std::allocator_traits&lt;A&gt;::construct(m, p, v);\n</code></pre>\n</blockquote>\n<p>So in the case of a C-array, one has, for the standard allocator, an expression <a href=\"http://en.cppreference.com/w/cpp/memory/allocator/construct\" rel=\"nofollow noreferrer\">like</a> </p>\n<pre><code>::new((void *)p) int[3](std::forward&lt;int[3]&gt;(v))\n</code></pre>\n<p>where v is of the array type. This is ill-formed, according to the <a href=\"http://en.cppreference.com/w/cpp/language/new\" rel=\"nofollow noreferrer\">specification of new</a>:</p>\n<blockquote id=\"so_47474063_47475066_1\">\n<ul>\n<li>If type is an array type, an array of objects is initialized. \n  \n  <ul>\n<li>If initializer is absent, each element is default-initialized</li>\n<li>If initializer is an empty pair of parentheses, each element is value-initialized. </li>\n<li>If initializer is a brace-enclosed list of arguments, the array is aggregate-initialized. </li>\n</ul></li>\n</ul>\n</blockquote>\n<p>There is no syntax for array types allowing for non-empty parantheses.</p>\n<p>The argumentation goes quite similarily with the <code>MoveInsertable</code> category.\nAll in all, the proposed solution would be the (already mentioned) use of <code>std::array</code> which is itself not of array type and therefore can be initialized properly by the syntax taken by standard allocators' <code>construct</code> function.</p>\n<p>One final note: the strict aliasing rules only allow for conversions of any type with <code>unsigned char</code>, <code>signed char</code> or <code>char</code>. While almost certain that <code>std::uint8_t</code> is just an alias typedef on one of those in your implementation, there is no guarantee in the standard for this.</p>\n", "LastEditorUserId": "7703564", "LastActivityDate": "2017-11-24T14:18:26.807", "Score": "4", "CreationDate": "2017-11-24T14:13:22.937", "ParentId": "47474063", "CommentCount": "0", "OwnerUserId": "7703564", "LastEditDate": "2017-11-24T14:18:26.807"}, "47474063": {"ViewCount": "92", "Body": "<p>I have an alias to a static-sized array, using it is easy and straightforward:</p>\n<pre><code>using triplet_t = std::uint8_t[3];\n\n//           vvvvvvvvvvvvvvvvvv &lt;--- easier than std::uint8_t(&amp;triplet)[3]\nvoid f(const triplet_t &amp;triplet) { /* whatever */ }\n\ntriplet_t t{}; // As good as std::uint8_t t[3]{};\n\nt[0] = '0';\nt[1] = '1';\nt[2] = '2';\nfor (auto &amp;v : t) std::cout &lt;&lt; v &lt;&lt; ' ';\nstd::cout &lt;&lt; '\\n';\n\n// So far so good...\ntriplet_t t3[3]{};\nfor (auto &amp;r : t3)\n    for(auto &amp;v : r)\n        v = 42;\n</code></pre>\n<p>I can even use the alias in containers:</p>\n<pre><code>std::vector&lt;triplet_t&gt; vt;\n</code></pre>\n<p>Or so I used to think, because as soon as you use <code>vt</code> it fails:</p>\n<pre><code>vt.push_back({});\n</code></pre>\n<blockquote>\n<p id=\"so_47474063_47474063_0\">GCC 8.0.0 201711</p>\n<pre><code>error: parenthesized initializer in array new [-fpermissive]\n{ ::new((void *)__p) _Up(std::forward&lt;_Args&gt;(__args)...); }\n  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: request for member '~unsigned char [3]' in '* __p', which is of non-class type 'unsigned char [3]'\ndestroy(_Up* __p) { __p-&gt;~_Up(); }\n                    ~~~~~~^~~\n</code></pre>\n</blockquote>\n<p>The issue seems to be that after unrolling all the template trickery a placement-new is called forwarding all the parameters provided parenthesized, and obviously this is not the way to initialize a static-sized array.</p>\n<p>Also, somehow the container thinks of <code>triplet_t</code> as an object and hence is asking for a destructor, failing again to compile. The issue is obviously the same without the alias:</p>\n<pre><code>std::vector&lt;std::uint8_t[3]&gt; vt;\nvt.push_back({});          // Boom!\nvt.push_back({255, 0, 0}); // Ouch!\n</code></pre>\n<p>But no problem using a <code>struct</code> with the same memory layout:</p>\n<pre><code>struct rgb { std::uint8_t r, g, b; };\nstd::vector&lt;rgb&gt; vt;\nvt.push_back({});          // Nice!\nvt.push_back({255, 0, 0}); // Cool!\n</code></pre>\n<p>I wonder why this happens, is there a way to use static-sized arrays as contained type in containers?</p>\n", "AcceptedAnswerId": "47475066", "Title": "Why static-sized array type cannot be a container type?", "CreationDate": "2017-11-24T13:11:19.877", "Id": "47474063", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2017-11-24T14:18:26.807", "Score": "3", "OwnerUserId": "499359", "Tags": "<c++><stl><containers>", "AnswerCount": "2"}, "47474400": {"Id": "47474400", "PostTypeId": "2", "Body": "<p>Reading <a href=\"http://en.cppreference.com/w/cpp/container/vector\" rel=\"nofollow noreferrer\"><code>std::vector</code> documentaion</a>, you can find that <code>T</code> must meet the requirements of <a href=\"http://en.cppreference.com/w/cpp/concept/CopyAssignable\" rel=\"nofollow noreferrer\">CopyAssignable</a> and CopyConstructible.</p>\n<p>This means (simplifying): with <code>v</code> and <code>t</code> two instances of type <code>T</code>, the expression <code>t = v</code> must be legal. Clearly, if <code>T</code> is a native array, this is not the case (you cannot assign a C-array to another), and certain functions of <code>std::vector&lt;T&gt;</code> would be ill-formed.</p>\n<p>A solution would be to define <code>triplet_t</code> as:</p>\n<pre><code>using triplet_t = std::array&lt;std::uint8_t, 3&gt;;\n\nvoid f(const triplet_t &amp;triplet) { /* whatever */ }\n\ntriplet_t t{};\n\nt[0] = '0';\nt[1] = '1';\nt[2] = '2';\nfor (auto &amp;v : t) std::cout &lt;&lt; v &lt;&lt; ' ';\nstd::cout &lt;&lt; '\\n';\n\n// So far so good...\ntriplet_t t3[3]{};\nfor (auto &amp;r : t3)\n    for(auto &amp;v : r)\n        v = 42;\n\nstd::vector&lt;triplet_t&gt; vt;\n\nvt.push_back({});\n</code></pre>\n", "LastEditorUserId": "5470596", "LastActivityDate": "2017-11-24T13:38:58.227", "Score": "5", "CreationDate": "2017-11-24T13:33:15.520", "ParentId": "47474063", "CommentCount": "4", "OwnerUserId": "5470596", "LastEditDate": "2017-11-24T13:38:58.227"}});