post_cb({"41424755": {"ParentId": "8833938", "LastEditDate": "2017-05-23T12:03:07.500", "CommentCount": "0", "CreationDate": "2017-01-02T10:11:04.400", "OwnerUserId": "895245", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "41424755", "Score": "1", "Body": "<p><strong>C++11 N3337 standard draft</strong> <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf</a> </p>\n<p>23.2.4 \"Associative containers\" says:</p>\n<blockquote>\n<p id=\"so_8833938_41424755_0\">1 Associative containers provide fast retrieval of data based on keys. The library provides four basic kinds of\n  associative containers: set, multiset, map and multimap.</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_8833938_41424755_1\">10 The fundamental property of iterators of associative containers is that they iterate through the containers\n  in the non-descending order of keys where non-descending is defined by the comparison that was used to\n  construct them.</p>\n</blockquote>\n<p>so <strong>yes</strong>, order is guaranteed by the C++ standard, which as <a href=\"https://stackoverflow.com/a/11812871/895245\">https://stackoverflow.com/a/11812871/895245</a> mentioned basically requires a balanced search tree implementation.</p>\n<p>Also contrast with C++11 <code>unordered_set</code>, which may provide better performance since it has less restrictions: <a href=\"https://stackoverflow.com/questions/1349734/why-on-earth-would-anyone-use-set-instead-of-unordered-set\">Why on earth would anyone use set instead of unordered_set?</a> e.g. using a hash set.</p>\n", "LastActivityDate": "2017-01-16T21:36:37.137"}, "8834041": {"ParentId": "8833938", "LastEditDate": "2012-01-12T11:10:43.593", "CommentCount": "0", "CreationDate": "2012-01-12T11:05:38.037", "OwnerUserId": "166749", "LastEditorUserId": "166749", "PostTypeId": "2", "Id": "8834041", "Score": "31", "Body": "<p>Per the C++ standard, iteration over the elements in an <code>std::set</code> proceeds in sorted order as determined by <code>std::less</code> or by the optional comparison predicate template argument.</p>\n<p>(Also per the C++ standard, insertion, lookup and deletion take at most O(lg <em>n</em>) time, so balanced search trees are currently the only viable implementation choice for <code>std::set</code>, even though the use of red-black trees is not mandated by the standard.)</p>\n", "LastActivityDate": "2012-01-12T11:10:43.593"}, "8834064": {"ParentId": "8833938", "LastEditDate": "2015-05-02T14:11:51.807", "CommentCount": "0", "CreationDate": "2012-01-12T11:07:15.527", "OwnerUserId": "255803", "LastEditorUserId": "281545", "PostTypeId": "2", "Id": "8834064", "Score": "13", "Body": "<p>It means that internally <code>std::set</code> will store its elements as a sorted tree. However, the specification says nothing about the sort order. By default, <code>std::set</code> uses <code>std::less</code> and so will order from low to high. However, you can make the sorting function be whatever you want, using this constructor:</p>\n<pre><code>std::set&lt;valueType, comparissonStruct&gt; myCustomOrderedSet;\n</code></pre>\n<p>So for example:</p>\n<pre><code>std::set&lt;int, std::greater&lt;int&gt; &gt; myInverseSortedSet;\n</code></pre>\n<p>or</p>\n<pre><code>struct cmpStruct {\n  bool operator() (int const &amp; lhs, int const &amp; rhs) const\n  {\n    return lhs &gt; rhs;\n  }\n};\n\nstd::set&lt;int, cmpStruct &gt; myInverseSortedSet;\n</code></pre>\n<p>In fact, these examples are also provided on the website you linked. More specifically here: <a href=\"http://www.cplusplus.com/reference/stl/set/set/\" rel=\"noreferrer\">set constructor</a>.</p>\n", "LastActivityDate": "2015-05-02T14:11:51.807"}, "8834058": {"ParentId": "8833938", "CommentCount": "0", "Body": "<p>The default comparator is less, so the set will be ordered ascending. To change this you can specify another existing or custom comparator as a template argument.</p>\n", "OwnerUserId": "1143451", "PostTypeId": "2", "Id": "8834058", "Score": "3", "CreationDate": "2012-01-12T11:06:44.933", "LastActivityDate": "2012-01-12T11:06:44.933"}, "8834025": {"ParentId": "8833938", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_8833938_8834025_0\">by specification iteration order of set is always ascending</p>\n</blockquote>\n<p>Yes, the values of set are always ascending if you print them out in sequence. As the description says, it's typically implemented using Red-Black Tree(RBT), but the compiler writers have the option to violate this, but usually the would stick to the Theme of RBT since any other implementation won't be resource efficient to achieve the task of <code>set</code>.</p>\n", "OwnerUserId": "326820", "PostTypeId": "2", "Id": "8834025", "Score": "1", "CreationDate": "2012-01-12T11:04:47.697", "LastActivityDate": "2012-01-12T11:04:47.697"}, "bq_ids": {"n4140": {"so_8833938_41424755_0": {"section_id": 737, "quality": 0.95, "length": 19}, "so_8833938_41424755_1": {"section_id": 746, "quality": 0.95, "length": 19}}, "n3337": {"so_8833938_41424755_0": {"section_id": 726, "quality": 0.95, "length": 19}, "so_8833938_41424755_1": {"section_id": 735, "quality": 0.95, "length": 19}}, "n4659": {"so_8833938_41424755_0": {"section_id": 795, "quality": 0.95, "length": 19}, "so_8833938_41424755_1": {"section_id": 805, "quality": 0.95, "length": 19}}}, "8833938": {"CommentCount": "0", "CreationDate": "2012-01-12T10:59:07.707", "PostTypeId": "1", "AcceptedAnswerId": "8834041", "LastEditorUserId": "895245", "LastActivityDate": "2017-01-16T21:36:37.137", "LastEditDate": "2017-01-07T10:16:52.847", "ViewCount": "19180", "FavoriteCount": "4", "Title": "Is the std::set iteration order always ascending according to the C++ specification?", "Id": "8833938", "Score": "17", "Body": "<p>Here <a href=\"http://www.cplusplus.com/reference/stl/set/\">http://www.cplusplus.com/reference/stl/set/</a> I read that std::set in C++ is \"typically\" implemented as a tree (red-black one?) and it is sorted.</p>\n<p>I could not understand, does it mean that <strong>by specification</strong> iteration order of set is always ascending? Or is it only \"usual implementation detail\" and sometimes, some library/compiler may violate this convention?</p>\n", "Tags": "<c++><stl><set>", "OwnerUserId": "1097074", "AnswerCount": "5"}});