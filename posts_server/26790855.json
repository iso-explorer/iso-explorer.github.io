post_cb({"bq_ids": {"n4140": {"so_26790855_26790855_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 224}, "so_26790855_26791206_1": {"length": 19, "quality": 0.95, "section_id": 222}, "so_26790855_26791206_2": {"length": 28, "quality": 0.9655172413793104, "section_id": 216}, "so_26790855_26790855_2": {"length": 37, "quality": 0.9487179487179487, "section_id": 224}}, "n3337": {"so_26790855_26790855_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 217}, "so_26790855_26791206_1": {"length": 19, "quality": 0.95, "section_id": 215}, "so_26790855_26790855_2": {"length": 39, "quality": 1.0, "section_id": 217}, "so_26790855_26791206_2": {"length": 28, "quality": 0.9655172413793104, "section_id": 210}}, "n4659": {"so_26790855_26790855_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 232}, "so_26790855_26791206_1": {"length": 19, "quality": 0.95, "section_id": 230}, "so_26790855_26790855_2": {"length": 37, "quality": 0.9487179487179487, "section_id": 232}, "so_26790855_26791206_2": {"length": 28, "quality": 0.9655172413793104, "section_id": 224}}}, "26790855": {"ViewCount": "69", "Body": "<p>Consider the following code, in which the location of the overloads of <code>f</code> causes some non-intuitive behaviour. The code compiles with no warnings in both Clang 3.4.1 and gcc 4.8.</p>\n<pre><code>template&lt;typename T&gt;\nstruct A\n{\n    static const int value = sizeof(f(T()));\n};\n\nstruct B\n{\n};\n\nstruct D : B\n{\n};\n\nchar f(B);\n\n// instantiates A&lt;D&gt;, unqualified name lookup finds f(B) via ADL\nstatic_assert(A&lt;D&gt;::value == sizeof(f(B())), \"\"); // passes\n\nlong f(D); // but wait, f(D) would be a better match!\n\n// A&lt;D&gt; is already instantiated, f(D) is not found\nstatic_assert(A&lt;D&gt;::value == sizeof(f(B())), \"\"); // passes\n</code></pre>\n<p>The C++11 standard suggests that the above code invokes undefined behaviour:</p>\n<blockquote>\n<p id=\"so_26790855_26790855_0\">[temp.dep.candidate]</p>\n<p id=\"so_26790855_26790855_1\">For a function call that depends on a template parameter, the candidate functions are found using the usual\n  lookup rules except that:</p>\n<ul>\n<li>For the part of the lookup using unqualified name lookup or qualified name lookup, only\n  function declarations from the template definition context are found.</li>\n<li>For the part of the lookup using associated namespaces, only function declarations found in\n  either the template definition context or the template instantiation context are found.</li>\n</ul>\n<p id=\"so_26790855_26790855_2\"><strong>If the function name is an unqualified-id and the call would be ill-formed or would find a better match had\n  the lookup within the associated namespaces considered all the function declarations with external linkage\n  introduced in those namespaces in all translation units, not just considering those declarations found in the\n  template definition and template instantiation contexts, then the program has undefined behavior.</strong></p>\n</blockquote>\n<p>Does the above code invoke this specific undefined behaviour? Could a high-quality implementation be expected to report a warning?</p>\n", "AcceptedAnswerId": "26791206", "Title": "Best match not found by ADL after point of instantiation. Is this UB?", "CreationDate": "2014-11-06T22:45:20.060", "Id": "26790855", "CommentCount": "0", "LastEditDate": "2014-11-06T23:13:05.850", "PostTypeId": "1", "LastEditorUserId": "1690864", "LastActivityDate": "2014-11-06T23:23:07.447", "Score": "3", "OwnerUserId": "1690864", "Tags": "<c++><templates><language-lawyer><argument-dependent-lookup><dependent-name>", "AnswerCount": "1"}, "26791206": {"Id": "26791206", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_26790855_26791206_0\">Does the above code invoke this specific undefined behaviour?</p>\n</blockquote>\n<p>Yes. [temp.point]/7:</p>\n<blockquote>\n<p id=\"so_26790855_26791206_1\">The instantiation context of an expression that depends on the\n  template arguments is <strong>the set of declarations with external linkage\n  declared prior to the point of instantiation of the template\n  specialization in the same translation unit</strong>.</p>\n</blockquote>\n<p>The point of instantiation is right after the first <code>static_assert</code>-declaration:</p>\n<blockquote>\n<p id=\"so_26790855_26791206_2\">For [\u2026] a specialization for a [\u2026] static data member of a class\n  template, if the specialization is implicitly instantiated because it\n  is referenced from within another template specialization [\u2026].\n  <strong>Otherwise, the point of instantiation for such a specialization immediately follows the namespace scope declaration or definition that\n  refers to the specialization.</strong></p>\n</blockquote>\n<p>So there would indeed be a better match if we would have considered the second function declaration - which we couldn't, since it's declared after the point of instantiation of <code>A&lt;D&gt;::value</code>. According to the rule you quoted the code induces undefined behavior. <br>\nThe rule is basically extending the ODR to dependent name lookup in templates.</br></p>\n<blockquote>\n<p id=\"so_26790855_26791206_3\">Could a high-quality implementation be expected to report a warning?</p>\n</blockquote>\n<p>I wouldn't. Consider also that undefined behavior reaches back to compile time; The compiler is allowed but not required to issue a warning or error message if the code induces UB. Do not expect compilers to always point out illegal code.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-11-06T23:23:07.447", "Score": "2", "CreationDate": "2014-11-06T23:13:31.200", "ParentId": "26790855", "CommentCount": "1", "OwnerUserId": "3647361", "LastEditDate": "2014-11-06T23:23:07.447"}});