post_cb({"46353373": {"CommentCount": "7", "ViewCount": "157", "PostTypeId": "1", "LastEditorUserId": "5632316", "CreationDate": "2017-09-21T21:22:52.663", "LastActivityDate": "2017-09-22T00:14:55.073", "Title": "Is a fundamental type volatile initialization an observable behavior?", "LastEditDate": "2017-09-21T21:37:00.433", "Id": "46353373", "Score": "7", "Body": "<p>Consider this function:</p>\n<pre><code>void f(void* loc)\n  {\n  auto p = new(loc) volatile int{42};\n  *p = 0;\n  }\n</code></pre>\n<p>I have check the generated code by <em>clang, gcc and CL,</em> none of them elide the initialization. (The answer may be seen by the hardwer:).</p>\n<p>Is it an extension provided by compilers to the standard? Does the standard allow compilers not to perform the write 42?</p>\n<p>Actualy for objects of class type, it is specfied that constructor of an object is executed without consideration for the <code>volatile</code> qualifier [class.ctor]:</p>\n<blockquote>\n<p id=\"so_46353373_46353373_0\">A constructor can be invoked for a const, volatile or const volatile object. const and volatile\n  semantics (10.1.7.1) are not applied on an object under construction. They come into effect when the\n  constructor for the most derived object (4.5) ends.</p>\n</blockquote>\n", "Tags": "<c++><initialization><language-lawyer><volatile>", "OwnerUserId": "5632316", "AnswerCount": "2"}, "46354971": {"ParentId": "46353373", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>This is not a coherent question because what it means for a compiler to perform a write is platform-specific. There is no platform-independent notion of performing a write other than perhaps seeing the effects of a write in a subsequent read. </p>\n<p>As you see, typical compilers on x86 will emit a write instruction but no memory barrier. The CPU may reorder the write, coalesce it, or even avoid doing any write to main memory because of the way the platform's cache coherence works.</p>\n<p>The reason they made this implementation choice is that it makes <code>volatile</code> work for a broad range of applications, including those where the standard requires it to work, and because it has acceptable performance consequences. The standard, being platform-neutral, doesn't dictate platform-specific decisions like this and compiler writers do not understand it to do that.</p>\n<p>They could have forced every <code>volatile</code> access to be uncoalsecable, un-reorderable, and pushed through the cache subsystem to main memory. But that would provide terrible performance and, on this platform, no significant benefits. So they don't do it, and they don't understand the C++ standard to suggest that there's some mythical observer on the memory bus who must see specific things. The very existence of a memory bus is platform-specific. The standard is not platform-specific.</p>\n<p>You will sometimes see people argue, for example, that the standard somehow requires the compiler to issue instructions to do <code>volatile</code> writes in order but that it doesn't matter if the CPU coalesces or re-orders the writes. This is, frankly, silly. The C++ standard doesn't impose requirements on the instructions compilers generate but rather on what those instructions must actually do when executed. It doesn't distinguish between optimizations done by a CPU and optimizations done by a compiler and any such distinctions would be platform-specific anyway.</p>\n<p>If the standard allows a CPU to re-order two writes, then it allows the compiler to re-order them. It does not, and cannot, make that kind of distinction. Of course, compiler writers may still decide that they will issues the writes in order even though the CPU can re-order them because that may make the most sense on their platform.</p>\n", "OwnerUserId": "721269", "LastEditorUserId": "721269", "LastEditDate": "2017-09-22T00:14:55.073", "Id": "46354971", "Score": "0", "CreationDate": "2017-09-22T00:08:34.360", "LastActivityDate": "2017-09-22T00:14:55.073"}, "bq_ids": {"n4140": {"so_46353373_46353373_0": {"section_id": 368, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_46353373_46353373_0": {"section_id": 358, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_46353373_46353373_0": {"section_id": 380, "quality": 0.9615384615384616, "length": 25}}}, "46354835": {"ParentId": "46353373", "CommentCount": "5", "Body": "<p>[intro.execution]/8 lists the minimum requirements for a conforming implementation; these are also known as \u201cobservable behavior\u201d. The first requirement is that \u201cAccess to volatile objects are evaluated strictly according to the rules of the abstract machine.\u201d The compiler is required to produce all observable behavior. In particular, it is not allowed to remove accesses to volatile objects. And note that \u201cobject\u201d here is used in the compiler-writer\u2019s sense: it includes built-in types.</p>\n", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "46354835", "Score": "0", "CreationDate": "2017-09-21T23:50:33.403", "LastActivityDate": "2017-09-21T23:50:33.403"}});