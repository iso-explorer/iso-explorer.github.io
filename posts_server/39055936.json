post_cb({"39055936": {"CommentCount": "7", "ViewCount": "101", "CreationDate": "2016-08-20T15:43:04.953", "LastActivityDate": "2016-08-20T16:55:57.657", "Title": "Any guarantees with vector<bool> iterators?", "AcceptedAnswerId": "39056625", "PostTypeId": "1", "Id": "39055936", "Score": "3", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/container/vector_bool#Notes\" rel=\"nofollow\">cppreference</a> says that the iterators for the <code>vector&lt;bool&gt;</code> specialization are implementation defined and many not support traits like <code>ForwardIterator</code> (and therefore <code>RandomAccessIterator</code>). </p>\n<p><a href=\"http://www.cplusplus.com/reference/vector/vector-bool/\" rel=\"nofollow\">cplusplus</a> adds a mysterious \"most\":</p>\n<blockquote>\n<p id=\"so_39055936_39055936_0\">The pointer and iterator types used by the container are not\n  necessarily neither pointers nor conforming iterators, although they\n  shall simulate most of their expected behavior.</p>\n</blockquote>\n<p>I don't have access to the official specification. Are there <em>any</em> iterator behaviors guaranteed for the <code>vector&lt;bool&gt;</code> iterators?</p>\n<p>More concretely, how would one write standards-compliant code to insert an item in the middle of a <code>vector&lt;bool&gt;</code>? The following works on several compilers that I tried:</p>\n<pre><code>std::vector&lt;bool&gt; v(4);\nint k = 2;\nv.insert(v.begin() + k, true);\n</code></pre>\n<p>Will it always?</p>\n", "Tags": "<c++><vector><iterator>", "OwnerUserId": "105752", "AnswerCount": "2"}, "39056102": {"ParentId": "39055936", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>C++14 [vector.bool]/2:</p>\n<blockquote>\n<p id=\"so_39055936_39056102_0\">Unless described below, all operations have the same requirements and\n  semantics as the primary <code>vector</code> template, except that operations\n  dealing with the <code>bool</code> value type map to bit values in the container\n  storage and <code>allocator_traits::construct</code> (20.7.8.2) is not used to\n  construct these values.</p>\n</blockquote>\n", "OwnerUserId": "1593860", "LastEditorUserId": "3552770", "LastEditDate": "2016-08-20T16:04:29.700", "Id": "39056102", "Score": "3", "CreationDate": "2016-08-20T15:59:56.090", "LastActivityDate": "2016-08-20T16:04:29.700"}, "bq_ids": {"n4140": {"so_39055936_39056102_0": {"section_id": 993, "quality": 0.9259259259259259, "length": 25}}, "n3337": {"so_39055936_39056102_0": {"section_id": 978, "quality": 0.9259259259259259, "length": 25}}, "n4659": {"so_39055936_39056102_0": {"section_id": 1056, "quality": 0.9259259259259259, "length": 25}}}, "39056625": {"ParentId": "39055936", "CommentCount": "20", "Body": "<p>The fundamental problem with <code>vector&lt;bool&gt;</code>'s iterators is that they are not ForwardIterators. C++14 [forward.iterators]/1 requires that ForwardIterators' <code>reference</code> type be <code>T&amp;</code> or <code>const T&amp;</code>, as appropriate.</p>\n<p>Any function which takes a forward iterator over a range of <code>T</code>s is allowed to do this:</p>\n<pre><code>T &amp;t = *it;\nt = //Some value.\n</code></pre>\n<p>However, <code>vector&lt;bool&gt;</code>'s <code>reference</code> types are not <code>bool&amp;</code>; they're a <a href=\"http://en.cppreference.com/w/cpp/container/vector_bool/reference\" rel=\"nofollow\">proxy object that is convertible to and assignable from a <code>bool</code>.</a> They act like a <code>bool</code>, but they are <em>not</em> a <code>bool</code>. As such, this code is illegal:</p>\n<pre><code>bool &amp;b = *it;\n</code></pre>\n<p>It would be attempting to get an lvalue reference to a temporary created from the proxy object. That's not allowed.</p>\n<p>Therefore, you <em>cannot</em> use <code>vector&lt;bool&gt;</code>'s iterators in any function that takes ForwardIterators or higher.</p>\n<p>However, your code doesn't necessarily have to care about that. As long as you control what code you pass those <code>vector&lt;bool&gt;</code> iterators to, and you don't do anything that violates how they behave, then you're fine.</p>\n<p>As far as their interface is concerned, they act like RandomAccessIterators, except for when they don't (see above). So you can offset them with integers with constant time complexity and so forth.</p>\n<p><code>vector&lt;bool&gt;</code> is fine, so long as you don't treat it like a <code>vector</code> that contains <code>bool</code>s. Your code will work because it uses <code>vector&lt;bool&gt;</code>'s own interface, which it obviously accepts.</p>\n<p>It would not work if you passed a pair of <code>vector&lt;bool&gt;</code> iterators to <code>std::sort</code>.</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "39056625", "Score": "2", "CreationDate": "2016-08-20T16:55:57.657", "LastActivityDate": "2016-08-20T16:55:57.657"}});