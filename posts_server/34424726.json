post_cb({"bq_ids": {"n4140": {"so_34424726_34425285_2": {"section_id": 412, "quality": 0.8695652173913043, "length": 20}, "so_34424726_34425285_0": {"section_id": 6797, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_34424726_34425285_2": {"section_id": 403, "quality": 0.8695652173913043, "length": 20}, "so_34424726_34425285_0": {"section_id": 6552, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_34424726_34425285_2": {"section_id": 430, "quality": 0.8695652173913043, "length": 20}, "so_34424726_34425285_0": {"section_id": 8287, "quality": 0.6666666666666666, "length": 6}}}, "34424726": {"CommentCount": "4", "AcceptedAnswerId": "34425285", "PostTypeId": "1", "LastEditorUserId": "3928385", "CreationDate": "2015-12-22T21:30:30.227", "LastActivityDate": "2015-12-22T22:12:00.477", "LastEditDate": "2015-12-22T21:48:12.767", "ViewCount": "210", "FavoriteCount": "0", "Title": "Is it legal to call a destructor on int32_t?", "Id": "34424726", "Score": "12", "Body": "<p>I just found out that the following code is not a valid C++ (it doesn't parse at <code>int</code> after <code>~</code>):</p>\n<pre><code>int x = 5;\nx.~int();\n</code></pre>\n<p>However, the following snippet does work:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>int32_t x = 5;\nx.~int32_t();\n</code></pre>\n<p>This is because <code>int32_t</code> is a <code>typedef</code> in my particular implementation of C++, and a destructor can, apparently, be called on any typedef'ed type.</p>\n<p>My question is: is any implementation of C++ required to allow the second snipped to compile? In particular, is <code>int32_t</code> guaranteed to be a typedef, and is the compiler required to allow a destruction of a typedef if it knows that typedef typedefs something to int?</p>\n", "Tags": "<c++><destructor>", "OwnerUserId": "3928385", "AnswerCount": "1"}, "34425285": {"ParentId": "34424726", "CommentCount": "11", "Body": "<p>There's a clear requirement that <code>int32_t</code> be a typedef. We start with [cstdint.syn]/2:</p>\n<blockquote>\n<p id=\"so_34424726_34425285_0\">The header defines all functions, types, and macros the same as 7.18 in the C standard.</p>\n</blockquote>\n<p>So from there we look at the requirement for the C library:</p>\n<blockquote>\n<p id=\"so_34424726_34425285_1\">The <strong>typedef name</strong> intN_t designates a signed integer type with width N, no padding bits, and a two\u2019s complement representation.</p>\n</blockquote>\n<p>[emphasis added]</p>\n<p>So yes, <code>int32_t</code> must be a \"typedef name\".</p>\n<p>Although (as far as I know) it's never stated directly in normative text, the following note makes it clear that invoking a destructor for a typedef that resolves to a built-in type is intended to compile and succeed ( [class.dtor]/16):</p>\n<blockquote>\n<p id=\"so_34424726_34425285_2\">Note: the notation for explicit call of a destructor can be used for any scalar type name (5.2.4). Allowing this makes it possible to write code without having to know if a destructor exists for a given type. For example,</p>\n</blockquote>\n<pre><code>typedef int I;\nI* p;\np-&gt;I::~I();\n</code></pre>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "34425285", "Score": "8", "CreationDate": "2015-12-22T22:12:00.477", "LastActivityDate": "2015-12-22T22:12:00.477"}});