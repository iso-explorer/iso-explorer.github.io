post_cb({"bq_ids": {"n4140": {"so_11724592_11724592_2": {"length": 5, "quality": 1.0, "section_id": 5940}, "so_11724592_11724592_4": {"length": 10, "quality": 1.0, "section_id": 5940}, "so_11724592_11724592_3": {"length": 13, "quality": 1.0, "section_id": 5940}, "so_11724592_11724592_1": {"length": 13, "quality": 1.0, "section_id": 5940}}, "n3337": {"so_11724592_11724592_2": {"length": 5, "quality": 1.0, "section_id": 5711}, "so_11724592_11724592_4": {"length": 10, "quality": 1.0, "section_id": 5711}, "so_11724592_11724592_3": {"length": 13, "quality": 1.0, "section_id": 5711}, "so_11724592_11724592_1": {"length": 13, "quality": 1.0, "section_id": 5711}}, "n4659": {"so_11724592_11724592_2": {"length": 5, "quality": 1.0, "section_id": 7424}, "so_11724592_11724592_4": {"length": 10, "quality": 1.0, "section_id": 7424}, "so_11724592_11724592_3": {"length": 13, "quality": 1.0, "section_id": 7424}, "so_11724592_11724592_1": {"length": 13, "quality": 1.0, "section_id": 7424}}}, "11724644": {"Id": "11724644", "PostTypeId": "2", "Body": "<p><code>other</code> is an lvalue, because it's a variable. Named references are lvalues, regardless of what kind of reference they are.</p>\n", "LastActivityDate": "2012-07-30T15:32:25.680", "CommentCount": "1", "CreationDate": "2012-07-30T15:32:25.680", "ParentId": "11724592", "Score": "9", "OwnerUserId": "46642"}, "11724739": {"Id": "11724739", "PostTypeId": "2", "Body": "<p>Your assumption is not really true. The argument to the constructor is an <code>xvalue</code>, which allows the rvalue-reference to be bound, but once the rvalue-reference is bound, inside the constructor, it is no longer an <code>xvalue</code> but an <code>lvalue</code>. Conceptually, the object at the call place is <em>expiring</em>, but inside the constructor and until it completes it is no longer <em>expiring</em>, as it can be used later within the constructor block.</p>\n<pre><code>ArrayWrapper f();\nArrayWrapper r = f();   // [1]\n</code></pre>\n<p>In [1], the expression <code>f()</code> refers to a temporary, that will <em>expire</em> after the call to the constructor, so it can be bound by an rvalue-reference.</p>\n<pre><code>ArrayWrapper (ArrayWrapper&amp;&amp; other) \n    : _p_vals( other._p_vals  ) \n    , _metadata( other._metadata )        // [2] \n{ \n    other._p_vals = NULL; \n    std::cout &lt;&lt; other._metadata &lt;&lt; \"\\n\"; // [3]\n} \n</code></pre>\n<p>Inside the constructor, <code>other</code> is not expiring, it will be alive for each and every instruction of the constructor. If the compiler allowed <em>moving</em> in [2], than a potential further use of the variable in [3] would be invalid. You have to explicitly tell the compiler that you want the value to expire <em>now</em>.</p>\n", "LastActivityDate": "2012-07-30T15:37:17.447", "CommentCount": "2", "CreationDate": "2012-07-30T15:37:17.447", "ParentId": "11724592", "Score": "15", "OwnerUserId": "36565"}, "11724592": {"ViewCount": "503", "Body": "<p>I read a <a href=\"http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html\" rel=\"noreferrer\">beautiful article</a> on the move semantics in C++11. This article is written in a very intuitive way. The example class in the article is given below.</p>\n<pre><code>class ArrayWrapper \n{ \npublic: \n    // default constructor produces a moderately sized array \n    ArrayWrapper () \n        : _p_vals( new int[ 64 ] ) \n        , _metadata( 64, \"ArrayWrapper\" ) \n    {} \n\n    ArrayWrapper (int n) \n        : _p_vals( new int[ n ] ) \n        , _metadata( n, \"ArrayWrapper\" ) \n    {} \n\n    // move constructor \n    ArrayWrapper (ArrayWrapper&amp;&amp; other) \n        : _p_vals( other._p_vals  ) \n        , _metadata( other._metadata ) \n    { \n        other._p_vals = NULL; \n    } \n\n    // copy constructor \n    ArrayWrapper (const ArrayWrapper&amp; other) \n        : _p_vals( new int[ other._metadata.getSize() ] ) \n        , _metadata( other._metadata ) \n    { \n        for ( int i = 0; i &lt; _metadata.getSize(); ++i ) \n        { \n            _p_vals[ i ] = other._p_vals[ i ]; \n        } \n    } \n    ~ArrayWrapper () \n    { \n        delete [] _p_vals; \n    } \nprivate: \n    int *_p_vals; \n    MetaData _metadata; \n};\n</code></pre>\n<p>Clearly in the above move constructor implementation, the movement doesn't happen for the the embedded element <code>_metadata</code>. To facilitate this the trick is to use the <code>std::move()</code> method like this.</p>\n<pre><code>ArrayWrapper (ArrayWrapper&amp;&amp; other) \n        : _p_vals( other._p_vals  ) \n        , _metadata( std::move( other._metadata ) ) \n{ \n    other._p_vals = NULL; \n} \n</code></pre>\n<p>So far, so good.</p>\n<p>The standard says:</p>\n<p>\u00a75 (C++11 \u00a75[expr]/6):</p>\n<blockquote>\n<p id=\"so_11724592_11724592_0\">[ Note: An expression is an xvalue if it is:</p>\n<ul>\n<li><p id=\"so_11724592_11724592_1\">the result of calling a function, whether implicitly or explicitly,\n  whose return type is an rvalue reference to object type,</p></li>\n<li><p id=\"so_11724592_11724592_2\">a cast to an rvalue reference to object type,</p></li>\n<li><p id=\"so_11724592_11724592_3\">a class member access expression designating a non-static data member\n  of non-reference type in which the object expression is an xvalue, or</p></li>\n<li><p id=\"so_11724592_11724592_4\">a <code>.*</code> pointer-to-member expression in which the first operand is an\n  xvalue and the second operand is a pointer to data member.</p></li>\n</ul>\n</blockquote>\n<p>My question: </p>\n<p>Now, the variable <code>other</code> in the move constructor is an xvalue (am I right?). Then according to the last rule above, <code>other._metadata</code> should also be an xvalue. And hence the compiler can implicitely use the move constructor of <code>_metadata</code>'s class. So, no need to <code>std::move</code> here. </p>\n<p>What am I missing?</p>\n", "AcceptedAnswerId": "11724739", "Title": "Why std::move is needed?", "CreationDate": "2012-07-30T15:30:16.600", "Id": "11724592", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-07-30T15:32:59.440", "LastEditorUserId": "168175", "LastActivityDate": "2012-07-30T15:37:17.447", "Score": "10", "OwnerUserId": "1183123", "Tags": "<c++><c++11>", "AnswerCount": "2"}});