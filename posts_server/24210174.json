post_cb({"24210487": {"ParentId": "24210174", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Compilers are allowed to strip out the first copy iff</p>\n<p><ol>\n<li>The copy does not have observable behavior according to the as-if rule.<br>\nFor this rule to apply, your compiler must know neither constructor nor destructor of <code>myBigObject</code> have any observable side-effects when compiling the user of the <code>MyClass</code> ctor.</br></li></ol></p>\n<blockquote>\n<h3>1.9 Program Execution</h3>\n<p id=\"so_24210174_24210487_0\">The semantic descriptions in this International Standard define a parameterized nondeterministic abstract\n  machine. This International Standard places no requirement on the structure of conforming implementations.\n  In particular, they need not copy or emulate the structure of the abstract machine. Rather, conforming\n  implementations are required to emulate (only) the observable behavior of the abstract machine as explained\n  below.</p></blockquote>\n<li>or if they can use the copy-elision rule, which allows disregarding the as-if rule.<br>\n  For this to apply, you must feed the constructor an anonymous unbound object.</br></li>\n<h3>12.8 Copying and Moving class objects \u00a731</h3>\n<p>When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the copy/move constructor and/or destructor for the object have side effects. In such cases, the implementation treats the source and target of the omitted copy/move operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization.123 This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which may be combined to eliminate multiple copies):<br>\n  \u2014 in a return statement in a function with a class return type, when the expression is the name of a\n  non-volatile automatic object (other than a function or catch-clause parameter) with the same cvunqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function\u2019s return value<br>\n  \u2014 in a throw-expression, when the operand is the name of a non-volatile automatic object (other than a function or catch-clause parameter) whose scope does not extend beyond the end of the innermost\n  enclosing try-block (if there is one), the copy/move operation from the operand to the exception\n  object (15.1) can be omitted by constructing the automatic object directly into the exception object<br>\n  \u2014 when a temporary class object that has not been bound to a reference (12.2) would be copied/moved\n  to a class object with the same cv-unqualified type, the copy/move operation can be omitted by\n  constructing the temporary object directly into the target of the omitted copy/move<br>\n  \u2014 when the exception-declaration of an exception handler (Clause 15) declares an object of the same type (except for cv-qualification) as the exception object (15.1), the copy/move operation can be omitted by treating the exception-declaration as an alias for the exception object if the meaning of the program will be unchanged except for the execution of constructors and destructors for the object declared by the exception-declaration.</br></br></br></br></p>\n\n  Far easier to take the argument by movable-reference <code>&amp;&amp;</code>, which allows replacing the second copy with a move under any circumstances.\n\n", "OwnerUserId": "3204551", "LastEditorUserId": "353337", "LastEditDate": "2014-06-13T17:43:59.433", "Id": "24210487", "Score": "3", "CreationDate": "2014-06-13T17:05:42.500", "LastActivityDate": "2014-06-13T17:43:59.433"}, "24210174": {"CommentCount": "0", "AcceptedAnswerId": "24211176", "PostTypeId": "1", "LastEditorUserId": "353337", "CreationDate": "2014-06-13T16:44:12.747", "LastActivityDate": "2014-06-13T18:00:52.373", "LastEditDate": "2014-06-13T17:36:58.437", "ViewCount": "62", "FavoriteCount": "1", "Title": "extra copy on class construction", "Id": "24210174", "Score": "2", "Body": "<p>In C++, when initializing a class like</p>\n<pre><code>MyClass(myBigObject s):\n  s_(s)\n{\n...\n}\n</code></pre>\n<p>it looks as if <code>s</code> is copied once at function entry (\"pass by value\") and once when being assigned to <code>s_</code>.</p>\n<p>Are compilers smart enough to strip out the <em>first</em> copy?</p>\n", "Tags": "<c++><constructor><copy>", "OwnerUserId": "353337", "AnswerCount": "3"}, "24210494": {"ParentId": "24210174", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>compiler cannot optimize copying from argument to calss field in general case. Apparently your object can have complex copy constructor with side effects that cannot be omited.</p>\n<p>But in your case you probably want to replace <em>copying</em> with <a href=\"https://stackoverflow.com/questions/3106110/what-is-move-semantics\"><em>moving</em></a>.</p>\n<p>You should write move constructor and use <code>std::move</code> to move <code>s</code> to <code>_s</code>:</p>\n<pre><code>myBigObject(myBigObject&amp;&amp;other);\n\nMyClass(myBigObject s):\n  s_(std::move(s))\n{\n...\n}\n</code></pre>\n<p>In that case code like </p>\n<pre><code>MyClass obj((myBigObject()));\n</code></pre>\n<p>will end up with zero copyings as object will be first moved to constructor and then to class field.</p>\n", "OwnerUserId": "774651", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:33:20.293", "Id": "24210494", "Score": "1", "CreationDate": "2014-06-13T17:06:02.537", "LastActivityDate": "2014-06-13T17:47:49.947"}, "bq_ids": {"n4140": {"so_24210174_24210487_0": {"section_id": 5797, "quality": 0.8918918918918919, "length": 33}}, "n3337": {"so_24210174_24210487_0": {"section_id": 5570, "quality": 0.8918918918918919, "length": 33}}, "n4659": {"so_24210174_24210487_0": {"section_id": 7256, "quality": 0.8918918918918919, "length": 33}}}, "24211176": {"ParentId": "24210174", "PostTypeId": "2", "CommentCount": "0", "Body": "<h2>First copy into <code>s</code> can be omitted for a temporary</h2>\n<p>An optimizing compiler will likely omit the first copy if you pass a temporary object:</p>\n<pre><code>MyClass x{ myBigObject() };\n</code></pre>\n<p>This is likely to invoke the copy constructor only once since the temporary myBigObject will be constructed directly into the constructor argument <code>s</code>.</p>\n<p>Note that this can change the observable behaviour of your program.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct myBigObject\n{\n  size_t x;\n  myBigObject() : x() {}\n  myBigObject(myBigObject &amp;&amp; other)\n  {\n    std::cout &lt;&lt; \"Move myBigObject\" &lt;&lt; std::endl;\n  }\n  myBigObject(const myBigObject &amp;other)\n  {\n    std::cout &lt;&lt; \"Copy myBigObject\" &lt;&lt; std::endl;\n    x = 12;\n  }\n};\n\nstruct MyClass\n{\n    MyClass(myBigObject s)\n      : s_(s) \n    { \n      std::cout &lt;&lt; \"x of s : \" &lt;&lt; s.x &lt;&lt; std::endl;\n      std::cout &lt;&lt; \"x of s_ : \" &lt;&lt; s_.x &lt;&lt; std::endl;\n    }\n    myBigObject s_;\n};\n\nint main()\n{\n  std::cout &lt;&lt; \"A:\" &lt;&lt; std::endl;\n  MyClass x{ myBigObject() };\n  std::cout &lt;&lt; \"B:\" &lt;&lt; std::endl;\n  myBigObject y;\n  MyClass z{ y };\n}\n</code></pre>\n<p>It prints (<a href=\"https://ideone.com/hMEv1W\" rel=\"nofollow\">https://ideone.com/hMEv1W</a> + MSVS2013,Toolsetv120) </p>\n<pre><code>A:\nCopy myBigObject\nx of s : 0\nx of s_ : 12\nB:\nCopy myBigObject\nCopy myBigObject\nx of s : 12\nx of s_ : 12\n</code></pre>\n<h2>Second copy into <code>s_</code> cannot be elided</h2>\n<p>The copy into <code>s_</code> cannot be omitted since <code>s</code> and <code>s_</code> need to be different objects.</p>\n<p>If you want only one copy of <code>myBigObject</code> in your class you can go for:</p>\n<pre><code>MyClass(myBigObject const &amp; s)\n  : s_(s) \n{ \n}\nMyClass(myBigObject &amp;&amp; s)\n  : s_(std::forward&lt;myBigObject&gt;(s))\n{\n}\n</code></pre>\n<p>This way you do not see any copies in case of the temporary and only one copy for non-temporary objects.</p>\n<p>The altered code will print:</p>\n<pre><code>A:\nMove myBigObject\nB:\nCopy myBigObject\n</code></pre>\n", "OwnerUserId": "951423", "LastEditorUserId": "353337", "LastEditDate": "2014-06-13T18:00:52.373", "Id": "24211176", "Score": "1", "CreationDate": "2014-06-13T17:50:26.767", "LastActivityDate": "2014-06-13T18:00:52.373"}});