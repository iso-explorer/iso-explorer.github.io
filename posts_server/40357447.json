post_cb({"bq_ids": {"n4140": {"so_40357447_40360142_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 2691}, "so_40357447_40360142_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 5812}}, "n3337": {"so_40357447_40360142_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 5585}, "so_40357447_40360142_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 2653}}, "n4659": {"so_40357447_40360142_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 7275}, "so_40357447_40360142_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 3431}}}, "40357447": {"ViewCount": "123", "Body": "<p>I was going through <a href=\"https://stackoverflow.com/questions/19744250/what-happens-to-a-detached-thread-when-main-exits\">this</a> post on stack overflow in which the accepted answer says:</p>\n<pre><code>what happens to a detached thread when main() exits is:\nIt continues running (because the standard doesn't say it is stopped), and that's well-defined, as long as it touches neither (automatic|thread_local) variables of other threads nor static objects.\n</code></pre>\n<p>While in <a href=\"https://stackoverflow.com/questions/36652917/how-does-threaddetach-work-in-c11\">this</a> post the accepted answer says that:</p>\n<p><code>Process terminates when main() exits, and all threads are killed.</code></p>\n<p>To see the behavior, I tested below code on g++ (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4 which suggests that once the main thread exit other detach thread also exit.</p>\n<pre><code>#include &lt;iostream&gt;       \n#include &lt;thread&gt;         \n#include &lt;unistd.h&gt;\n#include &lt;fstream&gt;\nusing namespace std;\n\nvoid foo()\n{\nstd::cout&lt;&lt;\"Inside foo\\n\";\nint i=0;\nofstream myfile;\n\n\nwhile(i&lt;10)\n{\n    std::cout&lt;&lt;\"Inside while\\n\";\n    myfile.open (\"/home/abc/example.txt\",ios::app);\n    myfile &lt;&lt; \"Writing this to a file.\\n\";\n    myfile.close();\n    i++;\n    sleep(1);\n}}\n\nint main()\n{\n    std::thread first (foo);     \n    first.detach();\n    sleep(5);\n    return 0;\n}\n</code></pre>\n<p>So why in many posts here on stack overflow suggests that detach thread continues running in background even if main thread exit? In what condition the detach thread continues to run in background when main exit and which one of the above statement is true?</p>\n<p>Thanks in advance.</p>\n", "AcceptedAnswerId": "40360142", "Title": "Resource deallocation for Detach thread in C++", "CreationDate": "2016-11-01T09:39:56.737", "Id": "40357447", "CommentCount": "3", "LastEditDate": "2017-05-23T12:33:18.907", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-11-01T12:32:26.190", "Score": "2", "OwnerUserId": "2586729", "Tags": "<c++><multithreading><c++11><stdthread><detach>", "AnswerCount": "1"}, "40360142": {"Id": "40360142", "PostTypeId": "2", "Body": "<p>The standard defines the scope of thread as being the program:  </p>\n<blockquote>\n<p id=\"so_40357447_40360142_0\"><strong>1.10/1:</strong> A thread of execution (also known as a thread) is a single flow of control <strong>within</strong> a program (...)  The execution of the entire program consists of an execution of all of its threads. </p>\n</blockquote>\n<p>The standard says about detached threads:  </p>\n<blockquote>\n<p id=\"so_40357447_40360142_1\"><strong>30.3.3/1:</strong> A thread of execution is detached when no thread object represents that thread.</p>\n</blockquote>\n<p>So there's nothing in the standard that suggests hat a thread could survive its program. </p>\n<p>If you want to keep something running in background after the end of the program, you have to fork or create a separate process that will run in the background with its own resources and threads. </p>\n", "LastActivityDate": "2016-11-01T12:32:26.190", "CommentCount": "0", "CreationDate": "2016-11-01T12:32:26.190", "ParentId": "40357447", "Score": "0", "OwnerUserId": "3723423"}});