post_cb({"40548269": {"CommentCount": "0", "ViewCount": "150", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2016-11-11T12:41:38.640", "LastActivityDate": "2016-11-11T21:02:32.303", "Title": "Clang 3.7.0 complains of class not being literal because it is not an aggregate and has no constexpr constructors", "AcceptedAnswerId": "40553112", "LastEditDate": "2016-11-11T17:06:35.820", "Id": "40548269", "Score": "4", "Body": "<p>The following code compiles fine in GCC (4.9.3) and VC++ (19.00.23506) but gives these error in Clang (3.7.0).</p>\n<blockquote>\n<p id=\"so_40548269_40548269_0\">error: constexpr function's return type 'Foo' is not a literal type</p>\n<p id=\"so_40548269_40548269_1\">note: 'Foo' is not literal because it is not an aggregate and has no\n  constexpr constructors other than copy or move constructors</p>\n</blockquote>\n<p>Code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstruct Foo\n{\n    std::vector&lt;int&gt; m_vec;\n    Foo(const int *foo, std::size_t size=0):m_vec(foo, foo+size)\n    {;}\n    //Foo(const std::initializer_list&lt;int&gt; &amp;init):m_vec{init}\n    //{;}\n};\n\n\ntemplate &lt;std::size_t N&gt;\nconstexpr Foo make_fooArray(const int (&amp;a)[N]) noexcept\n{\n    return {a,N};\n}\n\n\nint main()\n{\n    Foo f{ make_fooArray({1,2,3}) };\n\n    for (auto i : f.m_vec)\n        std::cout&lt;&lt; i &lt;&lt;\" \";\n    std::cout&lt;&lt;std::endl;\n}\n</code></pre>\n<p>Code running on rextester:</p>\n<p><a href=\"http://rextester.com/KTYW81035\" rel=\"nofollow noreferrer\">GCC &amp; VC</a></p>\n<p><a href=\"http://rextester.com/WWB86885\" rel=\"nofollow noreferrer\">Clang</a></p>\n<p>Can you please clarify whether this is a compiler bug or have I missed something? What does the C++11 standard say? </p>\n<hr>\n<p>Here is one other case where it compiles in GCC and VC but not in Clang.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T, std::size_t N&gt;\nconstexpr std::size_t sizeOf_fooArray(const T (&amp;)[N]) noexcept\n{\n    return N;\n}\n\nint main()\n{\n    std::cout&lt;&lt; sizeOf_fooArray({16,20,53,87,54,7}) &lt;&lt;std::endl;\n}\n</code></pre>\n<p>However, if you alias the int[] and explicitly use it to specify the type of the initializer_list, then it works in all compilers.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T, std::size_t N&gt;\nconstexpr std::size_t sizeOf_fooArray(const T (&amp;)[N]) noexcept\n{\n    return N;\n}\n\nusing intArray = int[]; //Added\n\nint main()\n{\n    std::cout&lt;&lt; sizeOf_fooArray(intArray{16,20,53,87,54,7}) &lt;&lt;std::endl;\n}\n</code></pre>\n</hr>", "Tags": "<c++><c++11><c++14><constexpr><clang++>", "OwnerUserId": "2754510", "AnswerCount": "1"}, "40553112": {"ParentId": "40548269", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>All the compilers are right.</p>\n<p>With function templates, in general, it's possible that one instantiation meets the requirements for a <code>constexpr</code> function, but another doesn't. Normally, that means <code>constexpr</code> effectively gets ignored silently for those instantiations that don't meet the requirements. Example:</p>\n<pre><code>template &lt;typename T&gt; constexpr T f(T v) { return v; }\n</code></pre>\n<p>Both the <code>f&lt;int&gt;</code> and <code>f&lt;std::string&gt;</code> instantiations are valid, but <code>f&lt;std::string&gt;</code> cannot be called in a constant expression.</p>\n<p>However, as an exception to that rule, if there isn't <em>any</em> possible template argument that could lead to an instantiation that meets the usual requirements for <code>constexpr</code> functions, the program is ill-formed, no diagnostic required. This means compilers are at liberty to ignore this rule entirely, but they are equally allowed to diagnose the code as a fatal error.</p>\n<p>In general, it's not possible to reliably detect violations of this rule, that's why no diagnostic is required. Some compilers try harder than others to still give some diagnostics.</p>\n<p>All of this is described in the standard in [dcl.constexpr]p6:</p>\n<blockquote>\n<p id=\"so_40548269_40553112_0\">If the instantiated template specialization of a <code>constexpr</code> function template or member function of a class template would fail to satisfy the requirements for a <code>constexpr</code> function or <code>constexpr</code> constructor, that specialization is still a <code>constexpr</code> function or <code>constexpr</code> constructor, even though a call to such a function cannot appear in a constant expression. If no specialization of the template would satisfy the requirements for a <code>constexpr</code> function or <code>constexpr</code> constructor when considered as a non-template function or constructor, the template is ill-formed; no diagnostic required.</p>\n</blockquote>\n", "OwnerUserId": "743382", "LastEditorUserId": "2756719", "LastEditDate": "2016-11-11T21:02:32.303", "Id": "40553112", "Score": "8", "CreationDate": "2016-11-11T17:21:21.023", "LastActivityDate": "2016-11-11T21:02:32.303"}, "bq_ids": {"n4140": {"so_40548269_40553112_0": {"section_id": 5422, "quality": 1.0, "length": 50}, "so_40548269_40548269_0": {"section_id": 5419, "quality": 0.625, "length": 5}}, "n3337": {"so_40548269_40553112_0": {"section_id": 5217, "quality": 0.68, "length": 34}, "so_40548269_40548269_0": {"section_id": 5214, "quality": 0.625, "length": 5}}, "n4659": {"so_40548269_40553112_0": {"section_id": 6844, "quality": 1.0, "length": 50}, "so_40548269_40548269_0": {"section_id": 6841, "quality": 0.625, "length": 5}}}});