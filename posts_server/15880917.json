post_cb({"bq_ids": {"n4140": {"so_15880917_15882787_1": {"length": 12, "quality": 0.631578947368421, "section_id": 5804}, "so_15880917_15882787_0": {"length": 4, "quality": 0.8, "section_id": 5804}}, "n3337": {"so_15880917_15882787_1": {"length": 12, "quality": 0.631578947368421, "section_id": 5577}, "so_15880917_15882787_0": {"length": 4, "quality": 0.8, "section_id": 5577}}, "n4659": {"so_15880917_15882787_1": {"length": 12, "quality": 0.631578947368421, "section_id": 7262}, "so_15880917_15882787_0": {"length": 4, "quality": 0.8, "section_id": 7262}}}, "15880917": {"ViewCount": "1985", "Body": "<p>I am quite new to C++, I have some java experience.</p>\n<p>Currently I write a small c++ project using xcode. I just used the standard library. Then I create a project in VS2010. I \u201cadd existing items (My source file in xcode project) \u201d under source folder of the project. After that, I found the project could compile but it did not run properly in VS2010.</p>\n<p>I heard that c++ code has portability, I don't understand why the code that run on xcode causes problem in VS2010.</p>\n<p>In my source code, I write something like:</p>\n<p>a.h:</p>\n<pre><code>  class a{\n    public :\n     int p ; \n    vector&lt;Token*&gt; v;\n    a();\n    int b();\n    void c();\n }\n</code></pre>\n<p>a.cpp:</p>\n<pre><code>   a::a(){ //constructor of a\n      p = 0;\n      v.push_back(new Token(\"a\",1));\n   }\n   int a::b(){\n        ......\n        //breakpoint to view p, v \n    c();\n   }\n   void a::c(){\n        .......\n       // when I set breakpoint here, in xcode, the debugger stops here.\n       // in VS2010, it said the debugger did not hit this breakpoint.\n   }\n</code></pre>\n<p>During runtime, xcode debugger shows vector and p properly, but inside VS2010 the debugger cannot show p and vector properly. If I expand the view of vector, the size of vector become very large in VS2010, but the vector size in xcode is correct.</p>\n<p>Is there any way to import Xcode C++ project to VS2010? Or any method to solve the above problem? </p>\n", "AcceptedAnswerId": "15882787", "Title": "What are the differences between Xcode c++ and VS2010 c++", "CreationDate": "2013-04-08T13:52:31.390", "Id": "15880917", "CommentCount": "12", "LastEditDate": "2013-04-08T14:04:39.443", "PostTypeId": "1", "LastEditorUserId": "597607", "LastActivityDate": "2013-04-09T12:48:57.620", "Score": "0", "OwnerUserId": "1681877", "Tags": "<c++><visual-studio-2010>", "AnswerCount": "1"}, "15882787": {"Id": "15882787", "PostTypeId": "2", "Body": "<p>The C++ standard defines an \"abstract machine\" that produces certain behaviors when presented with a well-formed C++ program.  Compilers are not required to reproduce all the behavior of the abstract machine, only its \"observable behavior\".</p>\n<p>C++11 standard, \u00a71.9/8:</p>\n<blockquote>\n<p id=\"so_15880917_15882787_0\">The least requirements on a conforming implementation are:</p>\n<ul>\n<li>Access to volatile objects are evaluated strictly according to the rules of the abstract machine.</li>\n<li>At program termination, all data written into \ufb01les shall be identical to one of the possible results that\n  execution of the program according to the abstract semantics would have produced.</li>\n<li>The input and output dynamics of interactive devices shall take place in such a fashion that prompting output is actually delivered before a program waits for input. What constitutes an interactive device is implementation-de\ufb01ned.</li>\n</ul>\n<p id=\"so_15880917_15882787_1\">These collectively are referred to as the <em>observable behavior</em> of the program. [<em>Note</em>: More stringent correspondences between abstract and actual semantics may be de\ufb01ned by each implementation. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>Note, \"my functions will always be called at runtime\" is not one of those requirements.  Compilers are allowed (indeed, encouraged) to optimize very aggressively, as long as the observable behavior matches that allowed by the standard.  The compiler is allowed to assume that you wrote a well-formed C++ program that does not cause undefined behavior.  Assuming it does so, if it notices that a function will have no <em>observable behavior</em> and will return a consistent value, it is allowed to omit the call altogether, compute the value at compile time, etc.</p>\n<p>Whether VS's output is broken depends heavily on</p>\n<ul>\n<li>whether optimizations are disabled (many are on by default, but most compilers \u2014 including VC++ \u2014 will disable the non-essential ones if asked);</li>\n<li>whether <code>a::c()</code> is ever actually called outside of a debugger (if it's never used, the compiler might not even include it in the binary);</li>\n<li>whether it causes any observable side effects;</li>\n<li>in some cases, the contents of <code>a::b()</code>, and even of the caller;</li>\n<li>whether the program's behavior is undefined at any point prior to the would-be call to <code>a::b()</code> or <code>a::c()</code> \u2014 in particular, whether you're calling <code>a::b()</code> through a dangling or improperly-casted pointer or reference, etc (once the program runs off the rails, all bets are off);</li>\n</ul>\n<p>and a bunch of other things.</p>\n<p>I will say, though:  if VS lets you view the contents of <code>v</code> and <code>p</code>, and they have garbage values, then the problem is more likely the code than the debugger or compiler.  It could as easily say \"i can't display this\" (as it loves to do with .net objects :P ) if it didn't know how.  The fact that it thought it could, tried, and was wrong, is rather telling.</p>\n", "LastEditorUserId": "319403", "LastActivityDate": "2013-04-09T12:48:57.620", "Score": "1", "CreationDate": "2013-04-08T15:14:47.760", "ParentId": "15880917", "CommentCount": "0", "OwnerUserId": "319403", "LastEditDate": "2013-04-09T12:48:57.620"}});