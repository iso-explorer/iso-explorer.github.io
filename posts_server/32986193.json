post_cb({"bq_ids": {"n4140": {"so_32986193_32986347_5": {"length": 8, "quality": 1.0, "section_id": 5962}, "so_32986193_32986339_0": {"length": 17, "quality": 1.0, "section_id": 5962}, "so_32986193_32986347_2": {"length": 6, "quality": 1.0, "section_id": 5962}, "so_32986193_32986347_0": {"length": 68, "quality": 0.8607594936708861, "section_id": 5962}, "so_32986193_32986347_4": {"length": 6, "quality": 1.0, "section_id": 5962}, "so_32986193_32986347_1": {"length": 5, "quality": 1.0, "section_id": 5962}, "so_32986193_32986347_3": {"length": 6, "quality": 1.0, "section_id": 5962}}, "n3337": {"so_32986193_32986347_5": {"length": 8, "quality": 1.0, "section_id": 5731}, "so_32986193_32986339_0": {"length": 17, "quality": 1.0, "section_id": 5731}, "so_32986193_32986347_2": {"length": 6, "quality": 1.0, "section_id": 5731}, "so_32986193_32986347_0": {"length": 64, "quality": 0.810126582278481, "section_id": 5731}, "so_32986193_32986347_4": {"length": 6, "quality": 1.0, "section_id": 5731}, "so_32986193_32986347_1": {"length": 5, "quality": 1.0, "section_id": 5731}, "so_32986193_32986347_3": {"length": 6, "quality": 1.0, "section_id": 5731}}, "n4659": {"so_32986193_32986347_5": {"length": 8, "quality": 1.0, "section_id": 7452}, "so_32986193_32986339_0": {"length": 17, "quality": 1.0, "section_id": 7452}, "so_32986193_32986347_2": {"length": 6, "quality": 1.0, "section_id": 7452}, "so_32986193_32986347_0": {"length": 44, "quality": 0.5569620253164557, "section_id": 7452}, "so_32986193_32986347_4": {"length": 6, "quality": 1.0, "section_id": 7452}, "so_32986193_32986347_1": {"length": 5, "quality": 1.0, "section_id": 7452}, "so_32986193_32986347_3": {"length": 6, "quality": 1.0, "section_id": 7452}}}, "32986193": {"ViewCount": "2281", "Body": "<p>When is a lambda a guaranteed to be trivial, if ever?</p>\n<p>I assumed that if it captures only trivial types or nothing, it would be trivial. I don't have any standard-ese to back that up though.</p>\n<p>My motivation was in moving some code from Visual C++ 12 to 14 and discovered some static asserts failed when dealing with lambdas I assumed to be trivial.</p>\n<p>Example:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    auto lambda = [](){};\n\n    cout &lt;&lt; boolalpha &lt;&lt; is_trivially_copyable&lt;decltype(lambda)&gt;{} &lt;&lt; endl;\n}\n</code></pre>\n<p>This produces <code>false</code> on vs140 but <code>true</code> in vs120 and clang. I could not test gcc due to not having gcc &gt;= 5 around. I expect this is a regression in vs140, but I'm not certain of the correct behavior here. </p>\n", "AcceptedAnswerId": "32986339", "Title": "When is a lambda trivial?", "CreationDate": "2015-10-07T07:27:23.417", "Id": "32986193", "CommentCount": "1", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2016-08-25T11:21:32.500", "Score": "30", "OwnerUserId": "3055694", "Tags": "<c++><c++11><lambda><typetraits>", "AnswerCount": "2"}, "32986339": {"Id": "32986339", "PostTypeId": "2", "Body": "<p>The standard does not specify whether a <em>closure type</em> (the type of a lambda expression) is trivial or not. It explicitly leaves this up to implementation, which makes it non-portable. I am afraid you cannot rely on your <code>static_assert</code> producing anything consistent.</p>\n<p>Quoting C++14 (N4140) 5.1.2/3:</p>\n<blockquote>\n<p id=\"so_32986193_32986339_0\">... An implementation may define the closure type differently from what is described below provided this does not alter the observable\n  behavior of the program <strong>other than by changing:</strong></p>\n<ul>\n<li>the size and/or alignment of the closure type,</li>\n<li>whether the closure type is trivially copyable (Clause 9),</li>\n<li>whether the closure type is a standard-layout class (Clause 9), or</li>\n<li>whether the closure type is a POD class (Clause 9).</li>\n</ul>\n<p id=\"so_32986193_32986339_1\">...</p>\n</blockquote>\n<p>(Emphasis mine)</p>\n<p>After parsing the double negation in that sentence, we can see that the implementation is allowed to decide whether the closure type is trivially copyable, standard layout, or POD.</p>\n", "LastActivityDate": "2015-10-07T07:35:18.620", "CommentCount": "1", "CreationDate": "2015-10-07T07:35:18.620", "ParentId": "32986193", "Score": "30", "OwnerUserId": "1782465"}, "32986347": {"Id": "32986347", "PostTypeId": "2", "Body": "<p>According to the draft standard <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf\" rel=\"nofollow\">N4527</a> <em>5.1.2/3 Lambda expressions [expr.prim.lambda]</em> (<strong>emphasis mine</strong>): </p>\n<blockquote>\n<p id=\"so_32986193_32986347_0\">The type of the lambda-expression (which is also the type of the\n  closure object) is a unique, unnamed nonunion class type \u2014 called the\n  closure type \u2014 whose properties are described below. This class type\n  is neither an aggregate (8.5.1) nor a literal type (3.9). The closure\n  type is declared in the smallest block scope, class scope, or\n  namespace scope that contains the corresponding lambda-expression. [\n  Note: This determines the set of namespaces and classes associated\n  with the closure type (3.4.2). The parameter types of a\n  lambdadeclarator do not affect these associated namespaces and\n  classes. \u2014 end note ] <strong>An implementation may define the closure type\n  differently from what is described below provided this does not alter\n  the observable behavior of the program other than by changing:</strong></p>\n<p id=\"so_32986193_32986347_1\">(3.1) \u2014 the size and/or alignment of the closure type, </p>\n<p id=\"so_32986193_32986347_2\">(3.2)  \u2014 <strong>whether the closure type is trivially copyable</strong> (Clause 9), </p>\n<p id=\"so_32986193_32986347_3\">(3.3) \u2014 whether the\n  closure type is a standard-layout class (Clause 9), or </p>\n<p id=\"so_32986193_32986347_4\">(3.4)  \u2014 whether\n  the closure type is a POD class (Clause 9).</p>\n<p id=\"so_32986193_32986347_5\">An implementation shall\n  not add members of rvalue reference type to the closure type</p>\n</blockquote>\n<p><strong>Thus, it's implementation dependent.</strong></p>\n", "LastEditorUserId": "3747990", "LastActivityDate": "2016-08-25T11:21:32.500", "Score": "13", "CreationDate": "2015-10-07T07:35:45.333", "ParentId": "32986193", "CommentCount": "0", "OwnerUserId": "2352671", "LastEditDate": "2016-08-25T11:21:32.500"}});