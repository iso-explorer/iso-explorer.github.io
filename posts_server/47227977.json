post_cb({"47229011": {"ParentId": "47227977", "CommentCount": "3", "Body": "<p><a href=\"http://eel.is/c++draft/basic.compound#def:invalid_pointer_value\" rel=\"noreferrer\"><strong>[basic.compound]</strong></a> says:</p>\n<blockquote>\n<p id=\"so_47227977_47229011_0\">Every value of pointer type is one of the following:</p>\n<ul>\n<li>a pointer to an object or function (the pointer is said to point to the object or function), or</li>\n<li>a pointer past the end of an object ([expr.add]), or</li>\n<li>the null pointer value ([conv.ptr]) for that type, or</li>\n<li>an invalid pointer value.</li>\n</ul>\n</blockquote>\n<p>By the process of elimination we can deduce that <code>p</code> is an invalid pointer value.</p>\n<p><a href=\"http://eel.is/c++draft/basic.stc#1.4\" rel=\"noreferrer\"><strong>[basic.stc]</strong></a> says:</p>\n<blockquote>\n<p id=\"so_47227977_47229011_1\"><strong>Indirection through an invalid pointer value</strong> and passing an invalid\n  pointer value to a deallocation function <strong>have undefined behavior</strong>. Any\n  other use of an invalid pointer value has implementation-defined\n  behavior.</p>\n</blockquote>\n<p>As indirection operator is said to perform indirection by <a href=\"http://eel.is/c++draft/expr.unary.op#1\" rel=\"noreferrer\"><strong>[expr.unary.op]</strong></a>, I would say, that expression <code>*p</code> causes UB no matter if the result is used or not.</p>\n", "OwnerUserId": "3410396", "PostTypeId": "2", "Id": "47229011", "Score": "8", "CreationDate": "2017-11-10T18:26:55.510", "LastActivityDate": "2017-11-10T18:26:55.510"}, "47229927": {"ParentId": "47227977", "LastEditDate": "2017-11-11T20:26:34.553", "CommentCount": "5", "CreationDate": "2017-11-10T19:32:24.010", "OwnerUserId": "485343", "LastEditorUserId": "485343", "PostTypeId": "2", "Id": "47229927", "Score": "1", "Body": "<blockquote>\n<p id=\"so_47227977_47229927_0\"><em>... some platforms trap on indirection for invalid pointers.</em></p>\n</blockquote>\n<p><em>Most</em> platforms trap on invalid address <em>access</em>. This does not contradict the issue in any way. The question of what happens in <code>*p;</code> boils down to whether an attempt to actually <em>fetch</em> at an invalid address takes place or not.</p>\n<p>The question of <em>fetching</em> is very similar to the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#232\" rel=\"nofollow noreferrer\">core issue 232</a> (indirection through a null pointer). As you have already pointed out, <code>*p;</code> is a <a href=\"http://eel.is/c++draft/stmt.expr\" rel=\"nofollow noreferrer\">discarded value expression</a>, and as such no <a href=\"http://eel.is/c++draft/expr#12\" rel=\"nofollow noreferrer\">lvalue-to-rvalue conversion</a> (\"fetching\") takes place:</p>\n<blockquote>\n<p id=\"so_47227977_47229927_1\">Tom Plum:</p>\n<p id=\"so_47227977_47229927_2\">...it is only the act of \"fetching\", of lvalue-to-rvalue conversion, that triggers the ill-formed or undefined behavior.</p>\n</blockquote>\n<p>And subsequently:</p>\n<blockquote>\n<p id=\"so_47227977_47229927_3\"><strong>Notes from the October 2003 meeting:</strong></p>\n<p id=\"so_47227977_47229927_4\">We agreed that the approach in the standard seems okay: <code>p = 0; *p;</code> is\n  not inherently an error. An lvalue-to-rvalue conversion would give it\n  undefined behavior.</p>\n</blockquote>\n<hr>\n<p>As to whether or not <code>reinterpret_cast&lt;int*&gt;(0xbadface)</code> produces a <em>valid pointer</em>, indeed in implementations with <em>strict pointer safety</em>, it wouldn't be a safely-derived pointer, and as such is invalid and any use of it is UB.</p>\n<p>But in case of <a href=\"http://eel.is/c++draft/basic.stc.dynamic.safety#4\" rel=\"nofollow noreferrer\"><em>relaxed pointer safety</em></a> the resulting pointer is valid (otherwise it would be impossible to use pointers returned from binary libraries and components written in C or other languages).</p>\n</hr>", "LastActivityDate": "2017-11-11T20:26:34.553"}, "47227977": {"CommentCount": "28", "CreationDate": "2017-11-10T17:13:34.983", "PostTypeId": "1", "AcceptedAnswerId": "47229011", "LastEditorUserId": "4832499", "LastActivityDate": "2017-11-11T20:26:34.553", "LastEditDate": "2017-11-10T17:35:13.240", "ViewCount": "274", "FavoriteCount": "5", "Title": "Is dereferencing invalid pointers legal if no lvalue-to-rvalue conversion occurs", "Id": "47227977", "Score": "12", "Body": "<p>Try as I might, the closest answer I've seen is <a href=\"https://stackoverflow.com/questions/7346634/dereferencing-an-invalid-pointer-then-taking-the-address-of-the-result/7346775\">this</a>, with two completely opposing answers(!)</p>\n<p>The question is simple, is this legal?</p>\n<pre><code>auto p = reinterpret_cast&lt;int*&gt;(0xbadface);\n*p;  // legal?\n</code></pre>\n<p>My take on the matter</p>\n<ol>\n<li><a href=\"http://eel.is/c++draft/expr.reinterpret.cast#:cast,integer_to_pointer\" rel=\"noreferrer\">Casting integer to pointer</a>: no restrictions on what may be casted</li>\n<li><a href=\"http://eel.is/c++draft/expr.unary.op#1\" rel=\"noreferrer\">Indirection</a>: only states the result is a lvalue.</li>\n<li><a href=\"http://eel.is/c++draft/basic.life\" rel=\"noreferrer\">Lifetimes</a>: only states what can't be done on objects, there is no object here</li>\n<li><a href=\"http://eel.is/c++draft/stmt.expr\" rel=\"noreferrer\">Expression statements</a>: <code>*p</code> is a discarded value expression</li>\n<li><a href=\"http://eel.is/c++draft/expr#12\" rel=\"noreferrer\">Discarded value expressions</a>: no lvalue-to-rvalue conversion occurs</li>\n<li><a href=\"http://eel.is/c++draft/basic.lval#8\" rel=\"noreferrer\">Undefined-ness of lvalues</a>: aka strict aliasing rule, only if the lvalue is converted to a rvalue</li>\n</ol>\n<p>So I conclude there is nothing explicitly saying this is undefined behaviour. Yet I distinctively remember that some platforms trap on indirection for invalid pointers. What went wrong with my reasoning?</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "4832499", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_47227977_47229011_1": {"section_id": 7183, "quality": 0.9545454545454546, "length": 21}, "so_47227977_47229011_0": {"section_id": 7185, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_47227977_47229011_0": {"section_id": 6929, "quality": 0.8333333333333334, "length": 5}, "so_47227977_47229927_2": {"section_id": 5, "quality": 0.625, "length": 5}}, "n4659": {"so_47227977_47229011_1": {"section_id": 8671, "quality": 0.9090909090909091, "length": 20}, "so_47227977_47229011_0": {"section_id": 8732, "quality": 1.0, "length": 6}}}});