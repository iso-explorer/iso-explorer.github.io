post_cb({"bq_ids": {"n4140": {"so_644461_644476_1": {"length": 26, "quality": 0.9629629629629629, "section_id": 564}, "so_644461_644476_0": {"length": 15, "quality": 1.0, "section_id": 563}}, "n3337": {"so_644461_644476_1": {"length": 26, "quality": 0.9629629629629629, "section_id": 555}, "so_644461_644476_0": {"length": 15, "quality": 1.0, "section_id": 554}}, "n4659": {"so_644461_644476_1": {"length": 26, "quality": 0.9629629629629629, "section_id": 587}, "so_644461_644476_0": {"length": 15, "quality": 1.0, "section_id": 586}}}, "644475": {"Body": "<p>This is discussed in \"Effective C++\" by Scott Meyer. The reason this is ambiguous is that they wanted to ensure that merely changing the visibility of a member wouldn't change the meaning of already-existing code elsewhere.</p>\n<p>Otherwise, suppose your C class was in a header somewhere. If you had a private C(int) member, the code you present would call C(float). If, for some reason, the C(int) member was made public, the old code would suddenly call that member, even though neither the <em>old code, nor the function it called had changed</em>.</p>\n<p>EDIT: More reasons: </p>\n<p>Even worse, suppose you had the following 2 functions:</p>\n<pre><code>C A::foo() \n{\n    return C(1.0);\n}\n\nC B::bar() \n{\n    return C(1.0);\n}\n</code></pre>\n<p>These two functions could call different functions depending on whether either foo or bar was declared as a friend of C, or whether A or B inherits from it. Having <em>identical</em> code call different functions is scary.</p>\n<p>(That's probably not as well put as Scott Meyer's discussion, but that's the idea.)</p>\n", "CreationDate": "2009-03-13T20:18:38.457", "ParentId": "644461", "CommentCount": "2", "LastEditDate": "2009-03-13T20:33:08.313", "PostTypeId": "2", "LastEditorDisplayName": "jder", "LastActivityDate": "2009-03-13T20:33:08.313", "LastEditorUserId": "3737", "Id": "644475", "OwnerDisplayName": "jder", "Score": "18", "OwnerUserId": "3737"}, "644481": {"Id": "644481", "PostTypeId": "2", "Body": "<p>I don't think that:</p>\n<pre><code>C p(0);\n</code></pre>\n<p>is being converted to:</p>\n<pre><code>C(float t)\n</code></pre>\n<p>you probably need to do:</p>\n<pre><code>C p(0.0f);\n</code></pre>\n", "LastActivityDate": "2009-03-13T20:19:39.533", "CommentCount": "1", "CreationDate": "2009-03-13T20:19:39.533", "ParentId": "644461", "Score": "-1", "OwnerUserId": "61915"}, "644476": {"Body": "<p>0 is an <code>int</code> type. Because it can be implicitly cast to either a float or char equally, the call is ambiguous. <strong>Visibility is irrelevant for these purposes.</strong></p>\n<p>Either put <code>0.0</code>, <code>0.</code>, or <code>0.0f</code>, or get rid of the <code>C(char)</code> constructor entirely.</p>\n<p>Edit: Relevant portion of the standard, section 13.3:</p>\n<blockquote>\n<p id=\"so_644461_644476_0\">3) [...] But, once the candidate functions and argument lists have been identified, the selection of the best function is the same in all cases:</p>\n<ul>\n<li>First, a subset of the candidate functions\u2014those that have the proper number of arguments and meet certain other conditions\u2014is selected to form a set of viable functions (13.3.2).</li>\n<li>Then the best viable function is selected based on the implicit conversion sequences (13.3.3.1) needed to match each argument to the corresponding parameter of each viable function.</li>\n</ul>\n<p id=\"so_644461_644476_1\">4) If a best viable function exists and is unique, overload resolution succeeds and produces it as the result. Otherwise overload resolution fails and the invocation is ill-formed. When overload resolution succeeds, and the best viable function is not accessible (clause 11) in the context in which it is used, the program is ill-formed.</p>\n</blockquote>\n<p>Note that visibility is not part of the selection process.</p>\n", "CreationDate": "2009-03-13T20:18:41.720", "ParentId": "644461", "CommentCount": "9", "LastEditDate": "2009-03-14T17:11:27.443", "PostTypeId": "2", "LastEditorDisplayName": "greyfade", "LastActivityDate": "2009-03-14T17:11:27.443", "LastEditorUserId": "33345", "Id": "644476", "OwnerDisplayName": "greyfade", "Score": "7", "OwnerUserId": "33345"}, "644461": {"ViewCount": "3363", "Body": "<p>Can you tell me why the following code is giving me the following error - <em>call of overloaded \"C(int)\" is ambiguous</em></p>\n<p>I would think that since C(char x) is private, only the C(float) ctor is visible from outside and that should be called by converting int to float.</p>\n<p>But that's not the case. </p>\n<pre><code>class C\n{\n    C(char  x)\n    {\n    }\npublic:\n    C(float t)\n    {\n    }\n};\n\nint main()\n{\n    C p(0);\n}\n</code></pre>\n", "AcceptedAnswerId": "644475", "Title": "C++ - Constructor overloading - private and public", "CreationDate": "2009-03-13T20:15:56.810", "Id": "644461", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2009-03-13T20:23:08.120", "LastEditorDisplayName": "Iraimbilanja", "OwnerDisplayName": "Happy-Go-Lucky", "LastActivityDate": "2009-03-14T17:11:27.443", "Score": "8", "Tags": "<c++><compiler-construction><constructor><overloading><private>", "AnswerCount": "3"}});