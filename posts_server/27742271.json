post_cb({"27742271": {"CommentCount": "0", "ViewCount": "147", "CreationDate": "2015-01-02T12:31:25.220", "LastActivityDate": "2015-04-17T11:28:16.163", "Title": "Specializing \"type argument\" with \"non-type argument\" (or the other way around)", "PostTypeId": "1", "Id": "27742271", "Score": "1", "Body": "<p>What I'd like to achieve is demonstrated with the toy-example below.</p>\n<pre><code>#include &lt;cstddef&gt;\n\ntemplate&lt;size_t ElementSize&gt;\nclass Buffer\n{\npublic:\n\n    char buffer[ElementSize];\n};\n\ntemplate&lt;typename T&gt;\nclass Buffer&lt;sizeof(T)&gt;\n{\npublic:\n\n    char buffer[sizeof(T)];\n};\n\nint main()\n{\n    Buffer&lt;4&gt; b1;   // buffer with 4 bytes\n    Buffer&lt;int&gt; b2; // buffer with space for \"int\"\n}\n</code></pre>\n<p>This code obviously doesn't compile:</p>\n<pre><code>$ g++ test.cpp \ntest.cpp:12:7: error: template argument \u2018sizeof (T)\u2019 involves template parameter(s)\n class Buffer&lt;sizeof(T)&gt;\n       ^\ntest.cpp: In function \u2018int main()\u2019:\ntest.cpp:22:12: error: type/value mismatch at argument 1 in template parameter list for \u2018template&lt;long unsigned int ElementSize&gt; class Buffer\u2019\n  Buffer&lt;int&gt; b2; // buffer with space for \"int\"\n            ^\ntest.cpp:22:12: error:   expected a constant of type \u2018long unsigned int\u2019, got \u2018int\u2019\ntest.cpp:22:16: error: invalid type in declaration before \u2018;\u2019 token\n  Buffer&lt;int&gt; b2; // buffer with space for \"int\"\n</code></pre>\n<p>Is there any way I could have two specializations of such template - one using explicit size in bytes (non-type argument), the other taking the size (with <code>sizeof()</code>) from the type <code>T</code> (type argument)? I'm interested in a solution that doesn't need two separate templates with distinct names or any <code>#define</code> macros.</p>\n<p>I tried to implement that in \"reverse\" - having the <code>&lt;typename T&gt;</code> as the primary template and the one using <code>size_t</code> as the specialization (passing <code>char[sizeof(T)]</code> or <code>std::aligned_storage&lt;...&gt;::type</code> to the primary template), but that fails too.</p>\n", "Tags": "<c++><templates><partial-specialization>", "OwnerUserId": "157344", "AnswerCount": "2"}, "27745081": {"ParentId": "27742271", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Class templates cannot be overloaded. If a class template <code>Buffer</code> takes a non-type parameter of type <code>size_t</code>, then each time you write <code>Buffer&lt;thing&gt;</code> the <code>thing</code> has to be a valid non-type argument; it can't be a type. The reverse is also true - if <code>Buffer</code> takes a type parameter, then each time you write <code>Buffer&lt;thing&gt;</code> <code>thing</code>'s got to be a type.</p>\n<p>The template arguments of partial specializations are always <em>deduced</em> during partial specialization matching; you can never explicitly specify them.</p>\n<p>Function templates, however, can be overloaded. So you can write overloading <code>make_buffer</code>s and use <code>auto</code>:</p>\n<pre><code>template&lt;class T&gt; Buffer&lt;sizeof(T)&gt; make_buffer() { return {}; }\ntemplate&lt;size_t Size&gt; Buffer&lt;Size&gt; make_buffer() { return {}; }\n\nauto buffer1 = make_buffer&lt;int&gt;();\nauto buffer2 = make_buffer&lt;42&gt;();\n</code></pre>\n<p>And you can use <code>decltype</code> to achieve a uniform, but tortured syntax:</p>\n<pre><code>decltype(make_buffer&lt;int&gt;()) buffer1;\ndecltype(make_buffer&lt;42&gt;()) buffer2;\n</code></pre>\n<p>You can then write a macro for this easily.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2015-01-02T16:28:54.167", "Id": "27745081", "Score": "2", "CreationDate": "2015-01-02T16:17:07.943", "LastActivityDate": "2015-01-02T16:28:54.167"}, "bq_ids": {"n4140": {"so_27742271_27742637_0": {"section_id": 142, "quality": 0.9411764705882353, "length": 16}, "so_27742271_27742637_3": {"section_id": 142, "quality": 0.8571428571428571, "length": 6}, "so_27742271_27742637_2": {"section_id": 142, "quality": 0.9, "length": 9}}, "n3337": {"so_27742271_27742637_0": {"section_id": 136, "quality": 0.9411764705882353, "length": 16}, "so_27742271_27742637_3": {"section_id": 137, "quality": 0.7142857142857143, "length": 5}, "so_27742271_27742637_2": {"section_id": 136, "quality": 0.9, "length": 9}}, "n4659": {"so_27742271_27742637_3": {"section_id": 146, "quality": 0.8571428571428571, "length": 6}, "so_27742271_27742637_2": {"section_id": 142, "quality": 0.6, "length": 6}}}, "27742637": {"ParentId": "27742271", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>No, you can't. Once we have <code>template &lt;size_t Size&gt; class Buffer</code>, we're pretty limited to what we can do as far as specializations go. Namely, \u00a714.5.5/8.1:</p>\n<blockquote>\n<p id=\"so_27742271_27742637_0\">A partially specialized non-type argument expression shall not involve a template parameter of the\n  partial specialization except when the argument expression is a simple <em>identifier</em>. <em>[Example:</em></p>\n<pre><code>template &lt;int I, int J&gt; struct A {};\ntemplate &lt;int I&gt; struct A&lt;I+5, I*2&gt; {}; // error\n\ntemplate &lt;int I, int J&gt; struct B {};\ntemplate &lt;int I&gt; struct B&lt;I, I&gt; {}; // OK\n</code></pre>\n<p id=\"so_27742271_27742637_1\"><em>- end example ]</em></p>\n</blockquote>\n<p>So the only partially specialization we could do is:</p>\n<pre><code>template &lt;size_t I&gt; class Buffer&lt;I&gt; { .. };\n</code></pre>\n<p>which runs afoul of \u00a714.5.5/8.3</p>\n<blockquote>\n<p id=\"so_27742271_27742637_2\">The argument list of the specialization shall not be identical to the implicit argument list of the primary template.</p>\n</blockquote>\n<p>In the other direction, we run afoul of 14.5.5/8.4:</p>\n<blockquote>\n<p id=\"so_27742271_27742637_3\">The specialization shall be more specialized than the primary template</p>\n</blockquote>\n<p>And in no way is a <code>size_t</code> more specialized than a <code>T</code>. </p>\n<p>What you could do instead is just create an alias:</p>\n<pre><code>template &lt;size_t ElementSize&gt;\nclass Buffer {\n    char buffer[ElementSize];\n};\n\ntemplate &lt;typename T&gt;\nusing BufferFromType = Buffer&lt;sizeof(T)&gt;;    \n\n// or, if not C++11, another type\ntemplate &lt;typename T&gt;\nclass BufferFromType : public Buffer&lt;sizeof(T)&gt; { };\n</code></pre>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-04-17T11:28:16.163", "Id": "27742637", "Score": "3", "CreationDate": "2015-01-02T12:57:45.033", "LastActivityDate": "2015-04-17T11:28:16.163"}});