post_cb({"bq_ids": {"n4140": {"so_29336262_29336262_0": {"length": 21, "quality": 0.7777777777777778, "section_id": 5414}}, "n3337": {"so_29336262_29336262_0": {"length": 21, "quality": 0.7777777777777778, "section_id": 5209}}, "n4659": {"so_29336262_29336262_0": {"length": 21, "quality": 0.7777777777777778, "section_id": 6836}}}, "29336262": {"ViewCount": "135", "Body": "<p>The following code (<a href=\"http://coliru.stacked-crooked.com/a/d8c456320ee02aab\" rel=\"nofollow\">live example</a>) does not compile:</p>\n<pre><code>struct S {};\ntypedef struct S T;\nS s = T();          // OK\nstruct T * p;       // error: elaborated type refers to a typedef\nT::T(){}            // error: C++ requires a type specifier for all declarations\n</code></pre>\n<p>Why is the language designed to not permit the last two lines?</p>\n<hr>\n<p>Relevant Standard quote (N4140 \u00a77.1.3/8):</p>\n<blockquote>\n<p id=\"so_29336262_29336262_0\">[ Note: A <em>typedef-name</em> that names a class type, or a cv-qualified version thereof, is also a <em>class-name</em> (9.1).\n  If a <em>typedef-name</em> is used to identify the subject of an <em>elaborated-type-specifier</em> (7.1.6.3), a class definition (Clause 9), a constructor declaration (12.1), or a destructor declaration (12.4), the program is ill-formed.\n  \u2014end note ]</p>\n</blockquote>\n</hr>", "Title": "Why can a typedef-name for a struct not be used interchangeably with the struct name?", "CreationDate": "2015-03-29T23:36:12.490", "LastActivityDate": "2015-03-30T00:25:11.440", "CommentCount": "8", "LastEditDate": "2015-03-30T00:06:33.593", "PostTypeId": "1", "LastEditorUserId": "36565", "Id": "29336262", "Score": "3", "OwnerUserId": "1042389", "Tags": "<c++><language-lawyer>", "AnswerCount": "1"}, "29336361": {"Id": "29336361", "PostTypeId": "2", "Body": "<p>So there are three unrelated issues. The first one you have in the quote you provide:</p>\n<pre><code>struct T * p;\n</code></pre>\n<p>That is illegal as <code>T</code> is a typedef.</p>\n<pre><code>T{};\n</code></pre>\n<p>That is illegal at namespace level, but would be legal in other concepts, for example as part of the initialization of a global, or inside a function:</p>\n<pre><code>T t = T{};\nvoid f() { T{}; }\n</code></pre>\n<p>It really means to create a <em>value-initialized</em> temporary object of type <code>T</code>.</p>\n<pre><code>T::T(){}\n</code></pre>\n<p>That would be a valid definition for a default constructor, except that you did not declare one. If you modify the <code>S</code> to have a user declared default constructor that would work:</p>\n<pre><code>struct S { S(); };\n</code></pre>\n<p><strong>Why is the language designed to not permit the last two lines?</strong></p>\n<p>Those two lines, in the updated question are:</p>\n<pre><code>struct T* p;\nT::T() {}\n</code></pre>\n<p>The second one is legal, but you are trying to define a function that has not been declared as a member, so this is also unrelated to the original text.  Which leaves us with one: <code>struct T* p</code>.</p>\n<p>The motive comes from C.  The identifiers for user defined types and other names appear to live in different scopes, when lookup is trying to resolve a name not qualified with <code>struct</code> or <code>enum</code>, it will ignore struct and enums, when trying to resolve a <code>struct</code> or <code>enum</code> it ignores everything else. The following is valid C (and C++):</p>\n<pre><code>struct T {};          // 1\ntypedef struct S {} T;  // 2\nstruct T t;\n</code></pre>\n<p>In C++ the rules for lookup changed a bit and you can use the type specifiers without explicitly qualifying it but that is a different thing.  Additionally, typedef-ed names can be used in other contexts that were not possible in C.</p>\n<p>An special case is lookup for an elaborated type specifier, should the typedef-ed name be usable in an elaborated type specifier? If it was, the semantics of the program above would change and where in C <code>t</code> is of type <code>T</code> (defined in 1), in C++ it would become <code>S</code> (defined in 2).</p>\n<p>Note that this is to some extent a wild guess, I did not make the rules and I don't know what went into consideration there. Note that C and C++ were never really compatible in this respect, a similar example changes semantics in C and C++:</p>\n<pre><code>int T;\nvoid f() {\n   struct T { int data[10]; };\n   printf(\"%d\\n\", sizeof(T));\n}\n</code></pre>\n<p>That program will print a number 10x larger in C++ than in C.  But the ability to use a type without having to qualify it with <code>class</code> or <code>struct</code> was probably more important than breaking compatibility in a few cases...</p>\n", "LastEditorUserId": "36565", "LastActivityDate": "2015-03-30T00:25:11.440", "Score": "3", "CreationDate": "2015-03-29T23:49:14.420", "ParentId": "29336262", "CommentCount": "6", "OwnerUserId": "36565", "LastEditDate": "2015-03-30T00:25:11.440"}});