post_cb({"38353442": {"ParentId": "38352691", "CommentCount": "2", "Body": "<p>Scott Mayers is undoubtedly a c++ expert, but he doesn't always get it right.</p>\n<p>Problem: </p>\n<p>Allow most efficient possible construction, limiting copies where possible</p>\n<p>Answer: </p>\n<p>X-value constructor, limited by std::enable_if:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n\nclass MyClass\n{\n\npublic:\n\n    template &lt;class T, std::enable_if_t&lt;std::is_constructible&lt;std::string, T&gt;::value&gt;* = nullptr&gt;\n    MyClass(T&amp;&amp; data)\n    : _data(std::forward&lt;T&gt;(data))\n    {\n        std::cout &lt;&lt; \"MyClass universal reference template c'tor\" &lt;&lt; std::endl;\n    }\n\nprivate:\n\n    std::string _data;\n\n};\n\nint main()\n{\n    using namespace std::string_literals;\n\n    auto a = MyClass(\"hello\"s);\n    auto b = MyClass(\"world\");\n\n\n    const auto s = \"Hello, World\"s;\n    auto s2 = \"Hello, World\";\n\n    auto c = MyClass(s);\n    auto d = MyClass(s2);\n\n// won't compile\n//    auto e = MyClass(10);\n\n}\n</code></pre>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "38353442", "Score": "2", "CreationDate": "2016-07-13T13:42:17.677", "LastActivityDate": "2016-07-13T13:42:17.677"}, "38352905": {"ParentId": "38352691", "CommentCount": "0", "Body": "<p>That is not specific to delegating constructors. Constructors (and conversion functions) do not have names, and thus there is no way in the langauge to supply explicit template arguments to them. Quoting C++14, [temp.mem] 14.5.2/5:</p>\n<blockquote>\n<p id=\"so_38352691_38352905_0\">[ <em>Note:</em> Because the explicit template argument list follows the function template name,\n  and because conversion member function templates and constructor member function templates are called\n  without using a function name, there is no way to provide an explicit template argument list for these\n  function templates. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>Notes are not normative, but this note just explicitly spells out what follows from the rules throughout chapter 14.</p>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "38352905", "Score": "4", "CreationDate": "2016-07-13T13:18:14.527", "LastActivityDate": "2016-07-13T13:18:14.527"}, "bq_ids": {"n4140": {"so_38352691_38352905_0": {"section_id": 114, "quality": 0.9117647058823529, "length": 31}}, "n3337": {"so_38352691_38352905_0": {"section_id": 109, "quality": 0.9117647058823529, "length": 31}}, "n4659": {"so_38352691_38352905_0": {"section_id": 118, "quality": 0.9117647058823529, "length": 31}}}, "38352691": {"CommentCount": "0", "AcceptedAnswerId": "38352905", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-07-13T13:09:16.523", "LastActivityDate": "2016-07-13T13:42:17.677", "LastEditDate": "2017-05-23T12:22:30.133", "ViewCount": "195", "FavoriteCount": "1", "Title": "c++11: delegate constructor - can't select constructor template?", "Id": "38352691", "Score": "4", "Body": "<p>This is a follow up question to:<br>\n<a href=\"https://stackoverflow.com/questions/38346436/c11-dedicated-proxy-constructors-delegating-to-private-univeral-reference-co\">c++11 dedicated \"proxy constructors\" delegating to private univeral reference constructor?</a></br></p>\n<p>I would like to get rid off the \"enum class Dummy\" used there.</p>\n<p>But i don't manage to delegate to a template constructor.<br>\nSee code example below.</br></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;typeinfo&gt;\n\nclass MyClass\n{\n\nprivate:\n\n    template &lt;class T&gt;\n    MyClass(T&amp;&amp; data)\n    : _data(std::forward&lt;T&gt;(data))\n    {\n        std::cout &lt;&lt; \"MyClass universal reference template c'tor\" &lt;&lt; std::endl;\n    }\n\npublic:\n\n\n    // proxy c'tors delegating to universal reference c'tor\n    MyClass (std::string const &amp; data)\n    : MyClass&lt;std::string&gt;(data)\n    {\n        std::cout &lt;&lt; \"MyClass lvalue c'tor\" &lt;&lt; std::endl;\n    }\n\n    MyClass (std::string &amp;&amp; data)\n    : MyClass&lt;std::string&gt;(std::move(data))\n    {\n        std::cout &lt;&lt; \"MyClass rvalue c'tor\" &lt;&lt; std::endl;\n    }\n\nprivate:\n\n    std::string _data;\n\n};\n\nint\nmain(\n        int,\n        char**)\n{\n\n    {\n        std::string str(\"demo\");\n        MyClass myClass(str);\n    }\n\n    {\n        MyClass myClass(\"hello, world\");\n    }\n\n    return 0;\n}\n</code></pre>\n<p>I get following error:<br/></p>\n<pre><code>main2.cpp: In constructor 'MyClass::MyClass(const string&amp;)':\nmain2.cpp:21:7: error: 'class MyClass MyClass::MyClass' is not a non-static data member of 'MyClass'\n : MyClass&lt;std::string&gt;(data)\n   ^\nmain2.cpp:21:14: error: expected '(' before '&lt;' token\n : MyClass&lt;std::string&gt;(data)\n          ^\nmain2.cpp:21:14: error: expected '{' before '&lt;' token\nmain2.cpp: In constructor 'MyClass::MyClass(std::__cxx11::string&amp;&amp;)':\nmain2.cpp:27:7: error: 'class MyClass MyClass::MyClass' is not a non-static data member of 'MyClass'\n : MyClass&lt;std::string&gt;(std::move(data))\n   ^\nmain2.cpp:27:14: error: expected '(' before '&lt;' token\n : MyClass&lt;std::string&gt;(std::move(data))\n          ^\nmain2.cpp:27:14: error: expected '{' before '&lt;' token\nmain2.cpp: In function 'int main(int, char**)':\nmain2.cpp:11:5: error: 'MyClass::MyClass(T&amp;&amp;) [with T = std::__cxx11::basic_string&lt;char&gt;&amp;]' is private\n MyClass(T&amp;&amp; data)\n ^\nmain2.cpp:46:28: error: within this context\n     MyClass myClass(str);\n                        ^\nmain2.cpp:11:5: error: 'MyClass::MyClass(T&amp;&amp;) [with T = const char (&amp;)[13]]' is private\n MyClass(T&amp;&amp; data)\n ^\nmain2.cpp:50:39: error: within this context\n     MyClass myClass(\"hello, world\");\n</code></pre>\n", "Tags": "<c++><c++11>", "OwnerUserId": "2685189", "AnswerCount": "2"}});