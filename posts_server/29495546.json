post_cb({"29495546": {"ViewCount": "1538", "Body": "<p>I want to read from a file backwards - from the end to the beginning .\nThis works , but not only I would like to get the characters from the file , I would like to remove them as I read .</p>\n<pre><code>std::fstream fileA;\nfileA.seekg(-1, fileA.end);\nint size = fileA.tellg();\nfor (i = 1; i &lt;= size; i++)\n{\n    fileA.seekg(-i, fileA.end);\n    fileA.get(ch);\n\n    std::cout &lt;&lt; ch;\n}\n</code></pre>\n<p>is there anyway to do this , without copying the content and creating a new file without what I have read ? </p>\n", "AcceptedAnswerId": "29496377", "Title": "Reading file backwards , c++ ifstream", "CreationDate": "2015-04-07T15:40:29.717", "Id": "29495546", "CommentCount": "7", "LastEditDate": "2015-04-07T17:15:56.807", "PostTypeId": "1", "LastEditorUserId": "3723423", "LastActivityDate": "2015-04-07T17:15:56.807", "Score": "1", "OwnerUserId": "4381424", "Tags": "<c++><fstream>", "AnswerCount": "2"}, "29496377": {"Id": "29496377", "PostTypeId": "2", "Body": "<p>If you just want to take the binary data an present it in reverse order, regardless of it's meaning, your code is ok.  </p>\n<p>Some recommendations:  </p>\n<ul>\n<li><p>You should then open the stream in <code>binary</code> for consistency accross the platform (i.e. avoid that a newline is transformed in double newline on platforms such as windows which encode it as <code>0x0d,0x0a</code>).  </p></li>\n<li><p>You could also consider using in the loop the relative position to the current one, to navigate backwards, instead of always going to the end and repoistion yourself from the absolute position from the end.  </p></li>\n</ul>\n<p>Here the fine-tuned code:  </p>\n<pre><code>ifstream fileA(\"test.txt\", ios::binary);  // binary data because binary revert\nfileA.seekg(-1, ios::end); // position on last char to be read \nchar ch; \nfor (; fileA.get(ch); fileA.seekg(-2, ios::cur))  // try to read and rewind.  \n    std::cout &lt;&lt; ch;\n</code></pre>\n<p>Your code is however not able to read proper <a href=\"https://en.wikipedia.org/wiki/UTF-8\" rel=\"nofollow noreferrer\">UTF8</a> encoded files, because the multibyte sequences will be mecanically revereted, and their reverted version is invalid UTF8: </p>\n<ul>\n<li>This is not an issue if you only have ASCII caracters in your file.  </li>\n<li>If UTF8 consistency is a problem for you, you could consider a very simple <strong>workaround</strong>:  if you read a character <code>u</code> for which <code>(u &amp; 0xC0) == 0x80</code> , you have to read all the preceding chars until this condition goes false, and output the group of bytes (between 2 and 8) in the correct order.  </li>\n</ul>\n<p>Here how to do it: </p>\n<pre><code>...                           // If UTF-8 must be processed correctly\nfileA.seekg(-1, ios::end);\nchar ch, buft[9]{},*p;\nbool mb=false; \nfor (; fileA.get(ch); fileA.seekg(-2, ios::cur))\n{\n    if (mb) {  // if we are already processing a multibyte sequence\n        if ((ch &amp; 0xC0) == 0x80 &amp;&amp; p!=buft) // still another byte ?\n            *--p=ch; \n        else {\n            cout &lt;&lt;ch&lt;&lt;p;   // if no other output the current leading char followed by the multibyte encoding that we've identified\n            mb=false;      // and multibyte processing is then finished\n        }\n    }\n    else if ((ch &amp; 0xC0) == 0x80) {  // if a new multibyte sequence is identified\n        mb =true;      // start its processing\n        buft[7]=ch; \n        p=buft+7; \n    }\n    else std::cout &lt;&lt; ch;  // normal chars ar procesed as before.\n}\n</code></pre>\n<p>Here a <a href=\"http://goo.gl/sDUH1C\" rel=\"nofollow noreferrer\">runnable demo</a>. </p>\n<p>Last point:  removing the last byte from the input stream  is operating system dependent.  You should have a look at <a href=\"https://stackoverflow.com/questions/873454/how-to-truncate-a-file-in-c\">this SO question</a> to get answers on how to do it on linux/posix and windows.    </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-04-07T17:08:43.733", "Score": "1", "CreationDate": "2015-04-07T16:21:40.743", "ParentId": "29495546", "CommentCount": "0", "OwnerUserId": "3723423", "LastEditDate": "2017-05-23T12:10:48.007"}, "bq_ids": {"n4140": {"so_29495546_29496571_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 5694}}, "n3337": {"so_29495546_29496571_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 5477}}, "n4659": {"so_29495546_29496571_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 7139}}}, "29496571": {"Id": "29496571", "PostTypeId": "2", "Body": "<p>This really isn't possible without using one of the methods outlined <a href=\"https://stackoverflow.com/questions/10813930/read-a-file-backwards\">here</a> or <a href=\"https://stackoverflow.com/a/9027103/4342498\">here</a>.  If look at an istream_iterator you will see that it is an input iterator (24.6.1)(1)</p>\n<blockquote>\n<p id=\"so_29495546_29496571_0\">The class template istream_iterator is an input iterator</p>\n</blockquote>\n<p>Then from (24.2.1)(table 105)</p>\n<pre><code>Random Access -&gt; Bidirectional -&gt; Forward -&gt; Input\n                                          -&gt; Output\n</code></pre>\n<p>As you can see an input iterator is a more restrictive forward iterator and a forward iterator can only go in one direction.  Because of this behavior thier isn't a standard way to start at the end of an input stream and walk backwards</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-04-07T16:33:37.357", "Score": "2", "CreationDate": "2015-04-07T16:33:37.357", "ParentId": "29495546", "CommentCount": "1", "OwnerUserId": "4342498", "LastEditDate": "2017-05-23T10:24:18.720"}});