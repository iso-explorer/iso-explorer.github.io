post_cb({"7298926": {"ParentId": "7298872", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2011-09-04T11:37:03.117", "Score": "5", "LastEditorUserId": "168175", "LastEditDate": "2011-09-04T14:13:19.077", "Id": "7298926", "OwnerUserId": "168175", "Body": "<h2>Logging memory addresses</h2>\n<p>If you want to output a pointer using iostreams (e.g. for logging) then going via <code>void*</code> is the only way of ensuring <code>operator&lt;&lt;</code> hasn't been overloaded in some crazy way.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct foo {\n};\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, foo*) {\n  return out&lt;&lt;\"it's a trap!\";\n}\n\nint main() {\n  foo bar;\n  foo *ptr = &amp;bar;\n\n  std::cout &lt;&lt; ptr &lt;&lt; std::endl;\n  std::cout &lt;&lt; static_cast&lt;void*&gt;(ptr) &lt;&lt; std::endl;\n}\n</code></pre>\n<hr>\n<h2>Testing iostream status</h2>\n<p>iostreams overload <code>operator void*</code> as a status check so that syntax like <code>if (stream)</code> or <code>while (stream)</code> is a short hand way of testing the stream status.</p>\n<hr>\n<h2>Template meta programming</h2>\n<p>You might want to use <code>void*</code> with template metaprogramming sometimes as a reduced catch all, e.g. with SFINAE tricks, but more often than not there's a nicer way around it using a partial specialisation of one form or another.</p>\n<hr>\n<h2>Accessing most derived pointer</h2>\n<p>As Alf pointed out in the comments <code>dynamic_cast&lt;void*&gt;</code> is also useful for getting at the most derived type in a heirarchy, e.g.:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct other {\n  virtual void func() = 0;\n  int c;\n};\n\nstruct foo {\n  virtual void func() { std::cout &lt;&lt; \"foo\" &lt;&lt; std::endl; }\n  int a;\n};\n\nstruct bar : foo, other {\n  virtual void func() { std::cout &lt;&lt; \"bar\" &lt;&lt; std::endl; }\n  int b;\n};\n\nnamespace {\n  void f(foo *ptr) {\n    ptr-&gt;func();\n    std::cout &lt;&lt; ptr &lt;&lt; std::endl;\n    std::cout &lt;&lt; dynamic_cast&lt;void*&gt;(ptr) &lt;&lt; std::endl;\n  }\n\n  void g(other *ptr) {\n    ptr-&gt;func();\n    std::cout &lt;&lt; ptr &lt;&lt; std::endl;\n    std::cout &lt;&lt; dynamic_cast&lt;void*&gt;(ptr) &lt;&lt; std::endl;\n  }\n}\n\nint main() {\n  foo a;\n  bar b;\n  f(&amp;a);\n  f(&amp;b);\n  g(&amp;b);\n}\n</code></pre>\n<p>Gives:</p>\n<pre><code>foo\n0xbfb815f8\n0xbfb815f8\nbar\n0xbfb815e4\n0xbfb815e4\nbar\n0xbfb815ec\n0xbfb815e4\n</code></pre>\n<p>On my system.</p>\n<hr>\n<h2>Exceptions</h2>\n<p>\u00a7 15.3.1 states:</p>\n<blockquote>\n<p id=\"so_7298872_7298926_0\">The exception-declaration shall not denote a pointer or reference to\n  an incomplete type, other than void*, <code>const void*</code>, volatile void*, or\n  const volatile void*.</p>\n</blockquote>\n<p>So it seems to be the only legal way of catching a pointer to an incomplete type is via <code>void*</code>. (Although I think there's possibly bigger issues if you actually needed to use that)</p>\n<hr>\n<h2>Legacy C uses</h2>\n<p>There are a lot of \"legacy\" C uses for <code>void*</code> for storing pointers to data without knowing what it is, but in new C++ code there is almost always a better way of expressing the same functionality.</p>\n</hr></hr></hr></hr></hr>", "LastActivityDate": "2011-09-04T14:13:19.077"}, "7299158": {"ParentId": "7298872", "CommentCount": "2", "CreationDate": "2011-09-04T12:21:40.840", "OwnerUserId": "725163", "PostTypeId": "2", "Id": "7299158", "Score": "2", "Body": "<p><code>void*</code> is frequently used for callbacks.</p>\n<blockquote>\n<p id=\"so_7298872_7299158_0\">Callbacks are generally implemented in the C language using function\n  pointers and auxiliary user-defined data passed as a void pointer for\n  genericity.  </p>\n</blockquote>\n<p>[<a href=\"http://www.crystalclearsoftware.com/cgi-bin/boost_wiki/wiki.pl?Generalizing_C-Style_Callbacks\" rel=\"nofollow\">from here</a>]</p>\n<p>Of course, this is not type-safe, so people come up with ways to wrap this kind of thing, <a href=\"http://ccan.ozlabs.org/info/typesafe_cb.html\" rel=\"nofollow\">like here</a>.</p>\n", "LastActivityDate": "2011-09-04T12:21:40.840"}, "7299185": {"ParentId": "7298872", "CommentCount": "2", "CreationDate": "2011-09-04T12:25:39.930", "OwnerUserId": "887836", "PostTypeId": "2", "Id": "7299185", "Score": "1", "Body": "<p>void * is used in C++ to express a pointer type to an unknown structure. </p>\n<p>So I would use it whenever I have a pointer type where the code shouldn't know what is in there:</p>\n<ul>\n<li>memory allocation</li>\n<li>containers</li>\n<li>...</li>\n</ul>\n<p>Often void * mix quite well with template code to avoid template induced code bloat.</p>\n<p>imagine you implement a</p>\n<pre><code>template &lt;typename T&gt;\nclass vector {\n /*stuff */\n};\n</code></pre>\n<p>you can then create a template specialisation for T * which uses void pointers so the code doesn't get duplicated.</p>\n", "LastActivityDate": "2011-09-04T12:25:39.930"}, "7298883": {"ParentId": "7298872", "CommentCount": "1", "CreationDate": "2011-09-04T11:29:13.613", "OwnerUserId": "828559", "PostTypeId": "2", "Id": "7298883", "Score": "1", "Body": "<p>No it isn't. It's only an idiom to refer to non typed memory</p>\n", "LastActivityDate": "2011-09-04T11:29:13.613"}, "7298872": {"CommentCount": "6", "AcceptedAnswerId": "7298926", "PostTypeId": "1", "LastEditorUserId": "436641", "CreationDate": "2011-09-04T11:27:34.387", "LastActivityDate": "2011-09-20T02:36:06.053", "LastEditDate": "2011-09-20T02:36:06.053", "ViewCount": "274", "FavoriteCount": "1", "Title": "Is void* necessary apart from memory allocation related stuff", "Id": "7298872", "Score": "5", "Body": "<p>Is <code>void*</code> necessary apart from memory allocation related stuff in C++?\nCan you give me an example?</p>\n", "Tags": "<c++><void-pointers>", "OwnerUserId": "833538", "AnswerCount": "6"}, "7298945": {"ParentId": "7298872", "CommentCount": "5", "CreationDate": "2011-09-04T11:39:23.433", "OwnerUserId": "627005", "PostTypeId": "2", "Id": "7298945", "Score": "1", "Body": "<p>One situation where you might want to use void is when passing around data buffers, such as in this function:</p>\n<pre><code>void loadData(void* data, std::size_t size)\n</code></pre>\n<p>A lot of code passes buffers through a char-pointer instead of a void-pointer because, typically, buffers are read in 1 byte chunks, which happens to be the size that the C++ standard ensures a <code>char</code> to have.</p>\n<p>However, using void-pointers is more generic. It's a way for the function to tell you, \"Just give me some data, don't worry about how I'll read it\". The function can then cast the pointer and read the data in chunks or whatever size it likes.</p>\n", "LastActivityDate": "2011-09-04T11:39:23.433"}, "7298951": {"ParentId": "7298872", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2011-09-04T11:39:59.503", "Score": "2", "LastEditorUserId": "191596", "LastEditDate": "2011-09-04T12:04:41.113", "Id": "7298951", "OwnerUserId": "191596", "Body": "<p>external libraries use them often (esp. in C).</p>\n<p>in this case, i'll usually hide the use of these libraries (or the more dangerous portions). i hide them by writing interfaces around them (like wrapping). the interfaces i write serve to introduce type safety into the program. in this case, <code>void*</code> may be required, but at least it's hidden and restricted to a method or callback.</p>\n", "LastActivityDate": "2011-09-04T12:04:41.113"}, "bq_ids": {"n4140": {"so_7298872_7298926_0": {"section_id": 3346, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_7298872_7298926_0": {"section_id": 3216, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_7298872_7298926_0": {"section_id": 4113, "quality": 0.9411764705882353, "length": 16}}}});