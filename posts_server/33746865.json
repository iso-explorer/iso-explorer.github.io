post_cb({"bq_ids": {"n4140": {"so_33746865_33747605_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 179}, "so_33746865_33747605_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 190}, "so_33746865_33747605_3": {"length": 17, "quality": 1.0, "section_id": 194}, "so_33746865_33747605_1": {"length": 9, "quality": 0.9, "section_id": 7085}}, "n3337": {"so_33746865_33747605_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 173}, "so_33746865_33747605_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 184}, "so_33746865_33747605_3": {"length": 16, "quality": 0.9411764705882353, "section_id": 188}, "so_33746865_33747605_1": {"length": 9, "quality": 0.9, "section_id": 6829}}, "n4659": {"so_33746865_33747605_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 184}, "so_33746865_33747605_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 195}, "so_33746865_33747605_3": {"length": 17, "quality": 1.0, "section_id": 200}, "so_33746865_33747605_1": {"length": 9, "quality": 0.9, "section_id": 8586}}}, "33746865": {"ViewCount": "242", "Body": "<p>Consider the following:</p>\n<pre><code>template&lt;typename X&gt;\nstruct Z {};\n\nstruct A\n{\n    using Z = ::Z&lt;int&gt;;\n\n    struct B : Z\n    {\n        using C = Z;\n    };\n};\n</code></pre>\n<p>This compiles fine. Nice. But now add another parameter in <code>Z</code>:</p>\n<pre><code>template&lt;typename X, typename Y&gt;\nstruct Z {};\n\nstruct A\n{\n    template&lt;typename X&gt;\n    using Z = ::Z&lt;X, int&gt;;\n\n    struct B : Z&lt;B&gt;\n    {\n        using C = Z&lt;B&gt;;  // error: too few template arguments for class template 'Z'\n    };\n};\n</code></pre>\n<p>Ok, maybe it makes sense that the definition of template alias <code>Z</code> in class <code>A</code> is visible when deriving nested class <code>B</code>, but not inside its body, triggering the error since the global definition of <code>Z</code> has two parameters.</p>\n<p>But <strong>why</strong> is the behavior different in the first case, when <code>Z</code> is just a type alias in <code>A</code>?</p>\n<p>Finally, make <code>A</code> a template:</p>\n<pre><code>template&lt;typename X, typename Y&gt;\nstruct Z {};\n\ntemplate&lt;typename T&gt;\nstruct A\n{\n    template&lt;typename X&gt;\n    using Z = ::Z&lt;X, int&gt;;\n\n    struct B : Z&lt;B&gt;\n    {\n        using C = Z&lt;B&gt;;\n    };\n};\n</code></pre>\n<p>Now the error is gone. <strong>Why?</strong></p>\n<p>(Tested on Clang 3.6 and GCC 4.9.2)</p>\n", "AcceptedAnswerId": "33747605", "Title": "Template alias visibility in nested class", "CreationDate": "2015-11-17T00:00:16.073", "Id": "33746865", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-11-17T14:23:54.903", "LastEditorUserId": "2644390", "LastActivityDate": "2015-11-17T14:23:54.903", "Score": "12", "OwnerUserId": "2644390", "Tags": "<c++><c++11><language-lawyer><nested-class><template-aliases>", "AnswerCount": "1"}, "33747605": {"Id": "33747605", "PostTypeId": "2", "Body": "<p>In short: Deriving from a specialization of <code>Z</code> introduces the <em>injected-class-name</em> of <code>::Z</code>, which is found before the alias template. If <code>A</code> is a template, however, the <em>injected-class-name</em> is not found anymore because the base class of <code>B</code> is dependent.</p>\n<hr>\n<p>Consider [temp.local]/1: </p>\n<blockquote>\n<p id=\"so_33746865_33747605_0\">Like normal (non-template) classes, class templates have an\n  <em>injected-class-name</em> (Clause 9). <strong>The <em>injected-class-name</em> can be used\n  as a <em>template-name</em> or a <em>type-name</em></strong>.</p>\n</blockquote>\n<p>And [basic.lookup]/3:</p>\n<blockquote>\n<p id=\"so_33746865_33747605_1\">The <em>injected-class-name</em> of a class (Clause 9) is also <strong>considered to be a member of that class for the purposes of name [\u2026] lookup</strong>.</p>\n</blockquote>\n<p><code>Z</code> is looked up as an unqualified name; [basic.lookup.unqual]/7:</p>\n<p><a href=\"https://i.stack.imgur.com/3bq9Q.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/3bq9Q.png\"/></a></p>\n<p>Thus, the <em>injected-class-name</em> <code>Z</code> is found as a member of the base class  <code>Z&lt;B, int&gt;</code>, and used as a <em>template-name</em>, which renders your second program ill-formed. In fact, your first snippet uses the <em>injected-class-name</em> as well - the following snippet won't compile:</p>\n<pre><code>struct A\n{\n    using Z = ::Z&lt;float&gt;;\n    struct B : ::Z&lt;int&gt;\n    {\n        static_assert( std::is_same&lt;Z, ::Z&lt;float&gt;&gt;{}, \"\" );\n    };\n};\n</code></pre>\n<p>Finally, if <code>A</code> is made a template, note that <code>B</code> is a dependent type as per [temp.dep.type]/(9.3)<sup>1</sup>, thus <code>Z&lt;B&gt;</code> is a dependent type as per [temp.dep.type]/(9.7), thus the <strong>base class <code>Z&lt;B&gt;</code> is not examined during lookup for the <em>unqualified-id</em> <code>Z</code></strong> according to [temp.dep]/3:</p>\n<blockquote>\n<p id=\"so_33746865_33747605_2\">In the definition of a class [..], the scope of a\n  dependent base class (14.6.2.1) is not examined during unqualified\n  name lookup either at the point of definition of the class template or\n  member or during an instantiation of the class template or member.</p>\n</blockquote>\n<p>Hence the <em>injected-class-name</em> won't be found.</p>\n<hr>\n<p><sup>1</sup> <code>B</code> is a \"nested class [..] that is a <em>dependent member</em> of the current instantiation\" (emphasis mine), since </p>\n<blockquote>\n<p id=\"so_33746865_33747605_3\">A name is a <em>dependent member</em> of the current instantiation if it is a\n  member of the current instantiation that, when looked up, refers to at\n  least one member of a class that is the current instantiation.</p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2015-11-17T11:31:07.293", "Score": "9", "CreationDate": "2015-11-17T01:23:40.510", "ParentId": "33746865", "CommentCount": "4", "OwnerUserId": "3647361", "LastEditDate": "2015-11-17T11:31:07.293"}});