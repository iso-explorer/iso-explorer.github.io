post_cb({"19986170": {"Id": "19986170", "PostTypeId": "2", "Body": "<p>It is fine GCC is either right/more helpful (it sticks to the standard VERY strongly)</p>\n<p>It can't see why the definition would be ambiguous because you're talking about a type not a member, and type are equal if their names are equal in C++ (names being some mangled form of types involved and such)</p>\n<p>Addendum:</p>\n<p>It'd be wrong if \"nested\" and \"nested\" in the other base were different. It is a struct, not a typedef or using (which are scoped)</p>\n<p>GCC will whine if something is ambiguous, try with -pedantic if you want to make it bitch even where it is not. I see no reason why this should be rejected even if GCC is just being permissive.</p>\n", "LastEditorUserId": "2112028", "LastActivityDate": "2013-11-14T19:11:33.180", "Score": "0", "CreationDate": "2013-11-14T19:05:03.230", "ParentId": "19986123", "CommentCount": "14", "OwnerUserId": "2112028", "LastEditDate": "2013-11-14T19:11:33.180"}, "bq_ids": {"n4140": {"so_19986123_19986123_0": {"length": 41, "quality": 0.9761904761904762, "section_id": 6984}}, "n3337": {"so_19986123_19986123_0": {"length": 41, "quality": 0.9761904761904762, "section_id": 6730}}, "n4659": {"so_19986123_19986123_0": {"length": 41, "quality": 0.9761904761904762, "section_id": 8482}}}, "19986123": {"ViewCount": "281", "Body": "<p>Is this code valid C++(11)?</p>\n<pre><code>struct Base {\n    template &lt;typename&gt;\n    struct nested;\n};\nstruct Derived1 : Base { };\nstruct Derived2 : Base { };\nstruct Derived3 : Derived1, Derived2 { };\n\ntypedef Derived3::nested&lt;int&gt; xxx;\n</code></pre>\n<p><strong>What I know</strong></p>\n<p>The above code fails to compile with:</p>\n<ul>\n<li>Apple LLVM 5.0 (clang-500.2.75)</li>\n<li>Clang 3.4</li>\n</ul>\n<p>But it successfully compiles with:</p>\n<ul>\n<li>gcc 4.9.0 20131110 (experimental)</li>\n<li>gcc 4.8</li>\n</ul>\n<p>Also, if I change the <code>nested</code> type to a non-template type, i.e.</p>\n<pre><code>struct Base {\n    struct nested;\n};\n...\ntypedef Derived3::nested xxx;\n</code></pre>\n<p>then it works with the above compilers.</p>\n<p><strong>[edit]</strong>\nChanging the <code>nested</code> template struct to a template alias also does not change anything;</p>\n<pre><code>template &lt;typename&gt; struct dependent { struct type; };\nstruct Base {\n    template &lt;typename T&gt;\n    using nested = typename dependent&lt;T&gt;::type;\n};\n</code></pre>\n<p>produces the same results with the above compilers.\n<strong>[end edit]</strong></p>\n<p><strong>From N3242 \u00a710.1 [class.mi]</strong></p>\n<blockquote>\n<p id=\"so_19986123_19986123_0\">A class can be an indirect base class more than once and can be a direct and an indirect base class. There are limited things that can be done with such a class. The non-static data members and member functions of the direct base class cannot be referred to in the scope of the derived class. However, the static members, enumerations and types can be unambiguously referred to.</p>\n</blockquote>\n<p>I <em>think</em> it means that the code should be valid, but I'm not sure.</p>\n", "Title": "Nested class hidden by multiple inheritance", "CreationDate": "2013-11-14T19:01:36.740", "LastActivityDate": "2013-11-14T19:43:50.180", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-11-14T19:43:50.180", "LastEditorUserId": "627587", "Id": "19986123", "Score": "6", "OwnerUserId": "627587", "Tags": "<c++><gcc><clang><multiple-inheritance><nested-class>", "AnswerCount": "1"}});