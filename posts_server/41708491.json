post_cb({"bq_ids": {"n4140": {"so_41708491_41708972_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4088}, "so_41708491_41708982_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4088}}, "n4659": {"so_41708491_41708972_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4996}, "so_41708491_41708982_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4996}}}, "41708972": {"Id": "41708972", "PostTypeId": "2", "Body": "<p>From N4527 (I presume it's still in the standard):</p>\n<p>\u00a7 20.4.2.6 (8):</p>\n<blockquote>\n<p id=\"so_41708491_41708972_0\">Requires: The type T occurs exactly once in Types.... Otherwise, the program is ill-formed.</p>\n</blockquote>\n<p>The program above is ill-formed, according to the standard. </p>\n<p>End of discussion.</p>\n", "Score": "3", "LastActivityDate": "2017-01-17T23:37:55.930", "CreationDate": "2017-01-17T23:37:55.930", "ParentId": "41708491", "CommentCount": "0", "OwnerUserId": "2015579"}, "41708491": {"ViewCount": "481", "LastEditDate": "2017-05-23T11:45:53.870", "AcceptedAnswerId": "41708982", "Title": "Making `std::get` play nice with SFINAE", "CreationDate": "2017-01-17T22:53:54.807", "LastActivityDate": "2017-01-18T20:30:00.950", "CommentCount": "8", "Body": "<p><code>std::get</code> does not seem to be SFINAE-friendly, as shown by the following test case:</p>\n<pre><code>template &lt;class T, class C&gt;\nauto foo(C &amp;c) -&gt; decltype(std::get&lt;T&gt;(c)) {\n    return std::get&lt;T&gt;(c);\n}\n\ntemplate &lt;class&gt;\nvoid foo(...) { }\n\nint main() {\n    std::tuple&lt;int&gt; tuple{42};\n\n    foo&lt;int&gt;(tuple);    // Works fine\n    foo&lt;double&gt;(tuple); // Crashes and burns\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/852745e1cb012c37\" rel=\"nofollow noreferrer\">See it live on Coliru</a></p>\n<p>The goal is to divert the second call to <code>foo</code> towards the second overload. In practice, libstdc++ gives:</p>\n<pre><code>/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.3.0/../../../../include/c++/6.3.0/tuple:1290:14: fatal error: no matching function for call to '__get_helper2'\n    { return std::__get_helper2&lt;_Tp&gt;(__t); }\n             ^~~~~~~~~~~~~~~~~~~~~~~\n</code></pre>\n<p>libc++ is more direct, with a straight <code>static_assert</code> detonation:</p>\n<pre><code>/usr/include/c++/v1/tuple:801:5: fatal error: static_assert failed \"type not found in type list\"\n    static_assert ( value != -1, \"type not found in type list\" );\n    ^               ~~~~~~~~~~~\n</code></pre>\n<p>I would really like not to implement onion layers checking whether <code>C</code> is an <code>std::tuple</code> specialization, and looking for <code>T</code> inside its parameters...</p>\n<p>Is there a reason for <code>std::get</code> not to be SFINAE-friendly? Is there a better workaround than what is outlined above?</p>\n<p>I've found <a href=\"https://stackoverflow.com/questions/31035563/does-the-standard-require-stdtuple-size-to-be-sfinae-friendly\">something about <code>std::tuple_element</code></a>, but not <code>std::get</code>.</p>\n", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "41708491", "AnswerCount": "3", "Score": "14", "OwnerUserId": "3233393", "Tags": "<c++><c++14><language-lawyer><sfinae><stdtuple>", "FavoriteCount": "2"}, "41710040": {"Id": "41710040", "PostTypeId": "2", "LastEditDate": "2017-01-18T05:33:40.407", "CommentCount": "0", "LastEditorUserId": "1774667", "LastActivityDate": "2017-01-18T05:33:40.407", "CreationDate": "2017-01-18T01:38:14.623", "ParentId": "41708491", "Score": "5", "Body": "<p>Don't SFINAE on <code>std::get</code>; that is not permitted.</p>\n<p>Here are two relatively sfinae friendly ways to test if you can <code>using std::get; get&lt;X&gt;(t)</code>:</p>\n<pre><code>template&lt;class T,std::size_t I&gt;\nusing can_get=std::integral_constant&lt;bool, I&lt;std::tuple_size&lt;T&gt;::value&gt;;\n\nnamespace helper{\n  template&lt;class T, class Tuple&gt;\n  struct can_get_type:std::false_type{};\n  template&lt;class T, class...Ts&gt;\n  struct can_get_type&lt;T,std::tuple&lt;Ts...&gt;&gt;:\n    std::integral_constant&lt;bool, (std::is_same_v&lt;T,Ts&gt;+...)==1&gt;\n  {};\n}\ntemplate&lt;class T,class Tuple&gt;\nusing can_get=typename helpers::can_get_type&lt;T,Tuple&gt;::type;\n</code></pre>\n<p>Then your code reads:</p>\n<pre><code>template &lt;class T, class C, std::enable_if_t&lt;can_get_type&lt;C,T&gt;{},int&gt; =0&gt;\ndecltype(auto) foo(C &amp;c) {\n  return std::get&lt;T&gt;(c);\n}\n</code></pre>\n", "OwnerUserId": "1774667"}, "41708982": {"Id": "41708982", "PostTypeId": "2", "Body": "<p><code>std::get&lt;T&gt;</code> is explicitly not SFINAE-friendly, as per [tuple.elem]:</p>\n<blockquote>\n<pre><code>template &lt;class T, class... Types&gt;\n  constexpr T&amp; get(tuple&lt;Types...&gt;&amp; t) noexcept;\n// and the other like overloads\n</code></pre>\n<p id=\"so_41708491_41708982_0\"><em>Requires:</em> The type <code>T</code> occurs exactly once in <code>Types...</code>. <strong>Otherwise, the program is ill-formed.</strong></p>\n</blockquote>\n<p><code>std::get&lt;I&gt;</code> is also explicitly not SFINAE-friendly. </p>\n<hr/>\n<p>As far as the other questions:</p>\n<blockquote>\n<p id=\"so_41708491_41708982_1\">Is there a reason for <code>std::get</code> not to be SFINAE-friendly? </p>\n</blockquote>\n<p>Don't know. Typically, this isn't a point that needs to be SFINAE-ed on. So I guess it wasn't considered something that needed to be done. Hard errors are a lot easier to understand than scrolling through a bunch of non-viable candidate options. If you believe there to be compelling reason for <code>std::get&lt;T&gt;</code> to be SFINAE-friendly, you could submit an LWG issue about it.</p>\n<blockquote>\n<p id=\"so_41708491_41708982_2\">Is there a better workaround than what is outlined above?</p>\n</blockquote>\n<p>Sure. You could write your own SFINAE-friendly verison of <code>get</code>:</p>\n<pre><code>template &lt;class T, class... Types,\n    std::enable_if_t&lt;(std::is_same&lt;T, Types&gt;::value + ...) == 1, int&gt; = 0&gt;\nconstexpr T&amp; my_get(tuple&lt;Types...&gt;&amp; t) noexcept {\n    return std::get&lt;T&gt;(t);\n}\n</code></pre>\n<p>And then do with that as you wish.    </p>\n", "Score": "15", "LastActivityDate": "2017-01-17T23:38:26.847", "CreationDate": "2017-01-17T23:38:26.847", "ParentId": "41708491", "CommentCount": "0", "OwnerUserId": "2069064"}});