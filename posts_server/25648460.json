post_cb({"25648460": {"CommentCount": "2", "ViewCount": "1623", "PostTypeId": "1", "LastEditorUserId": "996371", "CreationDate": "2014-09-03T15:39:44.287", "LastActivityDate": "2016-04-11T18:38:09.590", "Title": "Shouldn't char* implicitly converted to std::string?", "AcceptedAnswerId": "25648645", "LastEditDate": "2014-09-03T16:15:27.600", "Id": "25648460", "Score": "8", "Body": "<p>Here is my code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct ST {};\n\nbool operator==(const struct ST *s1, const string &amp;s2) {\n    return true;\n}\n\nint main() {\n    struct ST *st = new ST();\n    const char *p = \"abc\";\n\n    if (st == p) {\n        return 0;\n    }\n\n    return 1;\n}\n</code></pre>\n<p>I get compile error:</p>\n<pre><code>prog.cpp:14:12: error: comparison between distinct pointer types \u2018ST*\u2019 and \u2018const char*\u2019 lacks a cast [-fpermissive]\n  if (st == p) {\n            ^\n</code></pre>\n<p>I wonder why the implicit conversion from char* to string does not work here? </p>\n<p>UPDATE\nAnton's answer makes sense, I updated the code:</p>\n<pre><code>#include &lt;string&gt;\nusing namespace std;\n\nstruct ST {};\n\nbool operator==(const struct ST s1, const string &amp;s2) {\n    return true;\n}\n\nint main() {\n    struct ST st;\n    const char *p = \"abc\";\n\n    if (st == p) {\n        return 0;\n    }\n\n    return 1;\n}\n</code></pre>\n<p>Now it compiles. </p>\n", "Tags": "<c++>", "OwnerUserId": "996371", "AnswerCount": "2"}, "25648645": {"ParentId": "25648460", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><a href=\"http://www.lcdf.org/c%2B%2B/clause13.html#s13.3.1.2\" rel=\"nofollow\">\u00a713.3.1.2 Operators in expressions [over.match.oper]</a> states:</p>\n<blockquote>\n<p id=\"so_25648460_25648645_0\">If no operand of an operator in an expression has a type that is a class or an enumeration, the operator is assumed to be a built-in operator and interpreted according to Clause 5.</p>\n</blockquote>\n<p>This is exactly your case: <code>operator==</code>'s arguments are pointers, so it's considered to be built-in and compiler doesn't look for possible overloads.</p>\n", "OwnerUserId": "3959454", "LastEditorUserId": "3959454", "LastEditDate": "2016-04-11T18:38:09.590", "Id": "25648645", "Score": "17", "CreationDate": "2014-09-03T15:49:58.877", "LastActivityDate": "2016-04-11T18:38:09.590"}, "25648684": {"ParentId": "25648460", "CommentCount": "1", "Body": "<p>Absolutely not.</p>\n<p>First of all, you are trying to use a pointer in place of a reference.  Any similarity between a pointer and a reference is a implementation detail.  Remember the motto:  \"Implementation Is Irrelevant!\"</p>\n<p>Next, and more directly to your question, a std::string and a char* are quite different, even if they are used to represent the same things.  Conversion between them was deliberately made difficult to prevent using them interchangably.</p>\n", "OwnerUserId": "12725", "PostTypeId": "2", "Id": "25648684", "Score": "0", "CreationDate": "2014-09-03T15:52:29.343", "LastActivityDate": "2014-09-03T15:52:29.343"}, "bq_ids": {"n4140": {"so_25648460_25648645_0": {"section_id": 582, "quality": 1.0, "length": 13}}, "n3337": {"so_25648460_25648645_0": {"section_id": 572, "quality": 1.0, "length": 13}}, "n4659": {"so_25648460_25648645_0": {"section_id": 605, "quality": 1.0, "length": 13}}}});