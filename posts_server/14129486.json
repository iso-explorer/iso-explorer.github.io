post_cb({"14130197": {"ParentId": "14129486", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Although this question was perfectly answered by <a href=\"https://stackoverflow.com/users/151292/james-mcnellis\">James</a> already, I would like to point out one thing:</p>\n<p>In proper C++ code, you'll almost never end up working with <code>void</code> pointers, which means your code would probably look like this:</p>\n<pre><code>SubType *p = new SubType;\nBaseType* pB = (BaseType*)p;\ndelete pB;\n</code></pre>\n<p>in this case, even if the <code>BaseType</code> would have proper virtual constructor, there is still possible undefined behavior if the <code>SubType</code> is not derived from the <code>BaseType</code>. Common C-style cast isn't very lucky choice here.</p>\n<p>But in case you would use <code>dynamic_cast</code>, compiler would most likely not let you do that in case that <code>p</code> doesn't point to object of polymorphic type. And even in case that <code>p</code> points to object of polymorphic type, but <code>BaseType</code> wouldn't be base type of <code>SubType</code>, <code>dynamic_cast</code> would return <code>NULL</code> and you could handle this state appropriately:</p>\n<pre><code>SubType *p = new SubType;\nBaseType* safePtr = dynamic_cast&lt;BaseType *&gt;(p);\nif (!safePtr) // p doesn't point to object of type derived from BaseType\n    ...       // handle this situation\nelse          // p points to object of polymorphic type derived from BaseType\n    delete safePtr;\n</code></pre>\n", "OwnerUserId": "1168156", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:43:06.797", "Id": "14130197", "Score": "0", "CreationDate": "2013-01-02T22:24:03.320", "LastActivityDate": "2013-01-02T22:29:26.543"}, "14129525": {"ParentId": "14129486", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The behavior is undefined.  In this case, the dynamically allocated object may only be deleted via a pointer of type <code>Type1</code>.</p>\n<p>First, by using the pointer obtained by <code>(Type2 *)p</code> in the <code>delete</code> expression, you violate the aliasing rules.  There is a limited set of types via which the object pointed-to by <code>p</code> may be used.  The rules from C++03 may be found <a href=\"https://stackoverflow.com/questions/4807643/container-covariance-in-c/4807726#4807726\">in an answer to another question</a>.  The C++11 rules are similar (the differences are not relevant to the answer to your question).</p>\n<p>Even if the program did not violate the strict aliasing rules, it would violate the requirements of the <code>delete</code> expression.  The specification states (C++11 \u00a75.3.5[expr.delete]/3):</p>\n<blockquote>\n<p id=\"so_14129486_14129525_0\">if the static type of the object to be deleted is different from its dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the\n  static type shall have a virtual destructor or the behavior is undefined.</p>\n</blockquote>\n<p>In your <code>delete</code> expression, the static type of the object is <code>Type2</code>, whereas the dynamic type is <code>Type1</code>.  The types are different, but the static type is not a base class of the dynamic type.</p>\n", "OwnerUserId": "151292", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:18:46.553", "Id": "14129525", "Score": "14", "CreationDate": "2013-01-02T21:33:03.053", "LastActivityDate": "2013-01-02T21:39:35.030"}, "14129537": {"ParentId": "14129486", "CommentCount": "0", "Body": "<p>That would be a really bad idea, as you would be asking the compiler to arrange to run Type2::~Type2 on a Type1 pointer, and that destructor might reference off the end of the object.</p>\n<p>In conventional environments, the eventual free of the memory would be alright, because <code>operator delete</code> calls <code>free</code> which does not care what type you called it at compile time. However, in a not so conventional environment, it could be a disaster.</p>\n", "OwnerUserId": "131433", "PostTypeId": "2", "Id": "14129537", "Score": "4", "CreationDate": "2013-01-02T21:34:19.803", "LastActivityDate": "2013-01-02T21:34:19.803"}, "14129486": {"CommentCount": "4", "ViewCount": "224", "PostTypeId": "1", "LastEditorUserId": "1168156", "CreationDate": "2013-01-02T21:29:23.100", "LastActivityDate": "2013-01-02T22:29:26.543", "LastEditDate": "2013-01-02T21:37:09.070", "AcceptedAnswerId": "14129525", "OwnerDisplayName": "user707549", "Title": "Is this safe to deallocate memory from a pointer of a different type than when it was allocated?", "Id": "14129486", "Score": "7", "Body": "<p>I have a question about deallocating memory in C++:</p>\n<pre><code>typedef struct type1\n{\n   int a;\n   int b;\n   float c;\n} Type1;\n\ntypedef struct type2\n{\n   int a;\n   int b;\n} Type2;\n\nvoid *p = new Type1;\n\ndelete (Type2 *)p;\n</code></pre>\n<p>In this case, will be the memory area pointed by <code>p</code> be deleted completely even after <code>p</code> was cast to type of different size?</p>\n", "Tags": "<c++><memory><dynamic>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_14129486_14129525_0": {"section_id": 6107, "quality": 1.0, "length": 23}}, "n3337": {"so_14129486_14129525_0": {"section_id": 5873, "quality": 1.0, "length": 23}}, "n4659": {"so_14129486_14129525_0": {"section_id": 7604, "quality": 1.0, "length": 23}}}});