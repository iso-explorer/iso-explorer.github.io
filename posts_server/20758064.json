post_cb({"20761976": {"ParentId": "20758064", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>As @DyP says, this section has changed a bit in the final standard. C++11 6.5.4 The range-based <code>for</code> statement [stmt.ranged]:</p>\n<blockquote>\n<p id=\"so_20758064_20761976_0\">1 For a range-based <code>for</code> statement of the form</p>\n<pre><code>  for ( for-range-declaration : expression ) statement\n</code></pre>\n<p id=\"so_20758064_20761976_1\">let <em>range-init</em> be equivalent to the <em>expression</em> surrounded by parentheses</p>\n<pre><code>  ( expression )\n</code></pre>\n<p id=\"so_20758064_20761976_2\">and for a range-based <code>for</code> statement of the form</p>\n<pre><code>  for ( for-range-declaration : braced-init-list ) statement\n</code></pre>\n<p id=\"so_20758064_20761976_3\">let <em>range-init</em> be equivalent to the <em>braced-init-list</em>. In each case, a range-based <code>for</code> statement is equivalent to</p>\n<pre><code>  {\n    auto &amp;&amp; __range = range-init;\n    for ( auto __begin = begin-expr,\n               __end = end-expr;\n          __begin != __end;\n          ++__begin ) {\n      for-range-declaration = *__begin;\n      statement\n    }\n  }\n</code></pre>\n<p id=\"so_20758064_20761976_4\">where <code>__range</code>, <code>__begin</code>, and <code>__end</code> are variables defined for exposition only, and <code>_RangeT</code> is the type of the expression, and <em>begin-expr</em> and <em>end-expr</em> are determined as follows:</p>\n<ul>\n<li><p id=\"so_20758064_20761976_5\">if <code>_RangeT</code> is an array type, <em>begin-expr</em> and <em>end-expr</em> are <code>__range</code> and <code>__range + __bound</code>, respectively, where <code>__bound</code> is the array bound. If <code>_RangeT</code> is an array of unknown size or an array of incomplete type, the program is ill-formed;</p></li>\n<li><p id=\"so_20758064_20761976_6\">if <code>_RangeT</code> is a class type, the <em>unqualified-ids</em> <code>begin</code> and <code>end</code> are looked up in the scope of class <code>_RangeT</code> as if by class member access lookup (3.4.5), and if either (or both) finds at least one declaration, <em>begin-expr</em>\n  and <em>end-expr</em> are <code>__range.begin()</code> and <code>__range.end()</code>, respectively;</p></li>\n<li><p id=\"so_20758064_20761976_7\">otherwise, <em>begin-expr</em> and <em>end-expr</em> are <code>begin(__range)</code> and <code>end(__range)</code>, respectively, where <code>begin</code> and <code>end</code> are looked up with argument-dependent lookup (3.4.2). For the purposes of this name lookup,\n  namespace <code>std</code> is an associated namespace. </p></li>\n</ul>\n<p id=\"so_20758064_20761976_8\">[ Example:</p>\n<pre><code>  int array[5] = { 1, 2, 3, 4, 5 };\n  for (int&amp; x : array)\n    x *= 2;\n</code></pre>\n<p id=\"so_20758064_20761976_9\">\u2014end example ]</p>\n<p id=\"so_20758064_20761976_10\">2 In the <em>decl-specifier-seq</em> of a <em>for-range-declaration</em>, each <em>decl-specifier</em> shall be either a <em>type-specifier</em> or <code>constexpr</code>.</p>\n</blockquote>\n", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2013-12-24T13:45:59.457", "Id": "20761976", "Score": "3", "CreationDate": "2013-12-24T13:40:06.693", "LastActivityDate": "2013-12-24T13:45:59.457"}, "bq_ids": {"n4140": {"so_20758064_20761976_5": {"section_id": 3906, "quality": 0.9047619047619048, "length": 19}, "so_20758064_20761976_1": {"section_id": 3906, "quality": 0.8333333333333334, "length": 5}, "so_20758064_20761976_4": {"section_id": 3906, "quality": 0.7857142857142857, "length": 11}, "so_20758064_20761976_3": {"section_id": 3906, "quality": 0.8888888888888888, "length": 8}, "so_20758064_20761976_10": {"section_id": 3907, "quality": 1.0, "length": 7}, "so_20758064_20761976_6": {"section_id": 3906, "quality": 0.9230769230769231, "length": 24}}, "n3337": {"so_20758064_20761976_5": {"section_id": 3766, "quality": 0.9047619047619048, "length": 19}, "so_20758064_20761976_1": {"section_id": 3766, "quality": 0.8333333333333334, "length": 5}, "so_20758064_20761976_3": {"section_id": 3766, "quality": 0.8888888888888888, "length": 8}, "so_20758064_20761976_4": {"section_id": 3766, "quality": 0.7857142857142857, "length": 11}, "so_20758064_20761976_6": {"section_id": 3766, "quality": 0.9230769230769231, "length": 24}, "so_20758064_20761976_10": {"section_id": 3767, "quality": 1.0, "length": 7}, "so_20758064_20761976_7": {"section_id": 3766, "quality": 0.8571428571428571, "length": 18}}, "n4659": {"so_20758064_20761976_5": {"section_id": 4792, "quality": 0.7619047619047619, "length": 16}, "so_20758064_20761976_1": {"section_id": 4792, "quality": 0.6666666666666666, "length": 4}, "so_20758064_20761976_6": {"section_id": 4792, "quality": 0.7692307692307693, "length": 20}, "so_20758064_20761976_10": {"section_id": 4793, "quality": 1.0, "length": 7}, "so_20758064_20761976_4": {"section_id": 4792, "quality": 0.6428571428571429, "length": 9}}}, "20758064": {"CommentCount": "1", "ViewCount": "725", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-12-24T09:15:09.570", "LastActivityDate": "2013-12-24T13:45:59.457", "LastEditDate": "2017-05-23T11:59:43.910", "AcceptedAnswerId": "20761976", "OwnerDisplayName": "user1508519", "Title": "Range-based for loop equivalent", "Id": "20758064", "Score": "4", "Body": "<p>So according to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2243.html#the-range-based-for-statement\" rel=\"nofollow noreferrer\">n2243</a> the range-based for loop is equivalent to this:</p>\n<pre><code>{\n     auto &amp;&amp; __range = ( expression );\n\n     for ( auto __begin = std::Range&lt;_RangeT&gt;::begin(__range),\n                  __end = std::Range&lt;_RangeT&gt;::end(__range);\n          __begin != __end;\n          ++__begin )\n     {\n         for-range-declaration = *__begin;\n         statement\n     }    \n}\n</code></pre>\n<p>It then says <code>2 If the header &lt;iterator_concept&gt; is not included prior to a use of the range-based for statement, the program is ill-formed.</code> so I question how up to date this is. I'm also curious what <code>std::Range</code> is or if it's purely an implementation detail. The closest I can find is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3350.html\" rel=\"nofollow noreferrer\">n3350</a>.</p>\n<p>This <a href=\"https://stackoverflow.com/a/10821839/1508519\">answer</a> relies on this information and says:</p>\n<blockquote>\n<p id=\"so_20758064_20758064_0\">Range for is as fast as possible since it caches the end\n  iterator[citation], uses pre-increment and only dereferences the\n  iterator once.</p>\n<p id=\"so_20758064_20758064_1\">so if you tend to write:</p>\n<p id=\"so_20758064_20758064_2\"><code>for(iterator i = cont.begin(); i != cont.end(); i++) { /**/ }</code></p>\n<p id=\"so_20758064_20758064_3\">Then, yes, range-for may be slightly faster, since it's also easier to\n  write there's no reason not to use it (when appropriate).</p>\n<p id=\"so_20758064_20758064_4\">P.S. I said it's as fast as possible, it isn't however faster than\n  possible. You can achieve the exact same performance if you write your\n  manual loops carefully.</p>\n</blockquote>\n<p>I'm curious if it actually makes a difference now. As far as I can see it's just syntactic sugar. For example, in a loop where you could do <code>auto it = s.rbegin(); it != s.rend(); ++it</code>, it would require boiler plate code that returns reverse iterators where the ranged-based for loop expects <code>begin</code> and <code>end</code>. And if all it saves is typing, then what other advantages does it offer, since it <b>only</b> expects <code>begin</code> and <code>end</code>? I'm curious if the answer I quoted above still holds weight since the paper is from 2007.</p>\n", "Tags": "<c++><c++11><for-loop>", "AnswerCount": "1"}});