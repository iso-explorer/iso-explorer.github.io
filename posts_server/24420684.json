post_cb({"24420684": {"CreationDate": "2014-06-26T00:26:50.123", "ViewCount": "2214", "FavoriteCount": "3", "Id": "24420684", "AcceptedAnswerId": "24420797", "Score": "14", "Title": "Store weak pointer to self", "CommentCount": "6", "Body": "<p>I work with a codebase that was partially implemented by someone who was in love with overly complex solutions to simple problems (e.g. template classes with two parameters that were only ever instantiated for one pair of types).  One thing she did was to create objects in a smart pointer, and then have the object store a weak pointer to itself.</p>\n<pre><code>class MyClass {\n    //...\n    boost::weak_ptr&lt;MyClass&gt; m_self;\n    //...\n};\n\nboost::shared_ptr&lt;MyClass&gt;\nFactory::Factory::Factory::CreateMyClass() {\n    boost::shared_ptr&lt;MyClass&gt; obj(new MyClass(...));\n    boost::weak_ptr&lt;MyClass&gt; p(obj);\n    obj-&gt;storeSelfPointer(p);\n    return obj;\n}\n</code></pre>\n<p>The class then proceeds to use m_self by locking it and passing around the resulting shared pointer.</p>\n<p>For the life of me, I cannot fathom what she was trying to accomplish.  Is there some pattern or idea that would explain this implementation?  It looks to me like this is completely pointless and I'd like to refactor it away.</p>\n<p><strong>EDIT</strong>: I should mention that none of the places that use the resulting smart pointer obtained from locking m_self actually retain the smart pointer.</p>\n", "Tags": "<c++><smart-pointers><weak-ptr>", "LastActivityDate": "2014-11-29T04:17:04.200", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "931824"}, "bq_ids": {"n4140": {"so_24420684_24420797_1": {"length": 16, "quality": 0.8421052631578947, "section_id": 4507}}, "n3337": {"so_24420684_24420797_1": {"length": 16, "quality": 0.8421052631578947, "section_id": 4338}}}, "24420797": {"LastActivityDate": "2014-11-29T04:17:04.200", "CommentCount": "6", "Body": "<p>A possible use of this \"design\" could be to use <code>m_self.lock()</code> to generate shared pointers from this.</p>\n<p>If you remove this weak pointer member, the reference count hold by the generated shared pointer from <code>this</code> would be incorrect.</p>\n<p>It achieves the same than <a href=\"http://en.cppreference.com/w/cpp/memory/enable_shared_from_this\" rel=\"nofollow\"><code>std::enable_shared_from_this</code></a>, interestingly enough, <a href=\"http://en.cppreference.com/w/cpp/memory/enable_shared_from_this\" rel=\"nofollow\">cppreference.com mentions this design</a> :</p>\n<blockquote>\n<p id=\"so_24420684_24420797_0\">A common implementation for enable_shared_from_this is to hold a weak\n  reference (such as std::weak_ptr) to this. The constructors of\n  std::shared_ptr detect the presence of an enable_shared_from_this base\n  and assign the newly created std::shared_ptr to the internally stored\n  weak reference</p>\n</blockquote>\n<p>And the C++ standard, section \u00a7 20.8.2.4 10 , mention the same possible implementation :</p>\n<blockquote>\n<p id=\"so_24420684_24420797_1\">The shared_ptr constructors that create unique pointers can detect the\n  presence of an enable_shared_- from_this base and assign the newly\n  created shared_ptr to its\n  __weak_this member</p>\n</blockquote>\n<hr>\n<p><strong>Possible Refactoring :</strong></p>\n<ul>\n<li><p>If you are using C++11, you can remove the <code>std::weak_ptr</code> member, and publicly inherits from <code>std::enable_shared_from_this&lt;T&gt;</code>. You should retrieve a shared pointer from this by calling <code>shared_from_this()</code>.</p></li>\n<li><p>If you are not using C++11 but can use boost, use <code>boost::enable_shared_from_this</code>, see the <a href=\"http://www.boost.org/doc/libs/1_55_0/libs/smart_ptr/enable_shared_from_this.html\" rel=\"nofollow\">boost documentation</a>. You should retrieve a shared pointer from this by calling <code>shared_from_this()</code>.</p></li>\n<li><p>If you are not using C++11, and can't use boost, you can bring the proposed implementation of the standard to your code base, it is short enough :</p></li>\n</ul>\n<p><strong>Code :</strong> (copied from \u00a7 20.8.2.4 - 11, remove leading underscores, and you probably want to rename it)</p>\n<pre><code>template&lt;class T&gt; class enable_shared_from_this {\n    private:\n     weak_ptr&lt;T&gt; __weak_this;\n    protected:\n     constexpr enable_shared_from_this() : __weak_this() { }\n     enable_shared_from_this(enable_shared_from_this const &amp;) { }\n     enable_shared_from_this&amp; operator=(enable_shared_from_this const &amp;) { return *this; }\n     ~enable_shared_from_this() { }\n    public:\n     shared_ptr&lt;T&gt; shared_from_this() { return shared_ptr&lt;T&gt;(__weak_this); }\n     shared_ptr&lt;T const&gt; shared_from_this() const { return shared_ptr&lt;T const&gt;(__weak_this); }\n};\n</code></pre>\n<p>And use <code>shared_from_this()</code> to make a shared pointer. If you do copy this code, note that constructing shared pointers from this by other means would <em>not work</em>. The shared pointers constructors need to be modified (as explain by the standard quote above).</p>\n</hr>", "CreationDate": "2014-06-26T00:40:49.433", "LastEditDate": "2014-11-29T04:17:04.200", "ParentId": "24420684", "Id": "24420797", "LastEditorUserId": "3510483", "PostTypeId": "2", "Score": "17", "OwnerUserId": "3510483"}});