post_cb({"bq_ids": {"n4140": {"so_6577906_6578021_0": {"length": 42, "quality": 0.8235294117647058, "section_id": 5873}, "so_6577906_6578021_1": {"length": 50, "quality": 0.9433962264150944, "section_id": 5873}}, "n3337": {"so_6577906_6578021_0": {"length": 42, "quality": 0.8235294117647058, "section_id": 5644}, "so_6577906_6578021_1": {"length": 49, "quality": 0.9245283018867925, "section_id": 5644}}, "n4659": {"so_6577906_6578021_0": {"length": 42, "quality": 0.8235294117647058, "section_id": 7356}, "so_6577906_6578021_1": {"length": 50, "quality": 0.9433962264150944, "section_id": 7356}}}, "6577906": {"ViewCount": "320", "Body": "<p>While answering one of the question, there was a discussion thread <a href=\"https://stackoverflow.com/questions/6568656/why-the-size-of-derived-class-increased-even-though-the-base-class-member-is-pri/6568693#6568693\">below my answer</a>. Which suggests that depending on the access specifier (or may be the type of inheritance) <code>private/protected/public</code> the <code>sizeof</code> the <code>class</code> object may vary!</p>\n<p>I still don't understand from their brief discussion, how is that possible ?</p>\n", "AcceptedAnswerId": "6578021", "Title": "Is size of the object affected by type of access-specifier and type of inheritance?", "CreationDate": "2011-07-05T04:14:13.940", "Id": "6577906", "CommentCount": "0", "LastEditDate": "2017-05-23T12:00:05.790", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2013-07-10T17:36:11.880", "Score": "9", "OwnerUserId": "514235", "Tags": "<c++><inheritance><access-specifier>", "AnswerCount": "1"}, "6578021": {"Id": "6578021", "PostTypeId": "2", "Body": "<p><strong>Note new language for C++11 below</strong></p>\n<p><strong>In C++03</strong>, there is language that makes this possible, 9.2 [class.mem]/12 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_6577906_6578021_0\">Nonstatic data members of a (non-union) class declared <strong>without an intervening access-specifier</strong> are allocated so that later members have higher addresses within a class object. <strong>The order of allocation of nonstatic data members separated by an access-specifier is unspecified</strong> (11.1). Implementation alignment requirements might cause two adjacent members not to be allocated immediately after each other; so might requirements for space for managing virtual functions (10.3) and virtual base classes (10.1).</p>\n</blockquote>\n<p>So given this definition:</p>\n<pre><code>class Foo\n{\n    char a; //8 bits\n    // a must come before b, so 3 bytes of padding have to go here to satisfy alignment\n    int b; //32 bits\n    char c; //8 bits\n    // 24 bits of padding required to make Foo a multiple of sizeof(int)\n};\n</code></pre>\n<p>on a system with 32 bit (<code>int</code>) alignment, the compiler is not allowed to reorder <code>c</code> to come before <code>b</code>, forcing the insertion of additional padding padding in between <code>a</code> and <code>b</code>, and after <code>c</code> to the end of the object (making <code>sizeof(Foo) == 12</code>). However, for this:</p>\n<pre><code>class Foo\n{\n    char a;\npublic:\n    int b;\npublic:\n    char c;\n};\n</code></pre>\n<p><code>a</code> and (<code>b</code> and <code>c</code>) are separated by an access specifier, so the compiler is free to perform such reordering, making </p>\n<pre><code>memory-layout Foo\n{\n    char a; // 8 bits\n    char c; // 8 bits\n    // 16 bits of padding\n    int b; // 32 bits\n};\n</code></pre>\n<p><code>sizeof(Foo) == 8</code>.</p>\n<p><strong>In C++11</strong>, the language changes slightly. N3485 9.2 [class.mem]/13 says (emphasis mine):</p>\n<blockquote>\n<p id=\"so_6577906_6578021_1\">Nonstatic data members of a (non-union) class <strong>with the same access control</strong> (Clause 11) are allocated so that later members have higher addresses within a class object. <strong>The order of allocation of non-static data members with different access control is unspecified</strong> (Clause 11). Implementation alignment requirements might cause two adjacent members not to be allocated immediately after each other; so might requirements for space for managing virtual functions (10.3) and virtual base classes (10.1).</p>\n</blockquote>\n<p>This means that in C++11, in the above example (separated by 3 publics), the compiler is still not allowed to perform the reordering. It would have to be something like</p>\n<pre><code>class Foo\n{\n    char a;\npublic:\n    int b;\nprotected:\n    char c;\n};\n</code></pre>\n<p>, which places <code>a</code>, <code>b</code>, and <code>c</code> with different access control.</p>\n<p>Note that under the C++11 rules, given a definition like:</p>\n<pre><code>class Foo\n{\n    char a;\npublic:\n    int b;\nprotected:\n    char c;\npublic:\n    int d;\n};\n</code></pre>\n<p>the compiler must put <code>d</code> after <code>b</code>, even though they are separated by access specifiers.</p>\n<hr>\n<p>(That said, I'm not aware of any implementation that actually takes advantage of the latitude offered by either standard)</p>\n</hr>", "LastEditorUserId": "82320", "LastActivityDate": "2013-07-10T17:36:11.880", "Score": "15", "CreationDate": "2011-07-05T04:42:25.113", "ParentId": "6577906", "CommentCount": "7", "LastEditDate": "2013-07-10T17:36:11.880", "OwnerUserId": "82320"}});