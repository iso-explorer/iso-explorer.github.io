post_cb({"bq_ids": {"n4140": {"so_6076946_6077022_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 49}}, "n3337": {"so_6076946_6077022_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 44}}, "n4659": {"so_6076946_6077022_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 50}}}, "6077022": {"Id": "6077022", "PostTypeId": "2", "Body": "<p>Partial function template specialization is illegal. From the C++03 standard, \u00a714/2:</p>\n<blockquote>\n<p id=\"so_6076946_6077022_0\">A <em>template-declaration</em> can appear only as a namespace scope or class scope declaration. In a function template declaration, the <em>declarator-id</em> shall be a <em>template-name</em> <strong>(i.e., not a <em>template-id</em>)</strong>. [<em>Note:</em> in a class template declaration, if the class name is a <em>template-id</em>, the declaration declares a class template partial specialization.]</p>\n</blockquote>\n<p>You'll want to simply overload your function instead:</p>\n<pre><code>class C\n{\npublic:\n    template&lt;typename Container&gt;\n    void Foo(Container&amp;)\n    {\n        // ...\n    }\n\n    template&lt;typename T, std::size_t N&gt;\n    void Foo(std::tr1::array&lt;T, N&gt;&amp;)\n    {\n        // special\n    }\n};\n</code></pre>\n<hr>\n<p><strong>EDIT</strong> (in response to the OP's edit):</p>\n<p>If you're only looking for a workaround for this specific scenario, since <code>std(::tr1)::array&lt;T,N&gt;::iterator</code> is simply <code>T*</code>, your 'special' overload can be:</p>\n<pre><code>template&lt;typename T&gt;\nvoid Foo(T*&amp;)\n{\n    // special\n}\n</code></pre>\n</hr>", "LastEditorUserId": "636019", "LastActivityDate": "2011-05-20T20:19:32.677", "Score": "1", "CreationDate": "2011-05-20T20:00:38.480", "ParentId": "6076946", "CommentCount": "4", "OwnerUserId": "636019", "LastEditDate": "2011-05-20T20:19:32.677"}, "6076946": {"ViewCount": "2587", "Body": "<p>I'm trying to specialize a template member function of a non-template class using a templatized parameter:</p>\n<pre><code>#include &lt;array&gt;\nclass C\n{\npublic:\n  template&lt;class Container&gt;\n  void Foo( Container&amp; )\n  {\n    // ...\n  }\n};\n\ntemplate&lt;class T, std::size_t N&gt;\ntemplate&lt;&gt;\nvoid C::Foo&lt; std::tr1::array&lt;T,N&gt; &gt;( std::tr1::array&lt;T,N&gt;&amp; )\n{\n  // special\n}\n</code></pre>\n<p>I get an error \"illegal use of explicit template arguments\" with this. What's the right syntax to make this valid?</p>\n<hr>\n<p><strong>Update</strong>:</p>\n<p>Perhaps I've muddled the issue by over-simplifying. What I really want to do is specially handle this one case where <em>there is a dependent name involved</em>, which I think may be what is throwing a monkey wrench into the works here. My original thought was to overload the function as such:</p>\n<pre><code>class C\n{\npublic:\n  template&lt;class Iter&gt;\n  void Foo( Iter )\n  {\n    std::cout &lt;&lt; \"Normal\\n\";\n  }\n\n  template&lt;class T, std::size_t N&gt;\n  void Foo( typename std::tr1::array&lt;T,N&gt;::iterator )\n  {\n    std::cout &lt;&lt; \"Special\\n\";\n  }\n};\n\nint main()\n{\n  C c;\n  std::tr1::array&lt;int,10&gt; a1;\n  c.Foo( a1.begin() ); // Doesn't print \"Special\"!\n}\n</code></pre>\n<p>But the special Foo doesn't get called. How can I do that?</p>\n</hr>", "AcceptedAnswerId": "6076999", "Title": "Specializing member function for non-template class in C++", "CreationDate": "2011-05-20T19:53:03.073", "Id": "6076946", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-05-20T20:28:24.697", "LastEditorUserId": "201787", "LastActivityDate": "2016-01-05T13:13:39.103", "Score": "2", "OwnerUserId": "201787", "Tags": "<c++><templates><dependent-name>", "AnswerCount": "2"}, "6076999": {"Id": "6076999", "PostTypeId": "2", "Body": "<p>Only the member function is templated, which means that you should only use one <code>template&lt;...&gt;</code> in there. But that will not solve it either, as you cannot partially specialize a function.</p>\n<p>The usual way of handling the problem is through overloads, rather than specialization (specialization of template functions is not that useful).</p>\n<pre><code>struct test {\n   template &lt;typename Container&gt;\n   void f( Container&amp; ) { ... }\n\n   template &lt;typename T, int N&gt;\n   void f( std::array&lt;T,N&gt;&amp; ) { ... }\n};\n</code></pre>\n<p>Note that the difference is that they are two separate template functions (rather than an specialization).</p>\n<p><strong>EDIT</strong>: After the update</p>\n<p>The update to the question changes the problem completely. The problem that you are seeing is that the argument of the second version is a dependent name, and as such it is non deducible. Given the function call the compiler is not able to determine what type T, and integral constant N are to match that particular instantiation. Consider a different example:</p>\n<pre><code>template &lt;typename T&gt;\nstruct inner_int {\n   typedef int type;\n};\ntemplate &lt;typename T&gt;\nvoid foo( typename inner_int&lt;T&gt;::type ) {\n}\nint main() {\n   foo( inner_int&lt;double&gt;::type() );\n}\n</code></pre>\n<p>When the compiler processes the call in <code>main</code>, it instantiates the template and extracts the type, from that it creates a temporary, and then it tries to decide what to do with <code>foo</code> but at that time it only knows that it is being called with an <code>int</code> rvalue... the original <code>inner&lt;double&gt;::type</code> is gone, now it is just <code>foo( int() )</code> and the compiler would have to try and instantiate <code>inner_int</code> with all possible types to determine whether any of them fits, and in the worse case, as above, many would match.</p>\n", "LastEditorUserId": "36565", "LastActivityDate": "2011-05-20T23:38:22.933", "Score": "2", "CreationDate": "2011-05-20T19:58:01.690", "ParentId": "6076946", "CommentCount": "2", "OwnerUserId": "36565", "LastEditDate": "2011-05-20T23:38:22.933"}});