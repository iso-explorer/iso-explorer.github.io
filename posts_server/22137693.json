post_cb({"22137878": {"ParentId": "22137693", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>As you quoted:</p>\n<blockquote>\n<p id=\"so_22137693_22137878_0\">The process of calling destructors <strong>for automatic objects</strong> constructed on the path from a try block to a throw-expression is called \u201cstack unwinding.\u201d</p>\n</blockquote>\n<p>This includes both objects and \"subobjects\" (which are just automatic objects enclosed in other objects). So, the destruction of subobjects is part of the <em>stack unwinding</em>, because subobjects are actually \"automatic objects constructed on the path from a try block to a throw-expression\" themselves.</p>\n<blockquote>\n<p id=\"so_22137693_22137878_1\">So my interpretation is that even if the exception is not handled, subobjects are still destroyed. </p>\n</blockquote>\n<p>Subobjects will be destroyed if the implementation decides so as per \u00a715.5.2/2 (that you also quoted).</p>\n<hr>\n<blockquote>\n<p id=\"so_22137693_22137878_2\">Is it also implementation-defined whether fully constructed subobjects of *p are destroyed?</p>\n</blockquote>\n<p>No, because they fall into the set of subobjects that the standard guarantees will be destroyed in \u00a715.2/2.</p>\n</hr>", "OwnerUserId": "493122", "LastEditorUserId": "493122", "LastEditDate": "2014-03-03T11:38:55.133", "Id": "22137878", "Score": "0", "CreationDate": "2014-03-03T02:53:30.733", "LastActivityDate": "2014-03-03T11:38:55.133"}, "22138378": {"ParentId": "22137693", "CommentCount": "0", "Body": "<p>I'm implemented exception handling and had to read through GCC's exception handling code. I'm not exactly sure what the standard guarantees, but I know what happens here. In GCC if an exception is not handled then no stack unwinding will be done. The ABI definition for stack unwinding on Unix-like systems just ends the program if no handler is called. It doesn't unwind any stack frames.</p>\n<p>The implementation defined aspect in the standard is to allow optimizations. It's possible that some destructors are called since they never existed in a <em>runtime</em> stack frame. The optimizer has reworked the code and removed some exception handling. So you could have some C++ objects that get destroyed. The amount will be really minimal though at the bottom of the stack only.</p>\n", "OwnerUserId": "229686", "PostTypeId": "2", "Id": "22138378", "Score": "1", "CreationDate": "2014-03-03T03:53:43.150", "LastActivityDate": "2014-03-03T03:53:43.150"}, "22137693": {"CommentCount": "6", "AcceptedAnswerId": "29576874", "PostTypeId": "1", "LastEditorUserId": "481267", "CreationDate": "2014-03-03T02:32:56.583", "LastActivityDate": "2015-04-11T10:40:59.317", "LastEditDate": "2014-03-03T03:14:25.243", "ViewCount": "168", "FavoriteCount": "5", "Title": "If initialization or destruction is terminated by an exception which is not handled, are fully-constructed subobjects necessarily destroyed?", "Id": "22137693", "Score": "12", "Body": "<p>The standard distinguishes between two forms of destruction that occur when an exception is thrown. Emphasis mine.</p>\n<p>\u00a715.2/1</p>\n<blockquote>\n<p id=\"so_22137693_22137693_0\"><strong>As control passes from a <em>throw-expression</em> to a handler, destructors are invoked for all automatic objects\n  constructed since the try block was entered.</strong> The automatic objects are destroyed in the reverse order of the\n  completion of their construction.</p>\n</blockquote>\n<p>\u00a715.2/2</p>\n<blockquote>\n<p id=\"so_22137693_22137693_1\"><strong>An object of any storage duration whose initialization or destruction is terminated by an exception will\n  have destructors executed for all of its fully constructed subobjects</strong> (excluding the variant members of a\n  union-like class), that is, for subobjects for which the principal constructor (12.6.2) has completed execution\n  and the destructor has not yet begun execution. Similarly, if the non-delegating constructor for an object\n  has completed execution and a delegating constructor for that object exits with an exception, the object\u2019s\n   destructor will be invoked. If the object was allocated in a <em>new-expression</em>, the matching deallocation\n  function (3.7.4.2, 5.3.4, 12.5), if any, is called to free the storage occupied by the object.</p>\n</blockquote>\n<p>\u00a715.2/3</p>\n<blockquote>\n<p id=\"so_22137693_22137693_2\">The process of calling destructors for automatic objects constructed on the path from a try block to a\n  <em>throw-expression</em> is called \u201c<em>stack unwinding.</em>\u201d If a destructor called during stack unwinding exits with an\n     exception, <code>std::terminate</code> is called (15.5.1). [ <em>Note:</em> So destructors should generally catch exceptions and\n    not let them propagate out of the destructor. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>So it seems that we have (a) stack unwinding, which destroys automatic objects, and (b) destruction of fully constructed subobjects of the object whose constructor or destructor exits <em>via</em> an exception, which occurs regardless of storage duration.</p>\n<p>A careful reading of \u00a715.2/1 suggests that stack unwinding only necessarily occurs if control passes to a handler, leaving open the possibility that stack unwinding might not occur if the exception is not handled. Indeed, \u00a715.5.2/2 says,</p>\n<blockquote>\n<p id=\"so_22137693_22137693_3\">In the situation where no matching handler is found, it is implementation-defined whether or not the stack is unwound before <code>std::terminate()</code> is called.\"</p>\n</blockquote>\n<p>But the wording of \u00a715.2/2 doesn't seem to leave open such a possibility. It simply says that the initialization or destruction has to be terminated by an exception---not that control has to pass to a handler. So my interpretation is that even if the exception is not handled, subobjects are still destroyed. Is this the correct interpretation?</p>\n<p>For example, let's say we have</p>\n<pre><code>std::vector&lt;int&gt; V;\nComplicatedObject* p = new ComplicatedObject();\n</code></pre>\n<p>and <code>ComplicatedObject</code>'s constructor throws, and the exception is not handled. Then whether or not <code>V</code> is destroyed is implementation-defined. Is it also implementation-defined whether fully constructed subobjects of <code>*p</code> are destroyed? Note that such objects do not have automatic storage duration.</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "481267", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_22137693_29576874_1": {"section_id": 3383, "quality": 1.0, "length": 5}, "so_22137693_22137693_1": {"section_id": 3344, "quality": 0.9354838709677419, "length": 58}, "so_22137693_22137693_0": {"section_id": 3343, "quality": 0.9166666666666666, "length": 22}, "so_22137693_22137693_2": {"section_id": 3345, "quality": 0.7777777777777778, "length": 28}, "so_22137693_29576874_5": {"section_id": 3383, "quality": 1.0, "length": 5}, "so_22137693_22137693_3": {"section_id": 3383, "quality": 0.9166666666666666, "length": 11}, "so_22137693_22137878_0": {"section_id": 3345, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_22137693_29576874_1": {"section_id": 3252, "quality": 1.0, "length": 5}, "so_22137693_22137693_1": {"section_id": 3214, "quality": 0.9354838709677419, "length": 58}, "so_22137693_22137693_0": {"section_id": 3213, "quality": 0.9583333333333334, "length": 23}, "so_22137693_22137693_2": {"section_id": 3215, "quality": 0.8055555555555556, "length": 29}, "so_22137693_29576874_5": {"section_id": 3252, "quality": 1.0, "length": 5}, "so_22137693_22137878_0": {"section_id": 3215, "quality": 0.9285714285714286, "length": 13}, "so_22137693_22137693_3": {"section_id": 3252, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_22137693_29576874_1": {"section_id": 4143, "quality": 1.0, "length": 5}, "so_22137693_22137693_0": {"section_id": 4109, "quality": 0.625, "length": 15}, "so_22137693_29576874_7": {"section_id": 4110, "quality": 0.7037037037037037, "length": 38}, "so_22137693_29576874_5": {"section_id": 4143, "quality": 1.0, "length": 5}, "so_22137693_22137693_3": {"section_id": 4143, "quality": 0.9166666666666666, "length": 11}}}, "29576874": {"ParentId": "22137693", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Your interpretation is (obviously) correct, and neither Clang nor GCC conform to the standard in this scenario.<br>\nThis was subject of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1774\" rel=\"noreferrer\"><strong>CWG issue #1774</strong></a>:</br></p>\n<blockquote>\n<p id=\"so_22137693_29576874_0\">The current wording of 15.5.1 [except.terminate] paragraph 2 affords\n  implementations a significant degree of freedom when exception\n  handling results in a call to <code>std::terminate</code>:</p>\n<blockquote>\n<p id=\"so_22137693_29576874_5\">In the situation where no matching handler is found [..]</p>\n</blockquote>\n<p id=\"so_22137693_29576874_2\">This contrasts with the treatment of subobjects and objects\n  constructed via delegating constructos in 15.2 [except.ctor] paragraph\n  2:</p>\n<blockquote>\n<p id=\"so_22137693_29576874_6\">An object of any storage duration [..]</p>\n</blockquote>\n<p id=\"so_22137693_29576874_4\">Here the destructors must be called. It would be helpful if these\n  requirements were harmonized.</p>\n</blockquote>\n<p>A resolution has been proposed that didn't make it into C++14. Your quote, \u00a715.3/11, will be deleted. Instead, \u00a715.2 will contain</p>\n<blockquote>\n<p id=\"so_22137693_29576874_7\"><strong>For an object of class type of any storage duration whose initialization or destruction is terminated by an\n  exception, the destructor is invoked for each of the object\u2019s fully constructed subobjects</strong>, that is, for each\n   subobject for which the principal constructor (12.6.2) has completed execution and the destructor has not\n  yet begun execution, except that in the case of destruction, the variant members of a union-like class are not\n  destroyed. The subobjects are destroyed in the reverse order of the completion of their construction. <strong>Such\n  destruction is sequenced before entering a handler of the function-try-block of the constructor or destructor,\n  if any.</strong></p>\n</blockquote>\n<p>This should eliminate any doubts. Also, note that the changes are already incorporated into the current working draft, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"noreferrer\">N4296</a>.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-04-11T10:40:59.317", "Id": "29576874", "Score": "5", "CreationDate": "2015-04-11T10:34:33.090", "LastActivityDate": "2015-04-11T10:40:59.317"}});