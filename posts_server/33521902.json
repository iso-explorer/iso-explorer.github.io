post_cb({"33521902": {"ViewCount": "129", "Body": "<p>I came up with the idea of using <code>decltype</code> to define static members in a .cpp file, and then using this macro:</p>\n<pre><code>#define DEFINE_SYMBOL(x) decltype(x) x\n</code></pre>\n<p>This way, for instance, if class <code>Foo</code> declares <code>static int bar</code>, I can do the following in foo.cpp:</p>\n<pre><code>DEFINE_SYMBOL(Foo::bar) = 1337;\n</code></pre>\n<p>This seems a bit \"hacky\", but it has the advantage of being resilient to changes in the original symbol type. For instance, if bar changes to unsigned in foo.hpp, I wouldn't need to change foo.cpp. It's also easier to read when the type of the member is complex.</p>\n<p>However, if the static member is private, in Visual Studio 2015, Intellisense complains about using decltype (saying it's inaccessible). The complaint makes sense, although the program compiles just fine. Now, my question is, is Intellisense wrong, or is this usage of decltype not recommended (and why)?</p>\n", "AcceptedAnswerId": "33523142", "Title": "Using decltype to define static members (Intellisense disagrees)", "CreationDate": "2015-11-04T12:25:51.090", "Id": "33521902", "CommentCount": "2", "LastEditDate": "2015-11-05T01:27:15.680", "PostTypeId": "1", "LastEditorUserId": "1708801", "LastActivityDate": "2015-11-05T01:27:15.680", "Score": "3", "OwnerUserId": "2236926", "Tags": "<c++><visual-studio-2015><intellisense><static-members><decltype>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33521902_33523142_0": {"length": 39, "quality": 0.9069767441860465, "section_id": 6669}, "so_33521902_33523142_1": {"length": 39, "quality": 0.9285714285714286, "section_id": 6670}}, "n3337": {"so_33521902_33523142_0": {"length": 39, "quality": 0.9069767441860465, "section_id": 6424}, "so_33521902_33523142_1": {"length": 39, "quality": 0.9285714285714286, "section_id": 6425}}, "n4659": {"so_33521902_33523142_0": {"length": 39, "quality": 0.9069767441860465, "section_id": 8144}, "so_33521902_33523142_1": {"length": 39, "quality": 0.9285714285714286, "section_id": 8145}}}, "33523142": {"Id": "33523142", "PostTypeId": "2", "Body": "<p>Intellisense is incorrect, both gcc and clang compile a similar program and we can see the draft C++ standard section <code>11</code> <em>[class.access]</em> says:</p>\n<blockquote>\n<p id=\"so_33521902_33523142_0\">All access controls in Clause 11 affect the ability to access a class member name from the declaration of a particular entity, including parts of the declaration preceding the name of the entity being declared and, if the\n  entity is a class, the definitions of members of the class appearing outside the class\u2019s member-specification.\n  [ Note: this access also applies to implicit references to constructors, conversion functions, and destructors.\n  \u2014end note ] [ Example:</p>\n<pre><code>class A {\ntypedef int I; // private member\nI f();\nfriend I g(I);\nstatic I x;\ntemplate&lt;int&gt; struct Q;\ntemplate&lt;int&gt; friend struct R;\nprotected:\nstruct B { };\n};\nA::I A::f() { return 0; }\nA::I g(A::I p = A::x);\nA::I g(A::I p) { return 0; }\nA::I A::x = 0;\ntemplate&lt;A::I&gt; struct A::Q { };\ntemplate&lt;A::I&gt; struct R { };\nstruct D: A::B, A { };\n</code></pre>\n<p id=\"so_33521902_33523142_1\">Here, all the uses of A::I are well-formed because A::f, A::x, and A::Q are members of class A and g and\n  R are friends of class A. This implies, for example, that access checking on the first use of A::I must be\n  deferred until it is determined that this use of A::I is as the return type of a member of class A. Similarly,\n  the use of A::B as a base-specifier is well-formed because D is derived from A, so checking of base-specifiers\n  must be deferred until the entire base-specifier-list has been seen. \u2014end example ]</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-11-04T19:24:43.623", "Score": "1", "CreationDate": "2015-11-04T13:27:04.603", "ParentId": "33521902", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2015-11-04T19:24:43.623"}});