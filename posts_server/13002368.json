post_cb({"13002620": {"ParentId": "13002368", "CommentCount": "2", "Body": "<p>Fixing your code, the following would work:</p>\n<pre><code>template&lt;class T&gt; class TestTemplate {\npublic:\n    //constructor 1\n    template&lt;class Y&gt; TestTemplate(Y * p) {\n        cout &lt;&lt; \"c1\" &lt;&lt; endl;\n    }\n\n    //constructor 2\n    template&lt;class Y, class D&gt; TestTemplate(Y * p, D d) {\n        cout &lt;&lt; \"c2\" &lt;&lt; endl;\n    }\n\n    template&lt;class A, class B&gt;\n    void foo(A a, B b) {\n        cout &lt;&lt; \"foo\" &lt;&lt; endl;\n    }\n};\n\nint main() {\n    TestTemplate&lt;int&gt; tp(new int());\n\n    tp.foo&lt;int*, string&gt;(new int(), \"hello\");\n\n    TestTemplate&lt;int&gt; tp2(new int(),2);\n}\n</code></pre>\n<p>You cannot use <code>T</code> for the class template parameter <strong>and</strong> the constructor template parameter. But, to answer your question, from [14.5.2p5]:</p>\n<blockquote>\n<p id=\"so_13002368_13002620_0\">Because the explicit template argument list follows the function\n  template name, and because conversion member function templates and\n  constructor member function templates are called without using a\n  function name, there is no way to provide an explicit template\n  argument list for these function templates.</p>\n</blockquote>\n<p>Therefore, you cannot explicitly specify template arguments for constructor.</p>\n", "OwnerUserId": "906773", "PostTypeId": "2", "Id": "13002620", "Score": "19", "CreationDate": "2012-10-21T22:01:09.603", "LastActivityDate": "2012-10-21T22:01:09.603"}, "13002706": {"ParentId": "13002368", "CommentCount": "1", "Body": "<p>You can't explicitly specify the template arguments for a constructor, because the constructor has no name on its own, and so there's no syntax for it.</p>\n<p>But, you can ensure that correct template arguments are <em>inferred</em>, by</p>\n<ul>\n<li><p>casting actual arguments, and/or</p></li>\n<li><p>introducing \"artificial\" extra arguments just to carry type information, if necessary, and/or</p></li>\n<li><p>use a factory function.</p></li>\n</ul>\n<p>For example, you can define</p>\n<pre><code>template&lt; class Type &gt; struct TypeCarrier{ typedef Type T; };\n\nstruct MyClass\n{\n    template&lt; class Type &gt;\n    MyClass( TypeCarrier&lt; Type &gt; ) { ... }\n};\n\n...\nMyClass o( TypeCarrier&lt;int&gt;() );\n</code></pre>\n<p>But don't get carried away with such techniques.</p>\n<p>Instead, if the apparent need to explicitly specify constructor template arguments pops up, think about whether the design is really sound?</p>\n<p>Perhaps you can use some simpler design if you reflect on what it\u2019s <em>for</em>?</p>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "13002706", "Score": "5", "CreationDate": "2012-10-21T22:11:25.843", "LastActivityDate": "2012-10-21T22:11:25.843"}, "13002587": {"ParentId": "13002368", "CommentCount": "12", "Body": "<p>You can explicitly specify the template arguments for your calls to <code>foo</code> because those member functions <code>foo</code> have names -- and the template arguments are part of that name.</p>\n<p>That doesn't work with constructors because a constructor has no name. You can't (directly) call a constructor. A constructor is of course called when you create an object, but the call is generated code.</p>\n", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "13002587", "Score": "3", "CreationDate": "2012-10-21T21:56:14.153", "LastActivityDate": "2012-10-21T21:56:14.153"}, "bq_ids": {"n4140": {"so_13002368_13002620_0": {"section_id": 114, "quality": 1.0, "length": 31}}, "n3337": {"so_13002368_13002620_0": {"section_id": 109, "quality": 1.0, "length": 31}}, "n4659": {"so_13002368_13002620_0": {"section_id": 118, "quality": 1.0, "length": 31}}}, "13002368": {"CommentCount": "5", "CreationDate": "2012-10-21T21:26:45.547", "PostTypeId": "1", "AcceptedAnswerId": "13002620", "LastEditorUserId": "833538", "LastActivityDate": "2012-10-21T22:17:46.273", "LastEditDate": "2012-10-21T22:17:46.273", "ViewCount": "36841", "FavoriteCount": "2", "Title": "Template constructor in a class template - how to explicitly specify template argument for the 2nd parameter?", "Id": "13002368", "Score": "10", "Body": "<p>Template constructor in a class template -  how to explicitly specify template argument for the 2nd parameter?</p>\n<p>compile error when tried to explicit specify template argument for constructor 2.\nHow should I do it if I really want to explicit call constructor 2 ?</p>\n<p>Please note this is the same situation for boost::shared_ptr when you want to explicitly specify the deleter type. </p>\n<p>N.B. For <strong>non</strong>-construction function foo(), explicitly specify works fine.</p>\n<p>N.B I know it works fine <strong>without</strong> specify the 2nd one explicitly for the constructor 2 as template argument deduction normally just works fine, I am just curious how to specify it explicitly.</p>\n<pre><code>template&lt;class T&gt; class TestTemplate {\npublic:\n    //constructor 1\n    template&lt;class Y&gt; TestTemplate(T * p) {\n        cout &lt;&lt; \"c1\" &lt;&lt; endl;\n    }\n\n    //constructor 2\n    template&lt;class Y, class D&gt; TestTemplate(Y * p, D d) {\n        cout &lt;&lt; \"c2\" &lt;&lt; endl;\n    }\n\n    template&lt;class T, class B&gt;\n    void foo(T a, B b) {\n        cout &lt;&lt; \"foo\" &lt;&lt; endl;\n    }\n};\n\nint main() {\n    TestTemplate&lt;int&gt; tp(new int());//this one works ok call constructor 1\n    //explicit template argument works ok\n    tp.foo&lt;int*, string&gt;(new int(), \"hello\");\n\n    TestTemplate&lt;int&gt; tp2(new int(),2);//this one works ok call constructor 2\n\n    //compile error when tried to explicit specify template argument for constructor 2\n    //How should I do it if I really want to explicit call constructor 2?\n    //TestTemplate&lt;int*, int&gt; tp3(new int(), 2); //wrong\n    //TestTemplate&lt;int*&gt; tp3&lt;int*,int&gt;(new int(), 2); //wrong again\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><templates>", "OwnerUserId": "833538", "AnswerCount": "3"}});