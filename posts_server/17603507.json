post_cb({"17603557": {"Id": "17603557", "PostTypeId": "2", "Body": "<p>I ran the program and saw this:</p>\n<pre><code>11\n22\n10\n20\n30\n40\n50\n\nBinary Search -  0\n</code></pre>\n<p>Your array is not sorted, therefore, binary search fails. (it sees <code>11</code> in the first position, and concludes <code>10</code> does not exist here)</p>\n<p>You either want to ensure the array is sorted before binary searching or use the regular <code>std::find</code>.</p>\n", "LastActivityDate": "2013-07-11T21:08:43.837", "CommentCount": "1", "CreationDate": "2013-07-11T21:08:43.837", "ParentId": "17603507", "Score": "12", "OwnerUserId": "1012936"}, "bq_ids": {"n4140": {"so_17603507_17603578_0": {"length": 21, "quality": 0.875, "section_id": 1431}}, "n3337": {"so_17603507_17603578_0": {"length": 21, "quality": 0.875, "section_id": 1425}}, "n4659": {"so_17603507_17603578_0": {"length": 21, "quality": 0.875, "section_id": 1551}}}, "17603578": {"Id": "17603578", "PostTypeId": "2", "Body": "<p>Your array is not sorted, so <code>binary_search</code> got undefined behavior. Try <code>std::find</code> instead</p>\n<pre><code>bool found = std::find(v.begin(), v.end(), 10) != v.end()\n</code></pre>\n<p>\u00a725.4.3.4 of the C++11 standard (3242 draft)</p>\n<blockquote id=\"so_17603507_17603578_0\">\n<ol>\n<li>Requires: The elements e of [first,last) are partitioned with respect to the expressions e &lt; value and !(value &lt; e) or comp(e,\n  value) and !comp(value, e). Also, for all elements e of [first, last),\n  e &lt; value implies !(value &lt; e) or comp(e, value) implies !comp(value,\n  e).</li>\n</ol>\n</blockquote>\n", "LastEditorUserId": "768110", "LastActivityDate": "2013-07-11T21:15:38.117", "Score": "4", "CreationDate": "2013-07-11T21:10:26.180", "ParentId": "17603507", "CommentCount": "0", "OwnerUserId": "768110", "LastEditDate": "2013-07-11T21:15:38.117"}, "17603507": {"ViewCount": "174", "Body": "<p>The following snippet is returning me 0. I expected it to be 1. What's wrong going on here? </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n#include &lt;ostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint main(){\n  vector&lt;int&gt; v;\n  int arr[] = {10,20,30,40,50};\n  v.push_back(11);\n  v.push_back(22);\n  copy(arr,arr + sizeof(arr)/sizeof(arr[0]),back_inserter(v));  // back_inserter makes space starting from the end of vector v\n  for(auto i = v.begin(); i != v.end(); ++i){\n    cout &lt;&lt; *i &lt;&lt; endl;\n  }\n  cout &lt;&lt; endl &lt;&lt; \"Binary Search -  \"  &lt;&lt; binary_search(v.begin(), v.end(), 10) &lt;&lt;endl; // returns bool \n}\n</code></pre>\n<p>I am using gcc /usr/lib/gcc/i686-linux-gnu/4.6/lto-wrapper</p>\n", "AcceptedAnswerId": "17603557", "Title": "binary_search in c++ unexpected behaviour", "CreationDate": "2013-07-11T21:05:31.323", "Id": "17603507", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-07-11T21:30:50.357", "LastEditorUserId": "1012936", "LastActivityDate": "2013-07-11T21:30:50.357", "Score": "2", "OwnerUserId": "690639", "Tags": "<c++><stl>", "AnswerCount": "4"}, "17603572": {"Id": "17603572", "PostTypeId": "2", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/algorithm/binary_search\" rel=\"nofollow\"><code>binary_search</code></a> says: </p>\n<blockquote>\n<p id=\"so_17603507_17603572_0\">Checks if the sorted range <code>[first, last)</code> contains an element equal to\n  <code>value</code>. The first version uses <code>operator&lt;</code> to compare the elements, the\n  second version uses the given comparison function <code>comp</code>.</p>\n</blockquote>\n<p>Your list is not sorted, it contains the elements <code>11</code> and <code>22</code> prior to <code>10</code>.</p>\n", "LastActivityDate": "2013-07-11T21:09:58.437", "CommentCount": "0", "CreationDate": "2013-07-11T21:09:58.437", "ParentId": "17603507", "Score": "4", "OwnerUserId": "489590"}, "17603761": {"Id": "17603761", "PostTypeId": "2", "Body": "<p>\"Unexpected behavior\"? There's nothing unexpected here.</p>\n<p>The whole idea of binary search algorithm is taking advantage of the fact that the input array is <em>sorted</em>. If the array is not sorted, there can't be any binary search on it.</p>\n<p>When you use <code>std::binary_search</code> (as well as all other standard binary search-based algorithms), the input sequence must be sorted in accordance with the same comparison predicate as the one used by <code>std::binary_search</code>. Since you did not pass any custom predicate to <code>std::binary_search</code>, it will use the ordering defined by <code>&lt;</code> operator. That means that your input Sequence of integers must be sorted in ascending order.</p>\n<p>In your case the input sequence does not satisfy that requirement. <code>std::binary_search</code> cannot be used on it.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2013-07-11T21:27:03.073", "Score": "4", "CreationDate": "2013-07-11T21:21:55.303", "ParentId": "17603507", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2013-07-11T21:27:03.073"}});