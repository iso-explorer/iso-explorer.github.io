post_cb({"bq_ids": {"n4140": {"so_32496236_32504997_0": {"length": 11, "quality": 1.0, "section_id": 1159}}, "n3337": {"so_32496236_32504997_0": {"length": 11, "quality": 1.0, "section_id": 1157}}, "n4659": {"so_32496236_32504997_0": {"length": 11, "quality": 1.0, "section_id": 1253}}}, "32504997": {"Id": "32504997", "PostTypeId": "2", "Body": "<p><code>volatile</code> is not necessary for any \"sane\" implementation when the <code>Gadget</code> example is changed to use <code>std::atomic&lt;bool&gt;</code>. The reason for this is not that the standard forbids the use of registers, instead (\u00a729.3/13 in n3690):</p>\n<blockquote>\n<p id=\"so_32496236_32504997_0\">Implementations should make atomic stores visible to atomic loads within a reasonable amount of time.</p>\n</blockquote>\n<p>Of course, what constitutes \"reasonable\" is open to interpretation, and it's \"should\", not \"shall\", so an implementation might ignore the requirement without violating the letter of the standard. Typical implementations do not cache the results of atomic loads, nor (much) delay issuing an atomic store to the CPU, and thus leave the decision largely to the hardware. If you would like to enforce this behavior, you should use <code>volatile std::atomic&lt;bool&gt;</code> instead. In both cases, however, if another thread sets the flag, the <code>Wait()</code> <em>should</em> be finite, but if your compiler and/or CPU are so willing, can still take much longer than you would like.</p>\n<p>Also note that a memory fence does <em>not</em> guarantee that a store becomes visible to another thread immediately nor any sooner than it otherwise would. So even if the compiler added fence instructions to <code>Gadget</code>'s methods, they wouldn't help at all. Fences are used to guarantee consistency, not to increase performance.</p>\n", "LastActivityDate": "2015-09-10T14:42:14.383", "CommentCount": "0", "CreationDate": "2015-09-10T14:42:14.383", "ParentId": "32496236", "Score": "1", "OwnerUserId": "4083309"}, "32496531": {"Id": "32496531", "PostTypeId": "2", "Body": "<p>Did you notice that there was no load from just a register in your code? There was an explicit memory load from <code>_Guard</code>. So it did in fact prevent caching in a register.</p>\n<p>Now how it does this is up to the specific platform's implementation of <code>std::atomic</code>, but it must do this.</p>\n<p>And, by the way, Alexandrescu's reasoning is completely wrong for modern platforms. While it's true that <code>volatile</code> prevents the compiler from caching in a register, it doesn't prevent similar caching being done by the CPU or by hardware. On some platforms, it might happen to be adequate, but there is absolutely no reason to write gratuitously non-portable code that might break on a future CPU, compiler, library, or platform when a fully-portable alternative is readily available.</p>\n", "LastEditorUserId": "721269", "LastActivityDate": "2015-09-10T08:22:55.330", "Score": "5", "CreationDate": "2015-09-10T08:14:44.270", "ParentId": "32496236", "CommentCount": "3", "OwnerUserId": "721269", "LastEditDate": "2015-09-10T08:22:55.330"}, "32496236": {"ViewCount": "430", "Body": "<p>in <a href=\"http://www.drdobbs.com/cpp/volatile-the-multithreaded-programmers-b/184403766\" rel=\"nofollow noreferrer\">volatile: The Multithreaded Programmer's Best Friend</a>, Andrei Alexandrescu gives this example:</p>\n<pre><code>class Gadget\n{\npublic:\n    void Wait()\n    {\n        while (!flag_)\n        {\n            Sleep(1000); // sleeps for 1000 milliseconds\n        }\n    }\n    void Wakeup()\n    {\n        flag_ = true;\n    }\n    ...\nprivate:\n    bool flag_;\n};\n</code></pre>\n<p>he states,</p>\n<blockquote>\n<p id=\"so_32496236_32496236_0\">... the compiler concludes that it can cache flag_ in a register ... it harms correctness: after you call Wait for some Gadget object, although another thread calls Wakeup, Wait will loop forever. This is because the change of flag_ will not be reflected in the register that caches flag_.</p>\n</blockquote>\n<p>then he offers a solution:</p>\n<blockquote>\n<p id=\"so_32496236_32496236_1\">If you use the volatile modifier on a variable, the compiler won't cache that variable in registers \u2014 each access will hit the actual memory location of that variable.</p>\n</blockquote>\n<p>now, other people mentioned on stackoverflow and elsewhere that volatile keyword doesn't really offer any thread-safety guarantees, and i should use std::atomic or mutex synchronization instead, which i do agree.</p>\n<p>however, going the std::atomic route for example, which internally uses memory fences read_acquire and write_release (<a href=\"http://preshing.com/20120913/acquire-and-release-semantics/\" rel=\"nofollow noreferrer\">Acquire and Release Semantics</a>), i don't see how it actually fixes the register-cache problem in particular. </p>\n<p>in case of x86 for example, every load on x86/64 already implies acquire semantics and every store implies release semantics such that compiled code under x86 doesn't emit any actual memory barriers at all. (<a href=\"http://preshing.com/20140709/the-purpose-of-memory_order_consume-in-cpp11/\" rel=\"nofollow noreferrer\">The Purpose of memory_order_consume in C++11</a>)</p>\n<pre><code>g = Guard.load(memory_order_acquire);\nif (g != 0)\n    p = Payload;\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/O71ZK.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/O71ZK.png\"/></a></p>\n<blockquote>\n<p id=\"so_32496236_32496236_2\">On Intel x86-64, the Clang compiler generates compact machine code for this example \u2013 one machine instruction per line of C++ source code. This family of processors features a strong memory model, so the compiler doesn\u2019t need to emit special memory barrier instructions to implement the read-acquire.</p>\n</blockquote>\n<p>so.... just assuming x86 arch for now, how does std::atomic solve the cache in registry problem? w/ no memory barrier instructions for read-acquire in compiled code, it seems to be the same as the compiled code for just regular read.</p>\n", "AcceptedAnswerId": "32496531", "Title": "c++11 register cache thread safety", "CreationDate": "2015-09-10T07:57:28.417", "Id": "32496236", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-09-10T08:04:28.613", "LastEditorUserId": "3101492", "LastActivityDate": "2015-09-10T14:42:14.383", "Score": "6", "OwnerUserId": "3101492", "Tags": "<c++><multithreading><c++11><volatile><cpu-registers>", "AnswerCount": "2"}});