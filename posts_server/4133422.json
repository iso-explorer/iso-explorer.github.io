post_cb({"4133504": {"Id": "4133504", "PostTypeId": "2", "Body": "<p>3.7.3.1/2:</p>\n<p>[32. The intent is to have operator new() implementable by calling malloc() or calloc(), so the rules are substantially the same. C++ differs from C in requiring a zero request to return a non-null pointer.]</p>\n<p>Compare dynamically allocated array to <code>std::vector</code> for example. You can have a vector of size 0, so why not allow the same for the array? And it is always an error to access past the end of the array whether its size is 0 or not.</p>\n", "LastActivityDate": "2010-11-09T12:14:22.340", "CommentCount": "4", "CreationDate": "2010-11-09T12:14:22.340", "ParentId": "4133422", "Score": "4", "OwnerUserId": "471164"}, "4133422": {"ViewCount": "1680", "Body": "<p>This is similar to <a href=\"https://stackoverflow.com/questions/1259803/what-does-zero-sized-array-allocation-do-mean\">What does zero-sized array allocation do/mean?</a></p>\n<p>I have following code</p>\n<pre><code>int *p = new int[0];\ndelete []p;\n</code></pre>\n<p>p gets an address and gets deleted properly.</p>\n<p>My question is:  Why allocation of zero bytes is allowed by c++ Standard in the first place?\nWhy doesn't it throw bad_alloc or some special exception ?</p>\n<p>I think, It is just postponing the catastrophic failure, making programmer's life difficult. Because if size to be allocated is calculated at run time and if programmer assumes its allocated properly and tries to write something to that memory, ends up corrupting memory !!! and Crash may happen some where else in the code.</p>\n<p>EDIT: How much memory it allocates upon zero size request ?</p>\n", "AcceptedAnswerId": "4133504", "Title": "Why the allocation succeeds for size zero bytes?", "CreationDate": "2010-11-09T12:05:07.463", "Id": "4133422", "CommentCount": "7", "LastEditDate": "2017-05-23T10:27:04.450", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2010-11-09T12:30:48.410", "Score": "6", "OwnerUserId": "426051", "Tags": "<c++><memory-management>", "AnswerCount": "5"}, "4133473": {"Id": "4133473", "PostTypeId": "2", "Body": "<p>Long time ago, before using exceptions, the malloc function returned a NULL pointer if the allocation failed.</p>\n<p>If allocating zero bytes would also return a NULL pointer, it would be hard to make the distinction between a failed allocation and a succeeding-zero-bytes allocation.</p>\n<p>On the other hand if the allocation of zero bytes would return a non-NULL pointer, you end up with a situation in which two different allocations of zero bytes can have the same pointer.</p>\n<p>Therefore, to keep things simple, the malloc function of zero bytes allocates 1 byte.</p>\n", "LastActivityDate": "2010-11-09T12:11:23.583", "CommentCount": "2", "CreationDate": "2010-11-09T12:11:23.583", "ParentId": "4133422", "Score": "5", "OwnerUserId": "163551"}, "bq_ids": {"n4140": {"so_4133422_4133555_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 6088}}, "n3337": {"so_4133422_4133555_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 5856}}, "n4659": {"so_4133422_4133555_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 7584}}}, "4133470": {"Id": "4133470", "PostTypeId": "2", "Body": "<p>The same can be said for int[N] where N&gt;0:</p>\n<blockquote>\n<p id=\"so_4133422_4133470_0\">Because if size to be allocated is calculated at run time and if programmer assumes its allocated properly and tries to write something <strong>past end of</strong> that memory, ends up corrupting memory !!! and Crash may happen some where else in the code.</p>\n</blockquote>\n", "LastActivityDate": "2010-11-09T12:10:47.687", "CommentCount": "0", "CreationDate": "2010-11-09T12:10:47.687", "ParentId": "4133422", "Score": "3", "OwnerUserId": "343443"}, "4133447": {"Id": "4133447", "PostTypeId": "2", "Body": "<p>Why would you want it to fail?  If the programmer tries to read/write to non-existent elements, then that is an error.  The initial allocation is not (this is no different to e.g. <code>int *p = new int[1]; p[1] = 5;</code>).</p>\n", "LastActivityDate": "2010-11-09T12:08:04.167", "CommentCount": "11", "CreationDate": "2010-11-09T12:08:04.167", "ParentId": "4133422", "Score": "6", "OwnerUserId": "129570"}, "4133555": {"Id": "4133555", "PostTypeId": "2", "Body": "<p>Zero sized array allocation is covered in the ISO C++ Standard under <a href=\"http://www.google.de/url?sa=t&amp;source=web&amp;cd=4&amp;ved=0CDAQFjAD&amp;url=http%3A%2F%2Fopenassist.googlecode.com%2Ffiles%2FC%252B%252B%2520Standard%2520-%2520ANSI%2520ISO%2520IEC%252014882%25202003.pdf&amp;rct=j&amp;q=C%2B%2B%205.3.4%20&amp;ei=YjrZTLGsH4jzsgaJkMDyBw&amp;usg=AFQjCNG4-cbawIu_O0_KwFqjXU6VG1cZDA&amp;sig2=E6fGC18UDiY4ofD8sg6STA&amp;cad=rja\" rel=\"nofollow\">5.3.4, paragrahp 7</a></p>\n<blockquote>\n<p id=\"so_4133422_4133555_0\">When the value of the expression in a direct-new-declarator is zero, the allocation function is called to allocate an array with no elements.</p>\n</blockquote>\n<p>This makes code that performs dnaymic array allocation easier.</p>\n<p>In general: If someone calls a function and asks it to return an array with n (0 in your case) elements, the code shouldn't be trying to read the returned array past the n-nth element anyway.</p>\n<p>So, I don't really see the catastrophic failure, since the code would have been faulty to begin with for any n.</p>\n<p>As you say:</p>\n<blockquote>\n<p id=\"so_4133422_4133555_1\">Because if size to be allocated is calculated at run time and if programmer assumes its  allocated properly</p>\n</blockquote>\n<p>The calculated size would be \"0\", if he tries to access more than his calculated size then, well.. I am repeating myself ;)</p>\n", "LastEditorUserId": "102693", "LastActivityDate": "2010-11-09T12:30:48.410", "Score": "2", "CreationDate": "2010-11-09T12:20:42.983", "ParentId": "4133422", "CommentCount": "0", "OwnerUserId": "102693", "LastEditDate": "2010-11-09T12:30:48.410"}});