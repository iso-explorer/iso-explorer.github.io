post_cb({"26082959": {"CommentCount": "0", "AcceptedAnswerId": "26083391", "PostTypeId": "1", "LastEditorUserId": "41071", "CreationDate": "2014-09-28T08:14:31.533", "LastActivityDate": "2014-09-28T12:58:27.037", "AnswerCount": "1", "LastEditDate": "2014-09-28T12:21:32.933", "ViewCount": "144", "FavoriteCount": "1", "Title": "Mutation of a mutable data-member via pointer-to-member", "Id": "26082959", "Score": "1", "Body": "<p>The Standard provide the following note:</p>\n<blockquote>\n<p id=\"so_26082959_26082959_0\">[ Note: it is not possible to use a pointer to member that refers to a\n  mutable member to modify a const class object. For example,</p>\n<pre><code>struct S {\n    S() : i(0) { }\n    mutable int i;\n};\nvoid f()\n{\n    const S cs;\n    int S::* pm = &amp;S::i; // pm refers to mutable member S::i\n    cs.*pm = 88; // ill-formed: cs is a const object\n}\n</code></pre>\n<p id=\"so_26082959_26082959_1\">-end note]</p>\n</blockquote>\n<p>But we can use just object-expression to modify const object which has a mutale data member.</p>\n<pre><code>#include &lt;iostream&gt;\nstruct A\n{\n    A(){ }\n    mutable int a;\n};\nconst A a;\n\nint main()\n{\n    a.a = 4;\n    std::cout &lt;&lt; a.a; //4\n}\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/a0cbab21f9042e64\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>But ISO/IEC Derictive tells</p>\n<blockquote>\n<p id=\"so_26082959_26082959_2\">Notes and examples integrated in the text of a document shall only be\n  used for giving additional information intended to assist the\n  understanding or use of the document. They shall not contain\n  requirements (\"shall\"; see 3.3.1 and Table H.1) or any information\n  considered indispensable for the use of the document [...]</p>\n</blockquote>\n<p>Which means the note I provide at the beginning of my Q is not a requirement.</p>\n<p>I'm looking for a normative requirement explcitly precludes such using.</p>\n", "Tags": "<c++><language-lawyer><mutable>", "OwnerDisplayName": "user2953119"}, "26083391": {"ParentId": "26082959", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Just before that note you will find the following:</p>\n<blockquote>\n<p id=\"so_26082959_26083391_0\">The restrictions on cv-quali\ufb01cation, and the manner in which the cv-quali\ufb01ers of the operands are combined to produce the cv-quali\ufb01ers of the result, are the same as the rules for E1.E2 given in 5.2.5</p>\n</blockquote>\n<p>Jump up to 5.2.5 and you'll find this:</p>\n<blockquote>\n<p id=\"so_26082959_26083391_1\">If E2 is a non-static data member and the type of E1 is \u201ccq1 vq1 X\u201d, and the type of E2 is \u201ccq2 vq2 T\u201d, the expression designates the named member of the object designated by the \ufb01rst expression. If E1 is an lvalue, then E1.E2 is an lvalue; otherwise E1.E2 is an xvalue. Let the notation vq12 stand for the \u201cunion\u201d of vq1 and vq2; that is, if vq1 or vq2 is volatile, then vq12 is volatile. Similarly, let the notation cq12 stand for the \u201cunion\u201d of cq1 and cq2; that is, <strong>if cq1 or cq2 is const, then cq12 is const.</strong> If E2 is declared to be a mutable member, then the type of E1.E2 is \u201cvq12 T\u201d. If E2 is not declared to be a mutable member, then the type of E1.E2 is \u201ccq12 vq12 T\u201d.</p>\n</blockquote>\n<p>The union of the const qualifiers in <code>cs.*pm</code> is <code>const</code>, the exception for <code>mutable</code> members doesn't apply to pointers.</p>\n<p>It's easier to understand if you consider that storage class specifiers are not part of the type, so how would the compiler be able to distinguish between <code>mutable</code> and non-<code>mutable</code> pointers to member?</p>\n<pre><code>struct S;\n\nvoid f(const S&amp; s, int S::* pm)\n{\n  s.*pm = 1; // How do I know if pm points to a mutable member? S isn't even defined!\n}\n</code></pre>\n<p>Simply put, there is no such thing as a pointer to a <code>mutable</code> member, just as there is no such thing as a pointer to a <code>static</code> member, the pointed type's storage class is unknown (the type can only be qualified by <code>const</code> and / or <code>volatile</code>).</p>\n", "OwnerUserId": "657267", "LastEditorUserId": "657267", "LastEditDate": "2014-09-28T12:58:27.037", "Id": "26083391", "Score": "1", "CreationDate": "2014-09-28T09:15:14.950", "LastActivityDate": "2014-09-28T12:58:27.037"}, "bq_ids": {"n4140": {"so_26082959_26082959_0": {"section_id": 6132, "quality": 0.8571428571428571, "length": 12}, "so_26082959_26083391_0": {"section_id": 6132, "quality": 0.6666666666666666, "length": 10}, "so_26082959_26083391_1": {"section_id": 6007, "quality": 0.7272727272727273, "length": 48}}, "n3337": {"so_26082959_26082959_0": {"section_id": 5896, "quality": 0.8571428571428571, "length": 12}, "so_26082959_26083391_0": {"section_id": 5896, "quality": 0.6666666666666666, "length": 10}, "so_26082959_26083391_1": {"section_id": 5775, "quality": 0.7121212121212122, "length": 47}}, "n4659": {"so_26082959_26082959_0": {"section_id": 7629, "quality": 0.8571428571428571, "length": 12}, "so_26082959_26083391_0": {"section_id": 7629, "quality": 0.6666666666666666, "length": 10}, "so_26082959_26083391_1": {"section_id": 7506, "quality": 0.7272727272727273, "length": 48}}}});