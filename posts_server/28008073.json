post_cb({"28008073": {"CommentCount": "3", "AcceptedAnswerId": "28008120", "OwnerDisplayName": "user2953119", "CreationDate": "2015-01-18T07:37:24.573", "LastActivityDate": "2015-01-18T07:45:05.743", "PostTypeId": "1", "ViewCount": "58", "FavoriteCount": "1", "Title": "Overload resolution for pointer to function", "Id": "28008073", "Score": "1", "Body": "<p>When the function is called it's clear how name-lookup and overload resolution is performed. But what happens when the funtion is not being called? E.g. </p>\n<pre><code>#include &lt;iostream&gt;\n\nusing std::cout;\nusing std::endl;\n\nvoid foo(int){ cout &lt;&lt; \"foo(int)\" &lt;&lt; endl; }\nvoid foo(int, int){ cout &lt;&lt; \"foo(int, int)\" &lt;&lt; endl; }\n\nvoid (*baz)(int, int);\n\n\nint main()\n{ \n    baz = foo; //1\n    baz(1, 1); \n}\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/f3bbe96c6a33dfaa\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>In that case we have two functions with the name <code>foo</code> and formally, the unqualified name lookup finds both them. The clause 13 of the Standard doesn't cover that case because it's concerned only in the function call context <code>N3797:13.3/2 [over.match]</code>:</p>\n<blockquote>\n<p id=\"so_28008073_28008073_0\">Overload resolution <em>selects the function to call</em> in seven distinct\n  contexts within the language:</p>\n</blockquote>\n", "Tags": "<c++><function>", "AnswerCount": "1"}, "28008120": {"ParentId": "28008073", "CommentCount": "1", "Body": "<p>The behavior in this case is governed by this verbiage in the C++11 standard (there is a similar section in N3797):</p>\n<blockquote>\n<p id=\"so_28008073_28008120_0\">A use of an overloaded function name without arguments is resolved in certain contexts to a function, a pointer to function or a pointer to member function for a specific function from the overload set. ... <strong>The function selected\n  is the one whose type is identical to the function type of the target type required in the context.</strong>  -- ISO/IEC 14882:2011(E) \u00a713.4 [over.over] (emphasis mine)</p>\n</blockquote>\n<p>The standard overload resolution rules aren't used here because you are assigning to a function pointer type, so the compiler will simply select the function overload that exactly matches the type of the function pointer.</p>\n", "OwnerUserId": "501250", "PostTypeId": "2", "Id": "28008120", "Score": "2", "CreationDate": "2015-01-18T07:45:05.743", "LastActivityDate": "2015-01-18T07:45:05.743"}, "bq_ids": {"n4140": {"so_28008073_28008073_0": {"section_id": 563, "quality": 1.0, "length": 10}, "so_28008073_28008120_0": {"section_id": 641, "quality": 0.8108108108108109, "length": 30}}, "n3337": {"so_28008073_28008073_0": {"section_id": 554, "quality": 1.0, "length": 10}, "so_28008073_28008120_0": {"section_id": 631, "quality": 0.8108108108108109, "length": 30}}, "n4659": {"so_28008073_28008073_0": {"section_id": 586, "quality": 1.0, "length": 10}, "so_28008073_28008120_0": {"section_id": 669, "quality": 0.7027027027027027, "length": 26}}}});