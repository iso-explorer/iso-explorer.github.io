post_cb({"bq_ids": {"n4140": {"so_15359654_15359823_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 7189}, "so_15359654_15359823_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 7194}}, "n3337": {"so_15359654_15359823_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 6933}, "so_15359654_15359823_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 6938}}, "n4659": {"so_15359654_15359823_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 8697}, "so_15359654_15359823_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 8703}}}, "15359823": {"Id": "15359823", "PostTypeId": "2", "Body": "<p>Assuming the <code>reinterpret_cast</code>s are well-defined (that is, <code>dest</code> really is a pointer to pointer to <code>T</code>), the standard defines the end of an object's lifetime as:</p>\n<blockquote>\n<p id=\"so_15359654_15359823_0\">The lifetime of an object of type T ends when:</p>\n<ul>\n<li>if T is a class type with a non-trivial destructor (12.4), the destructor call starts, or</li>\n<li>the storage which the object occupies is reused or released.</li>\n</ul>\n</blockquote>\n<p>It then gives some restrictions over what can be done with the glvalue <code>**reinterpret_cast&lt;T**&gt;(dest)</code>:</p>\n<blockquote>\n<p id=\"so_15359654_15359823_1\">Similarly, [...] after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any glvalue that refers to the original object may be used but only in limited ways. [...] The program has undefined behavior if:</p>\n<ul>\n<li>an lvalue-to-rvalue conversion (4.1) is applied to such a glvalue,</li>\n<li><strong>the glvalue is used to access a non-static data member or call a non-static member function of the object</strong>, or</li>\n<li>the glvalue is implicitly converted (4.10) to a reference to a base class type, or</li>\n<li>the glvalue is used as the operand of a static_cast (5.2.9) except when the conversion is ultimately to cv char&amp; or cv unsigned char&amp;, or</li>\n<li>the glvalue is used as the operand of a dynamic_cast (5.2.7) or as the operand of typeid.</li>\n</ul>\n</blockquote>\n<p>Emphasis added.</p>\n<p>If the object doesn't end up in this after-life state because it has a trivial destructor, there is no problem. However, for any <code>T</code> which is a class type with non-trivial destructor, we know that the assignment operator is considered a member function <code>operator=</code> of that class. Calling a non-static member function of the object through this glvalue results in undefined behaviour.</p>\n", "LastEditorUserId": "150634", "LastActivityDate": "2013-03-12T11:41:00.700", "Score": "3", "CreationDate": "2013-03-12T11:24:01.867", "ParentId": "15359654", "CommentCount": "2", "OwnerUserId": "150634", "LastEditDate": "2013-03-12T11:41:00.700"}, "15359760": {"Id": "15359760", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15359654_15359760_0\">This looks like UB to me, since the object is destroyed and then\n  assigned to without being constructed, i.e. it needs to either just\n  copy-assign (the second line only) or explicitly destruct (the first\n  line) followed by placement-new copy construction instead of the\n  assignment.</p>\n</blockquote>\n<p>There is no need to fix anything, although this code is certainly not safe without further qualification (it's certain to be safe in the context where it's used though).</p>\n<p>The object at <code>dest</code> is destroyed, and then the memory backing the object at <code>src</code> is copied over to where the object at <code>dest</code> used to live. End result: you have destroyed one object and placed a shallow clone of another object where the first one used to live.</p>\n<p>If you only do the copy assignment the first object will not have been destructed, resulting in resource leaks.</p>\n<p>Using placement <code>new</code> to populate the memory at <code>dest</code> would be an option, but it has very different semantics than the existing code (creates a brand new object instead of making a shallow clone of an existing one). Placement new and using the copy constructor also has different semantics: the object needs to have an accessible copy constructor, and you are no longer in control of what the result will be (the copy constructor does whatever it wants).</p>\n", "LastEditorUserId": "50079", "LastActivityDate": "2013-03-12T11:26:05.700", "Score": "0", "CreationDate": "2013-03-12T11:20:38.547", "ParentId": "15359654", "CommentCount": "6", "OwnerUserId": "50079", "LastEditDate": "2013-03-12T11:26:05.700"}, "15359654": {"ViewCount": "132", "Body": "<p>I have come across some code that is intended to replace an object in-place without reallocation of memory:</p>\n<pre><code>static void move(void* const* src, void** dest) {\n   (*reinterpret_cast&lt;T**&gt;(dest))-&gt;~T();\n   **reinterpret_cast&lt;T**&gt;(dest) = **reinterpret_cast&lt;T* const*&gt;(src);\n}\n</code></pre>\n<p>This looks like UB to me, since the object is destroyed and then assigned to without being constructed, i.e. it needs to either just copy-assign (the second line only) or explicitly destruct (the first line) followed by placement-new copy construction instead of the assignment.</p>\n<p>I only ask because although this seems like a glaring bug to me, it has existed for some time in both <a href=\"http://www.boost.org/doc/libs/1_53_0/boost/spirit/home/support/detail/hold_any.hpp\" rel=\"nofollow\">boost::spirit::hold_any</a> and the original <a href=\"http://www.codeproject.com/Articles/11250/High-Performance-Dynamic-Typing-in-C-using-a-Repla\" rel=\"nofollow\"><code>cdiggins::any</code></a> on which it is based. (I have asked about it on the Boost developers mailing list, but while awaiting responses wish to fix this locally if it is indeed incorrect.)</p>\n", "AcceptedAnswerId": "15359823", "Title": "Is this assignment invalid after explicit destructor call?", "CreationDate": "2013-03-12T11:15:54.227", "Id": "15359654", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-03-12T11:41:00.700", "Score": "4", "OwnerUserId": "322333", "Tags": "<c++>", "AnswerCount": "2"}});