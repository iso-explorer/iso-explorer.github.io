post_cb({"bq_ids": {"n4140": {"so_39186010_39186556_0": {"length": 36, "quality": 0.9, "section_id": 592}}, "n3337": {"so_39186010_39186556_0": {"length": 36, "quality": 0.9, "section_id": 582}}, "n4659": {"so_39186010_39186556_0": {"length": 36, "quality": 0.9, "section_id": 615}}}, "39186556": {"Id": "39186556", "PostTypeId": "2", "Body": "<p>If you had this, where the objective of the overload resolution process would be to determine <em>how to convert <code>C</code> to <code>A</code></em>, then it would indeed be ambiguous, since either the converting constructor or the conversion function could be used:</p>\n<pre><code>void f(A);\nf(c);\n</code></pre>\n<p>However, this is not the same as that:</p>\n<pre><code>A a(c);\n</code></pre>\n<p>Here, overload resolution is used to determine <em>which constructor of <code>A</code> to call,</em> and therefore it selects the constructor whose parameter type matches exactly with the type of the argument.</p>\n<p>The Standard reference is [over.match.ctor]/1 in C++14:</p>\n<blockquote>\n<p id=\"so_39186010_39186556_0\">When objects of class type are direct-initialized (8.5), or copy-initialized from an expression of the same or\n  a derived class type (8.5), overload resolution selects the constructor. For direct-initialization, the candidate\n  functions are all the constructors of the class of the object being initialized. For copy-initialization, the\n  candidate functions are all the converting constructors (12.3.1) of that class. The argument list is the\n  <em>expression-list</em> or <em>assignment-expression</em> of the <em>initializer.</em></p>\n</blockquote>\n", "LastActivityDate": "2016-08-27T23:00:55.703", "Score": "3", "CreationDate": "2016-08-27T23:00:55.703", "ParentId": "39186010", "CommentCount": "9", "OwnerUserId": "481267"}, "39186010": {"ViewCount": "129", "Body": "<p>Why isn't the call <code>A a(c);</code> in <code>main()</code> ambiguous?</p>\n<pre><code>struct C;\n\nstruct A {\n\n    A() { std::cout &lt;&lt; \"default ctor A\" &lt;&lt; '\\n'; }\n    A(const A&amp;) { std::cout &lt;&lt; \"copy A\" &lt;&lt; '\\n'; }\n    A(C&amp;) { std::cout &lt;&lt; \"ctor A(C)\" &lt;&lt; '\\n'; };\n};\nstruct C {\n\n    C() { std::cout &lt;&lt; \"default ctor C\" &lt;&lt; '\\n'; }\n    operator A() { std::cout &lt;&lt; \"C::operator A()\" &lt;&lt; '\\n'; return A(); };\n};\n\n\nint main()\n{\n     C c;\n     A a(c); \n}\n</code></pre>\n<p>The code prints (clang and GCC):</p>\n<pre><code>default ctor C\nctor A(C)\n</code></pre>\n<p>If we comment out the constructor A::A(C&amp;) the code prints:</p>\n<pre><code>default ctor C\nC::operator A()\ndefault ctor A\ncopy A\ncopy A\n</code></pre>\n", "Title": "Why isn't the call `A a(c);` in main() ambiguous?", "CreationDate": "2016-08-27T21:44:00.740", "LastActivityDate": "2016-08-27T23:00:55.703", "CommentCount": "10", "PostTypeId": "1", "Id": "39186010", "Score": "1", "OwnerUserId": "2548699", "Tags": "<c++><initialization><language-lawyer><ambiguous><c++1z>", "AnswerCount": "1"}});