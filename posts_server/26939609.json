post_cb({"bq_ids": {"n4140": {"so_26939609_26939661_3": {"length": 39, "quality": 0.9069767441860465, "section_id": 5879}, "so_26939609_26939661_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 5873}, "so_26939609_26939661_5": {"length": 15, "quality": 0.8333333333333334, "section_id": 5851}}, "n3337": {"so_26939609_26939661_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 5644}, "so_26939609_26939661_5": {"length": 15, "quality": 0.8333333333333334, "section_id": 5621}}, "n4659": {"so_26939609_26939661_3": {"length": 39, "quality": 0.9069767441860465, "section_id": 7363}, "so_26939609_26939661_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 7356}, "so_26939609_26939661_5": {"length": 15, "quality": 0.8333333333333334, "section_id": 7330}}}, "26939609": {"ViewCount": "2189", "Body": "<p>I come from C programming where the data in a struct is laid out with the top variable first, then the second, third and so on..</p>\n<p>I am now programming in C++ and I am using a class instead. I basically want to achieve the same, but I also want get/set methods and also maybe other methods (I also want to try do it in a C++ style and maye learn something new).</p>\n<p>Is there a guarantee e.g. that the public variables will be first in memory then the private variable?</p>\n", "AcceptedAnswerId": "26939661", "Title": "How is the memory layout of a class vs. a struct", "CreationDate": "2014-11-14T22:04:45.960", "Id": "26939609", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-03-18T10:34:43.800", "LastEditorUserId": "3647361", "LastActivityDate": "2016-09-03T12:10:53.387", "Score": "10", "OwnerUserId": "1840438", "Tags": "<c++><c><class><struct><language-lawyer>", "AnswerCount": "2"}, "26939665": {"Id": "26939665", "PostTypeId": "2", "Body": "<p>First thing first: <code>class</code> and <code>struct</code> in C++ are very much the same - the only difference is that all members before the first access specifier in a <code>class</code> are considered private, while in a <code>struct</code> they are public.</p>\n<blockquote>\n<p id=\"so_26939609_26939665_0\">Is there a guarantee e.g. that the public variables will be first in memory then the private variable?</p>\n</blockquote>\n<p>There is no such guarantee. When there is no inheritance, the memory will be allocated to class members in the order in which you declare them within the same access group. It is up to the compiler to decide if the public member variables should be placed ahead of the private / protected ones or vice versa. Like C, C++ can add padding in between class members.</p>\n<p>Inheritance makes things more complicated, because data members of the base class need to be placed within the derived class as well. On top of that, there is virtual inheritance and multiple inheritance, with complex rules.</p>\n<blockquote>\n<p id=\"so_26939609_26939665_1\">I basically want to achieve the same [layout], but I also want get/set methods and also maybe other methods.</p>\n</blockquote>\n<p>If you make all data members of your class private, and add accessor member functions (that's what C++ calls \"methods\" from other languages) you would achieve this effect.</p>\n", "LastEditorUserId": "335858", "LastActivityDate": "2016-09-03T12:10:53.387", "Score": "5", "CreationDate": "2014-11-14T22:07:55.363", "ParentId": "26939609", "CommentCount": "0", "OwnerUserId": "335858", "LastEditDate": "2016-09-03T12:10:53.387"}, "26939661": {"Id": "26939661", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_26939609_26939661_0\">Is there a guarantee e.g. that the public variables will be first in\n  memory then the private variable?</p>\n</blockquote>\n<p>No, such a guarantee is <strong>not</strong> made - C++11 standard, [class.mem]/14:</p>\n<blockquote>\n<p id=\"so_26939609_26939661_1\">Nonstatic data members of a (non-union) class with <strong>the same access\n  control</strong> (Clause 11) are allocated so that later members have higher\n  addresses within a class object. <strong>The order of allocation of non-static\n  data members with different access control is unspecified</strong> (11).</p>\n</blockquote>\n<p>So</p>\n<pre><code>struct A\n{\n    int i, j;\n    std::string str;\n\nprivate:\n\n    float f;\n\nprotected:\n\n    double d;\n};\n</code></pre>\n<p>It is only guaranteed that, for a given object of type <code>A</code>,</p>\n<ul>\n<li><code>i</code> has a smaller address than <code>j</code> and</li>\n<li><code>j</code> has a smaller address than <code>str</code></li>\n</ul>\n<p>Note that the class-keys <code>struct</code> and <code>class</code> have no difference regarding layout whatsoever: Their only difference are access-rights which only exist at compile-time.</p>\n<hr>\n<blockquote>\n<p id=\"so_26939609_26939661_2\">It only says the order, but not that the first variable actually start\n  at the \"first address\"? Lets assume a class without inheritance.</p>\n</blockquote>\n<p>Yes, but only for <strong>standard-layout classes</strong>. There is a row of requirements a class must satisfy to be a standard-layout class, one of them being that all members have the same access-control.<br>\nQuoting C++14 (the same applies for C++11, but the wording is more indirect), [class.mem]/19:</br></p>\n<blockquote>\n<p id=\"so_26939609_26939661_3\">If a standard-layout class object has any non-static data members, its\n  address is the same as the address of its first non-static data\n  member. Otherwise, its address is the same as the address of its first\n  base classsubobject (if any). [ <em>Note</em>: There might therefore be\n  unnamed padding within a standard-layout struct object, but not at its beginning, as necessary to achieve appropriate alignment. <em>\u2014 end note</em> ]</p>\n</blockquote>\n<p>[class]/7:</p>\n<blockquote>\n<p id=\"so_26939609_26939661_4\">A <em>standard-layout class</em> is a class that:</p>\n<ul>\n<li>has no non-static data members of type non-standard-layout class (or array of such types) or reference,</li>\n<li>has no virtual functions (10.3) and no virtual base classes (10.1),</li>\n<li>has the same access control (Clause 11) for all non-static data members,</li>\n<li>has no non-standard-layout base classes,</li>\n<li>either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base\n  classes with non-static data members, and</li>\n<li>has no base classes of the same type as the first non-static data member. <sup>110</sup></li>\n</ul>\n<p id=\"so_26939609_26939661_5\"><sup>110) This ensures that two subobjects that have the same class type and that belong to the same most derived object are not\n  allocated at the same address (5.10).</sup></p>\n</blockquote>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2014-11-15T01:29:32.037", "Score": "16", "CreationDate": "2014-11-14T22:07:51.767", "ParentId": "26939609", "CommentCount": "7", "OwnerUserId": "3647361", "LastEditDate": "2014-11-15T01:29:32.037"}});