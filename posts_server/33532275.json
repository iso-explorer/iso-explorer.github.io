post_cb({"33532275": {"CommentCount": "2", "ViewCount": "40", "PostTypeId": "1", "LastEditorUserId": "1478835", "CreationDate": "2015-11-04T21:24:01.937", "LastActivityDate": "2015-11-04T22:25:27.393", "Title": "I've met an copy constructor error, but don't know if my thought about this error is correct", "AcceptedAnswerId": "33532723", "LastEditDate": "2015-11-04T21:32:12.613", "Id": "33532275", "Score": "0", "Body": "<p>I'm writing an unique_ptr-like class called StackGuard, and trying to make two copy constructors:</p>\n<pre><code>template&lt;typename T&gt;    \nclass StackGuard{\n  T* thePtr;   //To store the raw pointer.\n               //something here...\n  StackGuard(StackGuard&lt;T&gt;&amp; newPtr) throw();\n  StackGuard(StackGuard&lt;T&gt; newPtr) throw();  //I know this is not the right way\n              //something here...\n};\n\ntemplate&lt;typename T&gt;\nStackGuard&lt;T&gt;::StackGuard(StackGuard&lt;T&gt;&amp; newPtr) throw(){\n    thePtr = newPtr.thePtr;\n    newPtr.thePtr = NULL;\n}\n\ntemplate&lt;typename T&gt;\nStackGuard&lt;T&gt;::StackGuard(StackGuard&lt;T&gt; newPtr) throw(){\n    thePtr = newPtr.thePtr;\n    newPtr.thePtr = NULL;\n}\n</code></pre>\n<p>But it doesn't work. The compiler says</p>\n<pre><code>error: invalid constructor; you probably meant \u2018StackGuard&lt;T&gt; (const StackGuard&lt;T&gt;&amp;)\u2019\n     StackGuard(StackGuard&lt;T&gt; newPtr) throw();\n                                            ^\nerror: prototype for \u2018StackGuard&lt;T&gt;::StackGuard(StackGuard&lt;T&gt;)\u2019 \ndoes not match any in class \u2018StackGuard&lt;T&gt;\u2019\n  StackGuard&lt;T&gt;::StackGuard(StackGuard&lt;T&gt; newPtr) throw(){\n  ^\nerror: candidates are: StackGuard&lt;T&gt;::StackGuard(const StackGuard&lt;T&gt;&amp;)\n  StackGuard&lt;T&gt;::StackGuard(const StackGuard&lt;T&gt;&amp; newPtr) throw(){\n  ^\nerror:                 StackGuard&lt;T&gt;::StackGuard(T*)\n  StackGuard&lt;T&gt;::StackGuard(T* guarded = NULL) throw() {\n</code></pre>\n<p>I have a thought about this error, but don't know if it's right.</p>\n<p>My thought is:</p>\n<p>The pass-by-value copy constructor need to use the copy constructor to copy the argument, and at this scenario, the it'll call itself recursively, which will result in infinite calls.</p>\n<p>I also wonder, why the compiler give a \"does not match any in class\" error, since it has a match.</p>\n", "Tags": "<c++><copy-constructor><pass-by-value>", "OwnerUserId": "1478835", "AnswerCount": "2"}, "33532721": {"ParentId": "33532275", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Your assumption that the copy constructor would have to call itself recursively is correct. For this reason, the standard disallows copy constructors declared by value. This means that only the second version is legal.</p>\n<p>The other constructor is legal. However, you should usually declare copy constructors by const reference. Constructors should not modify their input, so you should let the compiler enforce the guarantee for you. Using a const reference will also let you copy const objects, which you can't do otherwise.</p>\n", "OwnerUserId": "108517", "LastEditorUserId": "108517", "LastEditDate": "2015-11-04T22:25:27.393", "Id": "33532721", "Score": "0", "CreationDate": "2015-11-04T21:50:24.657", "LastActivityDate": "2015-11-04T22:25:27.393"}, "33532723": {"ParentId": "33532275", "CommentCount": "3", "Body": "<p>From [class.copy]:</p>\n<blockquote>\n<p id=\"so_33532275_33532723_0\">A declaration of a constructor for a class X is ill-formed if its first parameter is of type (optionally cv-qualified)\n  X and either there are no other parameters or else all other parameters have default arguments. A member\n  function template is never instantiated to produce such a constructor signature.</p>\n</blockquote>\n<p>Your constructor <code>StackGuard(StackGuard&lt;T&gt; )</code> is ill-formed. The issue here has nothing to do with recursion: such a constructor would lead to ambiguity. Consider the equivalent:</p>\n<pre><code>void foo(int ) { }\nvoid foo(int&amp; ) { }\n\nint i;\nfoo(i); // error: ambiguous\n</code></pre>\n<p>If such a constructor were allowed, there would always be ambiguity between this impostor copy constructor and the real (implicit or explicit) copy constructor.</p>\n<p>And furthermore, \"unique-ptr like\" doesn't suggest to me copyable. You'll want to write a move constructor. If you don't have access to C++11, you'll want to take a look at how <code>auto_ptr</code> is implemented and copy from there.</p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "33532723", "Score": "3", "CreationDate": "2015-11-04T21:50:26.643", "LastActivityDate": "2015-11-04T21:50:26.643"}, "bq_ids": {"n4140": {"so_33532275_33532723_0": {"section_id": 455, "quality": 1.0, "length": 30}}, "n3337": {"so_33532275_33532723_0": {"section_id": 446, "quality": 1.0, "length": 30}}, "n4659": {"so_33532275_33532723_0": {"section_id": 478, "quality": 1.0, "length": 30}}}});