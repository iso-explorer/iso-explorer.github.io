post_cb({"bq_ids": {"n4140": {"so_28916602_28916778_1": {"length": 48, "quality": 0.8888888888888888, "section_id": 7043}}, "n3337": {"so_28916602_28916778_1": {"length": 48, "quality": 0.8888888888888888, "section_id": 6788}}, "n4659": {"so_28916602_28916778_1": {"length": 48, "quality": 0.8888888888888888, "section_id": 8540}}}, "28916602": {"ViewCount": "172", "Body": "<p>When you write a template function (or member) you have to write the body in the header file. This makes perfect sense since templates are essentially instructions to the compiler how to make functions on the fly based on a type unknown until the initialization.</p>\n<p>My question is connected to the one definition rule, if I initialize a template with the same type (for example <strong>typename T</strong> becomes <strong>int</strong>) in two different files and I link them together I do not have a multiple definition error.</p>\n<p>What is the reason? Are template functions implicitly <strong>static</strong> and so not visible outside their compilation unit?</p>\n<p>Or there is another reason?</p>\n<p>Answer:\nNo. They aren't. They are an exception to the one definition rule.</p>\n", "AcceptedAnswerId": "28916778", "Title": "C++ template functions are automatically static? (No, they aren't)", "CreationDate": "2015-03-07T15:41:34.800", "Id": "28916602", "CommentCount": "2", "LastEditDate": "2015-03-07T16:52:45.860", "PostTypeId": "1", "LastEditorUserId": "1876111", "LastActivityDate": "2015-03-07T16:52:45.860", "Score": "2", "OwnerUserId": "1876111", "Tags": "<c++><templates><static>", "AnswerCount": "1"}, "28916778": {"Id": "28916778", "PostTypeId": "2", "Body": "<p>The standard contains a special exception in the one definition rule for templates.</p>\n<p>N4140, emphasis mine:</p>\n<blockquote>\n<p id=\"so_28916602_28916778_0\"><strong>3.2 One definition rule [basic.def.odr]</strong></p>\n<p id=\"so_28916602_28916778_1\">6 There can be more than one definition of a class type (Clause 9), enumeration type (7.2), inline function with external linkage (7.1.2), class template (Clause 14), <strong>non-static function template (14.5.6)</strong>, static data member of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for which some template parameters are not specified (14.7, 14.5.5) in a program provided that each definition\n  appears in a different translation unit, and provided the definitions satisfy the following requirements. [...]</p>\n</blockquote>\n<p>Those following requirements effectively state that all definitions are required to be identical, but I'm assuming they are in your code.</p>\n<p>You can tell that template functions are neither implicitly <code>inline</code> nor implicitly <code>static</code> by the fact that this program works:</p>\n<p>a.cc:</p>\n<pre><code>template &lt;typename T&gt; T f();\nint main() { return f&lt;int&gt;(); }\n</code></pre>\n<p>b.cc:</p>\n<pre><code>template &lt;typename T&gt; T f() { return T(); }\ntemplate int f();\n</code></pre>\n<p>If templates were implicitly <code>inline</code>, this program would be invalid because an <code>inline</code> function must be defined in every translation unit where it is used.</p>\n<p>If templates were implicitly <code>static</code>, this program would be invalid because the definition in <code>b.cc</code> would not be found to match the declaration in <code>a.cc</code>.</p>\n", "LastActivityDate": "2015-03-07T15:58:19.183", "CommentCount": "10", "CreationDate": "2015-03-07T15:58:19.183", "ParentId": "28916602", "Score": "3", "OwnerUserId": "743382"}});