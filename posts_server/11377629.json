post_cb({"11378023": {"Body": "<p>That portion of the standard is simply telling you that when you are constructing some \"large\" object <code>J</code> whose base class hierarchy includes multiple inheritance, and you are currently sitting inside the constructor of some base subobject <code>H</code>, then you are only allowed to use polymorphism of <code>H</code> and its direct and indirect base subobjects. You are not allowed to use any polymorphism outside that subhierarchy.</p>\n<p>For example, consider this inheritance diagram (arrows point from derived classes to base classes)</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/aP8Fb.jpg\"/></p>\n<p>Let's say we are constructing a \"large\" object of type <code>J</code>. And we are currently executing the constructor of class <code>H</code>. Inside the constructor of <code>H</code> you are allowed to enjoy typical constructor-restricted polymorphism of the subhierarchy inside the red oval. For example, you can call virtual functions of base subobject of type <code>B</code>, and the polymorphic behavior will work as expected inside the circled subhierarchy (\"as expected\" means that the polymorphic behavior will go as low as <code>H</code> in the hierarchy, but no lower). You can also call virtual functions of <code>A</code>, <code>E</code>, <code>X</code> and other subobjects that fall inside the red oval.</p>\n<p>However, if you somehow gain access to the hierarchy <em>outside</em> the oval and attempt to use polymorphism there, the behavior becomes undefined. For example, if you somehow gain access to <code>G</code> subobject from the constructor of <code>H</code> and attempt to call a virtual function of <code>G</code> - the behavior is undefined. The same can be said about calling virtual functions of <code>D</code> and <code>I</code> from the constructor of <code>H</code>.</p>\n<p>The only way to obtain such access to the \"outside\" subhierarchy is if someone somehow passed a pointer/reference to <code>G</code> subobject into the constructor of <code>H</code>. Hence the reference to \"explicit class member access\" in the standard text (although it seems to be excessive).</p>\n<p>The standard includes <em>virtual</em> inheritance into the example to demonstrate how inclusive this rule is. In the above diagram base subobject <code>X</code> is shared by both the subhierarchy inside the oval and subhierarchy outside the oval. The standard says that it is OK to call virtual functions of <code>X</code> subobject from the constructor of <code>H</code>.</p>\n<p>Note that this restriction applies even if the construction of <code>D</code>, <code>G</code> and <code>I</code> subobjects has been finished before the construction of <code>H</code> began.</p>\n<hr>\n<p>The roots of this specification lead to practical consideration of implementing polymorphic mechanism. In practical implementations the VMT pointer is introduced as a data field into the object layout of the most basic polymorphic classes in the hierarchy. Derived classes don't introduce their own VMT pointers, they simply provide their own specific <em>values</em> for the pointers introduced by the base classes (and, possibly, longer VMTs).</p>\n<p>Take a look at the example from the standard. The class <code>A</code> is derived from class <code>V</code>. This means that the VMT pointer of <code>A</code> physically belongs to <code>V</code> subobject. All calls to virtual functions introduced by <code>V</code> are dispatched through VMT pointer introduced by <code>V</code>. I.e. whenever you call</p>\n<pre><code>pointer_to_A-&gt;f();\n</code></pre>\n<p>it is actually translated into </p>\n<pre><code>V *v_subobject = (V *) pointer_to_A; // go to V\nvmt = v_subobject-&gt;vmt_ptr;          // retrieve the table\nvmt[index_for_f]();                  // call through the table\n</code></pre>\n<p>However, in the example from the standard the very same <code>V</code> subobject is also embedded into <code>B</code>. In order to make the constructor-restricted polymorphism work correctly, the compiler will place a pointer to <code>B</code>'s VMT into VMT pointer stored in <code>V</code> (because while <code>B</code>'s constructor is active <code>V</code> subobject has to act as part of <code>B</code>).</p>\n<p>If at this moment you somehow attempt to call </p>\n<pre><code>a-&gt;f(); // as in the example\n</code></pre>\n<p>the above algorithm will find <code>B</code>'s VMT pointer stored in its <code>V</code> subobject and will attempt to call <code>f()</code> through that VMT. This obviously makes no sense at all. I.e. having virtual methods of <code>A</code> dispatched through <code>B</code>'s VMT makes no sense. The behavior is undefined.</p>\n<p>This is rather simple to verify with practical experiment. Let's add its own version of <code>f</code> to <code>B</code> and do this</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct V {\n  virtual void f() { std::cout &lt;&lt; \"V\" &lt;&lt; std::endl; }\n};\n\nstruct A : virtual V {\n  virtual void f() { std::cout &lt;&lt; \"A\" &lt;&lt; std::endl; }\n};\n\nstruct B : virtual V {\n  virtual void f() { std::cout &lt;&lt; \"B\" &lt;&lt; std::endl; }\n  B(V*, A*);\n};\n\nstruct D : A, B {\n  virtual void f() {}\n  D() : B((A*)this, this) { }\n};\n\nB::B(V* v, A* a) {\n  a-&gt;f(); // What `f()` is called here???\n}\n\nint main() {\n  D d;\n}\n</code></pre>\n<p>You expect <code>A::f</code> to be called here? I tried several compilers, an all of them actually call <code>B::f</code>! Meanwhile, the <code>this</code> pointer value <code>B::f</code> receives in such call is completely bogus.</p>\n<p><a href=\"http://ideone.com/Ua332\" rel=\"nofollow noreferrer\">http://ideone.com/Ua332</a></p>\n<p>This happens exactly for the reasons I described above (most compilers implement polymorphism the way I described above). This is the reason the language describes such calls as undefined.</p>\n<p>One might note that in this specific example it is actually the <em>virtual</em> inheritance that leads to this unusual behavior. Yes, it happens exactly because the <code>V</code> subobject is shared between <code>A</code> and <code>B</code> subobjects. It is quite possible that without virtual inheritance the behavior would be much more predictable. However, the language specification apparently decided to just draw line the the way it is drawn in my diagram: when you are constructing <code>H</code> you are not allowed to step out of the \"sandbox\" of <code>H</code>'s subhierarchy regardless of what inheritance type is used.</p>\n</hr>", "CreationDate": "2012-07-07T19:29:02.103", "ParentId": "11377629", "CommentCount": "1", "LastEditDate": "2013-10-09T18:06:10.427", "Id": "11378023", "PostTypeId": "2", "LastActivityDate": "2013-10-09T18:06:10.427", "LastEditorUserId": "187690", "CommunityOwnedDate": "2012-07-07T22:16:54.200", "Score": "17", "OwnerUserId": "187690"}, "11377756": {"Id": "11377756", "PostTypeId": "2", "Body": "<p>The last sentence of the normative text that you cite reads as follows:</p>\n<blockquote>\n<p id=\"so_11377629_11377756_0\">If the virtual function call uses an explicit class member access and the object expression refers to the complete object of <code>x</code> or one of that object\u2019s base class subobjects but not <code>x</code> or one of its base class subobjects, the behavior is undefined.</p>\n</blockquote>\n<p>This is, admittedly, rather convoluted.  This sentence exists to restrict what functions may be called during construction in the presence of multiple inheritance.</p>\n<p>The example contains multiple inheritance:  <code>D</code> derives from <code>A</code> and <code>B</code> (we'll ignore <code>V</code>, because it is not required to demonstrate why the behavior is undefined).  During construction of a <code>D</code> object, both the <code>A</code> and <code>B</code> constructors will be called to construct the base class subobjects of the <code>D</code> object.</p>\n<p>When the <code>B</code> constructor is called, the type <em>of the complete object of <code>x</code></em> is <code>D</code>.  In that constructor, <code>a</code> is a pointer to the <code>A</code> base class subobject of <code>x</code>.  So, we can say the following about <code>a-&gt;f()</code>:</p>\n<ul>\n<li><p>The <em>object under construction</em> is the <code>B</code> base class subobject of a <code>D</code> object (because this base class subobject is the object currently under construction, it is what the text refers to as <code>x</code>).</p></li>\n<li><p>It uses <em>explicit class member access</em> (via the <code>-&gt;</code> operator, in this case)</p></li>\n<li><p>The type of <em>the complete object of <code>x</code></em> is <code>D</code>, because that is the most-derived type that is being constructed</p></li>\n<li><p>The <em>object expression</em> (<code>a</code>) refers to a <em>base class subobject</em> of the complete object of <code>x</code> (it refers to the <code>A</code> base class subobject of the <code>D</code> object being constructed)</p></li>\n<li><p>The base class subobject to which the <em>object expression</em> refers is not <code>x</code> and is not a base class subobject of <code>x</code>:  <code>A</code> is not <code>B</code> and <code>A</code> is not a base class of <code>B</code>.</p></li>\n</ul>\n<p>Therefore, the behavior of the call is undefined, per the rule we started from at the beginning.</p>\n<blockquote>\n<p id=\"so_11377629_11377756_1\">Why is the last method call in <code>B::B</code> undefined? Shouldn't it just call <code>a.A::f</code>?</p>\n</blockquote>\n<p>The rule you cite states that when a constructor is called during construction, \"the function called is the final overrider in the constructor\u2019s class and not one overriding it in a more-derived class.\"</p>\n<p>In this case, the constructor's class is <code>B</code>.  Because <code>B</code> does not derive from <code>A</code>, there is no final overrider for the virtual function.  Therefore the attempt to make the virtual call exhibits undefined behavior.</p>\n", "LastActivityDate": "2012-07-07T18:51:33.890", "CommentCount": "6", "CreationDate": "2012-07-07T18:51:33.890", "ParentId": "11377629", "Score": "1", "OwnerUserId": "151292"}, "bq_ids": {"n4140": {"so_11377629_11377756_0": {"length": 26, "quality": 1.0, "section_id": 447}, "so_11377629_11377629_0": {"length": 71, "quality": 0.9466666666666667, "section_id": 447}}, "n3337": {"so_11377629_11377756_0": {"length": 26, "quality": 1.0, "section_id": 438}, "so_11377629_11377629_0": {"length": 71, "quality": 0.9466666666666667, "section_id": 438}}, "n4659": {"so_11377629_11377756_0": {"length": 26, "quality": 1.0, "section_id": 469}, "so_11377629_11377629_0": {"length": 71, "quality": 0.9466666666666667, "section_id": 469}}}, "11377629": {"ViewCount": "1250", "Body": "<p>This is from the C++11 standard sec 12.7.4. This is rather confusing.</p>\n<ol>\n<li>What does the last sentence in the text mean exactly?</li>\n<li>Why is the last method call in <code>B::B</code> undefined? Shoudn't it just call <code>a.A::f</code>? </li>\n</ol>\n<blockquote>\n<p id=\"so_11377629_11377629_0\">4 Member functions, including virtual functions (10.3), can be called\n  during construction or destruction (12.6.2). When a virtual function\n  is called directly or indirectly from a constructor or from a\n  destructor, including during the construction or destruction of the\n  class\u2019s non-static data members, and the object to which the call\n  applies is the object (call it x) under construction or destruction,\n  the function called is the final overrider in the constructor\u2019s or\n  destructor\u2019s class and not one overriding it in a more-derived class.\n  If the virtual function call uses an explicit class member access\n  (5.2.5) and the object expression refers to the complete object of x\n  or one of that object\u2019s base class subobjects but not x or one of its\n  base class subobjects, the behavior is undefined. [ Example:</p>\n<pre><code>struct V {\n virtual void f();\n virtual void g();\n};\n\nstruct A : virtual V {\n virtual void f();\n};\n\nstruct B : virtual V {\n virtual void g();\n B(V*, A*);\n};\n\nstruct D : A, B {\n virtual void f();\n virtual void g();\n D() : B((A*)this, this) { }\n};\n\nB::B(V* v, A* a) {\n f(); // calls V::f, not A::f\n g(); // calls B::g, not D::g\n v-&gt;g(); // v is base of B, the call is well-defined, calls B::g\n a-&gt;f(); // undefined behavior, a\u2019s type not a base of B\n}\n</code></pre>\n<p id=\"so_11377629_11377629_1\">\u2014end example ]</p>\n</blockquote>\n", "AcceptedAnswerId": "11378023", "Title": "C++ constructors: why is this virtual function call not safe?", "CreationDate": "2012-07-07T18:32:40.153", "Id": "11377629", "CommentCount": "7", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2012-07-07T18:43:41.013", "LastEditorUserId": "336186", "LastActivityDate": "2013-10-09T18:06:10.427", "Score": "13", "OwnerUserId": "540815", "Tags": "<c++><constructor><c++11><standards><virtual>", "AnswerCount": "3"}, "11377723": {"Id": "11377723", "PostTypeId": "2", "Body": "<p>Here's how I understand this: During the construction of an object, each sub-object constructs  its part. In the example, it means that <code>V::V()</code> initializes <code>V</code>'s members; <code>A</code> initializes <code>A</code>'s members, and so on. Since <code>V</code> is initialized before <code>A</code> and <code>B</code>, they can both rely on <code>V</code>'s members to be initialized.</p>\n<p>In the example, <code>B</code>'s constructor accepts two pointers to itself. Its <code>V</code> part is already constructed, so it's safe to call <code>v-&gt;g()</code>. However, at that point <code>D</code>'s <code>A</code> part has not been initialized yet. Therefore, the call <code>a-&gt;f()</code> accesses uninitialized memory, which is undefined behavior. </p>\n<p><strong>Edit:</strong></p>\n<p>In the <code>D</code> above, <code>A</code> is initialized before <code>B</code>, so there won't be any access to <code>A</code>'s uninitialized memory. On the other hand, once <code>A</code> has been fully constructed, its virtual functions are overridden by those of <code>D</code> (in practice: its vtable is set to <code>A</code>'s during construction, and to <code>D</code>'s once the construction is over). Therefore, the call to <code>a-&gt;f()</code> will invoke <code>D::f()</code>, before <code>D</code> has been initialized. So either way - <code>A</code> is constructed before <code>B</code> or after - you're going to call a method on an uninitialized object.</p>\n<p>The virtual functions part has already been discussed here, but for completeness: the call to <code>f()</code> uses <code>V::f</code> because <code>A</code> has not been initialized yet, and as far as <code>B</code> is concerned, that's the only implementation of <code>f</code>. <code>g()</code> calls <code>B::g</code> because <code>B</code> overrides <code>g</code>.</p>\n", "LastEditorUserId": "26039", "LastActivityDate": "2012-07-07T19:07:15.327", "Score": "1", "CreationDate": "2012-07-07T18:46:57.433", "ParentId": "11377629", "CommentCount": "2", "OwnerUserId": "26039", "LastEditDate": "2012-07-07T19:07:15.327"}});