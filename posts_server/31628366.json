post_cb({"bq_ids": {"n4140": {"so_31628366_31628464_0": {"length": 60, "quality": 0.967741935483871, "section_id": 5451}}, "n3337": {"so_31628366_31628464_0": {"length": 34, "quality": 0.5483870967741935, "section_id": 5245}}, "n4659": {"so_31628366_31628464_0": {"length": 36, "quality": 0.5806451612903226, "section_id": 6889}}}, "31628366": {"ViewCount": "570", "Body": "<p>I've encountered a pretty weird behavior when using auto and dynamic_cast.\nThis is the class hierachy i have:</p>\n<pre><code>class BaseInterface {\npublic:\n    virtual void someMethod()=0;\n};\n\nclass Derived:public BaseInterface {\npublic:\n    virtual void someMethod1()=0;\n    void someMethod()override;\n};\n</code></pre>\n<p>And of course there are some classes that implement all derived methods.</p>\n<p>Then there is a third class which looks like this:</p>\n<pre><code>class ThirdClass {\npublic:\n    void demoMethod(BaseInterface&amp;);\n    void anotherMethod(Derived&amp;);\n};\n\nvoid ThirdClass::demoMethod(BaseInterface&amp; obj) {\n    auto buffer=dynamic_cast&lt;Derived&amp;&gt;(obj);\n    anotherMethod(buffer);\n}\n</code></pre>\n<p>When i compile this with gcc i get an \"cannot allocate an object of abstract type\" error. Whereas when i replace</p>\n<pre><code>auto buffer=...\n</code></pre>\n<p>with</p>\n<pre><code>Derived&amp; buffer=...\n</code></pre>\n<p>everything compiles fine. Why is that the case? Is auto not deducing the right type or something?</p>\n<p>Also i found a dirty trick to still use auto:</p>\n<pre><code>void ThirdClass::demoMethod(Base&amp; obj) {\n    auto buffer=dynamic_cast&lt;Derived*&gt;(&amp;obj);\n    anotherMethod(*buffer);\n}\n</code></pre>\n", "AcceptedAnswerId": "31628451", "Title": "dynamic cast a reference and auto", "CreationDate": "2015-07-25T15:59:03.257", "Id": "31628366", "CommentCount": "6", "LastEditDate": "2015-07-25T16:12:37.150", "PostTypeId": "1", "LastEditorUserId": "47453", "LastActivityDate": "2015-07-25T16:36:28.067", "Score": "5", "OwnerUserId": "1965150", "Tags": "<c++><c++11><reference><auto><dynamic-cast>", "AnswerCount": "2"}, "31628464": {"Id": "31628464", "PostTypeId": "2", "Body": "<p>\u00a77.1.6.4/7:</p>\n<blockquote>\n<p id=\"so_31628366_31628464_0\">When a variable declared using a placeholder type is initialized [\u2026]\n  the deduced return type or variable type is determined from the type\n  of its initializer. [\u2026] let <code>T</code> be the declared type of the variable\n  or return type of the function. <strong>If the placeholder is the <code>auto</code>\n  type-specifier, the deduced type is determined using the rules for\n  template argument deduction.</strong> [\u2026] obtain <code>P</code> from <code>T</code> by replacing the\n  occurrences of <code>auto</code> with either a new invented type template\n  parameter <code>U</code>[\u2026]. <strong>Deduce a value for <code>U</code> using the rules of template\n  argument deduction from a function call (14.8.2.1), where <code>P</code> is a\n  function template parameter type and the corresponding argument is the\n  initializer.</strong></p>\n</blockquote>\n<p>So, in order to familiarize yourself with the process, take a look at the actual rule used for deducing the type of <code>buffer</code>: What happens if you change</p>\n<pre><code>template &lt;typename U&gt;\nvoid f( U );\n</code></pre>\n<p>to</p>\n<pre><code>void f( Derived&amp; );\n</code></pre>\n<p>when calling <code>f</code> with an lvalue of type <code>Derived</code>? Clearly, for the function template, <code>U</code> will be deduced as <code>Derived</code>, which then yields a deduction failure.<br>\nThis directly corresponds to the deduction of the placeholder type in your example - <code>auto</code> will be replaced by <code>Derived</code>, and that fails, as <code>Derived</code> is abstract.</br></p>\n<p>Generally speaking, if you write</p>\n<pre><code>auto obj = \u2026;\n</code></pre>\n<p><strong><code>obj</code> will never be a reference</strong>, just as <code>U</code> will never be deduced as a reference type when calling the above function template.</p>\n<hr>\n<p>Instead, use <code>auto&amp;</code>:</p>\n<pre><code>auto&amp; buffer = dynamic_cast&lt;Derived&amp;&gt;(obj);\n</code></pre>\n<p>Now, <code>P</code> is <code>U&amp;</code>:</p>\n<pre><code>template &lt;typename U&gt;\nvoid f(U&amp;);\n</code></pre>\n<p><code>U</code> is, of course, still deduced as <code>Derived</code>, but the type of <code>P</code> - which is effectively the type of <code>buffer</code> - is <code>Derived&amp;</code>.</p>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2015-07-25T16:36:28.067", "Score": "5", "CreationDate": "2015-07-25T16:09:28.123", "ParentId": "31628366", "CommentCount": "4", "OwnerUserId": "3647361", "LastEditDate": "2015-07-25T16:36:28.067"}, "31628451": {"Id": "31628451", "PostTypeId": "2", "Body": "<p>You're getting <code>Derived</code> from <code>auto</code>. Use this instead:</p>\n<pre><code>auto &amp; buffer = dynamic_cast&lt;Derived&amp;&gt;(obj);\n</code></pre>\n", "LastActivityDate": "2015-07-25T16:07:55.520", "CommentCount": "0", "CreationDate": "2015-07-25T16:07:55.520", "ParentId": "31628366", "Score": "6", "OwnerUserId": "47453"}});