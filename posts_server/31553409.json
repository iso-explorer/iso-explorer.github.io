post_cb({"bq_ids": {"n4140": {"so_31553409_31557914_0": {"length": 33, "quality": 0.6, "section_id": 5878}, "so_31553409_31557852_0": {"length": 33, "quality": 0.7021276595744681, "section_id": 5878}, "so_31553409_31557852_1": {"length": 34, "quality": 0.85, "section_id": 5878}}, "n3337": {"so_31553409_31557914_0": {"length": 33, "quality": 0.6, "section_id": 5649}, "so_31553409_31557852_0": {"length": 33, "quality": 0.7021276595744681, "section_id": 5649}, "so_31553409_31557852_1": {"length": 34, "quality": 0.85, "section_id": 5649}}}, "31557852": {"Id": "31557852", "PostTypeId": "2", "Body": "<p>This is fine, because the members you are accessing are elements of a <em>common initial sequence</em>.</p>\n<p>C11 (<strong>6.5.2.3 Structure and union members</strong>; <strong>Semantics</strong>):</p>\n<blockquote>\n<p id=\"so_31553409_31557852_0\">[...] if a union contains several structures that share a common initial sequence (see below), and if the union object currently contains one of these structures, it is permitted to inspect the common initial part of any of them anywhere that a declaration of the completed type of the union is visible. Two structures share a <em>common initial sequence</em> if corresponding members have compatible types (and, for bit-fields, the same widths) for a sequence of one or more initial members.</p>\n</blockquote>\n<p>C++03 (<strong>[class.mem]/16</strong>):</p>\n<blockquote>\n<p id=\"so_31553409_31557852_1\">If a POD-union contains two or more POD-structs that share a common initial sequence, and if the POD-union object currently contains one of these POD-structs, it is permitted to inspect the common initial part of any of them. Two POD-structs share a common initial sequence if corresponding members have layout-compatible types (and, for bit-fields, the same widths) for a sequence of one or more initial members.</p>\n</blockquote>\n<p>Other versions of the two standards have similar language; since C++11 the terminology used is <em>standard-layout</em> rather than <em>POD</em>. </p>\n<hr>\n<p>I think the confusion may have arisen because C permits <em>type-punning</em> (aliasing a member of a different type) via a union where C++ does not; this is the main case where to ensure C/C++ compatibility you would have to use <code>memcpy</code>. But in your case the elements you are accessing have the <em>same</em> type and are preceded by members of compatible types, so the type-punning rule is not relevant.</p>\n</hr>", "LastEditorUserId": "567292", "LastActivityDate": "2015-07-22T08:34:58.180", "CommentCount": "42", "CreationDate": "2015-07-22T08:29:13.193", "ParentId": "31553409", "Score": "11", "OwnerUserId": "567292", "LastEditDate": "2015-07-22T08:34:58.180"}, "31553409": {"ViewCount": "512", "Body": "<p>I have an API with a publicly facing struct A and an internal struct B and need to be able to convert a struct B into a struct A. Is the following code legal <strong>and well defined behavior</strong> in C99 (and VS 2010/C89) and C++03/C++11? If it is, please explain what makes it well-defined. If it's not, what is the most efficient and cross-platform means for converting between the two structs?</p>\n<pre><code>struct A {\n  uint32_t x;\n  uint32_t y;\n  uint32_t z;\n};\n\nstruct B {\n  uint32_t x;\n  uint32_t y;\n  uint32_t z;\n  uint64_t c;\n};\n\nunion U {\n  struct A a;\n  struct B b;\n};\n\nint main(int argc, char* argv[]) {\n  U u;\n  u.b.x = 1;\n  u.b.y = 2;\n  u.b.z = 3;\n  u.b.c = 64;\n\n  /* Is it legal and well defined behavior when accessing the non-write member of a union in this case? */\n  DoSomething(u.a.x, u.a.y, u.a.z);\n\n  return 0;\n}\n</code></pre>\n<p><br>\n<strong>UPDATE</strong></br></p>\n<p>I simplified the example and wrote two different applications. One based on memcpy and the other using a union.</p>\n<p><br>\n<em>Union:</em></br></p>\n<pre><code>struct A {\n  int x;\n  int y;\n  int z;\n};\n\nstruct B {\n  int x;\n  int y;\n  int z;\n  long c;\n};\n\nunion U {\n  struct A a;\n  struct B b;\n};\n\nint main(int argc, char* argv[]) {\n  U u;\n  u.b.x = 1;\n  u.b.y = 2;\n  u.b.z = 3;\n  u.b.c = 64;\n  const A* a = &amp;u.a;\n  return 0;\n}\n</code></pre>\n<p><br>\n<em>memcpy:</em></br></p>\n<pre><code>#include &lt;string.h&gt;\n\nstruct A {\n  int x;\n  int y;\n  int z;\n};\n\nstruct B {\n  int x;\n  int y;\n  int z;\n  long c;\n};\n\nint main(int argc, char* argv[]) {\n  B b;\n  b.x = 1;\n  b.y = 2;\n  b.z = 3;\n  b.c = 64;\n  A a;\n  memcpy(&amp;a, &amp;b, sizeof(a));\n  return 0;\n}\n</code></pre>\n<p><br><br>\n<em>Profiled Assembly [DEBUG] (Xcode 6.4, default C++ compiler):</em></br></br></p>\n<p>Here is the relevant difference in the assembly for debug mode. When I profiled the release builds there was no difference in the assembly.</p>\n<p><br>\nUnion:</br></p>\n<pre><code>movq     %rcx, -48(%rbp)\n</code></pre>\n<p><br>\nmemcpy:</br></p>\n<pre><code>movq    -40(%rbp), %rsi\nmovq    %rsi, -56(%rbp)\nmovl    -32(%rbp), %edi\nmovl    %edi, -48(%rbp)\n</code></pre>\n<p><br><br>\n<em>Caveat:</em></br></br></p>\n<p>The example code based on union produces a warning regarding variable 'a' being unused. As the profiled assembly is from debug, I don't know if there is any impact.</p>\n", "AcceptedAnswerId": "31557852", "Title": "Is it legal and well defined behavior to use a union for conversion between two structs with a common initial sequence (see example)?", "CreationDate": "2015-07-22T03:36:31.740", "Id": "31553409", "CommentCount": "27", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2015-07-22T09:20:41.307", "LastEditorUserId": "3638462", "LastActivityDate": "2017-03-10T15:53:45.223", "Score": "15", "OwnerUserId": "3638462", "Tags": "<c++><c><c99><unions><c89>", "AnswerCount": "2"}, "31557914": {"Id": "31557914", "PostTypeId": "2", "Body": "<p>It is legal in both C and C++</p>\n<p>For example, in C99 (6.5.2.3/5) and C11 (6.5.2.3/6):</p>\n<blockquote>\n<p id=\"so_31553409_31557914_0\">One special guarantee is made in order to simplify the use of unions: if a union contains\n  several structures that share a common initial sequence (see below), and if the union\n  object currently contains one of these structures, it is permitted to inspect the common\n  initial part of any of them anywhere that a declaration of the complete type of the union is\n  visible. Two structures share a common initial sequence if corresponding members have\n  compatible types (and, for bit-fields, the same widths) for a sequence of one or more\n  initial members.</p>\n</blockquote>\n<p>Similar provisions exists in C++11 and C++14 (different wording, same meaning).</p>\n", "LastEditorUserId": "1235165", "LastActivityDate": "2017-03-10T15:53:45.223", "CommentCount": "2", "CreationDate": "2015-07-22T08:31:55.360", "ParentId": "31553409", "Score": "5", "OwnerUserId": "775806", "LastEditDate": "2017-03-10T15:53:45.223"}});