post_cb({"3049822": {"Id": "3049822", "PostTypeId": "2", "Body": "<p>You need to define a pure virtual version of the Interface destructor, but you need to also define the body of the destructor.  This is a sort of weird case in C++ where even though the function is virtual it must be defined because after the A destructor is called, the Instance destructor will also be called.</p>\n<p>Thus the correct answer is:</p>\n<pre><code>virtual ~Interface() = 0;\n</code></pre>\n<p>And later, in a cpp file:</p>\n<pre><code>Interface::~Interface() {}\n</code></pre>\n", "LastActivityDate": "2010-06-15T23:34:23.737", "CommentCount": "1", "CreationDate": "2010-06-15T23:34:23.737", "ParentId": "3049806", "Score": "2", "OwnerUserId": "36384"}, "bq_ids": {"n4140": {"so_3049806_3049820_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 6107}}, "n3337": {"so_3049806_3049820_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 5873}}, "n4659": {"so_3049806_3049820_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 7604}}}, "3049820": {"Id": "3049820", "PostTypeId": "2", "Body": "<p>You must define a virtual destructor in the base class, otherwise you'll get no polymorphic behavior.</p>\n<p>And more importantly, you get undefined behavior otherwise; \u00a75.3.5/3:</p>\n<blockquote>\n<p id=\"so_3049806_3049820_0\">If the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand\u2019s dynamic type and <em>the static type shall have a virtual destructor or the behavior is undefined</em>.</p>\n</blockquote>\n<p><sub>Emphasis mine.</sub></p>\n<hr>\n<p>I'd argue the best is this one:</p>\n<pre><code>class Interface\n{\npublic:\n    virtual ~Interface(void) = 0;\n};\n\ninline Interface::~Interface(void) {}\n</code></pre>\n<p>The compiler can easily inline this, unlike a solution where the implementation resides in a source file. (Speaking of which, this solution doesn't even mandate you have one.) It also leaves the class pure virtual.</p>\n</hr>", "LastEditorUserId": "87234", "LastActivityDate": "2010-06-16T05:41:34.537", "Score": "5", "CreationDate": "2010-06-15T23:34:10.663", "ParentId": "3049806", "CommentCount": "3", "OwnerUserId": "87234", "LastEditDate": "2010-06-16T05:41:34.537"}, "3049815": {"Id": "3049815", "PostTypeId": "2", "Body": "<p>You must declare the destructor <code>virtual</code> if you want to delete derived-class objects via a pointer to your base class interface type, and that destructor must have an implementation.</p>\n<p>You may still declare it pure virtual, though:</p>\n<pre><code>class Interface\n{\npublic:\n    virtual ~Interface() = 0;\n};\n\ninline Interface::~Interface() { }\n</code></pre>\n", "LastEditorUserId": "151292", "LastActivityDate": "2010-06-15T23:37:49.570", "Score": "2", "CreationDate": "2010-06-15T23:32:26.490", "ParentId": "3049806", "CommentCount": "7", "OwnerUserId": "151292", "LastEditDate": "2010-06-15T23:37:49.570"}, "3049806": {"ViewCount": "880", "Body": "<p>I have a question about the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;boost/scoped_ptr.hpp&gt;\n\nclass Interface\n{\n};\n\nclass A : public Interface\n{\n    public:\n        A() { std::cout &lt;&lt; \"A()\" &lt;&lt; std::endl; }\n        virtual ~A() { std::cout &lt;&lt; \"~A()\" &lt;&lt; std::endl; }\n};\n\n\nInterface* get_a()\n{\n    A* a = new A;\n    return a;\n}\n\nint main()\n{\n    {\n        std::cout &lt;&lt; \"1\" &lt;&lt; std::endl;\n        boost::scoped_ptr&lt;Interface&gt; x(get_a());\n        std::cout &lt;&lt; \"2\" &lt;&lt; std::endl;\n    }\n    std::cout &lt;&lt; \"3\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>It creates the following output:</p>\n<pre><code>1\nA()\n2\n3\n</code></pre>\n<p>As you can see, it doesn't call the destructor of A.\nThe only way I see to get the destructor of A being called, is to add a destructor for the Interface class like this:</p>\n<pre><code>virtual ~Interface() { }\n</code></pre>\n<p>But I really want to avoid any Implementation in my Interface class and <code>virtual ~Interface() = 0;</code> doesn't work (produces some linker errors complaining about a non existing implementation of <code>~Interface()</code>.</p>\n<p>So my question is: What do I have to change in order to make the destructor being called, but (if possible) leave the Interface as an Interface (only abstract methods).</p>\n", "AcceptedAnswerId": "3049820", "Title": "C++ destructor problem with boost::scoped_ptr", "CreationDate": "2010-06-15T23:29:07.073", "Id": "3049806", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2010-06-15T23:47:52.777", "LastEditorUserId": "151292", "LastActivityDate": "2010-06-16T05:41:34.537", "Score": "2", "OwnerUserId": "367777", "Tags": "<c++><abstract-class><destructor><virtual-functions>", "AnswerCount": "3"}});