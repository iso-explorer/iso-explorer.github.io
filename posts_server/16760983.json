post_cb({"16761002": {"ParentId": "16760983", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>Your program has undefined behavior because it violates the One Definition Rule. Two different translation units are defining a function with same name and signature, but with different bodies.</p>\n<p>Per paragraph 3.2/6 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16760983_16761002_0\">[...] Given\n  such an entity named <code>D</code> <strong>defined in more than one translation unit</strong>, then</p>\n<p id=\"so_16760983_16761002_1\">\u2014 each definition of <code>D</code> shall consist of the same sequence of tokens; and</p>\n<p id=\"so_16760983_16761002_2\">[...]</p>\n</blockquote>\n<p>Your program is also ill-formed because function <code>c()</code> is declared as <code>inline</code> in <code>test1.cpp</code> and <code>test2.cpp</code>, but not in <code>driver.cpp</code>. Per paragraph 7.1.2/4</p>\n<blockquote>\n<p id=\"so_16760983_16761002_3\">[...] If a function with external linkage is\n  declared <code>inline</code> in one translation unit, it shall be declared <code>inline</code> in all translation units in which it appears;\n  no diagnostic is required. [...]</p>\n</blockquote>\n<p>The \"<em>no diagnostic is required</em>\" bit means that the compiler (or linker) may or may not report an error for a violation of this rule. That means you have to be very careful to break it.</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-05-26T17:44:17.853", "Id": "16761002", "Score": "3", "CreationDate": "2013-05-26T15:57:20.417", "LastActivityDate": "2013-05-26T17:44:17.853"}, "16760983": {"CommentCount": "1", "ViewCount": "97", "CreationDate": "2013-05-26T15:55:43.423", "LastActivityDate": "2013-05-26T17:44:17.853", "Title": "unspecified ouput using inline function in c++", "AcceptedAnswerId": "16761002", "PostTypeId": "1", "Id": "16760983", "Score": "1", "Body": "<p>I was playing with code to understand internal and external linkage in c++.I came up with the code whose out seems to vary depending on the sequence in which it is linked.</p>\n<p><br><strong>test1.cpp</strong> <br/></br></p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\ninline int c()\n{\n     static int p=0;\n     p++;\n     return p;\n}\nvoid a()\n{\n     cout&lt;&lt;\"\\nIn function a() , c = \"&lt;&lt;c();\n}\n</code></pre>\n<p><br><strong>test2.cpp</strong><br/></br></p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\ninline int c()\n{\n    static int p=12;\n    p++;\n    return p;\n}\n\nvoid b()\n{\n       cout&lt;&lt;\"\\nIn function b() , c = \"&lt;&lt;c();\n} \n</code></pre>\n<p><br><strong>driver.cpp</strong><br/></br></p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nvoid a();\nvoid b();\nint c();\n\nint main()\n{\n   b();\n   a();\n   a();\n   b();\n   cout&lt;&lt;\"\\nIn function main() = , c \"&lt;&lt; c();\n   cout&lt;&lt;\"\\n\";\n}\n</code></pre>\n<p><strong>output 1 :-</strong> </p>\n<pre><code>when compiles as follows :- \n\nbash#&gt;g++ -c test1.cpp\nbash#&gt;g++ -c test2.cpp\nbash#&gt;g++ -c driver.cpp\n\nbash#&gt;g++ -o out driver.o test1.o test2.o\nbash#&gt;./out\n\nIn function b() , c = 1\nIn function a() ,  c = 2\nIn function a() ,  c = 3\nIn function b() , c = 4\nIN main() , c = 5\n</code></pre>\n<p>In above output , compiler is considering c() defined in test1.cpp</p>\n<p><strong>output 2:-</strong>\nchanging sequence of test1.o and test2.o while linking.</p>\n<pre><code>bash#&gt;g++ -o out driver.o test2.o test1.o\n\nIn function b() , c = 13\nIn function a() ,  c = 14\nIn function a() ,  c = 15 \nIn function b() , c = 16\nIN main() , c = 17\n</code></pre>\n<p>In above output , compiler is considering c() defined in test2.cpp</p>\n<p>I was perplexed when i made minor changes in the code , which are as follows :-\n<br>1) if I do not call c() in function a() [test1.cpp] and c() in funciton b()[test2.cpp]<br/></br></p>\n<pre><code>//test1.cpp changes\nvoid a()\n{\n   cout&lt;&lt;\"\\nIn function a() , c = \"; // not calling c()\n}\n\n//test2.cpp changes\nvoid b()\n{\n    cout&lt;&lt;\"\\nIn function b() , c = \"; // not calling c()\n} \n</code></pre>\n<p>I get following error while linking :-</p>\n<pre><code>bash#&gt;g++ -o out driver.o test1.o test2.o\ndriver.o: In function `main':\ndriver.cpp:(.text+0x1f): undefined reference to `c()'\ncollect2: ld returned 1 exit status\n</code></pre>\n<p>2) If i call c() in any one of the file i.e either in test1.cpp or in test2.cpp , then i wont get linker error.</p>\n<p>Could anyone please help me in understanding this behaviour.</p>\n<p>Thanks in advance.</p>\n", "Tags": "<c++><c++11><linker><inline><unspecified-behavior>", "OwnerUserId": "1057741", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_16760983_16761002_3": {"section_id": 5404, "quality": 1.0, "length": 16}, "so_16760983_16761002_1": {"section_id": 7043, "quality": 1.0, "length": 6}, "so_16760983_16761002_0": {"section_id": 7043, "quality": 1.0, "length": 11}}, "n3337": {"so_16760983_16761002_3": {"section_id": 5199, "quality": 1.0, "length": 16}, "so_16760983_16761002_1": {"section_id": 6788, "quality": 1.0, "length": 6}, "so_16760983_16761002_0": {"section_id": 6788, "quality": 1.0, "length": 11}}, "n4659": {"so_16760983_16761002_3": {"section_id": 6853, "quality": 1.0, "length": 16}, "so_16760983_16761002_1": {"section_id": 8540, "quality": 1.0, "length": 6}, "so_16760983_16761002_0": {"section_id": 8540, "quality": 1.0, "length": 11}}}});