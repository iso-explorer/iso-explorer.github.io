post_cb({"bq_ids": {"n4140": {"so_11871299_11871465_0": {"length": 11, "quality": 1.0, "section_id": 7223}}, "n3337": {"so_11871299_11871465_0": {"length": 11, "quality": 1.0, "section_id": 6967}}, "n4659": {"so_11871299_11871465_0": {"length": 11, "quality": 1.0, "section_id": 8732}}}, "11871465": {"Id": "11871465", "PostTypeId": "2", "Body": "<p>If you want to go this route, I believe you want something like this:</p>\n<p><strong>Edit:</strong> Based on James Kanze's answer, add a separate <code>activate</code> method to launch the thread after construction is finished.</p>\n<pre><code>class GenericThread {\nprotected:\n    GenericThread () {\n      //...\n    }\n    virtual ~GenericThread () {}\n\n    int activate () {\n        return pthread_create(..., GenericThreadEntry, this);\n    }\n\n    virtual void * thread_routine () = 0;\n\n    #if 0\n    // This code is wrong, because the C routine callback will do so using the\n    // C ABI, but there is no guarantee that the C++ ABI for static class methods\n    // is the same as the C ABI.\n    static void * thread_entry (void *arg) {\n        GenericThread *t = static_cast&lt;GenericThread *&gt;(arg);\n        return t-&gt;thread_routine();\n    }\n    #endif\n};\n\nextern \"C\" void * GenericThreadEntry (void *) {\n    GenericThread *t = static_cast&lt;GenericThread *&gt;(arg);\n    return t-&gt;thread_routine();\n}\n</code></pre>\n<p>Then, <code>ProducerThread</code> would derive from <code>GenericThread</code>.</p>\n<p><strong>Edit:</strong> <s>Searching for <code>extern \"C\"</code> in the C++ Standard. revealed no requirement that a function pointer must point to a function with C linkage to be callable by a C library routine. Since pointers are being passed, linkage requirements do not apply, as linkage is used to resolve names. A pointer to a static method is a function pointer, according to C++ 2011 draft (n3242), Sec. 3.9.2p3: </s></p>\n<blockquote>\n<p id=\"so_11871299_11871465_0\">Except for pointers to static members, text referring to pointers does not apply to pointers to members.</p></blockquote>\n<p><strong>Edit:</strong> <em>Mea culpa.</em> The C library will invoke the callback function assuming the C application binary interface. A function with C++ linkage may use a different ABI than the C ABI. This is why it is required to use a function with <code>extern \"C\"</code> linkage when passing to a callback function to a C library. My sincere apologies to James Kanze for doubting him, and my sincere thanks to Loki Astari for setting me straignt.</p>\n", "LastEditorUserId": "315052", "LastActivityDate": "2012-08-08T21:59:39.563", "Score": "3", "CreationDate": "2012-08-08T19:09:15.587", "ParentId": "11871299", "CommentCount": "3", "OwnerUserId": "315052", "LastEditDate": "2012-08-08T21:59:39.563"}, "11871598": {"Id": "11871598", "PostTypeId": "2", "Body": "<p>There are a number of problems with your code.  For starters, I don't\nsee where the <code>arg</code> you are casting is declared, so I can't say whether\nthe case is appropriate.</p>\n<p>Perhaps more importantly, <code>thread_routine</code> is a member function, so it\ncan't be converted to a pointer to a function.  The function passed to\n<code>pthread_create</code> must be <code>extern \"C\"</code>, so it cannot be a member, period; \nit must be a free function declare <code>extern \"C\"</code>.  If you want to call a\nmember function, pass a pointer to the object as the last argument, and\ndereference it in the <code>extern \"C\"</code> function:</p>\n<pre><code>extern \"C\" void* startProducerThread( void* arg )\n{\n    return static_cast&lt;ProducerThread*&gt;( arg )-&gt;thread_routine();\n}\n</code></pre>\n<p>And to start the thread:</p>\n<pre><code>int status = pthread_create( &amp;thread, &amp;thread_attr, startProducerThread, this );\n</code></pre>\n<p>Just don't do this in a constructor.  The other thread might start\nrunning before the object is fully constructed, with disasterous\neffects.</p>\n<p>Also, be very sure that the cast in <code>startProducerThread</code> is to\n<em>exactly</em> the same type as the pointer passed into <code>pthread_create</code>.  If\nyou cast to a base class in <code>startProducerThread</code>, then be very, very\nsure that it is a pointer to that base class that you pass to\n<code>pthread_create</code>; use an explicit cast if necessary (to the type in\n<code>startProducerThread</code>, <em>not</em> to <code>void*</code>).</p>\n<p>Finally, while not relevant to your actual question: if\n<code>ProtectedBuffer</code> has an interface like that of <code>std::vector</code>, and\nreturns references to internal data, there's no way you can make it\nthread safe.  The protection needs to be external to the class.</p>\n", "LastActivityDate": "2012-08-08T19:17:33.783", "CommentCount": "3", "CreationDate": "2012-08-08T19:17:33.783", "ParentId": "11871299", "Score": "4", "OwnerUserId": "649665"}, "11871299": {"ViewCount": "3097", "Body": "<p>I'm a little confused about how to pass an object to the pthread_create function. I've found a lot of piecemeal information concerning casting to void*, passing arguments to pthread_create, etc., but nothing that ties it all together. I just want to make sure I've tied it all together and am not doing anything stupid. Let's say I have the following thread class:\n<strong>Edit:</strong> fixed mis-matched <code>static_cast</code>.</p>\n<pre><code>class ProducerThread {\n    pthread_t thread;\n    pthread_attr_t thread_attr;\n    ProducerThread(const ProducerThread&amp; x);\n    ProducerThread&amp; operator= (const ProducerThread&amp; x);\n    virtual void *thread_routine(void *arg) {\n        ProtectedBuffer&lt;int&gt; *buffer = static_cast&lt;ProtectedBuffer&lt;int&gt; *&gt; arg;\n        int randomdata;\n\n        while(1) {\n            randomdata = RandomDataGen();\n            buffer-&gt;push_back(randomdata);\n        }\n\n        pthread_exit();\n    }\npublic:\n    ProtectedBuffer&lt;int&gt; buffer;\n\n    ProducerThread() {\n        int err_chk;\n\n        pthread_attr_init(&amp;thread_attr);\n        pthread_attr_setdetachstate(&amp;thread_attr,PTHREAD_CREATE_DETACHED);\n\n        err_chk = pthread_create(&amp;thread, &amp;thread_attr, thread_routine, static_cast&lt;void *&gt; arg);\n        if (err_chk != 0) {\n            throw ThreadException(err_chk);\n        }\n    }\n    ~ProducerThread() {\n        pthread_cancel(&amp;thread);\n        pthread_attr_destroy(&amp;thread_attr);\n    }\n}\n</code></pre>\n<p>To clarify, the data in the <code>ProtectedBuffer</code> class can only be accessed with methods like <code>ProtectedBuffer::push_back(int arg)</code>, which use mutexes to protect the actual data. </p>\n<p>My main question is: am I using <code>static_cast</code> correctly? And my secondary question is do I need that first line in <code>virtual void *thread_routine(void *arg)</code> where I copy the passed void pointer to a pointer to <code>ProtectedBuffer</code>?</p>\n<p>Also, if I've done anything else that might cause problems, I'd appreciate hearing it.</p>\n", "AcceptedAnswerId": "11871465", "Title": "casting to void* to pass objects to pthread in c++", "CreationDate": "2012-08-08T18:58:17.607", "Id": "11871299", "CommentCount": "7", "LastEditDate": "2012-08-08T19:47:17.073", "PostTypeId": "1", "LastEditorUserId": "1549983", "LastActivityDate": "2012-08-08T21:59:39.563", "Score": "4", "OwnerUserId": "1549983", "Tags": "<c++><pointers><pthreads><static-cast>", "AnswerCount": "2"}});