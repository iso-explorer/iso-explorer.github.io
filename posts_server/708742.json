post_cb({"708945": {"CommentCount": "5", "CreationDate": "2009-04-02T09:17:38.363", "LastEditorUserId": "72000", "LastActivityDate": "2009-04-05T17:16:34.607", "ParentId": "708742", "PostTypeId": "2", "LastEditorDisplayName": "bb", "LastEditDate": "2009-04-05T17:16:34.607", "Id": "708945", "Score": "5", "Body": "<p>Qute from standard:</p>\n<blockquote>\n<p id=\"so_708742_708945_0\">25.2.3  Transform                                  [lib.alg.transform]<br>\n   Requires:<br>\n      op and binary_op shall not have any side effects.</br></br></p>\n</blockquote>\n<p><a href=\"http://en.wikipedia.org/wiki/Side_effect_(computer_science)\" rel=\"nofollow noreferrer\">Side Effect ( wikipedia definition )</a> </p>\n<p>In your case we have next side effect:  </p>\n<pre><code>Converter c( data );  \nc( some_const_value ) != c( some_const_value );\n</code></pre>\n<p>You don't have any guarantees for your algorithms, but I belive that it will works on almost all stl implementations.</p>\n<p><strong>Suggested solution</strong><br>\nIt seems I know one way to do what you need:<br>\n    use boost::counting_iterator - for iterate over two containers;  </br></br></p>\n<p>it will looks like:  </p>\n<pre><code>bool bit_enabled( size_t data, unsigned char number )\n{\n    return ( data &amp; 1 &lt;&lt; number ) != 0;\n}\n\nstd::string select_word( \n                const std::string&amp; word,\n                size_t data, \n                size_t number )\n{\n    return bit_enabled( data, number ) ? word : std::string( ' ', word.length() );\n}\n\nconst size_t data = 7;\nconst boost::array&lt; std::string, 3 &gt; vocabulary = { \"a\", \"b\", \"c\" };\nstd::vector&lt; std::string &gt; result;\nstd::transform(\n    vocabulary.begin(),\n    vocabulary.end(),\n    boost::counting_iterator&lt; size_t &gt;(0),\n    back_inserter( result ),\n    boost::bind( &amp;select_word, _1, data, _2 )\n);\n</code></pre>\n<p>Also maybe if you will define bit iterator or will use some bit container you will can use boost::zip_iterator for iterate both containers.</p>\n<p><strong>EDIT:</strong><br>\nYestarday I found <a href=\"http://www.ddj.com/cpp/184403769\" rel=\"nofollow noreferrer\">interest article</a> which contain definition of Side Effect by standard.</br></p>\n<blockquote>\n<p id=\"so_708742_708945_1\">The Standard defines a side effect as\n  follows: Accessing an object\n  designated by a volatile lvalue,\n  modifying an object, calling a library\n  I/O function, or calling a function\n  that does any of those operations are\n  all side effects, which are changes in\n  the state of the execution\n  environment.</p>\n</blockquote>\n<p><strong>EDIT:</strong><br>\nI hope it will be latest edit.<br>\nI am always tought that \"no have side effect\" mean:<br>\nf(a) should be equal f(a) always. ( f independed from execution environment: memory/cpu/global variables/member variables as in your case etc).<br>\n\"Not produce side effect\" mean - don't changing execution environment.</br></br></br></br></p>\n<p>But in c++ standard we have more low-level defintion for Side effect.  </p>\n<p>Thing what you do in your example named as <strong>Stateful</strong> functor.<br>\nStandard doesn't say about \"Statefull\" functors, but also doesn't say about count of copies of your functor - you couldn't use this trick because it is unspecified behavior.</br></p>\n<p>See Standard Library Issues list ( similar issue for predicat ):<br>\n<a href=\"http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/lwg-active.html#92\" rel=\"nofollow noreferrer\">http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/lwg-active.html#92</a></br></p>\n", "OwnerUserId": "72000", "OwnerDisplayName": "bb"}, "708974": {"CommentCount": "0", "CreationDate": "2009-04-02T09:27:05.533", "LastEditorUserId": "31140", "LastActivityDate": "2009-04-02T09:32:59.183", "ParentId": "708742", "PostTypeId": "2", "LastEditorDisplayName": "tragomaskhalos", "LastEditDate": "2009-04-02T09:32:59.200", "Id": "708974", "Score": "0", "Body": "<p>I believe there are some instances where the answer is yes, but there are also definite cases where it's no. Without being able to recall which (sorry), and to make the code less brittle, I would not rely on it and keep i outside the functor to be safe.\nie inside <code>Converter</code> do:<br/><br/>\n<code>\nConverter( std::size_t value, std::size_t&amp; i ): value_( value ), i_ ( i ) {}\n</code>\n<br/>and<br/>\n<code>std::size_t &amp;i_;</code>\n<br/><br/> then invoke with<br/><br/>\n<code>std::vector v;</code><br/>\n<code>std::size_t i(0);</code><br/>\n<code>// initialization of v  </code><br/>\n<code>std::transform( v.begin(), v.end(),\n                std::back_inserter( result ), Converter( data, i ) );</code></p>\n<p>Messy, but safer.</p>\n", "OwnerUserId": "31140", "OwnerDisplayName": "tragomaskhalos"}, "712065": {"ParentId": "708742", "CommentCount": "1", "Body": "<p>As an example of a case where side-effects would be a definite <em>bad thing</em>, consider a hypothetical parallel STL implementation which split the work between several CPUs.</p>\n<p>I believe this was in the minds of the authors of STL.  The original STL was from SGI, one of the larger names in building massively parallel single-image and cluster systems.</p>\n", "OwnerUserId": "13422", "Id": "712065", "PostTypeId": "2", "OwnerDisplayName": "Zan Lynx", "Score": "0", "CreationDate": "2009-04-02T23:45:02.810", "LastActivityDate": "2009-04-02T23:45:02.810"}, "708944": {"CommentCount": "6", "CreationDate": "2009-04-02T09:17:29.563", "LastEditorUserId": "-1", "LastActivityDate": "2009-04-03T13:08:18.013", "ParentId": "708742", "PostTypeId": "2", "LastEditorDisplayName": "Richard Corden", "LastEditDate": "2017-05-23T12:01:24.217", "Id": "708944", "Score": "2", "Body": "<p>I've just checked the standard and if I understand it correctly the answer is no.  The description of 'transform' has the following additional requirement (25.2.3):</p>\n<blockquote>\n<p id=\"so_708742_708944_0\"><strong>Requires</strong>: op and binary_op shall not have any side effects.</p>\n</blockquote>\n<p>Reaching back into the depths of my memory, I remember a talk given <a href=\"http://www.josuttis.com/\" rel=\"nofollow noreferrer\">Nicolai Josuttis</a> at an <a href=\"http://accu.org/\" rel=\"nofollow noreferrer\">ACCU</a> conference, where he showed that for a particular type of container and STL implementation, the function object was copied. <a href=\"https://stackoverflow.com/users/59781/201ric-malenfant\">\u00c9ric</a> provided <a href=\"http://www.ddj.com/cpp/184403769\" rel=\"nofollow noreferrer\">this</a> link to a Dr. Dobb's article that discusses the differences in more detail.</p>\n<p><strong>EDIT:</strong>  Alternative solution:</p>\n<p>The <em>for_each</em> algorithm does not have this restriction, so you could change your Converter object to take a reference to the result vector and do the push_back inside the Converter function.</p>\n<pre><code>struct Converter\n{\n  Converter( std::size_t value, std::vector&lt;std::string&gt; &amp; result ):\n      value_( value ), i_( 0 ), result_(result)\n  {}\n  void operator() ( const std::string&amp; word )\n  {\n    result_.push_back ( value_ &amp; ( 1 &lt;&lt; i_++ ) ) ?\n             word:\n             std::string( word.size(), ' ' );\n  }\n  std::size_t value_;\n  std::size_t i_;\n  std::vector&lt;std::string&gt; &amp; result_;\n};\n</code></pre>\n<p>And use <em>for_each</em> rather than <em>transform</em>:</p>\n<pre><code>std::vector v;\n// initialization of v  \nstd::for_each ( v.begin()\n              , v.end(),\n              Converter( data, result ) );\n</code></pre>\n", "OwnerUserId": "11698", "OwnerDisplayName": "Richard Corden"}, "708753": {"ParentId": "708742", "CommentCount": "1", "Body": "<p>Yes and no. This is because you feed iterators to your <code>Converter</code> object. For a sequence container like <code>vector</code> you get <code>i</code> to correspond to the order of the elements. However, for associative containers like <code>map/multimap/set/multiset</code> this may not be (will most probably not be) valid. </p>\n", "OwnerUserId": "66692", "Id": "708753", "PostTypeId": "2", "OwnerDisplayName": "dirkgently", "Score": "0", "CreationDate": "2009-04-02T08:00:46.473", "LastActivityDate": "2009-04-02T08:00:46.473"}, "708742": {"CommentCount": "1", "AcceptedAnswerId": "708945", "PostTypeId": "1", "LastEditorUserId": "54684", "LastEditorDisplayName": "Mykola Golubyev", "CreationDate": "2009-04-02T07:55:10.573", "LastActivityDate": "2009-04-05T17:16:34.607", "AnswerCount": "5", "LastEditDate": "2009-04-02T10:04:30.467", "ViewCount": "2482", "FavoriteCount": "6", "Title": "C++ std::transform side effect", "Id": "708742", "Score": "3", "Body": "<p>I've implementation of UnaryOperation like this</p>\n<pre><code>struct Converter\n{\n    Converter( std::size_t value ):\n        value_( value ), i_( 0 )\n    {}\n    std::string operator() ( const std::string&amp; word )\n    {\n        return ( value_ &amp; ( 1 &lt;&lt; i_++ ) ) ?\n            word:\n            std::string( word.size(), ' ' );\n    }\n    std::size_t value_;\n    std::size_t i_;\n};\n</code></pre>\n<p>And I use it like</p>\n<pre><code>std::vector v;\n// initialization of v  \nstd::transform( v.begin(), v.end(),\n                std::back_inserter( result ),\n                Converter( data ) );\n</code></pre>\n<p>My <strong>question</strong> is can I rely on my assumption that algorithm will call my 'Converter operator ()' in the order that 'Converter::i_' will correspond to number of element in 'v'.</p>\n<p>Please quote the standard in case I can't rely on the order or put the stl-like solution that avoid possible problem if any.</p>\n<p>Thanks.</p>\n<p><strong>Edit:<br/></strong></p>\n<p>I am aware of \"no Side effect\" requirements in the standard for the transform algorithm. I can't find what is exactly \"side effect\" for functors in the same standard.</p>\n<p>Maybe there is some good-looking-boost-like solution for this task?</p>\n", "Tags": "<c++><stl>", "OwnerUserId": "54684", "OwnerDisplayName": "Mykola Golubyev"}, "bq_ids": {"n4140": {"so_708742_708945_1": {"section_id": 5808, "quality": 0.7142857142857143, "length": 20}}, "n3337": {"so_708742_708945_1": {"section_id": 5581, "quality": 0.7142857142857143, "length": 20}}, "n4659": {"so_708742_708945_1": {"section_id": 7269, "quality": 0.6785714285714286, "length": 19}}}});