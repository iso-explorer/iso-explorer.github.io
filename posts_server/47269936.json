post_cb({"47269937": {"ParentId": "47269936", "CommentCount": "4", "CreationDate": "2017-11-13T17:16:20.907", "OwnerUserId": "2001017", "PostTypeId": "2", "Id": "47269937", "Score": "8", "Body": "<p>My interpretation is that <strong>clang++ is right</strong> and <strong>g++ is too permissive</strong>. </p>\n<p>We can find a close example ([expr.const] section, page 126) in the standard <a href=\"https://isocpp.org/std/the-standard\" rel=\"noreferrer\">https://isocpp.org/std/the-standard</a> (draft can be downloaded, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4700.pdf\" rel=\"noreferrer\">attention big PDF!</a> ). </p>\n<pre><code>constexpr int g(int k) { \n    constexpr int x = incr(k); \n\n    return x; \n}\n</code></pre>\n<p>where it is explained that:</p>\n<blockquote>\n<p id=\"so_47269936_47269937_0\">error: incr(k) is not a core constant expression because \n  lifetime of k began outside the expression incr(k)</p>\n</blockquote>\n<p>This is exactly what is happening in the <code>use_size()</code> function with the <code>foo</code> argument, even if the <code>size()</code> function <strong>only</strong> use the <code>N</code> template parameter.</p>\n<pre><code>template &lt;int N&gt;\nconstexpr int size(const Foo&lt;N&gt;&amp;) { return N; }\n\ntemplate &lt;int N&gt;\nvoid use_size(const Foo&lt;N&gt;&amp; foo) { constexpr int n = size(foo); }\n</code></pre>\n", "LastActivityDate": "2017-11-13T17:16:20.907"}, "47269936": {"CommentCount": "0", "ViewCount": "252", "PostTypeId": "1", "LastEditorUserId": "1639256", "CreationDate": "2017-11-13T17:16:20.907", "LastActivityDate": "2017-11-14T14:23:06.377", "LastEditDate": "2017-11-14T03:52:18.247", "AcceptedAnswerId": "47269937", "FavoriteCount": "4", "Title": "constexpr expression and variable lifetime, an example where g++ and clang disagree", "Id": "47269936", "Score": "9", "Body": "<p>Consider the simple C++11 code:</p>\n<pre><code>template&lt;int N&gt;\nstruct Foo {};\n\ntemplate &lt;int N&gt;\nconstexpr int size(const Foo&lt;N&gt;&amp;) { return N; }\n\ntemplate &lt;int N&gt;\nvoid use_size(const Foo&lt;N&gt;&amp; foo) { constexpr int n = size(foo); }\n\nint main()\n{\n    Foo&lt;5&gt; foo;\n\n    constexpr int x = size(foo);  // works with gcc and clang\n                                  // _but_\n    use_size(foo);                // the same statement in the use_size() \n                                  // function _only_ works for gcc\n}\n</code></pre>\n<p>I can successfuly compile it with <code>g++ -std=c++11 foo.cpp</code></p>\n<p>however if I use clang++, <code>clang++ -std=c++11 foo.cpp</code> I get</p>\n<pre><code>foo.cpp:15:28: error: constexpr variable 'n' must be initialized by a constant expression\nvoid use_size(const Foo&lt;N&gt;&amp; foo) { constexpr int n = size(foo); }\n                                                     ~~~~~^~~~\nfoo.cpp:23:5: note: in instantiation of function template specialization 'use_size&lt;5&gt;' requested here\n    use_size(foo);                // the same statement in the use_size() \n    ^\n1 error generated.\n</code></pre>\n<p>(nb: compiler versions. I have checked the previous statement with g++ version 5.3.1 and 7.2.1 and with clang++ version 3.6.2 and 5.0.0)</p>\n<p><strong>My question:</strong> which of g++ or clang is right? What is the problem?</p>\n", "Tags": "<c++><c++11><g++><clang++>", "OwnerUserId": "2001017", "AnswerCount": "2"}, "47271207": {"ParentId": "47269936", "LastEditDate": "2017-11-14T14:23:06.377", "CommentCount": "2", "CreationDate": "2017-11-13T18:32:40.780", "Score": "3", "LastEditorUserId": "2104697", "PostTypeId": "2", "Id": "47271207", "OwnerUserId": "2104697", "Body": "<p>I was expecting Clang to be wrong in this case. It should evaluate your function call as being a constant expression, simply because you use only the template parameter, and not the object itself. Since you don't use the object in your <code>constexpr</code> function, there should be nothing prohibit compile time evaluation.</p>\n<p>However, there's a rule in the standard that says object that began their lifetime preceding the constant expression such as a reference is not useable as constexpr.</p>\n<p>There is a simple fix in that case. I think it didn't like the reference:</p>\n<pre><code>template &lt;int N&gt; // pass by value, clang is happy\nvoid use_size(Foo&lt;N&gt; foo) { constexpr int n = size(foo); }\n</code></pre>\n<p>Here's a <a href=\"https://godbolt.org/g/xYtDXm\" rel=\"nofollow noreferrer\">live example</a></p>\n<p>Alternatively, you can also copy your foo object and use that local object:</p>\n<pre><code>template &lt;int N&gt;\nvoid use_size(const Foo&lt;N&gt;&amp; foo) {\n    auto f = foo;\n    constexpr int n = size(f);\n}\n</code></pre>\n<p><a href=\"https://godbolt.org/g/MT9nNa\" rel=\"nofollow noreferrer\">Live example</a></p>\n", "LastActivityDate": "2017-11-14T14:23:06.377"}, "bq_ids": {"n4140": {"so_47269936_47269937_0": {"section_id": 6185, "quality": 0.5454545454545454, "length": 6}}, "n4659": {"so_47269936_47269937_0": {"section_id": 7687, "quality": 0.5454545454545454, "length": 6}}}});