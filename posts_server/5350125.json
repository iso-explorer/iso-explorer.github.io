post_cb({"5350125": {"FavoriteCount": "1", "ViewCount": "8930", "Id": "5350125", "AcceptedAnswerId": "5350155", "Score": "14", "Title": "Constructor of type int", "LastEditorUserId": "3002139", "CommentCount": "0", "Body": "<p>Considering the cost, are these cases the same? </p>\n<pre><code>// case 1\nint a = 5;\n\n// case 2\nint a (5);\n\n// case 3\nint a;\na = 5\n</code></pre>\n", "Tags": "<c++>", "CreationDate": "2011-03-18T09:29:45.377", "LastEditDate": "2015-05-02T17:05:41.377", "LastActivityDate": "2015-05-02T17:05:41.377", "PostTypeId": "1", "AnswerCount": "5", "OwnerUserId": "244031"}, "5350151": {"CommentCount": "9", "Body": "<p>Yes, they all evaluate to the exact same assembler representation. You can test this e.g. with GCC by writing a dummy function and then producing the assembler output: <code>g++ -S file.cxx -o file.s</code></p>\n", "CreationDate": "2011-03-18T09:33:13.397", "ParentId": "5350125", "Id": "5350151", "LastActivityDate": "2011-03-18T09:33:13.397", "PostTypeId": "2", "Score": "1", "OwnerUserId": "400056"}, "5350155": {"LastActivityDate": "2011-03-18T10:05:16.943", "CommentCount": "1", "Body": "<p>First and second are exactly same as both are <strong>initialization</strong>. Third one is different, as this is <strong>assignment</strong>. These differences are as per the C++ Standard. However, the compiler can treat all three as same!</p>\n", "CreationDate": "2011-03-18T09:33:57.733", "LastEditDate": "2011-03-18T10:05:16.943", "ParentId": "5350125", "Id": "5350155", "LastEditorUserId": "415784", "PostTypeId": "2", "Score": "15", "OwnerUserId": "415784"}, "5350147": {"CommentCount": "0", "Body": "<p>If you use an optimizing compiler, they will all compile to the same code. So they all have the same cost.</p>\n", "CreationDate": "2011-03-18T09:32:29.433", "ParentId": "5350125", "Id": "5350147", "LastActivityDate": "2011-03-18T09:32:29.433", "PostTypeId": "2", "Score": "3", "OwnerUserId": "154980"}, "bq_ids": {"n4140": {"so_5350125_5350209_0": {"length": 23, "quality": 0.7666666666666667, "section_id": 3293}}, "n3337": {"so_5350125_5350209_0": {"length": 23, "quality": 0.7666666666666667, "section_id": 3163}}}, "5351072": {"CommentCount": "4", "Body": "<p>The three syntaxes are different, bear with me while I use a user defined type instead of int, I will go back to int later.</p>\n<pre><code>T a(5);     // Direct initialization\nT b = 5;    // Implicit conversion (5-&gt;tmp) + copy-initialization\nT c; c = 5; // Default initialization + assignment\n</code></pre>\n<p>In the first case the object <code>a</code> is constructed by means of a constructor that takes an <code>int</code> or a type that can be implicitly converted from <code>int</code>.</p>\n<pre><code>struct T {\n  T( int ); // T a(5) will call this directly\n};\n</code></pre>\n<p>In the second case, a temporary object of type <code>T</code> is created by an <em>implicit conversion</em> from <code>int</code>, and then that temporary is used to <em>copy construct</em> <code>b</code>. The compiler is allowed to optimize the code away and perform just the <em>implicit conversion</em> in place of the final object (instead of using it to create the temporary. But <em>all restrictions have to be verified</em>:</p>\n<pre><code>class T {\n   T( T const &amp; );\npublic:\n   explicit implicit T( int );\n};\nint main() {\n   T b = 5;   // Error 1: No implicit conversion from int to T.\n              //     Fix: remove the `explicit` from the constructor\n              // Error 2: Copy constructor is not accessible\n}\n</code></pre>\n<p>The third case is default construction followed by assignment. The requirements on the type are that it can be default constructed (there is a constructor with no arguments, or there is no user defined constructor at all and the compiler will implicitly define it). The type must be assignable from <code>int</code> or there must be an implicit conversion from <code>int</code> to a type <code>U</code> that can be assigned to <code>T</code>. As you see, the requirements for the type in the tree cases differ. </p>\n<p>Besides the semantics of the different operations, there is other important difference, not all of them can be used in all of the contexts. In particular, in an initialization list in a class you cannot use the <em>implicit convert + copy initialize</em> version, and you can only have the first half of <em>default construct + assign</em>.</p>\n<pre><code>// OK                     // error                  // ok but different\nstruct test {             struct test {             struct test {\n   T x;                      T x;                      T x;\n   test(int v) : x(v) {}     test(int v) : x=5 {}      test( int v ) {\n                                                          x = v;\n                                                        }\n</code></pre>\n<p>In the first case the attribute <code>x</code> is directly initialized with the value <code>v</code>. The second case is a syntax error. The third case first <em>default initializes</em> and then assigns inside the body of the constructor.</p>\n<p>Going back to the <code>int</code> example, all of the requirements are met by the type, so there is almost no difference on the code that the compiler generates for the three cases, but still you cannot use the <code>int b = 5;</code> version inside an initializer list to initialize an integer attribute. Moreover, if a class has a member attribute that is a constant integer, then you cannot use the equivalent of <code>int c; c =5;</code> (third column above) as the member attribute becomes <code>const</code> when it enters the constructor block, that is, <code>x = v;</code> above would be trying to modify a constant and the compiler will complain.</p>\n<p>As to the cost that each one has, if they can be used at all, they incur the same cost for an <code>int</code> (for any POD type) but not so for user defined types that have a default constructor, in which case <code>T c; c = 5;</code> will incur the cost of <em>default construction</em> followed by the cost of <em>assignment</em>. In the other two cases, the standard explicitly states that the compiler is allowed to generate the exact same code (once the constraints are checked).</p>\n", "CreationDate": "2011-03-18T11:08:34.427", "ParentId": "5350125", "Id": "5351072", "LastActivityDate": "2011-03-18T11:08:34.427", "PostTypeId": "2", "Score": "13", "OwnerUserId": "36565"}, "5350209": {"LastActivityDate": "2011-03-18T09:46:44.527", "CommentCount": "1", "Body": "<p>For the first two, there will be no difference.</p>\n<p>From Standard docs, <em>8.5.11</em>,</p>\n<blockquote>\n<p id=\"so_5350125_5350209_0\"><strong>The form of initialization (using parentheses or =) is generally insignificant, but does matter when the initializer or the\n  entity being initialized has a class type;</strong> see below. A parenthesized initializer can be a list of expressions only when the\n  entity being initialized has a class type.</p>\n</blockquote>\n<p>The third one is not an initialization but an assignment.</p>\n<p>And considering the cost,</p>\n<p>In the first two cases, you are creating an integer with a value 5.</p>\n<p>In the third case, you are creating an integer with an <em>undefined</em> value and replace it with 5..</p>\n", "CreationDate": "2011-03-18T09:40:30.957", "LastEditDate": "2011-03-18T09:46:44.527", "ParentId": "5350125", "Id": "5350209", "LastEditorUserId": "249490", "PostTypeId": "2", "Score": "4", "OwnerUserId": "249490"}});