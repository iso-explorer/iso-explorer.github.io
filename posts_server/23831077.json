post_cb({"bq_ids": {"n4140": {"so_23831077_23831077_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 7089}, "so_23831077_23831761_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 7047}, "so_23831077_23831077_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 7047}, "so_23831077_23831761_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 7089}}, "n3337": {"so_23831077_23831077_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 6833}, "so_23831077_23831761_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 6792}, "so_23831077_23831077_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 6792}, "so_23831077_23831761_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 6833}}, "n4659": {"so_23831077_23831077_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 8590}, "so_23831077_23831761_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 8544}, "so_23831077_23831077_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 8544}, "so_23831077_23831761_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 8590}}}, "23831761": {"Id": "23831761", "PostTypeId": "2", "Body": "<p>When parsing the following program</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntypedef int foo;\n\nclass A\n{\npublic:\n   operator int(){\n    return 42;\n   }\n};\n\nint main()\n{ \n    cout &lt;&lt; foo(A());\n}\n</code></pre>\n<p>the output will be <code>42</code> because 3.4.1/3</p>\n<blockquote>\n<p id=\"so_23831077_23831761_0\">For purposes of determining (during parsing) whether an expression is\n  a postfix-expression for a function call, the usual name lookup rules\n  apply.</p>\n</blockquote>\n<p>that means: to determine if <code>foo</code> is a postfix-expression (e.g. a cast) or a function call, the compiler will first use name lookup and search for it in the global namespace and/or enclosing scopes / base classes (or with fully qualified lookups if available).</p>\n<p>Now take this code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A\n{\npublic:\n   friend int foo(A a){ return 55; }\n\n   operator int(){\n    return 42;\n   }\n};\n\nint main()\n{ \n    cout &lt;&lt; foo(A());\n}\n</code></pre>\n<p>The above will output <code>55</code> thanks to <a href=\"http://en.wikipedia.org/wiki/Argument-dependent_name_lookup\" rel=\"nofollow\">ADL</a>: foo will be found by searching inside the scopes defined by its potential arguments, i.e. A.</p>\n<p>A friend declaration introduces a (possibly not visible) name as you posted (3.3.1/4)</p>\n<blockquote>\n<p id=\"so_23831077_23831761_1\">friend declarations (11.3) may introduce a (possibly not visible) name\n  into an enclosing namespace</p>\n</blockquote>\n<p>that means the following code will not work</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A\n{\npublic:\n   friend int foo(A a){ return 55; }\n\n   operator int(){\n    return 42;\n   }\n};\n\nint main()\n{ \n    cout &lt;&lt; ::foo(A()); // Not found\n    cout &lt;&lt; A::foo(A()); // Not found\n}\n</code></pre>\n<p>You might want to search for \"<strong>friend name injection</strong>\" and/or the <a href=\"http://en.wikipedia.org/wiki/Barton%E2%80%93Nackman_trick\" rel=\"nofollow\">Barton-Nackman trick</a>. \nShort story: now ordinary lookups can't find friend declarations.</p>\n<p>So the code you posted is well-formed because ADL allows it to run as I explained in the previous passages.</p>\n", "LastActivityDate": "2014-05-23T14:24:24.007", "CommentCount": "3", "CreationDate": "2014-05-23T14:24:24.007", "ParentId": "23831077", "Score": "4", "OwnerUserId": "1938163"}, "23831077": {"ViewCount": "447", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nclass A\n{\npublic:\n    friend void foo(A a){ printf(\"3\\n\"); }\n};\n\nint main()\n{ \n    foo(A());\n}\n</code></pre>\n<p>It works. But I thought that this code is invalid. It is because 3.4.1/3:</p>\n<blockquote>\n<p id=\"so_23831077_23831077_0\">For purposes of determining (during parsing) whether an expression is\n  a postfix-expression for a function call, the <strong>usual name lookup rules</strong>\n  apply.</p>\n</blockquote>\n<p>Usual name lookup rules could not find the friend function because name declared by friend is invisible in the global namespace in my case. Actually 3.3.1/4:</p>\n<blockquote>\n<p id=\"so_23831077_23831077_1\">friend declarations (11.3) may introduce a (possibly not visible) name\n  into an enclosing namespace</p>\n</blockquote>\n<p>This implies that the programm is ill-formed. It is because that there is no name which found during the determining is the expression <code>foo(A());</code> is a postfix-expression for a function call.</p>\n<p>I'm confusing...</p>\n", "Title": "Why does friend function found successfully via ADL", "CreationDate": "2014-05-23T13:52:36.910", "LastActivityDate": "2014-05-23T14:24:24.007", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "Id": "23831077", "Score": "2", "Tags": "<c++><friend>", "AnswerCount": "1"}});