post_cb({"11493840": {"ParentId": "11492948", "CommentCount": "0", "CreationDate": "2012-07-15T16:58:43.073", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "11493840", "Score": "3", "Body": "<blockquote>\n<p id=\"so_11492948_11493840_0\">But logically, for any return expression, determining whether or not the result refers to a local variable would be solving the Halting Problem.</p>\n</blockquote>\n<p>You are overestimating the complexity of the problem. Clearly the compiler sees if the return expression mentions one of the variables that is local, and it must keep track of all those variables to call the destructors anyway. Note that it will move <em>only if</em> the return mentions explicitly the variable, if you return a pointer or reference to a local variable it need not do so:</p>\n<pre><code>std::unique_ptr&lt;int&gt;&amp; same( std::unique_ptr&lt;int&gt;&amp; x ) { return x; }\nstd::unique_ptr&lt;int&gt; foo() {\n   std::unique_ptr&lt;int&gt; p( new int );\n   std::unique_ptr&lt;int&gt;&amp; r = same(p);\n   return r;                           // FAIL\n}\n</code></pre>\n", "LastActivityDate": "2012-07-15T16:58:43.073"}, "11493012": {"ParentId": "11492948", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2012-07-15T15:06:47.693", "Score": "10", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:22:47.143", "Id": "11493012", "OwnerUserId": "500104", "Body": "<p>There's a simple rule: If the conditions for copy elision are met (except that the variable may be function parameter), treat as rvalue. If that fails, treat as lvalue. Otherwise, treat as lvalue.</p>\n<p><code>\u00a712.8 [class.copy] p32</code></p>\n<blockquote>\n<p id=\"so_11492948_11493012_0\">When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, <strong>and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue</strong>. If overload resolution fails, or if the type of the first parameter of the selected constructor is not an rvalue reference to the object\u2019s type (possibly cv-qualified), overload resolution is performed again, considering the object as an lvalue. [ <em>Note:</em> This two-stage overload resolution must be performed regardless of whether copy elision will occur. It determines the constructor to be called if elision is not performed, and the selected constructor must be accessible even if the call is elided. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>Example:</p>\n<pre><code>template&lt;class T&gt;\nT f(T v, bool b){\n  T t;\n  if(b)\n    return t; // automatic move\n  return v; // automatic move, even though it's a parameter\n}\n</code></pre>\n<p>Not that I personally agree with that rule, since there is no automatic move in the following code:</p>\n<pre><code>template&lt;class T&gt;\nstruct X{\n  T v;\n};\n\ntemplate&lt;class T&gt;\nT f(){\n  X&lt;T&gt; x;\n  return x.v; // no automatic move, needs 'std::move'\n}\n</code></pre>\n<p>See also <a href=\"https://stackoverflow.com/q/9183087/500104\">this question of mine</a>.</p>\n", "LastActivityDate": "2012-07-16T17:39:27.600"}, "11493036": {"ParentId": "11492948", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-07-15T15:10:16.817", "Score": "5", "LastEditorUserId": "147192", "LastEditDate": "2012-07-15T15:52:36.543", "Id": "11493036", "OwnerUserId": "34509", "Body": "<p>The Standard does not say \"refers to a local variable\", but it says \"is the name of a non-volatile automatic object\".</p>\n<p><code>\u00a712.8 [class.copy] p31</code></p>\n<blockquote>\n<p id=\"so_11492948_11493036_0\">[...] This elision of copy/move operations, called <em>copy elision</em>, is permitted in the following circumstances [...]:</p>\n<ul>\n<li>in a <code>return</code> statement in a function with a class return type, <strong>when the expression is the name of a non-volatile automatic object</strong> [...]</li>\n</ul>\n</blockquote>\n<p>So, pointers or references are not allowed. If you read it in evil ways that seek to exploit an interpretation that is less likely to have been intended, you can say that it means to move the following</p>\n<pre><code>struct A {\n  std::unique_ptr&lt;int&gt; x;\n  std::unique_ptr&lt;int&gt; f() { return x; }\n};\n\nint main() { A a; a.f(); }\n</code></pre>\n<p>In this case, the return expression is the name of a variable with automatic storage duration. Some other paragraphs in the Standard can be interpreted in multiple ways, but the rule is to take the interpretation that is most likely to be intended.</p>\n", "LastActivityDate": "2012-07-15T15:52:36.543"}, "11493041": {"ParentId": "11492948", "CommentCount": "0", "CreationDate": "2012-07-15T15:11:00.120", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "11493041", "Score": "2", "Body": "<p>I think you overestimate the capacity of the compiler here.</p>\n<p>If you directly return a local variable, then the job is easy: you can move it.</p>\n<p>If you are calling an expression that requires to move from a local variable, then you must specify it manually.</p>\n<p>See <a href=\"http://ideone.com/f7Jp5\" rel=\"nofollow\">some examples here</a>.</p>\n", "LastActivityDate": "2012-07-15T15:11:00.120"}, "bq_ids": {"n4140": {"so_11492948_11493012_0": {"section_id": 481, "quality": 0.8311688311688312, "length": 64}, "so_11492948_11493036_0": {"section_id": 480, "quality": 0.9, "length": 9}}, "n3337": {"so_11492948_11493012_0": {"section_id": 472, "quality": 0.948051948051948, "length": 73}, "so_11492948_11493036_0": {"section_id": 471, "quality": 0.9, "length": 9}}, "n4659": {"so_11492948_11493012_0": {"section_id": 504, "quality": 0.7792207792207793, "length": 60}, "so_11492948_11493036_0": {"section_id": 502, "quality": 0.9, "length": 9}}}, "11492948": {"CommentCount": "0", "AcceptedAnswerId": "11493012", "PostTypeId": "1", "LastEditorUserId": "298661", "CreationDate": "2012-07-15T14:59:46.517", "LastActivityDate": "2012-07-16T17:39:27.600", "LastEditDate": "2012-07-15T15:02:33.803", "ViewCount": "1250", "FavoriteCount": "3", "Title": "How does the compiler know to move local variables?", "Id": "11492948", "Score": "9", "Body": "<p>I'm curious as to exactly how this feature works. Consider something like</p>\n<pre><code>std::unique_ptr&lt;int&gt; f() { std::unique_ptr&lt;int&gt; lval(nullptr); return lval; }\n</code></pre>\n<p>This code compiles fine even for a move-only type, as the compiler implicitly moves it. But logically, for any return expression, determining whether or not the result refers to a local variable would be solving the Halting Problem- and if the compiler simply treated all local variables as rvalues in the return expression, then this would be problematic as the variable may be referred to in that one expression multiple times. Even if a local only had one <em>direct</em> reference, you would not be able to prove that it did not have other indirect aliases.</p>\n<p>So how does the compiler know when to move from the return expression?</p>\n", "Tags": "<c++><c++11><move-semantics>", "OwnerUserId": "298661", "AnswerCount": "4"}});