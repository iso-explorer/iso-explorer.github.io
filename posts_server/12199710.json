post_cb({"12199835": {"Id": "12199835", "PostTypeId": "2", "Body": "<p>Since it is now guaranteed that strings are stored contiguously and you are now allowed to take a pointer to the internal storage of a string, (i.e. &amp;str[0] works like it would for an array), it's not possible to make a useful COW implementation. You would have to make a copy for way too many things. Even just using <code>operator[]</code> or <code>begin()</code> on a non-const string would require a copy.</p>\n", "LastActivityDate": "2012-08-30T15:00:07.417", "CommentCount": "6", "CreationDate": "2012-08-30T15:00:07.417", "ParentId": "12199710", "Score": "1", "OwnerUserId": "1568792"}, "29199733": {"Id": "29199733", "PostTypeId": "2", "Body": "<p>The answers by <a href=\"https://stackoverflow.com/a/12199969/981959\">Dave S</a> and  <a href=\"https://stackoverflow.com/a/12199871/981959\">gbjbaanb</a> are <strong>correct</strong>. (And Luc Danton's is correct too, although it's more a side-effect of forbidding COW strings rather than the original rule that forbids it.)</p>\n<p>But to clear up some confusion, I'm going to add some further exposition. Various comments link to <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=21334#c47\" rel=\"noreferrer\">a comment of mine on the GCC bugzilla</a> which gives the following example:</p>\n<pre><code>std::string s(\"str\");\nconst char* p = s.data();\n{\n    std::string s2(s);\n    (void) s[0];\n}\nstd::cout &lt;&lt; *p &lt;&lt; '\\n';  // p is dangling\n</code></pre>\n<p>The point of that example is to demonstrate why GCC's reference counted (COW) string is not valid in C++11. The C++11 standard requires this code to work correctly. Nothing in the code permits the <code>p</code> to be invalidated in C++11.</p>\n<p>Using GCC's old reference-counted <code>std::string</code> implementation, that code has undefined behaviour, because <code>p</code> <em>is</em> invalidated, becoming a dangling pointer. (What happens is that when <code>s2</code> is constructed it shares the data with <code>s</code>, but obtaining a non-const reference via <code>s[0]</code> requires the data to be unshared, so <code>s</code> does a \"copy on write\" because the reference <code>s[0]</code> could potentially be used to write into <code>s</code>, then <code>s2</code> goes out of scope, destroying the array pointed to by <code>p</code>).</p>\n<p>The C++03 standard <strong>explicitly permits that behaviour</strong> in 21.3 [lib.basic.string] p5 where it says that subsequent to a call to <code>data()</code> the first call to <code>operator[]()</code> may invalidate pointers, references and iterators. So GCC's COW string was a valid C++03 implementation.</p>\n<p>The C++11 standard <strong>no longer permits</strong> that behaviour, because no call to <code>operator[]()</code> may invalidate pointers, references or iterators, irrespective of whether they follow a call to <code>data()</code>.</p>\n<p>So the example above <strong>must</strong> work in C++11, but <strong>does not</strong> work with libstdc++'s kind of COW string, therefore that kind of COW string is not permitted in C++11.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-16T17:58:50.847", "Score": "32", "CreationDate": "2015-03-22T20:55:21.843", "ParentId": "12199710", "CommentCount": "16", "OwnerUserId": "981959", "LastEditDate": "2017-05-23T10:31:26.040"}, "bq_ids": {"n4140": {"so_12199710_12199969_0": {"length": 8, "quality": 1.0, "section_id": 1567}, "so_12199710_38651410_5": {"length": 31, "quality": 0.5344827586206896, "section_id": 1567}, "so_12199710_12199893_3": {"length": 9, "quality": 0.8181818181818182, "section_id": 1569}, "so_12199710_12199893_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 1568}, "so_12199710_12199969_1": {"length": 12, "quality": 1.0, "section_id": 1567}}, "n3337": {"so_12199710_12199969_0": {"length": 8, "quality": 1.0, "section_id": 1562}, "so_12199710_38651410_5": {"length": 31, "quality": 0.5344827586206896, "section_id": 1562}, "so_12199710_12199893_3": {"length": 9, "quality": 0.8181818181818182, "section_id": 1565}, "so_12199710_12199893_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 1563}, "so_12199710_12199969_1": {"length": 12, "quality": 1.0, "section_id": 1562}}, "n4659": {"so_12199710_12199969_0": {"length": 8, "quality": 1.0, "section_id": 1716}, "so_12199710_38651410_5": {"length": 31, "quality": 0.5344827586206896, "section_id": 1716}, "so_12199710_12199893_3": {"length": 9, "quality": 0.8181818181818182, "section_id": 1718}, "so_12199710_12199893_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 1717}, "so_12199710_12199969_1": {"length": 12, "quality": 1.0, "section_id": 1716}}}, "38651410": {"Id": "38651410", "PostTypeId": "2", "Body": "<h2><em>Is COW <code>basic_string</code> prohibited in C++11 and later?</em></h2>\n<p>Regarding</p>\n<blockquote>\n<p id=\"so_12199710_38651410_0\"><strong>\u201d</strong> Am I correct that C++11 does not admit COW based implementations of <code>std::string</code>?</p>\n</blockquote>\n<p><strong><em>Yes.</em></strong></p>\n<p>Regarding</p>\n<blockquote>\n<p id=\"so_12199710_38651410_1\"><strong>\u201d</strong> If so, is this restriction explicitly stated somewhere in the new standard (where)?</p>\n</blockquote>\n<p><strong><em>Almost</em></strong> directly, by requirements of constant complexity for a number of operations that would require O(<em>n</em>) physical copying of the string data in a COW implementation.</p>\n<p>For example, for the member functions</p>\n<pre><code>auto operator[](size_type pos) const -&gt; const_reference;\nauto operator[](size_type pos) -&gt; reference;\n</code></pre>\n<p>\u2026 which in a COW implementation would \u00b9both trigger string data copying to un-share the string value, the C++11 standard requires</p>\n<i>C++11 \u00a721.4.5/4</i>:\n\n<blockquote>\n<p id=\"so_12199710_38651410_2\"><strong>\u201d</strong> <em>Complexity:</em> constant time.</p>\n</blockquote>\n<p>\u2026 which rules out such data copying, and hence, COW.</p>\n<p>C++03 supported COW implementations by <em>not</em> having these constant complexity requirements, and by, under certain restrictive conditions, allowing calls to <code>operator[]()</code>, <code>at()</code>, <code>begin()</code>, <code>rbegin()</code>, <code>end()</code>, or <code>rend()</code> to invalidate references, pointers and iterators referring to the string items, i.e. to possibly incur a COW data copying. This support was removed in C++11. </p>\n<hr>\n<h2><em>Is COW also prohibited via the C++11 invalidation rules?</em></h2>\n<p>In another answer which at the time of writing is selected as solution, and which is heavily upvoted and therefore apparently believed, it's asserted that</p>\n<blockquote>\n<p id=\"so_12199710_38651410_3\"><strong>\u201d</strong> For a COW string, calling non-<code>const</code> <code>operator[]</code> would require making a copy (and invalidating references), which is disallowed by the [quoted] paragraph above [C++11 \u00a721.4.1/6]. Hence, it's no longer legal to have a COW string in C++11.</p>\n</blockquote>\n<p>That assertion is incorrect and misleading in two main ways:</p>\n<ul>\n<li><em>It incorrectly indicates that only the non-<code>const</code> item accessors need to trigger a COW data copying.</em><br>\nBut also the <code>const</code> item accessors need to trigger data copying, because they allow client code to form references or pointers that (in C++11) it's not permitted to invalidate later via the operations that can trigger COW data copying.</br></li>\n<li><em>It incorrectly assumes that COW data copying can cause reference invalidation.</em><br>\nBut in a correct implementation COW data copying, un-sharing the string value, is done at a point before there are any references that can be invalidated.</br></li>\n</ul>\n<p>To see how a correct C++11 COW implementation of <code>basic_string</code> would work, when the O(1) requirements that make this invalid are ignored, think of an implementation where a string can switch between ownership policies. A string instance starts out with policy Sharable. With this policy active there can be no external item references. The instance can transition to Unique policy, and it must do so when an item reference is potentially created such as with a call to <code>.c_str()</code> (at least if that produces a pointer to the internal buffer). In the general case of multiple instances sharing ownership of the value, this entails copying the string data. After that transition to Unique policy the instance can only transition back to Sharable by an operation that invalidates all references, such as assignment.</p>\n<p>So, while that answer's conclusion, that COW strings are ruled out, is correct, the reasoning offered is incorrect and strongly misleading.</p>\n<p>I suspect the cause of this misunderstanding is a non-normative note in C++11's annex C:</p>\n<i>C++11 \u00a7C.2.11 [diff.cpp03.strings], about \u00a721.3:</i>\n<blockquote>\n<p id=\"so_12199710_38651410_4\"><strong>Change</strong>: <code>basic_string</code> requirements no longer allow reference-counted strings<br>\n<strong>Rationale:</strong> Invalidation is subtly different with reference-counted strings. This change regularizes behavor (sic) for this International Standard.<br>\n<strong>Effect on original feature:</strong> Valid C ++ 2003 code may execute differently in this International Standard</br></br></p>\n</blockquote>\n<p>Here the <em>rationale</em> explains the primary <em>why</em> one decided to remove the C++03 special COW support. This rationale, the <em>why</em>, is not <em>how</em> the standard effectively disallows COW implementation. The standard disallows COW via the O(1) requirements.</p>\n<p>In short, the C++11 invalidation rules don't rule out a COW implementation of <code>std::basic_string</code>. But they do rule out a reasonably efficient unrestricted C++03-style COW implementation like the one in at least one of g++'s standard library implementations. The special C++03 COW support allowed practical efficiency, in particular using <code>const</code> item accessors, at the cost of subtle, complex rules for invalidation:</p>\n<i>C++03 \u00a721.3/5</i> which includes \u201cfirst call\u201d COW support:\n\n<blockquote>\n<p id=\"so_12199710_38651410_5\"><strong>\u201d</strong> References, pointers, and iterators referring to the elements of a <code>basic_string</code> sequence may be invalidated by the following uses of that <code>basic_string</code> object:<br>\n  \u2014 As an argument to non-member functions <code>swap()</code> (21.3.7.8), <code>operator&gt;&gt;()</code> (21.3.7.9), and <code>getline()</code> (21.3.7.9).<br>\n  \u2014 As an argument to <code>basic_string::swap()</code>.<br>\n  \u2014 Calling <code>data()</code> and <code>c_str()</code> member functions.<br>\n  \u2014 Calling non-<code>const</code> member functions, except <code>operator[]()</code>, <code>at()</code>, <code>begin()</code>, <code>rbegin()</code>, <code>end()</code>, and <code>rend()</code>.<br>\n  \u2014 Subsequent to any of the above uses except the forms of <code>insert()</code> and <code>erase()</code> which return iterators, the first call to non-<code>const</code> member functions <code>operator[]()</code>, <code>at()</code>, <code>begin()</code>, <code>rbegin()</code>, <code>end()</code>, or <code>rend()</code>.</br></br></br></br></br></p>\n</blockquote>\n<p>These rules are so complex and subtle that I doubt many programmers, if any, could give a precise summary. I could not.</p>\n<hr>\n<h2><em>What if O(1) requirements are disregarded?</em></h2>\n<p>If the C++11 constant time requirements on e.g. <code>operator[]</code> are disregarded, then COW for <code>basic_string</code> could be technically feasible, but difficult to implement.</p>\n<p>Operations which could access the contents of a string without incurring COW data copying include:</p>\n<ul>\n<li>Concatenation via <code>+</code>.</li>\n<li>Output via <code>&lt;&lt;</code>.</li>\n<li>Using a <code>basic_string</code> as argument to standard library functions.</li>\n</ul>\n<p>The latter because the standard library is permitted to rely on implementation specific knowledge and constructs.</p>\n<p>Additionally an implementation could offer various non-standard functions for accessing string contents without triggering COW data copying.</p>\n<p>A main complicating factor is that in C++11 <code>basic_string</code> item access must trigger data copying (un-sharing the string data) but is required to <strong>not throw</strong>, e.g. C++11 \u00a721.4.5/3 \u201c<em>Throws:</em> Nothing.\u201d. And so it can't use ordinary dynamic allocation to create a new buffer for COW data copying. One way around this is to use a special heap where memory can be <em>reserved</em> without being actually allocated, and then reserve the requisite amount for each logical reference to a string value. Reserving and un-reserving in such a heap can be constant time, O(1), and allocating the amount that one has already reserved, can be <code>noexcept</code>. In order to comply with the standard's requirements, with this approach it seems there would need to be one such special reservation-based heap per distinct allocator.</p>\n<hr>\n<p><sup>\n<em>Notes:</em><br>\n\u00b9 The <code>const</code> item accessor triggers a COW data copying because it allows the client code to obtain a reference or pointer to the data, which it's not permitted to invalidate by a later data copying triggered by e.g. the non-<code>const</code> item accessor.\n</br></sup></p>\n</hr></hr></hr>", "LastEditorUserId": "464581", "LastActivityDate": "2016-07-29T09:23:24.627", "Score": "-2", "CreationDate": "2016-07-29T05:53:27.857", "ParentId": "12199710", "CommentCount": "20", "OwnerUserId": "464581", "LastEditDate": "2016-07-29T09:23:24.627"}, "12199893": {"Id": "12199893", "PostTypeId": "2", "Body": "<p>From 21.4.2 basic_string constructors and assignment operators [string.cons]</p>\n<blockquote>\n<p id=\"so_12199710_12199893_0\"><code>basic_string(const basic_string&lt;charT,traits,Allocator&gt;&amp; str);</code></p>\n<p id=\"so_12199710_12199893_1\">[...]</p>\n<p id=\"so_12199710_12199893_2\">2 <em>Effects</em>: Constructs an object of class <code>basic_string</code> as indicated in Table 64. [...]</p>\n</blockquote>\n<p>Table 64 helpfully documents that after construction of an object via this (copy) constructor, <code>this-&gt;data()</code> has as value:</p>\n<blockquote>\n<p id=\"so_12199710_12199893_3\">points at the \ufb01rst element of an allocated copy of the array whose \ufb01rst element is pointed at by str.data()</p>\n</blockquote>\n<p>There are similar requirements for other similar constructors.</p>\n", "LastActivityDate": "2012-08-30T15:02:40.470", "CommentCount": "2", "CreationDate": "2012-08-30T15:02:40.470", "ParentId": "12199710", "Score": "5", "OwnerUserId": "726300"}, "12199710": {"ViewCount": "17513", "Body": "<p>It had been my understanding that copy-on-write is not a viable way to implement a conforming <code>std::string</code> in C++11, but when it came up in discussion recently I found myself unable to directly support that statement.</p>\n<p>Am I correct that C++11 does not admit COW based implementations of <code>std::string</code>?</p>\n<p>If so, is this restriction explicitly stated somewhere in the new standard (where)?</p>\n<p>Or is this restriction implied, in the sense that it is the combined effect of the new requirements on <code>std::string</code> that precludes a COW based implementation of <code>std::string</code>. In this case, I'd be interested in a chapter and verse style derivation of 'C++11 effectively prohibits COW based <code>std::string</code> implementations'.</p>\n", "AcceptedAnswerId": "12199969", "Title": "Legality of COW std::string implementation in C++11", "CreationDate": "2012-08-30T14:54:05.910", "Id": "12199710", "CommentCount": "1", "FavoriteCount": "34", "PostTypeId": "1", "LastEditDate": "2015-01-01T11:17:54.137", "LastEditorUserId": "2642204", "LastActivityDate": "2016-07-29T09:23:24.627", "Score": "93", "OwnerUserId": "776473", "Tags": "<c++><c++11><stdstring><copy-on-write>", "AnswerCount": "6"}, "12199871": {"Id": "12199871", "PostTypeId": "2", "Body": "<p>It is, CoW is an acceptable mechanism for making faster strings... but...</p>\n<p>it makes multithreading code slower (all that locking to check if you're the only one writing kills performance when using a lot of strings). This was the main reason CoW was killed off years ago. </p>\n<p>The other reasons are that the <code>[]</code> operator will return you the string data, without any protection for you to overwrite a string someone else expects to be unchanging. The same applies to <code>c_str()</code> and <code>data()</code>.</p>\n<p>Quick google says that the multithreading is basically the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2668.htm\">reason it was effectively disallowed</a> (not explicitly).</p>\n<p>The proposal says : </p>\n<blockquote>\n<p id=\"so_12199710_12199871_0\">Proposal</p>\n<p id=\"so_12199710_12199871_1\">We propose to make all iterator and element access operations safely\n  concurrently executable.</p>\n<p id=\"so_12199710_12199871_2\">We are increasing the stability of operations even in sequential code.</p>\n<p id=\"so_12199710_12199871_3\">This change effectively disallows copy-on-write implementations.</p>\n</blockquote>\n<p>followed by</p>\n<blockquote>\n<p id=\"so_12199710_12199871_4\">The largest potential loss in performance due to a switch away from\n  copy-on-write implementations is the increased consumption of memory\n  for applications with very large read-mostly strings. However, we\n  believe that for those applications ropes are a better technical\n  solution, and recommend a rope proposal be considered for inclusion in\n  Library TR2.</p>\n</blockquote>\n<p><a href=\"http://www.sgi.com/tech/stl/Rope.html\">Ropes</a> are part of STLPort and SGIs STL.</p>\n", "LastEditorUserId": "2642204", "LastActivityDate": "2015-01-01T11:19:56.360", "Score": "14", "CreationDate": "2012-08-30T15:01:54.997", "ParentId": "12199710", "CommentCount": "3", "OwnerUserId": "13744", "LastEditDate": "2015-01-01T11:19:56.360"}, "12199969": {"Id": "12199969", "PostTypeId": "2", "Body": "<p>It's not allowed, because as per the standard 21.4.1 p6, invalidation of iterators/references is only allowed for</p>\n<blockquote>\n<p id=\"so_12199710_12199969_0\">\u2014 as an argument to any standard library function taking a reference\n  to non-const basic_string as an argument.</p>\n<p id=\"so_12199710_12199969_1\">\u2014 Calling non-const\n  member functions, except operator[], at, front, back, begin, rbegin,\n  end, and rend.</p>\n</blockquote>\n<p>For a COW string, calling non-const <code>operator[]</code> would require making a copy (and invalidating references), which is disallowed by the paragraph above.  Hence, it's no longer legal to have a COW string in C++11.</p>\n", "LastActivityDate": "2012-08-30T15:06:12.427", "CommentCount": "16", "CreationDate": "2012-08-30T15:06:12.427", "ParentId": "12199710", "Score": "94", "OwnerUserId": "862231"}});