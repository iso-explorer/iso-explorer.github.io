post_cb({"24303735": {"CommentCount": "6", "ViewCount": "249", "CreationDate": "2014-06-19T09:54:28.577", "LastActivityDate": "2014-06-20T09:12:54.210", "Title": "Why auto_ptr seems to breach private inheritance on Visual C++?", "AcceptedAnswerId": "24312655", "PostTypeId": "1", "Id": "24303735", "Score": "13", "Body": "<p>Background information: This was detected on Visual Studio 2008, and confirmed again on Visual Studio 2013. G++ screamed at the code, while Visual accepted the private inheritance breach silently.</p>\n<p>So, on Visual C++, we have the following code:</p>\n<pre><code>class Base {};\nclass Derived : Base {};      // inherits privately. Adding explicitly the\n                              //    keyword private changes nothing\n\nint main()\n{\n   std::auto_ptr&lt;Base&gt;(new Derived) ;   // compiles, which is NOT EXPECTED\n   std::auto_ptr&lt;Base&gt; p(new Derived) ; // Does not compile, which is expected\n}\n</code></pre>\n<p>Why would the first (temporary) auto_ptr compile? I went inside it in debug, it did exactly what is was supposed to do with a public inheritance (call the right constructor, etc.)</p>\n<p>Wondering if perhaps the issue was with the auto_ptr implementation (we never know...), I reduced the issue on this standalone code:</p>\n<pre><code>class Base {};\nclass Derived : Base {};\n\ntemplate &lt;typename T&gt;\nclass Ptr\n{\n   T * m_p;\n\n   public :\n      Ptr(T * p_p)\n         : m_p(p_p)\n      {\n      }\n} ;\n\nint main()\n{\n   Ptr&lt;Base&gt;(new Derived) ;   // compiles, which is NOT EXPECTED\n   Ptr&lt;Base&gt; p(new Derived) ; // Does not compile, which is expected\n}\n</code></pre>\n<p>Again, I expected the code to NOT compile, as Derived inherits privately from Base.</p>\n<p>But when we create a temporary, it works.</p>\n<p>And we can't blame it on std::auto_ptr.</p>\n<p><b>Is there something in the standard (either 98 or 11 or 14) I missed, or is this a bug?</b></p>\n", "Tags": "<c++><visual-studio><private-inheritance>", "OwnerUserId": "14089", "AnswerCount": "1"}, "24312655": {"ParentId": "24303735", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The <code>Derived*</code>-to-<code>Base*</code> conversion, even if the inheritance is private, is permitted in C-style and functional casts. And no, it doesn't mean <code>reinterpret_cast</code> in that case.</p>\n<p>This isn't allowed by the standard, but it <em>very</em> nearly looks as if it is allowed, so it's a subtle bug.</p>\n<blockquote>\n<p id=\"so_24303735_24312655_0\"><strong>5.2.3 Explicit type conversion (functional notation) [expr.type.conv]</strong></p>\n<p id=\"so_24303735_24312655_1\">1 [...] If the expression list is a single expression, the type conversion expression is equivalent (in definedness, and if defined in meaning) to the corresponding cast expression (5.4). [...]</p>\n<p id=\"so_24303735_24312655_2\"><strong>5.4 Explicit type conversion (cast notation) [expr.cast]</strong></p>\n<p id=\"so_24303735_24312655_3\">4 The conversions performed by</p>\n<ul>\n<li>a <code>const_cast</code> (5.2.11),</li>\n<li>a <code>static_cast</code> (5.2.9),</li>\n<li>a <code>static_cast</code> followed by a <code>const_cast</code>,</li>\n<li>a <code>reinterpret_cast</code> (5.2.10), or</li>\n<li>a <code>reinterpret_cast</code> followed by a <code>const_cast</code>,</li>\n</ul>\n<p id=\"so_24303735_24312655_4\">can be performed using the cast notation of explicit type conversion. The same semantic restrictions and behaviors apply, with the exception that in performing a\n  <code>static_cast</code> in the following situations the conversion is valid even if the base class is inaccessible:</p>\n<ul>\n<li>a pointer to an object of derived class type or an lvalue or rvalue of derived class type may be explicitly\n  converted to a pointer or reference to an unambiguous base class type, respectively;</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>In the situation you've got, the compiler interprets it as a <code>static_cast</code> from <code>Derived*</code> to <code>auto_ptr&lt;Base&gt;</code>, and in that <code>static_cast</code>, a pointer to an object of derived class type is converted to a pointer of an unambiguous base class type. So it looks like the standard allows it.</p>\n<p>However, the conversion from <code>Derived*</code> to <code>Base*</code> is implicit, it merely happens to be performed <em>as part of</em> an explicit different conversion. So in the end, no, the standard really doesn't allow it.</p>\n<p>You may want to report this as a bug. From <a href=\"https://stackoverflow.com/users/680982\">Csq</a>'s comment, we learn that there is a <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/540343/visual-c-compiler-downcasting-for-private-inheritance-with-static-cast-succeedes\" rel=\"nofollow\">related report</a>, in which an explicit <code>static_cast</code> also allows this conversion, but it's not exactly the same thing. In that case, the conversion from <code>Derived*</code> to <code>Base*</code> is explicit, but it is implicit here, and Visual C++ does usually reject that in implicit conversions.</p>\n<p>Note that in functional casts that use multiple expressions, this misinterpretation isn't possible: the compiler correctly rejects the following:</p>\n<pre><code>class Base { };\nclass Derived : Base { };\n\ntemplate &lt;typename T&gt;\nclass Ptr {\npublic:\n  Ptr(T *a, T *b) { }\n};\n\nint main() {\n  Ptr&lt;Base&gt;(new Derived, new Derived);\n  // error C2243: 'type cast' : conversion from 'Derived *' to 'Base *' exists, but is inaccessible\n}\n</code></pre>\n", "OwnerUserId": "743382", "LastEditorUserId": "14089", "LastEditDate": "2014-06-20T09:12:54.210", "Id": "24312655", "Score": "2", "CreationDate": "2014-06-19T17:19:16.990", "LastActivityDate": "2014-06-20T09:12:54.210"}, "bq_ids": {"n4140": {"so_24303735_24312655_1": {"section_id": 5999, "quality": 1.0, "length": 14}, "so_24303735_24312655_0": {"section_id": 367, "quality": 0.5714285714285714, "length": 4}, "so_24303735_24312655_4": {"section_id": 6126, "quality": 0.96, "length": 24}}, "n3337": {"so_24303735_24312655_1": {"section_id": 5767, "quality": 1.0, "length": 14}, "so_24303735_24312655_0": {"section_id": 356, "quality": 0.5714285714285714, "length": 4}, "so_24303735_24312655_4": {"section_id": 5890, "quality": 0.96, "length": 24}}, "n4659": {"so_24303735_24312655_0": {"section_id": 379, "quality": 0.5714285714285714, "length": 4}, "so_24303735_24312655_1": {"section_id": 7500, "quality": 0.8571428571428571, "length": 12}, "so_24303735_24312655_4": {"section_id": 7623, "quality": 0.96, "length": 24}}}});