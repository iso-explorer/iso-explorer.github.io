post_cb({"34966376": {"Id": "34966376", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_34966340_34966376_0\">What happens when my explicit definition tries to implicitly destroy the union object?</p>\n</blockquote>\n<p>It doesn't.  There is no implicit destruction of variant members, your destructor must perform destruction explicitly using <code>member.~TYPE()</code> syntax.</p>\n<p>For that to happen, your destructor has to figure out which one (if any) of the variant members in each anonymous union is alive and in need to destruction.</p>\n<p>Note that you even quoted the rule:</p>\n<blockquote>\n<p id=\"so_34966340_34966376_1\">After executing the body of the destructor and destroying any automatic objects allocated within the body, <strong><em>a destructor for class X calls the destructors for X\u2019s direct</em> NON-VARIANT <em>non-static data members</em></strong>, the destructors for X\u2019s direct base classes and, if X is the type of the most derived class (12.6.2), its destructor calls the destructors for X\u2019s virtual base classes.</p>\n</blockquote>\n<p>Your paraphrase \"implictly calls destructors of the class members\" left out this important qualification.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2016-01-23T17:18:44.400", "Score": "2", "CreationDate": "2016-01-23T17:12:55.940", "ParentId": "34966340", "CommentCount": "2", "OwnerUserId": "103167", "LastEditDate": "2016-01-23T17:18:44.400"}, "bq_ids": {"n4140": {"so_34966340_34966340_1": {"length": 34, "quality": 0.9714285714285714, "section_id": 404}, "so_34966340_34966376_1": {"length": 33, "quality": 0.9428571428571428, "section_id": 404}, "so_34966340_34966340_2": {"length": 28, "quality": 0.8, "section_id": 5914}}, "n3337": {"so_34966340_34966340_2": {"length": 28, "quality": 0.8, "section_id": 5686}, "so_34966340_34966376_1": {"length": 33, "quality": 0.9428571428571428, "section_id": 395}, "so_34966340_34966340_1": {"length": 34, "quality": 0.9714285714285714, "section_id": 395}}, "n4659": {"so_34966340_34966340_2": {"length": 28, "quality": 0.8, "section_id": 7406}, "so_34966340_34966376_1": {"length": 33, "quality": 0.9428571428571428, "section_id": 422}, "so_34966340_34966340_1": {"length": 34, "quality": 0.9714285714285714, "section_id": 422}}}, "34966340": {"ViewCount": "232", "Body": "<p>From C++ Primer (13.1.6):</p>\n<blockquote>\n<p id=\"so_34966340_34966340_0\">The compiler will not let us\n  define variables or create temporaries of a type that has a deleted destructor.\n  Moreover, <strong>we cannot define variables or temporaries of a class that has a member\n  whose type has a deleted destructor.</strong> If a member has a deleted destructor, then that\n  member cannot be destroyed. If a member can\u2019t be destroyed, the object as a whole\n  can\u2019t be destroyed.</p>\n</blockquote>\n<p>This certaintly seems true:</p>\n<pre><code>class B{\n\npublic:\n    B() { }\n    ~B() = delete;\n\n};\n\nclass A{\n\npublic:\n    A() {}\n    ~A() {}\n    B b;\n\n};\n\n\nint main(){\n\n    //B b; //error\n    A a; //error\n\n}\n</code></pre>\n<p>brings in all sorts of errors about <code>B</code>'s deleted destructor. This must be because a destructor, even an explicit one, implictly calls destructors of the class members as pointed out in (12.4/8) of N3337:</p>\n<blockquote>\n<p id=\"so_34966340_34966340_1\">After executing the body of the destructor and destroying any automatic objects allocated within the body, a\n  destructor for class X calls the destructors for X\u2019s direct non-variant non-static data members, the destructors\n  for X\u2019s direct base classes and, if X is the type of the most derived class (12.6.2), its destructor calls the\n  destructors for X\u2019s virtual base classes. </p>\n</blockquote>\n<p>I'm now curious why the following works though:</p>\n<pre><code>#include &lt;string&gt;\n\nclass A{\npublic:\n    A() { }\n    union {\n        std::string test;\n    };\n    ~A() { }\n};\n\n\nint main(){\n\n    A b;\n\n}\n</code></pre>\n<p>Given that, from 9.5/2 of N3337:</p>\n<blockquote>\n<p id=\"so_34966340_34966340_2\">If any non-static data member of a union has a non-trivial default\n  constructor (12.1), copy constructor (12.8), move constructor (12.8), copy assignment operator (12.8), move assignment operator (12.8), or destructor (12.4), the corresponding member function of the union must be\n  user-provided or it will be implicitly deleted (8.4.3) for the union.</p>\n</blockquote>\n<p>My class <code>A</code> has an anonymous union object which in turn has a <code>string</code> data member which of course defines its own destructor. So the union, from above, must have a deleted destructor! But my quote from the top says it must not be possible to create objects of <code>A</code>'s type because it has a member with a deleted destructor. If I comment out <code>~A(){}</code> then indeed I get an error, but for some reason my explicit definition is okay. What happens when my explicit definition tries to implicitly destroy the union object?</p>\n", "Title": "Why can I make an anonymous union even though the destructor is deleted?", "CreationDate": "2016-01-23T17:08:46.510", "LastActivityDate": "2017-02-05T17:00:30.813", "CommentCount": "0", "LastEditDate": "2017-02-05T17:00:30.813", "PostTypeId": "1", "LastEditorUserId": "718379", "Id": "34966340", "Score": "0", "OwnerUserId": "5627734", "Tags": "<c++><c++11><destructor><unions>", "AnswerCount": "1"}});