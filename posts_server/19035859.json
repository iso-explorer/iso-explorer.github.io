post_cb({"19046217": {"ParentId": "19035859", "CommentCount": "0", "Body": "<p><em>\"A Four bytes memory slot is reserved for every defined integer.\"</em>. </p>\n<p>No, it isn't. Disregarding the \"4 bytes\" size, the main problem with the statement is that modern compilers often find a new location for a variable each time it's assigned to. This can be a register or some place in memory. There's a lot of smartness involved.</p>\n<p>An uninitialized variable isn't written to, so in general there's not even a place assigned for it. Trying to read \"it\" might not produce a value at all; the compiler can fail outright to generate code for that.</p>\n<p>Now globals are another matter. Since they can be read and written from anywhere, the compiler can't just find new places for them on each write. They necessarily have to stick to one place, and it can't realistically be a register. Often they're all allocated together in one chunk of memory. Zeroing that chunk can typically be done very efficiently. that's why globals are different.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "19046217", "Score": "2", "CreationDate": "2013-09-27T08:30:09.423", "LastActivityDate": "2013-09-27T08:30:09.423"}, "19037588": {"ParentId": "19035859", "CommentCount": "2", "Body": "<p>As you might expect there are efficiency driven reasons behind this behavior as well.</p>\n<p>Stack space is generally \"allocated\" simply by adjusting the stack pointer.\nIf you have 32 bytes of simple variables in a function then the compiler emits an instruction equivalent to \"sp = sp - 32\"\nAny initialization of those variables would take additional code and execution time - hence they end up being initialized to apparently random values.</p>\n<p>Global variables are another beast entirely.\nSimple variables are effectively allocated by the program loader and can be located in what is commonly called \"BSS\". These variables take almost no space at all in the executable file. All of them can be merged together into a single block - so the executable image needs only specify the size of the block. Since the OS must ensure that a new process doesn't get to see any left-over data in memory from some now dead process, the memory needs to be filled with something - and you might as well fill it with zeros.</p>\n<p>Global variables that are initialized to non-zeros actually do take up space in the executable file, they appear as a block of data and just get loaded into memory - there is no code in the executable to initialize these.</p>\n<p>C++ also allows global variables that require code to be executed to initialize, C doesn't allow this.\nFor example \"int x = rand();\"\nGet initialized at run time by code in the executable.</p>\n<p>Try adding this global variable\n   int x[1024 * 1024];\nand see if it makes a difference to the executable size.\nNow try:\n   int x[1024 * 1024] = {1,2,3};\nAnd see what difference that makes.</p>\n", "OwnerUserId": "1791696", "PostTypeId": "2", "Id": "19037588", "Score": "1", "CreationDate": "2013-09-26T20:00:17.460", "LastActivityDate": "2013-09-26T20:00:17.460"}, "bq_ids": {"n4140": {"so_19035859_19035980_0": {"section_id": 7151, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_19035859_19035980_0": {"section_id": 6895, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_19035859_19035980_0": {"section_id": 4051, "quality": 0.6, "length": 9}}}, "19035859": {"CommentCount": "0", "ViewCount": "146", "CreationDate": "2013-09-26T18:26:53.327", "LastActivityDate": "2013-09-27T08:30:09.423", "Title": "C++ Global and Scoped integers initial values", "AcceptedAnswerId": "19035980", "PostTypeId": "1", "Id": "19035859", "Score": "1", "Body": "<p>A Four bytes memory slot is reserved for every defined integer. Uninitialised variable maintains the old value of that slot. hence, the initial value is somehow randomised.</p>\n<pre><code>int x = 5; // definition with initialisation\n</code></pre>\n<p>This fact in most C++ compilers as far as I know holds for scoped variables. But, when it comes to global variables. a value of zero will be set.</p>\n<pre><code>int x; // uninitialised definition\n</code></pre>\n<p>Why does the C++ Compiler behave differently regarding to the initial value of the global and scoped variables.</p>\n<p>Is it fundamental?</p>\n", "Tags": "<c++><compiler-construction><global-variables><initialization>", "OwnerUserId": "1586924", "AnswerCount": "3"}, "19035980": {"ParentId": "19035859", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The namespace level variables (which means global) belong to <strong>static</strong> storage duration, and as per the Standard, all variables with static storage duration are statically initialized, which means all bits are set 0:</p>\n<p>\u00a73.6.2/2 from the C++ Standard (n3242) says,</p>\n<blockquote>\n<p id=\"so_19035859_19035980_0\"><strong>Variables with static storage duration</strong> (3.7.1) or thread storage duration (3.7.2) <strong>shall be zero-initialized</strong> (8.5) before any other initialization takes place.</p>\n</blockquote>\n<p>In case of local variables with <strong>automatic</strong> storage duration, the Standard imposes <strong>no</strong> such requirement on the compilers. So the automatic variables are usually left uninitialized for performance reason \u2014 almost all major compilers choose this approach, though there might be a compiler which initializes the <em>automatic</em> variables also.</p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2013-09-26T18:47:18.540", "Id": "19035980", "Score": "4", "CreationDate": "2013-09-26T18:32:40.500", "LastActivityDate": "2013-09-26T18:47:18.540"}});