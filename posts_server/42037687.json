post_cb({"42037687": {"CommentCount": "5", "CreationDate": "2017-02-04T07:20:21.337", "PostTypeId": "1", "AcceptedAnswerId": "42042473", "LastEditorUserId": "636019", "LastActivityDate": "2017-02-05T22:36:41.200", "LastEditDate": "2017-02-04T16:25:17.553", "ViewCount": "182", "FavoriteCount": "1", "Title": "What is the correct result of decltype( (A{}.int_member) )?", "Id": "42037687", "Score": "10", "Body": "<p>Given the definition of type <code>A</code> :</p>\n<pre><code>struct A { int i; };\n</code></pre>\n<p>According to the specification <em>[expr.ref]</em> (I used <em>n4618</em>) :</p>\n<blockquote>\n<p id=\"so_42037687_42037687_0\">(if <code>E2</code> is non-reference,) ...If <code>E1</code> is an lvalue, then <code>E1.E2</code> is an lvalue; otherwise <code>E1.E2</code> is an <em>xvalue</em>...</p>\n</blockquote>\n<p>obviously <code>A{}.i</code> is xvalue;\n also given that <em>[dcl.type.simple]</em> :</p>\n<blockquote>\n<p id=\"so_42037687_42037687_1\">(for <code>decltype(e)</code>,) \u2014 ... if <code>e</code> is an <em>unparenthesized</em> id-expression or an <em>unparenthesized</em> class member access...\n  \u2014 <em>otherwise</em>, if <code>e</code> is an <em>xvalue</em>, decltype(e) is <em>T&amp;&amp;</em>, where T is the type of <code>e</code></p>\n</blockquote>\n<p>therefore, <code>decltype( ( A{}.i ) )</code> shall yields <em>int&amp;&amp;</em>.</p>\n<p>However I tried GCC5.1 and Clang3.9, they yield <em>int</em>, while vs2015u3 yields <em>int&amp;&amp;</em>. Which is correct?</p>\n", "Tags": "<c++><c++14><language-lawyer><c++1z>", "OwnerUserId": "2881005", "AnswerCount": "1"}, "42042473": {"ParentId": "42037687", "PostTypeId": "2", "CommentCount": "6", "Body": "<p><code>int&amp;&amp;</code> is correct.</p>\n<p>The wording you cited in [expr.ref] was changed a couple years ago by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#616\" rel=\"nofollow noreferrer\">cwg 616</a>, and wasn't immediately adopted by implementations; see my answer <a href=\"https://stackoverflow.com/questions/35947296/about-binding-a-const-reference-to-a-sub-object-of-a-temporary/35947513\">here</a>. Basically, compilers had to adopt DR 616 and the paper on temporary expressions simultaneously, or they'd break code in which lifetime extension of an object, where we bind a reference to the object's <em>member</em>, is required. In the old model of implementations, only prvalues could designate objects for which lifetime extension is viable (although no such requirement existed in wording as pointed out by Johannes, it was vague wording before N3918, so\u2026).</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:46:07.020", "Id": "42042473", "Score": "4", "CreationDate": "2017-02-04T16:07:15.283", "LastActivityDate": "2017-02-05T22:36:41.200"}, "bq_ids": {"n4140": {"so_42037687_42037687_1": {"section_id": 5440, "quality": 1.0, "length": 12}, "so_42037687_42037687_0": {"section_id": 6007, "quality": 0.875, "length": 7}}, "n3337": {"so_42037687_42037687_1": {"section_id": 5235, "quality": 1.0, "length": 12}, "so_42037687_42037687_0": {"section_id": 5775, "quality": 0.75, "length": 6}}, "n4659": {"so_42037687_42037687_1": {"section_id": 6867, "quality": 1.0, "length": 12}, "so_42037687_42037687_0": {"section_id": 7506, "quality": 0.875, "length": 7}}}});