post_cb({"18140639": {"CommentCount": "0", "Body": "<pre><code>static int a;//file scope variable\nvoid getVol()\n{\n    static int b;//fixed duration\n}\n</code></pre>\n<p><strong>File scoped variables</strong> act exactly like global variables, except their use is restricted to the file in which they are declared (which means you can not extern them to other files).\n <strong>A fixed duration variable</strong> is one that retains it\u2019s value even after the scope in which it has been created has been exited! Fixed duration variables are only created (and initialized) once, and then they are persisted throughout the life of the program.\nCheck this link:<a href=\"http://www.learncpp.com/cpp-tutorial/43-file-scope-and-the-static-keyword/\" rel=\"nofollow\">http://www.learncpp.com/cpp-tutorial/43-file-scope-and-the-static-keyword/</a></p>\n", "CreationDate": "2013-08-09T05:40:05.960", "ParentId": "18140552", "Id": "18140639", "LastActivityDate": "2013-08-09T05:40:05.960", "PostTypeId": "2", "Score": "0", "OwnerUserId": "2286337"}, "18140584": {"LastActivityDate": "2013-08-09T05:51:05.637", "CommentCount": "4", "Body": "<p>Using the static keyword in block scope is exactly like a global variable with respect to where it is stored, however the difference is that it is only accessible within the block scope that it was declared. Recall that as you nest blocks the inner-most block takes precedence when referencing an identifier -- which the same applies to static variables.</p>\n<p>Consider the following snippet of code to illustrate my response:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nvoid f1( void ) {\n    static int a = 10;\n    {\n        static int a = 9;\n\n        printf( \"inner a = %d\\n\", a );\n    }\n\n    printf( \"outer a = %d\\n\", a );\n}\n\nint main( void ) {\n    for ( int i = 0; i &lt; 10; i++ ) {\n        printf( \"Calling the function f1.\\n\" );\n\n        f1();\n    }\n\n    return 0;\n}\n</code></pre>\n", "CreationDate": "2013-08-09T05:34:43.333", "LastEditDate": "2013-08-09T05:51:05.637", "ParentId": "18140552", "Id": "18140584", "LastEditorUserId": "2648745", "PostTypeId": "2", "Score": "0", "OwnerUserId": "2648745"}, "18140582": {"LastActivityDate": "2013-08-09T07:04:47.200", "CommentCount": "6", "Body": "<pre><code>static int a;\n</code></pre>\n<p>means the variable <code>a</code> is a file scope variable, i.e, it can't be seen from other files.</p>\n<pre><code>void getVol(..)\n { \n   static int b;\n }\n</code></pre>\n<p>means the local variable <code>b</code> has a life cycle that goes from the program starts to the program ends, i.e, you can assign it some value, while on the next call of the function, it remembers that value. </p>\n<p><code>c</code> and <code>d</code> are similar to <code>b</code>.</p>\n", "CreationDate": "2013-08-09T05:34:36.247", "LastEditDate": "2013-08-09T07:04:47.200", "ParentId": "18140552", "Id": "18140582", "LastEditorUserId": "1009479", "PostTypeId": "2", "Score": "1", "OwnerUserId": "1009479"}, "18140552": {"FavoriteCount": "1", "ViewCount": "2506", "Id": "18140552", "AcceptedAnswerId": "18140733", "Score": "4", "Title": "Difference between Static variable declared in different scopes", "LastEditorUserId": "2666744", "CommentCount": "0", "Body": "<p>What is the difference between declaring static variable inside a block and outside a block in a file? Eg, here, what is difference between static variables a,b,c,d? Can we declare a static variable that is accessible from all files of a program?</p>\n<pre><code>    static int a;\n    void getVol(..)\n    { \n       static int b;\n    }\n\n    int main()\n    {\n       static int c;\n       while(condition)\n       {\n           static int d;\n            ....\n       }\n    some code here;\n    return 0;\n    }\n</code></pre>\n", "Tags": "<c++><static>", "CreationDate": "2013-08-09T05:31:02.127", "LastEditDate": "2013-08-09T06:42:59.397", "LastActivityDate": "2017-03-12T15:02:38.690", "PostTypeId": "1", "AnswerCount": "6", "OwnerUserId": "2666744"}, "bq_ids": {"n4140": {"so_18140552_18140733_1": {"length": 44, "quality": 0.9777777777777777, "section_id": 3919}, "so_18140552_18140733_0": {"length": 30, "quality": 0.8823529411764706, "section_id": 3919}}, "n3337": {"so_18140552_18140733_0": {"length": 30, "quality": 0.8823529411764706, "section_id": 3779}, "so_18140552_18140733_1": {"length": 44, "quality": 0.9777777777777777, "section_id": 3779}}}, "18140655": {"CommentCount": "0", "Body": "<p>Static variable inside a block(<strong>local static variable</strong>) - </p>\n<ol>\n<li>It is not visible outside the block/function</li>\n<li>It's value retains in function calls as it is static</li>\n</ol>\n<p>Static variable outside a block(<strong>Global static variable</strong>) -</p>\n<ol>\n<li>It's scope is the entire file(like <strong>a</strong> in your program)</li>\n<li>It's value retains between function calls as it is static.</li>\n</ol>\n", "CreationDate": "2013-08-09T05:41:45.750", "ParentId": "18140552", "Id": "18140655", "LastActivityDate": "2013-08-09T05:41:45.750", "PostTypeId": "2", "Score": "1", "OwnerUserId": "2551262"}, "18140733": {"LastActivityDate": "2013-08-09T07:48:13.300", "CommentCount": "5", "Body": "<p>Ultimately, there is no difference. Ignoring (for the moment) static member functions, <code>static</code> means what it means -- but we see different parts of what it means under different conditions because some of what it means can also happen without the keyword.</p>\n<p>When you use the <code>static</code> keyword, the object being defined always has:</p>\n<ol>\n<li>static lifetime -- it exists for the entire life of the program.</li>\n<li>local visibility -- the name is not visible outside the scope in which it is declared.</li>\n</ol>\n<p>Both of these are true about a static variable whether defined inside or outside a block. One part or the other will happen by default, even if you don't use the <code>static</code> keyword, but if you use the keyword, you always get both.</p>\n<p><code>static</code> member functions are analogous, but since they're functions they don't exactly have lifetime -- all functions have static lifetime. A static member function has local visibility (i.e., its name is visible only with its class) and something sort of like \"static lifetime\" -- the function isn't bound to an instance of the class.</p>\n<p>Edit: for those who care about the specific time at which a block-level static variable is intialized, the gory details are as follows (\u00a76.7/4):</p>\n<blockquote>\n<p id=\"so_18140552_18140733_0\">The zero-initialization (8.5) of all block-scope variables with static storage duration (3.7.1) or thread storage duration (3.7.2) is performed before any other initialization takes place. Constant initialization (3.6.2) of a block-scope entity with static storage duration, if applicable, is performed before its block is first entered.</p>\n<p id=\"so_18140552_18140733_1\">An implementation is permitted to perform early initialization of other block-scope variables with static or thread storage duration under the same conditions that an implementation is permitted to statically initialize a variable with static or thread storage duration in namespace scope (3.6.2). Otherwise such a variable is initialized the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization.</p>\n</blockquote>\n<p>So, the variable will be zero-initialized very early in the startup of the program. Then, if other initialization has been specified, that will happen no later than when execution passes through the initialization (but could happen earlier than that). Note, however, the difference between constant initialization and other initialization. Just for example, consider something like this:</p>\n<pre><code>int g()  { return 2; }\n\nint f() { \n    goto bypass;\n\n    static int x = 1;\n    static int y = g();\n\nbypass:\n\n    std::cout &lt;&lt; x &lt;&lt; \"\\n\" &lt;&lt; y;\n}\n</code></pre>\n<p>Here, <code>x</code> is constant initialized, but <code>y</code> is not. Since <code>x</code> is constant initialized, it is initialized upon entry to the block, so when we print out its value, we should get <code>1</code>. <code>y</code>, however, is <em>not</em> constant initialized, and the goto means that execution never flows through its initialization -- therefore, it will retain the <code>0</code> that it was initialized with before any other initialization took place, so (with a properly functioning compiler) the output will be:</p>\n<pre><code>1 \n0\n</code></pre>\n", "CreationDate": "2013-08-09T05:50:02.210", "LastEditDate": "2013-08-09T07:48:13.300", "ParentId": "18140552", "Id": "18140733", "LastEditorUserId": "179910", "PostTypeId": "2", "Score": "10", "OwnerUserId": "179910"}, "42748809": {"CommentCount": "2", "Body": "<p>The following worked for me:</p>\n<pre><code>/*\n * How to create an object on the stack.\n * Also make sure that only 5 objects are created for the class\n*/\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass User {\nprivate:\n    int id;\n    static int counter;\n    static bool isOk;\npublic:\n    User();\n    ~User() {}\n    int getId() { return id; }\n    static int getCounter() { return counter; }\n    static bool getStatus() { return isOk; }\n    static void resetOk() { isOk = false; }\n    static void setOk() { isOk = true; }\n};\n\nUser::User() {\n    if(counter == 5) {\n        cout &lt;&lt; \"Not allowed to create more than 5 objects\" &lt;&lt; endl;\n        resetOk();\n        return;\n    }\n    counter++;\n    id = counter;\n    setOk();\n}\n\nint User::counter = 0;\nbool User::isOk = false;\n\nint main()\n{\n    // Create objects on stack\n    User user1;\n    (User::getStatus()) ? cout &lt;&lt; \"user1 id: \" &lt;&lt; user1.getId() &lt;&lt; endl :\n                          cout &lt;&lt; \"Object Construction Failed\" &lt;&lt; endl;\n    User user2;\n    (User::getStatus()) ? cout &lt;&lt; \"user2 id: \" &lt;&lt; user2.getId() &lt;&lt; endl :\n                          cout &lt;&lt; \"Object Construction Failed\" &lt;&lt; endl;\n    User user3;\n    (User::getStatus()) ? cout &lt;&lt; \"user3 id: \" &lt;&lt; user3.getId() &lt;&lt; endl :\n                          cout &lt;&lt; \"Object Construction Failed\" &lt;&lt; endl;\n    User user4;\n    (User::getStatus()) ? cout &lt;&lt; \"user4 id: \" &lt;&lt; user4.getId() &lt;&lt; endl :\n                          cout &lt;&lt; \"Object Construction Failed\" &lt;&lt; endl;\n    User user5;\n    (User::getStatus()) ? cout &lt;&lt; \"user5 id: \" &lt;&lt; user5.getId() &lt;&lt; endl :\n                          cout &lt;&lt; \"Object Construction Failed\" &lt;&lt; endl;\n    User user6;\n    (User::getStatus()) ? cout &lt;&lt; \"user6 id: \" &lt;&lt; user6.getId() &lt;&lt; endl :\n                          cout &lt;&lt; \"Object Construction Failed\" &lt;&lt; endl;\n    User user7;\n    (User::getStatus()) ? cout &lt;&lt; \"user7 id: \" &lt;&lt; user7.getId() &lt;&lt; endl :\n                          cout &lt;&lt; \"Object Construction Failed\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n", "CreationDate": "2017-03-12T14:48:19.663", "ParentId": "18140552", "Id": "42748809", "LastActivityDate": "2017-03-12T14:48:19.663", "PostTypeId": "2", "Score": "1", "OwnerUserId": "7674158"}});