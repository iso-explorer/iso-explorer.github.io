post_cb({"bq_ids": {"n4140": {"so_47034088_47236038_1": {"length": 18, "quality": 0.5806451612903226, "section_id": 124}, "so_47034088_47236038_3": {"length": 8, "quality": 0.5714285714285714, "section_id": 4706}}, "n3337": {"so_47034088_47236038_1": {"length": 16, "quality": 0.5161290322580645, "section_id": 118}}, "n4659": {"so_47034088_47236038_1": {"length": 30, "quality": 0.967741935483871, "section_id": 130}, "so_47034088_47236038_4": {"length": 10, "quality": 0.8333333333333334, "section_id": 130}, "so_47034088_47236038_3": {"length": 12, "quality": 0.8571428571428571, "section_id": 130}}}, "47236038": {"Id": "47236038", "PostTypeId": "2", "Body": "<p>After a small investigation it turns out that standard does not provide any explicit guarantees on the parenthesizeness of an expression produced from fold expression <a href=\"http://eel.is/c++draft/temp.variadic#9\" rel=\"nofollow noreferrer\">[temp.variadic]/9</a> (emphasis mine): </p>\n<blockquote>\n<p id=\"so_47034088_47236038_0\">The instantiation of a fold-expression produces:</p>\n<ul>\n<li>((E1 op E2) op \u22ef) op EN for a unary left fold,</li>\n<li>E1 op (\u22ef op (EN\u22121 op EN)) for a unary right fold,</li>\n<li>(((E op E1) op E2) op \u22ef) op EN for a binary left fold, and</li>\n<li>E1 op (\u22ef op (EN\u22121 op (EN op E))) for a binary right fold.</li>\n</ul>\n<p id=\"so_47034088_47236038_1\">In each case, op is the fold-operator, N is the number of elements in\n  the pack expansion parameters, and each Ei is generated by\n  instantiating the pattern and replacing each pack expansion parameter\n  with its ith element. For a binary fold-expression, E is generated by\n  instantiating the cast-expression that did not contain an unexpanded\n  parameter pack.</p>\n<p id=\"so_47034088_47236038_2\">Example:</p>\n<pre><code>template&lt;typename ...Args&gt;\n  bool all(Args ...args) { return (... &amp;&amp; args); }\n\nbool b = all(true, true, true, false);\n</code></pre>\n<p id=\"so_47034088_47236038_3\">Within the instantiation of all, the returned expression <strong>expands to\n  ((true &amp;&amp; true) &amp;&amp; true) &amp;&amp; false</strong>, which evaluates to false. \u2014\u2009end\n  example</p>\n<p id=\"so_47034088_47236038_4\">If N is zero for a unary fold-expression, the value of the expression\n  is shown in Table 14; if the operator is not listed in Table 14, the\n  instantiation is ill-formed.</p>\n</blockquote>\n<p>This would suggest that there is no guarantees about the parenthesize even when of the fold expression operator would affect the change of the operators precedence of the produced expression which seems to be a standard defect to me. E.g. <code>(ts + ...)*4</code> should be expanded to <code>ts1 + ts2*4</code> and not <code>(ts1 + ts2)*4</code> when literally apply the rule in the example from standard. </p>\n<p>Nevertheless as the single element parameter pack isn't considered in the fold expression production rule it is underspecified what should parameter pack produce in this case and hence both parenthesized version as well as unparenthesized one conform the standard.</p>\n", "LastEditorUserId": "4324224", "LastActivityDate": "2017-11-11T08:49:27.220", "Score": "0", "CreationDate": "2017-11-11T08:43:10.173", "ParentId": "47034088", "CommentCount": "0", "OwnerUserId": "4324224", "LastEditDate": "2017-11-11T08:49:27.220"}, "47034850": {"Id": "47034850", "PostTypeId": "2", "Body": "<p>If you want a reference to be returned in the single parameter case, you'll need an extra set of parenthesis<sup>*</sup> so that the parameter pack expansion expands references:</p>\n<pre><code>template &lt;class... Ts&gt;\ndecltype (auto) foo(Ts... ts) {\n      return ((ts-&gt;x) + ...);\n}\n</code></pre>\n<p>Unfortunately in the scenario of multiple arguments being passed, the result is still the summation of integers, which returns an rvalue, so your static assertion will fail then.</p>\n<hr>\n<p><strong>Why doesn't <code>((ts-&gt;x + ...))</code> evaluate to a reference?</strong></p>\n<p><strike>Because the fold expression will return an expiring <code>int</code> and then wrapping that <code>int</code> in another level of parentheses is still an <code>int</code>. When we use the inner parentheses <code>((ts-&gt;x) + ...))</code> the fold expression for a single argument returns <code>int&amp;</code>.</strike> It does for clang 6.0.0 but not gcc 8.0.0, so I'm not sure.</p>\n<p><sup>*The fold expression's parentheses (the parentheses involved in <code>(ts-&gt;x + ...)</code>) are required as part of the fold expression; saying <code>ts-&gt;x + ...</code> alone is ill-formed.</sup></p>\n</hr>", "LastEditorUserId": "4324224", "LastActivityDate": "2017-11-02T18:40:37.730", "Score": "7", "CreationDate": "2017-10-31T11:58:16.970", "ParentId": "47034088", "CommentCount": "16", "OwnerUserId": "27678", "LastEditDate": "2017-11-02T18:40:37.730"}, "47034088": {"ViewCount": "322", "Body": "<p>Consider an example:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;class... Ts&gt;\ndecltype (auto) foo(Ts... ts) {\n      return (ts-&gt;x + ...);\n}\n\nstruct X {\n    int x;\n};\n\nint main() {\n    X x1{1};\n    static_assert(std::is_reference_v&lt;decltype(foo(&amp;x1))&gt;);\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/wUw9GpDeSU7zxoVz\" rel=\"nofollow noreferrer\">[live demo]</a></p>\n<p><code>decltype(auto)</code> deduced from parenthesized lvalue should according to <a href=\"http://eel.is/c++draft/dcl.type.simple#4.4\" rel=\"nofollow noreferrer\">[cl.type.simple]/4.4</a> be deduced to lvalue reference. E.g.:</p>\n<pre><code>decltype(auto) foo(X *x) { // type of result == int&amp;\n    return (x-&gt;x);\n}\n</code></pre>\n<p>But the snipped triggers static_assert. Even if we compose expression into additional parentheses, e.g.:</p>\n<pre><code>return ((ts-&gt;x + ...));\n</code></pre>\n<p>It doesn't change the effect.</p>\n<p>Is there a point in the standard that prevents deduction of a fold-expression of a single element into the lvalue reference?</p>\n<hr>\n<p><strong>Edit</strong></p>\n<p>As a great point of <a href=\"https://stackoverflow.com/a/47034850/4324224\">Johannes Schaub - litb</a> clang actually does interpret the <a href=\"https://wandbox.org/permlink/xVSR8KlH5GwLnkK3\" rel=\"nofollow noreferrer\">double-parens-version of the code</a> as parenthesized lvalue and deduce lvalue reference. I'd interpret it as a gcc bug in this case. The version with single-parens-version is however still under the question. What puzzles me is that the version must be transformed into a parenthesized code at least in case of more than one element - to fulfil operator precedence. E.g.:</p>\n<pre><code>(x + ...)*4 -&gt; (x1 + x2)*4\n</code></pre>\n<p>What is the reason of the inconsistency?</p>\n</hr>", "Title": "On what base fold expression of a parameter pack consisting of a single element is transformed into unparenthesized expression", "CreationDate": "2017-10-31T11:18:28.907", "LastActivityDate": "2017-11-11T08:49:27.220", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-11-03T20:58:51.177", "LastEditorUserId": "4324224", "Id": "47034088", "Score": "9", "OwnerUserId": "4324224", "Tags": "<c++><language-lawyer><c++1z><decltype><fold-expression>", "AnswerCount": "2"}});