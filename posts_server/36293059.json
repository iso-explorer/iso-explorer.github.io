post_cb({"36293080": {"ParentId": "36293059", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In the case of unsigned integral types, the lowest appropriate number of bits get stored in the variable. (Brian's answer encompasses everything that I say here.)</p>\n<p>For example, <code>unsigned char a = 257</code> would result in <code>a=1</code>.</p>\n<p>The compiler (<code>gcc</code> in this case) should warn you when you do such assignments, e.g. <code>filename.c:line:column: warning: overflow in implicit constant conversion [-Woverflow]</code>.</p>\n", "OwnerUserId": "2483038", "LastEditorUserId": "2483038", "LastEditDate": "2016-03-29T19:20:23.080", "Id": "36293080", "Score": "1", "CreationDate": "2016-03-29T19:09:53.280", "LastActivityDate": "2016-03-29T19:20:23.080"}, "36293059": {"CommentCount": "2", "ViewCount": "59", "ClosedDate": "2016-03-29T22:39:20.053", "CreationDate": "2016-03-29T19:08:45.767", "LastActivityDate": "2016-03-29T19:20:23.080", "Title": "What happens to a value assigned to take up more than a types available space?", "PostTypeId": "1", "Id": "36293059", "Score": "2", "Body": "<p>e.g.</p>\n<pre><code>uint8_t value = 256;\n</code></pre>\n<p>debug output:</p>\n<pre><code>0\n</code></pre>\n<p>I've read that it does some sort of truncating? I'm not seeing exactly how, any links are appreciated.</p>\n", "Tags": "<c++><memory><uint8t>", "OwnerUserId": "6030385", "AnswerCount": "3"}, "36293182": {"ParentId": "36293059", "CommentCount": "0", "Body": "<p>I'll try to make sense of it along with you.</p>\n<p><code>uint8_t</code> is an 8-bit data type, or a byte.  It has 8 slots which can either be <code>1</code> or <code>0</code>.  <code>1111 1111</code> would be 255.  So if you ad one to it, it keeps carrying over.  255 + 1 in binary would be <code>1 0000 0000</code>, but since the data type can only store 8 bits, it drops the 1, and becomes <code>0000 0000</code>, which translates to the integer value <code>0</code>. </p>\n<p>At least, that's how I understand it works. </p>\n", "OwnerUserId": "5834954", "PostTypeId": "2", "Id": "36293182", "Score": "3", "CreationDate": "2016-03-29T19:15:17.367", "LastActivityDate": "2016-03-29T19:15:17.367"}, "bq_ids": {"n4140": {"so_36293059_36293141_1": {"section_id": 32, "quality": 0.9285714285714286, "length": 13}, "so_36293059_36293141_0": {"section_id": 31, "quality": 0.90625, "length": 29}}, "n3337": {"so_36293059_36293141_1": {"section_id": 29, "quality": 0.9285714285714286, "length": 13}, "so_36293059_36293141_0": {"section_id": 28, "quality": 0.90625, "length": 29}}, "n4659": {"so_36293059_36293141_1": {"section_id": 32, "quality": 0.7857142857142857, "length": 11}, "so_36293059_36293141_0": {"section_id": 31, "quality": 0.90625, "length": 29}}}, "36293141": {"ParentId": "36293059", "CommentCount": "1", "Body": "<p>According to [conv.integral]</p>\n<blockquote>\n<p id=\"so_36293059_36293141_0\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source\n  integer (modulo 2^<code>n</code> where <code>n</code> is the number of bits used to represent the unsigned type). [ <em>Note:</em> In a two\u2019s\n  complement representation, this conversion is conceptual and there is no change in the bit pattern (if there\n  is no truncation). \u2014 <em>end note</em> ]</p>\n<p id=\"so_36293059_36293141_1\">If the destination type is signed, the value is unchanged if it can be represented in the destination type (and\n  bit-field width); otherwise, the value is implementation-defined.</p>\n</blockquote>\n<p>So, for your example, you would reliably get zero; if you used <code>int8_t</code> instead of <code>uint8_t</code>, the result would be implementation-defined. (In contrast, if an operation on signed integers <em>overflows</em>, the result is undefined behaviour. Why the inconsistency? I don't know.)</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "36293141", "Score": "3", "CreationDate": "2016-03-29T19:12:48.283", "LastActivityDate": "2016-03-29T19:12:48.283"}});