post_cb({"32665178": {"ViewCount": "216", "Body": "<p>As we know, the code below is ill-formed because the member <code>x</code> is in a dependent base class. However, changing <code>x</code> to <code>this-&gt;x</code> on the indicated line would fix the error.</p>\n<pre><code>template &lt;typename T&gt;\nstruct B {\n    int x;\n};\ntemplate &lt;typename T&gt;\nstruct C : B&lt;T&gt; {\n    void f() {\n        int y = x; // Error!\n    }\n};\nint main() {\n    C&lt;int&gt; c;\n    c.f();\n}\n</code></pre>\n<p>I would like an explanation of how this behaviour is specified in the standard. According to [temp.dep]/3:</p>\n<blockquote>\n<p id=\"so_32665178_32665178_0\">In the definition of a class or class template, if a base class depends on a <em>template-parameter,</em> the base class\n  scope is not examined during unqualified name lookup either at the point of definition of the class template\n  or member or during an instantiation of the class template or member. </p>\n</blockquote>\n<p>This seems to explain why using <code>x</code> alone fails. The name <code>x</code> is looked up at the point of definition, and the base class scope is not examined. However, what if we use <code>this-&gt;x</code>? Now the name <code>x</code> is dependent and its lookup is postponed until instantiation. But the quoted paragraph seems to imply that <code>x</code> should not be found <em>even at instantiation time,</em> since the lookup of <code>x</code> in <code>this-&gt;x</code> is <em>still</em> <strong>unqualified</strong> lookup.</p>\n<p>Obviously implementations don't behave this way, and it's widely understood that the base class scope <em>is</em> searched once the template is instantiated.</p>\n<ol>\n<li>Have I misinterpreted the quoted paragraph?</li>\n<li>Is there a paragraph that specifies the \"correct\" behaviour?</li>\n</ol>\n", "AcceptedAnswerId": "32665689", "Title": "What is the rule that allows `this->` to access members of dependent base classes?", "CreationDate": "2015-09-19T06:47:04.180", "Id": "32665178", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-10-28T09:58:29.300", "LastEditorUserId": "963864", "LastActivityDate": "2015-10-28T09:58:29.300", "Score": "15", "OwnerUserId": "481267", "Tags": "<c++><templates><language-lawyer><name-lookup><dependent-name>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_32665178_32665178_0": {"length": 27, "quality": 1.0, "section_id": 190}, "so_32665178_32665689_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 7127}}, "n3337": {"so_32665178_32665178_0": {"length": 27, "quality": 1.0, "section_id": 184}, "so_32665178_32665689_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 6871}}, "n4659": {"so_32665178_32665178_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 195}, "so_32665178_32665689_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 8628}}}, "32665689": {"Id": "32665689", "PostTypeId": "2", "Body": "<p>Class member access expressions (5.2.5. [expr.ref]) don't use unqualified lookup rules, they use class member access lookup rules (3.4.5 [basic.lookup.classref]).</p>\n<blockquote>\n<p id=\"so_32665178_32665689_0\">(2) If the <em>id-expression</em> in a class member access (5.2.5) is an unqualified-id, and the type of the object expression\n  is of a class type <code>C</code>, the unqualified-id is looked up in the scope of class <code>C</code>. </p>\n</blockquote>\n", "LastActivityDate": "2015-09-19T07:44:40.673", "CommentCount": "0", "CreationDate": "2015-09-19T07:44:40.673", "ParentId": "32665178", "Score": "7", "OwnerUserId": "775806"}});