post_cb({"bq_ids": {"n4140": {"so_22824974_22825016_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 5785}, "so_22824974_22825016_2": {"length": 18, "quality": 1.0, "section_id": 5873}, "so_22824974_22825016_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 4605}}, "n3337": {"so_22824974_22825016_2": {"length": 18, "quality": 1.0, "section_id": 5644}, "so_22824974_22825016_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 5558}, "so_22824974_22825016_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 4423}}, "n4659": {"so_22824974_22825016_2": {"length": 18, "quality": 1.0, "section_id": 7356}, "so_22824974_22825016_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 5962}, "so_22824974_22825016_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 7242}}}, "22825016": {"Id": "22825016", "PostTypeId": "2", "Body": "<p>Since this question is likely to be closed fast (it fits in well with the original idea of SO, but not with current \"policy\") I'm adding this answer quickly so that I can continue writing it. I disagree that strongly with current policy, for this particular kind of case. So\u2026</p>\n<h1>About the topic.</h1>\n<p>Memory management is an extremely large topic. However, your questions about it, e.g. \u201cdoes the memory start storing at address one\u201d, concern the very basics. And this is small topic, possible to answer.</p>\n<h1>The C++ memory model.</h1>\n<h2>/ Bytes.</h2>\n<p>As seen from the inside of a C++ program, memory is a not necessarily contiguous sequence of <strong>bytes</strong>. A byte is in this context the smallest addressable unit of electronic memory (or more generally of computer main memory, if other technologies should become popular), and corresponds to C++ <code>char</code>. The C++11 standard describes it thusly, in its \u00a71.7/1:</p>\n<blockquote>\n<p id=\"so_22824974_22825016_0\">\u201cA byte is at least large enough to contain\n  any member of the basic execution character set (2.3) and the eight-bit code units of the Unicode UTF-8\n  encoding form and is composed of a contiguous sequence of bits, the number of which is implementation-defined\u201d</p>\n</blockquote>\n<p>Essential facts about C++ bytes:</p>\n<ul>\n<li><p>A byte is at least 8 bits.<br>\nIn practice it\u2019s either 8 bits or 16 bits. The latter size is used on some digital signal processors, e.g. from Texas Instruments.</br></p></li>\n<li><p>The number of bits per byte is given by <code>CHAR_BIT</code>.<br>\nThis macro symbol is defined by the <code>&lt;limits.h&gt;</code> C header. It yields a value that can be used at compile time. An alternative way to designate that value is <code>std::numeric_limits&lt;unsigned char&gt;::digits</code>, after including the <code>&lt;limits&gt;</code> C++ header.</br></p></li>\n<li><p><code>unsigned char</code> is commonly used as a byte type.<br>\nAll three variants of <code>char</code>, namely plain <code>char</code>, <code>unsigned char</code> and <code>signed char</code>, are guaranteed to map to byte, but there is no dedicated standard C++ byte type.</br></p></li>\n</ul>\n<h2>/ Locations.</h2>\n<p>A value of a built-in type such as <code>double</code> typically occupies a small number of bytes, contiguous in memory. The C++ standard, in its \u00a71.7/3, refers to that, the bytes of a basic value, as a memory <strong>location</strong>. The essential fact about locations is that two threads can update separate memory locations without interfering with each other, but this is not guaranteed if they update separate bytes in the same memory location.</p>\n<p>The <strong>sizeof</strong> operator produces the number of bytes of a value of a specified type.</p>\n<p>By definition, in C++11 in \u00a75.3.3/1, <code>sizeof(char)</code> is 1.</p>\n<h2>/ Addresses.</h2>\n<p>To quote the C++11 standard\u2019s \u00a71.7/1, \u201cEvery byte has a unique address.\u201d.</p>\n<p>The standard doesn\u2019t define <strong>address</strong> further, but in practice, on modern machines the addresses that a C++ program deals with are bitpatterns of a fixed size, typically 32 or 64 bits.</p>\n<p>When a C++ program deals directly with addresses it must do so via pointers, which are adresses with associated types. As a special case the pointer type <code>void*</code> represents untyped addresses, and as such must be able to store the largest address bitpatterns. Thus, on a modern machine <code>CHAR_BIT*sizeof(void*)</code> is in practice the number of bits of an address as seen from inside a C++ program.</p>\n<p>Pointer values (addresses) are only guaranteed comparable via the built-in <code>==</code>, <code>&lt;</code> etc. if they point within the same array, extended with a hypothetical extra item at the end. However, the standard library offers a more general pointer comparision. C++ \u00a720.8.5/8:</p>\n<blockquote>\n<p id=\"so_22824974_22825016_1\">\u201cFor templates <strong><code>greater</code></strong>, <strong><code>less</code></strong>, <strong><code>greater_equal</code></strong>, and <strong><code>less_equal</code></strong>, the specializations for any pointer type\n  yield a total order, even if the built-in operators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> do not.\u201d</p>\n</blockquote>\n<p>Thus depending on the machine addresses, as seen from C++, either are or can be mapped to integer values. But this does <em>not</em> mean that they can be mapped to <code>int</code>. Depending on the C++ implementation type <code>int</code> may be too small to hold addresses.</p>\n<p>There are very few guarantees about what direction addresses increase in, e.g. that subsequent varaible declarations give you locations with increasing addresses. However, there is such a guarantee for non-static data members that (C++03) have no intervening access specifier or (C++11) have the same access, e.g. <code>public</code>. C++11 \u00a79.2/14:</p>\n<blockquote>\n<p id=\"so_22824974_22825016_2\">\u201cNonstatic data members of a (non-union) class with the same access control (Clause 11) are allocated so\n  that later members have higher addresses within a class object.\u201d</p>\n</blockquote>\n<p>There is also such a guarantee for items of an array.</p>\n<p>The literal <strong><code>0</code></strong>, used where a pointer value is expected, denotes the <strong>nullpointer</strong> of the relevant type. For the built in relational operators C++ supports comparing a non-0 pointer to 0 via <code>==</code> and <code>!=</code>, but does not support magnitude comparisons. For absolute safety pointer comparisons can be done via e.g. <code>std::less</code> etc., as noted above.</p>\n<h2>/ Objects.</h2>\n<p>An <strong>object</strong> is \u201ca region of storage\u201d, according to C++11 \u00a71.8/1. That paragraph also notes that an object \u201chas a <em>type</em>\u201d, which determines how the bits in the memory region are interpreted. In order to create an object you can simply declare a variable (a <strong>variable</strong> is an object with a name) or e.g. use a <code>new</code>-expression.</p>\n<p>Worth noting:</p>\n<ul>\n<li>A <strong>region</strong>, in the formal sense of the C++ standard, is <em>not necessarily contiguous</em>.</li>\n</ul>\n<p>As far as I can determine this fact is only implicit in the standard, in that an object can be a sub-object, which can be an object of a class with <code>virtual</code> inheritance (sharing a common base class sub-object), in a context of multiple inheritance, where that object \u2013 by definition a region of storage \u2013 is necessarily spread out in memory.</p>\n<p>Dave Abrahams once contended that the intent was to support C++ implementations where objects could be spread around also in other situations than multiple <code>virtual</code> inheritance, but as far as I know no C++ implementations do that. In particular, a variable or any other <strong>most derived object</strong> (object that isn\u2019t part of some other object) <em>o</em> is in practice a contiguous region of bytes, with all the bytes contained in the <code>sizeof(o)</code> bytes extending from and including the object\u2019 <strong>start address</strong>.</p>\n<h2>/ Arrays.</h2>\n<p>An <strong>array</strong>, in the sense of array created via the <code>[]</code> notation, is contiguous sequence of objects of some fixed type <code>T</code>. Each item (object in the array) has an associated <strong>index</strong>, starting at 0 for the first item and contigously increasing. To refer to the first item of an array <code>a</code>, you can use square bracket notation and write <code>a[0]</code>.</p>\n<p>If the first item has start address <em>a</em>, then iten number <em>n</em> has start address <em>a</em> + <i>n</i>*<code>sizeof(T)</code>.</p>\n<p>In other words, addresses increase in the same direction as the item indices, with item 0 placed lowest in memory.</p>\n<h1>Operating system processes.</h1>\n<p>A C++ program can run on just about any kind of computer, from the smallest embedded chips to the larges supercomputers. In the small computer end of the scale there is not necessarily any operating system or memory management hardware, with the program accessing the computer\u2019s physical memory and other hardware directly. But on e.g. a typical cell phone or desktop computer the program will be executed in an operating system <strong>process</strong> that isolates the program from direct access to the computer.</p>\n<p>In particular, the addresses that an OS process see and manage, may not necessarily be physical memory addresses. Instead they may be just <strong>logical addresses</strong>, which transparently to your C++ code are very efficiently mapped to <strong>physical addresses</strong>. Among other things this allows you to run two or more instances of your program at the same time, without their memory addressing clashing \u2013 because the instances\u2019 logical addresses are mapped to different parts of physical memory.</p>\n<p>Practical note: as a security measure, unless otherwise specified a C++ program for Windows, created with Microsoft\u2019s tools, will have have parts placed at different logical addresses in different instances, to make it more difficult for malware to exploit known locations. Thus you can\u2019t even rely on fixed logical addresses. And so where objects will be placed, and so on, is not just compiler dependent and operating system dependent, but can depend on the particular instance of the program\u2026</p>\n<p>Still you have the guarantees discussed above, namely \u2026</p>\n<ul>\n<li><p>increasing addresses for sub-objects with the same access (e.g. <code>public</code>) within the same outer object, and</p></li>\n<li><p>increasing addresses in the direction of higher indices in an array.</p></li>\n</ul>\n", "LastEditorUserId": "464581", "LastActivityDate": "2014-04-03T01:43:18.880", "Score": "2", "CreationDate": "2014-04-02T23:25:13.333", "ParentId": "22824974", "CommentCount": "2", "LastEditDate": "2014-04-03T01:43:18.880", "OwnerUserId": "464581"}, "22824974": {"ViewCount": "101", "Body": "<p>So already know there's like 'blocks' or units of memory called.. bytes? and different variables take up different amounts of bytes. But my real question is when you create a new program, say on the compiler, does the memory start storing at address one. And using a pointer you can see what fills what blocks of memory? Also is this ram? Sorry for so much wondering by trying to get a grasp on the lower level part of c++ to get a hint of how memory is stored and such, thanks.</p>\n", "Title": "Curious to know how the memory part in c++ works", "CreationDate": "2014-04-02T23:20:48.453", "LastActivityDate": "2014-04-03T01:43:18.880", "CommentCount": "3", "PostTypeId": "1", "ClosedDate": "2014-04-03T00:10:46.767", "Id": "22824974", "Score": "1", "OwnerUserId": "3491560", "Tags": "<c++><memory>", "AnswerCount": "3"}, "22825015": {"Id": "22825015", "PostTypeId": "2", "Body": "<p>Objects in C++ occupy memory, and if you can obtain the address of an object, you can inspect that memory. It's completely unspecified where and how that memory comes about; it's supposed to be provided by \"the platform\", i.e. the compiler knows how to generate machine code that interacts with the system's notion of memory in such a way that every object fits into some memory. You also have platform-provided services (<code>malloc</code> and <code>operator new</code>) to give you memory directly for your own use.</p>\n", "LastActivityDate": "2014-04-02T23:25:11.770", "Score": "2", "CreationDate": "2014-04-02T23:25:11.770", "ParentId": "22824974", "CommentCount": "1", "OwnerUserId": "596781"}, "22825511": {"Id": "22825511", "PostTypeId": "2", "Body": "<p>malloc and operator new are the library calls for allocating memory in C++ program. It is important to note that they aren't provided by the platform, they are provided by the standard library. All that is specified in C++ standard is that these calls should return a memory address that is allocated for the program code.</p>\n<p>The platform usually have a different API for allocating memory from the OS, e.g. in Linux there are mmap() and brk() system calls, in Windows there is VirtualAlloc() system call. Malloc and operator new uses these system specific syscalls to request memory from the OS, and then suballocate them to the program. In the OS kernel itself, these system calls usually modifies MMU entries (on architectures that uses MMU).</p>\n", "LastActivityDate": "2014-04-03T00:16:54.033", "Score": "0", "CreationDate": "2014-04-03T00:16:54.033", "ParentId": "22824974", "CommentCount": "0", "OwnerUserId": "309412"}});