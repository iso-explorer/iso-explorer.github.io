post_cb({"bq_ids": {"n4140": {"so_43789366_43789366_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 300}}, "n3337": {"so_43789366_43789366_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 291}}, "n4659": {"so_43789366_43789366_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 307}}}, "43789366": {"ViewCount": "41", "Body": "<p>I'm using gcc 4.8.4.</p>\n<p>The following code fails with a compiler error from line 22 (indicated):</p>\n<blockquote>\n<p id=\"so_43789366_43789366_0\">invalid initialization of reference of type \u2018int*&amp;&amp;\u2019 from expression of type \u2018int* const\u2019</p>\n</blockquote>\n<p>Why isn't the call to <code>square(ptr)</code> using the lvalue version of <code>square</code>?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nint square(int* &amp;&amp;num) {\n    std::cout &lt;&lt; \"rvalue\" &lt;&lt; std::endl;\n    std::unique_ptr&lt;int&gt; x(num);\n    const auto ptr = x.get();\n    return square(ptr);  // this is line 22\n}\n\nint square(const int* &amp;num) {\n    std::cout &lt;&lt; \"lvalue\" &lt;&lt; std::endl;\n    return (*num) * (*num);\n}\n\nint main() {\n    std::unique_ptr&lt;int&gt; up(new int);\n    *up = 5;\n    std::cout &lt;&lt; square(up.release()) &lt;&lt; std::endl;\n}\n</code></pre>\n", "AcceptedAnswerId": "43789525", "Title": "Overloading rvalue/const lvalue for pointer", "CreationDate": "2017-05-04T17:33:24.997", "Id": "43789366", "CommentCount": "1", "LastEditDate": "2017-05-04T17:42:26.510", "PostTypeId": "1", "LastEditorUserId": "4850040", "LastActivityDate": "2017-05-05T07:51:56.470", "Score": "1", "OwnerUserId": "931760", "Tags": "<c++><c++11><rvalue-reference>", "AnswerCount": "2"}, "43789525": {"Id": "43789525", "PostTypeId": "2", "Body": "<p>You have order problem:</p>\n<pre><code>return square(ptr);\n</code></pre>\n<p>only see <code>int square(int* &amp;&amp;num)</code> declaration and is invalid</p>\n<p>And <code>int square(const int* &amp;num)</code> sould be <code>int square(int*const &amp;num)</code>.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/233caf1bac03a95b\" rel=\"nofollow noreferrer\">Fixed version</a>.</p>\n", "LastActivityDate": "2017-05-04T17:42:38.017", "CommentCount": "2", "CreationDate": "2017-05-04T17:42:38.017", "ParentId": "43789366", "Score": "3", "OwnerUserId": "2684539"}, "43799391": {"Id": "43799391", "PostTypeId": "2", "Body": "<p>At line 22, the only definition of <code>square()</code> in scope is the one that takes an rvalue reference - <code>int square(int* &amp;&amp;)</code>.  <code>ptr</code> is an lvalue, so the error message explains the difference in type.</p>\n<p>If you swap the order of the function definitions so that <code>int square(const int* &amp;)</code> is also in scope, you'll still get the same error.  That is because you have a pointer to a mutable <code>int</code>, so the lvalue function is still not a candidate.</p>\n<p>You can change that to accept a const reference to a pointer to int:</p>\n<pre><code>int square(int *const&amp; num) {\n    std::cout &lt;&lt; \"lvalue\" &lt;&lt; std::endl;\n    return (*num) * (*num);\n}\n</code></pre>\n<p>And now the program compiles and runs.</p>\n<p>Obviously, this can be simplified to accept <code>num</code> by value, but I'm guessing you want to make this work with something more heavyweight than <code>int</code>.</p>\n<h1>Rewritten example</h1>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nint square(int *const&amp; num) {\n    std::cout &lt;&lt; \"lvalue\" &lt;&lt; std::endl;\n    return *num * *num;\n}\n\nint square(int*&amp;&amp; num) {\n    std::cout &lt;&lt; \"rvalue\" &lt;&lt; std::endl;\n    std::unique_ptr&lt;int&gt; x(num);\n    const auto ptr = x.get();\n    return square(ptr);\n}\n\nint main() {\n    auto up = std::make_unique&lt;int&gt;(5);\n    std::cout &lt;&lt; square(up.release()) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>As a side note, I try to avoid <code>unique_ptr::release()</code> - it can be useful when interfacing with pre-C++11 code that takes ownership of naked pointers, but it's hard to reason about it without following the code in detail. Modern code should prefer to pass the smart pointer:</p>\n<pre><code>int square(std::unique_ptr&lt;int&gt;&amp;&amp; x) {\n    std::cout &lt;&lt; \"rvalue\" &lt;&lt; std::endl;\n    const auto ptr = x.get();\n    return square(ptr);\n}\n\nint main() {\n    auto up = std::make_unique&lt;int&gt;(5);\n    std::cout &lt;&lt; square(std::move(up)) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Here, it's much clearer that <code>square()</code> will take ownership of its argument.</p>\n", "LastActivityDate": "2017-05-05T07:51:56.470", "CommentCount": "0", "CreationDate": "2017-05-05T07:51:56.470", "ParentId": "43789366", "Score": "1", "OwnerUserId": "4850040"}});