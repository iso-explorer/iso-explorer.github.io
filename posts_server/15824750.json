post_cb({"15824750": {"ViewCount": "902", "Body": "<p>The code is as follows:</p>\n<pre><code> #include &lt;iostream&gt;\n using namespace std;\n\n class A {\n\n };\n\n A rtByValue() {\nreturn A();\n }\n\n void passByRef(A &amp;aRef) {\n    // do nothing\n }\n\n int main() {\n    A aa;\n    rtByValue() = aa;            // compile without errors\n    passByRef(rtByValue());      // compile with error \n\n    return 0;\n }\n</code></pre>\n<p>The g++ compiler gives the following error:</p>\n<pre><code>d.cpp: In function \u2018int main()\u2019:\nd.cpp:19:23: error: invalid initialization of non-const reference of type \u2018A&amp;\u2019 from an rvalue of type \u2018A\u2019\nd.cpp:12:6: error: in passing argument 1 of \u2018void passByRef(A&amp;)\u2019\n</code></pre>\n<p>It says that I can't pass an rvalue as an argument of a non-const reference, but what I'm confused about is why I can assign to this rvalue, just as the code shows.</p>\n", "AcceptedAnswerId": "15825240", "Title": "C++ function returns a rvalue, but that can be assigned a new value?", "CreationDate": "2013-04-05T02:04:13.250", "Id": "15824750", "CommentCount": "15", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-04-05T03:10:07.923", "LastEditorUserId": "777186", "LastActivityDate": "2013-04-05T03:25:26.033", "Score": "6", "OwnerUserId": "1679133", "Tags": "<c++><assignment-operator><temporary><rvalue>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_15824750_15825240_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 7234}}, "n3337": {"so_15824750_15825240_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 6978}}}, "15825396": {"PostTypeId": "2", "Body": "<p>Because you can (but shouldn't!) override operator= such that calling it on an rvalue makes sense.  Consider the following code:</p>\n<pre><code>#include&lt;iostream&gt;\n\nusing namespace std;\n\nclass foo;\n\nfoo* gotAssigned = NULL;\nint assignedto = -1;\n\nclass foo {\npublic:\n  foo(int v) : val(v) {}\n  foo&amp; operator=(int v) {\n    assignedto=v;\n    gotAssigned = this;\n    val = v;\n    return *this;\n  }\n  int val;\n};\n\nfoo theFoo(2);\n\nfoo returnTheFooByValue() {\n  return theFoo;\n}\n\nmain() {\n  returnTheFooByValue()=5;\n  cout &lt;&lt; \"[\" &lt;&lt; assignedto &lt;&lt; \"] \" &lt;&lt; theFoo.val &lt;&lt; \" versus \" &lt;&lt; gotAssigned-&gt;val &lt;&lt; endl;\n}\n</code></pre>\n<p>Now let's compile it a few ways:</p>\n<pre><code>$ g++ -O0 -o rveq rveq.cc &amp;&amp; ./rveq\n[5] 2 versus 5\n$ g++ -O1 -o rveq rveq.cc &amp;&amp; ./rveq\n[5] 2 versus 2\n$ g++ -O4 -o rveq rveq.cc &amp;&amp; ./rveq\n[5] 2 versus -1218482176\n</code></pre>\n<p>I can't promise you'll see the same results.</p>\n<p>As you can see, the assignment happens, but any attempt to use the object that got assigned results in implementation-specific behaviour.</p>\n<p>Incidentaly, this <em>only</em> applies to user-defined types.  This code:</p>\n<pre><code>int v(){\n  return 2;\n}\n\nmain(){\n  v()=4;\n}\n</code></pre>\n<p>doesn't compile.</p>\n", "LastActivityDate": "2013-04-05T03:25:26.033", "Id": "15825396", "CommentCount": "1", "CreationDate": "2013-04-05T03:25:26.033", "ParentId": "15824750", "Score": "1", "OwnerUserId": "1944458"}, "15824826": {"PostTypeId": "2", "Body": "<p>@ddriver This outputs number 7, as I would expect.</p>\n<pre><code>#include &lt;iostream&gt;\n using namespace std;\n\n class A {\n public:\n     int i;\n     A() {i = 0x07;}\n };\n\n A rtByValue() {\nreturn A();\n }\n\n void passByRef(A &amp;aRef) {\n     cout &lt;&lt; aRef.i;\n }\n\n int main() {\n    passByRef(rtByValue());\n    return 0;\n }\n</code></pre>\n", "LastActivityDate": "2013-04-05T02:16:33.937", "Id": "15824826", "CommentCount": "11", "CreationDate": "2013-04-05T02:16:33.937", "ParentId": "15824750", "Score": "0", "OwnerUserId": "2217769"}, "15825240": {"PostTypeId": "2", "Body": "<p>Passing the rvalue <code>rtByValue()</code> to a function that expects an lvalue reference doesn't work because this would require the lvalue reference argument to be initialized from an rvalue. \u00a78.5.3/5 describes how lvalue references can be initialized \u2013 I won't quote it in full, but it basically says that an lvalue reference can be initialized</p>\n<ul>\n<li>either from another lvalue reference</li>\n<li>or something that can be converted to an lvalue reference of an intermediary type</li>\n<li>or from an rvalue, but only if the lvalue reference we initialize is a const-reference</li>\n</ul>\n<p>Since the argument we need to initialize is not a const-reference, none of this applies.</p>\n<p>On the other hand,</p>\n<pre><code>rtByValue() = aa; \n</code></pre>\n<p>i.e., assigning to a temporary object, is possible because of:</p>\n<blockquote>\n<p id=\"so_15824750_15825240_0\">(\u00a73.10/5) An lvalue for an object is necessary in order to modify the object except that an rvalue of class type can also be used to modify its referent under certain circumstances. [ Example: a member function called for an object (9.3) can modify the object. \u2014 end example ]</p>\n</blockquote>\n<p>So this works only because <code>A</code> is of class-type, and the (implicitly defined) assignment operator is a member function. (See <a href=\"https://stackoverflow.com/questions/6466253/if-temporaries-are-implicitly-non-modifiable-how-does-this-work\">this related question</a> for further details.)</p>\n<p>(So, if <code>rtByValue()</code> were to return, for example, an <code>int</code>, then the assignment wouldn't work.)</p>\n", "LastActivityDate": "2013-04-05T03:06:54.483", "LastEditorUserId": "-1", "Id": "15825240", "CommentCount": "0", "CreationDate": "2013-04-05T03:06:54.483", "ParentId": "15824750", "Score": "8", "OwnerUserId": "777186", "LastEditDate": "2017-05-23T10:28:45.303"}});