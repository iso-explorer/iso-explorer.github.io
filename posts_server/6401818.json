post_cb({"6401972": {"Id": "6401972", "PostTypeId": "2", "Body": "<p>I don't think that \"too many steps to figure on its own\" as DeadMG pointed out is the reason. I've had constructs with 3-4 conversions, and the compiler always figured them out just fine.</p>\n<p>I believe the problem is rather that the compiler is not allowed to convert a <code>const</code> reference to a non-<code>const</code>reference on its own behalf (it is only allowed to do that when you explicitly tell it with a cast).<br>\nAnd since the reference to the temporary object that is passed to the copy constructor is <code>const</code>, but the copy constructor is not, it doesn't find a suitable function.</br></p>\n<p><strong>EDIT:</strong> I didn't find any \"real\" code (see comments below) but constructed a multi-zigzag-convert example that actually compiles without errors under gcc 4.5. Note that this compiles just fine with <code>-Wall -Wextra</code> too, which frankly surprises me.</p>\n<pre><code>struct B\n{\n    signed int v;\n    B(unsigned short in) : v(in){}\n};\n\nstruct C\n{\n    char v;\n    C(int in) : v(in){}\n};\n\nstruct A\n{\n    int v;\n    A(B const&amp; in) : v(in.v){}\n    operator C() { return C(*this); }\n};\n\nenum X{ x = 1 };\n\nint main()\n{\n    C c = A(x);\n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "572743", "LastActivityDate": "2011-06-19T11:50:24.203", "Score": "5", "CreationDate": "2011-06-19T10:59:19.737", "ParentId": "6401818", "CommentCount": "8", "OwnerUserId": "572743", "LastEditDate": "2011-06-19T11:50:24.203"}, "6402127": {"Id": "6402127", "PostTypeId": "2", "Body": "<p>The error is quite clear on the list of candidates that were rejected. The problem is that implicit conversion sequences involving a user defined conversion in the C++ language are limited to a single user defined conversion:</p>\n<blockquote>\n<p id=\"so_6401818_6402127_0\">\u00a713.3.3.1.2 [over.ics.user]/1 A user-defined conversion sequence consists of an initial standard conversion sequence followed by a user-defined conversion (12.3) followed by a second standard conversion sequence.</p>\n</blockquote>\n<p>The standard conversion sequences are defined in \u00a74[conv]:</p>\n<blockquote>\n<p id=\"so_6401818_6402127_1\">[...] A standard conversion sequence is a sequence of standard conversions in the following order</p>\n<ul>\n<li><p id=\"so_6401818_6402127_2\">Zero or one conversion from the following set: lvalue-to-rvalue conversion, array-to-pointer conversion, and function-to-pointer conversion.</p></li>\n<li><p id=\"so_6401818_6402127_3\">Zero or one conversion from the following set: integral promotions, floating point promotion, integral conversions, floating point conversions, floating-integral conversions, pointer conversions, pointer to member conversions, and boolean conversions.</p></li>\n<li><p id=\"so_6401818_6402127_4\">Zero or one qualification conversion.</p></li>\n</ul>\n</blockquote>\n<p>The problem is that your code cannot get from point a) <code>int</code> rvalue to point b) <code>B</code> by applying a single user defined conversion. </p>\n<p>In particular, all conversion sequences that are available start with a user defined conversion (implicit constructor <code>A(int)</code>) that yield an <code>A</code> rvalue. From there, the rvalue cannot be bound to a non-const reference to call <code>A::A( A&amp; )</code>, so that path is discarded. All the other paths require a second user defined conversion that is not allowed, and in fact the only other path that would get us to point b) requires two other user defined conversions for a total of 3.</p>\n", "LastActivityDate": "2011-06-19T11:37:47.420", "CommentCount": "1", "CreationDate": "2011-06-19T11:37:47.420", "ParentId": "6401818", "Score": "4", "OwnerUserId": "36565"}, "6401880": {"Id": "6401880", "PostTypeId": "2", "Body": "<p>The error lists all the <em>potential</em> candidates to be used, and why they cannot be used. It lists the conversion from <code>B</code> because its one of the constructors, but it doesn't know how to use it in this case, so it doesn't.</p>\n", "LastActivityDate": "2011-06-19T10:37:51.377", "CommentCount": "2", "CreationDate": "2011-06-19T10:37:51.377", "ParentId": "6401818", "Score": "0", "OwnerUserId": "618400"}, "bq_ids": {"n4140": {"so_6401818_6402127_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 620}, "so_6401818_6402127_2": {"length": 11, "quality": 1.0, "section_id": 0}, "so_6401818_6402127_4": {"length": 4, "quality": 1.0, "section_id": 0}, "so_6401818_6402127_1": {"length": 6, "quality": 1.0, "section_id": 0}, "so_6401818_6402127_3": {"length": 24, "quality": 1.0, "section_id": 0}}, "n3337": {"so_6401818_6402127_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 610}, "so_6401818_6402127_3": {"length": 24, "quality": 1.0, "section_id": 0}, "so_6401818_6402127_4": {"length": 4, "quality": 1.0, "section_id": 0}, "so_6401818_6402127_1": {"length": 6, "quality": 1.0, "section_id": 0}, "so_6401818_6402127_2": {"length": 11, "quality": 1.0, "section_id": 0}}, "n4659": {"so_6401818_6402127_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 646}, "so_6401818_6402127_3": {"length": 20, "quality": 0.8333333333333334, "section_id": 0}, "so_6401818_6402127_4": {"length": 4, "quality": 1.0, "section_id": 0}, "so_6401818_6402127_1": {"length": 6, "quality": 1.0, "section_id": 0}, "so_6401818_6402127_2": {"length": 11, "quality": 1.0, "section_id": 0}}}, "6401818": {"ViewCount": "3728", "Body": "<p>Consider the following C++ code:</p>\n<pre><code>struct B { };\nstruct A\n{\n        A(int);\n        A(A&amp;); // missing const is intentional\n        A(B);\n        operator B();\n};\n\nA f()\n{\n        // return A(1); // compiles fine\n        return 1; // doesn't compile\n}\n</code></pre>\n<p>This compiles fine on MSVC++ 2010 (in fact, on MSVC it even works if I remove <code>B</code> altogether). It doesn't on GCC 4.6.0:</p>\n<pre><code>conv.cpp: In function \u2018A f()\u2019:\nconv.cpp:13:9: error: no matching function for call to \u2018A::A(A)\u2019\nconv.cpp:13:9: note: candidates are:\nconv.cpp:6:2: note: A::A(B)\nconv.cpp:6:2: note:   no known conversion for argument 1 from \u2018A\u2019 to \u2018B\u2019\nconv.cpp:5:2: note: A::A(A&amp;)\nconv.cpp:5:2: note:   no known conversion for argument 1 from \u2018A\u2019 to \u2018A&amp;\u2019\nconv.cpp:4:2: note: A::A(int)\nconv.cpp:4:2: note:   no known conversion for argument 1 from \u2018A\u2019 to \u2018int\u2019\n</code></pre>\n<p>What's confusing me is the message <code>no known conversion for argument 1 from \u2018A\u2019 to \u2018B\u2019</code>. How can this be true considering that <code>A::operator B()</code> is very well defined?</p>\n", "AcceptedAnswerId": "6402127", "Title": "Non-const copy constructor and implicit conversions on return value", "CreationDate": "2011-06-19T10:21:22.100", "Id": "6401818", "CommentCount": "5", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2011-06-19T10:30:44.533", "LastEditorUserId": "172594", "LastActivityDate": "2011-06-19T11:50:24.203", "Score": "7", "OwnerUserId": "172594", "Tags": "<c++><gcc><copy-constructor><implicit-conversion>", "AnswerCount": "4"}, "6401884": {"Id": "6401884", "PostTypeId": "2", "Body": "<p>Because you cannot do more than one implicit conversion. You would have to go <code>A::A(A::A(int)::operator B())</code> to make that work, and that's way too many steps for the compiler to figure out on it's own.</p>\n", "LastActivityDate": "2011-06-19T10:39:59.727", "CommentCount": "3", "CreationDate": "2011-06-19T10:39:59.727", "ParentId": "6401818", "Score": "5", "OwnerUserId": "298661"}});