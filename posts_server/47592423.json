post_cb({"47596356": {"ParentId": "47592423", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>If I got it correctly, you're asking if returning a warning should be considered abusing <code>std::error_code</code> semantics or not.</p>\n<p>Now, the standard introduces <code>error_code</code> as part of the <em>standard diagnostics library</em></p>\n<blockquote>\n<p id=\"so_47592423_47596356_0\"><strong>[diagnostics.general]</strong> This Clause describes components that C++ programs may use to detect and report error conditions.</p>\n</blockquote>\n<p>and, as far as I know, poses no semantical requirements on what an \"error condition\" is, we can just assume that these are to be used to report that <em>something</em> went wrong, but it does not seem imposing what the effects of a partial fulfillment of an operation specification should be, the operation should tell you.</p>\n<p>The only semantical requirement I see, is that error_code (and error_condition) is boolean convertible, that is, a 'zero' error code should always mean success.</p>\n<p>Now, given that you supposedly want an operation completing with a warning to be considered successful, for this reason <strong>I would not consider valid to return such a warning via an error code</strong>;\nthat said, you may always let your operation return <em>two</em> error codes (in the way you like, maybe belonging to different categories), documenting that only the first one reports the fulfillment of the operation effects:</p>\n<pre><code>auto [err,war] = some_operation();\n\nif(err) call_the police(); // some_operation failed\nelse if(war) // some_operation complains\n{\n  std::cerr &lt;&lt; \"hold breath...\";\n\n  if( war == some_error_condition )\n    thats_unacceptable();\n\n  //else ignore\n}\n</code></pre>\n<hr>\n<p>That said, note that there exist real use cases deviating from my reasoning above; indeed, things like HTTP result codes and libraries (like Vulkan) do use non zero 'result codes' for successful or partially successful conditions ...</p>\n<p>moreover, <a href=\"http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-4.html\" rel=\"nofollow noreferrer\">here</a> one of the very authors of the diagnostic library both claims that <em>\"the  facility uses a convention where zero means success.\"</em> and at the same time uses <code>error_code</code> to model HTTP errors (<code>200</code>status code included).</p>\n<p>This sheds some doubts either on the actual semantics of <code>error_code::operator bool()</code> (the meaning of which is not explicitly laid out in the standard) or on the effective ability of the standard diagnostic library to model the error code concept in a general way. YMMV.</p>\n</hr>", "OwnerUserId": "8631381", "LastEditorUserId": "8631381", "LastEditDate": "2017-12-02T14:36:14.467", "Id": "47596356", "Score": "2", "CreationDate": "2017-12-01T15:17:40.863", "LastActivityDate": "2017-12-02T14:36:14.467"}, "47594819": {"ParentId": "47592423", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>There are several options for a library to tell the user something went wrong or is not in line with what the function call expected.</p>\n<ul>\n<li>exceptions. But there's the exception overhead, try/catch...</li>\n<li>boost/std::optional. If there was an error/warning you can issue it as a return value (in/out or out param), otherwise the optional will be false</li>\n<li>std::pair/std::tuple. That way you can encode more information in the return value (though a custom struct might also do it more explicitly)</li>\n</ul>\n<p>You can introduce your own error data structure (don't use <code>std::error_code</code> as it's OS dependent).</p>\n<p>Killing the application from within a library is not very practical either. Even if it's an unrecoverable error in the library, it doesn't have to have much of an impact in the actual calling application/process/whatever. Let the caller decide what to do.</p>\n<p>But all that is not generally applicable. There is no one-fits-all solution to error handling. It can be very specific to where/how/when your library is used, so you wanna check what fits your purpose and how strong the calling constraints must/should be.</p>\n<p>In all cases be clear about what the caller can expect from your error handling and don't make it feel like rocket science. Minimal design is very helpful here imo.</p>\n", "OwnerUserId": "7647540", "LastEditorUserId": "7647540", "LastEditDate": "2017-12-01T13:53:16.033", "Id": "47594819", "Score": "0", "CreationDate": "2017-12-01T13:47:09.077", "LastActivityDate": "2017-12-01T13:53:16.033"}, "47592423": {"CommentCount": "12", "ViewCount": "79", "PostTypeId": "1", "ClosedDate": "2017-12-01T16:43:24.267", "LastEditorUserId": "70600", "CreationDate": "2017-12-01T11:29:44.367", "LastActivityDate": "2017-12-02T14:36:14.467", "Title": "Is std::error_code a good way to issue warnings?", "AcceptedAnswerId": "47596356", "LastEditDate": "2017-12-01T11:41:36.530", "Id": "47592423", "Score": "1", "Body": "<p>I'm currently using <code>std::error_code</code> to give feedback to the users of my API when something goes wrong. Would it be semantically acceptable to add an <code>std::error_condition</code> of type <code>warning</code> to notify my users that there was a minor issue but that operations will continue? Or should I only use logging for this?</p>\n", "Tags": "<c++><c++11><system-error>", "OwnerUserId": "70600", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_47592423_47596356_0": {"section_id": 2521, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_47592423_47596356_0": {"section_id": 2486, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_47592423_47596356_0": {"section_id": 3257, "quality": 0.8333333333333334, "length": 10}}}});