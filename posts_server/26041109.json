post_cb({"26041203": {"Id": "26041203", "PostTypeId": "2", "Body": "<p>This is what <code>std::thread</code>'s destructor does (\u00a730.3.1.3 [thread.thread.destr]):</p>\n<blockquote>\n<pre><code>~thread();\n</code></pre>\n<p id=\"so_26041109_26041203_0\">If <code>joinable()</code>, calls <code>std::terminate()</code>. Otherwise, has no\n  effects. [ <em>Note</em>: Either implicitly detaching or joining a <code>joinable()</code>\n  thread in its destructor could result in difficult to debug\n  correctness (for detach) or performance (for join) bugs encountered\n  only when an exception is raised. Thus the programmer must ensure that\n  the destructor is never executed while the thread is still joinable.\n  \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>The local <code>thread</code> created in the <code>SingletonClass</code> constructor is destroyed when that constructor exits, causing <code>terminate()</code> to be called (which in turn calls <code>abort()</code> by default).</p>\n<p>A possible fix is to make <code>thread</code> a member of the <code>Singleton</code> class, and <code>join</code> it in the destructor of <code>Singleton</code> (obviously if you do this you'd need some way to signal the thread to exit). Alternatively, you can consider <code>detach()</code>ing the thread in <code>Singleton</code>'s constructor.</p>\n", "LastActivityDate": "2014-09-25T14:31:05.100", "Score": "2", "CreationDate": "2014-09-25T14:31:05.100", "ParentId": "26041109", "CommentCount": "2", "OwnerUserId": "2756719"}, "bq_ids": {"n4140": {"so_26041109_26041203_0": {"length": 37, "quality": 0.925, "section_id": 2717}}, "n3337": {"so_26041109_26041203_0": {"length": 37, "quality": 0.925, "section_id": 2678}}, "n4659": {"so_26041109_26041203_0": {"length": 35, "quality": 0.875, "section_id": 3457}}}, "26041109": {"ViewCount": "309", "Body": "<p>I wish to create a class that has its own running thread.  I have the following code to test kicking off a new thread.</p>\n<pre><code>class SingletonClass\n{\npublic:\n    SingletonClass();\n    virtual ~SingletonClass(){};\n\n    static SingletonClass&amp; Instance();\n    void DoSomething();\nprivate:\n    static void MyThread(std::string data);\n\n    std::thread m_thread;\n};\n\nSingletonClass::SingletonClass()\n{\n    m_thread = std::thread(MyThread, \"test\");\n}\n\nvoid SingletonClass::MyThread(std::string data)\n{\n    while(1)\n    {\n        std::cout&lt;&lt;data&lt;&lt;std::endl;\n    }\n}\n\nvoid SingletonClass::DoSomething()\n{\n    std::cout&lt;&lt;\"Hello\"&lt;&lt;std::endl;\n}\n\nSingletonClass&amp; SingletonClass::Instance()\n{\n    static SingletonClass _instance;\n    return _instance;\n}\n\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    SingletonClass&amp; singleton = SingletonClass::Instance();\n    singleton.DoSomething();    \n\n    return 0;\n}\n</code></pre>\n<p>When I run my program the thread function is called and then the program just bombs out with this error:</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/AC0Cz.png\"/></p>\n<p>Why is this so?  And how can I get the thread to keep running as long as the class is instantiated</p>\n<p><strong>EDIT</strong></p>\n<p>I have added in the thread object as a private variable and kicked it off in the constructor.  It now doesnt crash.</p>\n", "AcceptedAnswerId": "26041203", "Title": "Running a thread in a c++ class", "CreationDate": "2014-09-25T14:26:22.513", "Id": "26041109", "CommentCount": "4", "LastEditDate": "2014-09-25T14:46:21.227", "PostTypeId": "1", "LastEditorUserId": "2339664", "LastActivityDate": "2014-09-25T14:46:21.227", "Score": "1", "OwnerUserId": "2339664", "Tags": "<c++><multithreading><c++11>", "AnswerCount": "1"}});