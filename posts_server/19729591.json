post_cb({"bq_ids": {"n4140": {"so_19729591_19729681_1": {"length": 24, "quality": 0.8571428571428571, "section_id": 6074}, "so_19729591_19729681_3": {"length": 33, "quality": 1.0, "section_id": 5811}, "so_19729591_19729681_4": {"length": 15, "quality": 1.0, "section_id": 6173}, "so_19729591_19729681_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 6009}}, "n3337": {"so_19729591_19729681_1": {"length": 24, "quality": 0.8571428571428571, "section_id": 5842}, "so_19729591_19729681_3": {"length": 33, "quality": 1.0, "section_id": 5584}, "so_19729591_19729681_4": {"length": 15, "quality": 1.0, "section_id": 5934}, "so_19729591_19729681_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 5777}}, "n4659": {"so_19729591_19729681_1": {"length": 19, "quality": 0.6785714285714286, "section_id": 7570}, "so_19729591_19729681_3": {"length": 27, "quality": 0.8181818181818182, "section_id": 7272}, "so_19729591_19729681_4": {"length": 15, "quality": 1.0, "section_id": 7675}, "so_19729591_19729681_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 7508}}}, "19729681": {"Id": "19729681", "PostTypeId": "2", "Body": "<p>The result of <em>postfix increment</em> is <em>prvalue</em> which mean <a href=\"http://en.cppreference.com/w/cpp/language/value_category\" rel=\"nofollow\">pure rvalue</a> so it is not modifiable. This is per the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> under <em>postfix expressions</em> section <code>5.2.6</code> <em>Increment and decrement</em> which says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_19729591_19729681_0\">The value of a postfix ++ expression is the value of its operand. [ Note: <strong>the value obtained is a copy of the original value</strong> \u2014end note ] [...] <strong>The result is a prvalue</strong>. [...]</p>\n</blockquote>\n<p>this makes sense if you think about it, since you need to return the previous value of <code>a</code> it has to be a temporary value. </p>\n<p>For completeness sake the language for <em>prefix increment</em> in section <code>5.3.2</code> <em>Increment and decrement</em> says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_19729591_19729681_1\">The operand of prefix ++ is modified by adding 1, or set to true if it is bool (this use is deprecated). <strong>The operand shall be a modifiable lvalue</strong>. The type of the operand shall be an arithmetic type or a pointer to a completely-defined object type. <strong>The result is the updated operand; it is an lvalue</strong> [...]</p>\n</blockquote>\n<p><b>Update</b></p>\n<p>I realized that:</p>\n<pre><code>++a = getSomeInt();\n</code></pre>\n<p>invokes <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow\">undefined behavior</a> in <em>C++03</em>, we can see that by looking at the relevant section in an <a href=\"http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2005/n1804.pdf\" rel=\"nofollow\">older draft standard</a> would be section <code>5</code> <em>Expressions</em> paragraph <em>4</em> which says:</p>\n<blockquote>\n<p id=\"so_19729591_19729681_2\">[...]<strong>Between the previous and next sequence point a scalar object shall have its stored value modified at most once</strong> by the evaluation of an expression. Furthermore, the prior value shall be accessed only to determine the value to be stored. The requirements of this paragraph shall be met for each allowable ordering of the subexpressions of a full expression; <strong>otherwise the behavior is undefined.</strong></p>\n</blockquote>\n<p>so since you are <em>modifying</em> <code>a</code> more than once it is <em>undefined</em>. As far as I can tell this is well defined in <em>C++11</em> which in section <code>1.9</code> <em>Program execution</em> paragraph <em>15</em> says:</p>\n<blockquote>\n<p id=\"so_19729591_19729681_3\">Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced. [...] <strong>If a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined.</strong></p>\n</blockquote>\n<p>and we can see in section <code>5.17</code> <em>Assignment and compound assignment operators</em> paragraph <em>1</em> says:</p>\n<blockquote>\n<p id=\"so_19729591_19729681_4\">[...] In all cases, the assignment is sequenced after the value computation of the right and left operands, and before the value computation of the assignment expression. [...]</p>\n</blockquote>\n<p>but regardless, even if it is <em>well defined</em> expression like this:</p>\n<pre><code>++a = getSomeInt();\n</code></pre>\n<p>are difficult to read and maintain and should be eschewed for simpler code.</p>\n<p><b>Update 2</b></p>\n<p>Not sure how I missed this beofre but you are not initializing <code>a</code> here:</p>\n<pre><code> int a;\n</code></pre>\n<p>and so it will have an <em>indeterminate value</em>, we don't know what it's initial value will be and performing a <em>pre-increment</em> on <code>a</code> would also be <em>undefined behavior</em>.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2013-11-02T01:14:48.493", "Score": "7", "CreationDate": "2013-11-01T15:18:33.857", "ParentId": "19729591", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2013-11-02T01:14:48.493"}, "19729591": {"ViewCount": "341", "Body": "<p>Why is the first expression allowed, but the second not:</p>\n<pre><code>void test()\n{\n   int a;\n\n   ++a = getSomeInt();\n   a++ = getSomeInt();\n}\n</code></pre>\n<p>I mean, why its forbidden for the second one to be an <em>lvalue</em>? The second one makes sense and the first not. In the first one we increment the variable and immediately after we gave here a new value, we lose it. That's not the case in the second expression. It makes sense to assign some value and increment the variable after that. </p>\n", "Title": "Weird behaviour of prefix and postfix operators", "CreationDate": "2013-11-01T15:13:41.673", "LastActivityDate": "2013-11-02T01:14:48.493", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-11-02T01:11:52.343", "LastEditorUserId": "1708801", "Id": "19729591", "Score": "3", "OwnerUserId": "1700080", "Tags": "<c++><compiler-construction><standards>", "AnswerCount": "1"}});