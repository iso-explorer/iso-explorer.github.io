post_cb({"bq_ids": {"n4140": {"so_16664375_16664420_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 2810}, "so_16664375_16664420_1": {"length": 12, "quality": 0.6666666666666666, "section_id": 2777}, "so_16664375_16664558_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 2754}}, "n3337": {"so_16664375_16664558_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 2715}, "so_16664375_16664420_1": {"length": 12, "quality": 0.6666666666666666, "section_id": 2738}}, "n4659": {"so_16664375_16664420_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 3548}, "so_16664375_16664558_1": {"length": 6, "quality": 0.5454545454545454, "section_id": 3492}, "so_16664375_16664420_1": {"length": 12, "quality": 0.6666666666666666, "section_id": 3515}}}, "16664397": {"Id": "16664397", "PostTypeId": "2", "Body": "<p>(<code>std::mutex</code> wasn't mentioned in the question when I wrote this answer.)</p>\n<p>It depends on the mutex library and mutex type you're using - you haven't told us.  Some systems provide a \"recursive mutex\" that is allowed to be called multiple times like this only if it happens from the same thread (then you must have a matching number of unlocks before another thread can lock it), other libraries consider this an error and may fail gracefully (as yours has) or have undefined behaviour.</p>\n", "LastEditorUserId": "410767", "LastActivityDate": "2013-05-21T08:28:27.350", "Score": "2", "CreationDate": "2013-05-21T07:26:51.877", "ParentId": "16664375", "CommentCount": "5", "OwnerUserId": "410767", "LastEditDate": "2013-05-21T08:28:27.350"}, "16664420": {"Id": "16664420", "PostTypeId": "2", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/thread/mutex\" rel=\"noreferrer\"><code>std::mutex</code></a>:</p>\n<blockquote>\n<p id=\"so_16664375_16664420_0\">A calling thread must not own the mutex prior to calling lock or try_lock. </p>\n</blockquote>\n<p>and from <a href=\"http://en.cppreference.com/w/cpp/thread/mutex/lock\" rel=\"noreferrer\"><code>std::mutex::lock</code></a>:</p>\n<blockquote>\n<p id=\"so_16664375_16664420_1\">If lock is called by a thread that already owns the mutex, the program may deadlock. Alternatively, if an implementation can detect the deadlock, a resource_deadlock_would_occur error condition may be observed.</p>\n</blockquote>\n<p>and the <em>exceptions</em> clause:</p>\n<blockquote>\n<p id=\"so_16664375_16664420_2\">Throws std::system_error when errors occur, including errors from the underlying operating system that would prevent lock from meeting its specifications. The mutex is not locked in the case of any exception being thrown. </p>\n</blockquote>\n<p>Therefore it is not supposed to block the thread. On your platform, the implementation appears to be able to detect when a thread is already the owner of a lock and raise an exception. This may not happen on other platforms, as indicated in the descriptions.</p>\n", "LastEditorUserId": "1033896", "LastActivityDate": "2013-05-21T07:33:12.320", "Score": "12", "CreationDate": "2013-05-21T07:27:48.463", "ParentId": "16664375", "CommentCount": "0", "OwnerUserId": "1033896", "LastEditDate": "2013-05-21T07:33:12.320"}, "16664375": {"ViewCount": "5086", "Body": "<p>I wrote the following code to test my understanding of <code>std::mutex</code></p>\n<pre><code>int main() {\n    mutex m;\n    m.lock();\n    m.lock(); // expect to block the thread\n}\n</code></pre>\n<p>And then I got a <code>system_error: device or resource busy</code>. Isn't the second <code>m.lock()</code> supposed to block the thread?</p>\n", "AcceptedAnswerId": "16664420", "Title": "Why locking a std::mutex doesn't block the thread", "CreationDate": "2013-05-21T07:24:55.200", "LastActivityDate": "2017-07-12T10:36:28.517", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-07-12T10:36:28.517", "OwnerDisplayName": "user955249", "LastEditorUserId": "2580955", "Id": "16664375", "Score": "11", "Tags": "<c++><c++11><concurrency>", "AnswerCount": "3"}, "16664558": {"Id": "16664558", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_16664375_16664558_0\">Isn't the second <code>m.lock()</code> supposed to block the thread?</p>\n</blockquote>\n<p>No, it gives undefined behaviour. The second <code>m.lock()</code> breaks this requirement:</p>\n<blockquote>\n<p id=\"so_16664375_16664558_1\">C++11 30.4.1.2/7 <em>Requires:</em> If m is of type <code>std::mutex</code> or <code>std::timed_mutex</code>, the calling thread does not own the mutex.</p>\n</blockquote>\n<p>It looks like your implementation is able to detect that the calling thread owns the mutex and gives an error; others may block indefinitely, or fail in other ways.</p>\n", "LastActivityDate": "2013-05-21T07:36:27.373", "CommentCount": "0", "CreationDate": "2013-05-21T07:36:27.373", "ParentId": "16664375", "Score": "8", "OwnerUserId": "204847"}});