post_cb({"bq_ids": {"n4140": {"so_29068333_29068918_1": {"section_id": 21, "quality": 1.0, "length": 38}, "so_29068333_29068918_0": {"section_id": 5943, "quality": 0.896551724137931, "length": 26}}, "n3337": {"so_29068333_29068918_1": {"section_id": 18, "quality": 1.0, "length": 38}, "so_29068333_29068918_0": {"section_id": 5714, "quality": 0.896551724137931, "length": 26}}, "n4659": {"so_29068333_29068918_1": {"section_id": 21, "quality": 1.0, "length": 38}, "so_29068333_29068918_0": {"section_id": 7428, "quality": 0.896551724137931, "length": 26}}}, "29068333": {"CommentCount": "11", "AcceptedAnswerId": "29068918", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-03-16T01:28:16.260", "LastActivityDate": "2015-03-16T03:08:08.383", "LastEditDate": "2017-05-23T12:28:22.500", "ViewCount": "475", "FavoriteCount": "1", "Title": "auto type deduction not working as expected", "Id": "29068333", "Score": "4", "Body": "<p>this is much like this question <a href=\"https://stackoverflow.com/questions/24371868/why-must-a-short-be-converted-to-an-int-before-arithmetic-operations-in-c-and-c\">Why must a short be converted to an int before arithmetic operations in C and C++?</a>\nhowever there is a sub-question why the compiler diagnoses a warning in one case and an error in the other case ,with the exact same expression.</p>\n<p>I really like the use of the <code>auto</code> 'type' as in <code>auto var =</code>..., but MSVC 2015 CTP gives an error from my code.</p>\n<p>The issue is I am <code>auto</code>-ing an expression of type <code>short</code> but sometimes it's promoted to <code>int</code>.</p>\n<p>Here's a MCVE:</p>\n<pre><code>struct MY_COORD { short X; short Y; };\nusing t_crd = MY_COORD; \n\nvoid call_test ( t_crd x )  {}\n\nint main()\n{\n    t_crd    crd { 10 ,20 };\n\n    auto     x5 = crd.X - crd.Y;\n    auto     y5 = crd.Y - crd.X;\n    t_crd    crd5 { x5 ,y5 };       // (1)\n    call_test( t_crd{ x5 ,y5 } );   // (2)\n}\n</code></pre>\n<p>The messages from lines (1) and (2) are respectively:</p>\n<pre><code> warning C4838: conversion from 'int' to 'short' requires a narrowing conversion\n error C2397: conversion from 'int' to 'short' requires a narrowing conversion\n</code></pre>\n<p>I thought this code was OK but it's not according to MSVC 2015 CTP compiler (but Intellisense doesn't indicate it).\nIs there some obscure little rule that I missed that makes MSVC right ?</p>\n<p>And if so why is the same expression a <strong>warning</strong> in one case and an <strong>error</strong> in the other case ?</p>\n<p>I wanted to use it in the initialization of a loop variable like this:</p>\n<pre><code>MY_COORD pos = ResultFromFunction();\nauto rows = pos.Y;\nfor ( auto i = (rows - rows); i &lt; rows; ++i )\n{\n   coord c{ 0 ,i };\n   ...\n}\n</code></pre>\n", "Tags": "<c++><c++11><visual-c++><auto>", "OwnerUserId": "517580", "AnswerCount": "2"}, "29068918": {"ParentId": "29068333", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Arithmetic operators always promote integral types smaller than <code>int</code> to <code>int</code> before performing the operation. This is mandated in <code>[expr]/10</code> of the C++11 standard:</p>\n<blockquote>\n<p id=\"so_29068333_29068918_0\">Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield\n  result types in a similar way. The purpose is to yield a common type, which is also the type of the result.\n  This pattern is called the <em>usual arithmetic conversions</em>.</p>\n</blockquote>\n<p>The sub-clause from there which applies to your case specifies that the operands in <code>rows - rows</code> will be subjected to integral promotion. In particular, according to <code>[conv.prom]/1</code></p>\n<blockquote>\n<p id=\"so_29068333_29068918_1\">A prvalue of an integer type other than <code>bool</code>, <code>char16_t</code>, <code>char32_t</code>, or <code>wchar_t</code> whose integer conversion\n  rank is less than the rank of <code>int</code> can be converted to a prvalue of type <code>int</code> if <code>int</code> can represent all\n  the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type <code>unsigned int</code>.</p>\n</blockquote>\n<p>Since the rank of <code>short</code> is guaranteed to be less than the rank of <code>int</code>, both the operands of <code>rows - rows</code> are promoted to <code>int</code>, giving the expression <code>rows - rows</code> a type of <code>int</code>.</p>\n<p>About the narrowing conversion, the standard specifies(in <code>[dcl.init.aggr]</code>) that, in aggregate initialization, if the expression requires a narrowing conversion, the program is ill-formed. Compilers are free to diagnose it anyway they like. IIRC, under the simple circumstances like <code>t_crd crd5 { x5 ,y5 };</code>, clang 3.5 issues an error while g++ 4.9.2 issues a warning when used with the default warnings settings. Either way. MSVC's behaviour, even if slightly odd, is standard-conforming.</p>\n", "OwnerUserId": "862351", "LastEditorUserId": "862351", "LastEditDate": "2015-03-16T02:54:36.510", "Id": "29068918", "Score": "6", "CreationDate": "2015-03-16T02:48:14.327", "LastActivityDate": "2015-03-16T02:54:36.510"}, "29068779": {"ParentId": "29068333", "PostTypeId": "2", "CommentCount": "3", "Body": "<pre><code>short x=1, y=2;\nstatic_assert(\n  std::is_same&lt;int, decltype(x-y)&gt;{},\n  \"subtracting two shorts gets an `int`, not a `short`\"\n);\n// that is how integral promotion works in C++ -- things\n// smaller than `int` promote to `int` almost always\nint a=3,b=4;\n// if you use the \"new\" {} style initialization\n// it is an error to have a narrowing conversion:\n//short z1 = {b-a};\n// but not if you don't use {}:\nshort z2 = b-a;\n(void)x;(void)y;(void)a;(void)b;(void)z2; // block unused var warnings.\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/82bb2fcd9defa441\" rel=\"nofollow\">live example</a></p>\n<p>The variables you make <code>auto</code> are mostly all <code>int</code>s, as they are usually the difference between two <code>short</code>s.  You then proceed to convert them in various contexts to <code>short</code>s -- sometimes in contexts where the compiler issues a warning, other times when it is an error to do a narrowing conversion.</p>\n<p>When you replace <code>auto</code> with <code>short</code> the conversion warnings and errors go away.</p>\n<p>Note that <code>short-short</code> can easily overflow a <code>short</code>.  If it does, the result is undefined behavior (signed overflow is undefined).  In practice, the hardware may do mod 2^n, but even on 2s complement hardware the optimizer is free to assume that no overflow occurs, and that can cause seemingly insane changes to your code during optimization.</p>\n<p>A classic example is <code>int x = (unsigned)-1; if (x&lt;0) std::cout &lt;&lt; \"not printed\\n\";</code> std::cout &lt;&lt; x &lt;&lt; \" == -1\\n\";<code>, where the branch of</code>x&lt;0<code>can be eliminated as \"impossible\" by an optimizer (as we converted</code>x` from an unsigned value, it cannot be negative unless it overflows, and if it overflows that is undefined behavior, so anything goes).</p>\n<p>So by changing <code>auto</code> to <code>short</code> you actually move the undefined behavior that the warnings and errors are talking about to a spot where the compiler doesn't warn you or generate errors.  The problem still remains.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2015-03-16T02:44:47.110", "Id": "29068779", "Score": "2", "CreationDate": "2015-03-16T02:30:50.173", "LastActivityDate": "2015-03-16T02:44:47.110"}});