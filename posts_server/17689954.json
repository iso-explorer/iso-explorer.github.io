post_cb({"17690085": {"ParentId": "17689954", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Indeed the template parameters you defined are <em>non-type</em> parameters, as opposed to the two other varieties of template parameters: type-parameters and template-parameters.</p>\n<p>However, they are still template parameters, and you will get an entirely new data type for each distinct set of template arguments. For example, <code>foo&lt;3,'a'&gt;</code> is a different data type from <code>foo&lt;4,'a'&gt;</code>, which again is different from <code>foo&lt;3,'b'&gt;</code> and so forth.</p>\n<p>Hence, the static members are separately allocated and initialized for each choice of template arguments, too.</p>\n<p>In this respect, non-type parameters, type-parameters and template-parameters all work the same way.</p>\n<hr>\n<p>For reference, from the Standard (C++11):</p>\n<blockquote>\n<p id=\"so_17689954_17690085_0\">(\u00a714.7/6) Each class template specialization instantiated from a template has its own copy of any static members. [ Example:</p>\n<pre><code>template&lt;class T&gt; class X {\n  static T s;\n};\ntemplate&lt;class T&gt; T X&lt;T&gt;::s = 0;\nX&lt;int&gt; aa;\nX&lt;char*&gt; bb;\n</code></pre>\n<p id=\"so_17689954_17690085_1\"><code>X&lt;int&gt;</code> has a static member <code>s</code> of type <code>int</code>, and <code>X&lt;char*&gt;</code> has a static member <code>s</code> of type <code>char*</code>. \u2014 end example ]</p>\n</blockquote>\n<p>The example given by the Standard above refers to type-parameters, but section 14.7/6 is part of a general discussion of templates. The broader context makes it clear that this holds for templates that use non-type parameters (or a combination of type-, non-type- and template-parameters).</p>\n<p>There is also a section on type-equivalence for template instantiations, which explains under what circumstances template instantiations with non-type parameters are considered as equal (relevant parts emphasized by me):</p>\n<blockquote>\n<p id=\"so_17689954_17690085_2\">(\u00a714/1) Two template-ids refer to the same class or function if<br>\n  \u2014 their template-names, operator-function-ids, or literal-operator-ids refer to the same template and<br>\n  \u2014 their corresponding type template-arguments are the same type and<br>\n  \u2014 their corresponding <strong>non-type template arguments of integral or enumeration type have identical values</strong> and<br>\n  \u2014 their corresponding non-type template-arguments of pointer type refer to the same external object or function or are both the null pointer value and<br>\n  \u2014 their corresponding non-type template-arguments of pointer-to-member type refer to the same class member or are both the null member pointer value and<br>\n  \u2014 their corresponding non-type template-arguments of reference type refer to the same external object or function and<br>\n  \u2014 their corresponding template template-arguments refer to the same template.</br></br></br></br></br></br></br></p>\n</blockquote>\n<p>Put in context, this means that two instantiations of the same class template constitute two distinct data types even if they differ in the value of only a single non-type parameter.</p>\n</hr>", "OwnerUserId": "777186", "LastEditorUserId": "777186", "LastEditDate": "2013-07-17T02:45:15.703", "Id": "17690085", "Score": "3", "CreationDate": "2013-07-17T02:28:45.253", "LastActivityDate": "2013-07-17T02:45:15.703"}, "17690082": {"ParentId": "17689954", "CommentCount": "1", "Body": "<p>The static constant member assigned there changes depending on the value that is being passed by the template parameter. Shorten it to something like this:</p>\n<pre><code>template&lt;int X&gt;\nstruct foo { \n    static const int value = X;\n};\n</code></pre>\n<p>You wouldn't expect <code>foo&lt;10&gt;::value</code> to be equal to <code>foo&lt;11&gt;::value</code> would you? This is commonly used in template meta programming because the value of that static constant depends on a template parameter.</p>\n", "OwnerUserId": "1381108", "PostTypeId": "2", "Id": "17690082", "Score": "3", "CreationDate": "2013-07-17T02:28:38.417", "LastActivityDate": "2013-07-17T02:28:38.417"}, "17689954": {"CommentCount": "5", "ViewCount": "140", "PostTypeId": "1", "ClosedDate": "2014-03-02T02:46:23.890", "LastEditorUserId": "-1", "CreationDate": "2013-07-17T02:12:28.660", "LastActivityDate": "2013-07-17T02:45:15.703", "Title": "Static member of template", "AcceptedAnswerId": "17690082", "LastEditDate": "2017-05-23T11:49:13.693", "Id": "17689954", "Score": "0", "Body": "<p>There is a similar question <a href=\"https://stackoverflow.com/questions/2220975/c-static-template-member-one-instance-for-each-template-type\">here</a> but it's related to templates with the <code>typename</code> keyword.</p>\n<p>Given a template:</p>\n<pre><code>template &lt; int X, char Y &gt;\nstruct foo\n{\n    char myArray[ X &lt;= 0 ? 1 : X ];\n    static const char Z = Y;\n}\n</code></pre>\n<p>Would that static member be shared between all instances of <code>foo</code> or will the compiler see that the template has been called with different arguments and create a new type?</p>\n", "Tags": "<c++><templates><c++11>", "OwnerUserId": "1479092", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_17689954_17690085_0": {"section_id": 232, "quality": 0.8461538461538461, "length": 11}, "so_17689954_17690085_1": {"section_id": 232, "quality": 0.8333333333333334, "length": 10}, "so_17689954_17690085_2": {"section_id": 95, "quality": 0.9873417721518988, "length": 78}}, "n3337": {"so_17689954_17690085_0": {"section_id": 225, "quality": 0.8461538461538461, "length": 11}, "so_17689954_17690085_1": {"section_id": 225, "quality": 0.8333333333333334, "length": 10}, "so_17689954_17690085_2": {"section_id": 90, "quality": 0.9873417721518988, "length": 78}}, "n4659": {"so_17689954_17690085_0": {"section_id": 240, "quality": 0.8461538461538461, "length": 11}, "so_17689954_17690085_1": {"section_id": 240, "quality": 0.8333333333333334, "length": 10}, "so_17689954_17690085_2": {"section_id": 99, "quality": 0.9620253164556962, "length": 76}}}});