post_cb({"28211603": {"ParentId": "25351809", "CommentCount": "0", "CreationDate": "2015-01-29T09:53:59.857", "OwnerUserId": "3003290", "PostTypeId": "2", "Id": "28211603", "Score": "0", "Body": "<p>you need to specialize for the whole class definition:</p>\n<pre><code>template&lt;class T&gt;\nstruct A {\n  enum E : T { eT };\n};\n\ntemplate&lt;&gt;\nstruct A&lt;char&gt; {\n  enum E : char { echar };\n};\n</code></pre>\n", "LastActivityDate": "2015-01-29T09:53:59.857"}, "bq_ids": {"n4140": {"so_25351809_25351809_0": {"section_id": 233, "quality": 0.9375, "length": 15}}, "n3337": {"so_25351809_25351809_0": {"section_id": 226, "quality": 0.9375, "length": 15}}, "n4659": {"so_25351809_25351809_0": {"section_id": 243, "quality": 0.9375, "length": 15}}}, "25351809": {"CommentCount": "10", "ViewCount": "649", "PostTypeId": "1", "LastEditorUserId": "701092", "CreationDate": "2014-08-17T17:34:27.587", "LastActivityDate": "2015-01-29T09:53:59.857", "Title": "Definition of a class member in the primary template and an implicit instantiation during specialization", "FavoriteCount": "1", "LastEditDate": "2014-08-17T21:33:52.890", "Id": "25351809", "Score": "14", "Body": "<p>I have the following example that I've decomposed from <code>\u00a714.7.3/6 [temp.expl.spec]</code> that defines a class member enumeration in the primary template and subsequently specializes it. The following doesn't compile in clang:</p>\n<pre><code>template&lt;class T&gt;\nstruct A {\n    enum E : T;\n};\n\ntemplate&lt;class T&gt;\nenum A&lt;T&gt;::E : T { eT };\n\ntemplate&lt;&gt;\nenum A&lt;char&gt;::E : char { echar }; // ill-formed, A&lt;char&gt;::E was instantiated\n                                  // when A&lt;char&gt; was instantiated\n\n// error: explicit specialization of 'E' after instantiation\n</code></pre>\n<p>The reason is supposed to be that the definition of the unscoped member enumeration was instantiated before the specialization. 14.7.1 [temp.inst]/1:</p>\n<blockquote>\n<p id=\"so_25351809_25351809_0\">The implicit instantiation of a class template specialization causes the implicit instantiation of [...] the definitions of unscoped member enumerations and member anonymous unions.</p>\n</blockquote>\n<p>I'm trying to understand why that is a problem exactly. Is it because if the enumeration already has a definition, then that would cause a redefinition error during the specialization?</p>\n", "Tags": "<c++><templates><c++11><enums><template-specialization>", "OwnerUserId": "701092", "AnswerCount": "1"}});