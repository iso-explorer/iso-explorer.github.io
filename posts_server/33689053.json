post_cb({"33689310": {"ParentId": "33689053", "CommentCount": "4", "Body": "<p>In case you catch the basic Exception they are completely the same. You only benefit from catching and rethrowing an exception, if you do something before throw, like logging. But you shouldn't catch Exception. Only ever catch exceptions you now how to recover from.</p>\n", "OwnerUserId": "5516339", "PostTypeId": "2", "Id": "33689310", "Score": "1", "CreationDate": "2015-11-13T09:15:55.590", "LastActivityDate": "2015-11-13T09:15:55.590"}, "33689626": {"ParentId": "33689053", "LastEditDate": "2015-11-13T09:53:59.593", "CommentCount": "6", "CreationDate": "2015-11-13T09:34:32.790", "OwnerUserId": "496161", "LastEditorUserId": "496161", "PostTypeId": "2", "Id": "33689626", "Score": "17", "Body": "<p>The latter mandates stack unwinding, whereas in the former it is implementation-defined if the stack is unwound.</p>\n<p>Relevant standards quotes (all from N3337):</p>\n<blockquote>\n<p id=\"so_33689053_33689626_0\"><code>[except.ctor]/1:</code> As control passes from a throw-expression to a handler, destructors are invoked for all automatic objects\n  constructed since the try block was entered. The automatic objects are destroyed in the reverse order of the\n  completion of their construction.</p>\n<p id=\"so_33689053_33689626_1\"><code>[except.ctor]/3:</code> The process of calling destructors for automatic objects constructed on the path from a try block to a\n  throw-expression is called \u201cstack unwinding.\u201d [...]</p>\n<p id=\"so_33689053_33689626_2\"><code>[except.terminate]/2:</code> [When the exception handling mechanism cannot find a handler for a throw exception], <code>std::terminate()</code> is called (18.8.3). In the situation where no matching handler is found,\n  it is implementation-defined whether or not the stack is unwound before <code>std::terminate()</code> is called. [...]</p>\n</blockquote>\n<p>As such, if you want to guarantee that your automatic objects have their destructors run in the case of an unhandled exception (e.g. some persistent storage must be mutated on destruction) then <code>try {/*code*/} catch (...) {throw;}</code> will do that, but <code>{/*code*/}</code> will not.</p>\n", "LastActivityDate": "2015-11-13T09:53:59.593"}, "33689632": {"ParentId": "33689053", "LastEditDate": "2015-11-13T09:42:38.173", "CommentCount": "5", "CreationDate": "2015-11-13T09:35:12.470", "OwnerUserId": "4706785", "LastEditorUserId": "4706785", "PostTypeId": "2", "Id": "33689632", "Score": "3", "Body": "<p>Assuming the \"some code\" does not exhibit undefined behaviour (in which case all bets are off, regardless of whether you add a try/catch block or not), there will be no difference in end result.   It is technically implementation defined (i.e. an implementation has to document what it does) whether stack unwinding will occur if an exception is never caught, but there has yet to be a report of any implementation that does NOT unwind the stack in such circumstances.  If stack unwinding occurs, all local variables will pass out of scope, and those with destructors will have destructors invoked.</p>\n<p>There may or may not be a measurable difference of performance, associated with the overhead of setup before the \"some code\" is executed, catching the exception (if any) and rethrowing, and any additional cleanup.    The difference will be compiler dependent and, with old compilers, was potentially significant.   With modern compilers, the difference of overhead - if any - would be somewhat less, since implementation techniques for exceptions and exception handling have improved.</p>\n", "LastActivityDate": "2015-11-13T09:42:38.173"}, "33689755": {"ParentId": "33689053", "LastEditDate": "2017-05-23T11:59:20.280", "CommentCount": "3", "CreationDate": "2015-11-13T09:43:33.947", "OwnerUserId": "3216312", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "33689755", "Score": "7", "Body": "<p>Elaboratring on <a href=\"https://stackoverflow.com/questions/33688686/will-throwing-an-exception-in-a-catch-block-lead-to-two-exceptions-being-in-flig/33688702#comment55151171_33688702\">Cheers and hth. - Alf's comment</a>:</p>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/error/terminate\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/error/terminate</a> :</p>\n<blockquote>\n<p id=\"so_33689053_33689755_0\">std::terminate() is called by the C++ runtime when exception handling\n  fails for any of the following reasons:</p>\n<p id=\"so_33689053_33689755_1\">1) an exception is thrown and not caught (<strong>it is implementation-defined\n  whether any stack unwinding is done in this case</strong>)</p>\n</blockquote>\n<p>So stack unwinding might not happen if your </p>\n<pre><code>{\n  // some code, may throw and/or have side effects\n}\n</code></pre>\n<p>is not within another <code>try/catch</code> block.</p>\n<p>Example:</p>\n<pre><code>struct A {\n    A() {}\n    ~A() { std::cout &lt;&lt; \"~A()\" &lt;&lt; std::endl; }\n};\n\nint main()\n{\n//    try {\n        A a;\n        throw 1;\n//    } catch(...) {\n//        throw;\n//    }\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/da8acc17d00d3747\" rel=\"nofollow noreferrer\">Under coliru's gcc 5.2.0 with -O2</a> does not print <code>~A()</code>, while with <code>try/catch</code> does print.</p>\n<p><strong>UPD</strong>: regarding your edit about separate compilation units, just tested with my local gcc 4.8.2, the behavior is the same: no stack unwinding if there is no <code>catch</code>. The particular example:</p>\n<p><code>a.h</code>:</p>\n<pre><code>struct A {\n   A();\n   ~A();\n};\n\nvoid foo();\n</code></pre>\n<p><code>a.cpp</code>:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct A {\n   A() {}\n   ~A() { cout &lt;&lt; \"~A()\" &lt;&lt; endl; }\n};\n\nvoid foo() {\n    A a;\n    throw 1;\n}\n</code></pre>\n<p><code>main.cpp</code>:</p>\n<pre><code>#include \"a.h\"\n\nint main () {\n   //try {\n    foo();\n   //} catch(...) {\n   //  throw;\n   //}\n}\n</code></pre>\n<p>I think that whether there is a <code>catch</code> is determined at run time, because anyway when exception is thrown at runtime, the program needs to look for <code>catch</code>. So it make sense to choose whether to unwind the stack at runtime too.</p>\n", "LastActivityDate": "2015-11-13T12:09:01.903"}, "33689314": {"ParentId": "33689053", "CommentCount": "4", "Body": "<p>Some meaningful clean up can be performed in catch block before rethrow if resources not managed as RAII idiom </p>\n<pre><code>       {\n          // some code, may throw and/or have side effects\n        }\n\n        try {\n          // same code as above\n        } catch(...) {\n//Some meaningful clean up can be performed here if resources not managed as RAII idiom\n          throw;\n        }\n</code></pre>\n", "OwnerUserId": "1694348", "PostTypeId": "2", "Id": "33689314", "Score": "-1", "CreationDate": "2015-11-13T09:16:09.350", "LastActivityDate": "2015-11-13T09:16:09.350"}, "33689053": {"CommentCount": "4", "CreationDate": "2015-11-13T09:03:11.433", "PostTypeId": "1", "AcceptedAnswerId": "33689626", "LastEditorUserId": "-1", "LastActivityDate": "2015-12-04T13:06:09.690", "LastEditDate": "2017-05-23T11:52:20.410", "ViewCount": "1323", "FavoriteCount": "3", "Title": "Is code with try-catch-rethrow equivalent to code w/o try-catch?", "Id": "33689053", "Score": "23", "Body": "<p>Under which circumstances are the following two codes not equivalent?</p>\n<pre><code>{\n  // some code, may throw and/or have side effects\n}\n\ntry {\n  // same code as above\n} catch(...) {\n  throw;\n}\n</code></pre>\n<hr>\n<p><strong>edit</strong> Just to clarify, I'm not interested in (i) deviations from above pattern (such as more code in the catch block) nor (ii) intended to invite patronising comments about the proper usage of <code>try</code>-<code>catch</code> blocks.</p>\n<p>I'm looking for a qualified answer referring to the C++ standard. This question was prompted by a comment by <a href=\"https://stackoverflow.com/users/464581/cheers-and-hth-alf\">Cheers and hth. - Alf</a> to <a href=\"https://stackoverflow.com/a/33688702/1023390\">this answer of mine</a>, stating w/o further explanation that above codes are <em>not equivalent</em>.</p>\n<hr>\n<p><strong>edit</strong> they are indeed different. stack un-winding will be done in the latter, but not necessarily in the former, depending on whether an exception handler (some <code>catch</code> block higher up the stack) is found at run time.</p>\n</hr></hr>", "Tags": "<c++><exception><try-catch><language-lawyer><throw>", "OwnerUserId": "1023390", "AnswerCount": "6"}, "33689220": {"ParentId": "33689053", "CommentCount": "2", "Body": "<p>Semantically that is equivalent. I am not sure, if some compilers might be unable to optimize the unnevessary <code>try</code>-<code>catch</code> away. I'd prefer to leave the <code>try</code>-<code>catch</code> block out. That usually makes the code easier to unterstand.</p>\n", "OwnerUserId": "5053331", "PostTypeId": "2", "Id": "33689220", "Score": "3", "CreationDate": "2015-11-13T09:11:23.333", "LastActivityDate": "2015-11-13T09:11:23.333"}, "bq_ids": {"n4140": {"so_33689053_33689626_0": {"section_id": 3343, "quality": 0.88, "length": 22}, "so_33689053_33689626_1": {"section_id": 3345, "quality": 0.8, "length": 12}, "so_33689053_33689626_2": {"section_id": 3383, "quality": 0.52, "length": 13}}, "n3337": {"so_33689053_33689626_0": {"section_id": 3213, "quality": 0.92, "length": 23}, "so_33689053_33689626_1": {"section_id": 3215, "quality": 0.8666666666666667, "length": 13}, "so_33689053_33689626_2": {"section_id": 3252, "quality": 0.52, "length": 13}}, "n4659": {"so_33689053_33689626_0": {"section_id": 4109, "quality": 0.6, "length": 15}, "so_33689053_33689626_2": {"section_id": 4143, "quality": 0.52, "length": 13}}}});