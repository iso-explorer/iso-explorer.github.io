post_cb({"33493378": {"ParentId": "33492796", "PostTypeId": "2", "CommentCount": "8", "Body": "<blockquote>\n<p id=\"so_33492796_33493378_0\">However, I am assuming that these days everyone throw std::Exception, so that is safe in a catch. Is that a fair assumption?</p>\n</blockquote>\n<p>That's mostly a safe assumption. Some people insist in  throwing random stuff, but it's not your business - if you are a library you throw exceptions and at most you catch your own, you shouldn't be concerned with what other people throw (your code should use RAII anyway to avoid resource leaks - this covers even the case where e.g. callbacks throw stuff you don't know). </p>\n<blockquote>\n<p id=\"so_33492796_33493378_1\">The Exception.what function returns a char * (not a string) with no way to free it. Of course, that string should contain information about the exception, for example if a file is not found then the name of the file that was not found. I assume that we just tolerate a small memory leak here when exceptions are thrown. Correct?</p>\n</blockquote>\n<p>Nope. The string returned by <code>what</code> normally does not result in a memory leak. Either is statically allocated (I've seen many simple exception classes that just return a string literal) or it's managed inside the exception itself (<code>std::runtime_error</code> normally contains an <code>std::string</code>, with <code>what</code> returning the result of its <code>c_str</code> method). In general, you can assume that whatever <code>what</code> results is there as long as the exception lives - if you need it outside the <code>catch</code> block copy it into an <code>std::string</code> or something.</p>\n<p>This is actually <em>required</em> by the standard:</p>\n<blockquote>\n<p id=\"so_33492796_33493378_2\">The return value remains valid until the exception object from which it is obtained is destroyed or a non-const member function of the exception object is called.</p>\n</blockquote>\n<p>(C++11, \u00a718.8.1 \u00b610)</p>\n<blockquote>\n<p id=\"so_33492796_33493378_3\">It is unclear how reliably stack traces can be generated in a general way and sent to a log file. (In a production environment when things go wrong, not in a debugger.) So I was thinking of inserting otherwise redundant try/catch blocks at interesting places in the code which can add logging and append extra information to the what text and then rethrow a new exception. But that process will, of course, destroy any stack trace. </p>\n</blockquote>\n<p>Stack traces in C++ are a sad story; there's no portable way to generate them, you have to resort to platform-specific calls (or to libraries that abstract them); personally I used several approaches in the past:</p>\n<ul>\n<li>on a new, multi-platform Qt application I wrote my own \"fat\" exception class, which saved the stack trace (I derived from <a href=\"http://cppcms.com/cppcms_ref/latest/classbooster_1_1exception.html\" rel=\"nofollow\"><code>booster::exception</code></a>, which already bundles the stack trace-saving part) and added the possibility to add extra information while the exception gets caught and rethrown, similar to how <a href=\"http://www.boost.org/doc/libs/master/libs/exception/doc/boost-exception.html\" rel=\"nofollow\">Boost.Exception</a> is implemented (important: Boost.Exception != booster::exception, they are completely unrelated); see <a href=\"https://bitbucket.org/skynet_bm/exceptions/src/c4f155fde41fa3f4e42a5c43c15fb3291a2d55fb/exceptions.hpp?at=master&amp;fileviewer=file-view-default\" rel=\"nofollow\">here</a>, it's full of Qt types but you can get the idea;</li>\n<li>on a legacy project which throw the most bizarre types (and there's no way to change them to a common exception type) I just hooked (via linker tricks) the throw and I always save the stack trace in a global circular buffer, which is printed out if an exception is not caught. </li>\n</ul>\n<p>Your approach is flawed because not only it loses parts of the stack trace, but even the type information about the exception. Look up how Boost.Exception does its thing to see how to do it right. Also, you <em>never, ever</em> throw a <code>new</code> (=heap allocated) exception, otherwise freeing it becomes a burden to people who want to catch it (also, probably nobody will catch it because no one catches by pointer, you normally catch by reference). </p>\n", "OwnerUserId": "214671", "LastEditorUserId": "214671", "LastEditDate": "2015-11-05T09:30:43.957", "Id": "33493378", "Score": "2", "CreationDate": "2015-11-03T07:14:27.233", "LastActivityDate": "2015-11-05T09:30:43.957"}, "33493084": {"ParentId": "33492796", "PostTypeId": "2", "CommentCount": "6", "Body": "<p><strong>Type of exception</strong><br>\nWhat type of exception object can be thrown is part of the function / method's public contract. </br></p>\n<p>Often, libraries may introduce their own exception types which may or may not inherit from <code>std::exception</code>. </p>\n<p><em>Recommended:</em> throw std::exception or an exception inherited from it. Document the type(s) of exception thrown. Usually, you will have a \"library default\", such as </p>\n<blockquote>\n<p id=\"so_33492796_33493084_0\"><em>Unless stated otherwise, all methods and functions in this library may throw an exception of type <code>mylib::exception</code> or a type inherited from it.</em></p>\n</blockquote>\n<p><strong>char * what()</strong><br>\nThe (implied?) assumption is that the pointer is valid as long as the exception object is valid. No necessity to free the string manually, no reason for leak. </br></p>\n<p>If you need to store the text for later, make a copy of it - e.g. by assigning to <code>std::string</code>.</p>\n<p><strong>Stack traces</strong><br>\n... are not part of the C++ standard. Furthermore, most compiler implementations allow generating code that does not allow re-discovering a stack trace. (the respective option usually says something about \"stack frame\"). </br></p>\n<p>However, for most compilers, libraries exist that can add this stack trace, but this usually requires access to the debug symbols. </p>\n<p><strong>\"Redundant\" try/catch</strong><br>\nYou might need them anyway.<br>\nThe perfect exception must support different aspects:</br></br></p>\n<ul>\n<li><p>it contains instructions or hints for the end user how to remove a blocking issue (<em>\"Cannot open file bibbit.txt because it is read only\"</em>)</p></li>\n<li><p>it contains information for support and development why the error occurred, allowing them to possibly avoid it  / handle it better in the future. (Such as ... the stack trace)</p></li>\n<li><p>it needs to allow calling code to detect known exceptions and handle them specifically (e.g. <em>the file the user wants to open is read-only, ask user if they want to open in read-only mode, and try again</em>)</p></li>\n</ul>\n<p>Rarely an exception does all that perfectly. But repackaging at certain \"layers\" helps a lot here - even though this makes us lose some of the beauty of exceptions. </p>\n<p>Does that help?</p>\n<hr>\n<p>Edit regarding your edit: </p>\n<p>Generally ok, but <strong>DO NOT</strong> re-construct the exception. Change your code to:</p>\n<pre><code> ...\n catch (std::exception&amp; ex) {\n  string msg = \"While processing \" + foo.toString() + \": \" + ex.what;\n  log &lt;&lt; msg;\n  throw;  // &lt;--- !!!!!!\n}\n</code></pre>\n<p>This re-throws the original exception, so catch handlers further down can still distinguish the different types:</p>\n<pre><code>  void Foo() {\n     class random_exception : public std::exception { ... }\n     try {\n        ...\n        if (rand() % 2) throw random_exception();\n        ...\n     }\n     catch(std::exception const &amp; x)\n     {\n        log &lt;&lt; x.what();\n        throw;\n     }\n   } \n\n   int main()\n   {\n      try {\n        Foo();\n      }\n      catch(random_exception const &amp; x)\n      {\n         cout &lt;&lt; \"A random exception occurred, you can try again\";\n      }\n      catch(std::exception const &amp; x)\n      {\n         cout &lt;&lt; This didn't work. \" &lt;&lt; x.what(); \n      }\n      catch(...) // catches all exception types, but you don't know what\n      {\n         cout &lt;&lt; \"Uh, oh, you are doomed.\".\n      }\n   }\n</code></pre>\n<p>Of course, that's an issue when repackaging the exception. </p>\n<hr>\n<p>Some things I'm leaning to:</p>\n<p>The exception type to be thrown is a thin wrapper around a (smart) pointer. This allows storing exceptions (e.g. to pass them to another thread, or as an \"inner exception\" when repackaging) without losing type information:</p>\n<p>I allow separate messages for end user and for diagnostics. End user message is required, diagnostics is usually generated from (and contains) the error code and context. User will see no \"weird numbers and techie gibberish\" unless they click on \"details\". </p>\n<p>Instead of including parameters in the error message: </p>\n<pre><code>msg = \"Could not open file bibbit.txt (tried 5 times)\"; // :-(\n</code></pre>\n<p>I use a fixed message, and a list of (name, value) parameters. </p>\n<pre><code>msg = \"Could not open file\";  // :-)\nmsg.Add(\"filename\", filename).Add(\"retries\", retryCount);\n</code></pre>\n<p>This should simplify localization, and allows the caller to access individual attributes for known errors, allowing more specific handling. </p>\n</hr></hr>", "OwnerUserId": "31317", "LastEditorUserId": "31317", "LastEditDate": "2015-11-03T07:16:01.400", "Id": "33493084", "Score": "3", "CreationDate": "2015-11-03T06:54:53.407", "LastActivityDate": "2015-11-03T07:16:01.400"}, "33492796": {"CommentCount": "2", "ViewCount": "1252", "PostTypeId": "1", "LastEditorUserId": "1968182", "CreationDate": "2015-11-03T06:35:09.790", "LastActivityDate": "2015-11-05T09:30:43.957", "Title": "How to use std::exception -- stack trace plus memory leak", "FavoriteCount": "2", "LastEditDate": "2015-11-03T06:55:05.497", "Id": "33492796", "Score": "2", "Body": "<p>I am trying to figure out the best way to deal with exceptions.</p>\n<p>C++ says that any datatype can be thrown as an exception, but there is no way to tell what data type has been thrown, which makes exceptions essentially worthless.  However, I am assuming that these days everyone throw std::exception, so that is safe in a catch.  Is that a fair assumption?</p>\n<p>(I am building a library that will be used by others, so has to fit in with other code that I do not control.)</p>\n<p>The Exception.what function returns a char * (not a string) with no way to free it.  Of course, that string should contain information about the exception, for example if a file is not found then the name of the file that was not found.  I assume that we just tolerate a small memory leak here when exceptions are thrown.  Correct?</p>\n<p>It is unclear how reliably stack traces can be generated in a general way and sent to a log file.  (In a production environment when things go wrong, not in a debugger.)  So I was thinking of inserting otherwise redundant try/catch blocks at interesting places in the code which can add logging  and append extra information to the what text and then rethrow a new exception.  But that process will, of course, destroy any stack trace.  For example</p>\n<pre><code>foo = stuff();\ntry {\n  processStuff()\n} catch (std::exception&amp; ex) {\n  string msg = \"While processing \" + foo.toString() + \": \" + ex.what;\n  log &lt;&lt; msg;\n  throw std::exception((char[])msg);\n}\n</code></pre>\n<p>Is that the best approach?</p>\n<p>There are lots of articles that describe the basic classes but nothing I could find on how to really make them work in practice.  Links appreciated.</p>\n<p>(Here again I am trying to write Java/.Net in C++.  Is that a hopeless cause?)</p>\n", "Tags": "<c++>", "OwnerUserId": "2698167", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_33492796_33493378_2": {"section_id": 6915, "quality": 0.9375, "length": 15}}, "n3337": {"so_33492796_33493378_2": {"section_id": 6663, "quality": 0.9375, "length": 15}}, "n4659": {"so_33492796_33493378_2": {"section_id": 8413, "quality": 0.9375, "length": 15}}}});