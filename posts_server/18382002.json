post_cb({"18668877": {"ParentId": "18382002", "CommentCount": "1", "Body": "<p>Yes your code is perfectly valid. A pack expansion consists of a pattern and an ellipsis and can appear in a pattern of another pack expansion. In paragraph \u00a714.5.3/5 of the standard you will find:</p>\n<blockquote>\n<p id=\"so_18382002_18668877_0\">[...] An appearance of the name of a parameter pack is only expanded by the innermost enclosing pack expansion. The pattern of a pack expansion shall name one or more parameter packs that are not expanded by a nested pack expansion; [...]</p>\n</blockquote>\n<p>A pack expansion can be used in any context mentioned in \u00a714.5.3/4. Given your example:</p>\n<pre><code>DebugPrinter&lt; T1, T2, T1...&gt;...\n</code></pre>\n<p>Both pack expansions are valid. The context of the first one is a <code>template-argument-list</code> while the second appears in a <code>base-specifier-list</code>.</p>\n<p>The example provided by the standard text:</p>\n<pre><code>template&lt;class ... Args&gt;\nvoid g(Args ... args) {                   // OK: Args is expanded by the function\n                                          // parameter pack args\n    f(const_cast&lt;const Args*&gt;(&amp;args)...); // OK: \u201cArgs\u201d and \u201cargs\u201d are expanded\n    f(5 ...);                             // error: pattern does not contain any\n                                          // parameter packs\n    f(args);                              // error: parameter pack \u201cargs\u201d is not\n                                          // expanded\n    f(h(args ...) + args ...);            // OK: first \u201cargs\u201d expanded within h,\n                                          // second \u201cargs\u201d expanded within f\n}\n</code></pre>\n", "OwnerUserId": "725863", "PostTypeId": "2", "Id": "18668877", "Score": "3", "CreationDate": "2013-09-07T01:52:41.657", "LastActivityDate": "2013-09-07T01:52:41.657"}, "bq_ids": {"n4140": {"so_18382002_18668877_0": {"section_id": 123, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_18382002_18668877_0": {"section_id": 117, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_18382002_18668877_0": {"section_id": 127, "quality": 0.9545454545454546, "length": 21}}}, "18382002": {"CommentCount": "4", "AcceptedAnswerId": "18668877", "PostTypeId": "1", "LastEditorUserId": "878532", "CreationDate": "2013-08-22T13:34:44.897", "LastActivityDate": "2017-08-20T19:29:49.720", "LastEditDate": "2017-08-20T19:29:49.720", "ViewCount": "2235", "FavoriteCount": "4", "Title": "Multiple expansions of multiple parameter packs in the same expression", "Id": "18382002", "Score": "10", "Body": "<p>I want to ask if the following code is valid.</p>\n<p>I wonder about the possibility to expand parameter packs multiple times in one expression.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;tuple&gt;\n\nclass ExpandWithConstructor\n{\n    public:\n        template &lt;typename ... T&gt;\n        ExpandWithConstructor( T... args) { }\n};\n\ntemplate &lt;typename T&gt;\nint PrintArgs( T arg )\n{\n    std::cout &lt;&lt; arg  &lt;&lt; \", \";\n    return 0;\n}\n\ntemplate &lt;typename Head, typename ... T&gt;\nclass DebugPrinter: public DebugPrinter&lt;T...&gt;\n{\n    public:\n        DebugPrinter() { }\n\n        template&lt; typename ...Y&gt;\n        DebugPrinter( Y ... rest ) \n        {   \n            std::cout &lt;&lt; \"Construction of: \" &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \" Values: \" ;\n            ExpandWithConstructor{PrintArgs( rest)...};\n            std::cout &lt;&lt; std::endl;\n        }   \n\n};\n\ntemplate &lt;typename Head&gt;\nclass DebugPrinter&lt; Head &gt;\n{   \n    public:\n};  \n\ntemplate &lt;typename ... T&gt;\nclass TypeContainer: public std::tuple&lt;T...&gt;\n{\n    public:\n        TypeContainer(T... args):std::tuple&lt;T...&gt;(args...){};\n};\n\ntemplate &lt;typename... T1&gt; class CheckVariadic;\n\ntemplate &lt;typename... T1, typename ...T2&gt;\nclass CheckVariadic&lt; TypeContainer&lt;T1...&gt;, TypeContainer&lt;T2...&gt;&gt; :\n          public DebugPrinter&lt; T1, T2, T1...&gt;...\n{\n    public:\n        CheckVariadic( T1... args1, T2... args2, T1... args3): DebugPrinter&lt; T1, T2, T1...&gt;(args1, args2..., args1)... {}\n};\n\n\nint main()\n{\n    CheckVariadic&lt; TypeContainer&lt;int,float&gt;, TypeContainer&lt;char, void*&gt;&gt; checkVariadic1{ 1,2.2,'c',(void*)0xddddd,5,6.6,};\n}\n</code></pre>\n<p>As you can see the code uses :\n    DebugPrinter&lt; T1, T2, T1...&gt;...</p>\n<p>if T1 is given with \"int,float\" and T2 is \"char,void*\"\nwhich expands to</p>\n<pre><code>DebugPrinter&lt; T1, T2, int, float&gt;...\n</code></pre>\n<p>which expands to</p>\n<pre><code>DebugPrinter&lt; int, char, int, float&gt;\nDebugPrinter&lt; float, void*, int, float&gt;\n</code></pre>\n<p>The same expansion goes with:</p>\n<pre><code> DebugPrinter&lt; T1, T2, T1...&gt;(args1, args2..., args1)...\n</code></pre>\n<p>The code compiles with clang3.3 but NOT with gcc4.8.1 so I want to ask if the code is valid or not.</p>\n<p>Update:\ngcc 7.2 still did not compile the code. </p>\n", "Tags": "<c++><c++11><variadic-templates>", "OwnerUserId": "878532", "AnswerCount": "1"}});