post_cb({"2423412": {"PostTypeId": "2", "Body": "<p>This is C++ Standard 5.19:</p>\n<blockquote>\n<p id=\"so_2423352_2423412_0\">In several places, C + + requires expressions that evaluate to an integral or enumeration constant: as array\n  bounds (8.3.4, 5.3.4), as case expressions (6.4.2), as bit-field lengths (9.6), as enumerator initializers (7.2),\n  as static member initializers (9.4.2), and as integral or enumeration non-type template arguments (14.3).  </p>\n<pre><code>constant-expression:  \n            conditional-expression  \n</code></pre>\n<p id=\"so_2423352_2423412_1\">An integral constant-expression can involve only literals (2.13), enumerators, const variables or static\n  data members of integral or enumeration types initialized with constant expressions (8.5), non-type template\n  parameters of integral or enumeration types, and sizeof expressions. Floating literals (2.13.3) can\n  appear only if they are cast to integral or enumeration types. Only type conversions to integral or enumeration\n  types can be used. In particular, except in sizeof expressions, functions, class objects, pointers, or references shall not be used.</p>\n<p id=\"so_2423352_2423412_2\">Other expressions are considered constant-expressions only for the purpose of non-local static object\n  initialization (3.6.2).</p>\n</blockquote>\n", "LastActivityDate": "2010-03-11T08:08:17.277", "Id": "2423412", "Score": "1", "CreationDate": "2010-03-11T08:08:17.277", "ParentId": "2423352", "CommentCount": "0", "OwnerUserId": "123111"}, "2423392": {"PostTypeId": "2", "Body": "<p>It doesn't look very standard to me, what I am sure of is that C++ works with bool type, so bool type has to be returned (because you code is in C++, not C, because of templates). It might be that some automatic conversion happens. As a general rule of thumb, try to avoid macros in C++.</p>\n", "LastActivityDate": "2010-03-11T08:02:24.110", "Id": "2423392", "Score": "0", "CreationDate": "2010-03-11T08:02:24.110", "ParentId": "2423352", "CommentCount": "0", "OwnerUserId": "249460"}, "bq_ids": {"n4140": {"so_2423352_2423412_0": {"length": 15, "quality": 0.5172413793103449, "section_id": 6186}}}, "2424074": {"PostTypeId": "2", "Body": "<p>To answer the last bit: there are many constants that you can use in templates, but not in macro's. </p>\n<p>For instance, <code>sizeof(int)</code> is a constant expression. But <code>sizeof</code> expressions aren't evaluated in macro context. You can't write <code>#if sizeof(int)==4</code>. </p>\n<p>Also, the preprocessor can't deal with floating-point math at all.</p>\n", "LastActivityDate": "2010-03-11T10:16:07.353", "Id": "2424074", "Score": "1", "CreationDate": "2010-03-11T10:16:07.353", "ParentId": "2423352", "CommentCount": "0", "OwnerUserId": "15416"}, "2423384": {"PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_2423352_2423384_0\">is this standard?</p>\n</blockquote>\n<p>Yes. These are called <a href=\"http://msdn.microsoft.com/en-us/library/3ffb821x.aspx\" rel=\"nofollow noreferrer\">\"constant expressions\"</a>. (Also see 5.19 [expr.const] in the C++ standard.)</p>\n<blockquote>\n<p id=\"so_2423352_2423384_1\">if so, what do the conditional operators return? 0 and 1? are there limits?</p>\n</blockquote>\n<p><code>false</code> and <code>true</code>, which can be implicitly converted to 0 and 1. (Of course, in your case 0 is returned because <code>&amp;</code> has lower precedence than <code>==</code>.)</p>\n<blockquote>\n<p id=\"so_2423352_2423384_2\">can you do it in macros? defines?</p>\n</blockquote>\n<p>I don't understand this question. Some expressions are evaluated in preprocessing time in <code>#if</code>, but otherwise left untouched. </p>\n", "LastActivityDate": "2010-03-11T08:00:25.017", "Id": "2423384", "Score": "7", "CreationDate": "2010-03-11T08:00:25.017", "ParentId": "2423352", "CommentCount": "4", "OwnerUserId": "224671"}, "2424358": {"PostTypeId": "2", "Body": "<p>I think you misunderstand a bit.</p>\n<p>The actual evaluation of constant expressions is done by the compiler, not the preprocessor. The preprocessor only evaluates macros, which is about textual substitution.</p>\n<p>If you check out <a href=\"http://www.boost.org/doc/libs/1_42_0/libs/preprocessor/doc/index.html\" rel=\"nofollow noreferrer\">Boost.Preprocessor</a>, you'll realize that even simple operations like addition or soustractions cannot be expressed using common expressions if you want them to be evaluated by the preprocessor.</p>\n<pre><code>BOOST_PP_ADD(4, 3) // expands to 7\nBOOST_PP_SUB(4, 3) // expands to 1\n</code></pre>\n<p>This is done, behind the scenes, by substitions means, for example you could define it (though it would be very tiresome) like so:</p>\n<pre><code>#define ADD_IMPL_4_3 7\n\n#define BOOST_PP_ADD(lhs, rhs) ADD_IMPL_##lhs##_##rhs\n</code></pre>\n<p>So this is way different from what the compiler does ;)</p>\n<p>As for testing whether or not your compiler is able to evaluate an expression or not, just use a template.</p>\n<pre><code>template &lt;int x&gt; struct f {};\n\ntypedef f&lt; 3*4 / 5 &gt; super_f_type;\n</code></pre>\n<p>If it compiles, then the compiler was able to properly evaluate the expression... since otherwise it would not have been able to instantiate the template!</p>\n<p><em>Note:</em> the actual definition of <code>BOOST_PP_ADD</code> is much more complicated, this is a toy example and this may not work properly &gt; <code>BOOST_PP_ADD(BOOST_PP_SUB(4,3),3)</code>.</p>\n", "LastActivityDate": "2010-03-11T11:05:43.787", "Id": "2424358", "Score": "1", "CreationDate": "2010-03-11T11:05:43.787", "ParentId": "2423352", "CommentCount": "1", "OwnerUserId": "147192"}, "2423352": {"ViewCount": "1039", "Body": "<pre><code>template &lt;int T&gt;\nvoid aFunc(){}\n\nint main()\n{\n\n    int anArray[45-32];\n\n    switch(4)\n    {\n    case 4&lt;45:\n        break;\n    }\n    aFunc&lt;4*3/7&amp;8 == 45 - 5&gt;();\n}\n</code></pre>\n<p>so this all compiles in VC++ 2005</p>\n<p>is this standard? if so, what do the conditional operators return? 0 and 1? are there limits?</p>\n<p>and the thing that interests me the most, can you do it in macros? defines? </p>\n<p>Edit:</p>\n<p>to elaborate further on the preprocessor bit:</p>\n<pre><code>#define STRINGAFY(n)     #n\n#define STRINGAFY_2(n)   STRINGAFY(n)\n\n#define SOME_RANDOM_MACRO(n)     n\n\n\nprintf(\"%s\", STRINGAFY(1));  //prints out \"1\"\nprintf(\"%s\", STRINGAFY(SOME_RANDOM_MACRO(1)));  //prints out \"SOME_RANDOM_MACRO(1)\"\nprintf(\"%s\", STRINGAFY_2(SOME_RANDOM_MACRO(1)));  //causes SOME_RANDOM_MACRO to be evaluated and prints out \"1\"\nprintf(\"%s\", STRINGAFY_2(1+1)); // doesn't evaluate and print \"2\", prints \"1+1\" :(\n</code></pre>\n", "AcceptedAnswerId": "2424358", "Title": "what's the deal with compile time evaluation of constant arithmetic, and can it be done in the pre processor?", "CreationDate": "2010-03-11T07:53:41.150", "LastActivityDate": "2010-03-11T11:05:43.787", "CommentCount": "1", "LastEditDate": "2010-03-11T10:28:30.057", "PostTypeId": "1", "LastEditorUserId": "259846", "Id": "2423352", "Score": "3", "OwnerUserId": "259846", "Tags": "<c++><c>", "AnswerCount": "5"}});