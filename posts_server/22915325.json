post_cb({"22915325": {"CommentCount": "4", "ViewCount": "373", "PostTypeId": "1", "LastEditorUserId": "1033581", "CreationDate": "2014-04-07T14:28:20.363", "LastActivityDate": "2017-03-06T14:01:35.710", "Title": "Avoiding self assignment in std::shuffle", "FavoriteCount": "2", "LastEditDate": "2017-03-06T14:01:35.710", "Id": "22915325", "Score": "25", "Body": "<p>I stumbled upon the following problem when using the checked implementation of glibcxx:</p>\n<pre><code>/usr/include/c++/4.8.2/debug/vector:159:error: attempt to self move assign.\nObjects involved in the operation:\nsequence \"this\" @ 0x0x1b3f088 {\n  type = NSt7__debug6vectorIiSaIiEEE;\n}\n</code></pre>\n<p>Which I have reduced to this minimal example:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;random&gt;\n#include &lt;algorithm&gt;\n\nstruct Type {\n        std::vector&lt;int&gt; ints;\n};\n\nint main() {\n        std::vector&lt;Type&gt; intVectors = {{{1}}, {{1, 2}}};\n        std::shuffle(intVectors.begin(), intVectors.end(), std::mt19937());\n}\n</code></pre>\n<p>Tracing the problem I found that <code>shuffle</code> wants to <code>std::swap</code> an element with itself. As the <code>Type</code> is user defined and no specialization for <code>std::swap</code> has been given for it, the default one is used which creates a temporary and uses <code>operator=(&amp;&amp;)</code> to transfer the values:</p>\n<pre><code>  _Tp __tmp = _GLIBCXX_MOVE(__a);\n  __a = _GLIBCXX_MOVE(__b);\n  __b = _GLIBCXX_MOVE(__tmp);\n</code></pre>\n<p>As <code>Type</code> does not explicitly give <code>operator=(&amp;&amp;)</code> it is default implemented by \"recursively\" applying the same operation on its members. </p>\n<p>The problem occurs on line 2 of the swap code where <code>__a</code> and <code>__b</code> point to the same object which results in effect in the code <code>__a.operator=(std::move(__a))</code> which then triggers the error in the checked implementation of <code>vector::operator=(&amp;&amp;)</code>.</p>\n<p>My question is: Who's fault is this?</p>\n<ul>\n<li>Is it mine, because I should provide an implementation for <code>swap</code> that makes \"self swap\" a <code>NOP</code>?</li>\n<li>Is it <code>std::shuffle</code>'s, because it should not try to swap an element with itself?</li>\n<li>Is it the checked implementation's, because self-move-assigment is perfectly fine?</li>\n<li>Everything is correct, the checked implementation is just doing me a favor in doing this extra check (but then how to turn it off)?</li>\n</ul>\n<p>I have read about shuffle requiring the iterators to be ValueSwappable. Does this extend to self-swap (which is a mere runtime problem and can not be enforced by compile-time concept checks)?</p>\n<h2>Addendum</h2>\n<p>To trigger the error more directly one could use:</p>\n<pre><code>#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; vectorOfInts;\n    vectorOfInts = std::move(vectorOfInts);\n}\n</code></pre>\n<p>Of course this is quite obvious (why would you move a vector to itself?).\nIf you where swapping <code>std::vector</code>s directly the error would not occur because of the vector class having a custom implementation of the swap function that does not use <code>operator=(&amp;&amp;)</code>.</p>\n", "Tags": "<c++11><g++>", "OwnerUserId": "760746", "AnswerCount": "3"}, "23657560": {"ParentId": "22915325", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>It is a bug in GCC's checked implementation. According to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">the C++11 standard</a>, swappable requirements include (emphasis mine):</p>\n<blockquote>\n<p id=\"so_22915325_23657560_0\">17.6.3.2 \u00a74 An rvalue or lvalue <code>t</code> is swappable if and only if <code>t</code> is swappable with <em>any</em> rvalue or lvalue, respectively, of type <code>T</code></p>\n</blockquote>\n<p><em>Any</em> rvalue or lvalue includes, by definition, <code>t</code> itself, therefore to be swappable <code>swap(t,t)</code> must be legal. At the same time the default <code>swap</code> implementation requires the following</p>\n<blockquote>\n<p id=\"so_22915325_23657560_1\">20.2.2 \u00a72 Requires: Type <code>T</code> shall be MoveConstructible (Table 20) and MoveAssignable (Table 22).</p>\n</blockquote>\n<p>Therefore, to be swappable under the definition of the default swap operator self-move assignment must be valid and have the postcondition that after self assignment <code>t</code> is equivalent to it's old value (not necessarily a no-op though!) as per Table 22.</p>\n<p>Although the object you are swapping is not a standard type, MoveAssignable has no precondition that <code>rv</code> and <code>t</code> refer to different objects, and as long as all members are MoveAssignable (as <code>std::vector</code> should be) the generate move assignment operator must be correct (as it performs memberwise move assignment as per 12.8 \u00a729). Furthermore, although the note states that <code>rv</code> has valid but unspecified state, any state except being equivalent to it's original value would be incorrect for self assignment, as otherwise the postcondition would be violated.</p>\n", "OwnerUserId": "2361316", "LastEditorUserId": "2361316", "LastEditDate": "2014-05-14T15:05:09.500", "Id": "23657560", "Score": "4", "CreationDate": "2014-05-14T14:28:45.577", "LastActivityDate": "2014-05-14T15:05:09.500"}, "23435368": {"ParentId": "22915325", "CommentCount": "1", "Body": "<p>I read a couple of tutorials about copy constructors and mode assignments and stuff (for example <a href=\"http://blog.smartbear.com/c-plus-plus/c11-tutorial-introducing-the-move-constructor-and-the-move-assignment-operator/\" rel=\"nofollow\">this</a>). They all say that the object must check for self assignment and do nothing in that case. So I would say it is the checked implementation's fault, because self-move-assigment is perfectly fine.</p>\n", "OwnerUserId": "417577", "PostTypeId": "2", "Id": "23435368", "Score": "0", "CreationDate": "2014-05-02T19:14:09.967", "LastActivityDate": "2014-05-02T19:14:09.967"}, "bq_ids": {"n4140": {"so_22915325_23657560_0": {"section_id": 6280, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_22915325_23657560_0": {"section_id": 6040, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_22915325_23657560_0": {"section_id": 7787, "quality": 0.7777777777777778, "length": 7}}}, "23691322": {"ParentId": "22915325", "CommentCount": "0", "Body": "<p>Your implementation is over-sensitive.</p>\n<p>As you wished a standard quote proving that point, here it is:</p>\n<blockquote id=\"so_22915325_23691322_0\">\n<h3>17.6.3.1 Template argument requirements</h3>\n</blockquote>\n<pre class=\"lang-none prettyprint-override\"><code>Table 22 \u2014 MoveAssignable requirements [moveassignable]\n\nExpression     Return type     Return value Post-condition\nt = rv         T&amp; t            t is equivalent to the value of rv before the assignment\n[ Note: rv remains a valid object. Its state is unspecified.\u2014end note ]\n</code></pre>\n", "OwnerUserId": "3204551", "PostTypeId": "2", "Id": "23691322", "Score": "0", "CreationDate": "2014-05-16T01:36:18.807", "LastActivityDate": "2014-05-16T01:36:18.807"}});