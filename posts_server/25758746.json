post_cb({"25758818": {"ParentId": "25758746", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2014-09-10T06:36:26.223", "Score": "6", "LastEditorUserId": "187690", "LastEditDate": "2014-09-10T15:44:32.733", "Id": "25758818", "OwnerUserId": "187690", "Body": "<p>An explicitly specialized template function is no longer a template (it no longer depends on any template parameters). As such it obeys the One Definition Rule as an ordinary function. This means that the <em>definition</em> of an explicitly specialized function should be made once and only once in the entire program. I.e. you have to place the definition into an implementation file (<code>.cpp</code> file).</p>\n<p>However, you still have to <em>declare</em> this specialization in the header file (to tell the compiler that it actually exists). I.e. in the header file you have to do</p>\n<pre><code>template&lt;&gt; \nvoid Foo::print&lt;int&gt;(const int&amp; t);\n</code></pre>\n<p>(Note that per standard requirements it should be done in namespace scope, i.e. outside of the class definition.)</p>\n<p>Then in one implementation file you do</p>\n<pre><code>template&lt;&gt;\nvoid Foo::print&lt;int&gt;(const int&amp; t) {\n    std::cout &lt;&lt; t &lt;&lt; std::endl;\n}\n</code></pre>\n<p>P.S. Of course, just as with any other function, you can declare it <code>inline</code> and keep the definition in the header file.</p>\n", "LastActivityDate": "2014-09-10T15:44:32.733"}, "25758850": {"ParentId": "25758746", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-09-10T06:38:33.040", "Score": "0", "LastEditorUserId": "3647361", "LastEditDate": "2014-09-10T06:45:14.770", "Id": "25758850", "OwnerUserId": "3647361", "Body": "<p>The standard says (\u00a714.7.3/12):</p>\n<blockquote>\n<p id=\"so_25758746_25758850_0\">An explicit specialization of a function template is inline only if it\n  is declared with the inline specifier or defined as deleted, and\n  independently of whether its function template is inline.</p>\n</blockquote>\n<p>A specialization of a function template is treated by the ODR like a normal function (no specialization).\nIf you define the specialization inside the header, you have to declare it with the <code>inline</code> specifier, so several translation units can include it.</p>\n<p>If you want to define it in the source file, you have to declare the specialization inside the  header (at namespace scope):</p>\n<pre><code>template&lt;&gt;\nvoid Foo::print&lt;int&gt;(const int&amp;);\n</code></pre>\n<p>And put the definition in the source file</p>\n<pre><code>template&lt;&gt;\nvoid Foo::print&lt;int&gt;(const int&amp; t)\n{\n    std::cout &lt;&lt; t &lt;&lt; std::endl;\n}\n</code></pre>\n<p>, just as you're used to with normal functions.</p>\n", "LastActivityDate": "2014-09-10T06:45:14.770"}, "bq_ids": {"n4140": {"so_25758746_25758850_0": {"section_id": 274, "quality": 1.0, "length": 16}}, "n3337": {"so_25758746_25758850_0": {"section_id": 265, "quality": 1.0, "length": 16}}, "n4659": {"so_25758746_25758850_0": {"section_id": 281, "quality": 1.0, "length": 16}}}, "25758746": {"CommentCount": "0", "AcceptedAnswerId": "25758818", "CreationDate": "2014-09-10T06:31:59.120", "LastActivityDate": "2014-09-10T15:44:32.733", "PostTypeId": "1", "ViewCount": "50", "FavoriteCount": "1", "Title": "Specialisations of class template members", "Id": "25758746", "Score": "1", "Body": "<p>I have a header containing a class with a template member and some specialisations of that member:</p>\n<pre><code>#include &lt;iostream&gt;\nclass Foo {\npublic:\n    template&lt;typename T&gt;\n    void print(const T&amp; t) {\n        std::cout &lt;&lt; t &lt;&lt; std::endl;\n    }\n};\n\ntemplate&lt;&gt;\nvoid Foo::print&lt;int&gt;(const int&amp; t) {\n    std::cout &lt;&lt; t &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This header is included in multiple source files.</p>\n<p>If I put the specialisation inside the class definition, then GCC complains:</p>\n<pre><code>error: explicit specialization in non-namespace scope \u2018class Foo\u2019\n</code></pre>\n<p>But if I move the specialisation outside the class definition, then VC++ complains about multiply-defined symbols.</p>\n<p>What's the right way of doing this that both compilers will be happy with?</p>\n", "Tags": "<c++><templates><template-specialization>", "OwnerUserId": "274460", "AnswerCount": "2"}});