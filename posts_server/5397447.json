post_cb({"5398498": {"Id": "5398498", "PostTypeId": "2", "Body": "<p>No. That is not possible. It's because of <strong>lack of standardization of C++ at the binary level</strong>.</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Don_Box\">Don Box</a> writes (quoting from his book <a href=\"http://rads.stackoverflow.com/amzn/click/0201634465\">Essential COM</a>, chapter <em>COM As A Better C++</em>)</p>\n<blockquote>\n<h1>C++ and Portability</h1>\n<p id=\"so_5397447_5398498_0\"><br/>\n  Once the decision is made to\n  distribute a C++ class as a DLL, one\n  is faced with one of <strong>the fundamental\n  weaknesses of C++</strong>, that is, <strong>lack of\n  standardization at the binary level</strong>.\n  Although the ISO/ANSI C++ Draft\n  Working Paper attempts to codify which\n  programs will compile and what the\n  semantic effects of running them will\n  be, <strong>it makes no attempt to standardize\n  the binary runtime model of C++</strong>. The\n  first time this problem will become\n  evident is when a client tries to link\n  against the FastString DLL's import library from\n  a C++ developement environment <em>other\n  than</em> the one used to build the\n  FastString DLL.</p>\n</blockquote>\n<p>struct-padding is done differently by different compilers. Even if you use the same compiler, the packing alignment for structs can be different based on what <a href=\"http://msdn.microsoft.com/en-us/library/2e70t5y1%28v=VS.100%29.aspx\">pragma pack</a> you're using.</p>\n<p>Not only that if you write two structs whose members are <em>exactly</em> same, the <strong>only</strong> difference is that the order in which they're declared is different, then size of each struct can be (and often is) different.</p>\n<p>For example, see this,</p>\n<pre><code>struct A\n{\n   char c;\n   char d;\n   int i;\n};\nstruct B\n{\n   char c;\n   int i;\n   char d;\n};\nint main() {\n        cout &lt;&lt; sizeof(A) &lt;&lt; endl;\n        cout &lt;&lt; sizeof(B) &lt;&lt; endl;\n}\n</code></pre>\n<p>Compile it with <code>gcc-4.3.4</code>, and you get this output:</p>\n<pre><code>8\n12\n</code></pre>\n<p>That is, sizes are different even though both structs has same members!</p>\n<p>Code at Ideone  : <a href=\"http://ideone.com/HGGVl\">http://ideone.com/HGGVl</a></p>\n<p>The bottomline is that the Standard doesn't talk about how padding should be done, and so the compilers are free to make any decision and you <strong>cannot</strong> assume all compilers make the same decision.</p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2011-03-23T05:47:00.530", "Score": "32", "CreationDate": "2011-03-22T22:12:34.080", "ParentId": "5397447", "CommentCount": "3", "OwnerUserId": "415784", "LastEditDate": "2011-03-23T05:47:00.530"}, "5397484": {"Id": "5397484", "PostTypeId": "2", "Body": "<p>No, there's no safe way. In addition to padding, you have to deal with different byte ordering, and different sizes of builtin types.</p>\n<p>You need to define a file format, and convert your struct to and from that format. Serialization libraries (e.g. boost::serialization, or google's protocolbuffers) can help with this.</p>\n", "LastActivityDate": "2011-03-22T20:32:41.523", "CommentCount": "2", "CreationDate": "2011-03-22T20:32:41.523", "ParentId": "5397447", "Score": "6", "OwnerUserId": "616700"}, "5397447": {"ViewCount": "31747", "Body": "<p>If I have a <code>struct</code> in c++, is there no way to safely read/write it to a file that is cross-platform/compiler compatible? Because if I understand correctly, every compiler 'pads' differently based on the target platform.</p>\n", "AcceptedAnswerId": "5398498", "Title": "struct padding in c++", "CreationDate": "2011-03-22T20:29:29.260", "Id": "5397447", "CommentCount": "1", "FavoriteCount": "16", "PostTypeId": "1", "LastActivityDate": "2011-03-23T05:47:00.530", "Score": "32", "OwnerUserId": "331785", "Tags": "<c++><struct>", "AnswerCount": "5"}, "5397471": {"Id": "5397471", "PostTypeId": "2", "Body": "<p>You could use something like <code>boost::serialization</code>.</p>\n", "LastActivityDate": "2011-03-22T20:31:28.433", "CommentCount": "0", "CreationDate": "2011-03-22T20:31:28.433", "ParentId": "5397447", "Score": "2", "OwnerUserId": "346332"}, "bq_ids": {"n4140": {"so_5397447_5397599_0": {"length": 17, "quality": 0.6296296296296297, "section_id": 7240}}, "n3337": {"so_5397447_5397599_0": {"length": 17, "quality": 0.6296296296296297, "section_id": 6984}}, "n4659": {"so_5397447_5397599_0": {"length": 15, "quality": 0.5555555555555556, "section_id": 8749}}}, "5397638": {"Id": "5397638", "PostTypeId": "2", "Body": "<p>If you have the opportunity to design the struct yourself, it should be possible. The basic idea is that you should design it so that there would be no need to insert pad bytes into it. the second trick is that you must handle differences in endianess.</p>\n<p>I'll describe how to construct the struct using scalars, but the you should be able to use nested structs, as long as you would apply the same design for each included struct.</p>\n<p>First, a basic fact in C and C++ is that the alignment of a type can not exceed the size of the type. If it would, then it would not be possible to allocate memory using <code>malloc(N*sizeof(the_type))</code>.</p>\n<p>Layout the struct, starting with the largest types.</p>\n<pre><code> struct\n {\n   uint64_t alpha;\n   uint32_t beta;\n   uint32_t gamma;\n   uint8_t  delta;\n</code></pre>\n<p>Next, pad out the struct manually, so that in the end you will match up the largest type:</p>\n<pre><code>   uint8_t  pad8[3];    // Match uint32_t\n   uint32_t pad32;      // Even number of uint32_t\n }\n</code></pre>\n<p>Next step is to decide if the struct should be stored in little or big endian format. The best way is to \"swap\" all the element <em>in situ</em> before writing or after reading the struct, if the storage format does not match the endianess of the host system.</p>\n", "LastActivityDate": "2011-03-22T20:47:38.310", "CommentCount": "6", "CreationDate": "2011-03-22T20:47:38.310", "ParentId": "5397447", "Score": "12", "OwnerUserId": "623133"}, "5397599": {"Id": "5397599", "PostTypeId": "2", "Body": "<p>Long story short, no.  There is no platform-independent, Standard-conformant way to deal with padding.  </p>\n<p>Padding is called \"alignment\" in the Standard, and it begins discussing it in 3.9/5:</p>\n<blockquote>\n<p id=\"so_5397447_5397599_0\">Object types have alignment\n  requirements (3.9.1, 3.9.2). The\n  alignment of a complete object type is\n  an implementation-defined integer\n  value representing a number of bytes;\n  an object is allocated at an address\n  that meets the alignment requirements\n  of its object type.</p>\n</blockquote>\n<p>But it goes on from there and winds off to many dark corners of the Standard.  Alignment is \"implementation-defined\" meaning it can be different across different compilers, or even across address models (ie 32-bit/64-bit) under the <em>same</em> compiler.</p>\n<p>Unless you have truly harsh performance requirements, you might consider storing your data to disc in a different format, like char strings.  Many high-performance protocols send everything using strings when the natural format might be something else.  For example, a low-latency exchange feed I recently worked on sends dates as strings formatted like this: \"20110321\" and times are sent similarly: \"141055.200\".  Even though this exchange feed sends 5 million messages per second all day long, they still use strings for everything because that way they can avoid endian-ness and other issues.</p>\n", "LastActivityDate": "2011-03-22T20:43:33.070", "CommentCount": "0", "CreationDate": "2011-03-22T20:43:33.070", "ParentId": "5397447", "Score": "3", "OwnerUserId": "241536"}});