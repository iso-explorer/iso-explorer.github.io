post_cb({"bq_ids": {"n4140": {"so_39925842_39926298_1": {"length": 43, "quality": 0.9555555555555556, "section_id": 223}, "so_39925842_39926298_0": {"length": 36, "quality": 1.0, "section_id": 224}}, "n3337": {"so_39925842_39926298_1": {"length": 43, "quality": 0.9555555555555556, "section_id": 216}, "so_39925842_39926298_0": {"length": 36, "quality": 1.0, "section_id": 217}}, "n4659": {"so_39925842_39926298_1": {"length": 44, "quality": 0.9777777777777777, "section_id": 231}, "so_39925842_39926298_0": {"length": 36, "quality": 1.0, "section_id": 232}}}, "39926298": {"Id": "39926298", "PostTypeId": "2", "Body": "<p><a href=\"https://timsong-cpp.github.io/cppwp/temp.dep.candidate#1\" rel=\"nofollow\">[temp.dep.candidate]/1</a>:</p>\n<blockquote>\n<p id=\"so_39925842_39926298_0\">If the call would be ill-formed or would find a better match had the\n  lookup within the associated namespaces considered all the function\n  declarations with external linkage introduced in those namespaces in\n  all translation units, not just considering those declarations found\n  in the template definition and template instantiation contexts, then\n  the program has undefined behavior.</p>\n</blockquote>\n<p>Moreover, <a href=\"https://timsong-cpp.github.io/cppwp/temp.point#8\" rel=\"nofollow\">[temp.point]/6</a>, emphasis mine:</p>\n<blockquote>\n<p id=\"so_39925842_39926298_1\">A specialization for a function template [...] may have multiple\n  points of instantiations within a translation unit, and in addition to\n  the points of instantiation described above, for any such\n  specialization that has a point of instantiation within the\n  translation unit, <strong>the end of the translation unit is also considered a\n  point of instantiation</strong>. [...] If two different points of instantiation\n  give a template specialization different meanings according to the\n  one-definition rule ([basic.def.odr]), the program is ill-formed, no\n  diagnostic required.</p>\n</blockquote>\n<p>The behavior of your program is undefined.</p>\n", "LastActivityDate": "2016-10-07T21:52:17.667", "CommentCount": "1", "CreationDate": "2016-10-07T21:52:17.667", "ParentId": "39925842", "Score": "4", "OwnerUserId": "2756719"}, "39925842": {"ViewCount": "86", "Body": "<p>Here is a minimalist example of a very strange overload resolution from a template context:</p>\n<pre><code>#include &lt;iostream&gt;\n\n// Types //\nstruct I { int v; };\n\ntemplate &lt;class T&gt;\nstruct D { T t; };\n\n// Functions //\n\n// Overload 1\ntemplate &lt;class T&gt;\nI f(T) { return {1}; }\n\n// Template indirection that calls f(T)\ntemplate &lt;class T&gt;\nI g(D&lt;T&gt;) { return f(T{}); }\n\n// Non template indirection that calls f(T)\nI h(D&lt;I&gt;) { return f(I{}); }\n\nint main() {\n    std::cout\n        &lt;&lt; f(I{}).v     // f(I{}) overload called directly\n        &lt;&lt; \"\\n\"         //    =&gt; overload 1 called\n        &lt;&lt; h(D&lt;I&gt;{}).v  // f(I{}) called though non-template\n        &lt;&lt; \"\\n\"         //    =&gt; overload 1 called\n        &lt;&lt; g(D&lt;I&gt;{}).v  // f(I{}) called though template\n        &lt;&lt; \"\\n\";        //    =&gt; overload 2 actually called ???\n}\n\n// Overload 2\n// Should not be reachable as declared after all f(...) calls.\n// If was a candidate, would be chosen over 1.\nI f(I) { return {2}; }\n</code></pre>\n<p>This seem to be related to <a href=\"http://en.cppreference.com/w/cpp/language/adl\" rel=\"nofollow\">ADL</a> because if <code>I</code> is placed in a namespace \"overload 1\" is always called. </p>\n<p>I know that ADL is performed as if the call was made from the template instantiation point (<code>main</code>).</p>\n<blockquote>\n<p id=\"so_39925842_39925842_0\">For a dependent name used in a template definition, the lookup is postponed until the template arguments are known, at which time ADL examines function declarations with external linkage (until C++11) that are visible from the template definition context as well as in the template instantiation context, while non-ADL lookup only examines function declarations with external linkage (until C++11) that are visible from the template definition context.\n  <a href=\"http://en.cppreference.com/w/cpp/language/unqualified_lookup#Template_definition\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/unqualified_lookup#Template_definition</a></p>\n</blockquote>\n<p>But here \"Overload 2\" is declared AFTER <code>main</code>! <code>main</code> being the instanciation point of <code>g</code> and <code>f</code>, I assumed only function declared <em>before</em> <code>main</code> would be overload candidates.</p>\n<p>Note that this behaviour is related to <code>g</code> being template as <code>h</code> (<code>g</code>'s equivalent not template function) calls \"Overload 1\".</p>\n<p><strong>How can \"overload 2\" -being declared after <code>main</code>- ever be called ?</strong></p>\n<p>This behaviour has been reproduced with clang++ (3.8.1) and g++ (6.2.1).</p>\n", "AcceptedAnswerId": "39926298", "Title": "C++ template overload resolution called from template function pick candidate declared after template instantiation", "CreationDate": "2016-10-07T21:09:24.863", "Id": "39925842", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-10-07T21:30:37.243", "LastEditorUserId": "6939185", "LastActivityDate": "2016-10-07T21:52:17.667", "Score": "9", "OwnerUserId": "6939185", "Tags": "<c++><templates><overload-resolution>", "AnswerCount": "1"}});