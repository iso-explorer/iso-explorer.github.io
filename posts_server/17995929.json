post_cb({"17995929": {"CommentCount": "3", "AcceptedAnswerId": "17996671", "PostTypeId": "1", "LastEditorUserId": "1000282", "CreationDate": "2013-08-01T13:49:32.493", "LastActivityDate": "2013-08-21T07:03:09.600", "LastEditDate": "2013-08-01T19:23:24.840", "ViewCount": "311", "FavoriteCount": "1", "Title": "Does the standard define the type for `a[i]` where `a` is `T [M][N]`?", "Id": "17995929", "Score": "5", "Body": "<p>I, very occasionally, make use of multidimensional arrays, and got curious what the standard says (C11 and/or C++11) about the behavior of indexing with less \"dimensions\" than the one declared for the array.</p>\n<p>Given:</p>\n<pre><code>int a[2][2][2] = {{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}};\n</code></pre>\n<p>Does the standard says what type <code>a[1]</code> is, or <code>a[0][1]</code>, is it legal, and whether it should properly index sub-arrays as expected?</p>\n<pre><code>auto&amp; b = a[1];\n\nstd::cout &lt;&lt; b[1][1];\n</code></pre>\n", "Tags": "<c++><c><multidimensional-array><language-lawyer>", "OwnerUserId": "1000282", "AnswerCount": "4"}, "17998239": {"ParentId": "17995929", "CommentCount": "0", "CreationDate": "2013-08-01T15:25:57.897", "OwnerUserId": "827263", "PostTypeId": "2", "Id": "17998239", "Score": "1", "Body": "<p>The key point to remember is that, in both C and C++, a multidimensional array is simply an array of arrays (so a 3-dimensional array is an array of arrays of arrays). All the syntax and semantics of multidimensional arrays follow from that (and from the other rules of the language, of course).</p>\n<p>So given an object definition:</p>\n<pre><code>int m[2][2][2];\n</code></pre>\n<p><code>m</code> is an object of type <code>int[2][2][2]</code> (an array of two arrays, each of which consists of two elements, each of which consists of two elements, each of which is an array of two <code>int</code>s).</p>\n<p>When you write <code>m[1][1][1]</code>, you're already evaluating <code>m</code>, <code>m[1]</code> and <code>m[1][1]</code>.</p>\n<p>The expression <code>m</code> is an lvalue referring to an array object of type <code>int[2][2][2]</code>. </p>\n<p>In <code>m[1]</code>, the array expression <code>m</code> is implicitly converted to (\"decays\" to) a pointer to the array's first element. This pointer is of type <code>int(*)[2][2]</code>, a pointer to a two-element array of two-element arrays of <code>int</code>. <code>m[1]</code> is by definition equivalent to <code>*(m+1)</code>; the <code>+1</code> advances <code>m</code> by one element and dereferences the resulting pointer value. So <code>m[1]</code> refers to an object of type <code>int[2][2]</code> (an array of two arrays, each of which consists of two <code>int</code> elements).</p>\n<p>(The array indexing operator <code>[]</code> is defined to operate on a <em>pointer</em>, not an array. In a common case like <code>arr[42]</code>, the pointer happens to be the result of an implicit array-to-pointer conversion.)</p>\n<p>We repeat the process for <code>m[1][1]</code>, giving us a pointer to an array of two <code>int</code>s (of type <code>int(*)[2]</code>).</p>\n<p>Finally, <code>m[1][1][1]</code> takes the result of evaluating <code>m[1][1]</code> and repeats the process yet again, giving us an lvalue referring to an object of type <code>int</code>. And that's how multidimensional arrays work.</p>\n<p>Just to add to the frivolity, an expression like <code>foo[index1][index2][index3]</code> can work directly with pointers as well as with arrays. That means you can construct something that works (almost) like a true multidimensional array using pointers and allocations of arbitrary size. This gives you the possibility of having \"ragged\" arrays with different numbers of elements in each row, or even rows and elements that are missing. But then it's up to you to manage the allocation and deallocation for each row, or even for each element.</p>\n<p>Recommended reading: Section 6 of the <a href=\"http://www.c-faq.com/\" rel=\"nofollow\">comp.lang.c FAQ</a>.</p>\n<p>A side note: There are languages where multidimensional arrays are <em>not</em> arrays of arrays. In Ada, for example (which uses parentheses rather than square brackets for array indexing), you can have an array of arrays, indexed like <code>arr(i)(j)</code>, or you can have a two-dimensional array, indexed like <code>arr(i, j)</code>. C is different; C doesn't have direct built-in support for multidimensional arrays, but it gives you the tools to build them yourself.</p>\n", "LastActivityDate": "2013-08-01T15:25:57.897"}, "17996671": {"ParentId": "17995929", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2013-08-01T14:20:13.120", "Score": "2", "LastEditorUserId": "1673391", "LastEditDate": "2013-08-21T07:03:09.600", "Id": "17996671", "OwnerUserId": "1009479", "Body": "<p>I think this example in C11 explained it implicitly.</p>\n<blockquote>\n<h3><a href=\"http://c0x.coding-guidelines.com/6.5.2.1.html\" rel=\"nofollow\">C11 6.5.2.1 Array subscripting</a></h3>\n<p id=\"so_17995929_17996671_0\">EXAMPLE Consider the array object defined by the declaration <code>int x[3][5];</code> Here <code>x</code> is a 3 \u00d7 5 array of ints; more precisely, <code>x</code> is an array of three element objects, each of which is an array of five ints. In the expression <code>x[i]</code>, which is equivalent to <code>(*((x) + (i)))</code>, <code>x</code> is first converted to a pointer to the initial array of five ints. Then <code>i</code> is adjusted according to the type of <code>x</code>, which conceptually entails multiplying <code>i</code> by the size of the object to which the pointer points, namely an array of five <code>int</code> objects. The results are added and indirection is applied to yield an array of five ints. When used in the expression <code>x[i][j]</code>, that array is in turn converted to a pointer to the first of the ints, so <code>x[i][j]</code> yields an <code>int</code>.</p>\n</blockquote>\n<p>The similar is in C++11 8.3.4 Arrays</p>\n<blockquote>\n<p id=\"so_17995929_17996671_1\">Example: consider</p>\n<pre><code>int x[3][5];\n</code></pre>\n<p id=\"so_17995929_17996671_2\">Here <code>x</code> is a 3 \u00d7 5 array of integers. When <code>x</code> appears in an expression, it is converted to a pointer to (the first of three) five-membered arrays of integers. In the expression <code>x[i]</code> which is equivalent to <code>*(x + i)</code>, <code>x</code> is first converted to a pointer as described; then x + i is converted to the type of <code>x</code>, which involves multiplying <code>i</code> by the length of the object to which the pointer points, namely five integer objects. The results are added\n  and indirection applied to yield an array (of five integers), which in turn is converted to a pointer to the first of the integers. If there is another subscript the same argument applies again; this time the result is an integer. \u2014end example ] \u2014end note ]</p>\n</blockquote>\n", "LastActivityDate": "2013-08-21T07:03:09.600"}, "17996468": {"ParentId": "17995929", "CommentCount": "5", "CreationDate": "2013-08-01T14:10:57.483", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "17996468", "Score": "3", "Body": "<blockquote>\n<p id=\"so_17995929_17996468_0\">Does the standard define the type for <code>a[i]</code> where <code>a</code> is <code>T [M][N]</code>?</p>\n</blockquote>\n<p>Of course. The standard basically defines the types of <em>all</em> expressions, and if it does not, it would be a defect report. But I guess you are more interested on what that type might be...</p>\n<p>While the standard may not explicitly mention your case, the rules are stated and are simple, given an array <code>a</code> of <code>N</code> elements of type <code>T</code>, the expression <code>a[0]</code> is an lvalue expression of type <code>T</code>. In the variable declaration <code>int a[2][2]</code> the type of <code>a</code> is <em>array of 2 elements of type array of two elements of type <code>int</code></em>, which applying the rule above means that <code>a[0]</code> is <em>lvalue to an array of 2 elements</em>, or as you would have to type it in a program: <code>int (&amp;)[2]</code>. Adding extra dimensions does not affect the mechanism.</p>\n", "LastActivityDate": "2013-08-01T14:10:57.483"}, "17996004": {"ParentId": "17995929", "CommentCount": "4", "CreationDate": "2013-08-01T13:52:37.550", "OwnerUserId": "2478565", "PostTypeId": "2", "Id": "17996004", "Score": "5", "Body": "<p><code>m[1]</code> is just of type <code>int[2][2]</code>. Likewise <code>m[0][1]</code> is just <code>int[2]</code>. And yes, indexing as sub-arrays works the way you think it does.</p>\n", "LastActivityDate": "2013-08-01T13:52:37.550"}, "bq_ids": {"n4140": {"so_17995929_17996671_2": {"section_id": 3235, "quality": 0.9166666666666666, "length": 55}}, "n3337": {"so_17995929_17996671_2": {"section_id": 3108, "quality": 0.9166666666666666, "length": 55}}, "n4659": {"so_17995929_17996671_2": {"section_id": 3991, "quality": 0.9166666666666666, "length": 55}}}});