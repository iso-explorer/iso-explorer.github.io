post_cb({"29890125": {"ParentId": "29889604", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>A class (be it a template or not) can (and should) be declared in any compilation unit that referes to it.</p>\n<p>A static field initialization does defines a variable, and as such it should exist only in one compilation unit -&gt; that's the reason why you get an error when class <code>A</code> is not a template.</p>\n<p>But when you declare a template, nothing is really created untill you instantiate it. As you never instantiate the template, the static field is never defined and you get no error.</p>\n<p>If you had two different instantiations in <code>source1.cpp</code> (say <code>A&lt;B&gt;</code>) and <code>main.cpp</code> (say <code>A&lt;C&gt;</code>) all will still be fine : you would get <code>A&lt;B&gt;::x</code> in source1 and <code>A&lt;C&gt;::x</code> in main =&gt; two different variables since <code>A&lt;B&gt;</code> and <code>A&lt;C&gt;</code> are different classes.</p>\n<p>The case where you instantiate same class in different compilation units is trickier. It should generate an error, but if it did, you could hardly declare special fields in templates. So it is processed as a special case by the compiler as it is explained in this <a href=\"https://stackoverflow.com/a/1553875/3545273\">other answer</a> to generate no errors.</p>\n", "OwnerUserId": "3545273", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:44:38.037", "Id": "29890125", "Score": "0", "CreationDate": "2015-04-27T07:55:06.387", "LastActivityDate": "2015-04-27T08:02:19.153"}, "29889929": {"ParentId": "29889604", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Templates as the name suggest are the the fragments of code that will be used several times for different parameters. For templates the compiler is to ensure if their methods and static fiels definition are linked only ones. So if you create a static field with its default value the compiler is obliged to provide single memory cell (for the same template parameter set) even though the template class header is included several times. Unfortunetly non-template classes you need to be managed by yourself.</p>\n<p>As for the second question, I believe the standard does not state when the static fields need to be initialized, each compiler can implement then it in its own manner.</p>\n", "OwnerUserId": "4324224", "LastEditorUserId": "4324224", "LastEditDate": "2015-04-27T07:50:04.657", "Id": "29889929", "Score": "0", "CreationDate": "2015-04-27T07:44:09.540", "LastActivityDate": "2015-04-27T07:50:04.657"}, "29890206": {"ParentId": "29889604", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Compiler will remove duplicate template instantiations on its own. If you turn your template class into regular one, then its your duty to make sure only one definition of static variable exists (otherwise linker error will appear). Also remember that static data members are not shared between instatiations of templates for different types. With c++11 you can control instatiations on your own using extern templates: <a href=\"https://stackoverflow.com/questions/8130602/using-extern-template-c0x\">using extern template (C++11)</a>.</p>\n<p>As for the point of instatiation for static members:</p>\n<blockquote>\n<p id=\"so_29889604_29890206_0\">14.6.4.1 Point of instantiation [temp.point]\n  1 For a function template specialization, a member function template specialization, or a specialization for a\n  member function <strong>or static data member of a class template</strong>, if the specialization is implicitly instantiated\n  because it is referenced from within another template specialization and the context from which it is referenced\n  depends on a template parameter, the point of instantiation of the specialization is the point of\n  instantiation of the enclosing specialization. Otherwise, <strong>the point of instantiation for such a specialization\n  immediately follows the namespace scope declaration or definition that refers to the specialization.</strong></p>\n</blockquote>\n<p>so point of instatiation should be ie. right after main() if you use your type for the first time inside main().</p>\n", "OwnerUserId": "471160", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:44:38.037", "Id": "29890206", "Score": "2", "CreationDate": "2015-04-27T07:59:22.947", "LastActivityDate": "2015-04-27T07:59:22.947"}, "29890055": {"ParentId": "29889604", "PostTypeId": "2", "CommentCount": "1", "Body": "<ol>\n<li><p>It is necessary to instantiate/initialize static members in cpp files not in headers. Static members are property of class not property of objects, so if you include header file in more cpp files, it looks like you are initializing it more times.</p></li>\n<li><p>Answer to this question is more complex. Template is not one class. It is instantiating on demand. It means that every different use of template is one standalone \"template instance\". For example if you use <code>A&lt;int&gt;</code> and <code>A&lt;float&gt;</code> than you will have 2 different classes therefore you would need to initialize <code>A&lt;int&gt;::x</code> and <code>A&lt;float&gt;::x</code>.</p></li>\n</ol>\n<p>For more info see this answer: <a href=\"https://stackoverflow.com/a/607335/1280316\">https://stackoverflow.com/a/607335/1280316</a></p>\n", "OwnerUserId": "1280316", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:59:18.930", "Id": "29890055", "Score": "0", "CreationDate": "2015-04-27T07:51:31.107", "LastActivityDate": "2015-04-27T07:57:31.550"}, "29889604": {"CommentCount": "4", "AcceptedAnswerId": "29890206", "CreationDate": "2015-04-27T07:24:02.883", "LastActivityDate": "2015-04-27T08:02:19.153", "PostTypeId": "1", "ViewCount": "766", "FavoriteCount": "0", "Title": "Template class's static variable initialization, c++", "Id": "29889604", "Score": "0", "Body": "<p>consider the following code:</p>\n<pre><code>//header.h\ntemplate&lt;class T&gt;\nclass A\n{\n    static int x;\n};\n\ntemplate&lt;class T&gt;\nint A&lt;T&gt;::x = 0;\n\n//source1.cpp\n#include \"header.h\"\nvoid f(){} // dummy function\n\n\n//main.cpp\n#include \"header.h\"\nint main(){}\n</code></pre>\n<p>In this case code compiles perfectly without errors, but if I remove the template qualifier from class    </p>\n<pre><code>class A\n{\n    static int x;\n};\n\nint A::x = 0;\n</code></pre>\n<ol>\n<li>In this case compiler erred with multiple definition of x. Can anybody explain this behavior?   </li>\n<li>And when the template class's static variable is initialized / instantiated?? </li>\n</ol>\n", "Tags": "<c++><templates><static><instantiation><linkage>", "OwnerUserId": "1856429", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_29889604_29890206_0": {"section_id": 216, "quality": 0.9074074074074074, "length": 49}}, "n3337": {"so_29889604_29890206_0": {"section_id": 210, "quality": 0.9074074074074074, "length": 49}}, "n4659": {"so_29889604_29890206_0": {"section_id": 224, "quality": 0.9074074074074074, "length": 49}}}});