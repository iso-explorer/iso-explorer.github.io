post_cb({"37970907": {"Id": "37970907", "PostTypeId": "2", "Body": "<p>The problem in each case is that the compiler is trying to infer <code>argument_types</code> from the <code>method</code> argument, which is illegal as variadic template parameters can only be inferred when they are at the end of an argument list.</p>\n<pre><code>void (foo::*method)(argument_types ... arguments, int, int, int)\n                    ^^^^^^^^^^^^^^^^^^ can't infer here\n                                                ^^^^^^^^^^^^^^^ because of these\n</code></pre>\n<p>The workaround is to protect <code>argument_types</code> from being deduced in this context, using a helper like <code>identity</code>:</p>\n<pre><code>template&lt;class T&gt; struct identity { using type = T; };\ntemplate&lt;class T&gt; using identity_t = typename identity&lt;T&gt;::type;\n\n// ...\n\ntemplate&lt;typename ... argument_types&gt;\nvoid invoke_foo(foo* instance, int first, int second, int third,\n    void (foo::*method)(identity_t&lt;argument_types&gt; ... arguments, int, int, int), argument_types ... arguments)\n//                      ^^^^^^^^^^^ fix here\n</code></pre>\n<hr>\n<p>Is this a bug in your code, or in the compilers? Actually, it's a bug in the compilers (yes, all of them); the question is whether a parameter pack appearing within a function type and not at the end of an argument list is a non-deduced context. The relevant part of the standard is <a href=\"http://eel.is/c++draft/temp.deduct.type\" rel=\"nofollow\">[temp.deduct.type]</a>, which states:</p>\n<blockquote>\n<p id=\"so_37969651_37970907_0\">5 - The non-deduced contexts are: [...]</p>\n<ul>\n<li>A function parameter pack that does not occur at the end of the parameter-declaration-list.</li>\n</ul>\n<p id=\"so_37969651_37970907_1\">6 - When a type name is specified in a way that includes a non-deduced context, all of the types that comprise that type name are also non-deduced. However, a compound type can include both deduced and non-deduced types.</p>\n</blockquote>\n<p>Here, <code>argument_types</code> is in a non-deduced context when deducing the type of <code>method</code>, but a deduced context when deducing the types for the trailing arguments of <code>invoke_foo</code>.</p>\n<p>Another compiler you could test is ICC (Intel C++ Compiler); ICC rejects the first two forms and accepts the last two, the exact opposite to gcc. The reason that compilers can be so different in their behavior is that dealing with this kind of code is essentially a matter of error handling, specifically recognising when template parameters appear in non-deduced contexts and using the types deduced elsewhere instead. The compilers are (each in their own way) recognising that <code>argument_types</code> cannot be deduced within <code>method</code>, but failing to realise or accept that it can be deduced elsewhere.</p>\n<p>Specifically, it appears that:</p>\n<ul>\n<li>gcc assumes that if it cannot deduce <code>argument_types</code> from <code>method</code>, it must be empty;</li>\n<li>clang assumes that if <code>argument_types</code> is deduced to be empty or explicitly specified, this must be an error;</li>\n<li>MSVC is unable to let the deduction of <code>argument_types</code> override the failure to deduce it, but is OK if it is explicitly specified;</li>\n<li>ICC assumes that if <code>argument_types</code> is deduced to be empty, this must be an error.</li>\n</ul>\n</hr>", "LastEditorUserId": "567292", "LastActivityDate": "2016-06-22T21:49:51.263", "Score": "4", "CreationDate": "2016-06-22T14:22:57.570", "ParentId": "37969651", "CommentCount": "8", "OwnerUserId": "567292", "LastEditDate": "2016-06-22T21:49:51.263"}, "bq_ids": {"n4140": {"so_37969651_37970907_1": {"length": 24, "quality": 1.0, "section_id": 337}}, "n3337": {"so_37969651_37970907_1": {"length": 24, "quality": 1.0, "section_id": 327}}, "n4659": {"so_37969651_37970907_1": {"length": 24, "quality": 1.0, "section_id": 346}}}, "37969651": {"ViewCount": "122", "Body": "<p>I needed to make a function that takes a function pointer with variable arguments and some fixed arguments after them and could not make it work on Visual Studio 2013. I assumed that maybe Visual Studio 2013 was missing something which is often a case and made a minimal example that did what I needed and tried it against gcc and clang. And I got totally different results on all three compilers. So the questions which I'd like to resolve are:</p>\n<ol>\n<li>Is my example valid at all? If not what am I doing wrong?</li>\n<li>If my example is valid, any hints on the behavior of gcc and clang (lets count msvc out since it is a black box)?</li>\n</ol>\n<p>The example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct foo\n{\n    void work(int first, int second, int third)\n    {\n        std::cout &lt;&lt; \"0: \" &lt;&lt; first &lt;&lt; \",1: \" &lt;&lt; second &lt;&lt; \",2: \" &lt;&lt; third &lt;&lt; std::endl;\n    }\n    void work_with_double(double first, int second, int third, int fourth)\n    {\n        std::cout &lt;&lt; \"0: \" &lt;&lt; first &lt;&lt; \",1: \" &lt;&lt; second &lt;&lt; \",2: \" &lt;&lt; third &lt;&lt; \",3: \" &lt;&lt; fourth &lt;&lt; std::endl;\n    }\n};\n\ntemplate&lt;typename ... argument_types&gt;\nvoid invoke_foo(foo* instance, int first, int second, int third, void (foo::*method)(argument_types ... arguments, int, int, int), argument_types ... arguments)\n{\n    (instance-&gt;*method)(arguments ..., first, second, third);\n}\n\nint main(int argc, char** argv)\n{\n    foo instance;\n    invoke_foo(&amp;instance, 1, 2, 3, &amp;foo::work); // gcc ok, clang err, msvc 2013 err\n    invoke_foo&lt;&gt;(&amp;instance, 1, 2, 3, &amp;foo::work); // gcc ok, clang err, msvc 2013 err\n    invoke_foo(&amp;instance, 1, 2, 3, &amp;foo::work_with_double, 1.0); // gcc err, clang ok, msvc 2013 err\n    invoke_foo&lt;double&gt;(&amp;instance, 1, 2, 3, &amp;foo::work_with_double, 1.0); // gcc err, clang err, msvc 2013 ok\n    return 0;\n}\n</code></pre>\n<p><strong>Modified snippet that makes Visual Studio 2015 (w/o updates) crash</strong></p>\n<p>If <code>invoke_foo</code> is made as a member function of an object, Visual Studio 2015 crashes.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nstruct foo\n{\n    void work(int first, int second, int third, int fourth, int fifth, int sixth, int seventh, int eight)\n    {\n        std::cout &lt;&lt; \"0: \" &lt;&lt; first &lt;&lt; \",1: \" &lt;&lt; second &lt;&lt; \",2: \" &lt;&lt; third &lt;&lt; std::endl;\n    }\n    void work_with_double(double firstExtra, int first, int second, int third, int fourth, int fifth, int sixth, int seventh, int eight)\n    {\n        std::cout &lt;&lt; \"0: \" &lt;&lt; first &lt;&lt; \",1: \" &lt;&lt; second &lt;&lt; \",2: \" &lt;&lt; third &lt;&lt; \",3: \" &lt;&lt; fourth &lt;&lt; std::endl;\n    }\n};\n\nstruct bar\n{\n\n};\n\nstruct wrapper\n{\n\n    template &lt;typename T&gt; struct non_deduced { using type = T; };\n    template &lt;typename T&gt; using non_deduced_t = typename non_deduced&lt;T&gt;::type;\n\n    template&lt;typename ... argument_types&gt;\n    std::shared_ptr&lt;bar&gt; invoke_foo(int first, int second, int third, int fourth, int fifth, int sixth, int seventh, int eight, void (foo::*method)(non_deduced_t&lt;argument_types&gt;... arguments, int, int, int, int, int, int, int, int), argument_types ... arguments)\n    {\n        (foo_.get()-&gt;*method)(arguments ..., first, second, third, fourth, fifth, sixth, seventh, eight);\n        return nullptr;\n    }\n\n    std::unique_ptr&lt;foo&gt; foo_ = std::move(std::unique_ptr&lt;foo&gt;(new foo));\n\n};\n\nint main(int argc, char** argv)\n{\n    wrapper instance;\n    instance.invoke_foo(1, 2, 3, 4, 5, 6, 7, 8, &amp;foo::work);\n    instance.invoke_foo(1, 2, 3, 4, 5, 6, 7, 8, &amp;foo::work_with_double, 1.0);\n}\n</code></pre>\n", "AcceptedAnswerId": "37970907", "Title": "Different results on a variadic template example among gcc, clang and msvc - can anyone explain?", "CreationDate": "2016-06-22T13:32:06.353", "Id": "37969651", "CommentCount": "4", "LastEditDate": "2016-06-28T12:08:20.633", "PostTypeId": "1", "LastEditorUserId": "1458617", "LastActivityDate": "2016-06-28T12:08:20.633", "Score": "4", "OwnerUserId": "1458617", "Tags": "<c++11><gcc><clang><variadic-templates><msvc12>", "AnswerCount": "1"}});