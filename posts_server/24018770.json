post_cb({"24018770": {"CommentCount": "8", "ViewCount": "457", "PostTypeId": "1", "LastEditorUserId": "1783614", "CreationDate": "2014-06-03T15:12:46.300", "LastActivityDate": "2014-06-04T11:58:07.650", "Title": "function pointer bit shift", "LastEditDate": "2014-06-03T15:13:24.023", "Id": "24018770", "Score": "0", "Body": "<p>I have the following code:</p>\n<pre><code>void (* point)();\npoint=prova;\nunsigned long int imm8 = point&lt;&lt;24;\n\n...\nvoid prova(){\n...\n}\n</code></pre>\n<p>The third line of code I have error: </p>\n<blockquote>\n<p id=\"so_24018770_24018770_0\">invalid operands to binary &lt;&lt; (have 'void (*)()' and 'int')</p>\n</blockquote>\n<p>I'm trying to apply the shift operator to a function pointer, but I get the following error. how can I do?</p>\n", "Tags": "<c++><function-pointers>", "OwnerUserId": "3699721", "AnswerCount": "3"}, "24018843": {"ParentId": "24018770", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>There should be no <em>valid</em> reason for doing this. However, you can do this by first casting to <code>unsigned long int</code></p>\n<pre><code>unsigned long int imm8 = reinterpret_cast&lt;unsigned long int &gt;(point)&lt;&lt;24;\n</code></pre>\n<p>Here <code>reinterpret_cast</code> is done to <em>treat the pointer as <code>unsigned long int</code></em>. Note that it is not portable and has the possibility of data loss.</p>\n", "OwnerUserId": "1390091", "LastEditorUserId": "1390091", "LastEditDate": "2014-06-04T03:46:18.753", "Id": "24018843", "Score": "0", "CreationDate": "2014-06-03T15:15:53.917", "LastActivityDate": "2014-06-04T03:46:18.753"}, "24023672": {"ParentId": "24018770", "CommentCount": "0", "Body": "<p>There is no portable way to do this.</p>\n<p>The standard guarantees that you can convert a <code>void*</code> to <code>uintptr_t</code> without loss of information -- but it doesn't guarantee that <code>uintptr_t</code> exists. A conforming implementation might not have an integer type wide enough to hold a converted pointer without loss of information.</p>\n<p>And even if <code>uintptr_t</code> exists, the language only guarantees that you can convert <code>void*</code> to <code>uintptr_t</code> without loss of information. A conforming permission might have, for example, 64-bit object pointers, 64-bit <code>uintprt_t</code>, and 128-bit function pointers.</p>\n<p>It's likely, in most implementations, that you <em>can</em> convert a function pointer to <code>uintptr_t</code> without loss of information. (I think POSIX guarantees this, though the ISO C and C++ standards do not.)</p>\n<p>Once you've done that, probably using a <code>reinterpret_cast</code>, you have an unsigned integer, which you can shift as you like.</p>\n<p>The result of this shift will almost certainly be meaningless garbage. C++ doesn't prevent you from shooting yourself in the foot, which is what you appear to be trying to do.</p>\n", "OwnerUserId": "827263", "PostTypeId": "2", "Id": "24023672", "Score": "2", "CreationDate": "2014-06-03T19:46:28.370", "LastActivityDate": "2014-06-03T19:46:28.370"}, "bq_ids": {"n4140": {"so_24018770_24018870_0": {"section_id": 6146, "quality": 0.8888888888888888, "length": 8}, "so_24018770_24018870_1": {"section_id": 6047, "quality": 0.9117647058823529, "length": 31}}, "n3337": {"so_24018770_24018870_0": {"section_id": 5909, "quality": 0.8888888888888888, "length": 8}, "so_24018770_24018870_1": {"section_id": 5815, "quality": 0.9117647058823529, "length": 31}}, "n4659": {"so_24018770_24018870_0": {"section_id": 7642, "quality": 0.8888888888888888, "length": 8}, "so_24018770_24018870_1": {"section_id": 7546, "quality": 0.9117647058823529, "length": 31}}}, "24018870": {"ParentId": "24018770", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I don't see why you want to do this but the error is correct, the draft C++ standard in section <code>5.8</code> <em>Shift operators</em> says;</p>\n<blockquote>\n<p id=\"so_24018770_24018870_0\">The operands shall be of integral or unscoped enumeration type and integral promotions are performed.[...]</p>\n</blockquote>\n<p>You can use <a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast\" rel=\"nofollow noreferrer\">reinterpret_cast</a> to convert it to an integral type(<a href=\"https://stackoverflow.com/questions/1845482/what-is-uintptr-t-data-type\">uintptr_t</a>) if needed. The linked reference contains the following example:</p>\n<pre><code>int i = 7;\n\n// pointer to integer and back\nuintptr_t v1 = reinterpret_cast&lt;uintptr_t&gt;(&amp;i); // static_cast is an error\n</code></pre>\n<p><b>Warning</b></p>\n<p>This type of conversion is only conditionally supported, we can see this from the C++ draft standard section <code>5.2.10</code> <em>Reinterpret cast</em> which says:</p>\n<blockquote>\n<p id=\"so_24018770_24018870_1\">Converting a function pointer to an object pointer type or vice versa\n  is conditionally-supported. The meaning of such a conversion is\n  implementation-defined, except that if an implementation supports\n  conversions in both directions, converting a prvalue of one type to\n  the other type and back, possibly with different cv- qualification,\n  shall yield the original pointer value.</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:11:03.907", "Id": "24018870", "Score": "3", "CreationDate": "2014-06-03T15:17:16.810", "LastActivityDate": "2014-06-03T19:55:52.433"}});