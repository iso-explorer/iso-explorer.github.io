post_cb({"bq_ids": {"n4140": {"so_9491973_9492837_3": {"length": 28, "quality": 0.9333333333333333, "section_id": 268}}, "n3337": {"so_9491973_9492837_3": {"length": 28, "quality": 0.9333333333333333, "section_id": 259}}, "n4659": {"so_9491973_9492837_3": {"length": 28, "quality": 0.9333333333333333, "section_id": 275}}}, "9492024": {"Id": "9492024", "PostTypeId": "2", "Body": "<p>Because <code>typename</code> is only to be used when indicating types from within a template.</p>\n", "LastActivityDate": "2012-02-29T00:38:04.727", "CommentCount": "6", "CreationDate": "2012-02-29T00:38:04.727", "ParentId": "9491973", "Score": "1", "OwnerUserId": "129570"}, "9492837": {"Id": "9492837", "PostTypeId": "2", "Body": "<p>You are actually asking for two different things, although both related to template instantiation.</p>\n<blockquote>\n<p id=\"so_9491973_9492837_0\">Why does the first piece of code compile?</p>\n</blockquote>\n<p>The standard states that the actual instantiation of the template is performed <em>after</em> the whole translation unit is processed, which means that the <em>real</em> instantiation of the template will be after all types defined in that translation unit are complete, even if the <em>point of instantiation</em> is different and much earlier in the translation unit. More on this in this other <a href=\"https://stackoverflow.com/questions/7210286/incomplete-class-usage-in-template\">question</a></p>\n<blockquote>\n<p id=\"so_9491973_9492837_1\">Why does the second example not compile?</p>\n</blockquote>\n<p>The problem with the second example is that the standard requires that an specialization of a template must be <em>declared</em> before the first use of that specialization. </p>\n<blockquote>\n<p id=\"so_9491973_9492837_2\">\u00a714.7.3p6 (C++03)</p>\n<p id=\"so_9491973_9492837_3\">If a template, a member template or the member of a class template is explicitly specialized then that specialization shall be declared before the first use of that specialization that would cause an implicit instantia- tion to take place, in every translation unit in which such a use occurs; no diagnostic is required.</p>\n</blockquote>\n<p>Note that there are two different concepts here. The <em>point of instantiation</em> refers to <em>where</em> in the code the instantiation takes place, not <em>when</em> it is instantiated. In your example the <em>point of instantiation</em> is the expression <code>C&lt;float&gt; gc;</code>, while the <em>when</em> as in all other cases is <em>after the whole translation unit is processed</em>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-02-29T02:49:13.553", "Score": "3", "CreationDate": "2012-02-29T02:37:39.660", "ParentId": "9491973", "CommentCount": "7", "OwnerUserId": "36565", "LastEditDate": "2017-05-23T10:34:50.803"}, "9492047": {"Id": "9492047", "PostTypeId": "2", "Body": "<p>You just have to remove the unnecessary typename qualifier and rearrange things a bit. As 2nd the error message says, you have specialized <code>A&lt;C&gt;</code> after it's already been instantiated in <code>C</code>. To fix this you can move the specialization of <code>A&lt;C&gt;</code> up to before the definition of <code>C</code> and then forward declare <code>C</code> to get rid of the undeclared identifier error.</p>\n<p>Here's the fixed code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;typename T&gt;\nstruct A {\n    struct B {\n    };\n};\n\nstruct C; // Forward declaration of C\n\ntemplate &lt;&gt;\nstruct A&lt;C&gt; {\n    struct B {\n        B() {\n            cout &lt;&lt; \"B::B()\" &lt;&lt; endl;\n        }\n\n        ~B() {\n            cout &lt;&lt; \"B::~B()\" &lt;&lt; endl;\n        }\n    };\n};\n\nstruct C {\n    typedef A&lt;C&gt; D;\n\n    int f() {\n        D::B p;\n        return 0;\n    }\n};\n\nC gc;\nint x = gc.f();\n\n\nint main() {\n}\n</code></pre>\n", "LastActivityDate": "2012-02-29T00:40:54.457", "CommentCount": "0", "CreationDate": "2012-02-29T00:40:54.457", "ParentId": "9491973", "Score": "2", "OwnerUserId": "185171"}, "9491973": {"ViewCount": "299", "Body": "<p>I wonder if anyone knows why the following two pieces of code behave very differently.  I can understand why the second one doesn't work, but why does the first one work?  At the same place <code>int x = gc.f();</code> the template should get instantiated so the same error would occur, but why actually there is no error?</p>\n<p><strong>a.cpp</strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;typename T&gt;\nstruct A {\n    struct B {\n    };\n};\n\ntemplate &lt;typename T&gt;\nstruct C {\n    typedef A&lt;C&lt;T&gt; &gt; D;\n\n    int f() {\n        typename D::B p;\n        return 0;\n    }\n};\n\nC&lt;float&gt; gc;\nint x = gc.f();\n\ntemplate &lt;typename T&gt;\nstruct A&lt;C&lt;T&gt; &gt; {\n    struct B {\n        B() {\n            cout &lt;&lt; \"B::B()\" &lt;&lt; endl;\n        }\n\n        ~B() {\n            cout &lt;&lt; \"B::~B()\" &lt;&lt; endl;\n        }\n    };\n};\n\nint main() {\n}\n</code></pre>\n<p><strong>output</strong></p>\n<pre><code>B::B()\nB::~B()\n</code></pre>\n<p>and</p>\n<p><strong>a2.cpp</strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;typename T&gt;\nstruct A {\n    struct B {\n    };\n};\n\nstruct C {\n    typedef A&lt;C&gt; D;\n\n    int f() {\n        D::B p;\n        return 0;\n    }\n};\n\nC gc;\nint x = gc.f();\n\ntemplate &lt;&gt;\nstruct A&lt;C&gt; {\n    struct B {\n        B() {\n            cout &lt;&lt; \"B::B()\" &lt;&lt; endl;\n        }\n\n        ~B() {\n            cout &lt;&lt; \"B::~B()\" &lt;&lt; endl;\n        }\n    };\n};\n\nint main() {\n}\n</code></pre>\n<p><strong>compiler error</strong></p>\n<pre><code>a2.cpp:24: error: specialization of \u2018A&lt;C&gt;\u2019 after instantiation\na2.cpp:24: error: redefinition of \u2018struct A&lt;C&gt;\u2019\na2.cpp:6: error: previous definition of \u2018struct A&lt;C&gt;\u2019\n</code></pre>\n", "AcceptedAnswerId": "9492837", "Title": "The timing of C++ template instantiation", "CreationDate": "2012-02-29T00:32:29.900", "Id": "9491973", "CommentCount": "2", "LastEditDate": "2012-02-29T01:59:44.507", "PostTypeId": "1", "LastEditorUserId": "875044", "LastActivityDate": "2012-02-29T02:49:13.553", "Score": "4", "OwnerUserId": "875044", "Tags": "<c++>", "AnswerCount": "3"}});