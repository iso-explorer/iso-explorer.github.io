post_cb({"1527766": {"Id": "1527766", "PostTypeId": "2", "Body": "<p>Allocating aligned memory is trickier than it looks - see for example <em><a href=\"http://jongampark.wordpress.com/2008/06/12/implementation-of-aligned-memory-alloc/\" rel=\"nofollow noreferrer\">Implementation of aligned memory allocation</a></em></p>\n", "LastEditorUserId": "63550", "LastActivityDate": "2017-09-03T13:11:12.493", "Score": "1", "CreationDate": "2009-10-06T20:00:03.290", "ParentId": "1527680", "CommentCount": "2", "OwnerUserId": "10897", "LastEditDate": "2017-09-03T13:11:12.493"}, "9796188": {"Id": "9796188", "PostTypeId": "2", "Body": "<p>This is what I'm using.  In addition to this, if you're allocating memory then a new()'d array of char with length greater than or equal to max_alignment will be aligned to max_alignment so you can then use indexes into that array to get aligned addresses.        </p>\n<pre><code>enum {\n            max_alignment = boost::mpl::deref&lt;\n                boost::mpl::max_element&lt;\n                        boost::mpl::vector&lt;\n                            boost::mpl::int_&lt;boost::alignment_of&lt;signed char&gt;::value&gt;::type,\n                            boost::mpl::int_&lt;boost::alignment_of&lt;short int&gt;::value&gt;::type,\n                            boost::mpl::int_&lt;boost::alignment_of&lt;int&gt;::value&gt;::type,                                boost::mpl::int_&lt;boost::alignment_of&lt;long int&gt;::value&gt;::type,\n                            boost::mpl::int_&lt;boost::alignment_of&lt;float&gt;::value&gt;::type,\n                            boost::mpl::int_&lt;boost::alignment_of&lt;double&gt;::value&gt;::type,\n                            boost::mpl::int_&lt;boost::alignment_of&lt;long double&gt;::value&gt;::type,\n                            boost::mpl::int_&lt;boost::alignment_of&lt;void*&gt;::value&gt;::type\n                        &gt;::type\n                    &gt;::type\n                &gt;::type::value\n            };\n        }\n</code></pre>\n", "LastActivityDate": "2012-03-20T22:46:53.313", "CommentCount": "1", "CreationDate": "2012-03-20T22:46:53.313", "ParentId": "1527680", "Score": "-2", "OwnerUserId": "1282098"}, "1527760": {"Id": "1527760", "PostTypeId": "2", "Body": "<p>Short of some <code>maximally_aligned_t</code> type that all compilers promised faithfully to support for all architectures everywhere, I don't see how this could be solved at compile time.  As you say, the set of potential types is unbounded.  Is the extra pointer indirection really that big a deal?</p>\n", "LastActivityDate": "2009-10-06T19:59:06.740", "CommentCount": "2", "CreationDate": "2009-10-06T19:59:06.740", "ParentId": "1527680", "Score": "5", "OwnerUserId": "121674"}, "bq_ids": {"n4140": {"so_1527680_4564433_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 6092}}, "n3337": {"so_1527680_4564433_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 5859}}, "n4659": {"so_1527680_4564433_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 7588}}}, "1527680": {"ViewCount": "3747", "Body": "<p>Is there any <em>portable</em> way to determine what the maximum possible alignment for <em>any</em> type is?</p>\n<p>For example on x86, SSE instructions require 16-byte alignment, but as far as I'm aware, no instructions require more than that, so any type can be safely stored into a 16-byte aligned buffer. </p>\n<p>I need to create a buffer (such as a char array) where I can write objects of arbitrary types, and so I need to be able to rely on the beginning of the buffer to be aligned.</p>\n<p>If all else fails, I know that allocating a char array with <code>new</code> is guaranteed to have maximum alignment, but with the TR1/C++0x templates <code>alignment_of</code> and <code>aligned_storage</code>, I am wondering if it would be possible to create the buffer in-place in my buffer class, rather than requiring the extra pointer indirection of a dynamically allocated array.</p>\n<p>Ideas?</p>\n<p>I realize there are plenty of options for determining the max alignment for a bounded set of types: A union, or just <code>alignment_of</code> from TR1, but my problem is that the set of types is unbounded. I don't know in advance which objects must be stored into the buffer.</p>\n", "AcceptedAnswerId": "4564433", "Title": "Determining maximum possible alignment in C++", "CreationDate": "2009-10-06T19:44:06.240", "Id": "1527680", "CommentCount": "5", "FavoriteCount": "11", "PostTypeId": "1", "LastEditDate": "2011-05-16T13:52:37.310", "LastEditorUserId": "33213", "LastActivityDate": "2017-09-03T13:11:12.493", "Score": "19", "OwnerUserId": "33213", "Tags": "<c++><alignment><c++11>", "AnswerCount": "6"}, "16071777": {"Id": "16071777", "PostTypeId": "2", "Body": "<p>In C++11 std::max_align_t defined in header cstddef is a POD type whose alignment requirement is at least as strict (as large) as that of every scalar type. </p>\n<p>Using the new alignof operator it would be as simple as <code>alignof(std::max_align_t)</code></p>\n", "LastActivityDate": "2013-04-17T23:06:24.443", "CommentCount": "2", "CreationDate": "2013-04-17T23:06:24.443", "ParentId": "1527680", "Score": "9", "OwnerUserId": "762809"}, "3126992": {"Id": "3126992", "PostTypeId": "2", "Body": "<p>Unfortunately ensuring max alignment is a lot tougher than it should be, and there are no guaranteed solutions AFAIK. From the <a href=\"http://www.gotw.ca/\" rel=\"nofollow noreferrer\">GotW</a> blog (<a href=\"http://www.gotw.ca/gotw/028.htm\" rel=\"nofollow noreferrer\">Fast Pimpl article</a>):</p>\n<pre><code>union max_align {\n  short       dummy0;\n  long        dummy1;\n  double      dummy2;\n  long double dummy3;\n  void*       dummy4;\n  /*...and pointers to functions, pointers to\n       member functions, pointers to member data,\n       pointers to classes, eye of newt, ...*/\n};\n\nunion {\n  max_align m;\n  char x_[sizeofx];\n};\n</code></pre>\n<blockquote>\n<p id=\"so_1527680_3126992_0\">This isn't guaranteed to be fully\n  portable, but in practice it's close\n  enough because there are few or no\n  systems on which this won't work as\n  expected.</p>\n</blockquote>\n<p>That's about the closest 'hack' I know for this. </p>\n<p>There is another approach that I've used personally for super fast allocation. Note that it is evil, but I work in raytracing fields where speed is one of the greatest measures of quality and we profile code on a daily basis. It involves using a heap allocator with pre-allocated memory that works like the local stack (just increments a pointer on allocation and decrements one on deallocation). </p>\n<p>I use it for <a href=\"http://c2.com/cgi/wiki?PimplIdiom\" rel=\"nofollow noreferrer\">Pimpls</a> particularly. However, just having the allocator is not enough; for such an allocator to work, we have to assume that memory for a class, Foo, is allocated in a constructor, the same memory is likewise deallocated only in the destructor, and that Foo itself is created on the stack. To make it safe, I needed a function to see if the 'this' pointer of a class is on the local stack to determine if we can use our super fast heap-based stack allocator. For that we had to research OS-specific solutions: I used <a href=\"http://en.wikipedia.org/wiki/Win32_Thread_Information_Block\" rel=\"nofollow noreferrer\">TIBs</a> and <a href=\"http://en.wikipedia.org/wiki/Win32_Thread_Information_Block\" rel=\"nofollow noreferrer\">TEBs</a> for Win32/Win64, and my co-workers found solutions for Linux and Mac OS X.</p>\n<p>The result, after a week of researching OS-specific methods to detect stack range, alignment requirements, and doing a lot of testing and profiling, was an allocator that could allocate memory in 4 clock cycles according to our tick counter benchmarks as opposed to about 400 cycles for malloc/operator new (our test involved thread contention so malloc is likely to be a bit faster than this in single-threaded cases, perhaps a couple of hundred cycles). We added a per-thread heap stack and detected which thread was being used which increased the time to about 12 cycles, though the client can keep track of the thread allocator to get the 4 cycle allocations. It wiped out memory allocation based hotspots off the map.</p>\n<p>While you don't have to go through all that trouble, writing a fast allocator might be easier and more generally applicable (ex: allowing the amount of memory to allocate/deallocate to be determined at runtime) than something like <code>max_align</code> here. <code>max_align</code> is easy enough to use, but if you're after speed for memory allocations (and assuming you've already profiled your code and found hotspots in malloc/free/operator new/delete with major contributors being in code you have control over), writing your own allocator can really make the difference.</p>\n", "LastEditorUserId": "63550", "LastActivityDate": "2011-01-02T15:55:25.177", "Score": "5", "CreationDate": "2010-06-27T09:43:52.913", "ParentId": "1527680", "CommentCount": "4", "OwnerUserId": "374980", "LastEditDate": "2011-01-02T15:55:25.177"}, "4564433": {"Id": "4564433", "PostTypeId": "2", "Body": "<p>In C++0x, the <code>Align</code> template parameter of <code>std::aligned_storage&lt;Len, Align&gt;</code> has a default argument of \"default-alignment,\" which is defined as (N3225 \u00a720.7.6.6 Table 56):</p>\n<blockquote>\n<p id=\"so_1527680_4564433_0\">The value of default-alignment shall be the most stringent alignment requirement for any C++ object type whose size is no greater than <code>Len</code>.</p>\n</blockquote>\n<p>It isn't clear whether SSE types would be considered \"C++ object types.\"</p>\n<p>The default argument wasn't part of the TR1 <code>aligned_storage</code>; it was added for C++0x.</p>\n", "LastActivityDate": "2010-12-30T16:42:33.103", "CommentCount": "0", "CreationDate": "2010-12-30T16:42:33.103", "ParentId": "1527680", "Score": "9", "OwnerUserId": "151292"}});