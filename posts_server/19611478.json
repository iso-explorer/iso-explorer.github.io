post_cb({"19611478": {"ViewCount": "180", "Body": "<p>I am new to programming in C++ and I have encountered a problem that I cannot seem to solve when enforcing separate compilation. I am trying to specialize my class <code>tokenize</code> to add a dtor for a specific type (<code>istream</code>). I have the following:</p>\n<pre><code>#ifndef __TOKENIZER_H__\n#define __TOKENIZER_H__\n\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n\ntemplate &lt;class T&gt;\nclass base {\n  // ... some methods/member variables.\n};\n\ntemplate &lt;class T&gt;\nclass tokenizer : public base&lt;T&gt; {\n  public:\n    tokenizer(T &amp;in);\n};\n\ntemplate &lt;&gt;\nclass tokenizer&lt;std::ifstream&gt; : public base&lt;std::ifstream&gt; {\n  public:\n    tokenizer(std::ifstream &amp;in);\n    ~tokenizer();\n};\n\n#endif\n</code></pre>\n<p>... and:</p>\n<pre><code>#include \"tokenizer.h\"\n\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;locale&gt;\n\nusing std::ifstream;\nusing std::istream;\nusing std::string;\n\n// [BASE]\n\n// ... code for those functions.\n\n// [TOKENIZER]\n\n// See header file.\ntemplate &lt;class T&gt;\ntokenizer&lt;T&gt;::tokenizer(T &amp;in) : base&lt;T&gt;(in) { }\n\n// See header file.\ntemplate &lt;&gt;\ntokenizer&lt;ifstream&gt;::tokenizer(ifstream &amp;in) : base&lt;ifstream&gt;(in) { }\n\n// See header file.\ntemplate &lt;&gt;\ntokenizer&lt;ifstream&gt;::~tokenizer() {\n  delete &amp;(base&lt;ifstream&gt;::in);\n}\n\n// Intantiating template classes (separate compilation).\ntemplate class base&lt;std::ifstream&gt;;\ntemplate class base&lt;std::istream&gt;;\ntemplate class tokenizer&lt;std::ifstream&gt;;\ntemplate class tokenizer&lt;std::istream&gt;;\n</code></pre>\n<p>... however I get the following error:</p>\n<pre><code>tokenizer.cc:62: error: template-id \u2018tokenizer&lt;&gt;\u2019 for \u2018tokenizer&lt;std::basic_ifstream&lt;char, std::char_traits&lt;char&gt; &gt; &gt;::tokenizer(std::ifstream&amp;)\u2019 does not match any template declaration\ntokenizer.cc:66: error: template-id \u2018tokenizer&lt;&gt;\u2019 for \u2018tokenizer&lt;std::basic_ifstream&lt;char, std::char_traits&lt;char&gt; &gt; &gt;::~tokenizer()\u2019 does not match any template declaration\n</code></pre>\n<p>I am compiling with g++. If someone can kindly point out what I am missing and a possible explanation then that would be fantastic. I am confused how templates work with separate compilation (defns/decl separated).</p>\n", "AcceptedAnswerId": "19611775", "Title": "C++ Class Template Specialization", "CreationDate": "2013-10-26T20:21:00.657", "Id": "19611478", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-10-26T21:32:42.503", "Score": "0", "OwnerUserId": "2648745", "Tags": "<c++><templates>", "AnswerCount": "1"}, "19611775": {"Id": "19611775", "PostTypeId": "2", "Body": "<p>[temp.expl.spec]/5 states:</p>\n<blockquote>\n<p id=\"so_19611478_19611775_0\">Members of an explicitly specialized class template are defined in the same manner as members of normal classes, and not using the <code>template&lt;&gt;</code> syntax. The same is true when defining a member of an explicitly specialized member class. However, <code>template&lt;&gt;</code> is used in\n  defining a member of an explicitly specialized member class template that is specialized as a class template.</p>\n</blockquote>\n<p>It also provides the following example (I'll only quote some excerpts):</p>\n<blockquote id=\"so_19611478_19611775_1\">\n<pre><code>template&lt;class T&gt; struct A {\n    template&lt;class U&gt; struct C { };\n};\n\ntemplate&lt;&gt; struct A&lt;int&gt; {\n    void f(int);\n};\n\n// template&lt;&gt; not used for a member of an\n// explicitly specialized class template\nvoid A&lt;int&gt;::f(int) { /\u2217 ... \u2217/ }\n\ntemplate&lt;&gt; template&lt;class U&gt; struct A&lt;char&gt;::C {\n    void f();\n};\n// template&lt;&gt; is used when defining a member of an explicitly\n// specialized member class template specialized as a class template\ntemplate&lt;&gt;\ntemplate&lt;class U&gt; void A&lt;char&gt;::C&lt;U&gt;::f() { /\u2217 ... \u2217/ }\n</code></pre>\n</blockquote>\n<p>As far as I know, once you've explicit specialized a class template, you've created a \"normal class\". It's obviously not a template any more (you cannot create classes from the specialization), but a type with some <code>&lt;..&gt;</code> in its name.</p>\n<p>In your case, that just means leave out the <code>template&lt;&gt;</code> before</p>\n<blockquote id=\"so_19611478_19611775_2\">\n<pre><code>// See header file.\n//template &lt;&gt;\ntokenizer&lt;ifstream&gt;::tokenizer(ifstream &amp;in) : base&lt;ifstream&gt;(in) { }\n\n// See header file.\n//template &lt;&gt;\ntokenizer&lt;ifstream&gt;::~tokenizer() {\n  delete &amp;(base&lt;ifstream&gt;::in);\n}\n</code></pre>\n</blockquote>\n<hr>\n<p>With regard to your request on clarification of the combination of separate compilation with templates:</p>\n<p>When you use a class template to create an object (e.g. <code>std::vector&lt;int&gt; v</code>) or call a function template (e.g. <code>std::sort(begin(v), end(v))</code>), you're dealing with <em>specializations</em> of the templates. <code>std::vector&lt;int&gt;</code> is a specialization of the class template <code>std::vector</code>.</p>\n<p>When a specialization is required in a TU, it might be necessary to produce it from the class template. This is called <em>instantiation</em>. An explicitly specialized template won't be instantiated implicitly (it already <em>is</em> specialized). That is, your specialization <code>tokenizer&lt;ifstream&gt;</code> doesn't have to be instantiated in any TU.</p>\n<p>Templates itself don't work with separate compilation for these reasons. However, you can use explicit instantiations and explicit specializations to provide the benefits of separate compilation for <em>specializations</em> of templates. For example:</p>\n<p>[header.hpp]</p>\n<pre><code>template&lt;class T&gt; void foo(T);\nextern template void foo&lt;int&gt;(int);\n</code></pre>\n<p>[impl.cpp]</p>\n<pre><code>#include \"header.hpp\"\n\ntemplate&lt;class T&gt; void foo(T) { return T{} };\n\ntemplate void foo&lt;int&gt;(int); // force instantiation\n</code></pre>\n<p>[main.cpp]</p>\n<pre><code>#include \"header.hpp\"\n\nint main()\n{\n    foo&lt;int&gt;(42); // no instantiation will occur\n}\n</code></pre>\n<p>In main.cpp we couldn't instantiate the definition of <code>foo</code>, as the definition is not available. We could instantiate the declaration. There's also an explicit instantiation declaration, which prevents any implicit instantiation. In another TU (impl.cpp), we did instantiate <code>foo&lt;int&gt;</code> via an explicit instantiation <em>definition</em>. This requires the definition of <code>f</code> to exist and instantiates the definition. The rest is similar to normal functions: We have two declarations and one definition.</p>\n<p>Similarly, for class templates: If the definition of a class is required in a TU, we need to either instantiate the template or we need to have an explicit specialization (an explicit instantiation definition is not possible here AFAIK). This is exactly the OP's example.</p>\n<p>If the definition of the class is <em>not</em> required, we can use something similar to the PIMPL idiom:</p>\n<p>[header.hpp]</p>\n<pre><code>template&lt;class T&gt;\nclass foobar;\n\nstruct s\n{\n    foobar&lt;int&gt;* p;\n    void f();\n}\n</code></pre>\n<p>[impl.cpp]</p>\n<pre><code>#include \"header.hpp\"\n\ntemplate&lt;class T&gt; class foobar { int i; }\n\nvoid s::f() { p = new foobar{42}; }\n</code></pre>\n<p>[main.cpp]</p>\n<pre><code>int main()\n{\n    s obj;\n    obj.f();\n}\n</code></pre>\n</hr>", "LastEditorUserId": "420683", "LastActivityDate": "2013-10-26T21:32:42.503", "Score": "4", "CreationDate": "2013-10-26T20:53:25.370", "ParentId": "19611478", "CommentCount": "0", "LastEditDate": "2013-10-26T21:32:42.503", "OwnerUserId": "420683"}, "bq_ids": {"n4140": {"so_19611478_19611775_0": {"length": 35, "quality": 0.9722222222222222, "section_id": 267}, "so_19611478_19611775_1": {"length": 21, "quality": 0.5526315789473685, "section_id": 4706}}, "n3337": {"so_19611478_19611775_0": {"length": 35, "quality": 0.9722222222222222, "section_id": 258}, "so_19611478_19611775_1": {"length": 21, "quality": 0.5526315789473685, "section_id": 4515}}, "n4659": {"so_19611478_19611775_0": {"length": 35, "quality": 0.9722222222222222, "section_id": 274}}}});