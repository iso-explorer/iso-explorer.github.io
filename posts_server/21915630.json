post_cb({"21915630": {"CommentCount": "17", "AcceptedAnswerId": "21917031", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2014-02-20T17:47:42.213", "LastActivityDate": "2014-02-23T05:58:11.900", "LastEditDate": "2014-02-20T17:57:36.417", "ViewCount": "365", "FavoriteCount": "1", "Title": "Do the C++ standards guarantee that unused private fields will influence sizeof?", "Id": "21915630", "Score": "12", "Body": "<p>Consider the following struct:</p>\n<pre><code>class Foo {\n    int a;\n};\n</code></pre>\n<p>Testing in g++, I get that <code>sizeof(Foo) == 4</code> but is that guaranteed by the standard? Would a compiler be allowed to notice that <code>a</code> is an unused private field and remove it from the in-memory representation of the class (leading to a smaller sizeof)?</p>\n<p>I don't expect any compilers to actually do that kind of optimization but this question popped up in a language lawyering discussion so now I'm curious.</p>\n", "Tags": "<c++><sizeof><language-lawyer>", "OwnerUserId": "90511", "AnswerCount": "3"}, "21917031": {"ParentId": "21915630", "CommentCount": "5", "Body": "<p>The C++ standard doesn't define a lot about memory layouts. The fundamental rule for this case is item 4 under section <code>9 Classes</code>:</p>\n<blockquote>\n<p id=\"so_21915630_21917031_0\">4 Complete objects and member subobjects of class type shall have nonzero size. [ Note: Class objects can be assigned, passed as arguments to functions, and returned by functions (except objects of classes for which copying or moving has been restricted; see 12.8). Other plausible operators, such as equality comparison, can be defined by the user; see 13.5. \u2014 end note ]</p>\n</blockquote>\n<p>Now there is one more restriction, though: Standard-layout classes. (no static elements, no virtuals, same visibility for all members) Section <code>9.2 Class members</code> requires layout compatibility between different classes for standard-layout classes. This prevents elimination of members from such classes.</p>\n<p>For non-trivial non-standard-layout classes I see no further restriction in the standard. The exact behavior of sizeof(), reinterpret_cast(), ... are implementation defined (i.e. 5.2.10 \"The mapping function is implementation-defined.\").</p>\n", "OwnerUserId": "206302", "PostTypeId": "2", "Id": "21917031", "Score": "3", "CreationDate": "2014-02-20T18:56:56.737", "LastActivityDate": "2014-02-20T18:56:56.737"}, "21932717": {"ParentId": "21915630", "LastEditDate": "2014-02-23T05:58:11.900", "CommentCount": "0", "CreationDate": "2014-02-21T11:07:58.177", "OwnerUserId": "1105562", "LastEditorUserId": "1105562", "PostTypeId": "2", "Id": "21932717", "Score": "3", "Body": "<p>The answer is yes and no. A compiler could not exhibit exactly that behaviour within the standard, but it could do so partly.</p>\n<p>There is no reason at all why a compiler could not optimise away the storage for the struct if that storage is never referenced. If the compiler gets its analysis right, then no program that you could write would ever be able to tell whether the storage exists or not.</p>\n<p>However, the compiler cannot report a smaller sizeof() thereby. The standard is pretty clear that objects have to be big enough to hold the bits and bytes they contain (see for example 3.9/4 in N3797), and to report a sizeof smaller than that required to hold an int would be wrong.</p>\n<p>At N3797 5.3.2: </p>\n<blockquote>\n<p id=\"so_21915630_21932717_0\">The sizeof operator yields the number of bytes in the object\n  representation of its operand</p>\n</blockquote>\n<p>I do not se that 'representation' can change according to whether the struct or member is referenced.</p>\n<p>As another way of looking at it:</p>\n<pre><code>struct A {\n  int i;\n};\nstruct B {\n  int i;\n};\nA a;\na.i = 0;\nassert(sizeof(A)==sizeof(B));\n</code></pre>\n<p>I do not see that this assert can be allowed to fail in a standards-conforming implementation.</p>\n", "LastActivityDate": "2014-02-23T05:58:11.900"}, "bq_ids": {"n4140": {"so_21915630_21917031_0": {"section_id": 5848, "quality": 0.8780487804878049, "length": 36}, "so_21915630_21932717_0": {"section_id": 6076, "quality": 0.9, "length": 9}}, "n3337": {"so_21915630_21917031_0": {"section_id": 5618, "quality": 0.8780487804878049, "length": 36}, "so_21915630_21932717_0": {"section_id": 5844, "quality": 0.9, "length": 9}}, "n4659": {"so_21915630_21917031_0": {"section_id": 7327, "quality": 0.8780487804878049, "length": 36}, "so_21915630_21932717_0": {"section_id": 7572, "quality": 0.9, "length": 9}}}, "21917561": {"ParentId": "21915630", "CommentCount": "0", "Body": "<p>If you look at templates, you'll notice that \"optimization\" of such often ends up with nearly nothing in the output even though the template files may be thousands of lines...</p>\n<p>I think that the optimization you are talking about will nearly always occur in a function when the object is used on the stack and the object doesn't get copied or passed down to another function and the private field is never accessed (not even initialized... which could be viewed as a bug!)</p>\n", "OwnerUserId": "212378", "PostTypeId": "2", "Id": "21917561", "Score": "0", "CreationDate": "2014-02-20T19:25:39.510", "LastActivityDate": "2014-02-20T19:25:39.510"}});