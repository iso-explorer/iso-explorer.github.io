post_cb({"bq_ids": {"n4140": {"so_44263503_44265134_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 344}}, "n3337": {"so_44263503_44265134_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 334}}, "n4659": {"so_44263503_44265134_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 309}, "so_44263503_44265134_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 353}}}, "44268576": {"Id": "44268576", "PostTypeId": "2", "Body": "<p>Here is a general C++14 solution that does not rely on manually specialized type traits or extending <code>Foo</code> and <code>Bar</code>.</p>\n<p>A template metafunction that obtains a type representing the class template of its argument type:</p>\n<pre><code>namespace detail\n{\n    // Type representing a class template taking any number of non-type template arguments.\n    template &lt;typename T, template &lt;T...&gt; class U&gt;\n    struct nontype_template {};\n}\n\n// If T is an instantiation of a class template U taking non-type template arguments,\n// this has a nested typedef \"type\" that is a detail::nontype_template representing U.\ntemplate &lt;typename T&gt;\nstruct nontype_template_of {};\n\n// Partial specializations for all of the builtin integral types.\ntemplate &lt;template &lt;bool...&gt; class T, bool... Vs&gt;\nstruct nontype_template_of&lt;T&lt;Vs...&gt;&gt; { using type = detail::nontype_template&lt;bool, T&gt;; };\ntemplate &lt;template &lt;char...&gt; class T, char... Vs&gt;\nstruct nontype_template_of&lt;T&lt;Vs...&gt;&gt; { using type = detail::nontype_template&lt;char, T&gt;; };\ntemplate &lt;template &lt;signed char...&gt; class T, signed char... Vs&gt;\nstruct nontype_template_of&lt;T&lt;Vs...&gt;&gt; { using type = detail::nontype_template&lt;signed char, T&gt;; };\ntemplate &lt;template &lt;unsigned char...&gt; class T, unsigned char... Vs&gt;\nstruct nontype_template_of&lt;T&lt;Vs...&gt;&gt; { using type = detail::nontype_template&lt;unsigned char, T&gt;; };\ntemplate &lt;template &lt;short...&gt; class T, short... Vs&gt;\nstruct nontype_template_of&lt;T&lt;Vs...&gt;&gt; { using type = detail::nontype_template&lt;short, T&gt;; };\ntemplate &lt;template &lt;unsigned short...&gt; class T, unsigned short... Vs&gt;\nstruct nontype_template_of&lt;T&lt;Vs...&gt;&gt; { using type = detail::nontype_template&lt;unsigned short, T&gt;; };\ntemplate &lt;template &lt;int...&gt; class T, int... Vs&gt;\nstruct nontype_template_of&lt;T&lt;Vs...&gt;&gt; { using type = detail::nontype_template&lt;int, T&gt;; };\ntemplate &lt;template &lt;unsigned int...&gt; class T, unsigned int... Vs&gt;\nstruct nontype_template_of&lt;T&lt;Vs...&gt;&gt; { using type = detail::nontype_template&lt;unsigned int, T&gt;; };\ntemplate &lt;template &lt;long...&gt; class T, long... Vs&gt;\nstruct nontype_template_of&lt;T&lt;Vs...&gt;&gt; { using type = detail::nontype_template&lt;long, T&gt;; };\ntemplate &lt;template &lt;unsigned long...&gt; class T, unsigned long... Vs&gt;\nstruct nontype_template_of&lt;T&lt;Vs...&gt;&gt; { using type = detail::nontype_template&lt;unsigned long, T&gt;; };\ntemplate &lt;template &lt;long long...&gt; class T, long long... Vs&gt;\nstruct nontype_template_of&lt;T&lt;Vs...&gt;&gt; { using type = detail::nontype_template&lt;long long, T&gt;; };\ntemplate &lt;template &lt;unsigned long long...&gt; class T, unsigned long long... Vs&gt;\nstruct nontype_template_of&lt;T&lt;Vs...&gt;&gt; { using type = detail::nontype_template&lt;unsigned long long, T&gt;; };\n</code></pre>\n<p>An alias template for ease of use:</p>\n<pre><code>// Alias template for nontype_template_of.\ntemplate &lt;typename T&gt;\nusing nontype_template_of_t = typename nontype_template_of&lt;T&gt;::type;\n</code></pre>\n<p>Then you can implement your <code>match_class</code> trait just like this:</p>\n<pre><code>template &lt;class A, class B&gt;\nstruct match_class : std::is_same&lt;nontype_template_of_t&lt;A&gt;, nontype_template_of_t&lt;B&gt;&gt; {};\n</code></pre>\n<p><a href=\"http://ideone.com/Uuea3b\" rel=\"nofollow noreferrer\">DEMO</a></p>\n", "LastEditorUserId": "1639256", "LastActivityDate": "2017-05-30T17:46:01.170", "Score": "1", "CreationDate": "2017-05-30T17:38:59.063", "ParentId": "44263503", "CommentCount": "4", "OwnerUserId": "1639256", "LastEditDate": "2017-05-30T17:46:01.170"}, "44265369": {"Id": "44265369", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_44263503_44265369_0\">Question: What is a workaround for this in C++14?</p>\n</blockquote>\n<p>A possible workaround in C++14 is based on traits.<br>\nAs a minimal, working example (maybe even stupid, but it helps getting the idea):</br></p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n\ntemplate&lt;int...&gt;\nstruct Foo{};\n\ntemplate&lt;unsigned long...&gt;\nstruct Bar{};\n\ntemplate&lt;typename&gt;\nstruct traits;\n\ntemplate&lt;int... V&gt;\nstruct traits&lt;Foo&lt;V...&gt;&gt; { using type = Foo&lt;0&gt;; };\n\ntemplate&lt;unsigned long... V&gt;\nstruct traits&lt;Bar&lt;V...&gt;&gt; { using type = Bar&lt;0&gt;; };\n\ntemplate&lt;typename T, typename U&gt;\nconstexpr bool match = std::is_same&lt;typename traits&lt;T&gt;::type, typename traits&lt;U&gt;::type&gt;::value;\n\nint main() {\n    using f1 = Foo&lt;1, 2, 3&gt;;\n    using f2 = Foo&lt;1&gt;;\n    using b1 = Bar&lt;1, 2, 3&gt;;\n    using b2 = Bar&lt;1&gt;;\n\n    static_assert(match&lt;f1, f2&gt;, \"Fail\");\n    static_assert(match&lt;b1, b2&gt;, \"Fail\");\n    static_assert(!match&lt;f1, b1&gt;, \"Fail\");\n}\n</code></pre>\n<hr>\n<p>As a side note, in C++17 you can simplify things up as it follows:</p>\n<pre><code>template&lt;template&lt;auto ...&gt; class S, auto... U, auto... V&gt;\nstruct match_class&lt;S&lt;U...&gt;, S&lt;V...&gt;&gt; : std::true_type{};\n</code></pre>\n<hr>\n<p>About the reasons that are behind the error, <a href=\"https://stackoverflow.com/a/44265134/4987285\">@Barry's answer</a> contains all what you need to understand it (as usual).</p>\n</hr></hr>", "LastActivityDate": "2017-05-30T14:43:08.217", "CommentCount": "3", "CreationDate": "2017-05-30T14:43:08.217", "ParentId": "44263503", "Score": "6", "OwnerUserId": "4987285"}, "44265134": {"Id": "44265134", "PostTypeId": "2", "Body": "<p>In C++14, you could not deduce <code>T</code> in:</p>\n<pre><code>template&lt;class T, template&lt;T...&gt; class S, T... U, T... V&gt;\nstruct match_class&lt;S&lt;U...&gt;, S&lt;V...&gt;&gt; : std::true_type{};\n</code></pre>\n<p>but in C++17, you can. The behavior you see is correct.</p>\n<p>In C++14, since you cannot deduce <code>T</code>, you need a way of explicitly providing it. So you might require the class templates themselves to indicate their non-type template parameter type:</p>\n<pre><code>template &lt;int...&gt; struct Foo { using type = int; };\ntemplate &lt;unsigned long...&gt; struct Bar { using type = unsigned long; };\n</code></pre>\n<p>Or have an external trait for this. And then explicitly write out everything - two class templates match if they have the same non-type template parameter <em>and</em> then also have the same class template, in that order:</p>\n<pre><code>template &lt;class... Ts&gt; struct make_void { using type = void; };\ntemplate &lt;class... Ts&gt; using void_t = typename make_void&lt;Ts...&gt;::type;\n\ntemplate &lt;class T1, class T2, class A, class B&gt;\nstruct match_class_impl : std::false_type { };\n\ntemplate &lt;class T, template &lt;T...&gt; class S, T... U, T... V&gt;\nstruct match_class_impl&lt;T, T, S&lt;U...&gt;, S&lt;V...&gt;&gt; : std::true_type{};\n\ntemplate &lt;class A, class B, class=void&gt;\nstruct match_class : std::false_type { };\n\ntemplate &lt;class A, class B&gt;\nstruct match_class&lt;A, B, void_t&lt;typename A::type, typename B::type&gt;&gt;\n    : match_class_impl&lt;typename A::type, typename B::type, A, B&gt;\n{ };\n</code></pre>\n<hr/>\n<p>This is a consequence of adding support for <a href=\"https://wg21.link/p0127\" rel=\"noreferrer\"><code>template auto</code></a>. In C++14, [temp.deduct.type] contained:</p>\n<blockquote>\n<p id=\"so_44263503_44265134_0\">A template type argument cannot be deduced from the type of a non-type template-argument. <em>[Example:</em></p>\n<pre><code>template&lt;class T, T i&gt; void f(double a[10][i]);\nint v[10][20];\nf(v); // error: argument for template-parameter T cannot be deduced\n</code></pre>\n<p id=\"so_44263503_44265134_1\"><em>-end example]</em></p>\n</blockquote>\n<p>But in C++17, it <a href=\"http://eel.is/c++draft/temp.deduct.type#13\" rel=\"noreferrer\">now reads</a>:</p>\n<blockquote>\n<p id=\"so_44263503_44265134_2\">When the value of the argument corresponding to a non-type template parameter <code>P</code> that is declared with a dependent type is deduced from an expression, the template parameters in the type of <code>P</code> are deduced from the type of the value. <em>[\u2009Example:</em></p>\n<pre><code>template&lt;long n&gt; struct A { };\n\ntemplate&lt;typename T&gt; struct C;\ntemplate&lt;typename T, T n&gt; struct C&lt;A&lt;n&gt;&gt; {\n  using Q = T;\n};\n\nusing R = long;\nusing R = C&lt;A&lt;2&gt;&gt;::Q;           // OK; T was deduced to long from the\n                                // template argument value in the type A&lt;2&gt;\n</code></pre>\n<p id=\"so_44263503_44265134_3\"><em>\u2014\u2009end example\u2009]</em> The type of <code>N</code> in the type <code>T[N]</code> is <code>std\u200b::\u200bsize_\u00adt</code>. <em>[\u2009Example:</em></p>\n<pre><code>template&lt;typename T&gt; struct S;\ntemplate&lt;typename T, T n&gt; struct S&lt;int[n]&gt; {\n  using Q = T;\n};\n\nusing V = decltype(sizeof 0);\nusing V = S&lt;int[42]&gt;::Q;        // OK; T was deduced to std\u200b::\u200bsize_\u00adt from the type int[42]\n</code></pre>\n<p id=\"so_44263503_44265134_4\"><em>\u2014\u2009end example\u2009]</em></p>\n</blockquote>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-05-30T15:18:08.463", "Score": "17", "CreationDate": "2017-05-30T14:32:17.833", "ParentId": "44263503", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2017-05-30T15:18:08.463"}, "44263503": {"ViewCount": "709", "Body": "<p>Let's say I have two structs, <code>Foo</code> and <code>Bar</code>:</p>\n<pre><code>template&lt;int...&gt;\nstruct Foo{};\n\ntemplate&lt;unsigned long...&gt;\nstruct Bar{};\n</code></pre>\n<p>I want to create a type trait (call it <code>match_class</code>) that returns true if I pass two <code>Foo&lt;...&gt;</code> types or two <code>Bar&lt;...&gt;</code> types, but false if I try to mix them:</p>\n<pre><code>int main()\n{\n    using f1 = Foo&lt;1, 2, 3&gt;;\n    using f2 = Foo&lt;1&gt;;\n    using b1 = Bar&lt;1, 2, 3&gt;;\n    using b2 = Bar&lt;1&gt;;\n    static_assert(match_class&lt;f1, f2&gt;::value, \"Fail\");\n    static_assert(match_class&lt;b1, b2&gt;::value, \"Fail\");\n    static_assert(!match_class&lt;f1, b1&gt;::value, \"Fail\");\n}\n</code></pre>\n<p>For C++1z (clang 5.0.0 and gcc 8.0.0) it's sufficient to do this (<a href=\"https://wandbox.org/permlink/eaoPBQZXhOFH9Ab2\" rel=\"noreferrer\">Demo</a>):</p>\n<pre><code>template&lt;class A, class B&gt;\nstruct match_class : std::false_type{};\n\ntemplate&lt;class T, template&lt;T...&gt; class S, T... U, T... V&gt;\nstruct match_class&lt;S&lt;U...&gt;, S&lt;V...&gt;&gt; : std::true_type{};\n</code></pre>\n<p>But in C++14 I get the following error (same compilers<sup>*</sup> <a href=\"https://wandbox.org/permlink/Oe0mpJtUK7Fnn7At\" rel=\"noreferrer\">Demo</a>):</p>\n<pre><code>error: class template partial specialization contains a template parameter that cannot be deduced; this partial specialization will never be used [-Wunusable-partial-specialization]\nstruct match_class&lt;S&lt;U...&gt;, S&lt;V...&gt;&gt; : std::true_type{};\n       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnote: non-deducible template parameter 'T'\ntemplate&lt;class T, template&lt;T...&gt; class S, T... U, T... V&gt;\n</code></pre>\n<h3>Question: What is a workaround for this in C++14?</h3>\n<p>Ideally the syntax for testing the type trait should remain the same.</p>\n<p>Secondary question: <strong>Is the behavior for C++14 correct? (or alternatively is the behavior I see for C++17 unspecified?)</strong></p>\n<p><sup>*Note that MSVC 19.00.23506 has the same kind of failure <a href=\"http://rextester.com/SJEYI3312\" rel=\"noreferrer\">Demo</a></sup></p>\n", "AcceptedAnswerId": "44265134", "Title": "Matching variadic non-type templates", "CreationDate": "2017-05-30T13:21:52.143", "Id": "44263503", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-30T13:42:48.333", "LastEditorUserId": "27678", "LastActivityDate": "2017-05-30T17:46:01.170", "Score": "22", "OwnerUserId": "27678", "Tags": "<c++><templates><c++14><variadic-templates><non-type>", "AnswerCount": "3"}});