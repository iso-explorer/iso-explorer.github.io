post_cb({"19347966": {"ParentId": "19347862", "CommentCount": "7", "CreationDate": "2013-10-13T17:13:14.900", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "19347966", "Score": "2", "Body": "<p>Using the address of an object as a hash pretty much guarantees that you won't find the object unless you already hold a pointer to the object other than iteration through the hash. You'll need to come up with a different approach to get a hash from your object. That said, once consructed inside the hash the object's address won't change.</p>\n", "LastActivityDate": "2013-10-13T17:13:14.900"}, "19348825": {"ParentId": "19347862", "CommentCount": "0", "CreationDate": "2013-10-13T18:39:59.347", "OwnerUserId": "1571944", "PostTypeId": "2", "Id": "19348825", "Score": "0", "Body": "<p>As Dietmar mentions, once constructed, the value's address can't change.  As far as the second part of the question, the standard seems to not only allow, but require implementations to call the hash/equal_to functors on an object passed to <code>insert()</code> by reference, rather than requiring the construction of a node first and calling the functions on that object:</p>\n<blockquote>\n<p id=\"so_19347862_19348825_0\"><strong>From 23.2.5 Table 103 \u2014 Unordered associative container requirements</strong></p>\n<p id=\"so_19347862_19348825_1\"><code>pair&lt;iterator, bool&gt; a_uniq.insert(t)</code></p>\n<p id=\"so_19347862_19348825_2\">Effects: Inserts <code>t</code> if and only if there is no element in the container with key equivalent to the key of <code>t</code>.</p>\n</blockquote>\n", "LastActivityDate": "2013-10-13T18:39:59.347"}, "19347862": {"CommentCount": "1", "ViewCount": "783", "PostTypeId": "1", "LastEditorUserId": "1571944", "CreationDate": "2013-10-13T17:03:58.773", "LastActivityDate": "2013-10-14T20:52:04.633", "Title": "unordered_set using hash of value object's address", "AcceptedAnswerId": "19357581", "LastEditDate": "2013-10-14T20:52:04.633", "Id": "19347862", "Score": "2", "Body": "<p>I have a class which needs to have a <code>std::unordered_set</code> which holds non-copyable, non-moveable entity objects, and whose hash function hashes the instance's address.  Something like the following:</p>\n<pre><code>class A\n{\npublic:\n    A();\n    A(const A&amp;) = delete;\n    A(A&amp;&amp;) = delete;\n    void operator=(const A&amp;) = delete;\n    void operator=(A&amp;&amp;) = delete;\n\n    bool operator==(const A&amp; other) { return this == &amp;other; }\n};\n\ntemplate&lt;&gt;\nstruct std::hash&lt;A&gt;\n{\n    size_t operator()(const A&amp; obj) const\n    {\n        return std::hash&lt;A*&gt;()(&amp;obj);\n    }\n};\n\nclass B\n{\nprivate:\n    std::unordered_set&lt;A&gt; entities;\n};\n</code></pre>\n<p>If <code>emplace()</code> is always used instead of <code>insert()</code>, is it safe to use <code>unordered_set</code> in this way?  Does the standard specify that an implementation can't move node objects after they are constructed?</p>\n<p>What about if <code>A</code> were moveable?  Is it guaranteed that the hash function will be called on the object owned by the set, or since the standard library prefers to think of everything as value-objects, is it allowed to hash an <code>insert</code>ed object before storage is allocated for it?</p>\n<p>As a final thought, I know I could get around all this by using <code>std::unordered_set&lt;std::unique_ptr&lt;A&gt;&gt;</code>, but I'd like to use a custom allocator for the <code>A</code> objects, and I don't want to override <code>new</code> and <code>delete</code> for <code>A</code>.</p>\n", "Tags": "<c++><c++11><hash><c++-standard-library>", "OwnerUserId": "1571944", "AnswerCount": "3"}, "19357581": {"ParentId": "19347862", "CommentCount": "4", "CreationDate": "2013-10-14T09:51:28.933", "OwnerUserId": "2073257", "PostTypeId": "2", "Id": "19357581", "Score": "1", "Body": "<p>I still think you are better off using a <code>std::list</code>. Consider:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nclass A\n{\npublic:\n    int i_;\n    A(int i) : i_(i) {}\n    A(const A&amp;) = delete;\n    A(A&amp;&amp;) = delete;\n    void operator=(const A&amp;) = delete;\n    void operator=(A&amp;&amp;) = delete;\n};\n\nint main()\n{\n    std::list&lt; A &gt; l;\n\n    // inserting elements\n    auto it1 = l.emplace( l.end(), 1 ); // note: complexity is O(1)\n    auto it2 = l.emplace( l.end(), 2 );\n    auto it3 = l.emplace( l.end(), 3 );\n    auto it4 = l.emplace( l.end(), 4 );\n\n    // deleting an element by iterator\n    l.erase( it2 ); // note: complexity is O(1)\n    // note: it2 is now invalid\n\n    // accessing element by iterator\n    it3-&gt;i_ = 42;\n\n    for( const auto&amp; e : l ) {\n        std::cout &lt;&lt; e.i_ &lt;&lt; std::endl;\n    }\n\n    // silence compiler warnings\n    (void)it1;\n    (void)it4;\n}\n</code></pre>\n<p>In the above, all your use-cases should have an efficient implementation. You can avoid the overhead of calculating the hash and having the hash-map. It's even more efficient as your hash-based approach, for the list both operations are O(1) and much more light-weigth wrt the implementation. And storing the iterator is not much different from storing a pointer to the element directly.</p>\n<p>Also, it is guaranteed that this works for non-copyable and non-movable types. See the documentation for <a href=\"http://en.cppreference.com/w/cpp/container/list/emplace\" rel=\"nofollow\"><code>std::list::emplace</code></a>.</p>\n", "LastActivityDate": "2013-10-14T09:51:28.933"}, "bq_ids": {"n4140": {"so_19347862_19348825_2": {"section_id": 744, "quality": 0.875, "length": 7}}, "n3337": {"so_19347862_19348825_2": {"section_id": 733, "quality": 0.875, "length": 7}}, "n4659": {"so_19347862_19348825_2": {"section_id": 802, "quality": 0.875, "length": 7}}}});