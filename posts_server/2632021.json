post_cb({"2632040": {"ParentId": "2632021", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2010-04-13T18:18:11.027", "Score": "5", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:54:40.310", "Id": "2632040", "OwnerUserId": "309308", "Body": "<p>Empty structs, as <a href=\"https://stackoverflow.com/users/281108/isbadawi\">isbadawi</a> <a href=\"https://stackoverflow.com/questions/2632021/can-sizeof-return-0-zero/2632031#2632031\">mentions</a>. Also gcc allows <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html\" rel=\"nofollow noreferrer\">arrays of 0 size</a>:</p>\n<pre><code>int a[0];\nsizeof(a);\n</code></pre>\n<p>EDIT: After seeing the MSDN link, I tried the empty struct in VS2005 and sizeof did return 1. I'm not sure if that's a VS bug or if the spec is somehow flexible about that sort of thing</p>\n", "LastActivityDate": "2010-04-13T18:18:11.027"}, "2635970": {"ParentId": "2632021", "CommentCount": "2", "CreationDate": "2010-04-14T08:42:16.353", "OwnerUserId": "126769", "PostTypeId": "2", "Id": "2635970", "Score": "0", "Body": "<p>Here's a test, where sizeof yields 0</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nvoid func(int i)\n{\n        int vla[i];\n        printf (\"%u\\n\",(unsigned)sizeof vla);\n}\n\n\nint main(void)\n{\n\n        func(0);\n        return 0;\n}\n</code></pre>\n", "LastActivityDate": "2010-04-14T08:42:16.353"}, "2632075": {"ParentId": "2632021", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2010-04-13T18:23:36.713", "Score": "37", "LastEditorUserId": "12711", "LastEditDate": "2010-04-13T18:34:37.937", "Id": "2632075", "OwnerUserId": "12711", "Body": "<p>In C++ an empty class or struct has a <code>sizeof</code> at least 1 by definition. From the C++ standard, 9/3 \"Classes\": \"Complete objects and member subobjects of class type shall have nonzero size.\"</p>\n<p>In C an empty struct is not permitted, except by extension (or a flaw in the compiler).</p>\n<p>This is a consequence of the grammar (which requires that there be something inside the braces) along with this sentence from 6.7.2.1/7 \"Structure and union specifiers\": \"If the struct-declaration-list contains no named members, the behavior is undefined\".</p>\n<p>If a zero-sized structure is permitted, then it's a language extension (or a flaw in the compiler). For example, in GCC the extension is documented in <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.4.3/gcc/Empty-Structures.html#Empty-Structures\" rel=\"noreferrer\">\"Structures with No Members\"</a>, which says:</p>\n<blockquote>\n<p id=\"so_2632021_2632075_0\">GCC permits a C structure to have no members:</p>\n<pre><code> struct empty {\n };\n</code></pre>\n<p id=\"so_2632021_2632075_1\">The structure will have size zero. In C++, empty structures are part of the language. G++ treats empty structures as if they had a single member of type <code>char</code>. </p>\n</blockquote>\n", "LastActivityDate": "2010-04-13T18:34:37.937"}, "2632646": {"ParentId": "2632021", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2010-04-13T19:40:35.293", "Score": "9", "LastEditorUserId": "79566", "LastEditDate": "2010-04-21T18:17:07.247", "Id": "2632646", "OwnerUserId": "79566", "Body": "<p>Every object in C must have a unique address.  Worded another way, an address must hold no more than one object of a given type (in order for pointer dereferencing to work).  That being said, consider an 'empty' struct:</p>\n<pre><code>struct emptyStruct {};\n</code></pre>\n<p>and, more specifically, an array of them:</p>\n<pre><code>struct emptyStruct array[10];\nstruct emptyStruct* ptr = &amp;array[0];\n</code></pre>\n<p>If the objects were indeed empty (that is, if <code>sizeof(struct emptyStruct) == 0</code>), then <code>ptr++ ==&gt; (void*)ptr + sizeof(struct emptyStruct) ==&gt; ptr</code>, which doesn't make sense.  Which object would <code>*ptr</code> then refer to, <code>ptr[0]</code> or <code>ptr[1]</code>?</p>\n<p>Even if a structure has no contents, the compiler should treat it as if it is one byte in length in order to maintain the \"one address, one object\" principle.</p>\n<p>The C language specification (section A7.4.8) words this requirement as</p>\n<blockquote>\n<p id=\"so_2632021_2632646_0\">when applied to a structure or union,\n  the result (of the <code>sizeof</code> operator)\n  is the number of bytes in the object,\n  including any padding required to make\n  the object tile an array</p>\n</blockquote>\n<p>Since a padding byte must be added to an \"empty\" object in order for it to work in an array, <code>sizeof()</code> must therefore return a value of at least 1 for any valid input.</p>\n<p><strong>Edit:</strong>\nSection A8.3 of the C spec calls a struct without a list of members an <em>incomplete type</em>, and the definition of <code>sizeof</code> specifically states (with emphasis added):</p>\n<blockquote>\n<p id=\"so_2632021_2632646_1\">The operator (sizeof) <strong>may not be\n  applied to an operand</strong> of function\n  type, or <strong>of incomplete type</strong>, or to a\n  bit-field.</p>\n</blockquote>\n<p>That would imply that using <code>sizeof</code> on an empty struct would be equally as invalid as using it on a data type that has not been defined.  If your compiler allows the use of empty structs, be aware that using <code>sizeof</code> on them is not allowed as per the C spec.  If your compiler allows you to do this anyway, understand that this is non-standard behavior that will not work on all compilers; do not rely on this behavior.</p>\n<p><strong>Edit:</strong> See also <a href=\"http://www2.research.att.com/~bs/bs_faq2.html#sizeof-empty\" rel=\"nofollow noreferrer\">this entry</a> in Bjarne Stroustrup's FAQ.</p>\n", "LastActivityDate": "2010-04-21T18:17:07.247"}, "2632021": {"CommentCount": "2", "AcceptedAnswerId": "2632075", "PostTypeId": "1", "LastEditorUserId": "105344", "CreationDate": "2010-04-13T18:15:13.473", "LastActivityDate": "2017-02-13T16:15:23.310", "LastEditDate": "2010-04-13T18:47:35.193", "ViewCount": "7356", "FavoriteCount": "9", "Title": "Can sizeof return 0 (zero)", "Id": "2632021", "Score": "46", "Body": "<p>Is it possible for the sizeof operator to ever return 0 (zero) in C or C++?  If it is possible, is it correct from a standards point of view?</p>\n", "Tags": "<c++><c><sizeof>", "OwnerUserId": "105344", "AnswerCount": "10"}, "bq_ids": {"n4140": {"so_2632021_2632646_0": {"section_id": 6077, "quality": 0.5294117647058824, "length": 9}, "so_2632021_2632646_1": {"section_id": 6076, "quality": 0.6363636363636364, "length": 7}}, "n3337": {"so_2632021_2632646_0": {"section_id": 5845, "quality": 0.5294117647058824, "length": 9}, "so_2632021_2632646_1": {"section_id": 5844, "quality": 0.6363636363636364, "length": 7}}, "n4659": {"so_2632021_2632646_0": {"section_id": 7573, "quality": 0.5294117647058824, "length": 9}, "so_2632021_2632646_1": {"section_id": 7572, "quality": 0.6363636363636364, "length": 7}}}, "34364028": {"ParentId": "2632021", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-12-18T21:11:18.540", "Score": "0", "LastEditorUserId": "220481", "LastEditDate": "2015-12-18T21:19:00.927", "Id": "34364028", "OwnerUserId": "220481", "Body": "<p>If you have this :</p>\n<pre><code>struct Foo {}; \nstruct Bar { Foo v[]; }\n</code></pre>\n<p><code>g++ -ansi</code> returns sizeof(Bar) == 0.  As does the clang &amp; intel compiler.</p>\n<p>However, this does not compile with gcc.  I deduce it's a C++ extension.</p>\n", "LastActivityDate": "2015-12-18T21:19:00.927"}, "15408988": {"ParentId": "2632021", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-03-14T12:12:41.963", "Score": "1", "LastEditorUserId": "193887", "LastEditDate": "2013-03-14T12:21:16.427", "Id": "15408988", "OwnerUserId": "193887", "Body": "<pre><code>typedef struct {\n  int : 0;\n} x;\n\nx x1;\nx x2;\n</code></pre>\n<p>Under MSVC 2010 (/Za /Wall):</p>\n<pre><code>sizeof(x) == 4\n&amp;x1 != &amp;x2\n</code></pre>\n<p>Under GCC (-ansi -pedantic -Wall) : </p>\n<pre><code>sizeof(x) == 0\n&amp;x1 != &amp;x2\n</code></pre>\n<p>i.e. Even though under GCC it has zero size, instances of the struct have distinct addresses.</p>\n<p>ANSI C (C89 and C99 - I haven't looked at C++) says \"It shall be possible to express the address of each individual byte of an object uniquely.\"  This seems ambiguous in the case of a zero-sized object, since it arguably has no bytes.</p>\n<p>Edit:  \"A bit-field declaration with no declarator, but only a colon and a width, indicates an unnamed bit-field. As a special case of this, a bit-field with a width of 0 indicates that no further bit-field is to be packed into the unit in which the previous bit-field, if any, was placed.\"</p>\n", "LastActivityDate": "2013-03-14T12:21:16.427"}, "2632510": {"ParentId": "2632021", "CommentCount": "0", "CreationDate": "2010-04-13T19:19:09.420", "OwnerUserId": "315653", "PostTypeId": "2", "Id": "2632510", "Score": "0", "Body": "<p>I think it never returns 0 in c , no empty structs is allowed </p>\n", "LastActivityDate": "2010-04-13T19:19:09.420"}, "2632099": {"ParentId": "2632021", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2010-04-13T18:26:17.347", "Score": "2", "LastEditorUserId": "271646", "LastEditDate": "2010-04-13T18:32:14.523", "Id": "2632099", "OwnerUserId": "271646", "Body": "<p>in my view, it is better that sizeof returns 0 for a structure of size 0  (in the spirit of c). \nbut then the programmer has to be careful when he takes the sizeof an empty struct.</p>\n<p>but it may cause a problem.\nwhen array of such structures is defined, then</p>\n<p>&amp;arr[1] == &amp;arr[2] == &amp;arr[0]</p>\n<p>which makes them lose their identities.</p>\n<p>i guess this doesnt directly answer your question, whether it is possible or not.\nwell that may be possible depending on the compiler. (as said in Michael's answer above).</p>\n", "LastActivityDate": "2010-04-13T18:32:14.523"}, "42208649": {"ParentId": "2632021", "CommentCount": "1", "CreationDate": "2017-02-13T16:15:23.310", "OwnerUserId": "2033130", "PostTypeId": "2", "Id": "42208649", "Score": "-1", "Body": "<pre><code>struct Empty {\n} em;\n\nstruct Zero {\n    Empty a[0];\n} zr;\n\nprintf(\"em=%d\\n\", sizeof(em));\nprintf(\"zr=%d\\n\", sizeof(zr));\n</code></pre>\n<p>Result:</p>\n<pre><code>em=1\nzr=0\n</code></pre>\n", "LastActivityDate": "2017-02-13T16:15:23.310"}, "2632160": {"ParentId": "2632021", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2010-04-13T18:32:51.967", "Score": "19", "LastEditorUserId": "187690", "LastEditDate": "2010-04-13T19:03:26.537", "Id": "2632160", "OwnerUserId": "187690", "Body": "<p><code>sizeof</code> never returns <code>0</code> in C and in C++. Every time you see <code>sizeof</code> evaluating to <code>0</code> it is a bug/glitch/extension of a specific compiler that has nothing to do with the language.</p>\n", "LastActivityDate": "2010-04-13T19:03:26.537"}});