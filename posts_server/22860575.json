post_cb({"22860575": {"CommentCount": "4", "ViewCount": "115", "CreationDate": "2014-04-04T10:44:21.137", "LastActivityDate": "2014-04-05T19:39:02.253", "Title": "Can std::set::insert() call the assignment operator?", "AcceptedAnswerId": "22883878", "PostTypeId": "1", "Id": "22860575", "Score": "2", "Body": "<p>I have a class with custom assignment operator that deliberately introduces controlled side effects.</p>\n<p>If I have a <code>std::set</code> of these elements, I would like to know whether the assignment operator could be called with the use of <code>insert</code>.</p>\n<p>I.e.:</p>\n<pre><code>class A\n{\npublic:\n    A &amp; operator=(A const &amp; rhs)\n    {\n        // custom assignment operator with deliberate side effects\n        // Could this be called with use of std::set::insert()?\n    }\n};\n\nstd::set&lt;A&gt; a;\n\n// Is it possible with this, or any use of \"insert\", that\n// the assignment operator will ever be called?\n\na.insert(A());\n</code></pre>\n<p>Can the assignment operator ever be called with the use of <code>std::set::insert</code>?</p>\n", "Tags": "<c++><c++11><stl>", "OwnerUserId": "368896", "AnswerCount": "2"}, "22883878": {"ParentId": "22860575", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The C++11 standard requires types to be used with <code>std::set::insert</code> to be \"CopyInsertable\n\", \"MoveInsertable\" or \"EmplaceConstructible\" depending on the insert function you are using (23.2.3/4).</p>\n<p>This is for example defined as:</p>\n<blockquote>\n<p id=\"so_22860575_22883878_0\">T is EmplaceConstructible into X from args, for zero or more arguments args, means that the following expression is well-formed: <code>allocator_traits&lt;A&gt;::construct(m, p, args);</code> (23.2.1/13)</p>\n</blockquote>\n<p>In all three cases, the default behaviour is <code>std::allocator</code> which uses placement new (17.6.3.5/2):</p>\n<pre><code>::new((void*)c)A(forward&lt;Args&gt;(args)...)\n</code></pre>\n<p>Depending on the <code>insert</code> function, in our case <code>args</code> is either an expression of type <code>A</code>, an rvalue of type <code>A</code> or some other arguments. But in all cases a constructor or copy constructor is used, not the assignment operator.</p>\n<p>This is what the standard says (and GCC 4.6.3 does). Even if there is no reason to use the assignment operator, some compiler may still do it. So I would suggest don't rely too much on it.</p>\n", "OwnerUserId": "316448", "LastEditorUserId": "316448", "LastEditDate": "2014-04-05T19:39:02.253", "Id": "22883878", "Score": "1", "CreationDate": "2014-04-05T16:55:45.317", "LastActivityDate": "2014-04-05T19:39:02.253"}, "bq_ids": {"n4140": {"so_22860575_22883878_0": {"section_id": 715, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_22860575_22883878_0": {"section_id": 704, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_22860575_22883878_0": {"section_id": 745, "quality": 0.9285714285714286, "length": 13}}}, "22860739": {"ParentId": "22860575", "CommentCount": "8", "Body": "<p>In pre-C++11, it could, theoretically.  C++11 bans it, no doubt\nbecause no implementation ever actually did it.  In C++11,\nmembers of <code>std::set</code> don't have to support assignment.\nIn pre-C++11, some implementations supporting concepts might\nhave code which uses assignment, as a means of checking that\nyour class supports it, but it should be in a non-evaluated\ncontext, so the operator will not actually be called.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "22860739", "Score": "3", "CreationDate": "2014-04-04T10:51:39.863", "LastActivityDate": "2014-04-04T10:51:39.863"}});