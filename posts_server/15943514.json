post_cb({"15943544": {"ParentId": "15943514", "PostTypeId": "2", "CommentCount": "2", "Body": "<pre><code>std::strcpy(str, \"I am string!\");\n</code></pre>\n<blockquote>\n<p id=\"so_15943514_15943544_0\">\"I am string!\"</p>\n</blockquote>\n<p>Is string-literal. Really it's <code>const char[13]</code> (that is decaying to <code>const char*</code> when passing in function).</p>\n<p>n3376 2.14.5/8\n<blockquote><p id=\"so_15943514_15943544_1\">\n<strong>Ordinary string literals</strong> and UTF-8 string literals <strong>are also referred to as narrow string literals. A narrow\nstring literal has type \u201carray of n const char\u201d, where n is the size of the string as defined below</strong>, and has\nstatic storage duration (3.7).</p></blockquote></p>\n<p>n3376 4.2/1 Implicit array to pointer conversion.</p>\n<p><blockquote><p id=\"so_15943514_15943544_2\">\nAn lvalue or rvalue of type \u201carray of N T\u201d or \u201carray of unknown bound of T\u201d can be converted to a prvalue\nof type \u201cpointer to T\u201d. The result is a pointer to the first element of the array.</p></blockquote></p>\n", "OwnerUserId": "1498580", "LastEditorUserId": "1498580", "LastEditDate": "2013-04-11T08:05:27.700", "Id": "15943544", "Score": "4", "CreationDate": "2013-04-11T08:00:13.267", "LastActivityDate": "2013-04-11T08:05:27.700"}, "15943565": {"ParentId": "15943514", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_15943514_15943565_0\">When using std::strcpy we take the value of the address given as its\n  second argument and assign this value to the pointer that is given as\n  the first argument (cstr).</p>\n</blockquote>\n<pre><code>char * strcpy ( char * destination, const char * source );\n</code></pre>\n<p>No strcpy actually read each character pointed by source and write them at destination, it stops when it reads a  terminating null character.</p>\n<p>In your second example, your source argument is a string-literal, which has a type const char[]. This string can be decayed into a const char* to be passed to strcpy. </p>\n<p>A string literal is not much more than a pointer to a read-only location.</p>\n", "OwnerUserId": "1439688", "LastEditorUserId": "1439688", "LastEditDate": "2013-04-11T08:12:29.017", "Id": "15943565", "Score": "4", "CreationDate": "2013-04-11T08:01:34.930", "LastActivityDate": "2013-04-11T08:12:29.017"}, "15943541": {"ParentId": "15943514", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_15943514_15943541_0\">And now as the second argument we have a string (and not a pointer to array as it was in the first example)</p>\n</blockquote>\n<p>In the second example you have a C string, which is a pointer to a NUL-terminated array of chars. There is no inconsistency.</p>\n", "OwnerUserId": "367273", "PostTypeId": "2", "Id": "15943541", "Score": "1", "CreationDate": "2013-04-11T08:00:09.833", "LastActivityDate": "2013-04-11T08:00:09.833"}, "15943583": {"ParentId": "15943514", "CommentCount": "0", "Body": "<p><code>char *strcpy( char *dest, const char *src );</code> needs source pointer of const char and it copies the memory to destination pointer which is of type char. The function copy the string length from source untill it finds null terminated string of source. <code>\"I am string!\"</code> is a const char* const` which is a string literal mostly stored in read only marked memory.</p>\n", "OwnerUserId": "1063250", "PostTypeId": "2", "Id": "15943583", "Score": "0", "CreationDate": "2013-04-11T08:03:03.317", "LastActivityDate": "2013-04-11T08:03:03.317"}, "15943514": {"CommentCount": "5", "ViewCount": "962", "CreationDate": "2013-04-11T07:58:24.093", "LastActivityDate": "2013-04-11T08:12:29.017", "Title": "What should we use as the second argument of std::strcpy?", "AcceptedAnswerId": "15943565", "PostTypeId": "1", "Id": "15943514", "Score": "0", "Body": "<p>I have the following example, taken from here:</p>\n<pre><code>// strings and c-strings\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;string&gt;\n\nint main ()\n{\n  std::string str (\"Please split this sentence into tokens\");\n\n  char * cstr = new char [str.length()+1];\n  std::strcpy (cstr, str.c_str());\n\n  // cstr now contains a c-string copy of str\n\n  char * p = std::strtok (cstr,\" \");\n  while (p!=0)\n  {\n    std::cout &lt;&lt; p &lt;&lt; '\\n';\n    p = strtok(NULL,\" \");\n  }\n\n  delete[] cstr;\n  return 0;\n}\n</code></pre>\n<p>As far as I understand <code>str</code> is a string, <code>str.c_str()</code> is a pointer pointing to the first element of an array that contains characters of <code>str</code> as its elements. Then using <code>std::strcpy</code> we take the value of the address given as its second argument and assign this value to the pointer that is given as the first argument (<code>cstr</code>).</p>\n<p>However, I have the following example, taken from <a href=\"http://en.cppreference.com/w/cpp/string/byte/strcpy\" rel=\"nofollow\">here</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nint main()\n{\n    char *str = new char[100];\n    std::strcpy(str, \"I am string!\");\n    std::cout &lt;&lt; str;\n    delete[] str;\n}\n</code></pre>\n<p>And now as the second argument we have a string (and not a pointer to array as it was in the first example).</p>\n<p>Can anybody, please, clarify this inconsistency?</p>\n", "Tags": "<c++><pointers><std><strcpy>", "OwnerUserId": "245549", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_15943514_15943544_2": {"section_id": 11, "quality": 0.9444444444444444, "length": 17}, "so_15943514_15943544_1": {"section_id": 5356, "quality": 1.0, "length": 26}}, "n3337": {"so_15943514_15943544_2": {"section_id": 8, "quality": 0.9444444444444444, "length": 17}, "so_15943514_15943544_1": {"section_id": 5153, "quality": 1.0, "length": 26}}, "n4659": {"so_15943514_15943544_2": {"section_id": 12, "quality": 0.9444444444444444, "length": 17}, "so_15943514_15943544_1": {"section_id": 6781, "quality": 1.0, "length": 26}}}});