post_cb({"4368468": {"ParentId": "4368361", "CommentCount": "8", "Body": "<p>I have no idea how this relates to the specification, but this is how I see it:</p>\n<p>When you do <code>Test a(a);</code> it allocates space for <code>a</code> on the stack. Therefore the location of <code>a</code> in memory is known to the compiler at the start of <code>main</code>. When the constructor is called (the memory is of course allocated before that), the correct <code>this</code> pointer is passed to it because it's known.</p>\n<p>When you do <code>Test *b = new Test(*b);</code>, you need to think of it as two steps. First the object is allocated and constructed, and then the pointer to it is assigned to <code>b</code>. The reason you get the message you get is that you're essentially passing in an uninitialized pointer to the constructor, and the comparing it with the actual <code>this</code> pointer of the object (which will eventually get assigned to <code>b</code>, but not before the constructor exits).</p>\n", "OwnerUserId": "227267", "PostTypeId": "2", "Id": "4368468", "Score": "3", "CreationDate": "2010-12-06T16:15:18.017", "LastActivityDate": "2010-12-06T16:15:18.017"}, "4368807": {"ParentId": "4368361", "CommentCount": "0", "Body": "<p>The reason this \"is allowed\" is because the rules say an identifiers scope starts immediately after the identifier. In the case</p>\n<pre><code>int i = i;\n</code></pre>\n<p>the RHS i is \"after\" the LHS i so i is in scope. This is not always bad:</p>\n<pre><code>void *p = (void*)&amp;p; // p contains its own address\n</code></pre>\n<p>because a variable can be addressed without its value being used. In the case of the OP's copy constructor no error can be given easily, since binding a reference to a variable does not require the variable to be initialised: it is equivalent to taking the address of a variable. A legitimate constructor could be:</p>\n<pre><code>struct List { List *next; List(List &amp;n) { next = &amp;n; } };\n</code></pre>\n<p>where you see the argument is merely addressed, its value isn't used. In this case a self-reference could actually make sense: the tail of a list is given by a self-reference. Indeed, if you change the type of \"next\" to a reference, there's little choice since you can't easily use NULL as you might for a pointer.</p>\n<p>As usual, the question is backwards. The question is not why an initialisation of a variable can refer to itself, the question is why it can't refer forward. [In Felix, this is possible]. In particular, for types as opposed to variables, the lack of ability to forward reference is extremely broken, since it prevents recursive types being defined other than by using incomplete types, which is enough in C, but not in C++ due to the existence of templates. </p>\n", "OwnerUserId": "518287", "PostTypeId": "2", "Id": "4368807", "Score": "8", "CreationDate": "2010-12-06T16:46:37.120", "LastActivityDate": "2010-12-06T16:46:37.120"}, "4368449": {"ParentId": "4368361", "CommentCount": "5", "Body": "<p>If you crank your warning levels up, your compiler will probably warn you about using uninitialized stuff. UB doesn't <em>require</em> a diagnostic, many things that are \"obviously\" wrong may compile.</p>\n", "OwnerUserId": "524436", "PostTypeId": "2", "Id": "4368449", "Score": "2", "CreationDate": "2010-12-06T16:13:52.957", "LastActivityDate": "2010-12-06T16:13:52.957"}, "4368738": {"ParentId": "4368361", "CommentCount": "2", "Body": "<p>The second one where you use <code>new</code> is actually easier to understand; what you're invoking there is exactly the same as:</p>\n<pre><code>Test *b;\nb = new Test(*b);\n</code></pre>\n<p>and you're actually performing an invalid dereference. Try to add a <code>&lt;&lt; &amp;other &lt;&lt;</code> to your <code>cout</code> lines in the constructor, and make that</p>\n<pre><code>Test *b = (Test *)0xFOOD1E44BADD1E5;\n</code></pre>\n<p>to see that you're passing through whatever value a pointer on the stack has been given. If not explicitly initialized, that's undefined. But even if you don't initialize it with some sort of (in)sane default, it'll be different from the return value of <code>new</code>, as you found out.</p>\n<p>For the first, think of it as an in-place <code>new</code>. <code>Test a</code> is a local variable not a pointer, it lives on the stack and therefore its memory location is always well defined - this is very much unlike a pointer, <code>Test *b</code> which, unless explicitly initialized to some valid location, will be dangling.</p>\n<p>If you write your first instantiation like:</p>\n<pre><code>Test a(*(&amp;a));\n</code></pre>\n<p>it becomes clearer what you're invoking there.</p>\n<p>I don't know a way to make the compiler disallow (or even warn) about this sort of self-initialization-from-nowhere through the copy constructor. </p>\n", "OwnerUserId": "512360", "PostTypeId": "2", "Id": "4368738", "Score": "2", "CreationDate": "2010-12-06T16:39:54.693", "LastActivityDate": "2010-12-06T16:39:54.693"}, "4368485": {"ParentId": "4368361", "CommentCount": "3", "Body": "<p>I don't know the spec reference, but I do know that accessing an uninitialized pointer always results in undefined behaviour. </p>\n<p>When I compile your code in Visual C++ I get:</p>\n<blockquote>\n<p id=\"so_4368361_4368485_0\">test.cpp(20): warning C4700:\n  uninitialized local variable 'b' used</p>\n</blockquote>\n", "OwnerUserId": "210102", "PostTypeId": "2", "Id": "4368485", "Score": "0", "CreationDate": "2010-12-06T16:16:50.403", "LastActivityDate": "2010-12-06T16:16:50.403"}, "4368361": {"CommentCount": "4", "AcceptedAnswerId": "4368807", "PostTypeId": "1", "LastEditorUserId": "276052", "CreationDate": "2010-12-06T16:06:53.477", "LastActivityDate": "2010-12-21T15:08:17.627", "LastEditDate": "2010-12-21T15:08:17.627", "ViewCount": "2988", "FavoriteCount": "8", "Title": "Construct object with itself as reference?", "Id": "4368361", "Score": "8", "Body": "<p>I just realised that this program compiles and runs (gcc version 4.4.5 / Ubuntu):</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Test\n{\npublic:\n  // copyconstructor\n  Test(const Test&amp; other);\n};\n\nTest::Test(const Test&amp; other)\n{\n  if (this == &amp;other)\n    cout &lt;&lt; \"copying myself\" &lt;&lt; endl;\n  else\n    cout &lt;&lt; \"copying something else\" &lt;&lt; endl;\n}\n\nint main(int argv, char** argc)\n{\n  Test a(a);              // compiles, runs and prints \"copying myself\"\n  Test *b = new Test(*b); // compiles, runs and prints \"copying something else\"\n}\n</code></pre>\n<p>I wonder why on earth this even compiles. I assume that (just as in Java) arguments are evaluated before the method / constructor is called, so I suspect that this case must be covered by some \"special case\" in the language specification?</p>\n<p><strong>Questions:</strong></p>\n<ol>\n<li>Could someone explain this (preferably by referring to the specification)?</li>\n<li>What is the rationale for allowing this?</li>\n<li>Is it standard C++ or is it gcc-specific?</li>\n</ol>\n<hr>\n<p>EDIT 1: I just realised that I can even write <code>int i = i;</code></p>\n<p>EDIT 2: Even with <code>-Wall</code> and <code>-pedantic</code> the compiler doesn't complain about <code>Test a(a);</code>.</p>\n<p>EDIT 3: If I add a method </p>\n<pre><code>Test method(Test&amp; t)\n{\n  cout &lt;&lt; \"in some\" &lt;&lt; endl;\n  return t;\n}\n</code></pre>\n<p>I can even do <code>Test a(method(a));</code> without any warnings.</p>\n</hr>", "Tags": "<c++><copy-constructor>", "OwnerUserId": "276052", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_4368361_4370147_0": {"section_id": 7194, "quality": 0.8837209302325582, "length": 38}}, "n3337": {"so_4368361_4370147_0": {"section_id": 6938, "quality": 0.8837209302325582, "length": 38}}, "n4659": {"so_4368361_4370147_0": {"section_id": 8703, "quality": 0.8837209302325582, "length": 38}}}, "4370147": {"ParentId": "4368361", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The first case is (perhaps) covered by 3.8/6:</p>\n<blockquote>\n<p id=\"so_4368361_4370147_0\">before the lifetime of an object has\n  started but after the storage which\n  the object will occupy has been\n  allocated or, after the lifetime of an\n  object has ended and before the\n  storage which the object occupied is\n  reused or released, any lvalue which\n  refers to the original object may be\n  used but only in limited ways. Such an\n  lvalue refers to allocated storage\n  (3.7.3.2), and using the properties of\n  the lvalue which do not depend on its\n  value is well-defined.</p>\n</blockquote>\n<p>Since all you're using of <code>a</code> (and <code>other</code>, which is bound to <code>a</code>) before the start of its lifetime is the address, I think you're good: read the rest of that paragraph for the detailed rules.</p>\n<p>Beware though that 8.3.2/4 says, \"A reference shall be initialized to refer to a valid object or function.\" There is some question (as a defect report on the standard) what \"valid\" means in this context, so possibly you can't bind the parameter <code>other</code> to the unconstructed (and hence, \"invalid\"?) <code>a</code>.</p>\n<p>So, I'm uncertain what the standard actually says here - I can use an lvalue, but not bind it to a reference, perhaps, in which case <code>a</code> <em>isn't</em> good, while passing a pointer to <code>a</code> would be OK as long as it's only used in the ways permitted by 3.8/5.</p>\n<p>In the case of <code>b</code>, you're using the value before it's initialized (because you dereference it, and also because even if you got that far, <code>&amp;other</code> would be the value of <code>b</code>). This clearly is not good.</p>\n<p>As ever in C++, it compiles because it's not a breach of language constraints, and the standard doesn't explicitly require a diagnostic. Imagine the contortions the spec would have to go through in order to mandate a diagnostic when an object is invalidly used in its own initialization, and imagine the data flow analysis that a compiler might have to do to identify complex cases (it may not even be possible at compile time, if the pointer is smuggled through an externally-defined function). Easier to leave it as undefined behavior, unless anyone has any really good suggestions for new spec language ;-)</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2010-12-06T21:15:10.610", "Id": "4370147", "Score": "3", "CreationDate": "2010-12-06T19:28:13.060", "LastActivityDate": "2010-12-06T21:15:10.610"}});