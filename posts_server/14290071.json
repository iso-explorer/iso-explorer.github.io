post_cb({"14290071": {"CommentCount": "2", "ViewCount": "872", "PostTypeId": "1", "LastEditorUserId": "1899020", "CreationDate": "2013-01-12T03:56:30.473", "LastActivityDate": "2013-01-12T05:21:32.730", "Title": "Cannot convert overloaded function pointer to member function pointer?", "AcceptedAnswerId": "14290201", "LastEditDate": "2013-01-12T04:18:35.240", "Id": "14290071", "Score": "2", "Body": "<p>I have code as following</p>\n<pre><code>class A\n{\npublic:\n    int Key() const;\n};\n\nclass B : public A\n{};\n\ntemplate&lt;class T, int (T::*MemFunction)() const&gt;\nclass TT\n{\npublic:\n    int Get() const               {return (m_t.*MemFunction)();}\n\nprivate:\n    T m_t;\n};\n\nTT&lt;B, &amp;B::Key&gt; t; // Wrong, cannot convert overloaded function\n                  // to int (T::*MemFunction)() (VS2010)\n</code></pre>\n<p>Why and how to a similar way works? Thanks</p>\n", "Tags": "<c++><templates><overloading>", "OwnerUserId": "1899020", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_14290071_14290523_2": {"section_id": 91, "quality": 0.8947368421052632, "length": 17}, "so_14290071_14290523_0": {"section_id": 6066, "quality": 0.8823529411764706, "length": 45}}, "n3337": {"so_14290071_14290523_2": {"section_id": 86, "quality": 0.8947368421052632, "length": 17}, "so_14290071_14290523_0": {"section_id": 5834, "quality": 0.8823529411764706, "length": 45}}, "n4659": {"so_14290071_14290523_2": {"section_id": 43, "quality": 0.5263157894736842, "length": 10}, "so_14290071_14290523_0": {"section_id": 7562, "quality": 0.8823529411764706, "length": 45}}}, "14290523": {"ParentId": "14290071", "CommentCount": "0", "Body": "<p>The answer has already been provided by billz, but I will try to produce an explanation.</p>\n<p>In C++ when obtaining a pointer to member, the result of the expression is not a pointer to member of the type present in the expression, but rather a pointer-to-member of the type where the member is defined. That is, the expression <code>&amp;B::Key</code> yields <code>&amp;A::Key</code>, as the member function <code>Key</code> is defined in <code>A</code> and not in <code>B</code>. This is defined in \u00a75.3.1/3, which is hard to read but comes with an example:</p>\n<blockquote>\n<p id=\"so_14290071_14290523_0\">The result of the unary &amp; operator is a pointer to its operand. The operand shall be an lvalue or a qualified-id. If the operand is a qualified-id naming a non-static member m of some class C with type T, the result has type \u201cpointer to member of class C of type T\u201d and is a prvalue designating C::m. Otherwise, if the type of the expression is T, the result has type \u201cpointer to T\u201d and is a prvalue that is the address of the designated object (1.7) or a pointer to the designated function. [ Note: In particular, the address of an object of type \u201ccv T\u201d is \u201cpointer to cv T\u201d, with the same cv-qualification. \u2014 end note ] [ Example:</p>\n</blockquote>\n<pre><code>struct A { int i; };\nstruct B : A { };\n... &amp;B::i ... // has type int A::*\n</code></pre>\n<blockquote>\n<p id=\"so_14290071_14290523_1\">\u2014 end example ] </p>\n</blockquote>\n<p>This means that your template instantiation is equivalent to:</p>\n<pre><code>TT&lt;B, &amp;A::Key&gt;\n</code></pre>\n<p>While a pointer-to-member to a member of a base can be converted to a pointer-to-member to the a derived type, for the particular case of a non-type non-template template parameter that conversion is not allowed. The conversions for non-type non-template template parameters are defined in \u00a714.3.2/5, which for this particular case states:</p>\n<blockquote>\n<p id=\"so_14290071_14290523_2\">For a non-type template-parameter of type pointer to member function, if the template-argument is of type std::nullptr_t, the null member pointer conversion (4.11) is applied; otherwise, no conversions apply.</p>\n</blockquote>\n<p>Since the <code>&amp;A::Key</code> cannot be converged to <code>int (B::*)() const</code>, the template instantiation is ill-formed. By adding the cast in the template instantiation you are forcing the conversion to happen before instantiating the template, and the instantiation becomes valid as there is no need for conversiones.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "14290523", "Score": "2", "CreationDate": "2013-01-12T05:21:32.730", "LastActivityDate": "2013-01-12T05:21:32.730"}, "14290201": {"ParentId": "14290071", "CommentCount": "1", "Body": "<p>A cast should make it work:</p>\n<pre><code>typedef int (B::*Key)() const;\nTT&lt;Key(&amp;B::Key)&gt; t;\nt.Get();\n</code></pre>\n", "OwnerUserId": "951757", "PostTypeId": "2", "Id": "14290201", "Score": "1", "CreationDate": "2013-01-12T04:21:16.353", "LastActivityDate": "2013-01-12T04:21:16.353"}});