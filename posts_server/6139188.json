post_cb({"bq_ids": {"n4140": {"so_6139188_6139228_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 480}}, "n3337": {"so_6139188_6139228_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 471}}, "n4659": {"so_6139188_6139228_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 502}}}, "6139188": {"ViewCount": "890", "Body": "<p>I'm still a rookie programmer, I know that premature optimization is bad, but I also know that copying huge stuff around is bad, as well.</p>\n<p>I've read up on copy elision and it's synonyms but the examples on Wikipedia for example make it seem to me that copy elision can only take place if the object to be returned gets returned at the same time it gets completely constructed.</p>\n<p>What about objects like vectors, which usually only make sense when filled with something, when used as a return value.\nAfter all, an empty vector could just be instantiated manually.</p>\n<p>So, does it also work in a case like this?</p>\n<p>bad style for brevity:    </p>\n<pre><code>vector&lt;foo&gt; bar(string baz)\n{\n    vector&lt;foo&gt; out;\n    for (each letter in baz)\n        out.push_back(someTable[letter]);\n\n    return out;\n}\n\nint main()\n{\n     vector&lt;foo&gt; oof = bar(\"Hello World\");\n}\n</code></pre>\n<p>I have no real trouble using bar(vector &amp; out, string text), but the above way would look so much better, aesthetically, and for intent.</p>\n", "AcceptedAnswerId": "6139245", "Title": "Can the compiler elide the following copy?", "CreationDate": "2011-05-26T13:22:54.090", "Id": "6139188", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-07-08T14:15:56.030", "LastEditorUserId": "3919155", "LastActivityDate": "2016-07-08T14:15:56.030", "Score": "14", "OwnerUserId": "377052", "Tags": "<c++><copy-elision>", "AnswerCount": "3"}, "6139228": {"Id": "6139228", "PostTypeId": "2", "Body": "<p>There is nothing preventing the compiler from eliding the copy. This is defined in 12.8.15:</p>\n<blockquote>\n<p id=\"so_6139188_6139228_0\">[...] This elision of copy operations is\n  permitted in the following\n  circumstances (which may be combined\n  to eliminate multiple copies):</p>\n<p id=\"so_6139188_6139228_1\">[...]</p>\n<ul>\n<li>when a temporary class object that has\n  not been bound to a reference (12.2)\n  would be copied to a class object with\n  the same cv-unqualified type, the copy\n  operation can be omitted by\n  constructing the temporary object\n  directly into the target of the\n  omitted copy</li>\n</ul>\n</blockquote>\n<p>If it actually does depends on the compiler and the settings you use.</p>\n", "LastActivityDate": "2011-05-26T13:26:21.283", "CommentCount": "3", "CreationDate": "2011-05-26T13:26:21.283", "ParentId": "6139188", "Score": "5", "OwnerUserId": "160206"}, "6139238": {"Id": "6139238", "PostTypeId": "2", "Body": "<p>Both implied copies of the <code>vector</code> can - and often are - eliminated. The named return value optimization can eliminate the copy implied in the return statement <code>return out;</code> and it is allowed the the for the temporary implied in the copy initialization of <code>oof</code> to be eliminated as well.</p>\n<p>With both optimizations in play the object constructed in <code>vector&lt;foo&gt; out;</code> is the same object as <code>oof</code>.</p>\n<p>It's easier to test which of these optimizations are being performed with an artificial test case such as this.</p>\n<pre><code>struct CopyMe\n{\n    CopyMe();\n    CopyMe(const CopyMe&amp; x);\n    CopyMe&amp; operator=(const CopyMe&amp; x);\n\n    char data[1024]; // give it some bulk\n};\n\nvoid Mutate(CopyMe&amp;);\n\nCopyMe fn()\n{\n    CopyMe x;\n    Mutate(x);\n    return x;\n}\n\nint main()\n{\n    CopyMe y = fn();\n    return 0;\n}\n</code></pre>\n<p>The copy constructor is declared but not defined so that calls to it can't be inlined and eliminated. Compiling with a now comparatively old gcc 4.4 gives the following assembly at <code>-O3 -fno-inline</code> (filtered to demangle C++ names and edited to remove non-code).</p>\n<pre><code>fn():\n        pushq   %rbx\n        movq    %rdi, %rbx\n        call    CopyMe::CopyMe()\n        movq    %rbx, %rdi\n        call    Mutate(CopyMe&amp;)\n        movq    %rbx, %rax\n        popq    %rbx\n        ret\n\nmain:\n        subq    $1032, %rsp\n        movq    %rsp, %rdi\n        call    fn()\n        xorl    %eax, %eax\n        addq    $1032, %rsp\n        ret\n</code></pre>\n<p>As can be seen there are no calls to the copy constructor. In fact, gcc performs these optimizations even at <code>-O0</code>. You have to provide the <code>-fno-elide-constructors</code> to turn this behaviour off; if you do this then gcc generates two calls to the copy constructor of <code>CopyMe</code> - one inside and one outside of the call to <code>fn()</code>.</p>\n<pre><code>fn():\n        movq    %rbx, -16(%rsp)\n        movq    %rbp, -8(%rsp)\n        subq    $1048, %rsp\n        movq    %rdi, %rbx\n        movq    %rsp, %rdi\n        call    CopyMe::CopyMe()\n        movq    %rsp, %rdi\n        call    Mutate(CopyMe&amp;)\n        movq    %rsp, %rsi\n        movq    %rbx, %rdi\n        call    CopyMe::CopyMe(CopyMe const&amp;)\n        movq    %rbx, %rax\n        movq    1040(%rsp), %rbp\n        movq    1032(%rsp), %rbx\n        addq    $1048, %rsp\n        ret\n\nmain:\n        pushq   %rbx\n        subq    $2048, %rsp\n        movq    %rsp, %rdi\n        call    fn()\n        leaq    1024(%rsp), %rdi\n        movq    %rsp, %rsi\n        call    CopyMe::CopyMe(CopyMe const&amp;)\n        xorl    %eax, %eax\n        addq    $2048, %rsp\n        popq    %rbx\n        ret\n</code></pre>\n", "LastEditorUserId": "19563", "LastActivityDate": "2011-05-26T22:00:54.400", "Score": "5", "CreationDate": "2011-05-26T13:27:05.867", "ParentId": "6139188", "CommentCount": "0", "OwnerUserId": "19563", "LastEditDate": "2011-05-26T22:00:54.400"}, "6139245": {"Id": "6139245", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_6139188_6139245_0\">the examples on wikipedia for example make it seem to me that copy elision can only take place if the object to be returned gets returned at the same time it gets completely constructed.</p>\n</blockquote>\n<p>That is misleading (read: wrong). The issue is rather that only <em>one</em> object is returned in all code paths, i.e. that only <em>one</em> construction for the potential return object is happening.</p>\n<p>Your code is fine, any modern compiler can elide the copy.</p>\n<p>On the other hand, the following code could potentially generate problems:</p>\n<pre><code>vector&lt;int&gt; foo() {\n    vector&lt;int&gt; a;\n    vector&lt;int&gt; b;\n    // \u2026 fill both.\n    bool c;\n    std::cin &gt;&gt; c;\n    if (c) return a; else return b;\n}\n</code></pre>\n<p>Here, the compiler needs to fully construct two distinct objects, and only <em>later</em> decides which of them are returned, hence it has to copy once because it cannot directly construct the returned object in the target memory location.</p>\n", "LastEditorUserId": "15416", "LastActivityDate": "2011-05-26T14:11:23.723", "Score": "10", "CreationDate": "2011-05-26T13:27:29.610", "ParentId": "6139188", "CommentCount": "5", "OwnerUserId": "1968", "LastEditDate": "2011-05-26T14:11:23.723"}});