post_cb({"24188429": {"ParentId": "24124493", "CommentCount": "0", "Body": "<p>In the following code <code>B::m_s</code> hides <code>A::m_s</code> in <code>C</code>. But it can be made directly accessible via <code>using A::m_s</code>.</p>\n<p>To see the difference comment out the using-directive.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct A {\n    std::string m_s;\n    A() :\n        m_s(\"I am A::m_s\")\n    {}\n};\n\nstruct B: A {\n    std::string m_s;\n\n    B() :\n        m_s(\"I am B::m_s\")\n    {}\n};\n\nstruct C: B {\n    using A::m_s;\n\n\n};\n\nint main() {\n    C c;\n    std::cout &lt;&lt; '\\n' &lt;&lt; c.C::m_s &lt;&lt; '\\n';\n}\n\n/*\n    Local Variables:\n    compile-command: \"g++ -g test.cc -o a.exe &amp;&amp; ./a.exe\"\n    End:\n */\n</code></pre>\n", "OwnerUserId": "2708138", "PostTypeId": "2", "Id": "24188429", "Score": "0", "CreationDate": "2014-06-12T15:35:14.350", "LastActivityDate": "2014-06-12T15:35:14.350"}, "24125092": {"ParentId": "24124493", "CommentCount": "2", "Body": "<p>I believe this is what the standard provides:</p>\n<pre><code>struct A {\n  struct s {} s;\n  enum e { e };\n};\nstruct B: A {\n  using A::s;\n  using A::e;\n};\nstruct B::s s2;\nenum B::e e2;\n</code></pre>\n<p>The <em>using-declaration</em>s in the scope of <code>B</code> bring into scope the class and enumeration names <code>A::s</code> and <code>A::e</code>, even though they are hidden by a member and enumerator respectively.</p>\n<p>Note that the <em>using-declaration</em>s also bring into scope the member and enumerator, so the class and enumeration are still hidden within the scope of <code>B</code>; this means that to use them within <code>B</code> or elsewhere we need to use the <code>struct</code> and <code>enum</code> tags.</p>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "24125092", "Score": "0", "CreationDate": "2014-06-09T16:59:15.737", "LastActivityDate": "2014-06-09T16:59:15.737"}, "bq_ids": {"n4140": {"so_24124493_24124493_1": {"section_id": 7113, "quality": 0.8666666666666667, "length": 13}, "so_24124493_24124493_0": {"section_id": 7113, "quality": 0.9375, "length": 15}}, "n3337": {"so_24124493_24124493_1": {"section_id": 6857, "quality": 0.8666666666666667, "length": 13}, "so_24124493_24124493_0": {"section_id": 6857, "quality": 0.9375, "length": 15}}, "n4659": {"so_24124493_24124493_1": {"section_id": 8614, "quality": 0.8666666666666667, "length": 13}, "so_24124493_24124493_0": {"section_id": 8614, "quality": 0.9375, "length": 15}}}, "24124493": {"CommentCount": "0", "AcceptedAnswerId": "24125092", "PostTypeId": "1", "LastEditorUserId": "1938163", "CreationDate": "2014-06-09T16:22:56.943", "LastActivityDate": "2014-06-12T15:35:14.350", "AnswerCount": "2", "LastEditDate": "2014-06-09T16:26:46.347", "ViewCount": "96", "FavoriteCount": "3", "Title": "Class or enumeration using declaration", "Id": "24124493", "Score": "3", "Body": "<p>The beginning of 3.4.3.1/1 of N3797 said:</p>\n<blockquote>\n<p id=\"so_24124493_24124493_0\">If the nested-name-specifier of a qualified-id nominates a class, the\n  name specified after the nested-name-specifier is looked up in the\n  scope of the class (10.2), except for the cases listed below.</p>\n</blockquote>\n<p>and one of this rules is:</p>\n<blockquote>\n<p id=\"so_24124493_24124493_1\">the lookup for a name specified in a using-declaration (7.3.3) also\n  finds class or enumeration names hidden within the same scope\n  (3.3.10).</p>\n</blockquote>\n<p>Can you get an example to demonstrate that rule?</p>\n", "Tags": "<c++><class><enumeration><using><language-lawyer>", "OwnerDisplayName": "user2953119"}});