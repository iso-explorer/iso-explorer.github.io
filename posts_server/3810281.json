post_cb({"3810522": {"Id": "3810522", "PostTypeId": "2", "Body": "<p>The first two statements explain where the instantiation point of certain template constructs are; it doesn't introduce new template constructs. So you can reuse your previous examples.</p>\n<p>The third statement (14.6.4.1/6) tells us what the point of instantiation points is: they are the point where names are looked up during the second phase of name lookup. Names that are declared <em>before</em> the instantiation point are visible; those declared afterwards are not. (In the first phase of two-phase name lookup, non-dependent names are looked up in the set of declarations that precede the template <em>definition</em>).</p>\n<p>So, given:</p>\n<pre><code>template &lt;typename T&gt; void foo() {\n  T() + T();\n}\n</code></pre>\n<p>the instantiation contexts of the expression <code>T()+T()</code> is the set of declarations that precede the respective instantiation points of <code>foo&lt;T&gt;</code>. The name <code>operator+</code> is looked up in those contexts, and includes declarations that follow this definition but precede the instantiation point.</p>\n", "LastActivityDate": "2010-09-28T07:24:51.907", "CommentCount": "2", "CreationDate": "2010-09-28T07:24:51.907", "ParentId": "3810281", "Score": "2", "OwnerUserId": "15416"}, "bq_ids": {"n4140": {"so_3810281_37500074_0": {"length": 19, "quality": 0.95, "section_id": 222}}, "n3337": {"so_3810281_37500074_0": {"length": 19, "quality": 0.95, "section_id": 215}}, "n4659": {"so_3810281_37500074_0": {"length": 19, "quality": 0.95, "section_id": 230}}}, "37500074": {"Id": "37500074", "PostTypeId": "2", "Body": "<p>There seems always tons of questions with regards to instantiation context.</p>\n<p>The example given by MSalters is problematic:</p>\n<pre><code>template &lt;typename T&gt; void foo() {\n  T() + T();\n}\n</code></pre>\n<p>consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n\ntemplate &lt;typename T&gt; void foo() {\n  T() + T();\n}\n\nclass A {};\n\nvoid operator +(const A&amp;, const A&amp;)\n{\n    cout &lt;&lt; \"Called operator+(const A&amp;, const A&amp;)\" &lt;&lt;endl;\n}\n\nint main()\n{\n    foo&lt;A&gt;();\n}\n</code></pre>\n<p>That compiles and runs on all compilers, but if you put the class A definition into a namespace:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n\ntemplate &lt;typename T&gt; void foo() {\n    T() + T();\n}\n\nnamespace {\n   class A {};\n}\n\n\nvoid operator+(const A&amp;, const  A&amp;)\n{\n    cout &lt;&lt; \"operator+(const N::A&amp;, const N::A&amp;)\" &lt;&lt; endl;\n}\n\nint main()\n{\n     foo&lt;A&gt;();\n}\n</code></pre>\n<p>Clang will fail to compile, but VC++ and gcc compiles. Why? which compiler conforms to the spec?</p>\n<p>Frankly, I don't know. Some compiler, like gcc even contradicts itself in this area. Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n\ntemplate &lt;typename T&gt; void foo() {\n    g(T());\n}\n\nnamespace {\n   class A {};\n}\n\n\nvoid g(A a)\n{\n    cout &lt;&lt; \"g(A)\" &lt;&lt; endl;\n}\n\nint main()\n{\n    foo&lt;A&gt;();\n}\n</code></pre>\n<p>Simply change from \"operator+\" to a function named \"g\", gcc fails to compile???Why???</p>\n<p>If the Spec is correct, then why GCC cannot find 'g'?</p>\n<blockquote>\n<p id=\"so_3810281_37500074_0\">6.The instantiation context of an expression that depends on the    template arguments is the set of declarations with external linkage<br>\n  declared prior to the point of instantiation of the template<br>\n  specialization in the same translation unit.</br></br></p>\n</blockquote>\n<p>When I was reading Bjarne Stroustrup's \"The C++ Programming Language, 4th Edition\", 26.3.5 Template and Namespaces, he has this example:</p>\n<pre><code>namespace N{\n    class A{};\n    char f(A);\n}\n\nchar f(int);\n\ntemplate&lt;typename T&gt;\nchar g(T t)\n{\n    return f(t);       //choose f() depending on what T is\n}\n\nchar f(double);\n\nchar c1 = g(N::A());   //causes N::f(N::A) to be called\nchar c2 = g(2);        //causes f(int) to be called\nchar c3 = g(2.1);      //causes f(int) to be called, f(double) not considered\n</code></pre>\n<p>Here, f(t) is clearly dependent, so we cannot bind f at the point of definition. To generate a specialization for g(N::A), the compiler looks in namespace N for functions called f() and fins N::f(N::A).</p>\n<p>The f(int) is found because it is in scope at the point of definition of the template. The f(double) is not found because it is not in scope at the point of definition of the template, and argument-dependent lookup does not find a global function takes only arguments of built-in types. </p>\n<p>So it's a mess!</p>\n", "LastActivityDate": "2016-05-28T14:18:28.563", "CommentCount": "0", "CreationDate": "2016-05-28T14:18:28.563", "ParentId": "3810281", "Score": "1", "OwnerUserId": "5972353"}, "3810281": {"ViewCount": "478", "Body": "<p>This is the statement from ISO C++ Standard 14.6.4.1 Point of instantiation</p>\n<pre><code> 4.If a virtual function is implicitly instantiated, its point of instantiation\n   is immediately following the point of instantiation of its enclosing\n   class template specialization.\n\n 5.An explicit instantiation directive is an instantiation point for the\n   specialization or specializations specified by the explicit \n   instantiation directive.\n\n 6.The instantiation context of an expression that depends on the\n   template arguments is the set of declarations with external linkage \n   declared prior to the point of instantiation of the template \n   specialization in the same translation unit.\n</code></pre>\n<p>I am unable to write a programs for this whole section. I am trying to write a programs for this section from yesterday.</p>\n<p>Please, normally I would try to ask a 1 or more points. In any section. But here I am unable to understand a single point in this section.</p>\n<p>So, kindly can any one provide me a code for this sections to understand.</p>\n", "AcceptedAnswerId": "3810522", "Title": "Name resolution and Point of instantiation in Templates", "CreationDate": "2010-09-28T06:41:09.187", "Id": "3810281", "CommentCount": "3", "LastEditDate": "2016-08-30T16:25:48.033", "PostTypeId": "1", "LastEditorDisplayName": "BE Student", "OwnerDisplayName": "BE Student", "LastEditorUserId": "2289509", "LastActivityDate": "2016-08-30T16:25:48.033", "Score": "0", "Tags": "<c++><templates>", "AnswerCount": "2"}});