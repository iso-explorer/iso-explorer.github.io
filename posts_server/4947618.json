post_cb({"4947923": {"ParentId": "4947618", "CommentCount": "0", "Body": "<p>You are assuming that because <code>optional&lt;int&gt;</code> has an implicit constructor from int, the compiler should know that is the type you are trying to create.</p>\n<p>Template type deduction does not extend to that.</p>\n<p>You could write your own template of boo with the one that takes optional as a generalisation</p>\n<pre><code>template&lt; typename A &gt; int boo( const A&amp; a );\ntemplate &lt; typename A &gt;\nint boo( const boost::optional&lt; A &gt; &amp; )\n{\n    return 3;\n}\n\ntemplate &lt; typename A &gt;\nint boo( const A &amp; a )\n{\n    return boo&lt;A&gt;(boost::optional(a)); // allows implicit conversion\n}\n</code></pre>\n", "OwnerUserId": "442284", "PostTypeId": "2", "Id": "4947923", "Score": "1", "CreationDate": "2011-02-09T16:51:41.170", "LastActivityDate": "2011-02-09T16:51:41.170"}, "4947618": {"CommentCount": "0", "ViewCount": "358", "PostTypeId": "1", "LastEditorUserId": "63550", "CreationDate": "2011-02-09T16:26:42.170", "LastActivityDate": "2012-04-25T20:13:07.867", "Title": "Failing the template function lookup", "AcceptedAnswerId": "4947668", "LastEditDate": "2012-04-25T20:13:07.867", "Id": "4947618", "Score": "1", "Body": "<p>Consider following example.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;boost/optional.hpp&gt;\n\ntemplate &lt; typename A &gt;\nint boo( const boost::optional&lt; A &gt; &amp;a );\n\ntemplate &lt; typename A &gt;\nint foo( const A &amp;a )\n{\n    return boo( a );\n}\n\ntemplate &lt; typename A &gt;\nint boo( const boost::optional&lt; A &gt; &amp; )\n{\n    return 3;\n}\n\n\nint main()\n{\n    std::cout &lt;&lt; \"foo = \" &lt;&lt; foo( 3 ) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"boo = \" &lt;&lt; boo( 3 ) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Compiling this using g++ 4.3.0 throws the next compiling errors:</p>\n<pre><code>dfg.cpp: In function \u2018int main()\u2019:\ndfg.cpp:25: error: no matching function for call to \u2018boo(int)\u2019\ndfg.cpp: In function \u2018int foo(const A&amp;) [with A = int]\u2019:\ndfg.cpp:24:   instantiated from here\ndfg.cpp:12: error: no matching function for call to \u2018boo(const int&amp;)\u2019\n</code></pre>\n<p>What should I do differently (if possible with references from the C++ standard)? \nWhy is it happening and how do I fix it?</p>\n<p><strong>EDIT</strong></p>\n<p>The fix is to create the correct type in <code>foo</code>:</p>\n<pre><code>template &lt; typename A &gt;\nint foo( const A &amp;a )\n{\n    const boost::optional&lt; A &gt; optA( a );\n    return boo( optA );\n}\n</code></pre>\n<p>But the questions still stands: why is it not created automatically?</p>\n", "Tags": "<c++><templates><language-lawyer>", "OwnerUserId": "476681", "AnswerCount": "3"}, "4947668": {"ParentId": "4947618", "PostTypeId": "2", "CommentCount": "2", "Body": "<pre><code>return boo( a );\n</code></pre>\n<p>Here type of <code>a</code> is <code>int</code>, and there is no function with name <code>boo</code> which accepts argument of type <code>int</code>. Hence you see this error:</p>\n<blockquote>\n<p id=\"so_4947618_4947668_0\">dfg.cpp:25: error: no matching\n  function for call to \u2018boo(int)\u2019</p>\n</blockquote>\n<p>Even if <code>int</code> can be <em>implicitly</em> converted into <code>boost::optional&lt;int&gt;</code>, the compiler cannot deduce the template argument for <code>boost::optional&lt;T&gt;</code> from the calling site. It's one of the non-deduced contexts where you <em>explicitly</em> need to mention the type as,</p>\n<pre><code>   return boo&lt;A&gt;(a);\n</code></pre>\n<p>The Standard says in $14.8.2.1,</p>\n<blockquote>\n<p id=\"so_4947618_4947668_1\">if a template-parameter is not used in\n  any of the function parameters of a\n  function template, or is used only in\n  a non-deduced context, <strong>its\n  corresponding template-argument cannot\n  be deduced from a function call and\n  the template-argument must be\n  explicitly specified</strong>.</p>\n</blockquote>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-02-09T16:49:08.593", "Id": "4947668", "Score": "5", "CreationDate": "2011-02-09T16:29:32.133", "LastActivityDate": "2011-02-09T16:49:08.593"}, "bq_ids": {"n4140": {"so_4947618_4947668_1": {"section_id": 306, "quality": 1.0, "length": 18}}, "n3337": {"so_4947618_4947668_1": {"section_id": 297, "quality": 1.0, "length": 18}}, "n4659": {"so_4947618_4947668_1": {"section_id": 313, "quality": 1.0, "length": 18}}}, "4947707": {"ParentId": "4947618", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>To fix this, you need to explicitly specify the type when calling <code>boo</code>, i.e.</p>\n<pre><code>return boo&lt;A&gt;( a );\n</code></pre>\n<p>and</p>\n<pre><code>std::cout &lt;&lt; \"boo = \" &lt;&lt; boo&lt;int&gt;( 3 ) &lt;&lt; std::endl;\n</code></pre>\n<p>EDIT: removed my explanation, it was rubbish, Nawaz's explanation is better..</p>\n", "OwnerUserId": "266198", "LastEditorUserId": "266198", "LastEditDate": "2011-02-09T17:05:43.043", "Id": "4947707", "Score": "2", "CreationDate": "2011-02-09T16:32:48.377", "LastActivityDate": "2011-02-09T17:05:43.043"}});