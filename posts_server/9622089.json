post_cb({"9636595": {"ParentId": "9622089", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your conversion operator will never be picked up.</p>\n<p><code>\u00a712.3.2 [class.conv.fct] p1</code></p>\n<blockquote>\n<p id=\"so_9622089_9636595_0\">A conversion function is never used to convert a (possibly cv-qualified) object to the (possibly cv-qualified) same object type (or a reference to it), to a (possibly cv-qualified) base class of that type (or a reference to it), or to (possibly cv-qualified) void.</p>\n</blockquote>\n<p>The reason is that the conversions mentioned here (except to cv <code>void</code>) are already done by so-called <em>standard conversions</em> (qualification conversion (adding <code>const</code> or <code>volatile</code>) and identity conversion (binding an object to a reference)) and standard conversions are always preferred to user-defined conversions:</p>\n<p><code>\u00a713.3.3.2 [over.ics.rank] p2</code></p>\n<blockquote>\n<p id=\"so_9622089_9636595_1\">a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than a user-defined conversion sequence [...]</p>\n</blockquote>\n<hr>\n<p>For your specific case, if you want to transfer ownership, do so in C++11 style, with a move constructor.</p>\n<pre><code>#include &lt;utility&gt; // move\n\nstruct foo{\n  int resource;\n  foo(int r)\n    : resource(r) {}\n  foo(foo&amp;&amp; other)\n    : resource(other.resource)\n  { other.resource = 0; }\n};\n\nint main(){\n  foo f1(foo(5));\n  //foo f2(f1); // error\n  foo f3(std::move(f1)); // OK\n}\n</code></pre>\n<p>Transferring ownership via non-const copy constructors is a very bad idea, as such a type can never be stored in standard containers, see the ugly <code>std::auto_ptr</code> (replaced by <code>std::unique_ptr</code> in C++11, which has proper move semantics).</p>\n</hr>", "OwnerUserId": "500104", "LastEditorUserId": "500104", "LastEditDate": "2012-03-09T15:50:24.027", "Id": "9636595", "Score": "3", "CreationDate": "2012-03-09T15:27:39.490", "LastActivityDate": "2012-03-09T15:50:24.027"}, "9622089": {"CommentCount": "9", "AcceptedAnswerId": "9636595", "PostTypeId": "1", "LastEditorUserId": "138579", "CreationDate": "2012-03-08T17:32:40.860", "LastActivityDate": "2012-03-09T15:50:24.027", "LastEditDate": "2012-03-09T15:35:49.633", "ViewCount": "425", "FavoriteCount": "1", "Title": "g++ and non-const copy constructor issue", "Id": "9622089", "Score": "1", "Body": "<p>Is it possible to tell g++ to use the <code>FOO&amp;</code> operator when constructing the FOO object ?</p>\n<pre><code>struct FOO {\n\n        FOO( FOO &amp; foo ) { // non-const copy constructor\n        }\n\n        operator FOO&amp;() {\n\n                return *this;\n        }\n\n        FOO( int i ) {\n        }\n};\n\n\nint main() {\n\n        FOO a(FOO(5));\n}\n</code></pre>\n<p>I currently get the following error:</p>\n<pre><code>In function int main():\n  error: no matching function for call to FOO::FOO(FOO)\n  note: candidates are: FOO::FOO(int)\n  note:                 FOO::FOO(FOO&amp;)\n</code></pre>\n<p><strong>-- edit --</strong></p>\n<p>Note that I try to setup an object that can exchange the ownership of a resource.<br>\nCalling <code>FOO foo1(foo)</code> make foo to lose the ownership of the resource, this mean that foo cannot be <code>const</code>.<br>\nAlso note that I want to avoid smart-pointer mechanism.</br></br></p>\n", "Tags": "<c++><g++><copy-constructor>", "OwnerUserId": "138579", "AnswerCount": "2"}, "9636830": {"ParentId": "9622089", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_9622089_9636830_0\">Note that I try to setup an object that can exchange the ownership of a resource.</p>\n<p id=\"so_9622089_9636830_1\">Calling FOO foo1(foo) make foo to lose the ownership of the resource, this mean that foo cannot be const.</p>\n<p id=\"so_9622089_9636830_2\">Also note that I want to avoid smart-pointer mechanism.</p>\n</blockquote>\n<p>So you've got something like:</p>\n<pre><code>struct FOO {\n        // ...\n        SomeType* storage;\n        bool owns_storage;\n        // ...\n        FOO(const FOO&amp; foo): storage(foo.storage), owns_storage(true) {\n            foo.owns_storage = false; /* &lt;-- fails to build */ }\n        ~FOO() { if(owns_storage) delete storage; }\n};\n</code></pre>\n<p>And you need a copy to set <code>owns_storage</code> to <code>false</code> on the <code>const</code> original object. Use the <code>mutable</code> keyword and your problem goes away:</p>\n<pre><code>struct FOO {\n        // ...\n        SomeType* storage;\n        mutable bool owns_storage;\n        // ...\n        FOO(const FOO&amp; foo): storage(foo.storage), owns_storage(true) {\n            foo.owns_storage = false; /* builds fine now */ }\n        ~FOO() { if(owns_storage) delete storage; }\n};\n</code></pre>\n", "OwnerUserId": "2624511", "LastEditorUserId": "2624511", "LastEditDate": "2012-03-09T15:49:19.103", "Id": "9636830", "Score": "1", "CreationDate": "2012-03-09T15:43:26.717", "LastActivityDate": "2012-03-09T15:49:19.103"}, "bq_ids": {"n4140": {"so_9622089_9636595_1": {"section_id": 603, "quality": 0.9, "length": 9}, "so_9622089_9636595_0": {"section_id": 391, "quality": 1.0, "length": 22}}, "n3337": {"so_9622089_9636595_1": {"section_id": 593, "quality": 0.9, "length": 9}, "so_9622089_9636595_0": {"section_id": 382, "quality": 1.0, "length": 22}}, "n4659": {"so_9622089_9636595_1": {"section_id": 629, "quality": 0.9, "length": 9}, "so_9622089_9636595_0": {"section_id": 408, "quality": 1.0, "length": 22}}}});