post_cb({"bq_ids": {"n4140": {"so_49067244_49067401_0": {"length": 75, "quality": 0.9615384615384616, "section_id": 1242}}, "n3337": {"so_49067244_49067401_0": {"length": 75, "quality": 0.9615384615384616, "section_id": 1240}}, "n4659": {"so_49067244_49067401_0": {"length": 75, "quality": 0.9615384615384616, "section_id": 1330}}}, "49067814": {"Id": "49067814", "PostTypeId": "2", "Body": "<p>Ok, I finally see your confusion. Is caused by the way the word \"both\" was used. </p>\n<p>The meaning should be that both of the following conditions must be true:</p>\n<ul>\n<li><p>The type <code>Type1</code> must be such that objects of types <code>ForwardIt1</code> can be \ndereferenced and then implicitly converted to <code>Type1</code></p></li>\n<li><p>The type <code>Type2</code> must be such that objects of types <code>ForwardIt2</code> can be dereferenced and then implicitly converted to <code>Type2</code></p></li>\n</ul>\n<hr>\n<p>You will find the requirements in 25.2.13 Search [alg.search]:</p>\n<blockquote>\n<p id=\"so_49067244_49067814_0\">\u00a725.2.13 Search [alg.search]</p>\n<pre><code>template&lt;class ForwardIterator1, class ForwardIterator2,\n         class BinaryPredicate&gt;\nForwardIterator1\nsearch(ForwardIterator1 first1, ForwardIterator1 last1,\n       ForwardIterator2 first2, ForwardIterator2 last2,\n       BinaryPredicate pred);\n</code></pre>\n<ol start=\"2\">\n<li>Returns: The first iterator <code>i</code> in the range <code>[first1,last1 - (last2-first2))</code> such that for every non-negative integer <code>n</code> less than\n  <code>last2 - first2</code> the following corresponding conditions hold: <code>*(i + n) == *(first2 + n)</code>, <code>pred(*(i + n), *(first2 + n)) != false</code>. Returns <code>first1</code> if <code>[first2, last2)</code> is empty, otherwise returns <code>last1</code> if no such\n  iterator is found.</li>\n</ol>\n</blockquote>\n<p>Relevant is the condition:</p>\n<pre><code>pred(*(i + n), *(first2 + n)) != false\n</code></pre>\n<p>This implies that <code>pred(*(i + n), *(first2 + n))</code> is valid. That means that <code>*(i + n)</code> and <code>*(first2 + n)</code> can be passed as arguments to pred. This means that first param of <code>pred</code> must be constructible from  dereferencing <code>ForwardIterator1</code> and the 2nd parameter of <code>pred</code> must be constructible from dereferencing <code>ForwardIterator2</code>.</p>\n</hr>", "LastEditorUserId": "2805305", "LastActivityDate": "2018-03-02T11:22:03.397", "Score": "1", "CreationDate": "2018-03-02T11:01:40.910", "ParentId": "49067244", "CommentCount": "2", "OwnerUserId": "2805305", "LastEditDate": "2018-03-02T11:22:03.397"}, "49067244": {"ViewCount": "230", "Body": "<p>On this <a href=\"http://en.cppreference.com/w/cpp/algorithm/search\" rel=\"nofollow noreferrer\">site</a> it states that one of the constraints for a binary predicate passed into <code>std::search</code> is that:</p>\n<blockquote>\n<p id=\"so_49067244_49067244_0\">The types Type1 and Type2 must be such that objects of types ForwardIt1 and ForwardIt2 can be dereferenced and then implicitly converted to both Type1 and Type2. </p>\n</blockquote>\n<p>However, in the C++ International Standard documentation I see no reference to such a constraint. I am wondering if this constraint is explicitly stated in the C++ International Standard documentation which section it is under. In addition if it is not then why is this constraint placed upon the <code>std::search</code> function as isn't it possible to have two distinct types that while not implicitly convertible have an equality operator overload defined? </p>\n", "AcceptedAnswerId": "49067967", "Title": "C++ binary predicate implementation requirements for std::search", "CreationDate": "2018-03-02T10:26:59.010", "LastActivityDate": "2018-03-02T11:58:21.303", "CommentCount": "3", "LastEditDate": "2018-03-02T10:55:39.153", "PostTypeId": "1", "LastEditorUserId": "2303798", "Id": "49067244", "Score": "6", "OwnerUserId": "2303798", "Tags": "<c++><c++11>", "AnswerCount": "3"}, "49067967": {"Id": "49067967", "PostTypeId": "2", "Body": "<p>It's a mistake on the site. </p>\n<p>That parameter description is populated from <a href=\"http://en.cppreference.com/w/Template:par_pred2_eq\" rel=\"nofollow noreferrer\">this template</a>. It doesn't distinguish between binary predicates that are only called as <code>pred(*first1, *first2)</code> from those that are called as both <code>pred(*first1, *first2)</code> and <code>pred(*first2, *first1)</code></p>\n<p>Further digging:\nIt appears that <a href=\"http://en.cppreference.com/mwiki/index.php?title=Template%3Apar_pred2&amp;diff=93520&amp;oldid=61756\" rel=\"nofollow noreferrer\">this edit</a> added a named parameter to the <a href=\"http://en.cppreference.com/mwiki/index.php?title=Template:par_pred2\" rel=\"nofollow noreferrer\">parent template's</a> use of <a href=\"http://en.cppreference.com/w/Template:cast_req2\" rel=\"nofollow noreferrer\"><code>cast req2</code></a>, which controls whether it says \"both\" or \"respectively\". The <code>eq</code> variant does not have a passthrough of this new parameter. I don't have edit privileges to add it in to the template and the entry for <code>std::search</code></p>\n", "LastEditorUserId": "2610810", "LastActivityDate": "2018-03-02T11:58:21.303", "Score": "6", "CreationDate": "2018-03-02T11:12:45.743", "ParentId": "49067244", "CommentCount": "3", "OwnerUserId": "2610810", "LastEditDate": "2018-03-02T11:58:21.303"}, "49067401": {"Id": "49067401", "PostTypeId": "2", "Body": "<p>The requirement of a <code>BinaryPredicate</code> is stated in <a href=\"http://www.eel.is/c++draft/algorithms.requirements#7\" rel=\"nofollow noreferrer\">[algorithms.requirements]/7</a>:</p>\n<blockquote>\n<p id=\"so_49067244_49067401_0\">The <code>BinaryPredicate</code> parameter is used whenever an algorithm expects a function object that when applied to the result of dereferencing two corresponding iterators or to dereferencing an iterator and type <code>T</code> when <code>T</code> is part of the signature returns a value testable as <code>true</code>. In other words, if an algorithm takes <code>BinaryPredicate</code> <code>binary_\u00adpred</code> as its argument and <code>first1</code> and <code>first2</code> as its iterator arguments, it should work correctly in the construct <code>binary_\u00adpred(*first1, *first2)</code> contextually converted to <code>bool</code> ([conv]). <code>BinaryPredicate</code> always takes the first iterator's <code>value_\u00adtype</code> as its first argument, that is, in those cases when <code>T value</code> is part of the signature, it should work correctly in the construct <code>binary_\u00adpred(*first1, value)</code> contextually converted to <code>bool</code> ([conv]). <code>binary_\u00adpred</code> shall not apply any non-constant function through the dereferenced iterators.</p>\n</blockquote>\n<p>There is no requirement for constructing <code>Type1</code> from dereferencing <code>ForwardIt2</code>. The word '<strong>both</strong>' in OP's quotation from cppreference is inaccurate. </p>\n", "LastEditorUserId": "8605791", "LastActivityDate": "2018-03-02T11:20:27.523", "Score": "3", "CreationDate": "2018-03-02T10:36:55.003", "ParentId": "49067244", "CommentCount": "4", "OwnerUserId": "8605791", "LastEditDate": "2018-03-02T11:20:27.523"}});