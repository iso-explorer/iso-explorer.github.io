post_cb({"bq_ids": {"n4140": {"so_49174008_49174320_2": {"length": 26, "quality": 0.6842105263157895, "section_id": 6142}, "so_49174008_49174320_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 7185}}, "n3337": {"so_49174008_49174320_2": {"length": 26, "quality": 0.6842105263157895, "section_id": 5906}, "so_49174008_49174320_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 6929}}, "n4659": {"so_49174008_49174320_2": {"length": 33, "quality": 0.868421052631579, "section_id": 7638}, "so_49174008_49174320_1": {"length": 48, "quality": 0.8888888888888888, "section_id": 8732}, "so_49174008_49174320_0": {"length": 6, "quality": 1.0, "section_id": 8732}}}, "49174008": {"ViewCount": "175", "Body": "<p>Is it <em>undefined behaviour</em> in C++ to access elements in adjacent arrays as in following code?</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;algorithm&gt;\n#include &lt;iterator&gt;\n\nint main()\n{\n    int a[10][10];\n    static_assert(std::is_standard_layout&lt; decltype(a) &gt;::value, \"!\");\n    std::fill(std::begin(*std::begin(a)), std::end(*std::prev(std::end(a))), 0);\n    struct B { int b[10]; };\n    B b[10];\n    static_assert(std::is_standard_layout&lt; decltype(b) &gt;::value, \"!\");\n    std::fill(std::begin(std::begin(b)-&gt;b), std::end(std::prev(std::end(b))-&gt;b), 0);\n}\n</code></pre>\n<p>Technically I think for POD-types it is legal to access underlying memory in any manner one want, but what about <code>std::*</code> stuff?</p>\n<p>What if I change all <code>begin/end</code> to <code>rbegin/rend</code>?</p>\n", "AcceptedAnswerId": "49174320", "Title": "Access to elements of array of arrays using common iterator", "CreationDate": "2018-03-08T13:15:20.780", "LastActivityDate": "2018-03-08T16:48:16.557", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-03-08T16:48:16.557", "LastEditorUserId": "1430927", "Id": "49174008", "Score": "9", "OwnerUserId": "1430927", "Tags": "<c++><arrays><stl><language-lawyer>", "AnswerCount": "1"}, "49174320": {"Id": "49174320", "PostTypeId": "2", "Body": "<p>Yes, this is UB.</p>\n<p>From <a href=\"http://eel.is/c++draft/basic.compound#3\" rel=\"noreferrer\">[basic.compound]</a>:</p>\n<blockquote>\n<p id=\"so_49174008_49174320_0\">Every value of pointer type is one of the following:</p>\n<ul>\n<li>a pointer to an object or function (the pointer is said to point to the object or function), or</li>\n<li>a pointer past the end of an object ([expr.add]), or</li>\n<li>the null pointer value ([conv.ptr]) for that type, or</li>\n<li>an invalid pointer value.</li>\n</ul>\n<p id=\"so_49174008_49174320_1\">A value of a pointer type that is a pointer to or past the end of an object represents the address of the first byte in memory ([intro.memory]) occupied by the object or the first byte in memory after the end of the storage occupied by the object, respectively. <em>[\u2009Note:</em> A pointer past the end of an object ([expr.add]) is not considered to point to an unrelated object of the object's type that might be located at that address. A pointer value becomes invalid when the storage it denotes reaches the end of its storage duration; see [basic.stc]. <em>\u2014\u2009end note\u2009]</em></p>\n</blockquote>\n<p>And <a href=\"http://eel.is/c++draft/expr.add#4\" rel=\"noreferrer\">[expr.add]/4</a>:</p>\n<blockquote>\n<p id=\"so_49174008_49174320_2\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the expression P points to element x[i] of an array object x with n elements,86 the expressions P + J and J + P (where J has the value j) point to the (possibly-hypothetical) element x[i+j] if 0\u2264i+j\u2264n; otherwise, the behavior is undefined. Likewise, the expression P - J points to the (possibly-hypothetical) element x[i\u2212j] if 0\u2264i\u2212j\u2264n ; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>So <code>&amp;a[0][0] + 10</code> is a \"pointer past the end of an object\", it's the past the end pointer of the first array. You cannot add one more to that pointer - there is no defined behavior for this case. </p>\n<p>A pointer cannot be <em>both</em> a \"past the end\" pointer <em>and</em> a \"pointer to object\" (interpreting <code>&amp;a[0][0] + 10</code> as if it were <code>&amp;a[1][0]</code>). It's one or the other.</p>\n", "LastActivityDate": "2018-03-08T13:31:02.780", "CommentCount": "0", "CreationDate": "2018-03-08T13:31:02.780", "ParentId": "49174008", "Score": "8", "OwnerUserId": "2069064"}});