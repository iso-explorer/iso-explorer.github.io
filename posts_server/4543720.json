post_cb({"bq_ids": {"n4140": {"so_4543720_4543783_0": {"length": 16, "quality": 1.0, "section_id": 142}}, "n3337": {"so_4543720_4543783_0": {"length": 16, "quality": 1.0, "section_id": 136}}}, "4543720": {"ViewCount": "4113", "Body": "<pre><code>struct Bar {\n  enum { Special = 4 };\n};\n\ntemplate&lt;class T, int K&gt; struct Foo {};\ntemplate&lt;class T&gt; struct Foo&lt;T,T::Special&gt; {};\n</code></pre>\n<p>Usage:</p>\n<pre><code>Foo&lt;Bar&gt; aa;\n</code></pre>\n<p>fails to compile using gcc 4.1.2\nIt complains about the usage of <code>T::Special</code> for partial specilization of Foo. If <code>Special</code> was a class the solution would be to a typename in front of it. Is there something equivalent to it for enums (or integers)?</p>\n", "Title": "Is it possible to specialize a template using a member enum?", "CreationDate": "2010-12-28T04:48:36.697", "LastActivityDate": "2013-07-28T14:27:44.400", "CommentCount": "2", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2013-07-28T14:27:44.400", "LastEditorUserId": "41071", "Id": "4543720", "Score": "20", "OwnerUserId": "397293", "Tags": "<c++><templates><enums><template-specialization>", "AnswerCount": "2"}, "4543783": {"PostTypeId": "2", "Body": "<p>The type of a non-type template argument cannot depend on a template parameter of a partial specialization.</p>\n<p>ISO C++03 14.5.4/9 says</p>\n<blockquote>\n<p id=\"so_4543720_4543783_0\">A partially specialized non-type argument expression shall not involve a template parameter of the partial specialization except when the argument expression is a simple identifier.  </p>\n</blockquote>\n<pre><code>template &lt;int I, int J&gt; struct A {};\ntemplate &lt;int I&gt; struct A&lt;I+5, I*2&gt; {}; //error\ntemplate &lt;int I, int J&gt; struct B {};\ntemplate &lt;int I&gt; struct B&lt;I, I&gt; {};     //OK\n</code></pre>\n<p>So something like this is illegal <code>template&lt;class T&gt; struct Foo&lt;T,T::Special&gt; {};</code> because <code>T::Special</code> depends on <code>T</code></p>\n<p>The usage is also illegal. You have provided one template argument but you need to provide two.</p>\n", "LastActivityDate": "2010-12-28T05:15:15.820", "LastEditorUserId": "165520", "Id": "4543783", "CommentCount": "5", "CreationDate": "2010-12-28T05:04:15.847", "ParentId": "4543720", "Score": "9", "OwnerUserId": "165520", "LastEditDate": "2010-12-28T05:15:15.820"}, "4543880": {"PostTypeId": "2", "Body": "<p>Since that is not allowed by C++ as <a href=\"https://stackoverflow.com/questions/4543720/template-specilization-using-member-enums/4543783#4543783\">explained</a> by Prasoon, so an alternative solution would be to use <code>EnumToType</code> class template,</p>\n<pre><code>struct Bar {\n  enum { Special = 4 };\n};\n\ntemplate&lt;int e&gt;\nstruct EnumToType\n{\n  static const int value = e;\n};\n\ntemplate&lt;class T, class K&gt; //note I changed from \"int K\" to \"class K\"\nstruct Foo\n{};\n\ntemplate&lt;class T&gt; \nstruct Foo&lt;T, EnumToType&lt;(int)T::Special&gt; &gt; \n{\n   static const int enumValue = T::Special;\n};\n</code></pre>\n<p>Sample code at ideone : <a href=\"http://www.ideone.com/JPvZy\" rel=\"nofollow noreferrer\">http://www.ideone.com/JPvZy</a></p>\n<hr>\n<p>Or, you can simply specialize like this (if it solves your problem),</p>\n<pre><code>template&lt;class T&gt; struct Foo&lt;T,Bar::Special&gt; {};\n\n//usage\nFoo&lt;Bar, Bar::Special&gt; f;\n</code></pre>\n</hr>", "LastActivityDate": "2010-12-28T07:25:22.380", "LastEditorUserId": "-1", "Id": "4543880", "CommentCount": "4", "CreationDate": "2010-12-28T05:28:59.037", "ParentId": "4543720", "Score": "16", "OwnerUserId": "415784", "LastEditDate": "2017-05-23T12:15:07.893"}});