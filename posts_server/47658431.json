post_cb({"bq_ids": {"n4140": {"so_47658431_47676430_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 3321}, "so_47658431_47658607_0": {"length": 13, "quality": 1.0, "section_id": 639}, "so_47658431_47658607_2": {"length": 18, "quality": 1.0, "section_id": 639}}, "n3337": {"so_47658431_47676430_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 3191}, "so_47658431_47658607_0": {"length": 13, "quality": 1.0, "section_id": 629}, "so_47658431_47658607_2": {"length": 18, "quality": 1.0, "section_id": 629}}, "n4659": {"so_47658431_47676430_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 4087}, "so_47658431_47658607_0": {"length": 13, "quality": 1.0, "section_id": 667}, "so_47658431_47658607_2": {"length": 18, "quality": 1.0, "section_id": 667}}}, "47659581": {"Id": "47659581", "PostTypeId": "2", "Body": "<p>clang++ is more accurate. Both <code>func</code> overloads are not exact matches for <code>StringDecorator const&amp;</code> or <code>StringDecorator&amp;&amp;</code>. Thus <code>my_string</code> can not be moved. The compiler can not choose between possible transforms <code>StringDecorator&amp;&amp;</code> --&gt; <code>std::string&amp;&amp;</code> --&gt; <code>func(std::string&amp;&amp;)</code> and <code>StringDecorator&amp;&amp;</code> -&gt; <code>StringDecorator&amp;</code> --&gt; <code>std::string&amp;</code> --&gt; <code>func(const std::string&amp;)</code>. In other words the compiler can not determine on what step it should apply cast operator.</p>\n<p>I do not have g++ installed to check my assumption. I guess it goes to the second way, since <code>my_string</code> can not be moved, it applies the cast operator <code>const&amp;</code> to <code>StringDecorator&amp;</code>. You can check it if you add debug output into bodies of cast operators.</p>\n", "LastEditorUserId": "6752050", "LastActivityDate": "2017-12-05T17:50:22.560", "Score": "1", "CreationDate": "2017-12-05T17:41:29.927", "ParentId": "47658431", "CommentCount": "2", "OwnerUserId": "6752050", "LastEditDate": "2017-12-05T17:50:22.560"}, "47658431": {"ViewCount": "222", "Body": "<p>I've been developing a kind of adapter class, when I encountered a problem under clang. When both conversion operators for lvalue-reference and rvalue reference are defined you get an ambiguity compilation error trying to move from your class (when such code should be fine, as </p>\n<pre><code>operator const T&amp; () const&amp;\n</code></pre>\n<p>is allowed only for lvalues AFAIK). I've reproduced error with simple example:</p>\n<pre><code>#include &lt;string&gt;\n\nclass StringDecorator\n{\npublic:\n  StringDecorator()\n  : m_string( \"String data here\" )\n  {}\n\n  operator const std::string&amp; () const&amp; // lvalue only\n  {\n    return m_string;\n  }\n\n  operator std::string&amp;&amp; () &amp;&amp; // rvalue only\n  {\n    return std::move( m_string );\n  }\n\nprivate:\n    std::string m_string;\n};\n\nvoid func( const std::string&amp; ) {}\nvoid func( std::string&amp;&amp; ) {}\n\nint main(int argc, char** argv)\n{\n  StringDecorator my_string;\n\n  func( my_string ); // fine, operator std::string&amp;&amp; not allowed\n  func( std::move( my_string ) ); // error \"ambiguous function call\"\n}\n</code></pre>\n<p>Compiles fine on gcc 4.9+, fails on any clang version.\nSo the question: is there any workaround? Is my understanding of <em>const&amp;</em> function modifier right?</p>\n<p>P.S.: To clarify - the question is about fixing StringDecorator class itself (or finding the workaround for such class as if were a library code). Please refrain providing answers that call operator T&amp;&amp;() directly or specify conversion type explicitly.</p>\n", "AcceptedAnswerId": "47658607", "Title": "Clang ambiguity with custom conversion operator", "CreationDate": "2017-12-05T16:35:55.177", "LastActivityDate": "2018-02-08T21:36:09.967", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-12-05T17:14:31.260", "LastEditorUserId": "445713", "Id": "47658431", "Score": "5", "OwnerUserId": "445713", "Tags": "<c++><c++11><decorator><move>", "AnswerCount": "3"}, "47658607": {"Id": "47658607", "PostTypeId": "2", "Body": "<p>The problem comes from the selection of the best viable function. In the case of the second <code>func</code> call, it implies the comparison of 2 <em>user-defined conversion sequence</em>. Unfortunately, 2 <em>user-defined conversion sequence</em> are <em>undistinguishable</em> if they do not use the same user-defined conversion function or constructor <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4700.pdf\" rel=\"nofollow noreferrer\">C++ standard</a> [over.ics.rank/3]:</p>\n<blockquote>\n<p id=\"so_47658431_47658607_0\">Two implicit conversion sequences of the same form are indistinguishable conversion sequences unless one of\n  the following rules applies: </p>\n<ul>\n<li><p id=\"so_47658431_47658607_1\">[...]</p></li>\n<li><p id=\"so_47658431_47658607_2\">User-defined conversion sequence\n  U1\n  is a better conversion sequence than another user-defined conversion\n  sequence\n  U2\n  if they contain the same user-defined conversion function or constructor [...]</p></li>\n</ul>\n</blockquote>\n<p>Because a rvalue can always bind to a const lvalue reference, you will in any case fall on this ambiguous call if a function is overloaded for <code>const std::string&amp;</code> and <code>std::string&amp;&amp;</code>.</p>\n<p>As you mentioned it, my first answer consisting in redeclaring all functions is not a solution as you are implementing a library. Indeed it is not possible to define proxy-functions for all functions taking a <code>string</code> as argument!!</p>\n<p>So that let you with a trade off between 2 imperfect solutions:</p>\n<ol>\n<li><p>You remove <code>operator std::string&amp;&amp;() &amp;&amp;</code>, and you will loose some optimization, or;</p></li>\n<li><p>You publicly inherit from std::string, and remove the 2 conversion functions, in which case you expose your library to misuses:</p>\n<pre><code>#include &lt;string&gt;\n\nclass StringDecorator\n  : public std::string\n{\npublic:\n  StringDecorator()\n  : std::string(\"String data here\" )\n  {}\n};\n\nvoid func( const std::string&amp; ) {}\nvoid func( std::string&amp;&amp; ) {}\n\nint main(int argc, char** argv)\n{\n  StringDecorator my_string;\n\n  func( my_string ); // fine, operator std::string&amp;&amp; not allowed\n  func( std::move( my_string  )); // No more bug:\n    //ranking of standard conversion sequence is fine-grained.\n}\n</code></pre></li>\n</ol>\n<hr>\n<p>An other solution is not to use Clang because it is a <a href=\"https://stackoverflow.com/questions/47712965/understanding-overload-resolution-ranking-involving-user-defined-conversion\">bug of Clang</a>.</p>\n<p>But if you have to use Clang, the Tony Frolov answer is the solution.</p>\n</hr>", "LastEditorUserId": "3552770", "LastActivityDate": "2018-02-08T21:36:09.967", "Score": "3", "CreationDate": "2017-12-05T16:45:57.450", "ParentId": "47658431", "CommentCount": "4", "OwnerUserId": "5632316", "LastEditDate": "2018-02-08T21:36:09.967"}, "47676430": {"Id": "47676430", "PostTypeId": "2", "Body": "<p>Oliv answer is correct, as standard seems to be quite clear in this case. The solution I've chosen at a time was to leave only one conversion operator:</p>\n<pre><code>operator const std::string&amp; () const&amp;\n</code></pre>\n<p>The problem exists because both conversion operators are considered viable. So this can be avoided by changing type of implicit argument of lvalue conversion operator from <strong>const&amp;</strong> to <strong>&amp;</strong>:</p>\n<pre><code>operator const std::string&amp; () &amp; // lvalue only (rvalue can't bind to non-const reference)\n{\n    return m_string;\n}\n\noperator std::string&amp;&amp; () &amp;&amp; // rvalue only\n{\n    return std::move( m_string );\n}\n</code></pre>\n<p>But this breaks conversion from <strong>const StringDecorator</strong>, making its usage awkward in typical cases. </p>\n<p>This broken solution led me thinking if there is a way to specify member function qualifier that will make conversion operator viable with const lvalue object, but not with the rvalue. And I've managed to achieve this by specifying implicit argument for const conversion operator as <strong>const volatile&amp;</strong>:</p>\n<pre><code>operator const std::string&amp; () const volatile&amp; // lvalue only (rvalue can't bind to volatile reference)\n{\n    return const_cast&lt; const StringDecorator* &gt;( this )-&gt;m_string;\n}\n\noperator std::string&amp;&amp; () &amp;&amp; // rvalue only\n{\n    return std::move( m_string );\n}\n</code></pre>\n<blockquote>\n<p id=\"so_47658431_47676430_0\">Per <strong>[dcl.init.ref]/5</strong>, for a reference to be initialized by binding to\n  an rvalue, the reference must be a const non-volatile lvalue\n  reference, or an rvalue reference:</p>\n</blockquote>\n<p>While lvalue reference and const lvalue reference can bind to const volatile reference. Obviously volatile modifier on member function serves completely different thing. But hey, it works and sufficient for my use-case. The only remaining problem is that code becomes misleading and astonishing.</p>\n", "LastEditorUserId": "445713", "LastActivityDate": "2017-12-09T22:03:32.857", "Score": "2", "CreationDate": "2017-12-06T14:17:08.250", "ParentId": "47658431", "CommentCount": "1", "OwnerUserId": "445713", "LastEditDate": "2017-12-09T22:03:32.857"}});