post_cb({"40329327": {"ParentId": "40329101", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2016-10-30T12:54:06.827", "Score": "0", "LastEditorUserId": "2380830", "LastEditDate": "2016-10-30T13:00:56.083", "Id": "40329327", "OwnerUserId": "2380830", "Body": "<p>It's hard to say and there is, I think, no hard and fast rule that defines a type that's consistent for all platforms. There's no standard library typedef for such an expression.</p>\n<p>If you're using C++, consider using auto to declare such a type, and std::cout to print a value of such a type: rely on the compiler to choose the appropriate overload for &lt;&lt;.</p>\n", "LastActivityDate": "2016-10-30T13:00:56.083"}, "40329101": {"CommentCount": "0", "AcceptedAnswerId": "40329102", "CreationDate": "2016-10-30T12:33:25.313", "LastActivityDate": "2016-10-30T22:51:19.963", "PostTypeId": "1", "ViewCount": "82", "FavoriteCount": "1", "Title": "What is the type of (ptr - A[0]) / (sizeof(A[0]) / sizeof(A[0][0]))?", "Id": "40329101", "Score": "4", "Body": "<p>I have a 2D array <code>A</code> and a pointer <code>ptr</code> pointing somewhere inside it.  I know how to compute the row number but the actual type of the expression seems non-portable:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int A[100][100];\n    int *ptr = &amp;A[42][24];\n\n    printf(\"row number is %d\\n\", (ptr - A[0]) / (sizeof(A[0]) / sizeof(A[0][0])));\n    printf(\"col number is %d\\n\", (ptr - A[0]) % (sizeof(A[0]) / sizeof(A[0][0])));\n    return 0;\n}\n</code></pre>\n<p>On OS/X, the <code>clang</code> compiler complains this way:</p>\n<pre><code>warning: format specifies type 'int' but the argument has type 'unsigned long' [-Wformat]\n</code></pre>\n<p>On Linux, <code>gcc</code> gives a similar warning, but on Windows, I get a different diagnostic:</p>\n<pre><code>warning: format specifies type 'int' but the argument has type 'unsigned long long' [-Wformat]\n</code></pre>\n<p>What is the actual type of this expression?</p>\n<p>Is there a way to pass the expression to <code>printf</code> without an ugly cast?</p>\n", "Tags": "<c++><c><arrays><printf>", "OwnerUserId": "4593267", "AnswerCount": "2"}, "40329102": {"ParentId": "40329101", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2016-10-30T12:33:25.313", "Score": "7", "LastEditorUserId": "4593267", "LastEditDate": "2016-10-30T22:51:19.963", "Id": "40329102", "OwnerUserId": "4593267", "Body": "<p>The difference of 2 pointers has type <code>ptrdiff_t</code>, a signed integer type defined in <code>&lt;stddef.h&gt;</code>.  The <code>printf</code> length modifier for this type is <code>t</code>. The difference of 2 pointers can be printed directly with:</p>\n<pre><code>printf(\"pointer difference: %td\\n\", ptr - A[42]);\n</code></pre>\n<p>The size of the subarray dimension <code>(sizeof(A[0]) / sizeof(A[0][0]))</code> is <code>size_t</code>, the unsigned type f the result of the <code>sizeof</code> operator defined in <code>&lt;stddef.h&gt;</code>.</p>\n<p>The <code>printf</code> length modifier for this type is <code>z</code>. The size of an object can be printed directly with:</p>\n<pre><code>printf(\"array size in bytes: %zu\\n\", sizeof(A));\n</code></pre>\n<p><code>ptrdiff_t</code> is required by the C standard to be able to represent values between <code>-65535</code> and <code>65535</code> at least, while <code>size_t</code> must have a range of at least <code>0</code> to <code>65535</code>.</p>\n<p>The question is: what is the type of the division of a <code>ptrdiff_t</code> by a <code>size_t</code>?</p>\n<p>The type is determined by applying the arithmetic conversions as specified in <strong>6.3.1.8 Usual arithmetic conversions</strong>:</p>\n<blockquote>\n<p id=\"so_40329101_40329102_0\">Otherwise (if both operands have integer types), the integer promotions are performed on both operands. Then the following rules are applied to the promoted operands:</p>\n<ul>\n<li><p id=\"so_40329101_40329102_1\">If both operands have the same type, then no further conversion is needed.\n  Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type of lesser integer conversion rank is converted to the type of the operand with greater rank.</p></li>\n<li><p id=\"so_40329101_40329102_2\">Otherwise, if the operand that has unsigned integer type has rank greater or equal to the rank of the type of the other operand, then the operand with signed integer type is converted to the type of the operand with unsigned integer type.</p></li>\n<li><p id=\"so_40329101_40329102_3\">Otherwise, if the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, then the operand with unsigned integer type is converted to the type of the operand with signed integer type.</p></li>\n<li><p id=\"so_40329101_40329102_4\">Otherwise, both operands are converted to the unsigned integer type corresponding to the type of the operand with signed integer type.</p></li>\n</ul>\n</blockquote>\n<p>Depending on the actual types used for <code>ptrdiff_t</code> and <code>size_t</code>, the type of the result can be different:</p>\n<p><em>Integer promotion</em> works this way: if type <code>int</code> can represent all values of its type, it is converted to <code>int</code>, if <code>unsigned</code> does, it is converted to <code>unsigned</code>, otherwise the type is unchanged.</p>\n<p>Hence if <code>size_t</code> is smaller than <code>int</code>, <code>size_t</code> gets promoted to <code>int</code>, a signed type, and the division is performed as a signed division, both operands are first converted to the larger type of <code>int</code> and <code>ptrdiff_t</code> (very likely to be <code>int</code> as well in this case).</p>\n<p>If <code>size_t</code> is type <code>unsigned int</code> and <code>ptrdiff_t</code> is type <code>int</code>, the <code>ptrdiff_t</code> is converted to <code>unsigned int</code> and the division is performed as an unsigned division with a result type <code>unsigned int</code>.</p>\n<p>Conversely, if <code>size_t</code> is <code>unsigned int</code> and <code>ptrdiff_t</code> is type <code>long int</code>, the <code>size_t</code> operand is converted to type <code>long int</code>, the division is then a signed division and the resulting type is <code>long int</code>.</p>\n<p>If <code>size_t</code> is <code>unsigned long int</code> and <code>ptrdiff_t</code> is type <code>long int</code> (Linux and OS/X 64-bit), the <code>ptrdiff_t</code> is converted to <code>unsigned long int</code> and the division is an unsigned division with resulting type <code>unsigned long int</code>.</p>\n<p>If <code>size_t</code> is <code>unsigned long long int</code> and <code>ptrdiff_t</code> is type <code>long long int</code> (Windows 64-bit), the <code>ptrdiff_t</code> is converted to <code>unsigned long long int</code> and the division is an unsigned division with resulting type <code>unsigned long long int</code>.</p>\n<p>More exotic architectures might have other combinations for types <code>size_t</code> and <code>ptrdiff_t</code>, resulting in more possibilities for the resulting type, such as <code>long long int</code>.</p>\n<p>As a consequence, the type of the row computation is implementation defined: it can be signed or unsigned and different from both <code>size_t</code> and <code>ptrdiff_t</code>.</p>\n<p>There are multiple ways to produce a consistent type and format for the printf statement:</p>\n<p>Using a cast:</p>\n<pre><code>printf(\"row number is %d\\n\", (int)((ptr - A[0]) / (sizeof(A[0]) / sizeof(A[0][0]))));\n</code></pre>\n<p>Using an intermediary variable:</p>\n<pre><code>int row = (ptr - A[0]) / (sizeof(A[0]) / sizeof(A[0][0])));\nprintf(\"row number is %d\\n\", row);\n</code></pre>\n<p>Using an extra operation to force a larger type (not perfect as <code>size_t</code> could be larger than <code>unsigned long long</code>):</p>\n<pre><code>printf(\"row number is %llu\\n\", 0ULL + (ptr - A[0]) / (sizeof(A[0]) / sizeof(A[0][0])));\n</code></pre>\n<p>Note that the <code>printf</code> formats <code>%zu</code> for <code>size_t</code> and <code>%td</code> for <code>ptrdiff_t</code> cannot be used since the type of the expression is not necessarily <code>size_t</code> not <code>ptrdiff_t</code>.  To make matters worse for Windows users, these standard length specifiers are not supported by the Microsoft C runtime library.  As suggested by Jean-Fran\u00e7ois Fabre, there is a work-around for MingW users who compile C code with <code>gcc</code> and generate native Windows applications: specifying <code>-D__USE_MINGW_ANSI_STDIO</code> on the command line tells <code>gcc</code> to use its own version of <code>printf</code> instead of that of the Microsoft runtime.</p>\n<hr>\n<p>Final note: the expression <code>ptr - A[0]</code> actually invokes undefined behavior if <code>ptr</code> does not point inside the first row of the array, as specified in <strong>6.5.6 Additive operators</strong>:</p>\n<blockquote id=\"so_40329101_40329102_5\">\n<ol start=\"9\">\n<li>When two pointers are subtracted, both shall point to elements of the same array object, or one past the last element of the array object; the result is the difference of the subscripts of the two array elements.</li>\n</ol>\n</blockquote>\n</hr>", "LastActivityDate": "2016-10-30T22:51:19.963"}, "bq_ids": {"n4140": {"so_40329101_40329102_1": {"section_id": 5943, "quality": 0.96875, "length": 31}, "so_40329101_40329102_5": {"section_id": 6143, "quality": 0.7272727272727273, "length": 16}, "so_40329101_40329102_0": {"section_id": 5943, "quality": 0.6470588235294118, "length": 11}, "so_40329101_40329102_4": {"section_id": 5943, "quality": 1.0, "length": 13}, "so_40329101_40329102_2": {"section_id": 5943, "quality": 0.9565217391304348, "length": 22}, "so_40329101_40329102_3": {"section_id": 5943, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_40329101_40329102_1": {"section_id": 5714, "quality": 0.96875, "length": 31}, "so_40329101_40329102_5": {"section_id": 5907, "quality": 0.7272727272727273, "length": 16}, "so_40329101_40329102_0": {"section_id": 5714, "quality": 0.6470588235294118, "length": 11}, "so_40329101_40329102_4": {"section_id": 5714, "quality": 1.0, "length": 13}, "so_40329101_40329102_2": {"section_id": 5714, "quality": 0.9565217391304348, "length": 22}, "so_40329101_40329102_3": {"section_id": 5714, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_40329101_40329102_1": {"section_id": 7428, "quality": 0.96875, "length": 31}, "so_40329101_40329102_4": {"section_id": 7428, "quality": 1.0, "length": 13}, "so_40329101_40329102_0": {"section_id": 7428, "quality": 0.6470588235294118, "length": 11}, "so_40329101_40329102_2": {"section_id": 7428, "quality": 0.9565217391304348, "length": 22}, "so_40329101_40329102_3": {"section_id": 7428, "quality": 0.9615384615384616, "length": 25}}}});