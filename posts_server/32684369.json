post_cb({"bq_ids": {"n4140": {"so_32684369_32684432_4": {"length": 18, "quality": 0.6, "section_id": 30}, "so_32684369_32684432_3": {"length": 38, "quality": 0.7169811320754716, "section_id": 21}, "so_32684369_32684463_0": {"length": 12, "quality": 1.0, "section_id": 6175}, "so_32684369_32684432_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 6160}, "so_32684369_32684432_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 6146}, "so_32684369_32684432_5": {"length": 22, "quality": 0.9166666666666666, "section_id": 37}, "so_32684369_32684432_0": {"length": 40, "quality": 0.975609756097561, "section_id": 44}}, "n3337": {"so_32684369_32684432_4": {"length": 18, "quality": 0.6, "section_id": 27}, "so_32684369_32684432_3": {"length": 38, "quality": 0.7169811320754716, "section_id": 18}, "so_32684369_32684463_0": {"length": 12, "quality": 1.0, "section_id": 5936}, "so_32684369_32684432_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 5921}, "so_32684369_32684432_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 5909}, "so_32684369_32684432_5": {"length": 22, "quality": 0.9166666666666666, "section_id": 34}, "so_32684369_32684432_0": {"length": 39, "quality": 0.9512195121951219, "section_id": 41}}, "n4659": {"so_32684369_32684432_4": {"length": 18, "quality": 0.6, "section_id": 30}, "so_32684369_32684432_3": {"length": 38, "quality": 0.7169811320754716, "section_id": 21}, "so_32684369_32684463_0": {"length": 12, "quality": 1.0, "section_id": 7677}, "so_32684369_32684432_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 7657}, "so_32684369_32684432_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 7642}, "so_32684369_32684432_5": {"length": 20, "quality": 0.8333333333333334, "section_id": 37}, "so_32684369_32684432_0": {"length": 40, "quality": 0.975609756097561, "section_id": 45}}}, "32684432": {"Id": "32684432", "PostTypeId": "2", "Body": "<p>The relevant conversion in all of these cases is a Boolean conversion, [conv.bool]:</p>\n<blockquote>\n<p id=\"so_32684369_32684432_0\">A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a\n  prvalue of type <code>bool</code>. A zero value, null pointer value, or null member pointer value is converted to <code>false</code>;\n  any other value is converted to <code>true</code>. For direct-initialization (8.5), a prvalue of type <code>std::nullptr_t</code> can\n  be converted to a prvalue of type <code>bool</code>; the resulting value is <code>false</code>.</p>\n</blockquote>\n<p>With two exceptions:</p>\n<pre><code>b &amp;= f;\nb &lt;&lt;= f;\n</code></pre>\n<p>The former, because of [expr.bit.and]:</p>\n<blockquote>\n<p id=\"so_32684369_32684432_1\">The usual arithmetic conversions are performed; the result is the bitwise AND function of the operands. The\n  operator <strong>applies only to integral or unscoped enumeration operands</strong>.</p>\n</blockquote>\n<p>and the latter, because of [expr.shift]:</p>\n<blockquote>\n<p id=\"so_32684369_32684432_2\">The operands <strong>shall be of integral or unscoped enumeration type</strong> and integral promotions are performed.</p>\n</blockquote>\n<p>Since <code>float</code> is neither integral nor of unscoped enumeration type, those two operations are invalid. </p>\n<hr/>\n<p>In the case of your (and I'm renaming your class here):</p>\n<pre><code>class Bool {Bool&amp; operator op=(int x) noexcept;}; // op &lt;=&gt; +,-,&amp;,|...\n</code></pre>\n<p>we would instead fall into one of three conversions, depending on the types. For <code>char</code> or <code>bool</code>, we do an Integral Promotion, [conv.prom]:</p>\n<blockquote>\n<p id=\"so_32684369_32684432_3\">A prvalue of an integer type other than <code>bool</code>, <code>char16_t</code>, <code>char32_t</code>, or <code>wchar_t</code> whose integer conversion\n  rank (4.13) is less than the rank of int can be converted to a prvalue of type int if <code>int</code> can represent all\n  the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type <code>unsigned\n  int</code>.<br>\n  [...]<br>\n  A prvalue of type <code>bool</code> can be converted to a prvalue of type <code>int</code>, with <code>false</code> becoming zero and <code>true</code>\n  becoming one.</br></br></p>\n</blockquote>\n<p>For the other integral types, Integral Conversion, from [conv.integral]:</p>\n<blockquote>\n<p id=\"so_32684369_32684432_4\">A prvalue of an integer type can be converted to a prvalue of another integer type. A prvalue of an unscoped\n  enumeration type can be converted to a prvalue of an integer type.<br>\n  [...]<br>\n  If the destination type is signed, the value is unchanged if it can be represented in the destination type;\n  otherwise, the value is implementation-defined.</br></br></p>\n</blockquote>\n<p>And for <code>float</code>, a Floating-Integral Conversion, from [conv.fpint]:</p>\n<blockquote>\n<p id=\"so_32684369_32684432_5\">A prvalue of a floating point type can be converted to a prvalue of an integer type. The conversion truncates;\n  that is, the fractional part is discarded. The behavior is undefined if the truncated value cannot be\n  represented in the destination type.</p>\n</blockquote>\n", "LastActivityDate": "2015-09-20T21:20:37.463", "CommentCount": "0", "CreationDate": "2015-09-20T21:20:37.463", "ParentId": "32684369", "Score": "1", "OwnerUserId": "2069064"}, "32684369": {"ViewCount": "72", "Body": "<p>I would like to understand what happens in the following cases :</p>\n<pre><code>bool b = false;\nfloat f = 3.14;\nchar c = 1;\nint i = 2;\nunsigned int u = 3;\nlong long int ll = 4;\nunsigned long long int ull = 5;\n\nb += f;\nb += c;\nb += i;\nb += u;\nb += ll;\nb += ull;\n\nb &amp;= f;\nb &amp;= c;\nb &amp;= i;\nb &amp;= u;\nb &amp;= ll;\nb &amp;= ull;\n\nb &lt;&lt;= f;\nb &lt;&lt;= c;\nb &lt;&lt;= i;\nb &lt;&lt;= u;\nb &lt;&lt;= ll;\nb &lt;&lt;= ull;\n</code></pre>\n<p>Or in other words, what are the implicit conversions that are done according to the standard?</p>\n<p>Other questions: would the result be the same, if the only provided signature of compound assignment for an hypothetical <code>bool</code> class would be of the form:</p>\n<pre><code>class bool {bool&amp; operator op=(int x) noexcept;}; // op &lt;=&gt; +,-,&amp;,|...\n</code></pre>\n", "AcceptedAnswerId": "32684432", "Title": "Implicit conversions in boolean compound assignment?", "CreationDate": "2015-09-20T21:13:58.263", "Id": "32684369", "CommentCount": "0", "LastEditDate": "2015-09-20T21:17:45.120", "PostTypeId": "1", "LastEditorUserId": "1413395", "LastActivityDate": "2015-09-20T21:36:08.697", "Score": "2", "OwnerUserId": "882932", "Tags": "<c++><boolean><language-lawyer><implicit-conversion>", "AnswerCount": "2"}, "32684463": {"Id": "32684463", "PostTypeId": "2", "Body": "<p>For compound assignment expressions, the right operand is first converted to the left operand's type (C++14 5.17 p3):</p>\n<blockquote>\n<p id=\"so_32684369_32684463_0\">If the left operand is not of class type, the expression is implicitly converted (Clause 4) to the cv-unqualified type of the left operand.</p>\n</blockquote>\n<p>Because of this, the equivalent hypothetical operator should take a bool parameter:</p>\n<pre><code>class bool {bool&amp; operator op=(bool x) noexcept;};\n</code></pre>\n<p>Here's an example where it would make a difference if you used <code>int</code> instead:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Bool {\n  bool value;\n\n  Bool(bool value) : value(value) { }\n  Bool &amp;operator += (int x) noexcept { value += x; return *this; }\n};\n\nint main()\n{\n  Bool fake_bool = false;\n  bool real_bool = false;\n\n  fake_bool += 0.1;\n  real_bool += 0.1;\n  std::cout &lt;&lt; fake_bool.value &lt;&lt; \"\\n\";\n  std::cout &lt;&lt; real_bool &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>outputs</p>\n<pre><code>0\n1\n</code></pre>\n", "LastEditorUserId": "951890", "LastActivityDate": "2015-09-20T21:36:08.697", "Score": "0", "CreationDate": "2015-09-20T21:23:52.717", "ParentId": "32684369", "CommentCount": "0", "OwnerUserId": "951890", "LastEditDate": "2015-09-20T21:36:08.697"}});