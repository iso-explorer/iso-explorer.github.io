post_cb({"bq_ids": {"n4140": {"so_27453230_27453649_1": {"length": 11, "quality": 1.0, "section_id": 712}, "so_27453230_27453230_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 712}, "so_27453230_27453649_0": {"length": 8, "quality": 1.0, "section_id": 818}, "so_27453230_27453230_1": {"length": 55, "quality": 0.9821428571428571, "section_id": 986}, "so_27453230_27453230_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 987}}, "n3337": {"so_27453230_27453649_1": {"length": 11, "quality": 1.0, "section_id": 701}, "so_27453230_27453230_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 701}, "so_27453230_27453649_0": {"length": 8, "quality": 1.0, "section_id": 807}, "so_27453230_27453230_1": {"length": 42, "quality": 0.75, "section_id": 971}, "so_27453230_27453230_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 972}}, "n4659": {"so_27453230_27453649_1": {"length": 11, "quality": 1.0, "section_id": 741}, "so_27453230_27453230_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 741}, "so_27453230_27453649_0": {"length": 8, "quality": 1.0, "section_id": 877}, "so_27453230_27453230_1": {"length": 54, "quality": 0.9642857142857143, "section_id": 1049}, "so_27453230_27453230_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 1050}}}, "27453649": {"Id": "27453649", "PostTypeId": "2", "Body": "<p>As far as my interpretation of the standard goes, here \"Unless otherwise specified\" means that once anything regarding exceptions is specified for <code>insert</code> in a corresponding clause for a particular container, the bullet point of the list in \u00a723.2.1 is not applying anymore.</p>\n<blockquote>\n<p id=\"so_27453230_27453649_0\">If an exception is thrown <strong>other than by the copy constructor</strong> [..]\n  of <code>T</code> [..] there are no effects.</p>\n</blockquote>\n<p>The opposite is indicated: When an exception is thrown by the copy constructor of <code>T</code> there is no guarantee that the call won't have any effects. The requirement that </p>\n<blockquote>\n<p id=\"so_27453230_27453649_1\">if an exception is thrown by an <code>insert()</code> or <code>emplace()</code> function while inserting a single element, that function has no effects</p>\n</blockquote>\n<p>is not applicable: \u00a723.3.6.5 specifies \"otherwise\".</p>\n", "LastActivityDate": "2014-12-12T23:19:54.577", "CommentCount": "10", "CreationDate": "2014-12-12T23:19:54.577", "ParentId": "27453230", "Score": "8", "OwnerUserId": "3647361"}, "27453230": {"ViewCount": "202", "Body": "<p>Firstly, assume <code>A</code> is a type with:</p>\n<ul>\n<li>A potentially throwing copy constructor/assignment operator.</li>\n<li>No move constructor/assignment.</li>\n</ul>\n<p>This is a common example of a C++03 RAII type. Now let me cite the C++14 standard (snipped irrelevant parts):</p>\n<blockquote>\n<h3>\u00a723.2.1 General container requirements</h3>\n<p id=\"so_27453230_27453230_0\"><sup>11</sup> Unless otherwise specified (see ... and 23.3.6.5) all container types defined in this\n  Clause meet the following additional requirements:</p>\n<ul>\n<li>if an exception is thrown by an <code>insert()</code> or <code>emplace()</code> function while inserting a single element, that function has no effects.</li>\n</ul>\n<h3>\u00a723.3.6.5  <code>vector</code> modifiers</h3>\n<pre><code>iterator insert(const_iterator position, const T&amp; x);\n...\n</code></pre>\n<p id=\"so_27453230_27453230_1\"><sup>1</sup> <em>Remarks:</em> Causes reallocation if the new size is greater than the old capacity. If no reallocation happens, all the iterators and references before the insertion point remain valid. If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of <code>T</code> or by any <code>InputIterator</code> operation there are no effects. If an exception is thrown while inserting a single element at the end and <code>T</code> is <code>CopyInsertable</code> or <code>is_nothrow_move_constructible&lt;T&gt;::value</code> is <code>true</code>, there are no effects. Otherwise, if an exception is thrown by the move constructor of a non-<code>CopyInsertable</code> <code>T</code>, the effects are unspecified.</p>\n<p id=\"so_27453230_27453230_2\"><sup>2</sup> <em>Complexity:</em> The complexity is linear in the number of elements inserted plus the distance to the end\n  of the vector.</p>\n</blockquote>\n<p>Now consider this:</p>\n<pre><code>std::vector&lt;A&gt; v(5);\nv.reserve(10);\nv.insert(begin() + 2, A());\n</code></pre>\n<p>Clearly we're inserting a single element, so \u00a723.2.1 - 11 applies and either the operation succeeds or <code>v</code> is unchanged. \u00a723.3.6.5 doesn't change anything about this. The exception is thrown by the copy constructor. We are not inserting at the end. The move constructor is not used.</p>\n<p>But now consider this possible scenario during the implementation of insert <strong>assuming no reallocation happens</strong>:</p>\n<pre class=\"lang-none prettyprint-override\"><code>01234_____ initial state\n0123_4____ making space by copying\n012_34____ continued\n012?34____ continued, but copy operation threw\n</code></pre>\n<p>At this point all future copy operations could throw, making it impossible to restore the state as required. Oops.</p>\n<p>I can't see any implementation without reallocation that enables strong exception safety. This means that any implementation must always reallocate when inserting a type without a move constructor and a throwing copy constructor in the middle. However:</p>\n<ol>\n<li><code>insert(pos, value)</code> becomes unbearably slow due to constant reallocations.</li>\n<li>The complexity requirement isn't met (reallocation always requires <code>n</code> operations).</li>\n<li><p>It could be argued that <em>\"Causes reallocation if the new size is greater than the old capacity.\"</em> implies that no reallocation is allowed if the new size is not greater than the old capacity.</p>\n<p>To support this, consider that if an implementation may reallocate anytime, the user has no way of knowing. This makes the guarantee about preserving iterators (<em>\"If no reallocation happens, all the iterators and references before the insertion point remain valid.\"</em>) useless information, and makes you wonder why both sentences were inserted into the standard in the first place.</p></li>\n</ol>\n<p>1 &amp; 2 are pretty damning observations, but if 3 is true then it's (as far as I can see) plain impossible to be compliant with the standard.</p>\n<p>So, is there any way of implementing the insert method for a standards-compliant vector? Or is this a standard defect?</p>\n<hr>\n<p>A demonstration of this issue can be seen here: <a href=\"http://coliru.stacked-crooked.com/a/afd2e838c34c8fcc\">http://coliru.stacked-crooked.com/a/afd2e838c34c8fcc</a></p>\n</hr>", "AcceptedAnswerId": "27453649", "Title": "Is there any way of implementing the insert method for a standards-compliant vector?", "CreationDate": "2014-12-12T22:40:51.377", "Id": "27453230", "CommentCount": "6", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-12-12T23:09:14.480", "LastEditorUserId": "565635", "LastActivityDate": "2014-12-12T23:19:54.577", "Score": "17", "OwnerUserId": "565635", "Tags": "<c++><language-lawyer>", "AnswerCount": "1"}});