post_cb({"27229578": {"ViewCount": "1573", "Body": "<p>This is a tangential follow up to my previous question <a href=\"https://stackoverflow.com/q/27226680/3920237\">The address of a function matching a bool vs const void* overload</a>. The answerer explained:</p>\n<blockquote>\n<p id=\"so_27229578_27229578_0\">The [C++11] standard does not define any standard conversions from a\n  \"pointer to function\" to a \"pointer to <code>void</code>.\"</p>\n<p id=\"so_27229578_27229578_1\">It's hard to provide a quote for the <em>absence</em> of something, but the\n  closest I can do is C++11 4.10/2 [conv.ptr]:</p>\n<blockquote>\n<p id=\"so_27229578_27229578_4\">A prvalue of type \u201cpointer to <em>cv</em> <code>T</code>,\u201d <strong>where <code>T</code> is an object type</strong>, can be converted to a prvalue of type \u201cpointer to <em>cv</em>\n<code>void</code>\u201d. The result of converting a \u201cpointer to <em>cv</em> <code>T</code>\u201d to a\n    \u201cpointer to <em>cv</em> <code>void</code>\u201d points to the start of the storage location\n    where the object of type <code>T</code> resides, as if the object is a most\n    derived object (1.8) of type T (that is, not a base class subobject).\n    The null pointer value is converted to the null pointer value of the\n    destination type.</p>\n</blockquote>\n<p id=\"so_27229578_27229578_3\">(emphasis mine)</p>\n</blockquote>\n<p>Assuming <code>func</code> is declared <code>void func();</code>, if you do a C-style cast, i.e. <code>(void*) func</code>, the cast will be successful. <code>static_cast&lt;void*&gt;(func)</code> however is invalid, but <code>reinterpret_cast&lt;void*&gt;(func)</code> will be successful. What you cannot do however is convert the subsequently converted pointer back to its original type. For example,</p>\n<p>Fine:</p>\n<pre><code>int main() {\n  int* i;\n  void* s = static_cast&lt;void*&gt;(i);\n  i = static_cast&lt;int*&gt;(s);\n  s = reinterpret_cast&lt;void*&gt;(i);\n  i = reinterpret_cast&lt;int*&gt;(s);\n}\n</code></pre>\n<p>Not fine:</p>\n<pre><code>void func() { }\n\nint main() {\n  void* s = reinterpret_cast&lt;void*&gt;(func);\n  reinterpret_cast&lt;decltype(func)&gt;(s);\n}\n</code></pre>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">N3337</a> starts off by saying,</p>\n<p>[expr.reinterpret.cast]</p>\n<blockquote>\n<p id=\"so_27229578_27229578_5\">The result of the expression <code>reinterpret_cast&lt;T&gt;(v)</code> is the result of\n  converting the expression <code>v</code> to type <code>T</code>. If <code>T</code> is an lvalue\n  reference type or an rvalue reference to function type, the result is\n  an lvalue; if <code>T</code> is an rvalue reference to object type, the result is\n  an xvalue; otherwise, the result is a prvalue and the lvalue-to-rvalue\n  (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard\n  conversions are performed on the expression v. <strong>Conversions that can be\n  performed explicitly using <code>reinterpret_cast</code> are listed below. No\n  other conversion can be performed explicitly using <code>reinterpret_cast</code>.</strong></p>\n</blockquote>\n<p>I bolded the language that I believe is key here. The last part seems to imply that if the conversion is not listed, it's illegal. In brief summary, the allowed conversions are:</p>\n<ul>\n<li>A pointer can be explicitly converted to any integral type large enough to hold it. </li>\n<li>A value of integral type or enumeration type can be explicitly converted to a pointer. </li>\n<li>A function pointer can be explicitly converted to a function pointer of a different type. </li>\n<li>An object pointer can be explicitly converted to an object pointer of a different type.</li>\n<li>Converting a function pointer to an object pointer type or vice versa is conditionally-supported. </li>\n<li>The null pointer value (4.10) is converted to the null pointer value of the destination type. </li>\n<li>A prvalue of type \"pointer to member of <code>X</code> of type <code>T1</code>\" can be explicitly converted to a prvalue of a different type \"pointer to member of Y of type <code>T2</code>\" if <code>T1</code> and <code>T</code>2 are both function types or both object types.</li>\n<li>An lvalue expression of type <code>T1</code> can be cast to the type \"reference to <code>T2</code>\" if an expression of type \"pointer to <code>T1</code>\" can be explicitly converted to the type \"pointer to <code>T2</code>\" using a reinterpret_cast. </li>\n</ul>\n<p><code>void*</code> is not a function pointer and objects don't have function or void type.</p>\n<p>[basic.types]</p>\n<blockquote>\n<p id=\"so_27229578_27229578_6\">An object type is a (possibly cv-qualified) type that is not a\n  function type, not a reference type, and not a void type.</p>\n</blockquote>\n<p>So maybe I'm grasping at straws, but it seems <code>reinterpret_cast&lt;void*&gt;(func)</code> is illegal. However, on the other hand, [expr.static.cast]/5 says \"Otherwise, the <code>static_cast</code> shall perform one of the conversions listed below. No other conversion shall be\nperformed explicitly using a <code>static_cast</code>.\" the key difference being \"shall\" and \"can\". Is this enough to make the <code>reinterpret_cast</code> legal or am I missing something else?</p>\n", "AcceptedAnswerId": "27229664", "Title": "Using reinterpret_cast to cast a function to void*, why isn't it illegal?", "CreationDate": "2014-12-01T13:32:15.290", "LastActivityDate": "2014-12-02T02:23:03.597", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:34:09.200", "LastEditorDisplayName": "user3920237", "OwnerDisplayName": "user3920237", "LastEditorUserId": "-1", "Id": "27229578", "Score": "16", "Tags": "<c++><pointers><c++11><language-lawyer>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27229578_27229578_6": {"length": 10, "quality": 0.9090909090909091, "section_id": 7206}, "so_27229578_27229578_2": {"length": 26, "quality": 0.5909090909090909, "section_id": 40}, "so_27229578_27229578_4": {"length": 26, "quality": 0.5909090909090909, "section_id": 40}, "so_27229578_27229578_5": {"length": 46, "quality": 0.9787234042553191, "section_id": 6040}, "so_27229578_27229664_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 7223}, "so_27229578_27229664_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 6047}}, "n3337": {"so_27229578_27229578_6": {"length": 10, "quality": 0.9090909090909091, "section_id": 6950}, "so_27229578_27229578_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 5913}, "so_27229578_27229578_2": {"length": 42, "quality": 0.9545454545454546, "section_id": 37}, "so_27229578_27229578_4": {"length": 42, "quality": 0.9545454545454546, "section_id": 37}, "so_27229578_27229578_5": {"length": 46, "quality": 0.9787234042553191, "section_id": 5808}, "so_27229578_27229664_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 6967}, "so_27229578_27229664_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 5815}}, "n4659": {"so_27229578_27229578_6": {"length": 9, "quality": 0.8181818181818182, "section_id": 4058}, "so_27229578_27229578_5": {"length": 46, "quality": 0.9787234042553191, "section_id": 7539}, "so_27229578_27229664_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 8732}, "so_27229578_27229578_4": {"length": 23, "quality": 0.5227272727272727, "section_id": 41}, "so_27229578_27229578_2": {"length": 23, "quality": 0.5227272727272727, "section_id": 41}, "so_27229578_27229664_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 7546}}}, "27229664": {"Id": "27229664", "PostTypeId": "2", "Body": "<p><sub>(All quotes are from N3337 and are equivalent for every single draft until N4296 from there on, i.e. this answer is valid  at least for C++11 and C++14 <strong>but not for C++03</strong> as the first quote of this answer does not exist in there.)</sub></p>\n<p>[expr.reinterpret.cast]/8:</p>\n<blockquote>\n<p id=\"so_27229578_27229664_0\"><strong>Converting a function pointer to an object pointer type or vice versa\n  is conditionally-supported.</strong> The meaning of such a conversion is\n  implementation-defined, except that if an implementation supports\n  conversions in both directions, converting a prvalue of one type to\n  the other type and back, possibly with different cv-qualification,\n  shall yield the orignal pointer value.</p>\n</blockquote>\n<p>This is contained in your listing. You argue that <code>void</code> is not an object type, but you didn't consider the crucial [basic.compound]/3:</p>\n<blockquote>\n<p id=\"so_27229578_27229664_1\">The type of <strong>a pointer to <code>void</code></strong> or a pointer to an object type <strong>is called an <em>object pointer type</em></strong>.</p>\n</blockquote>\n<p>(That is, a <em>object pointer type</em> is not necessarily a \"pointer to object type\" - standard terminology got you there.)</p>\n<p>The only reason that</p>\n<pre><code>f = reinterpret_cast&lt;decltype(f)&gt;(s);\n</code></pre>\n<p>Isn't fine on GCC or Clang is that the target type, as opposed to the source expression, is <em>not</em> decayed - and you can clearly not cast <code>void*</code> to a function type. You need to make the target type a pointer to function, <a href=\"http://coliru.stacked-crooked.com/a/964d3801acf6319a\"><strong>then it works</strong></a>.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-12-01T14:02:04.897", "Score": "18", "CreationDate": "2014-12-01T13:37:56.873", "ParentId": "27229578", "CommentCount": "14", "OwnerUserId": "3647361", "LastEditDate": "2014-12-01T14:02:04.897"}});