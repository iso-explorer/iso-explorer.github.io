post_cb({"bq_ids": {"n4140": {"so_25193041_25193277_1": {"length": 37, "quality": 0.6981132075471698, "section_id": 456}, "so_25193041_25193277_0": {"length": 20, "quality": 0.5714285714285714, "section_id": 402}}, "n3337": {"so_25193041_25193277_1": {"length": 39, "quality": 0.7358490566037735, "section_id": 447}, "so_25193041_25193277_0": {"length": 20, "quality": 0.5714285714285714, "section_id": 393}}, "n4659": {"so_25193041_25193277_1": {"length": 37, "quality": 0.6981132075471698, "section_id": 479}, "so_25193041_25193277_0": {"length": 19, "quality": 0.5428571428571428, "section_id": 498}}}, "25193277": {"Id": "25193277", "PostTypeId": "2", "Body": "<p>The compiler will <em>implicitly declare</em> both a destructor and copy constructor for your class, but since you have no way of creating an instance of the class, your program will never be able to odr-use either the destructor or copy constructor, because of which neither will be <em>implicitly defined</em>.</p>\n<p><em>\u00a712.4 [class.dtor]</em></p>\n<blockquote>\n<p id=\"so_25193041_25193277_0\"><em>4</em> \u00a0 If a class has no user-declared destructor, a destructor is implicitly declared as defaulted (8.4). An implicitly declared destructor is an <code>inline public</code> member of its class.<br/><br/>\n<em>5</em> \u00a0 A destructor that is defaulted and not defined as deleted is implicitly defined when it is odr-used (3.2) to destroy an object of its class type (3.7) or when it is explicitly defaulted after its first declaration.</p>\n</blockquote>\n<p><em>\u00a712.8 [class.copy]</em></p>\n<blockquote>\n<p id=\"so_25193041_25193277_1\"><em>7</em> \u00a0 If the class definition does not explicitly declare a copy constructor, one is declared implicitly. If the class definition declares a move constructor or move assignment operator, the implicitly declared copy constructor is defined as deleted; otherwise, it is defined as defaulted (8.4). The latter case is deprecated if the class has a user-declared copy assignment operator or a user-declared destructor.<br/><br/>\n<em>13</em> \u00a0 A copy/move constructor that is defaulted and not defined as deleted is implicitly defined if it is odr-used (3.2) or when it is explicitly defaulted after its first declaration.</p>\n</blockquote>\n<p>As for the address operator (<code>operator&amp;</code>), the compiler never generates that operator overload for you implicitly. The built-in address of operator can be applied to any lvalue type to take its address, but that's a language feature, and unrelated to overloading that operator for a user defined type.</p>\n", "LastEditorUserId": "241631", "LastActivityDate": "2014-08-07T22:32:04.123", "Score": "5", "CreationDate": "2014-08-07T22:25:46.010", "ParentId": "25193041", "CommentCount": "3", "OwnerUserId": "241631", "LastEditDate": "2014-08-07T22:32:04.123"}, "25193041": {"ViewCount": "292", "Body": "<p>In C++11, I define a struct of the following general form:</p>\n<pre><code>struct MyStruct\n{\n    static void myFunc( void );\n\n    //constructors\n    MyStruct( void ) = delete;\n};\n</code></pre>\n<p>It is not possible to create any object of type <code>MyStruct</code> as the default constructor is marked deleted. Even the method <code>myFunc</code> can't create an instance of the class. The struct is still of use though, as <code>MyStruct::myFunc</code> is <code>public</code> and can be called from outside.</p>\n<p>My question now is: Since it is not possible to create any object of type <code>MyStruct</code>, will the compiler even bother to create code for a copy constructor, <strike>address operator or</strike> destructor?</p>\n<p>Just as a remark: In the case of my actual code, I really have to implement functionality in terms of static class member functions, as I have to make use of partial template class specialization to emulate partial template function specialization. So I wonder how I can keep the class as slim as possible.</p>\n<p><strong>Edit</strong>: removed the remark about automatically generated address operators in accordance with the comment and answer of @Praetorian.</p>\n", "AcceptedAnswerId": "25193277", "Title": "Automatically generated class member functions in C++11 in the case of classes which do not have any constructors", "CreationDate": "2014-08-07T22:05:24.467", "Id": "25193041", "CommentCount": "7", "LastEditDate": "2014-08-07T22:51:29.863", "PostTypeId": "1", "LastEditorUserId": "3910671", "LastActivityDate": "2014-08-07T22:51:29.863", "Score": "3", "OwnerUserId": "3910671", "Tags": "<c++><c++11><class-members>", "AnswerCount": "1"}});