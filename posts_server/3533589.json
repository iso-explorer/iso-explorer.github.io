post_cb({"3533692": {"ParentId": "3533589", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Virtuals may have defaults.  The defaults in the base class are not inherited by derived classes.  </p>\n<p>Which default is used -- ie, the base class' or a derived class' -- is determined by the static type used to make the call to the function.  If you call through a base class object, pointer or reference, the default denoted in the base class is used.  Conversely, if you call through a derived class object, pointer or reference the defaults denoted in the derived class are used.  There is an example below the Standard quotation that demonstrates this.</p>\n<p>Some compilers may do something different, but this is what the C++03 and C++11 Standards say:</p>\n<p><em>(<strong>EDIT</strong>:  The C++11 Standard says exactly the same thing)</em></p>\n<h2>8.3.6.10:</h2>\n<blockquote>\n<p id=\"so_3533589_3533692_0\">A virtual function call (10.3) uses\n  the default arguments in the\n  declaration of the virtual function\n  determined\n      by the static type of the pointer or reference denoting the object. An\n  overriding function in a derived\n      class does not acquire default arguments from the function it\n  overrides. [Example:</p>\n</blockquote>\n<pre><code>struct A {\n  virtual void f(int a = 7);\n};\nstruct B : public A {\n  void f(int a);\n};\nvoid m()\n{\n  B* pb = new B;\n  A* pa = pb;\n  pa-&gt;f(); //OK, calls pa-&gt;B::f(7)\n  pb-&gt;f(); //error: wrong number of arguments for B::f()\n}\n</code></pre>\n<blockquote id=\"so_3533589_3533692_1\">\n<pre><code>\u2014end example]\n</code></pre>\n</blockquote>\n<p><strong>Edit</strong> Here is a sample program to demonstrate what defaults are picked up.  I'm using <code>struct</code>s here rather than <code>class</code>es simply for brevity -- <code>class</code> and <code>struct</code> are exactly the same in almost every way except default visibility.</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing std::stringstream;\nusing std::string;\nusing std::cout;\nusing std::endl;\n\nstruct Base { virtual string Speak(int n = 42); };\nstruct Der : public Base { string Speak(int n = 84); };\n\nstring Base::Speak(int n) \n{ \n    stringstream ss;\n    ss &lt;&lt; \"Base \" &lt;&lt; n;\n    return ss.str();\n}\n\nstring Der::Speak(int n)\n{\n    stringstream ss;\n    ss &lt;&lt; \"Der \" &lt;&lt; n;\n    return ss.str();\n}\n\nint main()\n{\n    Base b1;\n    Der d1;\n\n    Base *pb1 = &amp;b1, *pb2 = &amp;d1;\n    Der *pd1 = &amp;d1;\n    cout &lt;&lt; pb1-&gt;Speak() &lt;&lt; \"\\n\"    // Base 42\n        &lt;&lt; pb2-&gt;Speak() &lt;&lt; \"\\n\"     // Der 42\n        &lt;&lt; pd1-&gt;Speak() &lt;&lt; \"\\n\"     // Der 84\n        &lt;&lt; endl;\n}\n</code></pre>\n<p>The output of this program (on MSVC10 and GCC 4.4) is:</p>\n<pre><code>Base 42\nDer 42\nDer 84\n</code></pre>\n", "OwnerUserId": "241536", "LastEditorUserId": "241536", "LastEditDate": "2013-08-27T15:41:36.383", "Id": "3533692", "Score": "158", "CreationDate": "2010-08-20T18:17:22.373", "LastActivityDate": "2013-08-27T15:41:36.383"}, "25995338": {"ParentId": "3533589", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is a bad idea, because the default arguments you get will depend on the <em>static</em> type of the object, whereas the <code>virtual</code> function dispatched to will depend on the <em>dynamic</em> type.</p>\n<p>That is to say, when you call a function with default arguments, the default arguments are substituted at compile time, regardless of whether the function is <code>virtual</code> or not.</p>\n<p>@cppcoder offered the following example in his [closed] <a href=\"https://stackoverflow.com/q/25994594/1639256\">question</a>:</p>\n<pre><code>struct A {\n    virtual void display(int i = 5) { std::cout &lt;&lt; \"Base::\" &lt;&lt; i &lt;&lt; \"\\n\"; }\n};\nstruct B : public A {\n    virtual void display(int i = 9) override { std::cout &lt;&lt; \"Derived::\" &lt;&lt; i &lt;&lt; \"\\n\"; }\n};\n\nint main()\n{\n    A * a = new B();\n    a-&gt;display();\n\n    A* aa = new A();\n    aa-&gt;display();\n\n    B* bb = new B();\n    bb-&gt;display();\n}\n</code></pre>\n<p>Which produces the following output:</p>\n<pre><code>Derived::5\nBase::5\nDerived::9\n</code></pre>\n<p>With the aid of the explanation above, it is easy to see why. At compile time, the compiler substitutes the default arguments from the member functions of the static types of the pointers, making his <code>main</code> function equivalent to the following:</p>\n<pre><code>    A * a = new B();\n    a-&gt;display(5);\n\n    A* aa = new A();\n    aa-&gt;display(5);\n\n    B* bb = new B();\n    bb-&gt;display(9);\n</code></pre>\n", "OwnerUserId": "1639256", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:47:11.987", "Id": "25995338", "Score": "2", "CreationDate": "2014-09-23T12:38:47.883", "LastActivityDate": "2014-09-23T12:38:47.883"}, "3533732": {"ParentId": "3533589", "CommentCount": "1", "Body": "<p>As you can see from the other answers this is a complicated subject. Instead of trying to do this or understand what it does (if you have to ask now, the maintainer will have to ask or look it up a year from now).</p>\n<p>Instead, create a public non-virtual function in the base class with default parameters. Then it calls a private or protected virtual function that has no default parameters and is overridden in child classes as needed. Then you don't have to worry about the particulars of how it would work and the code is very obvious.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "3533732", "Score": "3", "CreationDate": "2010-08-20T18:22:45.770", "LastActivityDate": "2010-08-20T18:22:45.770"}, "3533695": {"ParentId": "3533589", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This was the topic of one of Herb Sutter's early <a href=\"http://www.gotw.ca/gotw/005.htm\" rel=\"noreferrer\">Guru of the Week</a> posts.</p>\n<p>The first thing he says on the subject is DON'T DO THAT.</p>\n<p>In more detail, yes, you can specify different default parameters.  They won't work the same way as the virtual functions.  A virtual function is called on the dynamic type of the object, while the default parameter values are based on the static type.</p>\n<p>Given</p>\n<pre><code>class A {\n    virtual void foo(int i = 1) { cout &lt;&lt; \"A::foo\" &lt;&lt; i &lt;&lt; endl; }\n};\nclass B: public A {\n    virtual void foo(int i = 2) { cout &lt;&lt; \"B::foo\" &lt;&lt; i &lt;&lt; endl; }\n};\nvoid test() {\nA a;\nB b;\nA* ap = &amp;b;\na.foo();\nb.foo();\nap-&gt;foo();\n}\n</code></pre>\n<p>you should get\n    A::foo1\n    B::foo2\n    B::foo1</p>\n", "OwnerUserId": "14148", "LastEditorUserId": "457237", "LastEditDate": "2016-02-18T01:12:50.357", "Id": "3533695", "Score": "26", "CreationDate": "2010-08-20T18:17:52.420", "LastActivityDate": "2016-02-18T01:12:50.357"}, "45517721": {"ParentId": "3533589", "CommentCount": "0", "Body": "<p>As other answers have detailed, its bad idea. However since no one mentions simple and effective solution, here it is: Convert your parameters to struct and then you can have default values to struct members!</p>\n<p>So instead of,</p>\n<pre><code>//bad idea\nvirtual method1(int x = 0, int y = 0, int z = 0)\n</code></pre>\n<p>do this,</p>\n<pre><code>//good idea\nstruct Param1 {\n  int x = 0, y = 0, z = 0;\n};\nvirtual method1(const Param1&amp; p)\n</code></pre>\n", "OwnerUserId": "207661", "PostTypeId": "2", "Id": "45517721", "Score": "0", "CreationDate": "2017-08-05T02:51:04.763", "LastActivityDate": "2017-08-05T02:51:04.763"}, "3533589": {"CommentCount": "3", "CreationDate": "2010-08-20T18:04:25.617", "PostTypeId": "1", "AcceptedAnswerId": "3533692", "LastEditorUserId": "241536", "LastActivityDate": "2017-08-05T02:51:04.763", "LastEditDate": "2013-08-27T15:42:32.983", "ViewCount": "39746", "FavoriteCount": "28", "Title": "Can virtual functions have default parameters?", "Id": "3533589", "Score": "116", "Body": "<p>If I declare a base class (or interface class) and specify a default value for one or more of its parameters, do the derived classes have to specify the same defaults and if not, which defaults will manifest in the derived classes?</p>\n<p>Addendum: I'm also interested in how this may be handled across different compilers and any input on \"recommended\" practice in this scenario.</p>\n", "Tags": "<c++><c++11><c++03>", "OwnerUserId": "31044", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_3533589_3533692_0": {"section_id": 3261, "quality": 0.9285714285714286, "length": 26}}, "n3337": {"so_3533589_3533692_0": {"section_id": 3133, "quality": 0.9285714285714286, "length": 26}}, "n4659": {"so_3533589_3533692_0": {"section_id": 4019, "quality": 0.9285714285714286, "length": 26}}}, "3533662": {"ParentId": "3533589", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>This is one that you can probably figure out reasonably well by testing (i.e., it's a sufficiently mainstream part of the language that most compilers almost certainly get it right and unless you see differences between compilers, their output can be considered pretty well authoritative).</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct base { \n    virtual void x(int a=0) { std::cout &lt;&lt; a; }\n    virtual ~base() {}\n};\n\nstruct derived1 : base { \n    void x(int a) { std:: cout &lt;&lt; a; }\n};\n\nstruct derived2 : base { \n    void x(int a = 1) { std::cout &lt;&lt; a; }\n};\n\nint main() { \n    base *b[3];\n    b[0] = new base;\n    b[1] = new derived1;\n    b[2] = new derived2;\n\n    for (int i=0; i&lt;3; i++) {\n        b[i]-&gt;x();\n        delete b[i];\n    }\n\n    derived1 d;\n    // d.x();       // won't compile.\n    derived2 d2;\n    d2.x();\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2010-08-20T18:33:04.483", "Id": "3533662", "Score": "3", "CreationDate": "2010-08-20T18:14:11.813", "LastActivityDate": "2010-08-20T18:33:04.483"}});