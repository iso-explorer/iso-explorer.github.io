post_cb({"17514157": {"ParentId": "14935722", "CommentCount": "4", "Body": "<p>An implicit conversion sequence of an expression <code>e</code> to type <code>T</code> is defined as being equivalent to the following declaration, using <code>t</code> as the result of the conversion (modulo value category, which will be defined depending on <code>T</code>), 4p3 and 4p6</p>\n<pre><code>T t = e;\n</code></pre>\n<blockquote>\n<p id=\"so_14935722_17514157_0\">The effect of any implicit conversion is the same as performing the corresponding declaration and initialization and then using the temporary variable as the result of the conversion. </p>\n</blockquote>\n<p>In clause 4, the conversion of an expression to a type always yields expressions with a specific property. For example, conversion of <code>0</code> to <code>int*</code> yields a null pointer value, and not just one arbitrary pointer value. The value category too is a specific property of an expression and its result is defined as follows</p>\n<blockquote>\n<p id=\"so_14935722_17514157_1\">The result is an lvalue if T is an lvalue reference type or an rvalue reference to function type (8.3.2), an xvalue if T is an rvalue reference to object type, and a prvalue otherwise.</p>\n</blockquote>\n<p>Hence we know that in <code>int t = e;</code>, the result of the conversion sequence is a prvalue, because <code>int</code> is a non-reference type. So if we provide a glvalue, we are in obvious need of a conversion. 3.10p2 further clarifies that to leave no doubt</p>\n<blockquote>\n<p id=\"so_14935722_17514157_2\">Whenever a glvalue appears in a context where a prvalue is expected, the glvalue is converted to a prvalue; see 4.1, 4.2, and 4.3. </p>\n</blockquote>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "17514157", "Score": "7", "CreationDate": "2013-07-07T16:52:31.880", "LastActivityDate": "2013-07-07T16:52:31.880"}, "14935722": {"CommentCount": "25", "ViewCount": "2022", "PostTypeId": "1", "LastEditorUserId": "596781", "CreationDate": "2013-02-18T11:55:30.290", "LastActivityDate": "2013-08-17T23:23:04.817", "Title": "Does initialization entail lvalue-to-rvalue conversion? Is `int x = x;` UB?", "FavoriteCount": "11", "LastEditDate": "2013-02-18T12:50:12.527", "Id": "14935722", "Score": "51", "Body": "<p>The C++ standard contains a semi-famous example of \"surprising\" name lookup in 3.3.2, \"Point of declaration\":</p>\n<pre><code>int x = x;\n</code></pre>\n<p>This initializes <code>x</code> with itself, which (being a primitive type) is <em>uninitialized</em> and thus has an indeterminate value (assuming it is an automatic variable).</p>\n<p>Is this actually undefined behaviour?</p>\n<p>According to 4.1 \"Lvalue-to-rvalue conversion\", it is undefined behaviour to perform lvalue-to-rvalue conversion on an uninitialized value. Does the right-hand <code>x</code> undergo this conversion? If so, would the example actually have undefined behaviour?</p>\n", "Tags": "<c++><initialization><undefined-behavior><language-lawyer>", "OwnerUserId": "596781", "AnswerCount": "4"}, "14936696": {"ParentId": "14935722", "CommentCount": "7", "Body": "<p>this is not undefined behaviour.You just don't know its specific values, because there is no initialization.\nIf the variable is global and built-in type so the compiler will put it initialized to the right value. If the variable is local so the compiler not initialize it,So all of the variables are initialized to yourself, don't rely on the compiler.</p>\n", "OwnerUserId": "2083277", "PostTypeId": "2", "Id": "14936696", "Score": "-4", "CreationDate": "2013-02-18T12:46:26.950", "LastActivityDate": "2013-02-18T12:46:26.950"}, "15101353": {"ParentId": "14935722", "CommentCount": "2", "Body": "<p>The behavior is not undefined. The variable is uninitialized and stays with whatever random value uninitialized values start up with. One example from clan'g test suit:</p>\n<pre><code>int test7b(int y) {\n  int x = x; // expected-note{{variable 'x' is declared here}}\n  if (y)\n    x = 1;\n  // Warn with \"may be uninitialized\" here (not \"is sometimes uninitialized\"),\n  // since the self-initialization is intended to suppress a -Wuninitialized\n  // warning.\n  return x; // expected-warning{{variable 'x' may be uninitialized when used here}}\n}\n</code></pre>\n<p>Which you can find in <a href=\"https://github.com/llvm-mirror/clang/blob/master/test/Sema/uninit-variables.c#L48\" rel=\"nofollow\">clang/test/Sema/uninit-variables.c</a> tests for this case explicitly.</p>\n", "OwnerUserId": "3961", "PostTypeId": "2", "Id": "15101353", "Score": "-4", "CreationDate": "2013-02-26T23:16:47.873", "LastActivityDate": "2013-02-26T23:16:47.873"}, "14991772": {"CommentCount": "17", "CreationDate": "2013-02-20T23:20:02.330", "CommunityOwnedDate": "2013-02-23T00:22:42.710", "LastEditorUserId": "-1", "LastActivityDate": "2013-02-23T14:29:40.970", "ParentId": "14935722", "PostTypeId": "2", "LastEditDate": "2017-05-23T12:00:13.463", "Id": "14991772", "Score": "19", "Body": "<p><strong>UPDATE:</strong> <em>Following the discussion in the comments, I added some more evidence at the end of this answer.</em></p>\n<hr>\n<p><strong>Disclaimer</strong>: <em>I admit this answer is rather speculative. The current formulation of the C++11 Standard, on the other hand, does not seem to allow for a more formal answer.</em></p>\n<hr>\n<p>In the context of <strong><a href=\"https://stackoverflow.com/questions/14991219/what-is-the-value-category-of-the-operands-of-c-operators-when-unspecified/14991297#comment21055383_14991297\">this Q&amp;A</a></strong>, it has emerged that the C++11 Standard fails to formally specify what <strong><a href=\"https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues\">value categories</a></strong> are expected by each language construct. In the following I will mostly focus on <em>built-in operators</em>, although the question is about <em>initializers</em>. Eventually, I will end up extending the conclusions I drew for the case of operators to the case of initializers.</p>\n<p>In the case of built-in operators, in spite of the lack of a formal specification, (non-normative) evidences are found in the Standard that the <em>intended</em> specification is to <strong>let prvalues be expected wherever a value is needed, and when not specified otherwise</strong>.</p>\n<p>For instance, a note in Paragraph 3.10/1 says:</p>\n<blockquote>\n<p id=\"so_14935722_14991772_0\">The discussion of each built-in operator in Clause 5 indicates the category of the value it yields and the value categories of the operands it expects. For example, <strong>the built-in assignment operators expect that the left operand is an lvalue and that the right operand is a prvalue and yield an lvalue as the result.</strong> User-defined operators are functions, and the categories of values they expect and yield are determined by their parameter and return types</p>\n</blockquote>\n<p>Section 5.17 on assignment operators, on the other hand, does not mention this. However, the possibility of performing an lvalue-to-rvalue conversion is mentioned, again in a note (Paragraph 5.17/1):</p>\n<blockquote>\n<p id=\"so_14935722_14991772_1\">Therefore, a function call shall not intervene between <strong>the lvalue-to-rvalue conversion</strong> and the side effect associated with any single compound assignment operator</p>\n</blockquote>\n<p>Of course, if no rvalue were expected, this note would be meaningless. </p>\n<p>Another evidence is found in 4/8, as pointed out by <a href=\"https://stackoverflow.com/users/34509/johannes-schaub-litb\">Johannes Schaub</a> in the comments to linked Q&amp;A:</p>\n<blockquote>\n<p id=\"so_14935722_14991772_2\">There are some contexts where certain conversions are suppressed. For example, the lvalue-to-rvalue conversion is not done on the operand of the unary &amp; operator. Specific exceptions are given in the descriptions of those operators and contexts.</p>\n</blockquote>\n<p>This seems to imply that lvalue-to-rvalue conversion is performed on all operands of built-in operators, except when specified otherwise. This would mean, in turn, that <strong>rvalues are expected as operands of built-in operators unless specified otherwise.</strong></p>\n<hr>\n<p><strong>CONJECTURE:</strong></p>\n<p>Even though initialization is not assignment, and therefore operators do not enter the discussion, my suspicion is that this area of the specification is affected by the very same problem described above. </p>\n<p>Traces supporting this belief can be found even in Paragraph 8.5.2/5, about the initialization of <em>references</em> (for which the value of the lvalue initializer expression is not needed):</p>\n<blockquote>\n<p id=\"so_14935722_14991772_3\">The <strong>usual</strong> lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are not needed, and therefore are suppressed, when such direct bindings to lvalues are done.</p>\n</blockquote>\n<p>The word \"usual\" seems to imply that when initializing objects which are not of a reference type, lvalue-to-rvalue conversion is meant to apply.</p>\n<p>Therefore, I believe that although requirements on the expected value category of initializers are ill-specified (if not completely missing), on the grounds of the evidences provided it makes sense to assume that the <em>intended</em> specification is that:</p>\n<p><strong>Wherever a value is required by a language construct, a prvalue is expected unless specified otherwise</strong>.</p>\n<p>Under this assumption, an lvalue-to-rvalue conversion would be required in your example, and that would lead to Undefined Behavior.</p>\n<hr>\n<p><strong>ADDITIONAL EVIDENCE:</strong></p>\n<p>Just to provide further evidence to support this conjecture, let's assume it <em>wrong</em>, so that no lvalue-to-rvalue conversion is indeed required for copy-initialization, and consider the following code (thanks to <a href=\"https://stackoverflow.com/users/777186/jogojapan\">jogojapan</a> for contributing):</p>\n<pre><code>int y;\nint x = y; // No UB\nshort t;\nint u = t; // UB! (Do not like this non-uniformity, but could accept it)\nint z;\nz = x; // No UB (x is not uninitialized)\nz = y; // UB! (Assuming assignment operators expect a prvalue, see above)\n       // This would be very counterintuitive, since x == y\n</code></pre>\n<p>This non-uniform behavior does not make a lot of sense to me. What makes more sense IMO is that wherever a value is required, a prvalue is expected.</p>\n<p>Moreover, as <a href=\"https://stackoverflow.com/users/906773/jesse-good\">Jesse Good</a> correctly points out in his answer, the key Paragraph of the C++ Standard is 8.5/16:</p>\n<blockquote>\n<p id=\"so_14935722_14991772_4\">\u2014 Otherwise, the initial value of the object being initialized is the\n  <strong>(possibly converted) value of the initializer expression</strong>. Standard\n  conversions (Clause 4) will be used, <strong>if necessary</strong>, to convert the\n  initializer expression to the cv-unqualified version of the\n  destination <strong>type</strong>; no user-defined conversions are considered. If the\n  conversion cannot be done, the initialization is ill-formed. [ Note:\n  An expression of type \u201ccv1 T\u201d can initialize an object of type \u201ccv2 T\u201d\n  independently of the cv-qualifiers cv1 and cv2. </p>\n</blockquote>\n<p>However, while Jesse mainly focuses on the \"<em>if necessary</em>\" bit, I would also like to stress the word \"<strong>type</strong>\". The paragraph above mentions that standard conversions will be used \"<em>if necessary</em>\" to convert to the destination <em>type</em>, but does not say anything about <em>category</em> conversions:</p>\n<ol>\n<li>Will category conversions be performed if needed?</li>\n<li>Are they needed?</li>\n</ol>\n<p>For what concerns the second question, as discussed in the original part of the answer, the C++11 Standard currently does not specify whether category conversions are needed or not, because nowhere it is mentioned whether copy-initialization expects a prvalue as an initializer. Thus, a clear-cut answer is impossible to give. However, I believe I provided enough evidence to assume this to be the <em>intended</em> specification, so that the answer would be \"Yes\".</p>\n<p>As for the first question, it seems reasonable to me that the answer is \"Yes\" as well. If it were \"No\", obviously correct programs would be ill-formed:</p>\n<pre><code>int y = 0;\nint x = y; // y is lvalue, prvalue expected (assuming the conjecture is correct)\n</code></pre>\n<p>To sum it up (A1 = \"<em>Answer to question 1</em>\", A2 = \"<em>Answer to question 2</em>\"):</p>\n<pre><code>          | A2 = Yes   | A2 = No |\n ---------|------------|---------|\n A1 = Yes |     UB     |  No UB  | \n A1 = No  | ill-formed |  No UB  |\n ---------------------------------\n</code></pre>\n<p>If A2 is \"No\", A1 does not matter: there's no UB, but the bizarre situations of the first example (e.g. <code>z = y</code> giving UB, but not <code>z = x</code> even though <code>x == y</code>) show up. If A2 is \"Yes\", on the other hand, A1 becomes crucial; yet, enough evidence has been given to prove it would be \"Yes\".</p>\n<p>Therefore, <strong>my thesis is that A1 = \"Yes\" and A2 = \"Yes\", and we <em>should</em> have Undefined Behavior</strong>.</p>\n<hr>\n<p><strong>FURTHER EVIDENCE:</strong></p>\n<p>This <strong><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#616\" rel=\"nofollow noreferrer\">defect report</a></strong> (courtesy of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#616\" rel=\"nofollow noreferrer\">Jesse Good</a>) proposes a change that is aimed at giving Undefined Behavior in this case:</p>\n<blockquote>\n<p id=\"so_14935722_14991772_5\">[...] In addition, 4.1 [conv.lval] paragraph 1 says that applying the lvalue-to-rvalue conversion to an \u201cobject [that] is uninitialized\u201d results in undefined behavior; <strong>this should be rephrased in terms of an object with an indeterminate value</strong>.</p>\n</blockquote>\n<p>In particular, the proposed wording for Paragraph 4.1 says:</p>\n<blockquote>\n<p id=\"so_14935722_14991772_6\">When an lvalue-to-rvalue conversion occurs in an unevaluated operand or a subexpression thereof (Clause 5 [expr]) the value contained in the referenced object is not accessed. In all other cases, the result of the conversion is determined according to the following rules:</p>\n<p id=\"so_14935722_14991772_7\">\u2014  If T is (possibly cv-qualified) std::nullptr_t, the result is a null pointer constant (4.10 [conv.ptr]).</p>\n<p id=\"so_14935722_14991772_8\">\u2014 Otherwise, if the glvalue T has a class type, the conversion copy-initializes a temporary of type T from the glvalue and the result of the conversion is a prvalue for the temporary.</p>\n<p id=\"so_14935722_14991772_9\">\u2014 Otherwise, if the object to which the glvalue refers contains an invalid pointer value (3.7.4.2 [basic.stc.dynamic.deallocation], 3.7.4.3 [basic.stc.dynamic.safety]), the behavior is implementation-defined.</p>\n<p id=\"so_14935722_14991772_10\">\u2014 Otherwise, if T is a (possibly cv-qualified) unsigned character type (3.9.1 [basic.fundamental]), and the object to which the glvalue refers contains an indeterminate value (5.3.4 [expr.new], 8.5 [dcl.init], 12.6.2 [class.base.init]), and that object does not have automatic storage duration or the glvalue was the operand of a unary &amp; operator or it was bound to a reference, the result is an unspecified value. [Footnote: The value may be different each time the lvalue-to-rvalue conversion is applied to the object. An unsigned char object with indeterminate value allocated to a register might trap. \u2014end footnote]</p>\n<p id=\"so_14935722_14991772_11\">\u2014 <strong>Otherwise, if the object to which the glvalue refers contains an indeterminate value, the behavior is undefined.</strong></p>\n<p id=\"so_14935722_14991772_12\">\u2014 Otherwise, if the glvalue has (possibly cv-qualified) type std::nullptr_t, the prvalue result is a null pointer constant (4.10 [conv.ptr]). Otherwise, the value contained in the object indicated by the glvalue is the prvalue result.</p>\n</blockquote>\n</hr></hr></hr></hr></hr>", "OwnerUserId": "1932150"}, "bq_ids": {"n4140": {"so_14935722_14991772_11": {"section_id": 9, "quality": 0.7777777777777778, "length": 7}, "so_14935722_14991772_6": {"section_id": 9, "quality": 0.7083333333333334, "length": 17}, "so_14935722_17514157_1": {"section_id": 5, "quality": 0.8888888888888888, "length": 16}, "so_14935722_17514157_0": {"section_id": 5, "quality": 0.9333333333333333, "length": 14}, "so_14935722_14991772_4": {"section_id": 3296, "quality": 0.8604651162790697, "length": 37}, "so_14935722_14991772_2": {"section_id": 7, "quality": 0.9545454545454546, "length": 21}, "so_14935722_14991772_3": {"section_id": 3321, "quality": 0.9333333333333333, "length": 14}, "so_14935722_17514157_2": {"section_id": 7231, "quality": 1.0, "length": 11}, "so_14935722_14991772_1": {"section_id": 6173, "quality": 1.0, "length": 14}, "so_14935722_14991772_9": {"section_id": 9, "quality": 0.7142857142857143, "length": 10}, "so_14935722_14991772_12": {"section_id": 9, "quality": 0.7142857142857143, "length": 15}, "so_14935722_14991772_7": {"section_id": 9, "quality": 0.7777777777777778, "length": 7}, "so_14935722_14991772_8": {"section_id": 9, "quality": 0.9230769230769231, "length": 12}, "so_14935722_14991772_0": {"section_id": 7230, "quality": 0.9523809523809523, "length": 40}}, "n3337": {"so_14935722_14991772_11": {"section_id": 5541, "quality": 0.5555555555555556, "length": 5}, "so_14935722_14991772_6": {"section_id": 6, "quality": 0.6666666666666666, "length": 16}, "so_14935722_17514157_1": {"section_id": 2, "quality": 0.8888888888888888, "length": 16}, "so_14935722_14991772_7": {"section_id": 6, "quality": 0.7777777777777778, "length": 7}, "so_14935722_14991772_4": {"section_id": 3166, "quality": 0.8604651162790697, "length": 37}, "so_14935722_14991772_2": {"section_id": 4, "quality": 0.9545454545454546, "length": 21}, "so_14935722_14991772_3": {"section_id": 3191, "quality": 0.9333333333333333, "length": 14}, "so_14935722_17514157_2": {"section_id": 6975, "quality": 1.0, "length": 11}, "so_14935722_14991772_1": {"section_id": 5934, "quality": 1.0, "length": 14}, "so_14935722_14991772_12": {"section_id": 6, "quality": 0.9047619047619048, "length": 19}, "so_14935722_17514157_0": {"section_id": 2, "quality": 0.8666666666666667, "length": 13}, "so_14935722_14991772_8": {"section_id": 6, "quality": 1.0, "length": 13}, "so_14935722_14991772_0": {"section_id": 6974, "quality": 0.9523809523809523, "length": 40}}, "n4659": {"so_14935722_14991772_11": {"section_id": 10, "quality": 0.7777777777777778, "length": 7}, "so_14935722_17514157_1": {"section_id": 5, "quality": 0.8888888888888888, "length": 16}, "so_14935722_14991772_7": {"section_id": 39, "quality": 0.5555555555555556, "length": 5}, "so_14935722_14991772_4": {"section_id": 4058, "quality": 0.8604651162790697, "length": 37}, "so_14935722_14991772_2": {"section_id": 7, "quality": 0.9545454545454546, "length": 21}, "so_14935722_14991772_3": {"section_id": 4087, "quality": 0.9333333333333333, "length": 14}, "so_14935722_17514157_2": {"section_id": 8743, "quality": 1.0, "length": 11}, "so_14935722_14991772_1": {"section_id": 7675, "quality": 1.0, "length": 14}, "so_14935722_14991772_9": {"section_id": 10, "quality": 0.6428571428571429, "length": 9}, "so_14935722_14991772_12": {"section_id": 10, "quality": 0.5714285714285714, "length": 12}, "so_14935722_17514157_0": {"section_id": 5, "quality": 0.9333333333333333, "length": 14}, "so_14935722_14991772_8": {"section_id": 4087, "quality": 0.6153846153846154, "length": 8}, "so_14935722_14991772_0": {"section_id": 8741, "quality": 0.9523809523809523, "length": 40}}}});