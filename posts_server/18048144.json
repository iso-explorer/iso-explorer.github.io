post_cb({"bq_ids": {"n4140": {"so_18048144_18048144_0": {"length": 42, "quality": 0.8571428571428571, "section_id": 188}}, "n3337": {"so_18048144_18048144_0": {"length": 45, "quality": 0.9183673469387755, "section_id": 182}, "so_18048144_18048217_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 5947}}, "n4659": {"so_18048144_18048144_0": {"length": 39, "quality": 0.7959183673469388, "section_id": 193}}}, "18048217": {"Id": "18048217", "PostTypeId": "2", "Body": "<p>Turns out that this behaviour is unspecified due to a known defect in the C++ standard:</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html</a></p>\n<blockquote>\n<p id=\"so_18048144_18048217_0\">DR 903. Value-dependent integral null pointer constants</p>\n</blockquote>\n<p>The proposed resolution is to change the wording of the standard to allow only the literal '0' as a null pointer constant, but this is under review as it would mean breaking existing code that uses 'false'.</p>\n<p>GCC appears to resolve this by treating 'g' as a dependent name. In contrast, Clang appears to rule that a value-dependent expression can never be a null pointer constant expression. Neither approach is strictly correct, because the correct behaviour is unspecified.</p>\n", "LastEditorUserId": "1690864", "LastActivityDate": "2013-08-05T10:54:35.550", "Score": "1", "CreationDate": "2013-08-04T22:24:54.627", "ParentId": "18048144", "CommentCount": "2", "OwnerUserId": "1690864", "LastEditDate": "2013-08-05T10:54:35.550"}, "18048144": {"ViewCount": "66", "Body": "<p>Clang 3.0 rejects the following code, complaining that <code>g(unsigned long)</code> was not found. \nGCC 4.8 accepts it without error. </p>\n<pre><code>void g(int*);\n\nvoid f()\n{\n    g(sizeof(int) - sizeof(int)); // ok, evaluates to 0\n}\n\ntemplate&lt;typename T&gt;\nstruct A\n{\n    void f()\n    {\n        g(sizeof(T) - sizeof(T)); // error: no matching function\n    }\n};\n</code></pre>\n<p>My reading of the standard suggests that 'g' is not a dependent name, and should be looked up and bound immediately as clang seems to do. Even so, the behaviour specified by the standard seems wrong, because <code>g</code> would otherwise be bound correctly at instantiation time.</p>\n<blockquote>\n<p id=\"so_18048144_18048144_0\">[temp.dep]<br>\n  [...] In an expression of the form:<br>\n<code>postfix-expression ( expression-list</code><sub>opt</sub><code>)</code><br>\n  where the postfix-expression is an id-expression, the id-expression denotes a dependent name if any of the expressions in the expression-list is a type-dependent expression (14.6.2.2) or if the unqualified-id of the id-expression is a template-id in which any of the template arguments depends on a template parameter.\n  If an operand of an operator is a type-dependent expression, the operator also denotes a dependent name.\n  Such names are unbound and are looked up at the point of the template instantiation (14.6.4.1) in both the context of the template definition and the context of the point of instantiation.</br></br></br></p>\n</blockquote>\n<p>What is the compliant behaviour in this scenario?</p>\n", "AcceptedAnswerId": "18048217", "Title": "When should name lookup happen for unqualified function-call with dependent null pointer constant expression argument?", "CreationDate": "2013-08-04T22:17:01.037", "Id": "18048144", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-08-05T10:54:35.550", "Score": "2", "OwnerUserId": "1690864", "Tags": "<c++><templates><null><expression><language-lawyer>", "AnswerCount": "1"}});