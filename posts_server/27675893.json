post_cb({"bq_ids": {"n4140": {"so_27675893_27676077_5": {"length": 15, "quality": 0.6818181818181818, "section_id": 3321}, "so_27675893_27676077_1": {"length": 18, "quality": 1.0, "section_id": 3321}, "so_27675893_27676077_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 593}, "so_27675893_27676077_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 3321}, "so_27675893_27676077_2": {"length": 37, "quality": 0.9487179487179487, "section_id": 597}}, "n3337": {"so_27675893_27676077_5": {"length": 15, "quality": 0.6818181818181818, "section_id": 3191}, "so_27675893_27676077_1": {"length": 18, "quality": 1.0, "section_id": 3191}, "so_27675893_27676077_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 583}, "so_27675893_27676077_2": {"length": 37, "quality": 0.9487179487179487, "section_id": 587}, "so_27675893_27676077_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 3191}}, "n4659": {"so_27675893_27676077_5": {"length": 20, "quality": 0.9090909090909091, "section_id": 4086}, "so_27675893_27676077_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 4087}, "so_27675893_27676077_4": {"length": 12, "quality": 1.0, "section_id": 616}, "so_27675893_27676077_2": {"length": 37, "quality": 0.9487179487179487, "section_id": 620}, "so_27675893_27676077_0": {"length": 12, "quality": 1.0, "section_id": 4087}}}, "27676077": {"Id": "27676077", "PostTypeId": "2", "Body": "<p><sup>(All quotes from N4140, the C++14 FD)</sup></p>\n<p><strong>TL;DR: The code is well-formed, this is (or was) a GCC bug.</strong></p>\n<p>The rules for reference initialization are covered in [dcl.init.ref]/5. I'll first show you the bullet that doesn't cover it - if you want to skip that go straight to the third quote.</p>\n<blockquote>\n<p id=\"so_27675893_27676077_0\">Otherwise, the reference shall be an lvalue reference to a\n  non-volatile const type (i.e., <em>cv1</em> shall be <code>const</code>), or the\n  reference shall be an rvalue reference.</p>\n<ul>\n<li>If the initializer expression\n  <ul>\n<li>is an xvalue (but not a bit-field), class prvalue, array prvalue or function lvalue and \u201c<em>cv1</em> <code>T1</code>\u201d is reference-compatible with \u201c<em>cv2</em> <code>T2</code>\u201d,\n  or</li>\n<li>has a class type (i.e., <code>T2</code> is a class type), where <code>T1</code> is not reference-related to <code>T2</code>, and <strong>can be converted to</strong> an xvalue,\n  <strong>class prvalue</strong>, or function lvalue <strong>of type \u201c<em>cv3</em> <code>T3</code>\u201d, where \u201c<em>cv1</em> <code>T1</code>\u201d is reference-compatible with \u201c<em>cv3</em> <code>T3</code>\u201d (see 13.3.1.6)</strong>,</li>\n</ul></li>\n</ul>\n<p id=\"so_27675893_27676077_1\"><strong>then the\n  reference is bound</strong> to the value of the initializer expression in the\n  first case and <strong>to the result of the conversion in the second case (or,\n  in either case, to an appropriate base class subobject).</strong></p>\n</blockquote>\n<p>And reference-compability is defined in [dcl.init.ref]/4<sup>1</sup>.<br>\nNow consider the linked 13.3.1.6:</br></p>\n<blockquote>\n<p id=\"so_27675893_27676077_2\">Under the conditions specified in 8.5.3, a reference can be bound\n  directly to a glvalue or class prvalue that is the result of applying\n  a conversion function to an initializer expression. Overload\n  resolution is used to select the conversion function to be invoked.\n  Assuming that \u201c<em>cv1</em> <code>T</code>\u201d is the underlying type of the reference\n  being initialized, and \u201c<em>cv</em> <code>S</code>\u201d is the type of the initializer\n  expression, with <code>S</code> a class type, the candidate functions are\n  selected as follows:</p>\n<ul>\n<li>The conversion functions of <code>S</code> and its base classes are considered. Those non-explicit conversion functions that are not\n  hidden within <code>S</code> <strong>and yield type \u201clvalue reference to <em>cv2</em> <code>T2</code>\u201d</strong>\n  (<strong>when initializing an lvalue reference</strong> or an rvalue reference to\n  function) or \u201c<em>cv2</em> <code>T2</code>\u201d [..],\n  where \u201c<em>cv1</em> <code>T</code>\u201d is reference-compatible (8.5.3) with \u201c<em>cv2</em> <code>T2</code>\u201d,\n  are candidate functions. For direct-initialization, [..].</li>\n</ul>\n</blockquote>\n<p>As you can see, your conversion function isn't a candidate after this paragraph. Thus the next bullet in [dcl.init]/5 is applicable:</p>\n<blockquote>\n<p id=\"so_27675893_27676077_3\">Otherwise:</p>\n<ul>\n<li>If <code>T1</code> is a class type, user-defined conversions are considered using the rules for copy-initialization of an object of type \u201c<em>cv1</em>\n<code>T1</code>\u201d by user-defined conversion (8.5, 13.3.1.4); the program is\n  ill-formed if the corresponding non-reference copy-initialization\n  would be ill-formed. <strong>The result of the call to the conversion\n  function, as described for the non-reference copy-initialization, is\n  then used to direct-initialize the reference. The program is\n  ill-formed if the direct-initialization does not result in a direct\n  binding or if it involves a user-defined conversion.</strong></li>\n</ul>\n</blockquote>\n<p>Note that the phrase \"<em>the program is\n ill-formed if the corresponding non-reference copy-initialization\n would be ill-formed</em>\" may imply that as</p>\n<pre><code>B b;\nA a = b;\n</code></pre>\n<p>is ill-formed, the program is ill-formed. I believe this to be a defect or vagueness in the wording though, and not the reason that GCC does not accept the code. Assuredly the wording solely aims at the initialization itself, not the fact that a most-derived object of type <code>T1</code> (aka <code>A</code>) can be created in the first place.<br>\nFinally 13.3.1.4 accepts our conversion function:</br></p>\n<blockquote>\n<p id=\"so_27675893_27676077_4\">Assuming that \u201c<em>cv1</em> <code>T</code>\u201d is the type of the object being initialized,\n  with <code>T</code> a class type, the candidate functions are selected as\n  follows:</p>\n<ul>\n<li>The converting constructors (12.3.1) of <code>T</code> are candidate functions.</li>\n<li>When the type of the initializer expression is a class type \u201c<em>cv</em> <code>S</code>\u201d, the non-explicit conversion functions of <code>S</code> and its base\n  classes are considered. [..]. <strong>Those that are not hidden within <code>S</code>\n  and yield a type whose cv-unqualified version</strong> is the same type as\n  <code>T</code> or <strong>is a derived class thereof are candidate functions.</strong></li>\n</ul>\n</blockquote>\n<p>Now the last question is whether in</p>\n<pre><code>A const&amp; ref(Ad());\n</code></pre>\n<p><code>ref</code> is bound directly. And it is.<br>\nThus the original parameter reference binds directly, and no most-derived object of type <code>A</code> must be created.<br>\nWhat GCC presumably thinks is that a temporary of type <code>A</code> must be initialized and the reference be bound to that temporary. Or it pedantically follows the above defected wording, which is very unlikely.</br></br></p>\n<hr>\n<p>1)</p></hr>\n<blockquote>\n<p id=\"so_27675893_27676077_5\">Given types \u201c<em>cv1</em> <code>T1</code>\u201d and \u201c<em>cv2</em> <code>T2</code>,\u201d \u201c<em>cv1</em> <code>T1</code>\u201d is reference-related to\n  \u201c<em>cv2</em> <code>T2</code>\u201d if <code>T1</code> is the same type as <code>T2</code>, <strong>or <code>T1</code> is a base class of <code>T2</code></strong>.\n  \u201c<em>cv1</em> <code>T1</code>\u201d is reference-compatible with \u201c<em>cv2</em> <code>T2</code>\u201d if <code>T1</code> is\n  reference-related to <code>T2</code> and <em>cv1</em> is the same cv-qualification as, <strong>or\n  greater cv-qualification than, <em>cv2</em>.</strong></p>\n</blockquote>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-12-28T12:31:00.003", "Score": "9", "CreationDate": "2014-12-28T11:43:51.943", "ParentId": "27675893", "CommentCount": "3", "OwnerUserId": "3647361", "LastEditDate": "2014-12-28T12:31:00.003"}, "27675893": {"ViewCount": "432", "Body": "<p>I've encountered a problem with implicit conversion in C++. The following is a minimal example:</p>\n<pre><code>struct A {\n  virtual void f()=0; // abstract\n};\n\nstruct Ad : A {\n  virtual void f() {} // not abstract\n};\n\nstruct B {\n  operator Ad () const { return Ad(); }\n};\n\nvoid test(A const &amp;lhs) {}\n\nint main()\n{\n  B b;\n  test(b);\n}\n</code></pre>\n<p>What I would like the compiler to do is: convert b to a variable of type Ad (using the conversion defined in B) and pass the result to <em>test</em>. However, the above code does not compile in GCC (with C++11 enabled), the result being <em>Cannot allocate an object of abstract type 'A'</em>.</p>\n<p>Some things to note:</p>\n<ol>\n<li>Clang compiles this.</li>\n<li>If you make A non-abstract by changing <code>f()=0;</code> to <code>f() {}</code>, the code works just fine.</li>\n<li>The compiler does find the conversion operator (as indicated by 2), but it doesn't do what I'd like it to do.</li>\n</ol>\n", "AcceptedAnswerId": "27676077", "Title": "(GCC bug?) Implicit conversion to a derived class", "CreationDate": "2014-12-28T11:17:08.550", "Id": "27675893", "CommentCount": "7", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2014-12-28T12:03:08.547", "LastEditorUserId": "341065", "LastActivityDate": "2014-12-28T12:31:00.003", "Score": "17", "OwnerUserId": "4399500", "Tags": "<c++><class><gcc><type-conversion><abstract-class>", "AnswerCount": "1"}});