post_cb({"27620277": {"CommentCount": "5", "ViewCount": "293", "PostTypeId": "1", "LastEditorUserId": "457598", "CreationDate": "2014-12-23T12:21:39.660", "LastActivityDate": "2015-07-20T08:41:30.630", "Title": "msvc is_copy_assignable always true?", "AcceptedAnswerId": "27620766", "LastEditDate": "2014-12-23T12:30:08.350", "Id": "27620277", "Score": "4", "Body": "<pre><code>#include &lt;type_traits&gt;\n\nclass Test\n{\npublic:\n    Test(const Test &amp;) = delete;\n    Test &amp;operator=(const Test &amp;) = delete;\n};\n\nvoid fn(Test &amp;a, const Test &amp;b) { a = b; }\n\nstatic_assert(!std::is_copy_assignable&lt;Test&gt;::value, \"Test shouldn't be assignable\");\n</code></pre>\n<p>Compiling this under MSVC 2013 Update 3 unexpectedly fails the <code>static_assert</code>, and the function <code>fn</code> fails to compile (as expected.) This is contradictory, right?</p>\n<p>Am I misusing <code>is_copy_assignable</code>? Is there another way to test for this condition?</p>\n", "Tags": "<c++><visual-c++><c++11><visual-studio-2013>", "OwnerUserId": "457598", "AnswerCount": "2"}, "27620766": {"ParentId": "27620277", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>You are correct this is a bug: <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/819202/std-is-assignable-and-std-is-constructible-give-wrong-value-for-deleted-members\" rel=\"nofollow\">https://connect.microsoft.com/VisualStudio/feedback/details/819202/std-is-assignable-and-std-is-constructible-give-wrong-value-for-deleted-members</a></p>\n<p>I took cplusplus.com's <a href=\"http://www.cplusplus.com/reference/type_traits/is_copy_assignable/\" rel=\"nofollow\"><code>is_copy_assignable</code></a> code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nstruct A { };\nstruct B { B&amp; operator= (const B&amp;) = delete; };\n\nint main() {\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; \"is_copy_assignable:\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"int: \" &lt;&lt; std::is_copy_assignable&lt;int&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"A: \" &lt;&lt; std::is_copy_assignable&lt;A&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"B: \" &lt;&lt; std::is_copy_assignable&lt;B&gt;::value &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>And tested it on Visual Studio 2013 and got:</p>\n<blockquote>\n<p id=\"so_27620277_27620766_0\">is_copy_assignable:<br>\n  int: true<br>\n  A: true<br>\n  B: true</br></br></br></p>\n</blockquote>\n<p>On <a href=\"http://ideone.com/1FQVe5\" rel=\"nofollow\">gcc 4.8.1</a> I got:</p>\n<blockquote>\n<p id=\"so_27620277_27620766_1\">is_copy_assignable:<br>\n  int: true<br>\n  A: true<br>\n  B: false</br></br></br></p>\n</blockquote>\n<p>Notably on the Visual Studio 2015 Beta this is fixed. I get:</p>\n<blockquote>\n<p id=\"so_27620277_27620766_2\">is_copy_assignable:<br>\n  int: true<br>\n  A: true<br>\n  B: false</br></br></br></p>\n</blockquote>\n<p>How do you feel about betas ;)</p>\n", "OwnerUserId": "2642059", "LastEditorUserId": "2642059", "LastEditDate": "2015-03-09T01:41:32.023", "Id": "27620766", "Score": "3", "CreationDate": "2014-12-23T12:51:11.580", "LastActivityDate": "2015-03-09T01:41:32.023"}, "bq_ids": {"n4140": {"so_27620277_27620766_2": {"section_id": 1532, "quality": 0.8, "length": 4}, "so_27620277_27620766_1": {"section_id": 1532, "quality": 0.8, "length": 4}, "so_27620277_27620766_0": {"section_id": 1532, "quality": 0.8, "length": 4}}, "n3337": {"so_27620277_27620766_2": {"section_id": 1526, "quality": 0.8, "length": 4}, "so_27620277_27620766_1": {"section_id": 1526, "quality": 0.8, "length": 4}, "so_27620277_27620766_0": {"section_id": 1526, "quality": 0.8, "length": 4}}, "n4659": {"so_27620277_27620766_2": {"section_id": 1682, "quality": 0.8, "length": 4}, "so_27620277_27620766_0": {"section_id": 1682, "quality": 0.8, "length": 4}, "so_27620277_27620766_1": {"section_id": 1682, "quality": 0.8, "length": 4}}}, "31512108": {"ParentId": "27620277", "CommentCount": "0", "Body": "<p>May be a bit too late, but I have a workaround here: define another copy-and-move assignment operator, also as a deleted one. The compiler gives a warning, complaining about multiple copy operators (C4522), so you have to disable it for the class:</p>\n<pre><code>#pragma warning (disable: 4522)\nclass A\n{\n    A&amp; operator=(const A&amp;) = delete;\n    A&amp; operator=(A) = delete;\n};\n#pragma warning (default: 4522)\n</code></pre>\n<p>Now <code>std::is_copy_assignable&lt;A&gt;::value</code> is <code>false</code>. </p>\n", "OwnerUserId": "5008129", "PostTypeId": "2", "Id": "31512108", "Score": "1", "CreationDate": "2015-07-20T08:41:30.630", "LastActivityDate": "2015-07-20T08:41:30.630"}});