post_cb({"25672839": {"ParentId": "25664848", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>To re-iterate, type-punning through unions is perfectly fine in C (but not in C++). In contrast, using pointer casts to do so violates C99 strict aliasing and is problematic because different types may have different alignment requirements and you could raise a SIGBUS if you do it wrong. With unions, this is never a problem.</p>\n<p>The relevant quotes from the C standards are:</p>\n<p>C89 section 3.3.2.3 \u00a75:</p>\n<blockquote>\n<p id=\"so_25664848_25672839_0\">if a member of a union object is accessed after a value has been stored in a different member of the object, the behavior is implementation-defined</p>\n</blockquote>\n<p>C11 section 6.5.2.3 \u00a73:</p>\n<blockquote>\n<p id=\"so_25664848_25672839_1\">A postfix expression followed by the . operator and an identifier designates a member of a structure or union object. The value is that of the named member</p>\n</blockquote>\n<p>with the following footnote 95:</p>\n<blockquote>\n<p id=\"so_25664848_25672839_2\">If the member used to read the contents of a union object is not the same as the member last used to store a value in the object, the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type as described in 6.2.6 (a process sometimes called \u2018\u2018type punning\u2019\u2019). This might be a trap representation.</p>\n</blockquote>\n<p>This should be perfectly clear. </p>\n<hr>\n<p>James is confused because C11 section 6.7.2.1 \u00a716 reads</p>\n<blockquote>\n<p id=\"so_25664848_25672839_3\">The value of at most one of the members can be stored in a union object at any time.</p>\n</blockquote>\n<p>This seems contradictory, but it is not: In contrast to C++, in C, there is no concept of active member and it's perfectly fine to access the single stored value through an expression of an incompatible type.</p>\n<p>See also C11 annex J.1 \u00a71:</p>\n<blockquote>\n<p id=\"so_25664848_25672839_4\">The values of bytes that correspond to union members other than the one last stored into [are unspecified].</p>\n</blockquote>\n<p>In C99, this used to read</p>\n<blockquote>\n<p id=\"so_25664848_25672839_5\">The value of a union member other than the last one stored into [is unspecified]</p>\n</blockquote>\n<p>This was incorrect. As the annex isn't normative, it did not rate its own TC and had to wait until the next standard revision to get fixed.</p>\n<hr>\n<p>GNU extensions to standard C++ (and to C90) <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Type%2Dpunning\" rel=\"noreferrer\">do explicitly allow type-punning with unions</a>.  Other compilers that don't support GNU extensions may also support union type-punning, but it's not part of the base language standard.</p>\n</hr></hr>", "OwnerUserId": "48015", "LastEditorUserId": "224132", "LastEditDate": "2016-09-20T05:19:14.430", "Id": "25672839", "Score": "18", "CreationDate": "2014-09-04T18:40:41.333", "LastActivityDate": "2016-09-20T05:19:14.430"}, "31080901": {"ParentId": "25664848", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Unions original purpose was to save space when you want to be able to be able to represent different types, what we call a <a href=\"http://en.wikipedia.org/wiki/Variant_type\" rel=\"nofollow noreferrer\">variant type</a> see <a href=\"http://www.boost.org/doc/libs/1_58_0/doc/html/variant.html\" rel=\"nofollow noreferrer\">Boost.Variant</a> as a good example of this.</p>\n<p>The other common use is <a href=\"http://en.wikipedia.org/wiki/Type_punning\" rel=\"nofollow noreferrer\">type punning</a> the validity of this is debated but practically most compiler support it, we can see that <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Type-punning\" rel=\"nofollow noreferrer\">gcc documents its support</a>:</p>\n<blockquote>\n<p id=\"so_25664848_31080901_0\">The practice of reading from a different union member than the one most recently written to (called \u201ctype-punning\u201d) is common. Even with -fstrict-aliasing, type-punning is allowed, provided the memory is accessed through the union type. So, the code above works as expected.</p>\n</blockquote>\n<p>note it says <em>even with -fstrict-aliasing, type-punning is allowed</em> which indicates there is an aliasing issue at play.</p>\n<p>Pascal Cuoq has argued that <a href=\"https://stackoverflow.com/questions/2310483/purpose-of-unions-in-c-and-c#comment26826326_2313676\">defect report 283</a> clarified this was allowed in C. <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_283.htm\" rel=\"nofollow noreferrer\">Defect report 283</a> added the following footnote as clarification:</p>\n<blockquote>\n<p id=\"so_25664848_31080901_1\">If the member used to access the contents of a union object is not the same as the member last used to store a value in the object, the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type as described in 6.2.6 (a process sometimes called \"type punning\"). This might be a trap representation.</p>\n</blockquote>\n<p>in C11 that would be footnote <code>95</code>. </p>\n<p>Although in the <code>std-discussion</code> mail group topic <a href=\"https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/awr9tXpZY1I\" rel=\"nofollow noreferrer\">Type Punning via a Union</a> the argument is made this is underspecified, which seems reasonable since <code>DR 283</code> did not add new normative wording, just a footnote:</p>\n<blockquote>\n<p id=\"so_25664848_31080901_2\">This is, in my opinion, an underspecified semantic quagmire in C.\n  Consensus has not been reached between implementors and the C\n  committee as to exactly which cases have defined behavior and which do\n  not[...]</p>\n</blockquote>\n<p>In C++ <a href=\"https://stackoverflow.com/q/11373203/1708801\">it is unclear whether is defined behavior or not</a>.</p>\n<p>This discussion also covers at least one reason why allowing type punning through a union is undesirable:</p>\n<blockquote>\n<p id=\"so_25664848_31080901_3\">[...]the C standard's rules break the type-based alias\n  analysis optimizations which current implementations perform. </p>\n</blockquote>\n<p>it breaks some optimizations. The second argument against this is that using memcpy should generate identical code and is does not break optimizations and well defined behavior, for example this:</p>\n<pre><code>std::int64_t n;\nstd::memcpy(&amp;n, &amp;d, sizeof d);\n</code></pre>\n<p>instead of this:</p>\n<pre><code>union u1\n{\n  std::int64_t n;\n  double d ;\n} ;\n\nu1 u ;\nu.d = d ;\n</code></pre>\n<p>and we can see <a href=\"https://godbolt.org/g/JN7nK4\" rel=\"nofollow noreferrer\">using godbolt this does generate identical code</a> and the argument is made if your compiler does not generate identical code it should be considered a bug:</p>\n<blockquote>\n<p id=\"so_25664848_31080901_4\">If this is true for your implementation, I suggest you file a bug on it. Breaking real optimizations (anything based on type-based alias analysis) in order to work around performance issues with some particular compiler seems like a bad idea to me.</p>\n</blockquote>\n<p>The blog post <a href=\"http://blog.regehr.org/archives/959\" rel=\"nofollow noreferrer\">Type Punning, Strict Aliasing, and Optimization</a> also comes to a similar conclusion.</p>\n<p>The undefined behavior mailing list discussion: <a href=\"http://www.open-std.org/pipermail/ub/2013-July/000071.html\" rel=\"nofollow noreferrer\">Type punning to avoid copying</a> covers a lot of the same ground and we can see how grey the territory can be.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:18:20.013", "Id": "31080901", "Score": "9", "CreationDate": "2015-06-26T19:37:59.140", "LastActivityDate": "2017-02-15T08:27:34.810"}, "25664954": {"ParentId": "25664848", "CommentCount": "16", "Body": "<p>It's legal in C99:</p>\n<p>From the standard:\n<strong>6.5.2.3 Structure and union members</strong></p>\n<blockquote>\n<p id=\"so_25664848_25664954_0\">If the member used to access the contents of a union object is not the\n  same as the member last used to store a value in the object, the\n  appropriate part of the object representation of the value is\n  reinterpreted as an object representation in the new type as described\n  in 6.2.6 (a process sometimes called \"type punning\"). This might be a\n  trap representation.</p>\n</blockquote>\n", "OwnerUserId": "1606345", "PostTypeId": "2", "Id": "25664954", "Score": "5", "CreationDate": "2014-09-04T12:01:06.350", "LastActivityDate": "2014-09-04T12:01:06.350"}, "25666515": {"ParentId": "25664848", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>There are (or at least were, back in C90) two modivations for\nmaking this undefined behavior.  The first was that a compiler\nwould be allowed to generate extra code which tracked what was\nin the union, and generated a signal when you accessed the wrong\nmember.  In practice, I don't think any one ever did (maybe\nCenterLine?).  The other was the optimization possibilities this\nopened up, and these are used.  I have used compilers which\nwould defer a write until the last possible moment, on the\ngrounds that it might not be necessary (because the variable\ngoes out of scope, or there is a subsequent write of a different\nvalue).  Logically, one would expect that this optimization\nwould be turned off when the union was visible, but it wasn't in\nthe earliest versions of Microsoft C. </p>\n<p>The issues of type punning are complex.  The C committee (back\nin the late 1980's) more or less took the position that you\nshould use casts (in C++, reinterpret_cast) for this, and not\nunions, although both techniques were widespread at the time.\nSince then, some compilers (g++, for example) have taken the\nopposite point of view, supporting the use of unions, but not\nthe use of casts.  And in practice, neither work if it is not\nimmediately obvious that there is type-punning.  This might be\nthe motivation behind g++'s point of view.  If you access\na union member, it is immediately obvious that there might be\ntype-punning.  But of course, given something like:</p>\n<pre><code>int f(const int* pi, double* pd)\n{\n    int results = *pi;\n    *pd = 3.14159;\n    return results;\n}\n</code></pre>\n<p>called with:</p>\n<pre><code>union U { int i; double d; };\nU u;\nu.i = 1;\nstd::cout &lt;&lt; f( &amp;u.i, &amp;u.d );\n</code></pre>\n<p>is perfectly legal according to the strict rules of the\nstandard, but fails with g++ (and probably many other\ncompilers); when compiling <code>f</code>, the compiler assumes that <code>pi</code>\nand <code>pd</code> can't alias, and reorders the write to <code>*pd</code> and the\nread from <code>*pi</code>.  (I believe that it was never the intent that\nthis be guaranteed.  But the current wording of the standard\ndoes guarantee it.)</p>\n<p>EDIT:</p>\n<p>Since other answers have argued that the behavior is in fact\ndefined (largely based on quoting a non-normative note, taken\nout of context):</p>\n<p>The correct answer here is that of pablo1977: the standard makes\nno attempt to define the behavior when type punning is involved.\nThe probable reason for this is that there is no portable\nbehavior that it could define.  This does not prevent a specific\nimplementation from defining it; although I don't remember any\nspecific discussions of the issue, I'm pretty sure that the\nintent was that implementations define something (and most, if\nnot all, do).</p>\n<p>With regards to using a union for type-punning: when the\nC committee was developing C90 (in the late 1980's), there was\na clear intent to allow debugging implementations which did\nadditional checking (such as using fat pointers for bounds\nchecking).  From discussions at the time, it was clear that the\nintent was that a debugging implementation might cache\ninformation concerning the last value initialized in a union,\nand trap if you tried to access anything else.  This is clearly\nstated in \u00a76.7.2.1/16: \"The value of at most one of the members\ncan be stored in a union object at any time.\"  Accessing a value\nthat isn't there is undefined behavior; it can be assimilated to\naccessing an uninitialized variable.  (There were some\ndiscussions at the time as to whether accessing a different\nmember with the same type was legal or not.  I don't know what\nthe final resolution was, however; after around 1990, I moved on\nto C++.)</p>\n<p>With regards to the quote from C89, saying the behavior is\nimplementation-defined: finding it in section 3 (Terms,\nDefinitions and Symbols) seems very strange.  I'll have to look\nit up in my copy of C90 at home; the fact that it has been\nremoved in later versions of the standards suggests that its\npresence was considered an error by the committee.</p>\n<p>The use of unions which the standard supports is as a means to\nsimulate derivation.  You can define:</p>\n<pre><code>struct NodeBase\n{\n    enum NodeType type;\n};\n\nstruct InnerNode\n{\n    enum NodeType type;\n    NodeBase* left;\n    NodeBase* right;\n};\n\nstruct ConstantNode\n{\n    enum NodeType type;\n    double value;\n};\n//  ...\n\nunion Node\n{\n    struct NodeBase base;\n    struct InnerNode inner;\n    struct ConstantNode constant;\n    //  ...\n};\n</code></pre>\n<p>and legally access base.type, even though the Node was\ninitialized through <code>inner</code>.  (The fact that \u00a76.5.2.3/6 starts\nwith \"One special guarantee is made...\" and goes on to\nexplicitly allow this is a very strong indication that all other\ncases are meant to be undefined behavior.  And of course, there\nis the statement that \"Undefined behavior is otherwise indicated\nin this International Standard by the words \u2018\u2018undefined\nbehavior\u2019\u2019 or <em>by the omission of any explicit definition of\nbehavior</em>\" in \u00a74/2; in order to argue that the behavior is not\nundefined, you have to show where it is defined in the standard.)</p>\n<p>Finally, with regards to type-punning: all (or at least all that\nI've used) implementations do support it in some way.  My\nimpression at the time was that the intent was that pointer\ncasting be the way an implementation supported it; in the C++\nstandard, there is even (non-normative) text to suggest that the\nresults of a <code>reinterpret_cast</code> be \"unsurprising\" to someone\nfamiliar with the underlying architecture.  In practice,\nhowever, most implementations support the use of union for\ntype-punning, provided the access is through a union member.\nMost implementations (but not g++) also support pointer casts,\nprovided the pointer cast is clearly visible to the compiler\n(for some unspecified definition of pointer cast).  And the\n\"standardization\" of the underlying hardware means that things\nlike:</p>\n<pre><code>int\ngetExponent( double d )\n{\n    return ((*(uint64_t*)(&amp;d) &gt;&gt; 52) &amp; 0x7FF) + 1023;\n}\n</code></pre>\n<p>are actually fairly portable.  (It won't work on mainframes, of\ncourse.)  What doesn't work are things like my first example,\nwhere the aliasing is invisible to the compiler.  (I'm pretty\nsure that this is a defect in the standard.  I seem to recall\neven having seen a DR concerning it.)</p>\n", "OwnerUserId": "649665", "LastEditorUserId": "649665", "LastEditDate": "2014-09-05T08:54:10.830", "Id": "25666515", "Score": "2", "CreationDate": "2014-09-04T13:15:05.903", "LastActivityDate": "2014-09-05T08:54:10.830"}, "25664848": {"CommentCount": "4", "AcceptedAnswerId": "25672839", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2014-09-04T11:56:08.293", "LastActivityDate": "2017-02-15T08:27:34.810", "LastEditDate": "2014-09-04T21:11:36.297", "ViewCount": "4671", "FavoriteCount": "10", "Title": "Unions and type-punning", "Id": "25664848", "Score": "25", "Body": "<p>I've been searching for a while, but can't find a clear answer.</p>\n<p>Lots of people say that using unions to type-pun is undefined and bad practice. Why is this? I can't see any reason why it would do anything undefined considering the memory you write the original information to isn't going to just change of its own accord (unless it goes out of scope on the stack, but that's not a union issue, that would be bad design).</p>\n<p>People quote the strict aliasing rule, but that seems to me to be like saying you can't do it because you can't do it.</p>\n<p>Also what is the point of a union if not to type pun? I saw somewhere that they are supposed to be used to use the same memory location for different information at different times, but why not just delete the info before using it again?</p>\n<p>To summarise:</p>\n<ol>\n<li>Why is it bad to use unions for type punning?</li>\n<li>What it the point of them if not this?</li>\n</ol>\n<p>Extra information: I'm using mainly C++, but would like to know about that and C. Specifically I'm using unions to convert between floats and the raw hex to send via CAN bus.</p>\n", "Tags": "<c++><c><unions><type-punning>", "OwnerUserId": "1756378", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_25664848_25672839_3": {"section_id": 5913, "quality": 0.8, "length": 8}, "so_25664848_25672839_5": {"section_id": 5313, "quality": 0.5454545454545454, "length": 6}}, "n3337": {"so_25664848_25672839_3": {"section_id": 5685, "quality": 0.8, "length": 8}, "so_25664848_25672839_5": {"section_id": 5110, "quality": 0.5454545454545454, "length": 6}}, "n4659": {"so_25664848_25672839_3": {"section_id": 7404, "quality": 0.8, "length": 8}, "so_25664848_25672839_5": {"section_id": 6737, "quality": 0.5454545454545454, "length": 6}}}, "25668287": {"ParentId": "25664848", "PostTypeId": "2", "CommentCount": "3", "Body": "<p><strong>BRIEF ANSWER:</strong> <strong>Type punning</strong> can be safe in a few circumstances. On the other hand, although it seems to be a very well known practice, it seems that standard is not very interested in make it official.  </p>\n<p>I will talk only about <strong>C</strong> (not C++).  </p>\n<p><strong>1. TYPE PUNNING and THE STANDARDS</strong> </p>\n<p>As folks already pointed but, <strong>type punning</strong> is allowed in the standard C99 and also C11, in subsection <strong>6.5.2.3</strong>. However, I will rewrite facts with my own perception of the issue:  </p>\n<ul>\n<li>The section <strong>6.5</strong> of standard documents C99 and C11 develop the topic of <strong>expressions</strong>.  </li>\n<li>The subsection <strong>6.5.2</strong> is referred to <strong>postfix expressions</strong>.  </li>\n<li>The subsubsection <strong>6.5.2.3</strong> talks about <strong>structs and unions</strong>.  </li>\n<li>The paragraph <strong>6.5.2.3(3)</strong> explains the <strong>dot operator</strong> applied to a <code>struct</code> or <code>union</code> object, and which value will be obtained.<br>\n Just there, the <strong>footnote 95</strong> appears. This footnote says:  </br></li>\n</ul>\n<blockquote>\n<p id=\"so_25664848_25668287_0\">If the member used to access the contents of a union object is not the same as the member last used to store a value in the object, the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type as described in 6.2.6 (a process sometimes called \"type punning\"). This might be a trap representation.  </p>\n</blockquote>\n<p>The fact that <strong>type punning</strong> barely appears, and as a footnote, it gives a clue that it's not a relevant issue in C programming.<br>\nActually, <strong>the main purpose for using <code>unions</code> is for saving space</strong> (in memory). Since several members are sharing the same address, if one knows that each member will be used different parts of the program, never at the same time, then a <code>union</code> can be used instead a <code>struct</code>, for saving memory.  </br></p>\n<ul>\n<li>The subsection <strong>6.2.6</strong> is mentioned.  </li>\n<li>The subsection <strong>6.2.6</strong> talks about how objects are represented (in memory, say).  </li>\n</ul>\n<p><strong>2. REPRESENTATION OF TYPES and ITS TROUBLE</strong></p>\n<p>If you pay attention to the different aspects of the standard, you can be sure of almost nothing:  </p>\n<ul>\n<li>The representation of pointers is not clearly specified.  </li>\n<li>Worst, pointers having different types could have a different representation (as objects in memory).  </li>\n<li><code>union</code> members share the same heading address in memory, and it's the same address that of the <code>union</code> object itself.  </li>\n<li><code>struct</code> members have increasing relative address, by starting in exactly the same memory address that of the <code>struct</code> object itself. However, padding bytes can be added at the end of every member. How many? It's unpredictable. Padding bytes are used mainly for memory allignment purposes.   </li>\n<li>Arithmetical types (integers, floating point real and complex numbers) could be representable in a number of ways. It depends on the implementation.  </li>\n<li>In particular, integer types could have <strong>padding bits</strong>. This is not true, I believe, for desktop computers. However the standard left the door open for this possibility. Padding bits are used for spetial purposes (parity, signals, who knows), and not for holding mathematical values.  </li>\n<li><code>signed</code> types can have 3 manners of being represented: 1's complement, 2's complement, just sign-bit.</li>\n<li>The <code>char</code> types occupy just 1 byte, but 1 byte can have a number of bits different of 8 (but never less than 8).  </li>\n<li><p>However we can be sure about some details:  </p>\n<p>a. The <code>char</code> types have not padding bits.<br>\n b. The <code>unsigned</code> integer types are represented exactly as in binary form.<br>\n c. <code>unsigned char</code> occupies exactly 1 byte, without padding bits, and there is not any trap representation because all the bits are used. Moreover, it represents a value without any ambiguity, following the binary format for integer numbers.  </br></br></p></li>\n</ul>\n<p><strong>3. TYPE PUNNING vs TYPE REPRESENTATION</strong> </p>\n<p>All these observations reveals that, if we try to do <strong>type punning</strong> with <code>union</code> members having types different of <code>unsigned char</code>, we could have a lot of ambiguity. It's not portable code and, in particular, we could have umpredictable behaviour of our program.<br>\nHowever, <strong>the standard allows this kind of access</strong>.  </br></p>\n<p>Even if we are sure about the specific manner in that every type is represented in our implementation, we could have a sequence of bits meaning nothing at all in other types (<strong>trap representation</strong>). We cannot do anything in this case.  </p>\n<p><strong>4. THE SAFE CASE: unsigned char</strong> </p>\n<p>The only safe manner of using <strong>type punning</strong> is with <code>unsigned char</code> or well <code>unsigned char</code> arrays (because we know that members of array objects are strictly contiguous and there is not any padding bytes when their size is computed with <code>sizeof()</code>).  </p>\n<pre><code>  union {\n     TYPE data;\n     unsigned char type_punning[sizeof(TYPE)];\n  } xx;  \n</code></pre>\n<p>Since we know that <code>unsigned char</code> is represented in strict binary form, without padding bits, the type punning can be used here to take a look to the binary represention of the member <code>data</code>.<br>\nThis tool can be used to analyze how values of a given type are represented, in a particular implementation.  </br></p>\n<p>I am not able to see another safe and useful application of <strong>type punning</strong> under the standard specifications.  </p>\n<p><strong>5. A COMMENT ABOUT CASTS...</strong> </p>\n<p>If one wants to play with types, it's better to define your own transformation functions, or well just use <strong>casts</strong>. We can remember this simple example:  </p>\n<pre><code>  union {\n     unsigned char x;  \n     double t;\n  } uu;\n\n  bool result;\n\n  uu.x = 7;\n  (uu.t == 7.0)? result = true: result = false;\n  // You can bet that result == false\n\n  uu.t = (double)(uu.x);\n  (uu.t == 7.0)? result = true: result = false;\n  // result == true\n</code></pre>\n", "OwnerUserId": "2698605", "LastEditorUserId": "2698605", "LastEditDate": "2014-09-04T14:43:08.593", "Id": "25668287", "Score": "3", "CreationDate": "2014-09-04T14:37:17.510", "LastActivityDate": "2014-09-04T14:43:08.593"}});