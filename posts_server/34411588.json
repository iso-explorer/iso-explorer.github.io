post_cb({"34412317": {"ParentId": "34411588", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-12-22T09:21:12.587", "Score": "5", "LastEditorUserId": "567292", "LastEditDate": "2015-12-22T10:10:04.910", "Id": "34412317", "OwnerUserId": "567292", "Body": "<p>The problem is that a using-declaration does not count as a user-declared assignment operator <strong>[namespace.udecl]</strong>:</p>\n<blockquote>\n<p id=\"so_34411588_34412317_0\">4 - [...] If an\n  assignment operator brought from a base class into a derived class scope has the signature of a copy/move\n  assignment operator for the derived class (12.8), the using-declaration does not by itself suppress the implicit\n  declaration of the derived class assignment operator [...]</p>\n</blockquote>\n<p>(In any case, <code>using Base::operator=</code> gives you an assignment operator with parameter type <code>Base const&amp;</code>, which is not one of the parameter types qualifying as a copy assignment operator <strong>[class.copy]</strong>/17 - <code>T</code>, <code>T&amp;</code>, <code>T const&amp;</code>, etc.)</p>\n<p>Because <code>Derived</code> does not have a user-declared copy assignment operator, one is generated automatically, which ends up calling <code>IDerived::operator=</code> which calls <code>IBase::operator=</code>. Note that automatically-generated copy assignment operators call subobject copy assignment operators ignoring virtual overrides:</p>\n<blockquote>\n<p id=\"so_34411588_34412317_1\">Each subobject is assigned in the manner\n  appropriate to its type:</p>\n<ul>\n<li>if the subobject is of class type, as if by a call to <code>operator=</code> with the subobject as the object expression\n  and the corresponding subobject of <code>x</code> as a single function argument (as if by explicit qualification; that\n  is, ignoring any possible virtual overriding functions in more derived classes); [...]</li>\n</ul>\n</blockquote>\n<p>A fix would be to write:</p>\n<pre><code>    Base&amp; operator=(Derived const&amp; other) { return Base::operator=(other); }\n</code></pre>\n<p>Note that MSVC 2015 rejects your code but works with the above fix:</p>\n<pre><code>main.cpp(36): warning C4250: 'Derived': inherits 'Base::Base::operator =' via dominance\nmain.cpp(14): note: see declaration of 'Base::operator ='\nmain.obj : error LNK2019: unresolved external symbol \"public: virtual class IBase &amp; __thiscall IBase::operator=(class IBase const &amp;)\" (??4IBase@@UAEAAV0@ABV0@@Z) referenced in function \"public: class IDerived &amp; __thiscall IDerived::operator=(class IDerived const &amp;)\" (??4IDerived@@QAEAAV0@ABV0@@Z)\nmain.exe : fatal error LNK1120: 1 unresolved externals\n</code></pre>\n", "LastActivityDate": "2015-12-22T10:10:04.910"}, "bq_ids": {"n4140": {"so_34411588_34412317_1": {"section_id": 477, "quality": 1.0, "length": 7}, "so_34411588_34412317_0": {"section_id": 5493, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_34411588_34412317_1": {"section_id": 468, "quality": 1.0, "length": 7}, "so_34411588_34412317_0": {"section_id": 5279, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_34411588_34412317_1": {"section_id": 500, "quality": 1.0, "length": 7}, "so_34411588_34412317_0": {"section_id": 6927, "quality": 0.9230769230769231, "length": 24}}}, "34411588": {"CommentCount": "0", "ViewCount": "186", "CreationDate": "2015-12-22T08:38:23.500", "LastActivityDate": "2015-12-22T10:10:04.910", "Title": "Clang linker error when overloading abstract operator=", "FavoriteCount": "1", "PostTypeId": "1", "Id": "34411588", "Score": "6", "Body": "<p>The VisualStudio 2013 compiler handles the following code just fine, but clang 5.0 and 6.2 gives me a linker error:</p>\n<pre><code>#include &lt;memory&gt;\n\nusing namespace::std;\n\nclass IBase\n{\npublic:\n    virtual IBase&amp; operator=(const IBase&amp; other) = 0;\n};\n\nclass Base : virtual public IBase\n{\npublic:\n    Base&amp; operator=(const IBase&amp; other) override\n    {\n        const Base&amp; b = dynamic_cast&lt;const Base&amp;&gt;(other);\n        return *this = b;\n    }\n\n    virtual Base&amp; operator=(const Base&amp; other)\n    {\n        return *this;\n    }\n};\n\nclass IDerived : virtual public IBase\n{\n};\n\nclass Derived : public IDerived, public Base\n{\npublic:\n    using Base::operator=;\n\n};\n\nint main(int argc, const char * argv[]) {\n    shared_ptr&lt;Derived&gt; d1 = make_shared&lt;Derived&gt;();\n    shared_ptr&lt;Derived&gt; d2 = make_shared&lt;Derived&gt;();\n    *d2 = *d1;\n}\n</code></pre>\n<p>Here's the build log output:</p>\n<pre><code>Ld /Users/Jennifer/Library/Developer/Xcode/DerivedData/Operator-bjjgcoxcziyegjgmazknrandutqz/Build/Products/Debug/Oper normal x86_64\n    cd /Users/Jennifer/Documents/Operator\n    export MACOSX_DEPLOYMENT_TARGET=10.9\n    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ -arch x86_64 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk -L/Users/Jennifer/Library/Developer/Xcode/DerivedData/Operator-bjjgcoxcziyegjgmazknrandutqz/Build/Products/Debug -F/Users/Jennifer/Library/Developer/Xcode/DerivedData/Operator-bjjgcoxcziyegjgmazknrandutqz/Build/Products/Debug -filelist /Users/Jennifer/Library/Developer/Xcode/DerivedData/Operator-bjjgcoxcziyegjgmazknrandutqz/Build/Intermediates/Operator.build/Debug/Oper.build/Objects-normal/x86_64/Oper.LinkFileList -mmacosx-version-min=10.9 -stdlib=libc++ -Xlinker -dependency_info -Xlinker /Users/Jennifer/Library/Developer/Xcode/DerivedData/Operator-bjjgcoxcziyegjgmazknrandutqz/Build/Intermediates/Operator.build/Debug/Oper.build/Objects-normal/x86_64/Oper_dependency_info.dat -o /Users/Jennifer/Library/Developer/Xcode/DerivedData/Operator-bjjgcoxcziyegjgmazknrandutqz/Build/Products/Debug/Oper\n\nUndefined symbols for architecture x86_64:\n  \"IBase::operator=(IBase const&amp;)\", referenced from:\n      IDerived::operator=(IDerived const&amp;) in main.o\nld: symbol(s) not found for architecture x86_64\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre>\n<p><code>IBase::operator=(IBase const&amp;)</code> is defined in <code>Base</code> which <code>Derived</code> inherits from, and <code>Derived</code> is <code>using Base::operator=</code> so it <em>should</em> be defined for <code>Derived</code>, not overridden by the default assignment operator. </p>\n<p>One solution I found was to remove the <code>IBase::operator=</code> method, but this is not ideal since it is a method any inheriting class would need to implement.</p>\n<p>Does anyone know what the difference is and how to fix it?  I'd like to keep the <code>IBase::operator=</code> method if possible.</p>\n", "Tags": "<c++><c++11><inheritance><operator-overloading><assignment-operator>", "OwnerUserId": "5706376", "AnswerCount": "1"}});