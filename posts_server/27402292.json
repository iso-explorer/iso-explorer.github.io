post_cb({"27404546": {"ParentId": "27402292", "LastEditDate": "2015-06-27T20:41:39.173", "CommentCount": "0", "CreationDate": "2014-12-10T15:17:41.810", "OwnerUserId": "3953764", "LastEditorUserId": "3953764", "PostTypeId": "2", "Id": "27404546", "Score": "5", "Body": "<blockquote>\n<p id=\"so_27402292_27404546_0\"><em>I read carefully through overload resolution from cppreference I cannot find the rationale for this behavior. Can you point the language rules responsible for this behavior?</em></p>\n</blockquote>\n<p>Before the <em>overload resolution</em> procedure selects the best viable function, an initial set of candidates is generated during the <em>name lookup</em> phase. In other words, the expected behavior should be searched for in the <a href=\"http://en.cppreference.com/w/cpp/language/lookup\" rel=\"nofollow\">Name lookup</a> section, not in the <a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution\" rel=\"nofollow\">Overload resolution</a> one.</p>\n<p>The name lookup procedure for an <em>unqualified name</em> is described in the C++ standard:</p>\n<p>\u00a73.4.1 [basic.lookup.unqual]/p8:</p>\n<blockquote>\n<p id=\"so_27402292_27404546_1\"><strong>A name used in the definition of a member function</strong> (9.3) of class <code>X</code> following the function\u2019s <em>declarator-id</em> or in the <em>brace-or-equal-initializer</em> of a non-static data member (9.2) of class <code>X</code> <strong>shall be declared in one of the following ways:</strong></p>\n<p id=\"so_27402292_27404546_2\">\u2014 before its use in the block in which it is used or in an enclosing block (6.3), or</p>\n<p id=\"so_27402292_27404546_3\">\u2014 shall be a member of class X or be a member of a base class of X (10.2), or</p>\n<p id=\"so_27402292_27404546_4\">\u2014 <strong>if <code>X</code> is a nested class of class <code>Y</code> (9.7), shall be a member of <code>Y</code></strong>, or shall be a member of a base class of <code>Y</code>\n  (this lookup applies in turn to <code>Y</code>\u2019s enclosing classes, starting with the innermost enclosing class), or [...]</p>\n</blockquote>\n<p>and only if still not found:</p>\n<blockquote>\n<p id=\"so_27402292_27404546_5\">\u2014 if <code>X</code> is a member of namespace <code>N</code>, or <strong>is a nested class of a class that is a member of <code>N</code></strong>, or is a local class or a nested class within a local class of a function that is a member of <code>N</code>, before the use of the name, <strong>in namespace <code>N</code></strong> or in one of <code>N</code>'s enclosing namespaces.</p>\n</blockquote>\n<p>Since the name lookup ends as soon as the name is found (\u00a73.4.1 [basic.lookup.unqual]/p1):</p>\n<blockquote>\n<p id=\"so_27402292_27404546_6\">In all the cases listed in 3.4.1, the scopes are searched for a declaration in the order listed in each of the respective categories; name lookup ends as soon as a declaration is found for the name. </p>\n</blockquote>\n<p>in your case no other scopes are searched as soon as <code>int foo() const { return 2; }</code> is encountered.</p>\n<hr>\n<blockquote>\n<p id=\"so_27402292_27404546_7\"><em>Workaround is simple, there is a need to tell compiler that such global function exists:</em></p>\n<pre><code>using Namespace::foo; //&lt; workaround: inform compiler such function exists\n</code></pre>\n<p id=\"so_27402292_27404546_8\"><em>Is that workaround correct?</em></p>\n</blockquote>\n<p>\u00a77.3.3 [namespace.udecl]/p1:</p>\n<blockquote>\n<p id=\"so_27402292_27404546_9\">A <em>using-declaration</em> introduces a name into the declarative region in which the <em>using-declaration</em> appears.</p>\n</blockquote>\n<p>\u00a73.3.1 [basic.scope.declarative]/p1:</p>\n<blockquote>\n<p id=\"so_27402292_27404546_10\">Every name is introduced in some portion of program text called a <em>declarative region</em>, which is the largest part of the program in which that name is <em>valid</em>, that is, in which that name may be used as an unqualified name to refer to the same entity.</p>\n</blockquote>\n<p>Introducing a name with a <em>using-declaration</em> impacts the <em>unqualified name lookup</em> in a way such that it finds that function in its first step, namely that name becomes <em>declared</em>:</p>\n<blockquote>\n<p id=\"so_27402292_27404546_11\">\u2014 before its use in the block in which it is used or in an enclosing block (6.3)</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_27402292_27404546_12\"><em>Are there any better solutions?</em></p>\n</blockquote>\n<p>One can use a <em>qualified name</em> when referring to a function from some namespace scope, explicitly indicating what symbol is being referred to:</p>\n<pre><code>Nested()\n{\n    cout &lt;&lt; Namespace::foo() &lt;&lt; endl;\n}\n</code></pre>\n</hr></hr>", "LastActivityDate": "2015-06-27T20:41:39.173"}, "27404825": {"ParentId": "27402292", "LastEditDate": "2014-12-10T15:58:31.947", "CommentCount": "0", "CreationDate": "2014-12-10T15:31:20.830", "OwnerUserId": "1594913", "LastEditorUserId": "1594913", "PostTypeId": "2", "Id": "27404825", "Score": "4", "Body": "<p>This was indeed about Name Lookup and not about Overload Resolution. </p>\n<p>Indeed, as the standard stipulates, <strong>\u00a73.4.1/1</strong> of N3376 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_27402292_27404825_0\">In all the cases listed in 3.4.1, the scopes are searched for a declaration in the order listed in each of the respective categories; <strong>name lookup ends as soon as a declaration is found for the name.</strong> If no declaration is found, the program is ill-formed.</p>\n</blockquote>\n<p>So in fact, the lookup stops as soon as a declaration is found.</p>\n<p>Then, you can find more about the case you're dealing with in <strong>\u00a73.4.1/8</strong> which deals with names used in class inside a member function definition, especially this part:</p>\n<blockquote>\n<p id=\"so_27402292_27404825_1\">if X is a nested class of class Y (9.7), shall be a member of Y, or shall be a member of a base class of Y (this lookup applies in turn to Y\u2019s enclosing classes, starting with the innermost enclosing class)</p>\n</blockquote>\n<p>And if not found, in enclosing namespaces.</p>\n<p>In your case, that means that <code>Namespace::Class::foo()</code> is the first name found during the lookup, and it stops as soon as it has found a name, so <code>Namespace::foo()</code> isn't even considered.</p>\n<p>The example given by the standard illustrates the lookup path:</p>\n<pre><code>class B { };\nnamespace M {\n    namespace N {\n        class X : public B {\n            void f(); \n        };\n    } \n}\nvoid M::N::X::f() {\n    i = 16;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_27402292_27404825_2\">The following scopes are searched for a declaration of i:</p>\n<p id=\"so_27402292_27404825_3\">1) outermost block scope of M::N::X::f, before the use of i // 2) scope of class M::N::X</p>\n<p id=\"so_27402292_27404825_4\">3) scope of M::N::X\u2019s base class B</p>\n<p id=\"so_27402292_27404825_5\">4) scope of namespace M::N</p>\n<p id=\"so_27402292_27404825_6\">5) scope of namespace M</p>\n<p id=\"so_27402292_27404825_7\">6) global scope, before the definition of M::N::X::f</p>\n</blockquote>\n<p>And as to how you deal with such problem, you have to qualify the call, i.e.</p>\n<pre><code>cout &lt;&lt; Namespace::foo() &lt;&lt; endl;\n</code></pre>\n<p>so that the compiler selects the function you want through qualified lookup.</p>\n", "LastActivityDate": "2014-12-10T15:58:31.947"}, "27407347": {"ParentId": "27402292", "CommentCount": "0", "Body": "<p>Piotr S. and JBL explained the why of your problem.</p>\n<p>IMHO the simpler solution is to use the qualified name of the function :</p>\n<pre><code>public:\n    Nested()\n    {\n        cout &lt;&lt; Namespace::foo() &lt;&lt; endl;\n    }\n</code></pre>\n", "OwnerUserId": "3545273", "PostTypeId": "2", "Id": "27407347", "Score": "2", "CreationDate": "2014-12-10T17:36:07.247", "LastActivityDate": "2014-12-10T17:36:07.247"}, "bq_ids": {"n4140": {"so_27402292_27404546_10": {"section_id": 7044, "quality": 0.9, "length": 18}, "so_27402292_27404546_2": {"section_id": 7094, "quality": 1.0, "length": 6}, "so_27402292_27404825_1": {"section_id": 7093, "quality": 1.0, "length": 16}, "so_27402292_27404546_1": {"section_id": 7092, "quality": 0.5294117647058824, "length": 9}, "so_27402292_27404546_5": {"section_id": 7094, "quality": 1.0, "length": 22}, "so_27402292_27404546_11": {"section_id": 7094, "quality": 1.0, "length": 6}, "so_27402292_27404546_3": {"section_id": 187, "quality": 0.8333333333333334, "length": 5}, "so_27402292_27404825_0": {"section_id": 7087, "quality": 0.9545454545454546, "length": 21}, "so_27402292_27404825_3": {"section_id": 7094, "quality": 0.6666666666666666, "length": 6}, "so_27402292_27404546_6": {"section_id": 7087, "quality": 0.9473684210526315, "length": 18}, "so_27402292_27404546_4": {"section_id": 7093, "quality": 1.0, "length": 16}, "so_27402292_27404546_9": {"section_id": 5490, "quality": 1.0, "length": 8}}, "n3337": {"so_27402292_27404546_10": {"section_id": 6789, "quality": 0.9, "length": 18}, "so_27402292_27404546_2": {"section_id": 6838, "quality": 1.0, "length": 6}, "so_27402292_27404825_1": {"section_id": 6837, "quality": 1.0, "length": 16}, "so_27402292_27404546_1": {"section_id": 6838, "quality": 1.0, "length": 17}, "so_27402292_27404546_4": {"section_id": 6837, "quality": 1.0, "length": 16}, "so_27402292_27404546_3": {"section_id": 181, "quality": 0.8333333333333334, "length": 5}, "so_27402292_27404825_0": {"section_id": 6831, "quality": 0.9545454545454546, "length": 21}, "so_27402292_27404825_3": {"section_id": 6838, "quality": 0.6666666666666666, "length": 6}, "so_27402292_27404546_11": {"section_id": 6838, "quality": 1.0, "length": 6}, "so_27402292_27404546_6": {"section_id": 6831, "quality": 0.9473684210526315, "length": 18}, "so_27402292_27404546_5": {"section_id": 6838, "quality": 1.0, "length": 22}, "so_27402292_27404546_9": {"section_id": 5276, "quality": 1.0, "length": 8}}, "n4659": {"so_27402292_27404546_11": {"section_id": 8595, "quality": 1.0, "length": 6}, "so_27402292_27404546_10": {"section_id": 8541, "quality": 0.9, "length": 18}, "so_27402292_27404546_2": {"section_id": 8595, "quality": 1.0, "length": 6}, "so_27402292_27404825_1": {"section_id": 8594, "quality": 1.0, "length": 16}, "so_27402292_27404546_1": {"section_id": 8594, "quality": 0.5294117647058824, "length": 9}, "so_27402292_27404546_5": {"section_id": 8595, "quality": 1.0, "length": 22}, "so_27402292_27402292_0": {"section_id": 6103, "quality": 0.5555555555555556, "length": 5}, "so_27402292_27404546_3": {"section_id": 192, "quality": 0.8333333333333334, "length": 5}, "so_27402292_27404825_0": {"section_id": 8588, "quality": 0.9545454545454546, "length": 21}, "so_27402292_27404825_3": {"section_id": 8595, "quality": 0.6666666666666666, "length": 6}, "so_27402292_27404546_6": {"section_id": 8588, "quality": 0.9473684210526315, "length": 18}, "so_27402292_27404546_4": {"section_id": 8594, "quality": 1.0, "length": 16}, "so_27402292_27404546_9": {"section_id": 6924, "quality": 0.875, "length": 7}}}, "27402292": {"CommentCount": "2", "CreationDate": "2014-12-10T13:30:27.793", "PostTypeId": "1", "AcceptedAnswerId": "27404546", "LastEditorUserId": "1463922", "LastActivityDate": "2015-06-27T20:41:39.173", "LastEditDate": "2014-12-10T17:10:35.910", "ViewCount": "383", "FavoriteCount": "1", "Title": "Nested class strange function lookup: surrounding class functions hide global functions", "Id": "27402292", "Score": "8", "Body": "<p>I have the following simplified code</p>\n<pre><code>namespace Namespace\n{\nint foo() { return 1; }\n\nclass Class\n{\npublic:\n    int foo() const { return 2; }\n    class Nested {\n    public:\n        Nested()\n        {\n            cout &lt;&lt; foo() &lt;&lt; endl;\n        }\n    };\n};\n}\n</code></pre>\n<p>And I got this error:</p>\n<blockquote>\n<p id=\"so_27402292_27402292_0\">error: cannot call member function \u2018int Namespace::Class::foo() const\u2019\n  without object:</p>\n</blockquote>\n<pre><code> cout &lt;&lt; foo() &lt;&lt; endl;\n         ^^^^^\n</code></pre>\n<p>It seems that compiler selects non static <code>int Namespace::Class::foo() const</code> instead of global function <code>int Namespace::foo()</code>. </p>\n<p>But how can it be expected that non-static function from other class can be called without object? <code>Nested object</code> has no access to surrounding  <code>Class object</code> - this is not Java after all.</p>\n<p>I read carefully through <a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution\" rel=\"nofollow\">overload resolution from cppreference</a> I cannot find the rationale for this behavior. I rather doubt that this is gcc error.</p>\n<ul>\n<li>Can you point the language rules responsible for this behavior?  </li>\n<li>And how do you deal with such problems?</li>\n</ul>\n<h2>[UPDATE]</h2>\n<p>Just an answer for 2nd question. Workaround is simple, there is a need to tell compiler that such global function exists:</p>\n<pre><code>        Nested()\n        {\n            using Namespace::foo; //&lt; workaround: inform compiler such function exists\n            cout &lt;&lt; foo() &lt;&lt; endl;\n        }\n</code></pre>\n<p>BTW, is that workaround correct? Are there any better solutions?</p>\n", "Tags": "<c++><gcc><argument-dependent-lookup>", "OwnerUserId": "1463922", "AnswerCount": "3"}});