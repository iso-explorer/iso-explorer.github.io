post_cb({"20255173": {"CommentCount": "0", "AcceptedAnswerId": "20255756", "PostTypeId": "1", "LastEditorUserId": "725863", "CreationDate": "2013-11-27T23:32:18.033", "LastActivityDate": "2013-11-28T00:44:57.227", "LastEditDate": "2013-11-27T23:49:42.937", "ViewCount": "176", "FavoriteCount": "3", "Title": "Value initialization for classes with exclusively inherited constructors", "Id": "20255173", "Score": "6", "Body": "<p>According to <a href=\"http://en.cppreference.com/w/cpp/language/value_initialization\">cppreference</a> non-union class types without any user-provided constructors will be zero-initialized before being constructed:</p>\n<blockquote>\n<p id=\"so_20255173_20255173_0\">If T is an non-union class type without any user-provided constructors, then the object is zero-initialized and then the implicitly-declared default constructor is called (unless it's trivial)</p>\n</blockquote>\n<p>I'm not sure what should happen when the c++11 inherited constructors are used since the quote explicitly mentions the <strong>implicitly-declared</strong> default constructor.</p>\n<p>Given the following example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n    int a;\n    A() {}\n    A(int i): a(i) {}\n};\n\nstruct B: public A {\n    using A::A;\n};\n\nint main() {\n    B b { 5 };\n    B* p = new (&amp;b) B{ };\n    std::cout &lt;&lt; b.a &lt;&lt; std::endl;\n}\n</code></pre>\n<p>What is the correct output, 0 or 5? Should a class type exclusively providing inherited constructors be zero-initialized before value-initialization (<code>B{ }</code>)?</p>\n", "Tags": "<c++><c++11><value-initialization>", "OwnerUserId": "725863", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_20255173_20255756_0": {"section_id": 484, "quality": 0.975609756097561, "length": 40}, "so_20255173_20255173_0": {"section_id": 3287, "quality": 0.5333333333333333, "length": 8}, "so_20255173_20255756_2": {"section_id": 487, "quality": 0.9629629629629629, "length": 26}, "so_20255173_20255756_1": {"section_id": 487, "quality": 0.9, "length": 9}}, "n3337": {"so_20255173_20255173_0": {"section_id": 3157, "quality": 0.7333333333333333, "length": 11}, "so_20255173_20255756_0": {"section_id": 475, "quality": 0.8536585365853658, "length": 35}, "so_20255173_20255756_2": {"section_id": 478, "quality": 0.9629629629629629, "length": 26}, "so_20255173_20255756_1": {"section_id": 478, "quality": 0.9, "length": 9}}, "n4659": {"so_20255173_20255173_0": {"section_id": 4049, "quality": 0.5333333333333333, "length": 8}}}, "20255756": {"ParentId": "20255173", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The correct answer is <code>0</code> because the default constructor for <code>B</code> is implicitly declared.</p>\n<p>Note that default, copy &amp; move constructors are not inherited; quoting from <em>\u00a712.9/3 [class.inhctor]</em></p>\n<blockquote>\n<p id=\"so_20255173_20255756_0\">For each non-template constructor in the candidate set of inherited constructors <strong>other than a constructor\n  having no parameters or a copy/move constructor having a single parameter</strong>, a constructor is implicitly\n  declared with the same constructor characteristics unless there is a user-declared constructor with the same\n  signature in the complete class where the using-declaration appears or the constructor would be a default,\n  copy, or move constructor for that class.</p>\n</blockquote>\n<hr>\n<p>Your example is similar to the one listed in N3797, <em>\u00a712.9/6</em> (edited for brevity)</p>\n<pre><code>struct B2 {\n  B2(int = 13, int = 42);\n};\n\nstruct D2 : B2 {\n  using B2::B2;\n};\n</code></pre>\n<blockquote>\n<p id=\"so_20255173_20255756_1\">The candidate set of inherited constructors in <code>D2</code> for <code>B2</code> is<br/>\n  \u2014 <code>B2(const B2&amp;)</code><br/>\n  \u2014 <code>B2(B2&amp;&amp;)</code><br/>\n  \u2014 <code>B2(int = 13, int = 42)</code><br/>\n  \u2014 <code>B2(int = 13)</code><br/>\n  \u2014 <code>B2()</code><br/></p>\n<p id=\"so_20255173_20255756_2\">The set of constructors present in <code>D2</code> is<br/>\n  \u2014 <code>D2()</code>, implicitly-declared default constructor, not inherited<br/>\n  \u2014 <code>D2(const D2&amp;)</code>, implicitly-declared copy constructor, not inherited<br/>\n  \u2014 <code>D2(D2&amp;&amp;)</code>, implicitly-declared move constructor, not inherited<br/>\n  \u2014 <code>D2(int, int)</code>, implicitly-declared inheriting constructor<br/>\n  \u2014 <code>D2(int)</code>, implicitly-declared inheriting constructor<br/></p>\n</blockquote>\n<p>In your case, the candidate set of inherited constructors in <code>B</code> for <code>A</code> are</p>\n<pre><code>A()\nA(int)\nA(const&amp; A)\nA(A&amp;&amp;)\n</code></pre>\n<p>and the constructors present in <code>B</code> are </p>\n<pre><code>B() implicitly declared, not inherited\nB(int) implicitly declared, inherited\nB(const&amp; B) implicitly declared, not inherited\nB(B&amp;&amp;) implicitly declared, not inherited\n</code></pre>\n</hr>", "OwnerUserId": "241631", "LastEditorUserId": "241631", "LastEditDate": "2013-11-28T00:44:57.227", "Id": "20255756", "Score": "6", "CreationDate": "2013-11-28T00:37:08.210", "LastActivityDate": "2013-11-28T00:44:57.227"}});