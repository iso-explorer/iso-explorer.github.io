post_cb({"30539969": {"ParentId": "30539849", "LastEditDate": "2015-05-29T22:32:37.700", "CommentCount": "4", "CreationDate": "2015-05-29T22:23:42.463", "OwnerUserId": "434551", "LastEditorUserId": "434551", "PostTypeId": "2", "Id": "30539969", "Score": "0", "Body": "<pre><code>myClass object1(0), object2(1);\nobject1 = object2++ + object2;\n</code></pre>\n<p>is analogous to:</p>\n<pre><code>int i1 = 0; i2 = 1;\ni1 = i2++ + i2;\n</code></pre>\n<p>which is not guaranteed to produce a deterministic value. Evaluation of <code>i2++</code> and <code>i2</code> are not guaranteed to be from left to right. Depending on which gets evaluated first, the RHS of that expression can evaluate to <code>3</code> or <code>2</code>.</p>\n<p>You should rethink your code.</p>\n<p>Make it:</p>\n<pre><code>object1 = object2;\nobject1 += (object2++);\n</code></pre>\n<p>or</p>\n<pre><code>object1 = (object2++);\nobject1 += object2;\n</code></pre>\n<p>depending on what your intentions are.</p>\n", "LastActivityDate": "2015-05-29T22:32:37.700"}, "30540423": {"ParentId": "30539849", "CommentCount": "0", "Body": "<p>As mentioned in comments - this is a poor idea because the semantics of your code will not match the semantics of how <code>operator++</code> normally works, so other people looking at your code, and perhaps even yourself at a later date, will be confused.</p>\n<p>To do it you would need to use a technique called <em>expression templates</em>. This isn't simple but the basic idea is that <code>operator++</code> and <code>operator+</code> (and any other operator) will return objects of a new type (say <code>Myclass_expr</code>) and that object builds up an expression as it goes; so the result of <code>x++ + x</code> will be a small tree that says \"this expression means add x to x and then increment x\". No actual arithmetic is performed yet.</p>\n<p>Finally, the <code>Myclass_expr</code> will have a conversion operator to <code>Myclass</code> which contains the logic to traverse the stored expression and perform all the computations in the order that you want.</p>\n<p>To see an example of this look at the Eigen matrix library.</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "30540423", "Score": "1", "CreationDate": "2015-05-29T23:12:37.330", "LastActivityDate": "2015-05-29T23:12:37.330"}, "30539954": {"ParentId": "30539849", "LastEditDate": "2015-05-29T23:54:29.433", "CommentCount": "5", "CreationDate": "2015-05-29T22:22:22.523", "OwnerUserId": "493122", "LastEditorUserId": "493122", "PostTypeId": "2", "Id": "30539954", "Score": "3", "Body": "<p>Your code:</p>\n<pre><code>myClass object1(0), object2(1);\nobject1 = object2++ + object2;\n</code></pre>\n<p>has actually unspecified behaviour, according to \u00a78.3.6/9:</p>\n<blockquote>\n<p id=\"so_30539849_30539954_0\">The order of evaluation of function arguments is unspecified.</p>\n</blockquote>\n<p>and due to the fact that that expression is converted to something like:</p>\n<pre><code>operator=(objec1, operator+(operator++(.., object2), object))\n</code></pre>\n<p>The obvious way to avoid this inconvenience is to perform the increment after the sum:</p>\n<pre><code>object1 = object + object2;\nobject++;\n</code></pre>\n<p>or (assuming <code>operator*</code> is also defined):</p>\n<pre><code>object1 = object2 * 2;\nobject++;\n</code></pre>\n<hr>\n<p>It would be undefined behaviour is they were of scalar types, according to \u00a71.9/15:</p>\n<blockquote>\n<p id=\"so_30539849_30539954_1\">Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced. [ Note: In an expression that is evaluated more than once during the execution of a program, unsequenced and indeterminately sequenced evaluations of its subexpressions need not be performed consistently in different evaluations. \u2014 end note ] The value computations of the operands of an operator are sequenced before the value computation of the result of the operator. If a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, and they are not potentially concurrent (1.10), the behavior is undefined.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2015-05-29T23:54:29.433"}, "30539849": {"CommentCount": "2", "ViewCount": "113", "CreationDate": "2015-05-29T22:11:18.917", "LastActivityDate": "2015-06-11T16:16:51.513", "Title": "Overloading postincrement", "FavoriteCount": "0", "PostTypeId": "1", "Id": "30539849", "Score": "2", "Body": "<p>Let's say we have a class <code>myClass</code> storing one <code>int</code>. I want to overload standard operators, like <code>+</code>, <code>=</code>, <code>+=</code>, <code>++</code> etc. How can I overload postfix increment, i.e. <code>operator++(int)</code>, so that the actual incrementation is done after the expression is evaluated? I mean, after the following code has bean executed,</p>\n<pre><code>myClass object1(0), object2(1);\nobject1 = object2++ + object2;\n</code></pre>\n<p>I want both object1 and object2 to hold 2.</p>\n<p>The naive approach</p>\n<pre><code>myClass&amp; operator++(int){\n  myClass tmp(x) //x - stored value\n  ++x;\n  return tmp;\n}\n</code></pre>\n<p>doesn't work, since <code>++</code> is called before <code>+</code>.</p>\n<p>I've been looking for an answer to that, but found nothing relevant. Frankly, until recently I didn't think it was possible to do this.</p>\n", "Tags": "<c++>", "OwnerUserId": "4699328", "AnswerCount": "4"}, "30786144": {"ParentId": "30539849", "CommentCount": "0", "Body": "<p>Ok, I've found an ugly, but simple way to do this, so I'm posting it for future generations. I added a <code>myClass * ptr</code> field to <code>myClass</code>. It usually stores <code>nullptr</code>, except in an object returned by <code>operator++(int)</code>. In that case, <code>ptr</code> stores a pointer to the object that should be incremented. I also modified destructor, so that incrementation is executed when temporary object is destructed:</p>\n<pre><code>    myClass&amp; operator++(int){\n      myClass tmp(x);\n      tmp.ptr = this;\n      return tmp;\n    }\n\n    ~myClass(){\n      if(ptr != nullptr)\n        ++ptr-&gt;x;\n    }\n</code></pre>\n<p>Although it's not standardized, <code>tmp</code> is usually destructed when semicolon is reached, i.e. when <code>x++ + x + x;</code> is executed, incrementation is done after the sum has been computed.</p>\n", "OwnerUserId": "4699328", "PostTypeId": "2", "Id": "30786144", "Score": "1", "CreationDate": "2015-06-11T16:16:51.513", "LastActivityDate": "2015-06-11T16:16:51.513"}, "bq_ids": {"n4140": {"so_30539849_30539954_0": {"section_id": 3260, "quality": 0.8333333333333334, "length": 5}, "so_30539849_30539954_1": {"section_id": 5811, "quality": 0.927536231884058, "length": 64}}, "n3337": {"so_30539849_30539954_0": {"section_id": 3132, "quality": 0.8333333333333334, "length": 5}, "so_30539849_30539954_1": {"section_id": 5584, "quality": 0.855072463768116, "length": 59}}, "n4659": {"so_30539849_30539954_0": {"section_id": 7709, "quality": 0.6666666666666666, "length": 4}, "so_30539849_30539954_1": {"section_id": 7272, "quality": 0.8405797101449275, "length": 58}}}});