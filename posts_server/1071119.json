post_cb({"1071461": {"ParentId": "1071119", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2009-07-01T21:22:52.413", "Score": "8", "LastEditorUserId": "123336", "LastEditDate": "2012-03-05T22:26:17.167", "Id": "1071461", "OwnerUserId": "123336", "Body": "<p>As Richard Corden points out, this issue was addressed in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html\" rel=\"noreferrer\">C++ Standard Core Language Defect Reports</a> after the 2003 standard was ratified: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#11\" rel=\"noreferrer\">How do the keywords typename/template interact with using-declarations?</a></p>\n<blockquote>\n<p id=\"so_1071119_1071461_0\">Proposed resolution (April 2003,\n  revised October 2003):</p>\n<p id=\"so_1071119_1071461_1\">Add a new paragraph to the bottom of\n  7.3.3 [namespace.udecl]:</p>\n<p id=\"so_1071119_1071461_2\">If a using-declaration uses the\n  keyword typename and specifies a\n  dependent name (14.7.2 [temp.dep]),\n  the name introduced by the\n  using-declaration is treated as a\n  typedef-name (7.1.3 [dcl.typedef]).</p>\n</blockquote>\n<p>This text doesn't seem to appear in the Second Edition standard from October 15, 2003.</p>\n<p>GCC does not yet implement this resolution, as explained in <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=14258\" rel=\"noreferrer\">bug 14258</a>:</p>\n<blockquote>\n<p id=\"so_1071119_1071461_3\">------- Comment #3 From Giovanni Bajo 2004-02-27 12:47 [reply] ------- The\n  problem is that our USING_DECL doesn't\n  record the \"typename\", that is the \n  fact that it is a type which is\n  imported through it. This used to work\n  thanks  to the implicit type name\n  extension, I believe.</p>\n</blockquote>\n<p>Duplicate <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=21484\" rel=\"noreferrer\">bug 21484</a> indicates that 'using typename' works on Comeau and Intel compilers. Because MSVC treats all names as dependent, the construct is unnecessary (but permitted) for that compiler.</p>\n<hr>\n<p><strong><a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=14258#c15\" rel=\"noreferrer\">Fixed</a> in GCC 4.7 on Dec 13 2011!</strong></p>\n</hr>", "LastActivityDate": "2012-03-05T22:26:17.167"}, "1071159": {"ParentId": "1071119", "CommentCount": "1", "Body": "<p>You didn't include an access specifier (public/protected/private) in the template for Base before declaring the typedef for Base::value_type. As a result, it defaults to private and is not accessible in classes derived from Base.</p>\n", "OwnerUserId": "19131", "PostTypeId": "2", "Id": "1071159", "Score": "-1", "CreationDate": "2009-07-01T20:19:35.677", "LastActivityDate": "2009-07-01T20:19:35.677"}, "1071119": {"CommentCount": "4", "ViewCount": "3089", "PostTypeId": "1", "LastEditorUserId": "961353", "CreationDate": "2009-07-01T20:12:41.947", "LastActivityDate": "2013-04-29T10:46:33.420", "Title": "Accessing types from dependent base classes", "AcceptedAnswerId": "1071461", "LastEditDate": "2013-04-29T10:46:33.420", "Id": "1071119", "Score": "9", "Body": "<p>Does anyone know why using-declarations don't seem to work for importing type names from dependent base classes? They work for member variables and functions, but at least in GCC 4.3, they seem to be ignored for types.</p>\n<pre><code>template &lt;class T&gt;\nstruct Base\n{\n  typedef T value_type;\n};\n\ntemplate &lt;class T&gt;\nstruct Derived : Base&lt;T&gt;\n{\n  // Version 1: error on conforming compilers\n  value_type get();\n\n  // Version 2: OK, but unwieldy for repeated references\n  typename Base&lt;T&gt;::value_type get();\n\n  // Version 3: OK, but unwieldy for many types or deep inheritance\n  typedef typename Base&lt;T&gt;::value_type value_type;\n  value_type get();\n\n  // Version 4: why doesn't this work?\n  using typename Base&lt;T&gt;::value_type;\n  value_type get(); // GCC: `value_type' is not a type\n};\n</code></pre>\n<p>I have a base class with a set of allocator-style typedefs that I'd like to inherit throughout several levels of inheritance. The best solution I've found so far is Version 3 above, but I'm curious why Version 4 doesn't seem to work. GCC accepts the using-declaration, but seems to ignore it.</p>\n<p>I've checked the C++ Standard, C++ Prog. Lang. 3rd ed. [Stroustrup], and C++ Templates [Vandevoorde, Josuttis], but none seem to address whether using-declarations can be applied to dependent base class types.</p>\n<p>In case it helps to see another example, <a href=\"http://gcc.gnu.org/ml/gcc-help/2008-09/msg00235.html\" rel=\"noreferrer\">here is the same question being asked</a>, but not really answered, on the GCC mailing list. The asker indicates that he has seen 'using typename' elsewhere, but that GCC doesn't seem to support it. I don't have another conforming compiler available to test it.</p>\n", "Tags": "<c++><templates><using-declaration><dependent-name>", "OwnerUserId": "123336", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_1071119_1071461_2": {"section_id": 5508, "quality": 0.75, "length": 12}}, "n3337": {"so_1071119_1071461_2": {"section_id": 5294, "quality": 0.75, "length": 12}}, "n4659": {"so_1071119_1071461_2": {"section_id": 6943, "quality": 0.6875, "length": 11}}}});