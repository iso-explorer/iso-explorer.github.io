post_cb({"14782923": {"Id": "14782923", "PostTypeId": "2", "Body": "<p>This happens because class templates have their template-name injected; the injected name can be used either as a template or a type referring to the template instantiation (14.6.1p1).  The injected class name is then inherited by the derived class (10.2p5); using it as a template is unambiguous (it's the same template however it is inherited) so is allowed.</p>\n<p>To fix your program, try using <code>is_base_of</code>:</p>\n<pre><code>struct B : A&lt;int, string&gt;, A&lt;int, float&gt; { };\ntemplate&lt;typename T, typename U&gt;\nusing check_A = typename std::enable_if&lt;std::is_base_of&lt;A&lt;T, U&gt;, B&gt;::value, A&lt;T, U&gt;&gt;::type;\n\ncheck_A&lt;int, float&gt;::type bar1; // compiles\ncheck_A&lt;int, int&gt;::type bar2; // error\n</code></pre>\n", "LastEditorUserId": "567292", "LastActivityDate": "2013-02-08T23:22:50.170", "Score": "6", "CreationDate": "2013-02-08T23:17:18.910", "ParentId": "14782568", "CommentCount": "1", "LastEditDate": "2013-02-08T23:22:50.170", "OwnerUserId": "567292"}, "bq_ids": {"n4140": {"so_14782568_14782795_0": {"length": 32, "quality": 0.9142857142857143, "section_id": 182}, "so_14782568_14782790_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 6677}}, "n3337": {"so_14782568_14782795_0": {"length": 32, "quality": 0.9142857142857143, "section_id": 176}, "so_14782568_14782790_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 6432}}, "n4659": {"so_14782568_14782795_0": {"length": 32, "quality": 0.9142857142857143, "section_id": 187}, "so_14782568_14782790_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 8152}}}, "14782790": {"Id": "14782790", "PostTypeId": "2", "Body": "<p>In \u00a711.1/5, the Standard says:</p>\n<blockquote>\n<p id=\"so_14782568_14782790_0\">In a derived class, the lookup of a base class name will find the\n  injected-class-name instead of the name of the base class in the scope\n  in which it was declared. The injected-class-name might be less\n  accessible than the name of the base class in the scope in which it\n  was declared.</p>\n</blockquote>\n<p>So <code>A</code> is an injected name in the scope of <code>B</code>. It refers to the template <code>A</code>, not the base class (because it would be ambiguous) according to \u00a714.1/4.</p>\n<p>Just like in the scope of <code>A</code>, if you say just <code>A</code>, it's the class itself (but it's the template in this context). You're making use of this injected name, and so the name <code>B::A</code> is the same as <code>::A</code>. I don't think there's a way to suppress this behaviour.</p>\n", "LastActivityDate": "2013-02-08T23:06:34.253", "Score": "2", "CreationDate": "2013-02-08T23:06:34.253", "ParentId": "14782568", "CommentCount": "0", "OwnerUserId": "726361"}, "14782568": {"ViewCount": "644", "Body": "<p><strong>Edit: I'm using tdm-gcc-4.7.1-2 for Windows</strong></p>\n<p>Not sure how to resolve this.  I'd like to use this as a sort of type list that will let me know I'm attempting to use a type not present in <code>B</code>'s typedefs.</p>\n<pre><code>template &lt;typename T, typename U&gt;\nstruct A {\n    typedef pair&lt;T, U&gt; type;\n};\n\nstruct B : A&lt;int, string&gt;, A&lt;int, float&gt; {};\n\nB::type foo; // won't compile, ambiguous reference, as expected\nB::A&lt;int, int&gt;::type bar; // compiles fine?? :(\n</code></pre>\n<p>Is there a way to get it to fail on <code>A&lt;int, int&gt;</code> (and any other <code>A</code>'s not inherited by <code>B</code>), or another way to go about this?  I guess I could use a <code>tuple</code> and recurse my way through it, doing an <code>is_same</code> comparison on each element vs whatever I feed the metafunction, but this seemed easier... at first :\\</p>\n", "AcceptedAnswerId": "14782923", "Title": "How to disambiguate multiple inherited typedefs from templated bases?", "CreationDate": "2013-02-08T22:45:02.983", "Id": "14782568", "CommentCount": "4", "LastEditDate": "2013-02-08T23:03:55.520", "PostTypeId": "1", "LastEditorUserId": "376331", "LastActivityDate": "2013-02-08T23:22:50.170", "Score": "9", "OwnerUserId": "376331", "Tags": "<c++><inheritance><c++11><typedef><multiple-inheritance>", "AnswerCount": "3"}, "14782795": {"Id": "14782795", "PostTypeId": "2", "Body": "<p>The standard explicitly allows this, though it's a bit confusing. From 14.6.1-4 in draft:</p>\n<blockquote>\n<p id=\"so_14782568_14782795_0\">A lookup that finds an injected-class-name (10.2) can result in an\n  ambiguity in certain cases (for example, if it is found in more than\n  one base class). If all of the injected-class-names that are found\n  refer to specializations of the same class template, and if the name\n  is followed by a template-argument-list, the reference refers to the\n  class template itself and not a specialization thereof, and is not\n  ambiguous. </p>\n</blockquote>\n<pre><code>[ Example: \ntemplate &lt;class T&gt; struct Base { }; \ntemplate &lt;class T&gt; struct Derived: Base&lt;int&gt;, Base&lt;char&gt; { \ntypename Derived::Base b; // error: ambiguous \ntypename Derived::Base&lt;double&gt; d;// OK \n}; \n\u2014 end example ]\n</code></pre>\n", "LastActivityDate": "2013-02-08T23:07:02.060", "Score": "2", "CreationDate": "2013-02-08T23:07:02.060", "ParentId": "14782568", "CommentCount": "0", "OwnerUserId": "2004300"}});