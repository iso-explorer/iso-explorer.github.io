post_cb({"bq_ids": {"n4140": {"so_31730222_31730222_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 602}}, "n3337": {"so_31730222_31730222_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 592}}, "n4659": {"so_31730222_31730222_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 628}}}, "31731582": {"Id": "31731582", "PostTypeId": "2", "Body": "<ul>\n<li><p>Narrowing is something the compiler only knows about for built-in types. A user defined implicit conversion can't be marked as narrowing or not.</p></li>\n<li><p>Narrowing conversions shouldn't be permitted to be implicit in the first place. (Unfortunately it was required for C compatibility. This has been somewhat corrected with <code>{}</code> initialization prohibiting narrowing for built-in types.)</p></li>\n</ul>\n<p>Given these, it makes sense that the overload rules don't bother to mention this special case. It might be an occasional convenience, but it's not all that valuable. IMO it's better in general to have fewer factors involved in overload resolution and to reject more things as ambiguous, forcing the programmer to resolve such things explicitly.</p>\n<hr>\n<p>Also, double to float is a narrowing conversion when the double isn't a constant expression or if the double is too large.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nint main() {\n    double d{1.1};\n    float f{d};\n    std::cout &lt;&lt; std::setprecision(100) &lt;&lt; d &lt;&lt; \" \" &lt;&lt; f &lt;&lt; '\\n';\n}\n</code></pre>\n<p>This will normally produce an error:</p>\n<pre><code>main.cpp:7:13: error: non-constant-expression cannot be narrowed from type 'double' to 'float' in initializer list [-Wc++11-narrowing]\n    float f{d};\n            ^\n</code></pre>\n</hr>", "LastEditorUserId": "365496", "LastActivityDate": "2015-07-30T18:56:02.960", "Score": "8", "CreationDate": "2015-07-30T18:38:05.103", "ParentId": "31730222", "CommentCount": "0", "OwnerUserId": "365496", "LastEditDate": "2015-07-30T18:56:02.960"}, "31730222": {"ViewCount": "666", "Body": "<p>Consider the following:</p>\n<pre><code>struct A {\n    A(float ) { }\n    A(int ) { }\n};\n\nint main() {\n    A{1.1}; // error: ambiguous\n}\n</code></pre>\n<p>This fails to compile with an error about an ambiguous overload of <code>A::A</code>. Both candidates are considered viable, because the requirement is simply:</p>\n<blockquote>\n<p id=\"so_31730222_31730222_0\">Second, for <code>F</code> to be a viable function, there shall exist for each argument an implicit conversion sequence (13.3.3.1) that converts that argument to the corresponding parameter of <code>F</code>.</p>\n</blockquote>\n<p>While there is an implicit conversion sequence from <code>double</code> to <code>int</code>, the <code>A(int )</code> overload isn't <em>actually</em> viable (in the canonical, non-C++-standard sense) - that would involve a narrowing conversion and thus be ill-formed. </p>\n<p>Why are narrowing conversions not considered in the process of determining viable candidates? Are there any other situations where an overload is considered ambiguous despite only one candidate being viable? </p>\n", "AcceptedAnswerId": "31731494", "Title": "Why doesn't narrowing affect overload resolution?", "CreationDate": "2015-07-30T17:19:48.463", "Id": "31730222", "CommentCount": "13", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-07-30T18:01:29.083", "LastEditorUserId": "415784", "LastActivityDate": "2015-07-30T19:23:56.337", "Score": "24", "OwnerUserId": "2069064", "Tags": "<c++><c++11><language-lawyer><overload-resolution>", "AnswerCount": "2"}, "31731494": {"Id": "31731494", "PostTypeId": "2", "Body": "<p>A problem lies with the fact that narrowing conversions can be detected not based on types.</p>\n<p>There are very complex ways to generate values at compile time in C++.</p>\n<p>Blocking narrowing conversions is a good thing.  Making the overload resolution of C++ even more complex than it already is is a bad thing.</p>\n<p>Ignoring narrowing conversion rules when determining overload resolution (which makes overload resolution purely about types), and then erroring out when the selected overload results in a narrowing conversion, keeps overload resolution from being even more complex, and adds in a way to detect and prevent narrowing conversions.</p>\n<p>Two examples where only one candidate is viable would be template functions that fail \"late\", during instantiation, and copy-list initialization (where <code>explicit</code> constructors are considered, but if they are chosen, you get an error).  Similarly, having that impact overload resolution would make overload resolution even more complex than it already is.</p>\n<p>Now, one might ask, why not fold narrowing conversion purely into the type system?</p>\n<p>Making narrowing conversion be purely type-based would be non-viable.  Such changes could break huge amounts of \"legacy\" code that the compiler could <em>prove</em> as being valid.  The effort required to sweep a code base is far more worthwhile when most of the errors are actual errors, and not the new compiler version being a jerk.</p>\n<pre><code>unsigned char buff[]={0xff, 0x00, 0x1f};\n</code></pre>\n<p>this would fail under a type-based narrowing conversion, as <code>0xff</code> is of type <code>int</code>, and such code is very common.</p>\n<p>Had such code required pointless modification of the <code>int</code> literals to <code>unsigned char</code> literals, odds are the sweep would have ended with us setting a flag to tell the compiler to shut up about the stupid error.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2015-07-30T19:23:56.337", "Score": "15", "CreationDate": "2015-07-30T18:33:33.800", "ParentId": "31730222", "CommentCount": "6", "OwnerUserId": "1774667", "LastEditDate": "2015-07-30T19:23:56.337"}});