post_cb({"25457178": {"CommentCount": "0", "ViewCount": "351", "PostTypeId": "1", "LastEditorUserId": "241631", "CreationDate": "2014-08-23T00:05:04.127", "LastActivityDate": "2014-08-23T00:28:49.180", "Title": "Using initializer lists with a boost::multi_index::multi_index_container of std::unique_ptr elements", "LastEditDate": "2014-08-23T00:21:30.850", "Id": "25457178", "Score": "1", "Body": "<p>I'm getting compilation errors when trying to use an initializer list to assign values into a <code>boost::multi_index::multi_index_container</code> object containing <code>std::unique_ptr</code> elements of any type.</p>\n<p>Here's a short example (also available on <a href=\"http://melpon.org/wandbox/permlink/NzwFgwJJbNElof17\" rel=\"nofollow\">Wandbox</a>):</p>\n<pre><code>#include &lt;boost/multi_index_container.hpp&gt;\n#include &lt;boost/multi_index/ordered_index.hpp&gt;\n\n#include &lt;memory&gt;\n\nint main()\n{\n    boost::multi_index::multi_index_container&lt;std::unique_ptr&lt;int&gt;&gt; foo;\n\n    // Works:\n    foo.insert(std::make_unique&lt;int&gt;(0));\n    foo.insert(std::make_unique&lt;int&gt;(1));\n\n    // Doesn't work:\n    foo = { std::make_unique&lt;int&gt;(0), std::make_unique&lt;int&gt;(1) };\n}\n</code></pre>\n<p>As shown above, inserting each object one at a time using <code>insert()</code> works, but I'd really rather not have to do that.</p>\n<p>I'm using Boost 1.56.0 and compiling with Visual C++ 12.0 (Visual Studio 2013 Update 3). However, compiling with either Clang 3.4 or GCC 4.9.0 results in essentially the same errors.</p>\n<p>Here's the output from Clang (selected for readability):</p>\n<pre><code>In file included from test.cpp:1:\nIn file included from boost/multi_index_container.hpp:20:\nboost/detail/allocator_utilities.hpp:153:11: error: call to implicitly-deleted copy constructor of 'std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt;'\n  new (p) Type(t);\n          ^    ~\nboost/multi_index/detail/index_base.hpp:105:33: note: in instantiation of function template specialization 'boost::detail::allocator::construct&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt; &gt;' requested here\n      boost::detail::allocator::construct(&amp;x-&gt;value(),v);\n                                ^\n\nboost/multi_index/detail/index_base.hpp:144:12: note: in instantiation of member function 'boost::multi_index::detail::index_base&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt;, boost::multi_index::indexed_by&lt;boost::multi_index::ordered_unique&lt;boost::multi_index::identity&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt; &gt;, mpl_::na, mpl_::na&gt;, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na&gt;, std::__1::allocator&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt; &gt; &gt;::insert_' requested here\n    return insert_(v,x,lvalue_tag());\n           ^\n\nboost/multi_index/ordered_index.hpp:728:33: note: in instantiation of member function 'boost::multi_index::detail::index_base&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt;, boost::multi_index::indexed_by&lt;boost::multi_index::ordered_unique&lt;boost::multi_index::identity&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt; &gt;, mpl_::na, mpl_::na&gt;, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na&gt;, std::__1::allocator&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt; &gt; &gt;::insert_' requested here\n    final_node_type* res=super::insert_(v,position,x,variant);\n                                ^\n\nboost/multi_index_container.hpp:657:27: note: in instantiation of function template specialization 'boost::multi_index::detail::ordered_index&lt;boost::multi_index::identity&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt; &gt;, std::__1::less&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt; &gt;, boost::multi_index::detail::nth_layer&lt;1, std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt;, boost::multi_index::indexed_by&lt;boost::multi_index::ordered_unique&lt;boost::multi_index::identity&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt; &gt;, mpl_::na, mpl_::na&gt;, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na&gt;, std::__1::allocator&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt; &gt; &gt;, boost::mpl::vector0&lt;mpl_::na&gt;, boost::multi_index::detail::ordered_unique_tag&gt;::insert_&lt;boost::multi_index::detail::lvalue_tag&gt;' requested here\n    node_type* res=super::insert_(v,position,x,variant);\n                          ^\n\nboost/multi_index_container.hpp:669:12: note: in instantiation of function template specialization 'boost::multi_index::multi_index_container&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt;, boost::multi_index::indexed_by&lt;boost::multi_index::ordered_unique&lt;boost::multi_index::identity&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt; &gt;, mpl_::na, mpl_::na&gt;, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na&gt;, std::__1::allocator&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt; &gt; &gt;::insert_&lt;boost::multi_index::detail::lvalue_tag&gt;' requested here\n    return insert_(v,position,detail::lvalue_tag());\n           ^\n\nboost/multi_index_container.hpp:339:30: note: in instantiation of member function 'boost::multi_index::multi_index_container&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt;, boost::multi_index::indexed_by&lt;boost::multi_index::ordered_unique&lt;boost::multi_index::identity&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt; &gt;, mpl_::na, mpl_::na&gt;, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na&gt;, std::__1::allocator&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt; &gt; &gt;::insert_' requested here\n      hint=x.make_iterator(x.insert_(*first,hint.get_node()).first);\n                             ^\n\ntest.cpp:15:6: note: in instantiation of member function 'boost::multi_index::multi_index_container&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt;, boost::multi_index::indexed_by&lt;boost::multi_index::ordered_unique&lt;boost::multi_index::identity&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt; &gt;, mpl_::na, mpl_::na&gt;, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na&gt;, std::__1::allocator&lt;std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt; &gt; &gt;::operator=' requested here\n        foo = { std::make_unique&lt;int&gt;(0), std::make_unique&lt;int&gt;(1) };\n            ^\n\nlibcxx-3.4/include/c++/v1/memory:2510:31: note: copy constructor is implicitly deleted because 'unique_ptr&lt;int, std::__1::default_delete&lt;int&gt; &gt;' has a user-declared move constructor\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&amp;&amp; __u) _NOEXCEPT\n                          ^\n1 error generated.\n</code></pre>\n<p>I'm afraid I don't quite understand what's going on here. Why is a copy constructor being invoked? Is this just a limitation of Boost? Is there any viable workaround \u2014 specifically, one that will work with my target compiler, Visual C++ 12.0?</p>\n", "Tags": "<c++><c++11><unique-ptr><initializer-list><boost-multi-index>", "OwnerUserId": "79851", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_25457178_25457259_0": {"section_id": 6955, "quality": 1.0, "length": 9}}, "n3337": {"so_25457178_25457259_0": {"section_id": 6702, "quality": 1.0, "length": 9}}, "n4659": {"so_25457178_25457259_0": {"section_id": 8452, "quality": 1.0, "length": 9}}}, "25457259": {"ParentId": "25457178", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-08-23T00:19:58.303", "Score": "3", "LastEditorUserId": "241631", "LastEditDate": "2014-08-23T00:28:49.180", "Id": "25457259", "OwnerUserId": "241631", "Body": "<p>An <a href=\"http://en.cppreference.com/w/cpp/utility/initializer_list\" rel=\"nofollow\"><code>initializer_list</code></a> only allows <code>const</code> access to its elements, which means they cannot be moved and must be copied.</p>\n<p>From N3337, <em>\u00a718.9.1/2 [support.initlist]</em></p>\n<blockquote>\n<p id=\"so_25457178_25457259_0\">An object of type <code>initializer_list&lt;E&gt;</code> provides access to an array of objects of type <code>const E</code>.</p>\n</blockquote>\n<p>So the assignment to <code>foo</code> attempts to make copies of the <code>unique_ptr</code>, which, of course, fails.</p>\n<pre><code>foo = { std::make_unique&lt;int&gt;(0), std::make_unique&lt;int&gt;(1) };\n</code></pre>\n<p><a href=\"https://stackoverflow.com/a/8469002/241631\">This answer</a> has some workarounds, but I don't think they'll be useful in this case.</p>\n", "LastActivityDate": "2014-08-23T00:28:49.180"}});