post_cb({"bq_ids": {"n4140": {"so_14547986_14548934_1": {"length": 17, "quality": 1.0, "section_id": 5942}, "so_14547986_14548934_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 5908}, "so_14547986_14548934_2": {"length": 12, "quality": 1.0, "section_id": 7041}}, "n3337": {"so_14547986_14548934_1": {"length": 17, "quality": 1.0, "section_id": 5713}, "so_14547986_14548934_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 5680}, "so_14547986_14548934_2": {"length": 12, "quality": 1.0, "section_id": 6786}}, "n4659": {"so_14547986_14548934_1": {"length": 17, "quality": 1.0, "section_id": 7426}, "so_14547986_14548934_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 7390}, "so_14547986_14548934_2": {"length": 12, "quality": 1.0, "section_id": 8538}}}, "14547986": {"ViewCount": "1118", "Body": "<p>This is probably a bit of an unusual question, in that it asks for a fuller explanation of a short answer given to <a href=\"https://stackoverflow.com/questions/14547370/confusion-about-in-class-initialization-of-static-data-members/14547498#comment20292860_14547498\">another question</a> and of some aspects of the C++11 Standard related to it. </p>\n<p>For ease of reference, I shall sum up the referenced question here. The OP defines a class:</p>\n<pre><code>struct Account \n{\n    static constexpr int period = 30;\n    void foo(const int &amp;) { }\n    void bar() { foo(period); } //no error?\n};\n</code></pre>\n<p>and is wondering why he gets no error about his usage of an in-class initialized static data member (a book mentioned this to be illegal). Johannes Schaub's answer states, that:</p>\n<ol>\n<li>This violates the <strong>One Definition Rule</strong>;</li>\n<li>No diagnostics is required.</li>\n</ol>\n<p>As much as I rely the source and validity of this answer, I honestly dislike it because I personally find it too cryptic, so I tried to work out a more meaningful answer myself, with only partial success. Relevant seems to be \u00a7 9.4.2/4: </p>\n<p><em>\"There shall be exactly one definition of a static data member that is <strong>odr-used</strong> (3.2) in a program; <strong>no diagnostic is required</strong>\"</em> [Emphases are mine]</p>\n<p>Which gets me a bit closer to the point. And this is how \u00a7 3.2/2 defines an <strong>odr-used</strong> variable:</p>\n<p><em>\"A variable whose name appears as a potentially-evaluated expression is odr-used <strong>unless</strong> it is an object that satisfies the requirements for appearing in a constant expression (5.19) <strong>and</strong> the lvalue-to-rvalue conversion (4.1) is immediately applied\"</em> [Emphases are mine]</p>\n<p>In the OP's question, variable <code>period</code> clearly satisfies the requirements for appearing in a constant expression, being a <code>constexpr</code> variable. So the reason must be certainly found in the <em>second</em> condition: <em>\"<strong>and the lvalue-to-rvalue conversion (4.1) is immediately applied</strong>\"</em>.</p>\n<p>This is where I have troubles interpreting the Standard. <strong>What does this second condition actually mean?</strong> What are the situations it covers? Does it mean that a static <code>constexpr</code> variable is <strong>not</strong> odr-used (and therefore can be in-class initialized) if it is returned from a function? </p>\n<p>More generally: <strong>What are you allowed to do with a static <code>constexpr</code> variable so that you can in-class initialize it?</strong></p>\n", "AcceptedAnswerId": "14548199", "Title": "What am I allowed to do with a static, constexpr, in-class initialized data member?", "CreationDate": "2013-01-27T13:45:08.467", "Id": "14547986", "CommentCount": "15", "LastEditDate": "2017-05-23T12:31:11.610", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2013-01-27T17:23:48.490", "Score": "8", "OwnerUserId": "1932150", "Tags": "<c++><c++11><static-members><constexpr><one-definition-rule>", "AnswerCount": "2"}, "14548199": {"Id": "14548199", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_14547986_14548199_0\">Does it mean that a static constexpr variable is not odr-used (and\n  therefore can be in-class initialized) if it is returned from a\n  function?</p>\n</blockquote>\n<p>Yes.</p>\n<p>Essentially, as long as you treat it as a <em>value</em>, rather than an <em>object</em>, then it is not odr-used. Consider that if you pasted in the value, the code would function identically- this is when it is treated as an rvalue. But there are some scenarios where it would not.</p>\n<p>There are only a few scenarios where lvalue-to-rvalue conversion is <em>not</em> performed on primitives, and that's reference binding, <code>&amp;obj</code>, and probably a couple others, but it's very few. Remember that, if the compiler gives you a <code>const int&amp;</code> referring to <code>period</code>, then you must be able to take it's address, and furthermore, this address must be the same <em>for each TU</em>. That means, in C++'s horrendous TU system, that there must be one explicit definition.</p>\n<p>If it is not odr-used, the compiler can make a copy in each TU, or substitute the value, or whatever it wants, and you can't observe the difference.</p>\n", "LastActivityDate": "2013-01-27T14:10:52.747", "CommentCount": "8", "CreationDate": "2013-01-27T14:10:52.747", "ParentId": "14547986", "Score": "3", "OwnerUserId": "298661"}, "14548934": {"Id": "14548934", "PostTypeId": "2", "Body": "<p>You missed a part of the premise. The class definition give above is completely valid, if you also define <code>Account::period</code> somewhere (but without providing an initializer). See the last sentance of 9.4.2/3:</p>\n<blockquote>\n<p id=\"so_14547986_14548934_0\">The member shall still be defined in a namespace scope if it is odr-used\n  (3.2) in the program and the namespace scope definition shall not\n  contain an initializer.</p>\n</blockquote>\n<p>This entire discussion only applies to static constexpr data members, not to namespace-scope static variables. When static data members are <code>constexpr</code> (rather than simply const) you <em>have to</em> initialize them in the class definition.  So your question should really be: <strong>What are you allowed to do with a static constexpr data member so that you don't have to provide a definition for it at namespace scope?</strong></p>\n<p>From the preceding, the answer is that the member must not be <em>odr-used</em>. And you already found relevant parts of the definition of <em>odr-used</em>. So you can use the member in a context where it is not <em>potentially-evaluated</em> - as an unevaluated operand (for example of <code>sizeof</code>or <code>decltype</code>) or a subexpression thereof.  And you can use it in an expression where the lvalue-to-rvalue conversion is immediately applied. </p>\n<p>So now we are down to <strong>What uses of a variable cause an immediate lvalue to rvalue conversion?</strong></p>\n<p>Part of that answer is in \u00a75/8:</p>\n<blockquote>\n<p id=\"so_14547986_14548934_1\">Whenever a glvalue expression appears as an operand of an operator\n  that expects a prvalue for that operand, the lvalue-to-rvalue (4.1),\n  array-to-pointer (4.2), or function-to-pointer (4.3) standard\n  conversions are applied to convert the expression to a prvalue.</p>\n</blockquote>\n<p>For arithmetic types that essentially applies to all operators that apply standard arithmetic conversions. So you can use the member in various arithmetic and logical operations without needing a definition.</p>\n<p>I can't enumerate all things, you can or can't do here, because the requirements that something be a [g]lvalue or [p]rvalue are spread across the standard. The rule of thumb is: <em>if only the <strong>value</strong> of the variable is used, a lvalue to rvalue conversion is applied; if the variable is used as an <strong>object</strong>, it is used as lvalue</em>.</p>\n<p>You can't use it in contexts where an lvalue is explicitly required, for example as argument to the address-of operator or mutating operators). Direct binding of lvalue references (without conversion) is such a context.</p>\n<p>Some more examples (without detailed standardese analysis):</p>\n<p>You can pass it to functions, unless the function parameter is a reference to which the variable can be directly bound.</p>\n<p>For returning it from a function: if implicit conversion to the return type involves a user-defined conversion function, the rules for passing to a function apply. Otherwise you can return it, unless the function returns an lvalue (a reference) referring directly to the variable. </p>\n<p>The key rule for <em>odr-used</em> variables, the \"One Definition Rule\" is in 3.2/3:</p>\n<blockquote>\n<p id=\"so_14547986_14548934_2\">Every program shall contain exactly one definition of every non-inline\n  function or variable that is odr-used in that program; no diagnostic\n  required.</p>\n</blockquote>\n<p>The \"no diagnostic required\" part means that programs violating this rule cause undefined behavior, which may range from failing to compile, compiling and failing in surprising ways to compiling and acting as if everything was OK. And your compiler need not warn you about the problem.</p>\n<p>The reason, as others have already indicated, is that many of these violations would only be detected by a linker. But optimizations may have removed references to objects, so that no cause for linkage failure remains or else linking may sometimes occur only at runtime or be defined to pick an arbitrary instance from multiple definitions of a name.</p>\n", "LastEditorUserId": "585729", "LastActivityDate": "2013-01-27T17:23:48.490", "Score": "3", "CreationDate": "2013-01-27T15:34:23.237", "ParentId": "14547986", "CommentCount": "0", "OwnerUserId": "585729", "LastEditDate": "2013-01-27T17:23:48.490"}});