post_cb({"bq_ids": {"n4140": {"so_26324347_26324347_0": {"length": 33, "quality": 0.9166666666666666, "section_id": 380}, "so_26324347_26324405_0": {"length": 19, "quality": 0.8636363636363636, "section_id": 480}}, "n3337": {"so_26324347_26324347_0": {"length": 33, "quality": 0.9166666666666666, "section_id": 371}, "so_26324347_26324405_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 471}}, "n4659": {"so_26324347_26324347_0": {"length": 33, "quality": 0.9166666666666666, "section_id": 395}, "so_26324347_26324405_0": {"length": 19, "quality": 0.8636363636363636, "section_id": 502}}}, "26324347": {"ViewCount": "159", "Body": "<p>Why isn't destructor for temporary object called after evaluating a full-expression:</p>\n<pre><code>#include &lt;iostream&gt;\n\n\nstruct A \n{\n    int a;\n    A();\n    ~A();\n};\n\nA::~A()\n{\n    std::cout &lt;&lt; \"~A()\" &lt;&lt; std::endl; \n}\n\nA::A()\n{\n    std::cout &lt;&lt; \"A()\" &lt;&lt; std::endl; \n} \n\n\n\nint main()\n{\n    A b = A(); //Constructing of temporary object and applies copy-initalization\n    std::cout &lt;&lt; \"side effect\" &lt;&lt; std::endl;\n    //Destructor calling.\n}\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/27c65dc012d7def2\" rel=\"noreferrer\">DEMO</a></strong></p>\n<p>Output:</p>\n<pre><code>A()\nside effect\n~A()\n</code></pre>\n<p>But 12.2/3 [class.temporary] says:</p>\n<blockquote>\n<p id=\"so_26324347_26324347_0\">When an implementation introduces a temporary object of a class that\n  has a non-trivial constructor (12.1, 12.8), it shall ensure that a\n  constructor is called for the temporary object. Similarly, the\n  destructor shall be called for a temporary with a non-trivial\n  destructor (12.4). <strong>Temporary objects are destroyed as the last step in</strong>\n<strong>evaluating the full-expression</strong> (1.9) that (lexically) contains the\n  point where they were created.</p>\n</blockquote>\n", "AcceptedAnswerId": "26324405", "Title": "Temporary object destruction", "CreationDate": "2014-10-12T10:50:04.247", "LastActivityDate": "2014-10-12T15:53:40.977", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "ClosedDate": "2014-10-12T11:16:17.163", "Id": "26324347", "Score": "5", "Tags": "<c++><temporary>", "AnswerCount": "1"}, "26324405": {"Id": "26324405", "PostTypeId": "2", "Body": "<p>With your compiler and options the temporary is elided (optimized away), which is permitted.</p>\n<p>Thus there is no temporary.</p>\n<p>Thus there is no missing constructor and destructor call pair.</p>\n<hr>\n<p>It's also well worth noting that the copy and move constructors are the only constructors where the compiler is allowed to <em>assume</em> that the constructor has no side effects, even when it knows better.</p>\n<blockquote>\n<p id=\"so_26324347_26324405_0\"><strong><em>C++11 \u00a712.8/31</em></strong>:<br>\n<strong>\u201d</strong> When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the copy/move constructor and/or destructor for the object have side effects. [\u2026]</br></p>\n</blockquote>\n</hr>", "LastEditorUserId": "464581", "LastActivityDate": "2014-10-12T15:53:40.977", "Score": "2", "CreationDate": "2014-10-12T10:56:44.893", "ParentId": "26324347", "CommentCount": "6", "OwnerUserId": "464581", "LastEditDate": "2014-10-12T15:53:40.977"}});