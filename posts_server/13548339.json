post_cb({"13548339": {"ViewCount": "1172", "Body": "<p>Quite frequently in C++11 I need to define a function that takes a container as a parameter.</p>\n<p>For example lets define a function <code>addup</code> (yes just a simple version of <code>std::accumulate</code>):</p>\n<pre><code>template &lt;class I&gt;\nint addup (I first, I last)\n{\n    int x = 0;\n    while ( first != last )\n        x += *first++;\n    return x;\n}\n</code></pre>\n<p>This takes an iterator range, which is flexible and the standard library idiom.</p>\n<p>However suppose I have a function:</p>\n<pre><code>vector&lt;T&gt; f();\n</code></pre>\n<p>I have to do this:</p>\n<pre><code>auto v = f();\nint x = addup(v.begin(), v.end());\n</code></pre>\n<p>I would rather just do this:</p>\n<pre><code>int x = addup(f());\n</code></pre>\n<p>Just like I can do this:</p>\n<pre><code>for (auto t : f())\n    ...\n</code></pre>\n<p>In the spirit of <em>range-based for</em> I would like something like this:</p>\n<pre><code>template&lt;class C&gt;\nint addup(C&amp;&amp; container)\n{\n    addup(beginexpr(container), endexpr(container)); // ???\n}\n</code></pre>\n<p>In the standard it says in 6.5.4 (paraphrasing):</p>\n<blockquote>\n<p id=\"so_13548339_13548339_0\">(A) if <code>container</code> is an array type, <code>beginexpr</code> and <code>endexpr</code> are <code>container</code> and <code>container</code> + <code>bound</code>, respectively, where <code>bound</code> is the array bound.</p>\n<p id=\"so_13548339_13548339_1\">(B) if <code>container</code> is a class type, the unqualified-ids <code>begin</code> and <code>end</code> are looked up in the scope of class <code>container</code> as if by class member access lookup (3.4.5), and if either (or both) finds at least one declaration, <code>beginexpr</code> and <code>endexpr</code> are container.begin() and container.end(), respectively;</p>\n<p id=\"so_13548339_13548339_2\">(C) otherwise, <code>beginexpr</code> and <code>endexpr</code> are <code>begin(container)</code> and <code>end(container)</code>, respectively, where begin and end are looked up with argument-dependent lookup (3.4.2).</p>\n</blockquote>\n<p>Is it possible to define a set of overloads or specializations of <code>addup</code> such that it will handle the four cases, and not conflict with other overloads?  That is firstly a regular iterator pair function, and then each of A, B and C above.  How?</p>\n<p>(If this is possible than why doesn't the standard library offer such overloads?)</p>\n<p>Also, what if the function takes extra parameters beyond the container?  Can we modify the overloads in such a way that an <em>optional extra parameter</em> <code>x</code> (one with a default value) added to all of them will not make the following two calls ambiguous:</p>\n<pre><code>addup(v.begin(), v.end());\naddup(v, x);\n</code></pre>\n<p>That is can we statically assert (using \"SFINAE\" or similar) that the template parameter has to be an iterator, an array, a container class, etc - and have this information used for overload disambiguation?</p>\n", "AcceptedAnswerId": "13548423", "Title": "C++11: Defining Function With Container Parameter (like range-based for)?", "CreationDate": "2012-11-25T04:38:59.733", "Id": "13548339", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2012-11-25T04:53:28.280", "LastEditorUserId": "1131467", "LastActivityDate": "2012-11-25T15:47:23.407", "Score": "13", "OwnerUserId": "1131467", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "13548557": {"Id": "13548557", "PostTypeId": "2", "Body": "<p>A few cases:</p>\n<ul>\n<li>If you do not have any other parameters it is possible to handle all cases using <code>std::begin</code> and <code>std::end</code></li>\n<li>There's an additional parameter whose type is not a template or is dependent on your range/iterator (for instance <code>T::value_type</code> will work both on the range and on the iterators) or has a default value. Then there's no problem again.</li>\n<li>There's an additional parameter whose is unrelated to the range and whose type is a template and has no default. Then you can't do it without specifying the manually that type while calling your function.</li>\n</ul>\n<p>Here is an example:</p>\n<pre><code>template &lt;class Thing, class Iterator&gt;\nvoid DoStuff(Iterator first, Iterator last, Thing thing = Thing())\n{ ... }\n\ntemplate &lt;class Thing, class Range&gt;\nvoid DoStuff(Range&amp; range, Thing thing = Thing())\n{ ... }\n\n\nvector&lt;int&gt; coin = {1,2,3,4};\nDoStuff(coin, 123); // OK\nDoStuff(begin(coin), end(coin), 123); // OK\nDoStuff&lt;int&gt;(coin); // OK\nDoStuff&lt;int&gt;(begin(coin), end(coin)); // OK\n\nDoStuff(coin); // !! KO\nDoStuff(begin(coin), end(coin)); // !! KO\n</code></pre>\n<p>If you replace <code>Thing</code> by <code>typename Range::value_type</code> or <code>int</code> (and move it to the second position in the template argument list) then all overloads will work. You can also give <code>Thing</code> a default value.</p>\n", "LastActivityDate": "2012-11-25T05:23:48.667", "CommentCount": "0", "CreationDate": "2012-11-25T05:23:48.667", "ParentId": "13548339", "Score": "3", "OwnerUserId": "628361"}, "bq_ids": {"n4140": {"so_13548339_13548339_2": {"length": 8, "quality": 0.6153846153846154, "section_id": 3906}, "so_13548339_13548339_1": {"length": 21, "quality": 0.8076923076923077, "section_id": 3906}}, "n3337": {"so_13548339_13548339_2": {"length": 9, "quality": 0.6923076923076923, "section_id": 3766}, "so_13548339_13548339_1": {"length": 21, "quality": 0.8076923076923077, "section_id": 3766}}, "n4659": {"so_13548339_13548339_2": {"length": 7, "quality": 0.5384615384615384, "section_id": 4792}, "so_13548339_13548339_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 6103}, "so_13548339_13548339_1": {"length": 18, "quality": 0.6923076923076923, "section_id": 4792}}}, "13548423": {"Id": "13548423", "PostTypeId": "2", "Body": "<p>This is what I would do:</p>\n<pre><code>template&lt;class Range&gt;\nint addup(Range&amp;&amp; range)\n{\n    using std::begin;\n    using std::end;\n    addup(begin(range), end(range));  // begin(), NOT std::begin()  (ADL)\n}\n</code></pre>\n<p>It will handle all the important cases and does ADL properly. I'm not sure if it's equivalent to what ranged-based-for does but in my opinion it is the best solution.</p>\n<blockquote>\n<p id=\"so_13548339_13548423_0\">the following two calls ambiguous:</p>\n</blockquote>\n<p>I haven't compiled, but I don't see any ambiguity there unless <code>x</code> needs an implicit conversion. You can also use <code>boost::make_iterator_range</code> and avoid having an iterator parameter overload.</p>\n<hr>\n<p>I think this will also work:</p>\n<pre><code>template&lt;class Range&gt;\nint addup(Range&amp;&amp; range)\n{\n    int x = 0;\n    for(auto&amp;&amp; v : range)\n        x += v;\n    return x; \n}\n\ntemplate &lt;class I&gt;\nint addup (I first, I last)\n{\n    return addup(boost::make_iterator_range(first, last));\n}\n</code></pre>\n</hr>", "LastEditorUserId": "964135", "LastActivityDate": "2012-11-25T15:47:23.407", "Score": "11", "CreationDate": "2012-11-25T04:57:01.183", "ParentId": "13548339", "CommentCount": "11", "OwnerUserId": "964135", "LastEditDate": "2012-11-25T15:47:23.407"}});