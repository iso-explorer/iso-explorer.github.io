post_cb({"bq_ids": {"n4140": {"so_26414443_26414748_0": {"length": 25, "quality": 1.0, "section_id": 3324}, "so_26414443_26414748_1": {"length": 45, "quality": 0.9574468085106383, "section_id": 599}}, "n3337": {"so_26414443_26414748_0": {"length": 25, "quality": 1.0, "section_id": 3194}, "so_26414443_26414748_1": {"length": 45, "quality": 0.9574468085106383, "section_id": 589}}, "n4659": {"so_26414443_26414748_0": {"length": 24, "quality": 0.96, "section_id": 4090}, "so_26414443_26414748_1": {"length": 45, "quality": 0.9574468085106383, "section_id": 622}}}, "26414443": {"ViewCount": "41", "Body": "<p>Tangentially-related, follow-on beginner question to a question that I had originally posted <a href=\"https://stackoverflow.com/questions/26391745/custom-array-class-constructor-for-initialization-of-list/26391928?noredirect=1#comment41438118_26391928\">here</a>.</p>\n<p>In short: how (without using any of the standard library's containers) can I access the pointers of type <code>T</code> that point to the first and last element of a list-initialization? In case my explanation is not understandable:</p>\n<p><code>int x = {1, 2, 3, 4, 5}</code></p>\n<p>If I wanted to create a custom class <code>template&lt;typename T&gt; class array&lt;T&gt; {};</code> that I can list-initialize, it's my understanding that I could leverage <code>std::initializer_list</code> to be <a href=\"http://en.cppreference.com/w/cpp/utility/initializer_list\" rel=\"nofollow noreferrer\">able to do this</a>. </p>\n<p>My question is: how would I be able to replicate that behavior? It looks like it leverages <a href=\"http://en.cppreference.com/w/cpp/utility/initializer_list/begin2\" rel=\"nofollow noreferrer\">std::begin()</a> to do this, but (unless I'm mistaken) that still begs the question: how can I write code that says \"return a pointer to the first element of a list to be allocated on the stack\" and, at the same time, \"return a pointer to the first-past-the-last element of a list to be allocated on the stack\"?</p>\n<p>I realize that there's a significant \"reinventing-the-wheel\" component to my question (i.e. why shouldn't I go ahead and use <code>std::initializer_list</code>), but I just want to make sure I understand what the standard library is doing. </p>\n", "AcceptedAnswerId": "26414748", "Title": "Pointers to First and Last Members: List Initialization", "CreationDate": "2014-10-16T21:45:27.047", "Id": "26414443", "CommentCount": "3", "LastEditDate": "2017-05-23T10:33:35.247", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-16T22:28:20.773", "Score": "0", "OwnerUserId": "2174678", "Tags": "<c++>", "AnswerCount": "1"}, "26414748": {"Id": "26414748", "PostTypeId": "2", "Body": "<p>If you want to write your own <code>initializer_list</code>, that's not possible. By this I mean that you can't achieve the behavior where a line like this</p>\n<pre><code>array&lt;int&gt; a = {1, 2, 3, 4};\n</code></pre>\n<p>would call a contructor like <code>array(my_custom_initializer_list)</code>.</p>\n<p>This is because <code>std::initializer_list</code> is a special class which is explicitly mentioned in the C++ standard as the argument type for list-initialization.</p>\n<p>The relevant quotes are spread all over the text, but the essential parts are: </p>\n<h3>8.5.4/2 List-initialization:</h3>\n<blockquote>\n<p id=\"so_26414443_26414748_0\">A constructor is an <em>initializer-list constructor</em> if its first parameter is of type <code>std::initializer_list&lt;E&gt;</code> or reference to possibly cv-qualified <code>std::initializer_list&lt;E&gt;</code> for some type <code>E</code>, and either there are no other parameters or else all other parameters have default arguments</p>\n</blockquote>\n<h3>13.3.1.7 Initialization by list-initialization:</h3>\n<blockquote>\n<p id=\"so_26414443_26414748_1\">When objects of non-aggregate class type <code>T</code> are list-initialized (8.5.4), overload resolution selects the constructor in two phases:<br>\n  \u2014 Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class T and the argument list consists of the initializer list as a single argument.<br>\n  \u2014 If no viable initializer-list constructor is found, overload resolution is performed again, where the\n  candidate functions are all the constructors of the class T and the argument list consists of the elements\n  of the initializer list.</br></br></p>\n</blockquote>\n", "LastEditorUserId": "3959454", "LastActivityDate": "2014-10-16T22:28:20.773", "Score": "2", "CreationDate": "2014-10-16T22:09:30.317", "ParentId": "26414443", "CommentCount": "0", "OwnerUserId": "3959454", "LastEditDate": "2014-10-16T22:28:20.773"}});