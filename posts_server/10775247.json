post_cb({"10775259": {"ParentId": "10775247", "CommentCount": "7", "Body": "<p><strong>Yes it is</strong>. Deleting an object of a derived <code>class</code> through a pointer to a base class with no <code>virtual</code> destructor is textbook UB.</p>\n<p><strong>5.3.5/3:</strong></p>\n<blockquote>\n<p id=\"so_10775247_10775259_0\">In the first alternative (delete object), if the static type of the\n  operand is different from its dynamic type, the static type shall be a\n  base class of the operand\u2019s dynamic type and the static type shall\n  have a virtual destructor or the behavior is undefined. In the second\n  alternative (delete array) if the dynamic type of the object to be\n  deleted differs from its static type, the behavior is undefined.73)</p>\n</blockquote>\n<p>Because it's undefined behavior, it doesn't really make sense to guess whether the code will leak or not. Just attempt to fix the code instead of predicting results.</p>\n", "OwnerUserId": "673730", "PostTypeId": "2", "Id": "10775259", "Score": "7", "CreationDate": "2012-05-27T15:49:31.983", "LastActivityDate": "2012-05-27T15:49:31.983"}, "10775247": {"CommentCount": "0", "ViewCount": "114", "CreationDate": "2012-05-27T15:48:33.403", "LastActivityDate": "2012-05-27T15:51:00.430", "Title": "Is this undefined behavior or not?", "PostTypeId": "1", "Id": "10775247", "Score": "0", "Body": "<pre><code>class A\n{\npublic:\n    int i;\n    ~A()\n    {   \n        std::cout &lt;&lt; \"~A\" &lt;&lt; std::endl;\n    }   \n};\n\nclass B: public A\n{\npublic:\n    int k;\n    ~B()\n    {   \n        std::cout &lt;&lt; \"~B\" &lt;&lt; std::endl;\n    }   \n};\n\nint main(int argc, char* argv[])\n{\n    A* p = new B();\n    delete p;\n    return 0;\n}\n</code></pre>\n<p>The above doesn't cause memory leak though base destructor is not virtual and I know the reason.</p>\n<p>But is this undefined behavior or not?</p>\n<p>Say there won't be memory leak if derived class doesn't point to other dynamic data even though base destructor is non-virtual?</p>\n", "Tags": "<c++><standards>", "OwnerUserId": "807893", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_10775247_10775266_0": {"section_id": 6107, "quality": 0.88, "length": 22}, "so_10775247_10775259_0": {"section_id": 6107, "quality": 0.8717948717948718, "length": 34}}, "n3337": {"so_10775247_10775266_0": {"section_id": 5873, "quality": 0.88, "length": 22}, "so_10775247_10775259_0": {"section_id": 5873, "quality": 0.8717948717948718, "length": 34}}, "n4659": {"so_10775247_10775266_0": {"section_id": 7604, "quality": 0.88, "length": 22}, "so_10775247_10775259_0": {"section_id": 7604, "quality": 0.8717948717948718, "length": 34}}}, "10775266": {"ParentId": "10775247", "CommentCount": "0", "Body": "<p>Yes, since the static type (here it's <code>A</code>) differs from the dynamic type (<code>B</code> in your example) and there's no <code>virtual</code> destructor, it's an UB.</p>\n<p>5.3.5/2 (5.3.5/3 in C++11):</p>\n<blockquote>\n<p id=\"so_10775247_10775266_0\">In the first alternative (delete object), if the static type of the operand is different from its dynamic type, the\n  static type shall be a base class of the operand\u2019s dynamic type and the static type shall have a virtual\n  destructor or the behavior is undefined.</p>\n</blockquote>\n", "OwnerUserId": "784668", "PostTypeId": "2", "Id": "10775266", "Score": "4", "CreationDate": "2012-05-27T15:51:00.430", "LastActivityDate": "2012-05-27T15:51:00.430"}});