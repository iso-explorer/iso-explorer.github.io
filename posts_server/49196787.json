post_cb({"49197446": {"Id": "49197446", "PostTypeId": "2", "Body": "<p>C language answer:</p>\n<p>Regular variable declarations and parameter declarations <strong>are not</strong> always identical. This is regulated by the C standard C11 6.7.6.3 \"Function declarators\", where we can read</p>\n<blockquote>\n<p id=\"so_49196787_49197446_0\">The only storage-class specifier that shall occur in a parameter declaration is register.</p>\n</blockquote>\n<p>This alone is a major difference. We cannot have parameters that are <code>static</code> or <code>extern</code> - they can only be <code>auto</code>(default) or <code>register</code>.</p>\n<blockquote>\n<p id=\"so_49196787_49197446_1\">A declaration of a parameter as \u2018\u2018array of type\u2019\u2019 shall be adjusted to \u2018\u2018qualified pointer to\n  type\u2019\u2019,</p>\n</blockquote>\n<p>Meaning all parameters that are declared as arrays get adjusted to a pointer to the first element of that array. This is what happens in your example!</p>\n<p><code>int (*p[3])(int, double);</code> or<br>\n<code>int (*p[])(int, double);</code> or<br>\n<code>int (*p[666])(int, double);</code></br></br></p>\n<p>when written as a parameter to a function, all get adjusted (\"decay\") into a pointer to the first element. That is, <em>a pointer to a function pointer to a function accepting int, double and returning int</em>. Aka this monstrosity: <code>int (**p)(int, double)</code>;</p>\n<p>You get away with the empty <code>[]</code> just because the compiler doesn't care about the array boundaries. This would actually create an array of incomplete type (which wouldn't be allowed), but the compiler adjusts it to a pointer to the first element instead, so the array size is irrelevant, as that part is lost during \"adjustment\" anyway.</p>\n<blockquote>\n<p id=\"so_49196787_49197446_2\">A declaration of a parameter as \u2018\u2018function returning type\u2019\u2019 shall be adjusted to \u2018\u2018pointer to\n  function returning type\u2019\u2019, as in 6.3.2.1.</p>\n</blockquote>\n<p>Meaning that if you get the crazy idea to pass a whole function to another function, it gets adjusted to a function pointer. Meaning that crazy code like <code>void func( int p (int, double) )</code> is actually valid and equivalent to <code>void func( int (*p)(int, double) )</code>. This is a special case for function parameters. </p>\n", "LastActivityDate": "2018-03-09T15:51:43.627", "Score": "4", "CreationDate": "2018-03-09T15:51:43.627", "ParentId": "49196787", "CommentCount": "0", "OwnerUserId": "584518"}, "bq_ids": {"n4140": {"so_49196787_49197446_1": {"length": 5, "quality": 0.625, "section_id": 300}, "so_49196787_49197446_2": {"length": 8, "quality": 0.7272727272727273, "section_id": 558}}, "n3337": {"so_49196787_49197446_1": {"length": 5, "quality": 0.625, "section_id": 291}, "so_49196787_49197446_2": {"length": 8, "quality": 0.7272727272727273, "section_id": 549}}, "n4659": {"so_49196787_49197446_1": {"length": 6, "quality": 0.75, "section_id": 3997}, "so_49196787_49197446_2": {"length": 8, "quality": 0.7272727272727273, "section_id": 581}}}, "49197068": {"Id": "49197068", "PostTypeId": "2", "Body": "<p><em>Disclaimer</em> This answer was written when C++ was the sole language tag of the question.</p>\n<blockquote>\n<p id=\"so_49196787_49197068_0\">When you normally declare an array of pointer to functions, you will\n  write</p>\n<pre><code>int (*p[3])(int, double);\n</code></pre>\n</blockquote>\n<p>No. That is a false premise.</p>\n<p>You write it like this:</p>\n<pre><code>using My_callback_t = int (int, double);\n\nstd::array&lt;My_callback_t*, 3&gt; p;\n// or\nstd::array&lt;std::function&lt;My_callback_t&gt;, 3&gt; p;\n</code></pre>\n<p>Or use <code>std::vector</code> instead of <code>std::array</code> for more flexibility.</p>\n<p>The rest of the question becomes moot in my opinion, but for your amusement this is the monstrosity you are asking for:</p>\n<pre><code>void func(int (*(&amp;p)[3])(int, double))\n{\n}\n</code></pre>\n<p>Just in case I wasn't clear enough: Don't write this!!</p>\n<pre><code>void func(int (*(&amp;p)[3])(int, double))\n                  ^                       p\n                 ^                        is a reference\n                    ^                     to an array\n                     ^                    of 3 elements of type\n               ^                          pointer\n                        ^                 to function\n                         ^~~~~~~~~~~~     receiving 2 params of type int and double\n          ^~~                             and returning int\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~      Kill. Me. Now!\n</code></pre>\n", "LastEditorUserId": "2805305", "LastActivityDate": "2018-03-09T16:53:50.790", "Score": "4", "CreationDate": "2018-03-09T15:30:23.957", "ParentId": "49196787", "CommentCount": "7", "OwnerUserId": "2805305", "LastEditDate": "2018-03-09T16:53:50.790"}, "49196787": {"ViewCount": "94", "Body": "<p>By \"normal variable declarations\", I assume the declarations like the below.</p>\n<pre><code>int a = 3;\n</code></pre>\n<p>If you define a parameter of a function, you will write like this:</p>\n<pre><code>void func(int a) {\n    &lt;statement&gt;\n}\n</code></pre>\n<p>Let's assume a more complicated case. When you normally declare an array of pointer to functions, you will write</p>\n<pre><code>int (*p[3])(int, double);\n</code></pre>\n<p>and if you'd like to set this array as a function parameter, you will write</p>\n<pre><code>void func(int (*p[])(int, double)) {\n    &lt;statement&gt;\n}\n</code></pre>\n<p>Now I found that, in any cases, the both ways look almost the same. However, I don't find what kind of \"written evidence\" assure this rule. In other words, when I write a super complex normal declaration, by what can I believe that I'm able to set the object as a function parameter with the way I just now used in normally declaring the object? As far as I know, this rule is true, but it seems there is no evidence, though I visited so many websites in English and Japanese and even read the C++11 draft.</p>\n<p>Does anyone have the evidence?</p>\n", "AcceptedAnswerId": "49197446", "Title": "Does anyone have the written evidence which assure that the way parameters are defined in a function is the same as normal variable declarations?", "CreationDate": "2018-03-09T15:14:48.357", "LastActivityDate": "2018-03-09T16:53:50.790", "CommentCount": "16", "LastEditDate": "2018-03-09T16:15:57.063", "PostTypeId": "1", "LastEditorUserId": "2380830", "Id": "49196787", "Score": "1", "OwnerUserId": "8776746", "Tags": "<c++><c><language-lawyer>", "AnswerCount": "2"}});