post_cb({"39287634": {"ParentId": "39286114", "CommentCount": "1", "Body": "<p>IMHO I believe that GCC is wrong and CLANG is correct here. I'll try to justify my claim below:</p>\n<p>According to the standard <em>\u00a714.8.3/p1 Overload resolution [temp.over] (<strong>Emphasis Mine</strong>)</em>:</p>\n<blockquote>\n<p id=\"so_39286114_39287634_0\">A function template can be overloaded either by (non-template)\n  functions of its name or by (other) function templates of the same\n  name. When a call to that name is written (explicitly, or implicitly\n  using the operator notation), <strong>template argument deduction (14.8.2)\n  and checking of any explicit template arguments (14.3) are performed\n  for each function template to find the template argument values (if\n  any) that can be used with that function template to instantiate a\n  function template specialisation that can be invoked with the call\n  arguments. For each function template, if the argument deduction and\n  checking succeeds, the template-arguments (deduced and/or explicit)\n  are used to synthesise the declaration of a single function template\n  specialisation which is added to the candidate functions set to be\n  used in overload resolution.</strong> If, for a given function template,\n  argument deduction fails or the synthesised function template\n  specialisation would be ill-formed, no such function is added to the\n  set of candidate functions for that template. The complete set of\n  candidate functions includes all the synthesised declarations and all\n  of the non-template overloaded functions of the same name. The\n  synthesised declarations are treated like any other functions in the\n  remainder of overload resolution, except as explicitly noted in\n  13.3.3.<sup>144</sup></p>\n<p id=\"so_39286114_39287634_1\">[Example:</p>\n<pre><code>template&lt;class T&gt; T max(T a, T b) { return a&gt;b?a:b; }\nvoid f(int a, int b, char c, char d) {\nint m1 = max(a,b); // max(int a, int b)\nchar m2 = max(c,d); // max(char a, char b)\nint m3 = max(a,c); // error: cannot generate max(int,char)\n}\n</code></pre>\n<p id=\"so_39286114_39287634_2\"><sub>144) The parameters of function template specializations contain\n  no template parameter types. The set of conversions allowed on deduced\n  arguments is limited, because the argument deduction process produces\n  function templates with parameters that either match the call\n  arguments exactly or differ only in ways that can be bridged by the\n  allowed limited conversions. Non-deduced arguments allow the full\n  range of conversions. Note also that 13.3.3 specifies that a\n  non-template function will be given preference over a template\n  specialisation if the two functions are otherwise equally good\n  candidates for an overload match.</sub></p>\n</blockquote>\n<p>From the above we get that explicit template arguments will be checked and if checking succeeds then will be used to synthesise a specialisation that will be added to the candidate functions for overload resolution. Thus, the fact the you specify explicitly <code>X</code> is irrelevant for the process.</p>\n<p>Also from the C++ standard <em>\u00a713.3.3/p1.7 Best viable function [over.match.best]</em>:</p>\n<blockquote>\n<p id=\"so_39286114_39287634_3\"><code>F1</code> and <code>F2</code> are function template specialisations, and the function\n  template for <code>F1</code> is more specialised than the template for <code>F2</code>\n  according to the partial ordering rules described in 14.5.6.2.</p>\n</blockquote>\n<p>Now from <em>\u00a714.5.6.2/p3 Partial ordering of function templates [temp.func.order]</em> we get that in partial ordering parameters packs are also into play, so no problem also here.</p>\n<p>Now:</p>\n<pre><code>template &lt;typename X, typename... T&gt;\nauto bar(int, T...) -&gt; void;\n</code></pre>\n<p>is more specialized than:</p>\n<pre><code>template &lt;typename X, typename Check, typename... T&gt;\nauto bar(Check, T...) -&gt; void;\n</code></pre>\n<p>Therefore calling:</p>\n<pre><code>bar&lt;void&gt;(7, \"\");\n</code></pre>\n<p>is not ambiguous. </p>\n<p>Based on the above I believe that this is a GCC bug.</p>\n", "OwnerUserId": "2352671", "PostTypeId": "2", "Id": "39287634", "Score": "0", "CreationDate": "2016-09-02T08:22:53.900", "LastActivityDate": "2016-09-02T08:22:53.900"}, "39295906": {"ParentId": "39286114", "CommentCount": "0", "Body": "<p>This is <a href=\"http://wg21.link/cwg200\" rel=\"nofollow\">core issue 200</a>.</p>\n<blockquote>\n<p id=\"so_39286114_39295906_0\">The description of how the partial ordering of template functions is\n  determined in 14.5.6.2 [temp.func.order] paragraphs 3-5 does not make\n  any provision for nondeduced template parameters. For example, the\n  function call in the following code is ambiguous, even though one\n  template is \"obviously\" more specialized than the other:</p>\n<pre><code>template &lt;class T&gt; T f(int);\ntemplate &lt;class T, class U&gt; T f(U);\nvoid g() {\n    f&lt;int&gt;(1);\n}\n</code></pre>\n<p id=\"so_39286114_39295906_1\">The reason is that neither function parameter list allows template parameter <code>T</code> to be deduced; both deductions fail, so neither\n  template is considered more specialized than the other and the\n  function call is ambiguous.</p>\n</blockquote>\n<p>The resolution of <a href=\"http://wg21.link/cwg214\" rel=\"nofollow\">core issue 214</a>, which this one was reduced to, introduced <a href=\"http://eel.is/c++draft/temp.deduct.partial#11\" rel=\"nofollow\">[temp.deduct.partial]/11</a>:</p>\n<blockquote>\n<p id=\"so_39286114_39295906_2\">In most cases, all template parameters must have values in order for deduction to succeed, <strong>but for partial ordering purposes a template parameter may remain without a value provided it is not used in the types being used for partial ordering</strong>.</p>\n</blockquote>\n<p>Apparently GCC's implementation of this wording is buggy once packs come into play. </p>\n", "OwnerUserId": "3647361", "PostTypeId": "2", "Id": "39295906", "Score": "4", "CreationDate": "2016-09-02T15:24:25.813", "LastActivityDate": "2016-09-02T15:24:25.813"}, "bq_ids": {"n4140": {"so_39286114_39287634_3": {"section_id": 603, "quality": 0.8, "length": 12}, "so_39286114_39295906_2": {"section_id": 330, "quality": 1.0, "length": 25}, "so_39286114_39287634_0": {"section_id": 355, "quality": 0.8617886178861789, "length": 106}, "so_39286114_39287634_2": {"section_id": 355, "quality": 0.9206349206349206, "length": 58}}, "n3337": {"so_39286114_39287634_3": {"section_id": 593, "quality": 0.8, "length": 12}, "so_39286114_39295906_2": {"section_id": 320, "quality": 1.0, "length": 25}, "so_39286114_39287634_0": {"section_id": 345, "quality": 0.8617886178861789, "length": 106}, "so_39286114_39287634_2": {"section_id": 345, "quality": 0.9206349206349206, "length": 58}}, "n4659": {"so_39286114_39287634_3": {"section_id": 629, "quality": 0.8, "length": 12}, "so_39286114_39295906_2": {"section_id": 339, "quality": 1.0, "length": 25}, "so_39286114_39287634_0": {"section_id": 365, "quality": 0.8943089430894309, "length": 110}, "so_39286114_39287634_2": {"section_id": 365, "quality": 0.9206349206349206, "length": 58}}}, "39286114": {"CommentCount": "4", "AcceptedAnswerId": "39295906", "PostTypeId": "1", "LastEditorUserId": "2352671", "CreationDate": "2016-09-02T06:57:12.357", "LastActivityDate": "2016-09-02T15:24:25.813", "LastEditDate": "2016-09-02T08:24:28.800", "ViewCount": "254", "FavoriteCount": "1", "Title": "gcc vs. clang, msvc and icc: Is this function call ambiguous?", "Id": "39286114", "Score": "9", "Body": "<p>All compilers I could get my hands on agree that this is fine:</p>\n<pre><code>template &lt;typename Check, typename... T&gt;\nauto foo(Check, T...) -&gt; void;\n\ntemplate &lt;typename... T&gt;\nauto foo(int, T...) -&gt; void;\n\nint main()\n{\n  foo(7, \"\");\n}\n</code></pre>\n<p>However, the following code (with a leading template parameter that cannot be deduced from the function parameters) is ambiguous according to gcc:</p>\n<pre><code>template &lt;typename X, typename Check, typename... T&gt;\nauto bar(Check, T...) -&gt; void;\n\ntemplate &lt;typename X, typename... T&gt;\nauto bar(int, T...) -&gt; void;\n\nint main()\n{\n  bar&lt;void&gt;(7, \"\"); // ambiguous according to gcc\n  bar&lt;void&gt;(7);     // just fine\n}\n</code></pre>\n<p>On the other hand, clang, msvc and icc are quite happy with this.</p>\n<p>Which compiler is right?</p>\n<p>References to the respective sections of the standard preferred.</p>\n", "Tags": "<c++><c++11><language-lawyer><partial-ordering>", "OwnerUserId": "2173029", "AnswerCount": "2"}});