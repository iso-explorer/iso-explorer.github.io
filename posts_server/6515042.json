post_cb({"6515042": {"CommentCount": "1", "AcceptedAnswerId": "6515176", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2011-06-29T02:08:10.683", "LastActivityDate": "2011-06-29T08:56:05.980", "LastEditDate": "2011-06-29T08:56:05.980", "ViewCount": "418", "FavoriteCount": "1", "Title": "Class component order of initialisation", "Id": "6515042", "Score": "10", "Body": "<pre><code>class D: A\n{\n    B obj;\n    C obj2;\n}\n</code></pre>\n<p>What order of construction here is <em>guaranteed</em>?</p>\n<p>I know that D will be constructed after A, B and C, but what I really want to know is whether A is <em>guaranteed</em> to be constructed before B or C, or even whether B is <em>guaranteed</em> to be constructed before C.</p>\n<p>I know you can have an explicit initialiser list:</p>\n<pre><code>D(): A(), B(), C()\n{}\n</code></pre>\n<p>but does that initialiser list determine the <em>order</em> of initialisation?</p>\n<p>Also, does whether or not any of the components do or don't have a default constructor?</p>\n", "Tags": "<c++><standards>", "OwnerUserId": "259846", "AnswerCount": "3"}, "6515176": {"ParentId": "6515042", "CommentCount": "0", "Body": "<p>From the C++03 standard ISO/IEC 14882:2003(E) \u00a712.6.2/5 [class.base.init]:</p>\n<blockquote>\n<p id=\"so_6515042_6515176_0\">Initialization shall proceed in the following order:<br>\n  \u2014 First, and only for the constructor of the most derived class as described below, virtual base classes shall be initialized in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes, where \u201cleft-to-right\u201d is the order of appearance of the base class names in the derived class <em>base-specifier-list</em>.<br>\n  \u2014 Then, direct base classes shall be initialized in declaration order as they appear in the <em>base-specifier-list</em> (regardless of the order of the <em>mem-initializers</em>).<br>\n  \u2014 Then, nonstatic data members shall be initialized in the order they were declared in the class definition (again regardless of the order of the <em>mem-initializers</em>).<br>\n  \u2014 Finally, the body of the constructor is executed.<br>\n  [<em>Note:</em> the declaration order is mandated to ensure that base and member subobjects are destroyed in the reverse order of initialization. ]</br></br></br></br></br></p>\n</blockquote>\n<p>So in this case, you are guaranteed that the order of initialization will be first the base class <code>A</code>, then the subobject <code>B</code> (since it appears first in the list of class members in the class definition), then the subobject <code>C</code>.  The order of the initializer list is irrelevant, as is whether or not any of the members do or do not have a default constructor\u2014if a member does not have a default constructor and it is not explicitly initialized in an initializer list, then it has an unspecified value.</p>\n", "OwnerUserId": "9530", "PostTypeId": "2", "Id": "6515176", "Score": "10", "CreationDate": "2011-06-29T02:32:50.940", "LastActivityDate": "2011-06-29T02:32:50.940"}, "6515147": {"ParentId": "6515042", "CommentCount": "1", "Body": "<p>Perhaps this example of broken code will help illustrate:</p>\n<p>If I define a class like so:</p>\n<pre><code>class Connection {\n\n   boost::asio::tcp::ip::socket _socket;\n   boost::asio::io_service _io_service;\n\n   Connection() : _io_service(), _socket(_io_service)\n   {\n   }\n};\n</code></pre>\n<p>This will fail in all modern compilers. Because <code>_socket</code> is defined first as a class member, the initialization list will try to initialize it first, despite the fact that the initialization list asks the compiler to initialize <code>_io_service</code> first. But since <code>_io_service</code> has not yet been initialized (the socket constructor depends on an initialized <code>_io_service</code>), the initialization of <code>_socket</code> will cause a segfault.</p>\n<p>Perhaps somebody can quote the appropriate section of the standard that dictates this behaviour.</p>\n<p>For the second half of the question, base classes will always be initialized before the classes own members.</p>\n", "OwnerUserId": "591057", "PostTypeId": "2", "Id": "6515147", "Score": "1", "CreationDate": "2011-06-29T02:27:27.677", "LastActivityDate": "2011-06-29T02:27:27.677"}, "bq_ids": {"n4140": {"so_6515042_6515176_0": {"section_id": 438, "quality": 0.9, "length": 72}}, "n3337": {"so_6515042_6515176_0": {"section_id": 429, "quality": 0.9, "length": 72}}, "n4659": {"so_6515042_6515176_0": {"section_id": 458, "quality": 0.9, "length": 72}}}, "6515128": {"ParentId": "6515042", "PostTypeId": "2", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_6515042_6515128_0\">but does that initialiser list determinethe ORDER of initialisation?</p>\n</blockquote>\n<p><strong>No</strong>. Initialization-list <strong>doesn't</strong> determine the the order of initialization of member data and the base subobject(s). Members are initialized in order of their declaration, and base subobjects are constructed in the order of their mention - from left to right:</p>\n<pre><code>struct A : B, C {}  //B is constructed before C\n</code></pre>\n<p>Also, the base subobjects are constructed before the initialization of the member data.</p>\n<pre><code>struct A : B, C \n{\n      D d;\n      E e;\n};\n</code></pre>\n<p>Order of initialization in the above struct:</p>\n<pre><code>    B     =&gt;    C      =&gt;   d    =&gt;   e   \nsubobject   subobject     member    member\n</code></pre>\n<p>And they're destructed in the reverse order.</p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-06-29T06:05:34.613", "Id": "6515128", "Score": "9", "CreationDate": "2011-06-29T02:24:21.633", "LastActivityDate": "2011-06-29T06:05:34.613"}});