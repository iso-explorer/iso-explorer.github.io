post_cb({"30650073": {"CommentCount": "7", "ViewCount": "409", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-06-04T17:09:59.187", "LastActivityDate": "2015-07-01T13:06:35.320", "Title": "C++ dynamic downcasting to class template having template template parameter being a class template or an alias template", "AcceptedAnswerId": "30654483", "LastEditDate": "2017-05-23T12:15:44.670", "Id": "30650073", "Score": "2", "Body": "<p>I hope the title makes sense. I probably miss vocabulary to express it correctly.</p>\n<p>Well, an exemple will probably be more clear.</p>\n<p>Problem for me is: dynamic downcasting returns 0 at run time in some of the following cases (written in comments). I'd like to know if it's a correct behaviour (using C++11), also why, and what can I do to make it work. Apparently, Templated and A::A_templated are treated as different classes, despite being defined as identical by using alias \"using\". Problem doesn't appear for simple typedef alias.</p>\n<pre><code>template &lt;class T&gt;\nclass Templated {};\n\nclass A {\n    public :\n    typedef int A_Type;\n    template &lt;class T&gt;\n    using A_Templated = Templated&lt;T&gt;;\n};\n\nclass Test_base {\n    public :\n    Test_base() {}\n    virtual void foo()=0;\n};\n\ntemplate &lt;class T&gt;\nclass Test_Type : public Test_base {\n    public :\n    Test_Type() {}\n    void foo() {}\n};\n\ntemplate &lt; template &lt;class T&gt; class TT &gt;\nclass Test_Templated : public Test_base {\n    public :\n    Test_Templated() {}\n    void foo() {}\n};\n\nint main() {\n    Test_base* test;\n\n    test = new Test_Type&lt;int&gt;;\n    std::cout &lt;&lt; dynamic_cast&lt; Test_Type&lt;int&gt;* &gt;(test) &lt;&lt; std::endl;//--&gt;ok\n    std::cout &lt;&lt; dynamic_cast&lt; Test_Type&lt;A::A_Type&gt;* &gt;(test) &lt;&lt; std::endl;//--&gt;ok\n\n    test = new Test_Templated&lt;Templated&gt;;\n    std::cout &lt;&lt; dynamic_cast&lt; Test_Templated&lt;Templated&gt;* &gt;(test) &lt;&lt; std::endl;//--&gt;ok\n    std::cout &lt;&lt; dynamic_cast&lt; Test_Templated&lt;A::A_Templated&gt;* &gt;(test) &lt;&lt; std::endl;//--&gt; returns 0 !\n\n    test = new Test_Templated&lt;A::A_Templated&gt;;\n    std::cout &lt;&lt; dynamic_cast&lt; Test_Templated&lt;A::A_Templated&gt;* &gt;(test) &lt;&lt; std::endl;//--&gt;ok\n    std::cout &lt;&lt; dynamic_cast&lt; Test_Templated&lt;Templated&gt;* &gt;(test) &lt;&lt; std::endl;//--&gt; returns 0 !\n\n\n}\n</code></pre>\n<hr>\n<p>I propose another way to see the problem, this is probably more clear. I'm facing it after trying to avoid the example above. The following example's basically says what Bogdan pointed out. I find very frustrating the fact the compiler can't resolve Templated with Templated_alias. I'm wondering if a compilation option exists, which can sort of force type resolving through template aliases.</p>\n<pre><code>template &lt;class T&gt;\nclass Templated {};\n\ntemplate &lt;class T&gt;\nusing Templated_alias = Templated&lt;T&gt;;\n\ntemplate &lt; template &lt;class T&gt; class TT &gt;\nclass B;\n\ntemplate &lt;&gt;\nclass B&lt;Templated&gt; {\n    public :\n    void foo(Templated&lt;int&gt; _arg) {}\n};\n\nint main() {\n    B&lt;Templated&gt; b1;\n    b1.foo(Templated&lt;int&gt;());\n    b1.foo(Templated_alias&lt;int&gt;());//compiles =&gt; Templated_alias&lt;int&gt; is equivalent to Templated&lt;int&gt;\n    B&lt;Templated_alias&gt; b2;//Compilation error: Implicit instantiation of undefined template B&lt;Templated_alias&gt;\n    //which means: Templated_alias is not equivalent to Templated\n}\n</code></pre>\n<hr>\n<p>Thanks to Bogdan's trick, and after some little nose-bleeding, I managed to find some kind of solution. The idea is to build a class in charge of 'filtering' potential aliases of template classes. It needs one specification per template class needed to be 'filtered'. Main drawback of the method is that filtering thus needs to be used everywhere template classes are used as template parameters in order to be consistent.</p>\n<pre><code>//Classes to be dealt with\n\ntemplate &lt;class T&gt;\nclass Templated {};\n\ntemplate &lt;class T&gt;\nclass Templated2 {};\n\ntemplate &lt;class T&gt;\nusing Templated_alias = Templated&lt;T&gt;;\n\nclass A_base {\n    virtual void foo()=0;\n};\n\ntemplate &lt;template &lt;class T&gt; class TT&gt;\nclass A : public A_base {\n    void foo() {}\n};\n\n//Here starts the trick definition\n\ntemplate&lt;template&lt;class&gt; class TT1, template&lt;class&gt; class TT2&gt;\nusing is_same_template_t = typename std::is_same&lt;TT1&lt;int&gt;, TT2&lt;int&gt; &gt;::type;\n\n//Template Template aliasing\ntemplate &lt; template &lt;class T&gt; class TT &gt;\nclass TT_aliasing {\n    public :\n    template &lt;class T&gt;\n    using Class_T = TT&lt;T&gt;;\n};\n\n//Template Template Alias Filtering\ntemplate &lt; template &lt;class T&gt; class TT, class = std::true_type&gt;\nclass TT_AF {\n    public :\n    template &lt;class T&gt;\n    using Class_T = TT&lt;T&gt;;\n};\n\ntemplate &lt; template &lt;class T&gt; class TT &gt;\nclass TT_AF&lt;TT, is_same_template_t&lt;TT, Templated&gt; &gt; : public TT_aliasing&lt;Templated&gt; {};\n\nint main() {\n\n    A_base* a;\n    a = new A&lt; TT_AF&lt;Templated&gt;::Class_T &gt;();\n    std::cout &lt;&lt; dynamic_cast&lt; A&lt; TT_AF&lt;Templated&gt;::Class_T &gt;* &gt;(a) &lt;&lt; std::endl;\n    std::cout &lt;&lt; dynamic_cast&lt; A&lt; TT_AF&lt;Templated_alias&gt;::Class_T &gt;* &gt;(a) &lt;&lt; std::endl;\n    std::cout &lt;&lt; dynamic_cast&lt; A&lt; TT_AF&lt;Templated2&gt;::Class_T &gt;* &gt;(a) &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"---------------\" &lt;&lt; std::endl;\n\n    a = new A&lt; TT_AF&lt;Templated_alias&gt;::Class_T &gt;();\n    std::cout &lt;&lt; dynamic_cast&lt; A&lt; TT_AF&lt;Templated&gt;::Class_T &gt;* &gt;(a) &lt;&lt; std::endl;\n    std::cout &lt;&lt; dynamic_cast&lt; A&lt; TT_AF&lt;Templated_alias&gt;::Class_T &gt;* &gt;(a) &lt;&lt; std::endl;\n    std::cout &lt;&lt; dynamic_cast&lt; A&lt; TT_AF&lt;Templated2&gt;::Class_T &gt;* &gt;(a) &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"---------------\" &lt;&lt; std::endl;\n\n    a = new A&lt; TT_AF&lt;Templated2&gt;::Class_T &gt;();\n    std::cout &lt;&lt; dynamic_cast&lt; A&lt; TT_AF&lt;Templated&gt;::Class_T &gt;* &gt;(a) &lt;&lt; std::endl;\n    std::cout &lt;&lt; dynamic_cast&lt; A&lt; TT_AF&lt;Templated_alias&gt;::Class_T &gt;* &gt;(a) &lt;&lt; std::endl;\n    std::cout &lt;&lt; dynamic_cast&lt; A&lt; TT_AF&lt;Templated2&gt;::Class_T &gt;* &gt;(a) &lt;&lt; std::endl;\n\n    A&lt; TT_AF&lt;Templated&gt;::Class_T &gt; a1;\n    A&lt; TT_AF&lt;Templated_alias&gt;::Class_T &gt; a2;\n    a1 = a2;\n    A&lt; TT_AF&lt;Templated2&gt;::Class_T &gt; a3;\n    //a1 = a3;//no viable overloaded '='\n\n}\n</code></pre>\n<p>Output gives:</p>\n<pre><code>0x600000014ba0\n0x600000014ba0\n0x0\n---------------\n0x600000014bb0\n0x600000014bb0\n0x0\n---------------\n0x0\n0x0\n0x600000014bc0\n</code></pre>\n<hr>\n<p>After using the above trick. I ran into different problems. Can't be absolutely sure it's related but it's very likely. Compiler seems to struggle to correctly build the 'dynamic table'. I asked for this problem at <a href=\"https://stackoverflow.com/questions/30768565/c-what-can-make-type-infohash-code-differs-for-two-supposedly-same-objects\">C++ what can make type_info::hash_code differs for two (supposedly) same objects</a>\nMay be my bad, but for now I wouldn't recommend using the trick with Clang 3.1 .</p>\n</hr></hr></hr>", "Tags": "<c++><templates><c++11><dynamic-cast><template-aliases>", "OwnerUserId": "3033051", "AnswerCount": "1"}, "30654483": {"ParentId": "30650073", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Clang's behaviour is correct.</p>\n<p><code>A::A_Type</code> is equivalent to <code>int</code> according to [7.1.3p1] in the standard:</p>\n<blockquote>\n<p id=\"so_30650073_30654483_0\">[...] Within the scope of its declaration, a <em>typedef-name</em> is syntactically\n  equivalent to a keyword and names the type associated with the\n  identifier in the way described in Clause 8. A <em>typedef-name</em> is thus a\n  synonym for another type. A <em>typedef-name</em> does not introduce a new type\n  the way a class declaration (9.1) or enum declaration does.</p>\n</blockquote>\n<p><code>A::A_Templated&lt;int&gt;</code> is equivalent to <code>Templated&lt;int&gt;</code> according to [14.5.7p2]:</p>\n<blockquote>\n<p id=\"so_30650073_30654483_1\">When a <em>template-id</em> refers to the specialization of an alias template,\n  it is equivalent to the associated type obtained by substitution of\n  its <em>template-arguments</em> for the <em>template-parameters</em> in the <em>type-id</em> of\n  the alias template.</p>\n</blockquote>\n<p>However, <code>A::A_Templated</code> is <em>not</em> equivalent to <code>Templated</code>, according to [14.5.7p1]:</p>\n<blockquote>\n<p id=\"so_30650073_30654483_2\">[...] The name of the alias template is a <em>template-name</em>.</p>\n</blockquote>\n<p>This means that <code>A::A_Templated</code> and <code>Templated</code> are two different templates, so <code>Test_Templated&lt;A::A_Templated&gt;</code> and <code>Test_Templated&lt;Templated&gt;</code> are different specializations of <code>Test_Templated</code>, thus the casts that return null pointers are correct in doing so.</p>\n<p>GCC 5.1.0 doesn't handle this correctly. Clang 3.6.0 and MSVC 14 RC handle it correctly.</p>\n<hr>\n<p>All references are to working draft N4431.</p>\n<p>Note that there is an active Core Working Group Issue regarding this behaviour - <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1286\" rel=\"nofollow\">Issue 1286</a>. The author says that the intention is to introduce standard wording to make such cases work the way you expected, that is, make the alias template equivalent to the one referenced in the <em>type-id</em>. There's a note from May 2015 in there, indicating that the issue is receiving attention, but it's not there yet.</p>\n<hr>\n<p>In terms of \"making it work\", it's difficult to give solutions without knowing what your practical needs are, but I'd try to make <code>Test_Templated</code> depend on specializations of <code>Templated</code>, rather than the template itself, that is, declare it like</p>\n<pre><code>template&lt;class T&gt;\nclass Test_Templated : public Test_base { /* ... */ };\n</code></pre>\n<p>and use it like </p>\n<pre><code>test = new Test_Templated&lt;Templated&lt;int&gt;&gt;;\nstd::cout &lt;&lt; dynamic_cast&lt; Test_Templated&lt;Templated&lt;int&gt;&gt;* &gt;(test) &lt;&lt; std::endl; //ok\nstd::cout &lt;&lt; dynamic_cast&lt; Test_Templated&lt;A::A_Templated&lt;int&gt;&gt;* &gt;(test) &lt;&lt; std::endl; //also ok\n</code></pre>\n<p>You could wrap this by adding a level of indirection, if that helps in any way:</p>\n<pre><code>template&lt;template&lt;class&gt; class TT, class T&gt; using Make_Test_Templated = Test_Templated&lt;TT&lt;T&gt;&gt;;\n</code></pre>\n<p>and then use it like this:</p>\n<pre><code>test = new Make_Test_Templated&lt;A::A_Templated, long&gt;;\nstd::cout &lt;&lt; dynamic_cast&lt; Make_Test_Templated&lt;A::A_Templated, long&gt;* &gt;(test) &lt;&lt; std::endl; //ok\nstd::cout &lt;&lt; dynamic_cast&lt; Make_Test_Templated&lt;Templated, long&gt;* &gt;(test) &lt;&lt; std::endl; //also ok\n</code></pre>\n<p>Anyway, I think the key is to try to use the fact that the <em>specializations</em> are equivalent.</p>\n<hr>\n<p>Alright, based on your latest update, here's a hack addressing the problem in your second code sample: change the explicit specialization <code>B&lt;Templated&gt;</code> to a partial specialization that only matches if given a template that generates the same specialization as <code>Templated</code> when instantiated with a certain argument (let's say <code>int</code> for this example). </p>\n<p>How's that for a confusing sentence? Sorry. Here's what your code sample becomes with the above changes:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\ntemplate&lt;class&gt; class Templated { };\ntemplate&lt;class T&gt; using Templated_alias = Templated&lt;T&gt;;\ntemplate&lt;class&gt; class Templated2 { };\n\n// Helper trait\ntemplate&lt;template&lt;class&gt; class TT1, template&lt;class&gt; class TT2&gt;\nusing is_same_template_t = typename std::is_same&lt;TT1&lt;int&gt;, TT2&lt;int&gt;&gt;::type;\n\ntemplate&lt;template&lt;class&gt; class, class = std::true_type&gt; class B;\ntemplate&lt;template&lt;class&gt; class TT&gt; class B&lt;TT, is_same_template_t&lt;TT, Templated&gt;&gt;\n{\npublic:\n   void foo(Templated&lt;int&gt;) { std::cout &lt;&lt; \"B&lt;Templated&gt;::foo\\n\"; }\n};\n\nint main() {\n   B&lt;Templated&gt; b1;\n   b1.foo(Templated&lt;int&gt;());\n   b1.foo(Templated_alias&lt;int&gt;());\n   B&lt;Templated_alias&gt; b2; // Works fine now, and so do the next two lines.\n   b2.foo(Templated&lt;int&gt;());\n   b2.foo(Templated_alias&lt;int&gt;());\n   // B&lt;Templated2&gt; b22; // Error trying to instantiate the primary template B.\n}\n</code></pre>\n<p>Note that you have to make sure <code>is_same_template_t</code> is only used to check templates that can be instantiated with an <code>int</code> argument (change <code>int</code> to whatever you need, of course). If you want to make it more generic, you can also include the type on which the templates need to be instantiated in the trait's parameter list, like this:</p>\n<pre><code>template&lt;template&lt;class&gt; class TT1, template&lt;class&gt; class TT2, class T&gt;\nusing is_same_template_t = typename std::is_same&lt;TT1&lt;T&gt;, TT2&lt;T&gt;&gt;::type;\n</code></pre>\n<p>and use it like this:</p>\n<pre><code>is_same_template_t&lt;TT, Templated, int&gt;\n</code></pre>\n</hr></hr></hr>", "OwnerUserId": "4326278", "LastEditorUserId": "4326278", "LastEditDate": "2015-06-22T15:49:03.717", "Id": "30654483", "Score": "3", "CreationDate": "2015-06-04T21:27:09.230", "LastActivityDate": "2015-06-22T15:49:03.717"}, "bq_ids": {"n4140": {"so_30650073_30654483_1": {"section_id": 166, "quality": 1.0, "length": 17}, "so_30650073_30654483_0": {"section_id": 5407, "quality": 1.0, "length": 31}, "so_30650073_30654483_2": {"section_id": 165, "quality": 0.8, "length": 4}}, "n3337": {"so_30650073_30654483_1": {"section_id": 160, "quality": 1.0, "length": 17}, "so_30650073_30654483_0": {"section_id": 5202, "quality": 1.0, "length": 31}, "so_30650073_30654483_2": {"section_id": 159, "quality": 0.8, "length": 4}}, "n4659": {"so_30650073_30654483_1": {"section_id": 170, "quality": 1.0, "length": 17}, "so_30650073_30654483_0": {"section_id": 6829, "quality": 1.0, "length": 31}, "so_30650073_30654483_2": {"section_id": 169, "quality": 0.8, "length": 4}}}});