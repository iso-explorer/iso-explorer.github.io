post_cb({"16322943": {"CommentCount": "3", "ViewCount": "50", "PostTypeId": "1", "LastEditorUserId": "427762", "CreationDate": "2013-05-01T17:12:30.367", "LastActivityDate": "2013-05-22T12:44:04.877", "Title": "template argument deduction for destructor", "LastEditDate": "2013-05-02T17:59:50.333", "Id": "16322943", "Score": "0", "Body": "<p>Should a compiler deduce the template argument when the destructor of a class is called ?\nThe following piece of code : </p>\n<pre><code>#include &lt;iostream&gt; \ntemplate &lt;typename T&gt;\nclass A{\n};\nint main(){\n   A&lt;int&gt; * a = new A&lt;int&gt;();\n   a-&gt;~A();\n}\n</code></pre>\n<p>compiles fine on gcc (g++ 4.3.4) but fails on XLC++ with </p>\n<pre><code>line 30.5: 1540-0210 (S) \"A\" is not a base class of\n\"A&lt;int&gt;\"\n</code></pre>\n<p>Which of the two behavior is expect from a standard compliant compiler ?</p>\n", "Tags": "<c++><compiler-construction><standards><destructor>", "OwnerUserId": "427762", "AnswerCount": "1"}, "16692118": {"ParentId": "16322943", "CommentCount": "0", "Body": "<p>The C++03 standard (I doubt that the C++11 standard will be any different) has the following paragraph (C++03 14.3/5 [temp.arg]):</p>\n<blockquote>\n<p id=\"so_16322943_16692118_0\">An explicit destructor call (12.4) for an object that has a type that is a class template specialization may explicitly specify the <em>template-arguments</em>. [<em>Example:</em></p>\n<pre><code>    template&lt;class T&gt; struct A {\n        ~A();\n    };\n    void f(A&lt;int&gt;* p, A&lt;int&gt;* q) {\n        p-&gt;A&lt;int&gt;::~A();       // OK: destructor call\n        q-&gt;A&lt;int&gt;::~A&lt;int&gt;();  // OK: destructor call\n    };\n</code></pre>\n<p id=\"so_16322943_16692118_1\"><em>--end example</em>]</p>\n</blockquote>\n<p>Clause 12.4/12 [class.dtor] describes the explicit destructor call in terms of a call to a regular member function and has an example showing the explicit destructor call with both qualified and unqualified versions for the destructor's type.</p>\n<p>To me, this clearly indicates that the intent of the standard is that each of</p>\n<pre><code>A&lt;int&gt; * a = new A&lt;int&gt;();\na-&gt;~A();\na-&gt;~A&lt;int&gt;();\na-&gt;A&lt;int&gt;::~A();\na-&gt;A&lt;int&gt;::~A&lt;int&gt;();\n</code></pre>\n<p>should be valid.\nThe fact that the first two are not mentioned in the example in 14.4/12 should not affect this, as examples are not normative.</p>\n", "OwnerUserId": "430719", "PostTypeId": "2", "Id": "16692118", "Score": "0", "CreationDate": "2013-05-22T12:44:04.877", "LastActivityDate": "2013-05-22T12:44:04.877"}, "bq_ids": {"n4140": {"so_16322943_16692118_0": {"section_id": 80, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_16322943_16692118_0": {"section_id": 75, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_16322943_16692118_0": {"section_id": 82, "quality": 0.8571428571428571, "length": 12}}}});