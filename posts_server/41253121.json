post_cb({"41253658": {"ParentId": "41253121", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Quoting the same section as from your <a href=\"https://stackoverflow.com/a/41248530/2069064\">previous question</a>, [dcl.init.list]:</p>\n<blockquote>\n<p id=\"so_41253121_41253658_0\">A narrowing conversion is an implicit conversion [...] \u2014 from an integer type or unscoped enumeration type to an integer type that cannot represent all the values of the original type, <strong>except where the source is a constant expression whose value after integral promotions will fit into the target type</strong>.</p>\n</blockquote>\n<p>What counts as a constant expression? That is defined in [expr.const]:</p>\n<blockquote>\n<p id=\"so_41253121_41253658_1\">A conditional-expression e is a core constant expression unless the evaluation of e, following the rules of the abstract machine (1.9), would evaluate one of the following expressions: [...]<br>\n  \u2014 an invocation of a function other than a <code>constexpr</code> constructor for a literal class, a <code>constexpr</code> function, or an implicit invocation of a trivial destructor<br>\n  \u2014 [...]<br>\n  \u2014 an lvalue-to-rvalue conversion (4.1) unless it is applied to a non-<code>volatile</code> glvalue of integral or enumeration type that refers to a complete non-<code>volatile</code> <code>const</code> object with a preceding initialization, initialized with a constant expression<br>\n  \u2014 [...]</br></br></br></br></p>\n</blockquote>\n<p>So, <code>i</code> is a constant expression in <code>const int i = 1024;</code> because <code>i</code> is a non-<code>volatile</code> <code>const</code> object of integral type initialized with a constant expression (<code>1024</code>). But in the second example, <code>pow()</code> isn't a constant expression because it's an invocation of a non-<code>constexpr</code> function. </p>\n<p>Hence, the first example doesn't count as narrowing but the second does. You can think of it as the compiler <strong>knows</strong> that 1024 is fine, but doesn't know that pow(2, 10) is. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:46:01.853", "Id": "41253658", "Score": "3", "CreationDate": "2016-12-21T01:07:50.210", "LastActivityDate": "2016-12-21T01:07:50.210"}, "bq_ids": {"n4140": {"so_41253121_41253658_1": {"section_id": 6185, "quality": 0.9565217391304348, "length": 44}, "so_41253121_41253658_0": {"section_id": 3329, "quality": 0.96875, "length": 31}}, "n3337": {"so_41253121_41253658_1": {"section_id": 5946, "quality": 0.6521739130434783, "length": 30}, "so_41253121_41253658_0": {"section_id": 3199, "quality": 0.875, "length": 28}}, "n4659": {"so_41253121_41253658_1": {"section_id": 7687, "quality": 0.9347826086956522, "length": 43}, "so_41253121_41253658_0": {"section_id": 4095, "quality": 0.96875, "length": 31}}}, "41253121": {"CommentCount": "2", "ViewCount": "80", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2016-12-20T23:57:24.920", "LastActivityDate": "2016-12-21T01:08:27.707", "Title": "Strange behavior of narrowing in context of initializer lists", "AcceptedAnswerId": "41253658", "LastEditDate": "2016-12-21T01:08:27.707", "Id": "41253121", "Score": "1", "Body": "<p>Does someone knows why this compiles without warnings</p>\n<pre><code>int main()\n{\n  const int i = 1024;\n  std::initializer_list&lt;size_t&gt; i_l = { i }; // no warning\n\n  return 0;\n}\n</code></pre>\n<p>but does not</p>\n<pre><code>int main()\n{\n  const int i = pow(2,10);\n  std::initializer_list&lt;size_t&gt; i_l = { i }; // warning\n\n  return 0;\n}\n</code></pre>\n<p>Warning:</p>\n<pre><code>non-constant-expression cannot be narrowed from type 'int' to 'unsigned long' in initializer list [-Wc++11-narrowing]\n      std::initializer_list&lt;size_t&gt; i_l = { i }; i_l = i_l; // warning\n</code></pre>\n", "Tags": "<c++><initializer-list><narrowing>", "OwnerUserId": "7006673", "AnswerCount": "1"}});