post_cb({"28904737": {"ParentId": "28904035", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is definitely a bug in gcc. The code below rightly prints <code>right</code> with clang but <code>wrong</code> with GCC.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt; struct A{ T t; };\nstruct B{};\nstruct C : public B{};\n\nstd::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const B&amp;) \n  { return out &lt;&lt; \"right\"; }\n\nnamespace {\ntemplate&lt;typename T&gt;\nstd::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const A&lt;T&gt;&amp;v) \n  { return out &lt;&lt; v.t; }\n\nstd::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const C&amp;) \n  { return out &lt;&lt; \"wrong\"; }\n}\n\nint main(){\n  A&lt;C&gt; a;\n  std::cout &lt;&lt; a;\n}\n</code></pre>\n<p>Reported <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65336\" rel=\"nofollow\">here</a>.</p>\n", "OwnerUserId": "401200", "LastEditorUserId": "401200", "LastEditDate": "2015-03-06T18:38:20.647", "Id": "28904737", "Score": "2", "CreationDate": "2015-03-06T17:55:02.853", "LastActivityDate": "2015-03-06T18:38:20.647"}, "bq_ids": {"n4140": {"so_28904035_28904035_0": {"section_id": 7137, "quality": 0.9444444444444444, "length": 17}, "so_28904035_28904035_1": {"section_id": 222, "quality": 0.9047619047619048, "length": 19}, "so_28904035_28904035_2": {"section_id": 224, "quality": 0.7777777777777778, "length": 14}, "so_28904035_28904035_4": {"section_id": 224, "quality": 0.8888888888888888, "length": 16}, "so_28904035_28904035_3": {"section_id": 224, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_28904035_28904035_0": {"section_id": 6881, "quality": 0.9444444444444444, "length": 17}, "so_28904035_28904035_1": {"section_id": 215, "quality": 0.9047619047619048, "length": 19}, "so_28904035_28904035_2": {"section_id": 217, "quality": 0.5555555555555556, "length": 10}, "so_28904035_28904035_4": {"section_id": 217, "quality": 0.8888888888888888, "length": 16}, "so_28904035_28904035_3": {"section_id": 217, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_28904035_28904035_4": {"section_id": 232, "quality": 0.8888888888888888, "length": 16}, "so_28904035_28904035_0": {"section_id": 8638, "quality": 0.9444444444444444, "length": 17}, "so_28904035_28904035_2": {"section_id": 232, "quality": 0.7777777777777778, "length": 14}, "so_28904035_28904035_1": {"section_id": 230, "quality": 0.9047619047619048, "length": 19}, "so_28904035_28904035_3": {"section_id": 232, "quality": 0.8571428571428571, "length": 12}}}, "28904035": {"CommentCount": "4", "ViewCount": "437", "PostTypeId": "1", "LastEditorUserId": "1782465", "CreationDate": "2015-03-06T17:14:32.243", "LastActivityDate": "2015-03-06T18:38:20.647", "Title": "Template overload resolution for operators inside an anonymous namespace", "AcceptedAnswerId": "28904737", "LastEditDate": "2015-03-06T17:18:35.677", "Id": "28904035", "Score": "12", "Body": "<p><strong>Short question:</strong> do operators have special template lookup rules for overload resolution with internal linkage or is the code at the bottom a template overload resolution bug for operators in GCC?</p>\n<p><strong>The detail:</strong> instead of pasting a chunk of code I'll take you through my reasoning. Let's start with some simple code:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt; struct A{ T b; };\nstruct B{};\n\ntemplate&lt;typename T&gt; \nvoid foo (const A&lt;T&gt;&amp;a) { foo(a.b); } \nvoid foo (const B&amp;) { std::cout &lt;&lt; \"hello\"; }\n\nint main(){\n  A&lt;B&gt; b;\n  foo(b);\n}\n</code></pre>\n<p>The above prints <code>\"hello\"</code>, everything is fine. </p>\n<p>Now let's put both <code>foo</code> in an anonymous namespace:</p>\n<pre><code>namespace {\ntemplate&lt;typename T&gt; \nvoid foo (const A&lt;T&gt;&amp;a) { foo(a.b); } \nvoid foo (const B&amp;) { std::cout &lt;&lt; \"hello\"; }\n}\n</code></pre>\n<p>The code now fails to compile. Clang says <code>error: call to function 'foo' that is neither visible in the template definition nor found by argument-dependent lookup</code> and GCC <code>template argument deduction/substitution failed</code>. </p>\n<p>This is broken because <code>foo(const B&amp;)</code> is defined after <code>foo&lt;T&gt;</code> and doesn't have an external linkage, as explained in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\">n4296</a>:</p>\n<blockquote>\n<p id=\"so_28904035_28904035_0\"><em>[basic.link]</em>\n  An unnamed namespace or a namespace declared directly or indirectly within an unnamed namespace has\n  internal linkage. All other namespaces have external linkage.</p>\n<p id=\"so_28904035_28904035_1\"><em>[temp.point]</em>\n  The instantiation context of an expression that depends on the template arguments is the set of declarations\n  <em>with external linkage declared prior to the point of instantiation</em> of the template specialization in the same translation unit.</p>\n<p id=\"so_28904035_28904035_2\"><em>[temp.dep.candidate]</em>\n  For a function call where the postfix-expression is a dependent name,\n  the candidate functions are found using the usual lookup rules (3.4.1,\n  3.4.2) except that: </p>\n<ul>\n<li><p id=\"so_28904035_28904035_3\">For the part of the lookup using unqualified name lookup (3.4.1), only function declarations from the template\n  definition context are found.</p></li>\n<li><p id=\"so_28904035_28904035_4\">For the part of the lookup using\n  associated namespaces (3.4.2), only function declarations found in\n  either the template definition context or the template instantiation\n  context are found.</p></li>\n</ul>\n</blockquote>\n<p>Now the same thing using operators:</p>\n<pre><code>struct ostream {} cout; \ntemplate&lt;typename T&gt; struct A{ T t; };\nstruct B{};\n\nnamespace {\ntemplate&lt;typename T&gt;\nostream&amp; operator&lt;&lt; (ostream&amp; out, const A&lt;T&gt;&amp;v) \n  { return out &lt;&lt; v.t; }\nostream&amp; operator&lt;&lt; (ostream&amp; out, const B&amp;) \n  { return out; }\n}\n\nint main(){\n  A&lt;B&gt; a;\n  cout &lt;&lt; a; \n}\n</code></pre>\n<p>GCC (4.7/4.8/4.9) is now perfectly happy with the code and gives zero warning with <code>-Wall -Wextra -pedantic -ansi</code> while clang complains about <code>'operator&lt;&lt;'</code> the same way it did for <code>foo</code>.</p>\n<p>I didn't find any exception for operator overload lookup in the standard so I believe this is a bug (feature?) in GCC but template resolution rules are not easy so I thought I might check here before filing a bug.</p>\n<p>You can see this code live <a href=\"http://ideone.com/AQkRdN\">here</a>.</p>\n", "Tags": "<c++><templates><gcc><language-lawyer><argument-dependent-lookup>", "OwnerUserId": "401200", "AnswerCount": "1"}});