post_cb({"48904015": {"ViewCount": "2740", "Body": "<p>According to the draft of the standard N4713 (7.11/1):</p>\n<blockquote>\n<p id=\"so_48904015_48904015_0\">A null pointer constant is an integer literal (5.13.2) with value zero or a prvalue of type <code>std::nullptr_t</code>.</p>\n</blockquote>\n<p>and 21.2.3/2:</p>\n<blockquote>\n<p id=\"so_48904015_48904015_1\">The macro <code>NULL</code> is an implementation-defined null pointer constant.</p>\n</blockquote>\n<p>follow that <code>NULL</code> can be defined as <code>nullptr</code>. Same is mentioned on <a href=\"http://en.cppreference.com/w/cpp/types/NULL\" rel=\"noreferrer\">cppreference</a>:</p>\n<pre><code>#define NULL 0\n//since C++11\n#define NULL nullptr\n</code></pre>\n<p>At the same time \"Additive operators\" clause says (8.5.6/7):</p>\n<blockquote>\n<p id=\"so_48904015_48904015_2\">If the value <code>0</code> is added to or subtracted from a null pointer value, the result is a null pointer value. If two null\n  pointer values are subtracted, the result compares equal to the value <code>0</code> converted to the type <code>std::ptrdiff_t</code>.</p>\n</blockquote>\n<p>Hence the following code should be valid:</p>\n<pre><code>0 + nullptr; \nnullptr - nullptr; \n</code></pre>\n<p>but because of the lack of +/- operators for <code>std::nullptr_t</code> the <a href=\"https://wandbox.org/permlink/L73ROVmycwIWMJYw\" rel=\"noreferrer\">code is invalid</a>.</p>\n<p>Is there something that I didn't take into account or <code>NULL</code> macro can't be actually defined as <code>nullptr</code>?</p>\n", "AcceptedAnswerId": "48904141", "Title": "Can the NULL macro actually be a nullptr?", "CreationDate": "2018-02-21T10:50:09.007", "LastActivityDate": "2018-02-21T14:53:40.770", "CommentCount": "9", "LastEditDate": "2018-02-21T11:40:11.123", "PostTypeId": "1", "LastEditorUserId": "3002139", "Id": "48904015", "Score": "40", "OwnerUserId": "3240681", "Tags": "<c++><null><language-lawyer><nullptr>", "AnswerCount": "4"}, "48904141": {"Id": "48904141", "PostTypeId": "2", "Body": "<p>While <code>nullptr</code> is a null pointer <em>constant</em>, it is not a null pointer <em>value</em>. The latter is a value of some pointer type, which <code>std::nullptr_t</code> is not.</p>\n<p>Reference:</p>\n<blockquote>\n<p id=\"so_48904015_48904141_0\">A null pointer constant is an integer literal (5.13.2) with value zero or a prvalue of type <code>std::nullptr_t</code>. <strong>A null pointer constant can be converted to a pointer type; the result is the null pointer value of that type</strong> and is\n  distinguishable from every other value of object pointer or function pointer type. Such a conversion is called\n  a null pointer conversion. [...]</p>\n</blockquote>\n<p>7.11/1 in N4659, emphasize mine</p>\n<p>So <code>NULL</code> can indeed be <code>nullptr</code> without providing the arithmetic operators.</p>\n", "LastEditorUserId": "3002139", "LastActivityDate": "2018-02-21T14:09:22.643", "Score": "44", "CreationDate": "2018-02-21T10:57:10.680", "ParentId": "48904015", "CommentCount": "14", "OwnerUserId": "3002139", "LastEditDate": "2018-02-21T14:09:22.643"}, "48904174": {"Id": "48904174", "PostTypeId": "2", "Body": "<p>The keyword <code>nullptr</code> denotes the pointer literal. It is a <code>prvalue</code> of type <code>std::nullptr_t</code>. There exist implicit conversions from <code>nullptr</code> to null pointer value of any pointer type and any pointer to member type.\n<code>nullptr</code> itself is not a pointer value nor pointer. Thus arithmetic operations are not applicable to <code>nullptr</code>.</p>\n", "LastActivityDate": "2018-02-21T10:59:00.897", "Score": "5", "CreationDate": "2018-02-21T10:59:00.897", "ParentId": "48904015", "CommentCount": "7", "OwnerUserId": "6752050"}, "bq_ids": {"n4140": {"so_48904015_48905122_1": {"length": 33, "quality": 0.9705882352941176, "section_id": 6139}, "so_48904015_48904015_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 2515}, "so_48904015_48904015_2": {"length": 18, "quality": 0.8181818181818182, "section_id": 6145}, "so_48904015_48905122_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 6138}, "so_48904015_48904015_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 39}, "so_48904015_48904141_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 39}}, "n3337": {"so_48904015_48905122_1": {"length": 33, "quality": 0.9705882352941176, "section_id": 5903}, "so_48904015_48904015_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6460}, "so_48904015_48904015_2": {"length": 18, "quality": 0.8181818181818182, "section_id": 5908}, "so_48904015_48905122_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 5902}, "so_48904015_48904141_0": {"length": 35, "quality": 0.9210526315789473, "section_id": 36}, "so_48904015_48904015_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 36}}, "n4659": {"so_48904015_48905122_1": {"length": 33, "quality": 0.9705882352941176, "section_id": 7636}, "so_48904015_48904015_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 3249}, "so_48904015_48904015_2": {"length": 22, "quality": 1.0, "section_id": 7641}, "so_48904015_48905122_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 7635}, "so_48904015_48904141_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 39}, "so_48904015_48904015_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 39}}}, "48905122": {"Id": "48905122", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48904015_48905122_0\">For addition, either both operands shall have arithmetic or unscoped enumeration type, or one operand shall be a pointer to a completely-defined object type and the other shall have integral or unscoped enumeration type.</p>\n<p id=\"so_48904015_48905122_1\">For subtraction, one of the following shall hold:<br>\n  (2.1) both operands have arithmetic or unscoped enumeration type; or<br>\n  (2.2) both operands are pointers to cv-qualified or cv-unqualified versions of the same completely-defined object type; or<br>\n  (2.3) the left operand is a pointer to a completely-defined object type and the right operand has integral or unscoped enumeration type.</br></br></br></p>\n</blockquote>\n<p><code>std::nullptr_t</code> is none of those, hence <code>std::nullptr</code> cannot participate in additive operations.</p>\n<p>Note that not even all pointer values can participate. For example, function pointer values and void pointer values cannot, even though either can be a null pointer value.</p>\n", "LastEditorUserId": "3002139", "LastActivityDate": "2018-02-21T12:13:28.267", "Score": "6", "CreationDate": "2018-02-21T11:47:11.987", "ParentId": "48904015", "CommentCount": "0", "OwnerUserId": "775806", "LastEditDate": "2018-02-21T12:13:28.267"}, "48904233": {"Id": "48904233", "PostTypeId": "2", "Body": "<p><code>nullptr</code> is a null pointer literal, and although the result of converting <code>nullptr</code> to a pointer type is the null pointer value, <code>nullptr</code> itself isn't of a pointer type, but of type <code>std::nullptr_t</code>. The arithmetic works if you do convert the <code>nullptr</code> to a pointer type:</p>\n<pre><code>0 + (int*)nullptr; \n(int*)nullptr - (int*)nullptr;\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_48904015_48904233_0\">Can the NULL macro actually be a nullptr?</p>\n</blockquote>\n<p>Yes, because <code>nullptr</code> is a null pointer literal.</p>\n<p>Note that prior to C++11, the all of the null pointer literals in C++ happened to also be integer literals, so this bad code: <code>char c = NULL;</code> used to work in practice. If <code>NULL</code> is defined as <code>nullptr</code>, that code no longer works.</p>\n</hr>", "LastEditorUserId": "2079303", "LastActivityDate": "2018-02-21T14:53:40.770", "Score": "7", "CreationDate": "2018-02-21T11:02:03.257", "ParentId": "48904015", "CommentCount": "0", "OwnerUserId": "2079303", "LastEditDate": "2018-02-21T14:53:40.770"}});