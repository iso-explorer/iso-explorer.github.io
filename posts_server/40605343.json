post_cb({"40605343": {"CommentCount": "0", "AcceptedAnswerId": "40606884", "PostTypeId": "1", "LastEditorUserId": "3540970", "CreationDate": "2016-11-15T08:41:01.847", "LastActivityDate": "2017-03-16T14:28:59.203", "LastEditDate": "2016-11-15T09:04:09.457", "ViewCount": "192", "FavoriteCount": "0", "Title": "Why does std::tuple decompose into rvalue references", "Id": "40605343", "Score": "6", "Body": "<p>Why does std::tuple decompose into rvalue references?</p>\n<pre><code>#include &lt;tuple&gt;\n\ntemplate &lt;typename, typename&gt; struct same_type;\ntemplate &lt;typename T&gt; struct same_type&lt;T, T&gt; {};\n\nvoid foo() {\n  std::tuple tuple(1, 'a', 2.3, true);\n  auto[i, c, d, b] = tuple;\n  same_type&lt;decltype(i), int &amp;&amp;&gt;{};\n  same_type&lt;decltype(c), char &amp;&amp;&gt;{};\n  same_type&lt;decltype(d), double &amp;&amp;&gt;{};\n  same_type&lt;decltype(b), bool &amp;&amp;&gt;{};\n}\n</code></pre>\n<p>This compiles without error using gcc trunk.\nI would have expected the plain types instead, e.g.</p>\n<pre><code>same_type&lt;decltype(i), int&gt;{};\n</code></pre>\n<p><a href=\"http://melpon.org/wandbox/permlink/9F22pVrxxrFpftgh\" rel=\"nofollow noreferrer\">Live example</a></p>\n", "Tags": "<c++><c++1z>", "OwnerUserId": "3540970", "AnswerCount": "1"}, "40606884": {"ParentId": "40605343", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>GCC bug. <code>decltype</code> applied to a structured binding returns the <em>referenced type</em>, which for the tuple-like case is the exact type returned by <code>std::tuple_element</code>. In other words, the language tries pretty hard here to hide the fact that those are actually references.</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/dcl.type.simple#4\" rel=\"nofollow noreferrer\">[dcl.type.simple]/4</a>:</p>\n<blockquote>\n<p id=\"so_40605343_40606884_0\">For an expression <code>e</code>, the type denoted by <code>decltype(e)</code> is defined as\n  follows:</p>\n<ul>\n<li>if <code>e</code> is an unparenthesized <em>id-expression</em> naming a structured binding  ([dcl.struct.bind]), <code>decltype(e)</code> is the referenced type as given in the\n  specification of the structured binding declaration;</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/dcl.struct.bind#3\" rel=\"nofollow noreferrer\">[dcl.struct.bind]/3</a>:</p>\n<blockquote>\n<p id=\"so_40605343_40606884_1\">Otherwise, if the expression <code>std::tuple_size&lt;E&gt;::value</code> is a\n  well-formed integral constant expression [...] Given the type <code>Ti</code>\n  designated by <code>std::tuple_element&lt;i, E&gt;::type</code>, each <code>vi</code> is a\n  variable of type \u201creference to <code>Ti</code>\u201d initialized with the initializer,\n  where the reference is an lvalue reference if the initializer is an\n  lvalue and an rvalue reference otherwise; the referenced type is <code>Ti</code>.</p>\n</blockquote>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2017-03-16T14:28:59.203", "Id": "40606884", "Score": "9", "CreationDate": "2016-11-15T09:59:16.940", "LastActivityDate": "2017-03-16T14:28:59.203"}, "bq_ids": {"n4140": {"so_40605343_40606884_0": {"section_id": 5440, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_40605343_40606884_0": {"section_id": 5235, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_40605343_40606884_1": {"section_id": 4040, "quality": 1.0, "length": 29}, "so_40605343_40606884_0": {"section_id": 6867, "quality": 0.8571428571428571, "length": 6}}}});