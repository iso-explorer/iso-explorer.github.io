post_cb({"485349": {"CommentCount": "0", "CreationDate": "2009-01-27T21:29:47.957", "LastEditorUserId": "10559", "LastActivityDate": "2009-01-28T01:42:34.407", "ParentId": "483337", "PostTypeId": "2", "LastEditorDisplayName": "jwfearn", "LastEditDate": "2009-01-28T01:42:34.407", "Id": "485349", "Score": "3", "Body": "<p>Yes <code>(str.empty() == (str == \"\"))</code> is always* true for <code>std::string</code>.  But remember that a <code>string</code> can contain <code>'\\0'</code> characters.  So even though the expression <code>s == \"\"</code> may be false, <code>s.c_str()</code> may still return an empty C-string.  For example:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid test( const string &amp; s ) {\n    bool bempty = s.empty();\n    bool beq = std::operator==(s, \"\"); // avoid global namespace operator==\n    const char * res = (bempty == beq ) ? \"PASS\" : \"FAIL\";\n    const char * isempty = bempty ? \"    empty \" : \"NOT empty \";\n    const char * iseq = beq ? \"    == \\\"\\\"\" : \"NOT == \\\"\\\"\";\n    cout &lt;&lt; res &lt;&lt; \" size=\" &lt;&lt; s.size();\n    cout &lt;&lt; \" c_str=\\\"\" &lt;&lt; s.c_str() &lt;&lt; \"\\\" \";\n    cout &lt;&lt; isempty &lt;&lt; iseq &lt;&lt; endl;\n}\n\nint main() {\n    string s;          test(s); // PASS size=0 c_str=\"\"     empty     == \"\"\n    s.push_back('\\0'); test(s); // PASS size=1 c_str=\"\" NOT empty NOT == \"\"\n    s.push_back('x');  test(s); // PASS size=2 c_str=\"\" NOT empty NOT == \"\"\n    s.push_back('\\0'); test(s); // PASS size=3 c_str=\"\" NOT empty NOT == \"\"\n    s.push_back('y');  test(s); // PASS size=4 c_str=\"\" NOT empty NOT == \"\"\n    return 0;\n}\n</code></pre>\n<p>**barring an overload of <code>operator==</code> in the global namespace, as others have mentioned*</p>\n", "OwnerUserId": "10559", "OwnerDisplayName": "jwfearn"}, "483471": {"ParentId": "483337", "CommentCount": "0", "Body": "<p>str.empty() is never slower, but might be faster than str == \"\".  This depends on implementation.  So you should use str.empty() just in case.</p>\n<p>This is a bit like using ++i instead of i++ to increase a counter (assuming you do not need the result of the increment operator itself).  Your compiler might optimise, but you lose nothing using ++i, and might win something, so you are better off using ++i.</p>\n<p>Apart from performance issues, the answer to your question is yes; both expressions are logically equivalent.</p>\n", "OwnerUserId": "25824", "Id": "483471", "PostTypeId": "2", "OwnerDisplayName": "Gorpik", "Score": "7", "CreationDate": "2009-01-27T13:54:55.130", "LastActivityDate": "2009-01-27T13:54:55.130"}, "483337": {"CommentCount": "1", "ViewCount": "59341", "PostTypeId": "1", "LastEditorUserId": "3508", "FavoriteCount": "8", "CreationDate": "2009-01-27T13:10:26.187", "LastActivityDate": "2009-06-03T20:09:04.817", "AnswerCount": "7", "LastEditDate": "2009-01-27T13:18:35.797", "LastEditorDisplayName": "A. Rex", "Title": "C++: is string.empty() always equivalent to string == \"\"?", "Id": "483337", "Score": "42", "Body": "<p>Can I make an assumption that given</p>\n<pre><code>std::string str;\n... // do something to str\n</code></pre>\n<p>Is the following statement is always true?</p>\n<pre><code>(str.empty() == (str == \"\"))\n</code></pre>\n", "Tags": "<c++><string>", "OwnerUserId": "59320", "OwnerDisplayName": "Michael"}, "483361": {"CommentCount": "7", "CreationDate": "2009-01-27T13:17:27.267", "LastEditorUserId": "-1", "LastActivityDate": "2009-01-27T15:36:59.480", "ParentId": "483337", "PostTypeId": "2", "LastEditorDisplayName": "A. Rex", "LastEditDate": "2017-05-23T11:53:10.763", "Id": "483361", "Score": "48", "Body": "<h3>Answer</h3>\n<p>Yes.  Here is the relevant implementation from <code>bits/basic_string.h</code>, the code for <code>basic_string&lt;_CharT, _Traits, _Alloc&gt;</code>:</p>\n<pre><code>  /**\n   *  Returns true if the %string is empty.  Equivalent to *this == \"\".\n   */\n  bool\n  empty() const\n  { return this-&gt;size() == 0; }\n</code></pre>\n<h3>Discussion</h3>\n<p>Even though the two forms are equivalent for <code>std::string</code>, you <em>may</em> wish to use <code>.empty()</code> because it is more general.</p>\n<p>Indeed, <a href=\"https://stackoverflow.com/users/4279/j-f-sebastian\">J.F. Sebastian</a> comments that if you switch to using <code>std::wstring</code> instead of <code>std::string</code>, then <code>==\"\"</code> won't even compile, because you can't compare a string of <code>wchar_t</code> with one of <code>char</code>.  This, however, is not directly relevant to your original question, and I am 99% sure you will not switch to <code>std::wstring</code>.</p>\n", "OwnerUserId": "3508", "OwnerDisplayName": "A. Rex"}, "483384": {"ParentId": "483337", "CommentCount": "4", "Body": "<p>Some implementations might test for the null character as the first character in the string resulting in a slight speed increase over calculating the size of the string.</p>\n<p>I believe that this is not common however.</p>\n", "OwnerUserId": "1804", "Id": "483384", "PostTypeId": "2", "OwnerDisplayName": "Jesse Dearing", "Score": "1", "CreationDate": "2009-01-27T13:25:19.403", "LastActivityDate": "2009-01-27T13:25:19.403"}, "483368": {"ParentId": "483337", "CommentCount": "0", "Body": "<p>Yes it is equivalent but allows the core code to change the implementation of what empty() actually means depending on OS/Hardware/anything and not affect your code at all.  There is similiar practice in Java and .NET</p>\n", "OwnerUserId": "42124", "Id": "483368", "PostTypeId": "2", "OwnerDisplayName": "Ray Booysen", "Score": "0", "CreationDate": "2009-01-27T13:20:57.680", "LastActivityDate": "2009-01-27T13:20:57.680"}, "483517": {"ParentId": "483337", "CommentCount": "0", "Body": "<p>It should be. The ANSI/ISO standard states in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/wp/html/oct97/lib-strings.html#lib.string.capacity\" rel=\"noreferrer\">21.3.3 <code>basic_string</code> capacity</a>:</p>\n<blockquote>\n<p id=\"so_483337_483517_0\"><code>size_type size() const;</code></p>\n<p id=\"so_483337_483517_1\"><strong>Returns:</strong> a count of char-like objects currently in the string.</p>\n<p id=\"so_483337_483517_2\"><code>bool empty() const;</code></p>\n<p id=\"so_483337_483517_3\"><strong>Returns:</strong> <code>size() == 0</code></p>\n</blockquote>\n<p>However, in clause 18 of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/wp/html/oct97/lib-strings.html#lib.string.cons\" rel=\"noreferrer\">21.3.1 <code>basic_string</code> constructors</a> it states that the character-type assignment operator uses <code>traits::length()</code> to establish the length of the controlled sequence so you could end up with something strange if you are using a different specialization of <code>std::basic_string&lt;&gt;</code>.</p>\n<p>I think that the 100% correct statement is that</p>\n<pre><code>(str.empty() == (str == std::string()))\n</code></pre>\n<p>or something like that. If you haven't done anything strange, then <code>std::string(\"\")</code> and <code>std::string()</code> should be equivalent</p>\n<p>They are logically similar but they are testing for different things. <code>str.empty()</code> is checking if the string is empty where the other is checking for equality against a C-style empty string. I would use whichever is more appropriate for what you are trying to do. If you want to know if a string is empty, then use <code>str.empty()</code>.</p>\n", "OwnerUserId": "41747", "Id": "483517", "PostTypeId": "2", "OwnerDisplayName": "D.Shawley", "Score": "11", "CreationDate": "2009-01-27T14:10:02.930", "LastActivityDate": "2009-01-27T14:10:02.930"}, "483397": {"CommentCount": "4", "CreationDate": "2009-01-27T13:32:46.143", "LastEditorUserId": "8331", "LastActivityDate": "2009-01-27T13:38:32.247", "ParentId": "483337", "PostTypeId": "2", "LastEditorDisplayName": "therefromhere", "LastEditDate": "2009-01-27T13:38:32.247", "Id": "483397", "Score": "1", "Body": "<p>Normally, yes.</p>\n<p>But if someone decides to redefine an operator then all bets are off:</p>\n<pre><code>bool operator == (const std::string&amp; a, const char b[])\n{\n    return a != b; // paging www.thedailywtf.com\n}\n</code></pre>\n", "OwnerUserId": "8331", "OwnerDisplayName": "therefromhere"}, "bq_ids": {"n4140": {"so_483337_483517_1": {"section_id": 1600, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_483337_483517_1": {"section_id": 1596, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_483337_483517_1": {"section_id": 1752, "quality": 0.8333333333333334, "length": 5}}}});