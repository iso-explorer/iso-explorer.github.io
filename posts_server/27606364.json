post_cb({"27606511": {"Id": "27606511", "PostTypeId": "2", "Body": "<p>According to the C++ Standard (9.3.2 The this pointer)</p>\n<blockquote>\n<p id=\"so_27606364_27606511_0\">1 In the body of a non-static (9.3) member function, the keyword this\n  is a prvalue expression whose value is the address of the object for\n  which the function is called. The type of this in a member function of\n  a class X is X*. If the member function is declared const, the type of\n  this is const X*, if the member function is declared volatile, the\n  type of this is volatile X*, and if the member function is declared\n  const volatile, the type of this is const volatile X*.</p>\n</blockquote>\n<p>As you see there is nothing said that <code>this</code> has type <code>ClassTYpe * const</code> of <code>ClassType const * const</code>. It is a prvalue that may not be modified as any prvalue except that for a prvalue of a class type you may call non-const member functions..</p>\n<p>As for you then you mix two types a constant pointer and a pointer that points to a constant data.\nFor example this declaration</p>\n<pre><code>const ClassType *p;\n</code></pre>\n<p>does not declare a constant pointer. So the pointer itself may be not initialized. On the other hand thsi declaration</p>\n<pre><code>ClassTYpe * const p = new ClassTYpe;\n</code></pre>\n<p>declares a constant pointer and the pointer itself shall be initialized as any other constant.</p>\n<p>As for this quote from your book</p>\n<blockquote>\n<p id=\"so_27606364_27606511_1\">after all,the body of isbn doesn't change the object to which this\n  points, so our function would be more flexible if this were a pointer\n  to const</p>\n</blockquote>\n<p>Then it means that it would be better to define the function with qualifier const. In this case it could be called for constant and non-constant objects. Otherwise it may be called only for-non constant objects because within the function the pointer type of <code>this</code> is not <code>const ClassTYpe *</code>.</p>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2014-12-22T18:08:49.453", "Score": "7", "CreationDate": "2014-12-22T16:25:11.593", "ParentId": "27606364", "CommentCount": "5", "OwnerUserId": "2877241", "LastEditDate": "2014-12-22T18:08:49.453"}, "27606364": {"ViewCount": "1214", "Body": "<p>it might sound stupid.in C++prime 5th edition P258,it says:</p>\n<blockquote>\n<p id=\"so_27606364_27606364_0\">by default, the type of this is a const pointer to the nonconst version of the class type.for example,by default, the type of this in a Sales_data member function is Sales_data *const.</p>\n</blockquote>\n<p>i can understand that for this* is a const pointer which means the object it points once initialized cannot change.but then it says:</p>\n<blockquote>\n<p id=\"so_27606364_27606364_1\">although this is implicit, it follows the normal initialization rules,which means that(by default)we cannot bind this to a const object.</p>\n</blockquote>\n<p>but i wrote the following codes,it was still compiled fine:</p>\n<pre><code>class Test{\npublic:\n    Test() = default;\n    Test(const string &amp;s): teststr(\" \") {};\n    Test(int a) : testint(a) {};\n    Test(const string &amp;s, int a): teststr(s), testint(a) {};\n    string getstr() const { return teststr; };\n    int getint() { return testint; };   //there is no const here\nprivate:\n    string teststr;\n    int testint = 0;\n};\n\nint main(){\n    Test a(\"abc\",2);\n\n    cout &lt;&lt; a.getint() &lt;&lt; \" \";\n    cout &lt;&lt; a.getstr() &lt;&lt; endl;\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>so my question is :\nif the compiler can compile it fine whether there is a 'const' or not,why does it matter?\nand then the book says:</p>\n<blockquote>\n<p id=\"so_27606364_27606364_2\">after all,the body of isbn doesn't change the object to which this points, so our function would be more flexible if this were a pointer to const.</p>\n</blockquote>\n<p>and i'm wondering what is the flexiblity is?would you show me some examples?</p>\n", "AcceptedAnswerId": "27606476", "Title": "the type of this* in C++", "CreationDate": "2014-12-22T16:15:50.653", "Id": "27606364", "CommentCount": "6", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-12-22T16:17:18.993", "LastEditorUserId": "3323096", "LastActivityDate": "2015-11-30T11:15:35.700", "Score": "10", "OwnerUserId": "4385659", "Tags": "<c++><pointers><const-pointer>", "AnswerCount": "5"}, "27606475": {"Id": "27606475", "PostTypeId": "2", "Body": "<p>The \"flexibility\" is that you can call a <code>const</code> function on any object, constant or not. You can't call a non-<code>const</code> function on a <code>const</code> object (or reference/pointer to <code>const</code>).</p>\n<p>So the following would fail:</p>\n<pre><code>const Test c;\ncout &lt;&lt; a.getint() &lt;&lt; \" \";   // ERROR: non-const function\ncout &lt;&lt; a.getstr() &lt;&lt; endl;  // OK: const function\n</code></pre>\n<p>As well as this flexibility, declaring a member function <code>const</code> is a good idea since that will prevent you from accidentally modifying the object in a function that's not supposed to.</p>\n", "LastActivityDate": "2014-12-22T16:23:06.800", "CommentCount": "0", "CreationDate": "2014-12-22T16:23:06.800", "ParentId": "27606364", "Score": "5", "OwnerUserId": "204847"}, "27606470": {"Id": "27606470", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_27606364_27606470_0\"><em>\"i can understand that for this* is a const pointer which means the object it points once initialized cannot change.but then it says:\"</em></p>\n</blockquote>\n<p>No, you got this wrong. Being <code>this</code> a <em>const pointer</em> means, you cannot change the pointer value itself like</p>\n<pre><code> class MyClass {\n      void foo() {\n          MyClass a;\n          this = &amp;a; // &lt;&lt;&lt; Compiler error\n      }\n }\n</code></pre>\n<p>The type of <code>this</code> actually appears as</p>\n<pre><code> MyClass * const this;\n</code></pre>\n<p>and for <code>const</code> instances or references</p>\n<pre><code> MyClass const * const this;\n</code></pre>\n<p><a href=\"https://stackoverflow.com/questions/1143262/what-is-the-difference-between-const-int-const-int-const-int-const\">Note this is different from</a> </p>\n<pre><code> const MyClass* some_const_instance_pointer;\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-12-22T16:45:36.590", "Score": "5", "CreationDate": "2014-12-22T16:22:59.703", "ParentId": "27606364", "CommentCount": "3", "OwnerUserId": "1413395", "LastEditDate": "2017-05-23T11:59:23.117"}, "bq_ids": {"n4140": {"so_27606364_27606511_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 5895}}, "n3337": {"so_27606364_27606511_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 5666}}, "n4659": {"so_27606364_27606511_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 7378}}}, "27606484": {"Id": "27606484", "PostTypeId": "2", "Body": "<p>Two questions two answers.</p>\n<p>The <code>this</code> pointer cannot be reassigned. That's what is meant by <code>const</code> in this case. You can change the contents of the object that <code>this</code> points to but you cannot change which object it points to.</p>\n<p>The extra flexibility of making a method <code>const</code> is that it can be used on both <code>const</code> and non-const objects. A non-const method cannot be used on a <code>const</code> object.</p>\n<p>Example:</p>\n<pre><code>class A {\n    int a;\n    public:\n    int method() const {\n        return a;\n    }\n};\n\nvoid f() {\n    A a;\n    const A ca;\n\n    a.method();\n    ca.method();\n}\n</code></pre>\n", "LastActivityDate": "2014-12-22T16:23:41.083", "CommentCount": "0", "CreationDate": "2014-12-22T16:23:41.083", "ParentId": "27606364", "Score": "4", "OwnerUserId": "13422"}, "27606476": {"Id": "27606476", "PostTypeId": "2", "Body": "<p>For beginners, <code>this</code> is often depicted as a constant pointer.</p>\n<p>However, <code>this</code> is actually a prvalue (pure rvalue) of pointer type. You can't assign anything to prvalues of fundamental type, which implies the \"const-ness\" of <code>this</code>.</p>\n<p>The exact type of <code>this</code> depends on the cv-qualification of the method. A rule of thumb is that the cv-qualification is simply prepended to the usual pointer type - i.e., if a method of <code>Class</code> is marked <code>const</code>, then the type is <code>const</code> <code>Class*</code>.</p>\n<blockquote>\n<p id=\"so_27606364_27606476_0\">if the compiler can compile it fine whether there is a 'const' or\n  not,why does it matter?</p>\n</blockquote>\n<p>If (and only if) the pointee type of <code>this</code> is <code>const</code>, you can't modify the members of the class. </p>\n<pre><code>Class const* ptr; // ptr-&gt;data is also const, not modifiable through this pointer\n\nClass* ptr; // ptr-&gt;data isn't const - can be modified.\n</code></pre>\n<p>The <code>const</code>-qualifier on methods allows you to distinguish between methods for <code>const</code> objects and methods for non-<code>const</code> ones, which is often a necessity.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-11-30T11:15:35.700", "Score": "12", "CreationDate": "2014-12-22T16:23:11.580", "ParentId": "27606364", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2015-11-30T11:15:35.700"}});