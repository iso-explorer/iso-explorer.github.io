post_cb({"38826007": {"CommentCount": "10", "AcceptedAnswerId": "38826971", "PostTypeId": "1", "LastEditorUserId": "817643", "CreationDate": "2016-08-08T09:47:41.937", "LastActivityDate": "2016-08-10T08:15:24.080", "LastEditDate": "2016-08-08T10:35:38.253", "ViewCount": "160", "FavoriteCount": "0", "Title": "How does DBL_MAX addition work?", "Id": "38826007", "Score": "2", "Body": "<p>Code</p>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;limits.h&gt;\n#include&lt;float.h&gt;\n\nint f( double x, double y, double z){\n  return  (x+y)+z == x+(y+z);\n}\n\nint ff( long long x, long long y, long long z){\n  return  (x+y)+z == x+(y+z);\n}\n\nint main()\n{\n    printf(\"%d\\n\",f(DBL_MAX,DBL_MAX,-DBL_MAX));     \n    printf(\"%d\\n\",ff(LLONG_MAX,LLONG_MAX,-LLONG_MAX));\n    return 0;\n}\n</code></pre>\n<p>Output</p>\n<pre><code>0\n1\n</code></pre>\n<p>I am unable to understand why both functions work differently. What is happening here?</p>\n", "Tags": "<c++><c><double>", "OwnerUserId": "3883931", "AnswerCount": "1"}, "38826971": {"ParentId": "38826007", "PostTypeId": "2", "CommentCount": "18", "Body": "<p>In the eyes of the C++ and the C standard, the integer version definitely and the floating point version potentially invoke Undefined Behavior because the results of the computation <code>x + y</code> is not representable in the type the arithmetic is performed on.<sup>\u2020</sup> So both functions may yield or even do anything.</p>\n<p>However, many real world platforms offer additional guarantees for floating point operations and implement integers in a certain way that lets us explain the results you get.</p>\n<p>Considering <code>f</code>, we note that many popular platforms implement floating point math as described in IEEE 754. Following the rules of that standard, we get for the LHS:</p>\n<pre><code>DBL_MAX + DBL_MAX = INF\n</code></pre>\n<p>and</p>\n<pre><code>INF - DBL_MAX = INF.\n</code></pre>\n<p>The RHS yields</p>\n<pre><code>DBL_MAX - DBL_MAX = 0\n</code></pre>\n<p>and</p>\n<pre><code>DBL_MAX + 0 = DBL_MAX\n</code></pre>\n<p>and thus LHS != RHS.</p>\n<p>Moving on to <code>ff</code>: Many platforms perform signed integer computation in twos complement. Twos complement's addition is assoziative, so the comparison will yield true as long as optimizer does not change it to something that contradicts twos complement rules.</p>\n<p>The latter is entirely possible (for example see <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=30475\" rel=\"nofollow\">this discussion</a>), so you cannot rely on signed integer overflow doing what I explained above. However, it seems that it \"was nice\" in this case.</p>\n<hr>\n<p><sup>\u2020</sup>Note that this never applies to unsigned integer arithmetic. In C++, unsigned integers implement arithmetic modulo <code>2^NumBits</code> where <code>NumBits</code> is the number of bits of the type. In this arithmetic, every integer can be represented by picking a representative of its equivalence class in <code>[0, 2^NumBits - 1]</code>. So this arithmetic can never overflow.</p>\n<p>For those doubting that the floating point case is potential UB: N4140 5/4 [expr] says</p>\n<blockquote>\n<p id=\"so_38826007_38826971_0\">If during the evaluation of an expression, the result is not mathematically defined or not in the range of\n  representable values for its type, the behavior is undefined.</p>\n</blockquote>\n<p>which is the case. The inf and NaN stuff is allowed, but not required in C++ and C floating point math. It is only required if <code>std::numeric_limits::is_iec559&lt;T&gt;</code> is true for floating point type in question. (Or in C, if it defines <code>__STDC_IEC_559__</code>. Otherwise, the Annex F stuff need not apply.) If either of the iec indicators guarantees us IEEE semantics, the behavior is well defined to do what I described above.</p>\n</hr>", "OwnerUserId": "3002139", "LastEditorUserId": "3002139", "LastEditDate": "2016-08-10T08:15:24.080", "Id": "38826971", "Score": "4", "CreationDate": "2016-08-08T10:33:44.513", "LastActivityDate": "2016-08-10T08:15:24.080"}, "bq_ids": {"n4140": {"so_38826007_38826971_0": {"section_id": 5937, "quality": 1.0, "length": 13}}, "n3337": {"so_38826007_38826971_0": {"section_id": 5709, "quality": 1.0, "length": 13}}, "n4659": {"so_38826007_38826971_0": {"section_id": 7421, "quality": 1.0, "length": 13}}}});