post_cb({"46740824": {"ParentId": "46740302", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-10-14T04:19:02.277", "Score": "2", "LastEditorUserId": "4832499", "LastEditDate": "2017-10-14T06:07:44.630", "Id": "46740824", "OwnerUserId": "8482126", "Body": "<p>C++ Standard does not care about how <code>system_clock::now()</code> gets implemented. It merely specifies</p>\n<blockquote>\n<p id=\"so_46740302_46740824_0\">Returns a <code>time_point</code> object representing the current point in time.</p>\n</blockquote>\n<p>A typical C++ standard library implementation would rely on the underlying OS system call to get the actural system clock value to construct the <code>time_point</code> object.</p>\n<p>In term of hardware implementation you will need to take hardware architecture into consideration. But typically maintenance cost for system clock is always there, no matter how many processes / threads are reading it. And system clock acquiring are implemented as a lightweight routine which will not result in thread block and will not become the performance bottleneck in a multithreaded program. </p>\n<p>Besides, <code>std::chrono::system_clock::now().time_since_epoch()</code> is a simple observer method which only returns the embedded <code>duration</code> object inside the <code>time_point</code> object returned by <code>std::chrono::system_clock::now()</code>, which involves only C++ struct copying.</p>\n", "LastActivityDate": "2017-10-14T06:07:44.630"}, "46740302": {"CommentCount": "5", "ViewCount": "65", "CreationDate": "2017-10-14T02:38:35.607", "LastActivityDate": "2017-10-14T06:07:44.630", "Title": "Where does the time from `std::chrono::system_clock::now().time_since_epoch()` come from and can it block if accessed from multiple threads?", "AcceptedAnswerId": "46740824", "PostTypeId": "1", "Id": "46740302", "Score": "1", "Body": "<p>Where does <code>std::chrono::system_clock::now().time_since_epoch()</code> come from?\nThat is, is it a direct interface with a crystal oscillator (physical component)? </p>\n<p>If it is a crystal oscillator, is there one per core or one for all cores?</p>\n<p>If there is one oscillator for all cores, can it block threads if multiple threads access it at the exact same time (low latency environment)?</p>\n<p>If there is a crystal oscillators for each core how are they all synchronised?</p>\n", "Tags": "<c++><time><hardware><chrono>", "OwnerUserId": "4605629", "AnswerCount": "2"}, "46741303": {"ParentId": "46740302", "CommentCount": "0", "CreationDate": "2017-10-14T05:40:30.837", "OwnerUserId": "3102935", "PostTypeId": "2", "Id": "46741303", "Score": "0", "Body": "<p>The standard specifies <code>std::chrono::system_clock</code> as follows:</p>\n<blockquote>\n<p id=\"so_46740302_46741303_0\">23.17.7.1 Class system_clock [time.clock.system]</p>\n<p id=\"so_46740302_46741303_1\">Objects of class system_clock represent wall clock time from the system-wide realtime clock.</p>\n</blockquote>\n<p>This has multiple implications. First, timepoints from this clock can be converted to and from <code>time_t</code> time via <code>std::chrono::system_clock::to_time_t</code> and <code>std::chrono::system_clock::from_time_t</code> hinting that the clock represents some sort of physical time. Secondly, the clock is specified as \"system-wide\" which means that all processes should retrieve the same <code>time_point</code> values from this clock.</p>\n<p>In practice, this means that this clock is most often implemented with calls to OS specific functions that retrieve some sort of time, as you'd for example see in your taskbar.</p>\n<p>Note that it is unspecified if this clock <code>is_steady</code>. This means that <code>timepoints</code> from this clock do not have to always advance. You could get an earlier timepoint even if the call occured later in physical time. This could happen if the user for example adjusted the clock through some OS setting.</p>\n<p>What is closer to what you are describing is <code>std::chrono::steady_clock</code>:</p>\n<blockquote>\n<p id=\"so_46740302_46741303_2\">23.17.7.2 Class steady_clock [time.clock.steady]</p>\n<p id=\"so_46740302_46741303_3\">Objects of class steady_clock represent clocks for which values of time_point never decrease as physical time advances and for which values of time_point advance at a steady rate relative to real time.</p>\n</blockquote>\n<p>We have two requirements mentioned. First, the clock has to be monotonic, so time can never \"run backwards\". Secondly, the clock is steady, so every tick of this clock should take the same amount of physical time.</p>\n<p>It feels natural to implement this clock with some sort of hardware counter like a cycle counter. But be careful: this clock does not have to be system wide. This is, so that a value can e.g. be fetched from the CPU it is currently executing, even if there are perhaps other CPUs present with different counters.</p>\n", "LastActivityDate": "2017-10-14T05:40:30.837"}, "bq_ids": {"n4140": {"so_46740302_46741303_1": {"section_id": 4848, "quality": 1.0, "length": 10}, "so_46740302_46741303_3": {"section_id": 4852, "quality": 1.0, "length": 20}, "so_46740302_46740824_0": {"section_id": 4739, "quality": 1.0, "length": 7}}, "n3337": {"so_46740302_46741303_1": {"section_id": 4643, "quality": 1.0, "length": 10}, "so_46740302_46741303_3": {"section_id": 4647, "quality": 1.0, "length": 20}, "so_46740302_46740824_0": {"section_id": 4546, "quality": 1.0, "length": 7}}, "n4659": {"so_46740302_46741303_1": {"section_id": 6273, "quality": 1.0, "length": 10}, "so_46740302_46741303_3": {"section_id": 6277, "quality": 1.0, "length": 20}, "so_46740302_46740824_0": {"section_id": 6150, "quality": 1.0, "length": 7}}}});