post_cb({"43052499": {"CommentCount": "1", "ViewCount": "287", "CreationDate": "2017-03-27T17:07:53.733", "LastActivityDate": "2017-03-27T19:12:13.123", "Title": "lambda capture during initialization should be an error", "AcceptedAnswerId": "43054585", "PostTypeId": "1", "Id": "43052499", "Score": "4", "Body": "<p>What I'm <em>trying</em> to do is eat exceptions when constructing an object that <em>may</em> be invalid. It'd be perfect for use of <code>std::optional</code>, but I don't believe the omission of <code>std::optional</code> changes the error I see: the object is being captured and used before it's been initialized. I don't believe it should be captured in the first place because we haven't reached a <em>sequence point</em> to the best of my knowledge (does a lambda initialization count as a sequence point?). Moreover, the bug is IMO easily catchable human error (and even does get caught... depending upon circumstances).</p>\n<p>How (more importantly, <em>why</em>) is the lambda able to capture and use the not-yet-initialized <code>foo</code>?</p>\n<p><a href=\"https://godbolt.org/g/IwcHrV\" rel=\"nofollow noreferrer\">https://godbolt.org/g/IwcHrV</a></p>\n<pre><code>#include &lt;string&gt;\nusing namespace std;\n\nvoid foo() {\n  string foo = [&amp;]()-&gt;string{\n    // using foo before it's been initialized == undefined behavior\n    auto guessed_foo = to_string(1234);\n    if ( begin(foo) == end(foo) ) {\n      return guessed_foo;\n    }\n    return {};\n  }();\n}\n</code></pre>\n<blockquote>\n<p id=\"so_43052499_43052499_0\">Compiler exited with result code 0</p>\n</blockquote>\n<p>But... replacing the declaration of <code>string foo</code> with <code>auto foo</code> <em>does</em> appear to cause an error similar to what I'd like to see.</p>\n<p><a href=\"https://godbolt.org/g/GfE4WH\" rel=\"nofollow noreferrer\">https://godbolt.org/g/GfE4WH</a></p>\n<pre><code>#include &lt;string&gt;\nusing namespace std;\n\nvoid foo() {\n  auto foo = [&amp;]()-&gt;string{\n    auto guessed_foo = to_string(1234);\n    if ( begin(foo) == end(foo) ) {\n      return guessed_foo;\n    }\n    return {};\n  }();\n}\n</code></pre>\n<blockquote>\n<p id=\"so_43052499_43052499_1\">error: variable 'foo' declared with 'auto' type cannot appear in its own initializer</p>\n</blockquote>\n<p>Note that I found this using GCC 6.2 on Ubuntu 16.04 LTS. The configuration in Godbolt is using clang 3.9.1. Both are configured for c++14.</p>\n<p>So my questions are:</p>\n<ul>\n<li>Why is the lambda capture for an initialization of a non-auto-declared variable able to capture and use the (not-yet-initialized) variable?</li>\n<li>Why does <code>auto</code> get (in my opinion, correctly) caught and errored?</li>\n<li>Moreover, why the difference between the above two? It sounds like compiler bugs, but... is there something specific in the standard declaring this to be correct behavior?</li>\n<li>This could be taken as an argument <em>for</em> <code>auto</code> keyword?</li>\n</ul>\n", "Tags": "<c++><lambda><initialization><c++14>", "OwnerUserId": "1111557", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_43052499_43054585_0": {"section_id": 5455, "quality": 1.0, "length": 10}}, "n3337": {"so_43052499_43054585_0": {"section_id": 3191, "quality": 0.6, "length": 6}}, "n4659": {"so_43052499_43054585_0": {"section_id": 6881, "quality": 1.0, "length": 10}}}, "43054585": {"ParentId": "43052499", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The second snippet runs into <a href=\"https://timsong-cpp.github.io/cppwp/dcl.spec.auto#10\" rel=\"nofollow noreferrer\">[dcl.spec.auto]/10</a>:</p>\n<blockquote>\n<p id=\"so_43052499_43054585_0\">If the type of an entity with an undeduced placeholder type is needed\n  to determine the type of an expression, the program is ill-formed.</p>\n</blockquote>\n<p>The type of <code>foo</code> is needed to determine the type of the expression <code>foo</code> within the lambda body, but at that point you haven't deduced <code>foo</code>'s type yet, so the program is ill-formed.</p>\n<hr>\n<p>As to why you are allowed to capture something before its initialization, see generally <a href=\"https://stackoverflow.com/questions/11186261/why-is-int-i-i-legal\">Why is 'int i = i;' legal?</a>. We have many examples of recursive lambdas using <code>std::function</code>:</p>\n<pre><code>std::function&lt;void(int)&gt; foo = [&amp;foo](int i){ return foo(i - 1); };\n</code></pre>\n</hr>", "OwnerUserId": "2756719", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:32:14.490", "Id": "43054585", "Score": "2", "CreationDate": "2017-03-27T19:12:13.123", "LastActivityDate": "2017-03-27T19:12:13.123"}});