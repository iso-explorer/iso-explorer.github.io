post_cb({"46119548": {"CommentCount": "3", "ViewCount": "64", "PostTypeId": "1", "LastEditorUserId": "1625187", "CreationDate": "2017-09-08T15:09:26.403", "LastActivityDate": "2017-09-08T17:07:25.553", "Title": "Constexpr member function in class template", "LastEditDate": "2017-09-08T15:29:38.750", "Id": "46119548", "Score": "3", "Body": "<p>The following code fails to compile:</p>\n<pre><code>// template&lt;class&gt;\nstruct S {\n    int g() const {\n        return 0;\n    }\n\n    constexpr int f() const {\n        return g();\n    }\n};\n\nint main()\n{\n    S /*&lt;int&gt;*/ s;\n    auto z = s.f();\n}\n</code></pre>\n<p>GCC, for example, complains: <em>error: call to non-constexpr function \u2018int S::g() const\u2019</em>. This is perfectly reasonable. But if I turn <em>S</em> into a template, the code compiles (checked with MSVC 15.3, GCC 7.1.0, clang 4.0.1).</p>\n<p>Why? Does <em>constexpr</em> has any special meaning in class templates?</p>\n<p>As far as I understand it, this code is incorrect, but the standard does not require that compilers produce an error (why?).</p>\n", "Tags": "<c++11><templates><constexpr>", "OwnerUserId": "1625187", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_46119548_46120142_1": {"section_id": 6185, "quality": 0.75, "length": 12}}, "n3337": {"so_46119548_46120142_1": {"section_id": 5946, "quality": 0.9375, "length": 15}, "so_46119548_46120142_0": {"section_id": 5214, "quality": 0.9047619047619048, "length": 19}}, "n4659": {"so_46119548_46120142_1": {"section_id": 7687, "quality": 0.625, "length": 10}}}, "46120142": {"ParentId": "46119548", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Per [dcl.constexpr]</p>\n<blockquote>\n<p id=\"so_46119548_46120142_0\">The definition of a constexpr function shall satisfy the following constraints:<br/>\n  ...<br/>every constructor call and implicit conversion used in initializing the return value (6.6.3, 8.5) shall be\n  one of those allowed in a constant expression</p>\n</blockquote>\n<p>A call to <code>g()</code> is not allowed in a constant expression. Per [expr.const]:</p>\n<blockquote>\n<p id=\"so_46119548_46120142_1\">A <em>conditional-expression</em> is a <em>core constant expression</em> unless it involves one of the following as a potentially\n  evaluated subexpression...: <br/>\n  \u2014 an invocation of a function other than [...] a <code>constexpr</code> function</p>\n</blockquote>\n<p>It looks like some compilers may allow you to do what you're doing because <code>z</code> isn't declared <code>constexpr</code> so the value doesn't need to be known at compile-time. If you change your code to </p>\n<pre><code>constexpr auto z = s.f();\n</code></pre>\n<p>you'll note that all those compilers will proceed to barf, template or not.</p>\n", "OwnerUserId": "27678", "LastEditorUserId": "27678", "LastEditDate": "2017-09-08T17:07:25.553", "Id": "46120142", "Score": "1", "CreationDate": "2017-09-08T15:43:00.913", "LastActivityDate": "2017-09-08T17:07:25.553"}});