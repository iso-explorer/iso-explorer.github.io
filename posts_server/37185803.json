post_cb({"bq_ids": {"n4140": {"so_37185803_37189273_9": {"length": 5, "quality": 1.0, "section_id": 5440}, "so_37185803_37189273_8": {"length": 5, "quality": 1.0, "section_id": 5440}, "so_37185803_37189273_5": {"length": 6, "quality": 0.75, "section_id": 5959}, "so_37185803_37189273_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 5959}, "so_37185803_37189273_0": {"length": 10, "quality": 1.0, "section_id": 5959}, "so_37185803_37189273_6": {"length": 6, "quality": 0.8571428571428571, "section_id": 5440}, "so_37185803_37189273_7": {"length": 18, "quality": 0.9473684210526315, "section_id": 5440}, "so_37185803_37189273_3": {"length": 8, "quality": 0.8, "section_id": 5959}, "so_37185803_37189273_11": {"length": 6, "quality": 0.8571428571428571, "section_id": 5440}}, "n3337": {"so_37185803_37189273_8": {"length": 5, "quality": 1.0, "section_id": 5235}, "so_37185803_37189273_5": {"length": 6, "quality": 0.75, "section_id": 5728}, "so_37185803_37189273_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 5728}, "so_37185803_37189273_9": {"length": 5, "quality": 1.0, "section_id": 5235}, "so_37185803_37189273_0": {"length": 10, "quality": 1.0, "section_id": 5728}, "so_37185803_37189273_6": {"length": 5, "quality": 0.7142857142857143, "section_id": 5235}, "so_37185803_37189273_7": {"length": 18, "quality": 0.9473684210526315, "section_id": 5235}, "so_37185803_37189273_3": {"length": 8, "quality": 0.8, "section_id": 5728}, "so_37185803_37189273_11": {"length": 6, "quality": 0.8571428571428571, "section_id": 5235}}, "n4659": {"so_37185803_37189273_8": {"length": 5, "quality": 1.0, "section_id": 6867}, "so_37185803_37189273_5": {"length": 6, "quality": 0.75, "section_id": 7440}, "so_37185803_37189273_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 7440}, "so_37185803_37189273_0": {"length": 10, "quality": 1.0, "section_id": 7440}, "so_37185803_37189273_9": {"length": 5, "quality": 1.0, "section_id": 6867}, "so_37185803_37189273_11": {"length": 6, "quality": 0.8571428571428571, "section_id": 6867}, "so_37185803_37189273_7": {"length": 18, "quality": 0.9473684210526315, "section_id": 6867}, "so_37185803_37189273_3": {"length": 8, "quality": 0.8, "section_id": 7440}, "so_37185803_37189273_6": {"length": 6, "quality": 0.8571428571428571, "section_id": 6867}}}, "37185803": {"ViewCount": "204", "Body": "<p>Consider the following class:</p>\n<pre><code>class MyClass\n{\n    int _id;\npublic:\n    decltype(_id) getId();\n};\n\ndecltype(MyClass::_id) MyClass::getId()\n{\n    return _id;\n}\n</code></pre>\n<p>It compiles fine.</p>\n<p>However when I make a template class out of it:</p>\n<pre><code>template &lt;class T&gt;\nclass MyClass\n{\n    int _id;\npublic:\n    decltype(_id) getId();\n};\n\ntemplate &lt;class T&gt;\ndecltype(MyClass&lt;T&gt;::_id) MyClass&lt;T&gt;::getId()\n{\n    return _id;\n}\n</code></pre>\n<p>I get:</p>\n<pre><code>test.cpp:10:27: error: prototype for 'decltype (MyClass&lt;T&gt;::_id) MyClass&lt;T&gt;::getId()' does not match any in class 'MyClass&lt;T&gt;'\n decltype(MyClass&lt;T&gt;::_id) MyClass&lt;T&gt;::getId()                                                                                \n                           ^\ntest.cpp:6:19: error: candidate is: decltype (((MyClass&lt;T&gt;*)(void)0)-&gt;MyClass&lt;T&gt;::_id) MyClass&lt;T&gt;::getId()\n     decltype(_id) getId();\n                   ^\n</code></pre>\n<p>Why is that?<br>\nWhy the different types</br></p>\n<ul>\n<li><code>decltype (MyClass&lt;T&gt;::_id) MyClass&lt;T&gt;::getId()</code></li>\n<li><code>decltype (((MyClass&lt;T&gt;*)(void)0)-&gt;MyClass&lt;T&gt;::_id)</code></li>\n</ul>\n<p>I could fix it by defining the body in the class:</p>\n<pre><code>template &lt;class T&gt;\nclass MyClass\n{\n    int _id;\npublic:\n    decltype(_id) getId() { return _id; }\n};\n</code></pre>\n<p>Trailing return type suffers a similar problem:</p>\n<pre><code>template &lt;class T&gt;\nclass MyClass\n{\n    int _id;\npublic:\n    auto getId() -&gt; decltype(_id);\n};\n\ntemplate &lt;class T&gt;\nauto MyClass&lt;T&gt;::getId() -&gt; decltype(MyClass&lt;T&gt;::_id)\n{\n    return _id;\n}\n</code></pre>\n<p>error:</p>\n<pre><code>test.cpp:10:6: error: prototype for 'decltype (MyClass&lt;T&gt;::_id) MyClass&lt;T&gt;::getId()' does not match any in class 'MyClass&lt;T&gt;'\n auto MyClass&lt;T&gt;::getId() -&gt; decltype(MyClass&lt;T&gt;::_id)\n      ^\ntest.cpp:6:10: error: candidate is: decltype (((MyClass&lt;T&gt;*)this)-&gt;MyClass&lt;T&gt;::_id) MyClass&lt;T&gt;::getId()\n     auto getId() -&gt; decltype(_id);\n          ^\n</code></pre>\n<ul>\n<li><code>decltype (MyClass&lt;T&gt;::_id) MyClass&lt;T&gt;::getId()</code></li>\n<li><code>decltype (((MyClass&lt;T&gt;*)this)-&gt;MyClass&lt;T&gt;::_id) MyClass&lt;T&gt;::getId()</code></li>\n</ul>\n<p>g++ 5.3.0</p>\n", "AcceptedAnswerId": "37189273", "Title": "prototype mismatch with decltype and auto", "CreationDate": "2016-05-12T11:40:06.803", "Id": "37185803", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-05-12T11:44:49.370", "LastEditorUserId": "1784001", "LastActivityDate": "2016-05-12T14:50:17.470", "Score": "14", "OwnerUserId": "1784001", "Tags": "<c++><templates><c++14><auto><decltype>", "AnswerCount": "3"}, "37186060": {"Id": "37186060", "PostTypeId": "2", "Body": "<p>It seems like this is <code>g++</code> bug.</p>\n<p>I've tried your code in Visual Studio 2015:</p>\n<blockquote>\n<p id=\"so_37185803_37186060_0\">Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped</p>\n</blockquote>\n<p>Edit: I found <a href=\"http://coliru.stacked-crooked.com/view?id=c6afa8c7c5eb6ac3\" rel=\"nofollow\">workaround</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt;\nclass MyClass\n{\n    T _id = {0};\npublic:\n    decltype(((MyClass&lt;T&gt;*)nullptr)-&gt;_id) getId();\n};\n\ntemplate &lt;class T&gt;\ndecltype(((MyClass&lt;T&gt;*)nullptr)-&gt;_id) MyClass&lt;T&gt;::getId()\n{\n    return _id;\n}\n\nint main()\n{\n    MyClass&lt;int&gt; f;\n    auto n = f.getId();\n\n    std::cout &lt;&lt; n &lt;&lt; '\\n'; // output: 0\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>0\n</code></pre>\n", "LastEditorUserId": "5938816", "LastActivityDate": "2016-05-12T12:03:55.610", "Score": "2", "CreationDate": "2016-05-12T11:51:41.443", "ParentId": "37185803", "CommentCount": "4", "OwnerUserId": "5938816", "LastEditDate": "2016-05-12T12:03:55.610"}, "37188656": {"Id": "37188656", "PostTypeId": "2", "Body": "<p>It seems to be GCC <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57712\" rel=\"nofollow\">Bug 57712</a>.</p>\n<p>Example code from the bug description:</p>\n<pre><code>struct Test {\n  int method(int value) { return value; }\n\n  template &lt;typename T&gt;\n  auto test(T value) -&gt; decltype(this-&gt;method(value));\n};\n\ntemplate &lt;typename T&gt;\nauto Test::test(T value) -&gt; decltype(this-&gt;method(value)) {\n  return this-&gt;method(value);\n}\n</code></pre>\n", "LastActivityDate": "2016-05-12T13:38:55.103", "CommentCount": "0", "CreationDate": "2016-05-12T13:38:55.103", "ParentId": "37185803", "Score": "1", "OwnerUserId": "2020827"}, "37189273": {"Id": "37189273", "PostTypeId": "2", "Body": "<p>According to the draft standard <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4582.pdf\" rel=\"nofollow\">N4582</a> <em>\u00a75.1.1/p13 General [expr.prim.general]</em> (<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_37185803_37189273_0\">An id-expression that denotes a non-static data member or non-static\n  member function of a class can only be used:</p>\n<p id=\"so_37185803_37189273_1\">(13.1) \u2014  as part of a class member access (5.2.5) in which the object\n  expression refers to the member\u2019s class<sup>63</sup> or a class\n  derived from that class, or</p>\n<p id=\"so_37185803_37189273_2\">(13.2) \u2014 to form a pointer to member (5.3.1), or</p>\n<p id=\"so_37185803_37189273_3\"><strong>(13.3) \u2014 if that id-expression denotes a non-static data member and it\n  appears in an unevaluated operand. [Example:</strong></p>\n<pre><code>struct S {\nint m;\n};\nint i = sizeof(S::m); // OK\nint j = sizeof(S::m + 42); // OK\n</code></pre>\n<p id=\"so_37185803_37189273_4\"><strong>\u2014 end example ]</strong></p>\n<p id=\"so_37185803_37189273_5\"><sub>63) This also applies when the object expression is an implicit\n  (*this) (9.3.1).</sub></p>\n</blockquote>\n<p>Also from <em>\u00a77.1.6.2/p4 Simple type specifiers [dcl.type.simple]</em>(<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_37185803_37189273_6\">For an expression <code>e</code>, the type denoted by <code>decltype(e)</code> is defined as\n  follows:</p>\n<p id=\"so_37185803_37189273_7\">(4.1) \u2014 if <code>e</code> is an unparenthesized id-expression or an unparenthesized\n  class member access (5.2.5), <code>decltype(e)</code> is the type of the entity\n  named by e. If there is no such entity, or if e names a set of\n  overloaded functions, the program is ill-formed;</p>\n<p id=\"so_37185803_37189273_8\">(4.2) \u2014 otherwise, if e is an xvalue, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where\n  <code>T</code> is the type of <code>e</code>;</p>\n<p id=\"so_37185803_37189273_9\">(4.3) \u2014 otherwise, if e is an lvalue, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code>\n  is the type of <code>e</code>;</p>\n<p id=\"so_37185803_37189273_10\">(4.4) \u2014 otherwise, <code>decltype(e)</code> is the type of <code>e</code>.</p>\n<p id=\"so_37185803_37189273_11\"><strong>The operand of the <code>decltype</code> specifier is an unevaluated operand (Clause 5).</strong></p>\n<p id=\"so_37185803_37189273_12\">[Example:</p>\n<pre><code>const int&amp;&amp; foo();\nint i;\nstruct A { double x; };\nconst A* a = new A();\ndecltype(foo()) x1 = 17; // type is const int&amp;&amp;\ndecltype(i) x2; // type is int\ndecltype(a-&gt;x) x3; // type is double\ndecltype((a-&gt;x)) x4 = x3; // type is const double&amp;\n</code></pre>\n<p id=\"so_37185803_37189273_13\">\u2014 end example ] [ Note: The rules for determining types involving\n  decltype(auto) are specified in 7.1.6.4. \u2014 end note ]</p>\n</blockquote>\n<p>Consequently, since <code>decltype</code> is an unevaluated operand the code is legitimate and should compile.</p>\n<p>One clean workaround would be to use <code>decltype(auto)</code>:</p>\n<pre><code>template&lt;typename T&gt;\nclass MyClass {\n  int _id;  \npublic:\n  decltype(auto) getId();\n};\n\ntemplate&lt;typename T&gt;\ndecltype(auto) MyClass&lt;T&gt;::getId() {\n  return _id;\n}\n</code></pre>\n<p>Above code is accepted by GCC/CLANG/VC++.</p>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2016-05-12T14:50:17.470", "Score": "3", "CreationDate": "2016-05-12T14:01:51.460", "ParentId": "37185803", "CommentCount": "0", "OwnerUserId": "2352671", "LastEditDate": "2016-05-12T14:50:17.470"}});