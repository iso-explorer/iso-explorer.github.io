post_cb({"4819972": {"Id": "4819972", "PostTypeId": "2", "Body": "<p>Implicitly generated move constructors have been considered for the standard, but can be dangerous. See Dave Abrahams's <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3153.htm\" rel=\"noreferrer\">analysis</a>.</p>\n<p>In the end, however, the standard did include implicit generation of move constructors and move assignment operators, though with a fairly substantial list of limitations:</p>\n<blockquote>\n<p id=\"so_4819936_4819972_0\">If the definition of a class X does not explicitly declare a move constructor, one will be implicitly declared as defaulted if and only if<br>\n  \u2014 X does not have a user-declared copy constructor,<br>\n  \u2014 X does not have a user-declared copy assignment operator,<br>\n  \u2014 X does not have a user-declared move assignment operator,<br>\n  \u2014 X does not have a user-declared destructor, and<br>\n  \u2014 the move constructor would not be implicitly defined as deleted.</br></br></br></br></br></p>\n</blockquote>\n<p>That's not quite all there is to the story though. A ctor can be declared, but still defined as deleted:</p>\n<blockquote>\n<p id=\"so_4819936_4819972_1\">An implicitly-declared copy/move constructor is an inline public member of its class. A defaulted copy/move constructor for a class X is defined as deleted (8.4.3) if X has:</p>\n<p id=\"so_4819936_4819972_2\">\u2014 a variant member with a non-trivial corresponding constructor and X is a union-like class,<br>\n  \u2014 a non-static data member of class type M (or array thereof) that cannot be copied/moved because overload resolution (13.3), as applied to M\u2019s corresponding constructor, results in an ambiguity or a function that is deleted or inaccessible from the defaulted constructor,<br>\n  \u2014 a direct or virtual base class B that cannot be copied/moved because overload resolution (13.3), as applied to B\u2019s corresponding constructor, results in an ambiguity or a function that is deleted or inaccessible from the defaulted constructor,<br>\n  \u2014 any direct or virtual base class or non-static data member of a type with a destructor that is deleted or inaccessible from the defaulted constructor,<br>\n  \u2014 for the copy constructor, a non-static data member of rvalue reference type, or<br>\n  \u2014 for the move constructor, a non-static data member or direct or virtual base class with a type that does not have a move constructor and is not trivially copyable.</br></br></br></br></br></p>\n</blockquote>\n", "LastEditorUserId": "179910", "LastActivityDate": "2014-08-28T19:02:01.770", "Score": "12", "CreationDate": "2011-01-27T17:54:40.413", "ParentId": "4819936", "CommentCount": "7", "OwnerUserId": "179910", "LastEditDate": "2014-08-28T19:02:01.770"}, "4826308": {"Id": "4826308", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_4819936_4826308_0\">(as for now, I'm working on a stupid macro...)</p>\n</blockquote>\n<p>Yeah, I went that route too. Here's your macro:</p>\n<pre><code>// detail/move_default.hpp\n#ifndef UTILITY_DETAIL_MOVE_DEFAULT_HPP\n#define UTILITY_DETAIL_MOVE_DEFAULT_HPP\n\n#include &lt;boost/preprocessor.hpp&gt;\n\n#define UTILITY_MOVE_DEFAULT_DETAIL_CONSTRUCTOR_BASE(pR, pData, pBase) pBase(std::move(pOther))\n#define UTILITY_MOVE_DEFAULT_DETAIL_ASSIGNMENT_BASE(pR, pData, pBase) pBase::operator=(std::move(pOther));\n\n#define UTILITY_MOVE_DEFAULT_DETAIL_CONSTRUCTOR(pR, pData, pMember) pMember(std::move(pOther.pMember))\n#define UTILITY_MOVE_DEFAULT_DETAIL_ASSIGNMENT(pR, pData, pMember) pMember = std::move(pOther.pMember);\n\n#define UTILITY_MOVE_DEFAULT_DETAIL(pT, pBases, pMembers)                                               \\\n        pT(pT&amp;&amp; pOther) :                                                                               \\\n        BOOST_PP_SEQ_ENUM(BOOST_PP_SEQ_TRANSFORM(                                                       \\\n            UTILITY_MOVE_DEFAULT_DETAIL_CONSTRUCTOR_BASE, BOOST_PP_EMPTY, pBases))                      \\\n        ,                                                                                               \\\n        BOOST_PP_SEQ_ENUM(BOOST_PP_SEQ_TRANSFORM(                                                       \\\n            UTILITY_MOVE_DEFAULT_DETAIL_CONSTRUCTOR, BOOST_PP_EMPTY, pMembers))                         \\\n        {}                                                                                              \\\n                                                                                                        \\\n        pT&amp; operator=(pT&amp;&amp; pOther)                                                                      \\\n        {                                                                                               \\\n            BOOST_PP_SEQ_FOR_EACH(UTILITY_MOVE_DEFAULT_DETAIL_ASSIGNMENT_BASE, BOOST_PP_EMPTY, pBases)  \\\n            BOOST_PP_SEQ_FOR_EACH(UTILITY_MOVE_DEFAULT_DETAIL_ASSIGNMENT, BOOST_PP_EMPTY, pMembers)     \\\n                                                                                                        \\\n            return *this;                                                                               \\\n        }\n\n#define UTILITY_MOVE_DEFAULT_BASES_DETAIL(pT, pBases)                                                   \\\n        pT(pT&amp;&amp; pOther) :                                                                               \\\n        BOOST_PP_SEQ_ENUM(BOOST_PP_SEQ_TRANSFORM(                                                       \\\n            UTILITY_MOVE_DEFAULT_DETAIL_CONSTRUCTOR_BASE, BOOST_PP_EMPTY, pBases))                      \\\n        {}                                                                                              \\\n                                                                                                        \\\n        pT&amp; operator=(pT&amp;&amp; pOther)                                                                      \\\n        {                                                                                               \\\n            BOOST_PP_SEQ_FOR_EACH(UTILITY_MOVE_DEFAULT_DETAIL_ASSIGNMENT_BASE, BOOST_PP_EMPTY, pBases)  \\\n                                                                                                        \\\n            return *this;                                                                               \\\n        }\n\n#define UTILITY_MOVE_DEFAULT_MEMBERS_DETAIL(pT, pMembers)                                               \\\n        pT(pT&amp;&amp; pOther) :                                                                               \\\n        BOOST_PP_SEQ_ENUM(BOOST_PP_SEQ_TRANSFORM(                                                       \\\n            UTILITY_MOVE_DEFAULT_DETAIL_CONSTRUCTOR, BOOST_PP_EMPTY, pMembers))                         \\\n        {}                                                                                              \\\n                                                                                                        \\\n        pT&amp; operator=(pT&amp;&amp; pOther)                                                                      \\\n        {                                                                                               \\\n            BOOST_PP_SEQ_FOR_EACH(UTILITY_MOVE_DEFAULT_DETAIL_ASSIGNMENT, BOOST_PP_EMPTY, pMembers)     \\\n                                                                                                        \\\n            return *this;                                                                               \\\n        }\n\n#endif\n</code></pre>\n<p>\u200b</p>\n<pre><code>// move_default.hpp\n#ifndef UTILITY_MOVE_DEFAULT_HPP\n#define UTILITY_MOVE_DEFAULT_HPP\n\n#include \"utility/detail/move_default.hpp\"\n\n// move bases and members\n#define UTILITY_MOVE_DEFAULT(pT, pBases, pMembers) UTILITY_MOVE_DEFAULT_DETAIL(pT, pBases, pMembers)\n\n// base only version\n#define UTILITY_MOVE_DEFAULT_BASES(pT, pBases) UTILITY_MOVE_DEFAULT_BASES_DETAIL(pT, pBases)\n\n// member only version\n#define UTILITY_MOVE_DEFAULT_MEMBERS(pT, pMembers) UTILITY_MOVE_DEFAULT_MEMBERS_DETAIL(pT, pMembers)\n\n#endif\n</code></pre>\n<p>(I've removed the real comments, which are length and documentary.)</p>\n<p>You specify the bases and/or members in your class as a preprocessor list, for example:</p>\n<pre><code>#include \"move_default.hpp\"\n\nstruct foo\n{\n    UTILITY_MOVE_DEFAULT_MEMBERS(foo, (x)(str));\n\n    int x;\n    std::string str;\n};\n\nstruct bar : foo, baz\n{\n    UTILITY_MOVE_DEFAULT_BASES(bar, (foo)(baz));\n};\n\nstruct baz : bar\n{\n    UTILITY_MOVE_DEFAULT(baz, (bar), (ptr));\n\n    void* ptr;\n};\n</code></pre>\n<p>And out comes a move-constructor and move-assignment operator.</p>\n<p>(As an aside, if anyone knows how I could combine the details into one macro, that would be swell.)</p>\n", "LastActivityDate": "2011-01-28T08:39:32.670", "Score": "8", "CreationDate": "2011-01-28T08:39:32.670", "ParentId": "4819936", "CommentCount": "12", "OwnerUserId": "87234", "CommunityOwnedDate": "2011-01-28T08:39:32.670"}, "bq_ids": {"n4140": {"so_4819936_4819972_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 460}, "so_4819936_4820339_1": {"length": 5, "quality": 1.0, "section_id": 458}, "so_4819936_4820339_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 456}, "so_4819936_4820339_2": {"length": 6, "quality": 1.0, "section_id": 458}, "so_4819936_4820339_0": {"length": 12, "quality": 1.0, "section_id": 458}, "so_4819936_4820339_3": {"length": 6, "quality": 1.0, "section_id": 458}, "so_4819936_4819972_0": {"length": 36, "quality": 0.9230769230769231, "section_id": 458}}, "n3337": {"so_4819936_4820339_4": {"length": 4, "quality": 1.0, "section_id": 449}, "so_4819936_4819972_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 451}, "so_4819936_4819972_2": {"length": 85, "quality": 0.9770114942528736, "section_id": 451}, "so_4819936_4820339_1": {"length": 5, "quality": 1.0, "section_id": 449}, "so_4819936_4820339_3": {"length": 6, "quality": 1.0, "section_id": 449}, "so_4819936_4820339_5": {"length": 6, "quality": 1.0, "section_id": 449}, "so_4819936_4820339_2": {"length": 6, "quality": 1.0, "section_id": 449}, "so_4819936_4820339_0": {"length": 12, "quality": 1.0, "section_id": 449}, "so_4819936_4819972_0": {"length": 39, "quality": 1.0, "section_id": 449}}, "n4659": {"so_4819936_4819972_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 483}, "so_4819936_4820339_1": {"length": 5, "quality": 1.0, "section_id": 481}, "so_4819936_4820339_3": {"length": 6, "quality": 1.0, "section_id": 481}, "so_4819936_4820339_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 479}, "so_4819936_4820339_2": {"length": 6, "quality": 1.0, "section_id": 481}, "so_4819936_4820339_0": {"length": 12, "quality": 1.0, "section_id": 481}, "so_4819936_4819972_0": {"length": 36, "quality": 0.9230769230769231, "section_id": 481}}}, "4819936": {"ViewCount": "32834", "Body": "<p>I'm a simple programmer.  My class members variables most often consists of POD-types and STL-containers. Because of this I seldom have to write assignment operators or copy constructors, as these are implemented by default.</p>\n<p>Add to this, if I use <code>std::move</code> on objects not movable, it utilizes the assignment-operator, meaning <code>std::move</code> is perfectly safe.</p>\n<p>As I'm a simple programmer, I'd like to take advantage of the move-capabilities without adding a move constructor/assignment operator to every class I write, as the compiler could simply implemented them as \"<code>this-&gt;member1_ = std::move(other.member1_);...</code>\"</p>\n<p>But it doesn't (at least not in Visual 2010), is there any particular reason for this?</p>\n<p>More importantly; <strong>is there any way to get around this?</strong></p>\n<p><em><strong>Update:</strong></em></p>\nIf you look down at GManNickG's answer he provides a great macro for this. And if you didn't know, if you implement move-semantics you can remove the swap member function.\n", "AcceptedAnswerId": "4820339", "Title": "Why no default move-assignment/move-constructor?", "CreationDate": "2011-01-27T17:51:00.930", "Id": "4819936", "CommentCount": "2", "FavoriteCount": "24", "PostTypeId": "1", "LastEditDate": "2012-03-04T22:01:41.293", "LastEditorUserId": "100724", "LastActivityDate": "2014-08-28T19:02:01.770", "Score": "78", "OwnerUserId": "100724", "Tags": "<c++><c++11><pod><move-semantics>", "AnswerCount": "4"}, "4820275": {"Id": "4820275", "PostTypeId": "2", "Body": "<p>VS2010 doesn't do it because they weren't Standard at the time of implementation.</p>\n", "LastActivityDate": "2011-01-27T18:25:40.490", "CommentCount": "0", "CreationDate": "2011-01-27T18:25:40.490", "ParentId": "4819936", "Score": "4", "OwnerUserId": "298661"}, "4820339": {"Id": "4820339", "PostTypeId": "2", "Body": "<p>The implicit generation of move constructors and assignment operators has been contentious and there have been major revisions in recent drafts of the C++ Standard, so currently available compilers will likely behave differently with respect to implicit generation.</p>\n<p>For more about the history of the issue, see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/\" rel=\"noreferrer\">the 2010 WG21 papers list</a> and search for \"mov\"</p>\n<p>The current specification (N3225, from November) states (N3225 12.8/8):</p>\n<blockquote>\n<p id=\"so_4819936_4820339_0\">If the definition of a class <code>X</code> does not explicitly declare a move constructor, one will be implicitly declared as defaulted if and only if </p>\n<ul>\n<li><p id=\"so_4819936_4820339_1\"><code>X</code> does not have a user-declared copy constructor, and </p></li>\n<li><p id=\"so_4819936_4820339_2\"><code>X</code> does not have a user-declared copy assignment operator, </p></li>\n<li><p id=\"so_4819936_4820339_3\"><code>X</code> does not have a user-declared move assignment operator, </p></li>\n<li><p id=\"so_4819936_4820339_4\"><code>X</code> does not have a user-declared destructor, and </p></li>\n<li><p id=\"so_4819936_4820339_5\">the move constructor would not be implicitly defined as deleted. </p></li>\n</ul>\n</blockquote>\n<p>There is similar language in 12.8/22 specifying when the move assignment operator is implicitly declared as defaulted.  You can find the complete list of changes made to support the current specification of implicit move generation in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3203.htm\" rel=\"noreferrer\">N3203:  Tightening the conditions for generating implicit moves\n</a>, which was based largely on one of the resolutions proposed by Bjarne Stroustrup's paper <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3201.pdf\" rel=\"noreferrer\">N3201:  Moving right along</a>.</p>\n", "LastEditorUserId": "151292", "LastActivityDate": "2013-09-22T06:12:55.750", "Score": "70", "CreationDate": "2011-01-27T18:33:15.683", "ParentId": "4819936", "CommentCount": "11", "OwnerUserId": "151292", "LastEditDate": "2013-09-22T06:12:55.750"}});