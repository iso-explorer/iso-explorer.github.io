post_cb({"10260581": {"ParentId": "10259665", "CommentCount": "0", "Body": "<p>It seems that you have rediscovered on your own the issue about the separate compilation model that C and C++ use. While it certainly eases memory requirements (which was important at the time of its creation), it does so by exposing only minimal information to the compiler, meaning that some optimizations (like this one) cannot be performed.</p>\n<p>Newer languages, with their module systems can expose as much information as necessary, and we can hope to rip those benefits if modules get into the next version of C++...</p>\n<p>In the mean time, the simplest thing to go for is called Link-Time Optimization. The idea is that you will perform as much optimization as possible on each TU (Translation Unit) to obtain an object file, but you will also enrich the traditional object file (which contain assembly) with IR (Intermediate Representation, used by compilers to optimize) for part of or all functions.</p>\n<p>When the linker will be invoked to merge those object files together, instead of just merging the files together, it will merge the IR representations, rexeecute a number of optimization passes (constant propagation, inlining, ...) and then create assembly on its own. It means that instead of being just a linker, it is in fact a backend optimizer.</p>\n<p>Of course, like all optimization passes this has a cost, so makes for longer compilation. Also, it means that both the compiler <em>and</em> the linker should be passed a special option to trigger this behavior, in the case of gcc, it would be <code>-lto</code> or <code>-O4</code>.</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "10260581", "Score": "6", "CreationDate": "2012-04-21T15:57:46.313", "LastActivityDate": "2012-04-21T15:57:46.313"}, "10259665": {"CommentCount": "3", "AcceptedAnswerId": "10259702", "PostTypeId": "1", "LastEditorUserId": "492364", "CreationDate": "2012-04-21T14:14:23.213", "LastActivityDate": "2012-04-21T19:47:56.203", "LastEditDate": "2012-04-21T14:22:03.443", "ViewCount": "1453", "FavoriteCount": "2", "Title": "Can GCC optimize things better when I compile everything in one step?", "Id": "10259665", "Score": "10", "Body": "<p>gcc optimizes code when I pass it the <code>-O2</code> flag, but I'm wondering how well it can actually do that if I compile all source files to object files and then link them afterwards.</p>\n<p>Here's an example:</p>\n<pre><code>// in a.h\nint foo(int n);\n\n// in foo.cpp\nint foo(int n) {\n  return n;\n}\n\n// in main.cpp\n#include \"a.h\"\nint main(void) {\n  return foo(5);\n}\n\n// code used to compile it all\ngcc -c -O2 foo.cpp -o foo.o\ngcc -c -O2 main.cpp -o main.o\ngcc -O2 foo.o main.o -o executable\n</code></pre>\n<p>Normally, gcc should inline <code>foo</code> because it's a small function and <code>-O2</code> enables <code>-finline-small-functions</code>, right? But here, gcc only sees the code of <code>foo</code> and <code>main</code> independently before it creates the object files, so there won't be any optimizations like that, right? So, does compiling like this really make code slower?</p>\n<p>However, I could also compile it like this:</p>\n<pre><code>gcc -O2 foo.cpp main.cpp -o executable\n</code></pre>\n<p>Would that be faster? If not, would it be faster this way?</p>\n<pre><code>// in foo.cpp\nint foo(int n) {\n  return n;\n}\n\n// in main.cpp\n#include \"foo.cpp\"\nint main(void) {\n  return foo(5);\n}\n</code></pre>\n<p><strong>Edit</strong>: I looked at <code>objdump</code>, and its disassembled code showed that only the <code>#include \"foo.cpp\"</code> thing worked.</p>\n", "Tags": "<c++><optimization><gcc>", "OwnerUserId": "492364", "AnswerCount": "3"}, "10259702": {"ParentId": "10259665", "CommentCount": "4", "Body": "<p>You may be looking for <a href=\"http://gcc.gnu.org/wiki/LinkTimeOptimization\" rel=\"noreferrer\">Link-Time Optimization</a> (LTO), aka Whole Program Optimization.</p>\n", "OwnerUserId": "4323", "PostTypeId": "2", "Id": "10259702", "Score": "5", "CreationDate": "2012-04-21T14:18:36.940", "LastActivityDate": "2012-04-21T14:18:36.940"}, "bq_ids": {"n4140": {"so_10259665_10262415_4": {"section_id": 5403, "quality": 0.625, "length": 5}}, "n3337": {"so_10259665_10262415_4": {"section_id": 5198, "quality": 0.625, "length": 5}}, "n4659": {"so_10259665_10262415_3": {"section_id": 8540, "quality": 0.5294117647058824, "length": 9}}}, "10262415": {"ParentId": "10259665", "CommentCount": "0", "Body": "<p>Since you're using GCC, you can use the C99 <code>inline</code> function specifier mechanism.  This is from ISO/IEC 9899:1999.</p>\n<blockquote>\n<p id=\"so_10259665_10262415_0\">\u00a7 6.7.4 Function specifiers</p>\n<h3>Syntax</h3>\n<p id=\"so_10259665_10262415_1\">\u00b61 <em>function-specifier:</em> </p>\n<pre><code>      inline\n</code></pre>\n<h3>Constraints</h3>\n<p id=\"so_10259665_10262415_2\">\u00b62 Function specifiers shall be used only in the declaration of an identifier for a function.</p>\n<p id=\"so_10259665_10262415_3\">\u00b63 An inline definition of a function with external linkage shall not contain a definition of a\n  modifiable object with static storage duration, and shall not contain a reference to an\n  identifier with internal linkage.</p>\n<p id=\"so_10259665_10262415_4\">\u00b64 In a hosted environment, the <code>inline</code> function specifier shall not appear in a declaration\n  of <code>main</code>.</p>\n<h3>Semantics</h3>\n<p id=\"so_10259665_10262415_5\">\u00b65 A function declared with an <code>inline</code> function specifier is an <em>inline function</em>. The\n  function specifier may appear more than once; the behavior is the same as if it appeared\n  only once. Making a function an inline function suggests that calls to the function be as\n  fast as possible.<sup>118)</sup> The extent to which such suggestions are effective is\n  implementation-defined.<sup>119)</sup></p>\n<p id=\"so_10259665_10262415_6\">\u00b66 Any function with internal linkage can be an inline function. For a function with external\n  linkage, the following restrictions apply: If a function is declared with an <code>inline</code>\n  function specifier, then it shall also be defined in the same translation unit. If all of the\n  file scope declarations for a function in a translation unit include the <code>inline</code> function\n  specifier without <code>extern</code>, then the definition in that translation unit is an <em>inline\n  definition</em>. An inline definition does not provide an external definition for the function,\n  and does not forbid an external definition in another translation unit. An inline definition\n  provides an alternative to an external definition, which a translator may use to implement\n  any call to the function in the same translation unit. It is unspecified whether a call to the\n  function uses the inline definition or the external definition.120)</p>\n<p id=\"so_10259665_10262415_7\">\u00b67 EXAMPLE The declaration of an inline function with external linkage can result in either an external\n  definition, or a definition available for use only within the translation unit. A file scope declaration with\n  <code>extern</code> creates an external definition. The following example shows an entire translation unit.</p>\n<pre><code>inline double fahr(double t)\n{\n    return (9.0 * t) / 5.0 + 32.0;\n}\ninline double cels(double t)\n{\n    return (5.0 * (t - 32.0)) / 9.0;\n}\nextern double fahr(double); // creates an external definition\ndouble convert(int is_fahr, double temp)\n{\n    /* A translator may perform inline substitutions */\n    return is_fahr ? cels(temp) : fahr(temp);\n}\n</code></pre>\n<p id=\"so_10259665_10262415_8\">\u00b68 Note that the definition of <code>fahr</code> is an external definition because <code>fahr</code> is also declared with extern, but\n  the definition of cels is an inline definition. Because <code>cels</code> has external linkage and is referenced, an\n  external definition has to appear in another translation unit (see 6.9); the inline definition and the external\n  definition are distinct and either may be used for the call.</p>\n<p id=\"so_10259665_10262415_9\"><sup>118)</sup> By using, for example, an alternative to the usual function call mechanism, such as \"inline\n  substitution\". Inline substitution is not textual substitution, nor does it create a new function.\n  Therefore, for example, the expansion of a macro used within the body of the function uses the\n  definition it had at the point the function body appears, and not where the function is called; and\n  identifiers refer to the declarations in scope where the body occurs. Likewise, the function has a\n  single address, regardless of the number of inline definitions that occur in addition to the external\n  definition.</p>\n<p id=\"so_10259665_10262415_10\"><sup>119)</sup> For example, an implementation might never perform inline substitution, or might only perform inline\n  substitutions to calls in the scope of an <code>inline</code> declaration.</p>\n<p id=\"so_10259665_10262415_11\"><sup>120)</sup> Since an inline definition is distinct from the corresponding external definition and from any other\n  corresponding inline definitions in other translation units, all corresponding objects with static storage\n  duration are also distinct in each of the definitions.</p>\n</blockquote>\n<hr>\n<p>Note that GCC also had <code>inline</code> functions in C before they were standardized.  Read the GCC manual for details if you need that notation.</p>\n</hr>", "OwnerUserId": "15168", "PostTypeId": "2", "Id": "10262415", "Score": "1", "CreationDate": "2012-04-21T19:47:56.203", "LastActivityDate": "2012-04-21T19:47:56.203"}});