post_cb({"bq_ids": {"n4140": {"so_19174529_19174627_0": {"length": 27, "quality": 1.0, "section_id": 6107}}, "n3337": {"so_19174529_19174627_0": {"length": 27, "quality": 1.0, "section_id": 5873}}, "n4659": {"so_19174529_19174627_0": {"length": 27, "quality": 1.0, "section_id": 7604}}}, "19174627": {"Id": "19174627", "PostTypeId": "2", "Body": "<p>When you destroy a derived object using a base pointer and the destructor is not virtual you end up in an \"undefined behaviour\" scenario.</p>\n<h2>N3690, 5.3.5 [expr.delete] - 3</h2>\n<blockquote>\n<p id=\"so_19174529_19174627_0\">In the first alternative (delete object), if the static type of the\n  object to be deleted is different from its dynamic type, the static\n  type shall be a base class of the dynamic type of the object to be\n  deleted and the static type shall have a virtual destructor or the\n  behavior is undefined</p>\n</blockquote>\n<p>The explanation give in that github repository is just plain wrong (\"the derived destructor is not called but no memory leak occurs\"). You cannot count on that.</p>\n<p>I didn't read the rest because it would be a waste of time. UB is UB... trying to describe the undefined is nonsense.</p>\n", "LastEditorUserId": "320726", "LastActivityDate": "2013-10-04T06:35:55.093", "Score": "7", "CreationDate": "2013-10-04T06:21:26.997", "ParentId": "19174529", "CommentCount": "3", "OwnerUserId": "320726", "LastEditDate": "2013-10-04T06:35:55.093"}, "19174584": {"Id": "19174584", "PostTypeId": "2", "Body": "<p>When you declare the methods virtual, it means that you are instructing the compiler that it should always search for derived version of the method while working on derived class object. Its as simple as that.<br/>\nIn below example, if you do not use virtual keyword in base class method then base class version of method will be called.</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A\n{\n  public:\n      virtual const char* fetchClassName() { return \"A\"; }\n      // this is a virtual destructor:\n      virtual ~A(){ cout&lt;&lt;\"Destroying Base\";}\n  };\n\nclass B: public A\n{\n  public:\n      virtual const char* fetchClassName() { return \"B\"; }\n      virtual ~B(){ cout&lt;&lt;\"Destroying Derive\";}\n};\n\nint main(void)\n{\n   B obj_b;\n   A &amp;obj_a = obj_b;\n   std::cout &lt;&lt; obj_a.fetchClassName() &lt;&lt; \"\\n\";\n}\n</code></pre>\n", "LastEditorUserId": "2546068", "LastActivityDate": "2013-10-04T06:40:49.687", "Score": "-1", "CreationDate": "2013-10-04T06:19:02.040", "ParentId": "19174529", "CommentCount": "4", "OwnerUserId": "2546068", "LastEditDate": "2013-10-04T06:40:49.687"}, "19174529": {"ViewCount": "177", "Body": "<p>I'm trying to understand destruction behaviour in C++ by following examples from:\n<a href=\"https://github.com/peterdemin/virtual-destruction-5-cents\" rel=\"nofollow noreferrer\">https://github.com/peterdemin/virtual-destruction-5-cents</a></p>\n<p>Does that list fullfills every possible flow?\nWhat should be added?\nHow given examples can be converted into short terms?</p>\n<p><a href=\"https://stackoverflow.com/a/461224/135079\">https://stackoverflow.com/a/461224/135079</a> comes up with \"Always make base classes' destructors virtual when they're meant to be manipulated polymorphically.\" which doesn't cover Scenario 4.</p>\n<p>Item 7 in Scott Meyers' Effective C++ states:</p>\n<ul>\n<li>If a class has any virtual function, it should have a virtual destructor;</li>\n<li>Classes not designed to be base classes or not designed to be used polymorphically should not declare virtual destructors.</li>\n</ul>\n<p>which is light (<em>should</em> and <em>should not</em>) and confronts with Scenario 2.</p>\n<h2>UPDATE</h2>\n<p>I rewritten C++ standard provided by <a href=\"https://stackoverflow.com/a/19174627/135079\">6502</a> as pseudo-code:</p>\n<pre><code>if static type of object is different from its dynamic type:\n    if the static type is a base class of the dynamic type:\n        if the static type has a virtual destructor:\n            We're fine - dynamic type's destructor will be called\n        else:\n            behavior is undefined [1]\n    else:\n        behavior is undefined [2]\n</code></pre>\n<p>[1] Code will compile without warnings and probably will work fine, but it's not guaranteed and may cause entangled error at runtime.</p>\n<p>[2] That's awkward:</p>\n<pre><code>class A {};\nclass B {};\nB *a = (B*)(new A());\ndelete a;\n</code></pre>\n", "AcceptedAnswerId": "19174627", "Title": "C++ virtuality by examples", "CreationDate": "2013-10-04T06:14:49.607", "Id": "19174529", "CommentCount": "2", "LastEditDate": "2017-05-23T11:59:23.257", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-12-15T00:09:48.053", "Score": "1", "OwnerUserId": "135079", "Tags": "<c++><virtual-destructor>", "AnswerCount": "2"}});