post_cb({"2047004": {"Id": "2047004", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_2046952_2047004_0\">As I understand from my reading, undefined-behavior is the result of leaving the compiler with several non-identical alternatives at compile time.</p>\n</blockquote>\n<p>While that may be <em>one</em> source of undefined behavior, you're speaking too abstractly.  You need a specific example of what you mean by \"non-identical alternatives at compile time.\"</p>\n<p>If by \"follow strict coding practice,\" you mean don't use logic that results in undefined behavior, then yes (because there would be no undefined behavior).  Tracking down a bug because of undefined behavior may or may not be easier than tracking one caused by a logic error.</p>\n<p>Note that code which results in \"undefined behavior\" is still legal C++ code.  I consider it a class of code/logic that should only very seldomly be used, when that \"undefined behavior\" is predictable for a given program on a given platform with a given implementation.  You will find cases that what the language considers \"undefined behavior\" will in fact be defined for a particular environment/set of constraints.</p>\n", "OwnerDisplayName": "user123456", "LastActivityDate": "2010-01-12T06:01:37.193", "Score": "1", "CreationDate": "2010-01-12T06:01:37.193", "ParentId": "2046952", "CommentCount": "9"}, "2047172": {"Id": "2047172", "PostTypeId": "2", "Body": "<p>First, some definitions from the C++03 standard:</p>\n<blockquote>\n<p id=\"so_2046952_2047172_0\"><strong>1.3.5 implementation-defined behavior</strong></p>\n<p id=\"so_2046952_2047172_1\">Behavior, for a well-formed program construct and correct data, that depends on the implementation and that each implementation shall document</p>\n<p id=\"so_2046952_2047172_2\"><strong>1.3.12 undefined behavior</strong></p>\n<p id=\"so_2046952_2047172_3\">Behavior, such as might arises upon use of an erroneous program construct or erroneous data, for which this International Standard imposes no requirements.  Undefined behavior may also be expected when this International Standard omits the description of any explicit definition or behavior.</p>\n<p id=\"so_2046952_2047172_4\"><strong>1.3.13 unspecified behavior</strong></p>\n<p id=\"so_2046952_2047172_5\">Behavior, for a well-formed program construct and correct data, that depends on the implementation.  The implementation is not required to document which behavior occurs.</p>\n</blockquote>\n<p>Even though <em>unspecified behavior</em> could be called UB, I've never seen that, and UB always means <em>undefined behavior.</em>  Throughout the standard are statements similar to \"doing X is undefined behavior,\" but sometimes you run into a case that's simply not covered.</p>\n<p>To put the definition another way, if you have any undefined behavior anywhere, then <strong>all bets are off</strong>.  As far as the standard is concerned, your program could do anything from inviting your mother-in-law over for SuperBowl weekend to <a href=\"http://www.feross.org/gcc-ownage/\" rel=\"nofollow noreferrer\" title=\"The blog post is actually about implementation-specified behavior in the compiler, not at runtime, but it's fun. :)\">running nethack</a>.  Due to UB's very nature you can't test for it, and you can't expect any help from the compiler.  (Though for some trivial, common errors compilers do generally produce diagnostics.)</p>\n<p>Usually something is defined as UB because it just doesn't make sense logically (e.g. accessing an array out of bounds), but also often because it would require the implementation to do too much work to prevent\u2014often at runtime.  Remember C++ is derived from C, and being able to produce highly-optimized programs is a major goal of both languages.  To this end, the languages defer to the programmer to make sure the code is correct in these situations, related to the \"you don't pay for what you don't use\" principle.</p>\n<p>So, finally, UB is bad, very bad; avoid it at all costs.  However, the hard part of UB isn't knowing what it is or under what circumstances it occurs; the hard part is recognizing when you invoke UB.  For example:</p>\n<pre><code>std::string s = \"abc\";\nchar&amp; c = s[0];\ncout.write(s.data(), s.length());\nc = '-';\n</code></pre>\n<p>Looks perfectly reasonable, right?  Nope, this is UB, yet <em>it will work as you expect on all the popular implementations.</em></p>\n", "LastEditorDisplayName": "Roger Pate", "OwnerDisplayName": "Roger Pate", "LastActivityDate": "2010-10-06T14:46:58.167", "Score": "7", "CreationDate": "2010-01-12T06:38:00.270", "ParentId": "2046952", "CommentCount": "4", "LastEditDate": "2010-10-06T14:46:58.167"}, "2046985": {"Id": "2046985", "PostTypeId": "2", "Body": "<p>I'm not sure if there's a formal definition of \"undefined behavior\", but following good coding standards can reduce ambiguity and lead to fewer compile and runtime defects.</p>\n<p>However, getting two programmers to agree on what \"good coding standards\" is a complicated and error-prone process.</p>\n<p>To your second question, yes compilers will generally output an error code that you can use to fix the problem</p>\n", "LastActivityDate": "2010-01-12T05:58:41.770", "CommentCount": "5", "CreationDate": "2010-01-12T05:58:41.770", "ParentId": "2046952", "Score": "1", "OwnerUserId": "244002"}, "bq_ids": {"n4140": {"so_2046952_2047172_1": {"length": 9, "quality": 0.9, "section_id": 5768}, "so_2046952_2047172_5": {"length": 11, "quality": 0.8461538461538461, "section_id": 5768}, "so_2046952_2047172_3": {"length": 15, "quality": 0.5555555555555556, "section_id": 5768}}, "n3337": {"so_2046952_2047172_1": {"length": 9, "quality": 0.9, "section_id": 5541}, "so_2046952_2047172_5": {"length": 11, "quality": 0.8461538461538461, "section_id": 5541}, "so_2046952_2047172_3": {"length": 15, "quality": 0.5555555555555556, "section_id": 5541}}, "n4659": {"so_2046952_2047172_1": {"length": 9, "quality": 0.9, "section_id": 7225}, "so_2046952_2047172_5": {"length": 11, "quality": 0.8461538461538461, "section_id": 7225}, "so_2046952_2047172_3": {"length": 15, "quality": 0.5555555555555556, "section_id": 7225}}}, "2046952": {"ViewCount": "496", "Body": "<p>As I understand from my reading, undefined-behavior is the result of leaving the compiler with several non-identical alternatives at compile time.  However, wouldn't that mean that if one were to follow strict coding practice (like putting each assignment and each equality in a separate statement, proper debugging and commenting) then it shouldn't pose a significant problem in finding the source of the undefined-behavior.</p>\n<p>Further, there are, for each error that comes up, if you identify the code, you should know what statements can be used in that particular statement's stead, correct?</p>\n<p>EDIT:  I'm not interested in places where you have written code that you didn't mean to write.  I'm interested in examples where code that is sound by mathematical logic fails to work.</p>\n<p>Also, I consider 'good coding practice' to be strong informative comments every few lines, proper indentation, and debugging dumps on a regular basis.</p>\n", "AcceptedAnswerId": "2046986", "Title": "Limit the confusion caused by undefined-behavior?", "CreationDate": "2010-01-12T05:49:09.553", "Id": "2046952", "CommentCount": "9", "LastEditDate": "2010-01-12T06:14:38.317", "PostTypeId": "1", "LastEditorUserId": "239333", "LastActivityDate": "2010-10-06T14:46:58.167", "Score": "5", "OwnerUserId": "239333", "Tags": "<c++><language-agnostic><undefined-behavior>", "AnswerCount": "4"}, "2046986": {"Id": "2046986", "PostTypeId": "2", "Body": "<p>Undefined behavior isn't necessarily leaving the compiler with multiple alternatives. Most commonly it is simply doing something that doesn't make sense.</p>\n<p>For example, take this code:</p>\n<pre><code>int arr[2];\narr[200] = 42;\n</code></pre>\n<p>this is undefined behavior. It's not that the compiler was given multiple alternatives to choose from. it's just that what I'm doing does not make sense. Ideally, it should not be allowed in the first place, but without potentially expensive runtime checking, we can't guarantee that something like this won't occur in our code. So in C++, the rule is simply that the language specifies only the behavior of a program that sticks to the rules. If it does something erroneous like in the above example, it is simply <em>undefined</em> what should happen.</p>\n<p>Now, imagine how you're going to detect this error. How is it going to surface? It might <em>never</em> seem to cause any problems. Perhaps we just so happen to write into memory that's mapped to the process (so we don't get an access violation), but is never otherwise used (so no other part of the program will read our garbage value, or overwrite what we wrote). Then it'll seem like the program is bug-free and works just fine.</p>\n<p>Or it might hit an address that's not even mapped to our process. Then the program will crash immediately. </p>\n<p>Or it might hit an address that's mapped to our process, but <em>at some point later</em> will be used for something. Then all we know is that sooner or later, the function reading from that address will get an unexpected value, and it'll behave weird. That part is easy to spot in the debugger, but it doesn't tell us anything about <em>when</em> or from <em>where</em> that garbage value was written. So there's no simple way to trace the error back to its source.</p>\n", "LastActivityDate": "2010-01-12T05:58:44.717", "CommentCount": "18", "CreationDate": "2010-01-12T05:58:44.717", "ParentId": "2046952", "Score": "10", "OwnerUserId": "33213"}});