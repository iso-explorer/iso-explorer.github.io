post_cb({"bq_ids": {"n4140": {"so_32433554_32433916_0": {"length": 19, "quality": 0.6785714285714286, "section_id": 5908}, "so_32433554_32433923_0": {"length": 51, "quality": 0.9622641509433962, "section_id": 5908}}, "n3337": {"so_32433554_32433916_0": {"length": 19, "quality": 0.6785714285714286, "section_id": 5680}, "so_32433554_32433923_0": {"length": 51, "quality": 0.9622641509433962, "section_id": 5680}}, "n4659": {"so_32433554_32433916_0": {"length": 16, "quality": 0.5714285714285714, "section_id": 7390}, "so_32433554_32433923_0": {"length": 31, "quality": 0.5849056603773585, "section_id": 7390}}}, "32433923": {"Id": "32433923", "PostTypeId": "2", "Body": "<p>Initializers in C++ were meant to be part of a definition, not of a declaration. This was relaxed for <code>const</code> integral and <code>enum</code> types. In C++11 further directives were added for <code>constexpr</code> members of <strong>literal type</strong></p>\n<p><em>[class.static.data]/p3</em></p>\n<blockquote>\n<p id=\"so_32433554_32433923_0\">If a non-volatile const static data member is of integral or enumeration type, its declaration in the class\n  definition can specify a brace-or-equal-initializer in which every initializer-clause that is an assignment-expression\n  is a constant expression (5.20). A static data member of literal type can be declared in the\n  class definition with the constexpr specifier; if so, its declaration shall specify a brace-or-equal-initializer\n  in which every initializer-clause that is an assignment-expression is a constant expression. [ ... ] The member shall still be defined\n  in a namespace scope if it is odr-used (3.2) in the program and the namespace scope definition shall not\n  contain an initializer</p>\n</blockquote>\n<p>Since it doesn't apply to your case, you should thus initialize your static variable out-of-line <a href=\"http://coliru.stacked-crooked.com/a/a84a2601f1b33aa1\" rel=\"noreferrer\">as shown in this example</a></p>\n<pre><code>class POI {\npublic:\n  static const std::set&lt;std::string&gt; TYPES;\n};\n\nconst std::set&lt;std::string&gt; POI::TYPES = {\n   \"restaurant\", \"education\", \"financial\", \"health\", \"culture\", \"other\" \n};\n</code></pre>\n", "LastEditorUserId": "1938163", "LastActivityDate": "2015-09-07T08:20:14.600", "Score": "6", "CreationDate": "2015-09-07T08:10:27.627", "ParentId": "32433554", "CommentCount": "2", "OwnerUserId": "1938163", "LastEditDate": "2015-09-07T08:20:14.600"}, "32433916": {"Id": "32433916", "PostTypeId": "2", "Body": "<p>You must initialize your static variable out-of-line, as in:</p>\n<pre><code>#include &lt;set&gt;\n#include &lt;string&gt;\n\nclass POI {\npublic:\n  static const std::set&lt;std::string&gt; TYPES;\n};\nconst std::set&lt;std::string&gt; POI::TYPES { \"restaurant\", \"education\", \"financial\", \"health\", \"culture\", \"other\" };\n</code></pre>\n<p>This would work for an integral / enum type, as specified by the standard (section 9.4.2:)</p>\n<blockquote>\n<p id=\"so_32433554_32433916_0\">If a static data member is of const integral or const enumeration type, its declaration in the class definition can specify a constant-initializer which shall be an integral constant expression. In that case, the member can appear in integral constant expressions within its scope.</p>\n</blockquote>\n", "LastActivityDate": "2015-09-07T08:10:03.303", "CommentCount": "0", "CreationDate": "2015-09-07T08:10:03.303", "ParentId": "32433554", "Score": "8", "OwnerUserId": "5272893"}, "32433554": {"ViewCount": "2728", "Body": "<p>I'm trying to instantiate a set of strings like this:</p>\n<pre><code>class POI {\npublic:\n...\n  static const std::set&lt;std::string&gt; TYPES { \"restaurant\", \"education\", \"financial\", \"health\", \"culture\", \"other\" };\n...\n}\n</code></pre>\n<p>Now, when I do this I get these errors (all on this line):</p>\n<pre><code>error: field initializer is not constant\n static const std::set&lt;std::string&gt; TYPES { \"restaurant\", \"education\", \"financial\", \"health\", \"culture\", \"other\" };\nerror: in-class initialization of static data member 'const std::set&lt;std::basic_string&lt;char&gt; &gt; POI::TYPES' of non-literal type\nerror: non-constant in-class initialization invalid for static member 'POI::TYPES'                                                              \nerror: (an out of class initialization is required)\nerror: 'POI::TYPES' cannot be initialized by a non-constant expression when being declared\n</code></pre>\n<p>That would make sense to my eyes if I assumed that the strings inside the set are not treated as being const. Is that really the problem here? Unfortunately, I cannot find  a way of declaring those strings inside the initializer as const.. Is that possible?</p>\n", "AcceptedAnswerId": "32433916", "Title": "C++11 uniform initialization: Field initializer is not constant", "CreationDate": "2015-09-07T07:47:09.583", "Id": "32433554", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-09-07T07:50:23.470", "LastEditorUserId": "4694124", "LastActivityDate": "2015-09-07T08:20:14.600", "Score": "4", "OwnerUserId": "4694124", "Tags": "<c++><c++11><uniform-initialization>", "AnswerCount": "2"}});