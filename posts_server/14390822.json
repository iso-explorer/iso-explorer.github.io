post_cb({"bq_ids": {"n4140": {"so_14390822_14390961_0": {"length": 25, "quality": 0.8064516129032258, "section_id": 3228}}, "n3337": {"so_14390822_14390961_0": {"length": 26, "quality": 0.8387096774193549, "section_id": 3101}}, "n4659": {"so_14390822_14390961_0": {"length": 25, "quality": 0.8064516129032258, "section_id": 3985}}}, "14390822": {"ViewCount": "6228", "Body": "<p>I was trying to write a templated base class to store a fixed number of data types, each with varying length. Here is a simplified version of much what I was trying to do:</p>\n<pre><code>template&lt; int NINT, int NR0 &gt;\nclass EncapsulatedObjectBase\n{\n   public:\n\n  EncapsulatedObjectBase();\n\n  ~EncapsulatedObjectBase();\n\n  double m_real[NR0];\n  int m_int[NINT];\n}\n</code></pre>\n<p>Yeah...so the template parameters can be zero, thus declaring a zero-length array of objects. There will be multiple derived classes for this base, each defining their own number of variables. I have two questions:</p>\n<p>1) Is this approach fundamentally flawed?</p>\n<p>2) If so...why doesn't icc13 or gcc4.7.2 give me warnings about this when I instantiate a zero-length array? For gcc I use -wall and -wextra -wabi. The lack of warnings made me think that this sort of thing was OK.</p>\n<p>EDIT:</p>\n<p>Here is the contents of a file that show what I am talking about:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt; int NINT, int NR0 &gt;\nclass EncapsulatedObjectBase\n{\npublic:\n  EncapsulatedObjectBase(){}\n  ~EncapsulatedObjectBase(){}\n\n  double m_real[NR0];\n  int m_int[NINT];\n};\n\n\nclass DerivedDataObject1 : public EncapsulatedObjectBase&lt;2,0&gt;\n{\n   public:\n\n   DerivedDataObject1(){}\n\n  ~DerivedDataObject1(){}\n\n  inline int&amp; intvar1() { return this-&gt;m_int[0]; }\n  inline int&amp; intvar2() { return this-&gt;m_int[1]; }\n\n};\n\n\nclass DerivedDataObject2 : public EncapsulatedObjectBase&lt;0,2&gt;\n{\n   public:\n\n   DerivedDataObject2(){}\n\n  ~DerivedDataObject2(){}\n\n  inline double&amp; realvar1() { return this-&gt;m_real[0]; }\n  inline double&amp; realvar2() { return this-&gt;m_real[1]; }\n};\n\n\n\n\nint main()\n{\n   DerivedDataObject1 obj1;\n   DerivedDataObject2 obj2;\n\n   obj1.intvar1() = 12;\n   obj1.intvar2() = 5;\n\n   obj2.realvar1() = 1.0e5;\n   obj2.realvar2() = 1.0e6;\n\n   std::cout&lt;&lt;\"obj1.intvar1()  = \"&lt;&lt;obj1.intvar1()&lt;&lt;std::endl;\n   std::cout&lt;&lt;\"obj1.intvar2()  = \"&lt;&lt;obj1.intvar2()&lt;&lt;std::endl;\n   std::cout&lt;&lt;\"obj2.realvar1() = \"&lt;&lt;obj2.realvar1()&lt;&lt;std::endl;\n   std::cout&lt;&lt;\"obj2.realvar2() = \"&lt;&lt;obj2.realvar2()&lt;&lt;std::endl;\n\n\n}\n</code></pre>\n<p>If I compile this with \"g++ -Wall -Wextra -Wabi main.cpp\" I get no warnings. I have to use the -pedantic flag to get warnings. So I still don't know how unsafe this is. In retrospect, I feel as though it must not be a very good idea...although it would be pretty useful if I could get away with it.</p>\n", "AcceptedAnswerId": "14390961", "Title": "Member array with size defined by template parameter, but why no warning for zero-size array?", "CreationDate": "2013-01-18T00:52:08.140", "Id": "14390822", "CommentCount": "7", "LastEditDate": "2013-01-18T01:43:35.050", "PostTypeId": "1", "LastEditorUserId": "1695375", "LastActivityDate": "2013-01-18T04:24:58.470", "Score": "4", "OwnerUserId": "1695375", "Tags": "<c++><arrays><templates>", "AnswerCount": "3"}, "14391592": {"Id": "14391592", "PostTypeId": "2", "Body": "<p>1) Add to declaration of your class <strong>C++11 static_assert</strong> or <strong>BOOST_STATIC_ASSERT</strong> and you will have <strong>compile-time</strong> diagnostic for zero length array:</p>\n<pre><code>....\n   BOOST_STATIC_ASSERT(NR0 &gt; 0);\n   BOOST_STATIC_ASSERT(NINT &gt; 0);\n   double m_real[NR0];\n   int m_int[NINT];\n};\n</code></pre>\n<p>2) Use <strong>std::array</strong> or <strong>boost::array</strong> and you will have run-time diagnostic (in debug mode) for index overflow problem in such code:</p>\n<pre><code>   BOOST_STATIC_ASSERT(NR0 &gt; 0);\n   BOOST_STATIC_ASSERT(NINT &gt; 0);\n   boost::array&lt;double, NR&gt; m_real;   //double m_real[NR0];\n   boost::array&lt;int, NINT&gt; m_int;     //int m_int[NINT];\n};\n</code></pre>\n<p>Remark:\n<em>class <strong>boost::array</strong> has specialisation for zero-size array</em> </p>\n<p>3) Use <strong>size_t</strong> but not int for size of array.</p>\n<p>Your design is quite dangerous:</p>\n<pre><code>   DerivedDataObject1 a;\n   a.m_real[2] = 1;   // size of m_real == 0 !!!\n</code></pre>\n<p>I think it will better to change design of your class EncapsulatedObjectBase. May be it will better to use:</p>\n<pre><code>   template&lt;typename T, size_t N&gt; class EncapsulatedObjectBase\n   {\n    ....\n   };\n   class DerivedDataObject1 : public EncapsulatedObjectBase&lt;int,2&gt;\n   {\n     ....\n   };\n   class DerivedDataObject2 : public EncapsulatedObjectBase&lt;double,2&gt;\n   {\n     ....\n   };\n   class DerivedDataObject3 : public EncapsulatedObjectBase&lt;double,2&gt;\n                            , public EncapsulatedObjectBase&lt;int,2&gt;\n   {\n     ....\n   };\n</code></pre>\n", "LastEditorUserId": "1570382", "LastActivityDate": "2013-01-18T04:24:58.470", "Score": "1", "CreationDate": "2013-01-18T02:39:11.690", "ParentId": "14390822", "CommentCount": "7", "OwnerUserId": "1570382", "LastEditDate": "2013-01-18T04:24:58.470"}, "14390961": {"Id": "14390961", "PostTypeId": "2", "Body": "<p>Zero-sized arrays are actually illegal in C++:</p>\n<blockquote>\n<p id=\"so_14390822_14390961_0\"><code>[C++11: 8.3.4/1]:</code> <em>[..]</em> If the <em>constant-expression</em> (5.19) is present, <strong>it shall be an integral constant expression and its value shall be greater than zero</strong>. The constant expression specifies the bound of (number of elements in) the array. If the value of the constant expression is <code>N</code>, the array has <code>N</code> elements numbered <code>0</code> to <code>N-1</code>, and the type of the identifier of <code>D</code> is \u201c<em>derived-declarator-type-list</em> array of <code>N</code> T\u201d. <em>[..]</em></p>\n</blockquote>\n<p>For this reason, your class template <em>cannot</em> be instantiated with arguments <code>0,0</code> <a href=\"http://codepad.org/ZqlBniEl\" rel=\"nofollow\">in GCC 4.1.2</a> nor <a href=\"http://liveworkspace.org/code/3snWgY%240\" rel=\"nofollow\">in GCC 4.7.2</a> with reasonable flags:</p>\n<pre><code>template&lt; int NINT, int NR0 &gt;\nclass EncapsulatedObjectBase\n{\n   public:\n\n  EncapsulatedObjectBase();\n\n  ~EncapsulatedObjectBase();\n\n  double m_real[NR0];\n  int m_int[NINT];\n};\n\nint main()\n{\n   EncapsulatedObjectBase&lt;0,0&gt; obj;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_14390822_14390961_1\">t.cpp: In instantiation of 'EncapsulatedObjectBase&lt;0, 0&gt;': <br/>\n  t.cpp:17:   instantiated from here<br/>\n  Line 10: error: ISO C++ forbids zero-size array<br/>\n  compilation terminated due to -Wfatal-errors.</p>\n</blockquote>\n<p>clang 3.2 says:</p>\n<blockquote>\n<p id=\"so_14390822_14390961_2\">source.cpp:10:17: warning: zero size arrays are an extension [-Wzero-length-array]</p>\n</blockquote>\n<p>(Note that, in any case, you won't get any error until you do try to instantiate such a class.)</p>\n<p>So, is it a good idea? No, not really. I'd recommend prohibiting instantiation for your class template when either argument is <code>0</code>. I'd also look at why you want to have zero-length arrays and consider adjusting your design.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2013-01-18T01:14:51.113", "Score": "0", "CreationDate": "2013-01-18T01:09:33.840", "ParentId": "14390822", "CommentCount": "5", "OwnerUserId": "560648", "LastEditDate": "2013-01-18T01:14:51.113"}, "14390862": {"Id": "14390862", "PostTypeId": "2", "Body": "<p>In C using a zero-sized array as the last member of a struct is actually legal and is commonly used when the struct is going to end up with some sort of dynamically-created inline data that's not known at compile-time. In other words, I might have something like</p>\n<pre><code>struct MyData {\n    size_t size;\n    char data[0];\n};\n\nstruct MyData *newData(size_t size) {\n    struct MyData *myData = (struct MyData *)malloc(sizeof(struct MyData) + size);\n    myData-&gt;size = size;\n    bzero(myData-&gt;data, size);\n    return myData;\n}\n</code></pre>\n<p>and now the <code>myData-&gt;data</code> field can be accessed as a pointer to the dynamically-sized data</p>\n<p>That said, I don't know how applicable this technique is to C++. But it's probably fine as long as you never subclass your class.</p>\n", "LastEditorUserId": "582", "LastActivityDate": "2013-01-18T01:04:45.313", "Score": "3", "CreationDate": "2013-01-18T00:55:55.777", "ParentId": "14390822", "CommentCount": "25", "OwnerUserId": "582", "LastEditDate": "2013-01-18T01:04:45.313"}});