post_cb({"26188323": {"ParentId": "26188281", "LastEditDate": "2017-05-23T12:26:10.720", "CommentCount": "5", "CreationDate": "2014-10-04T00:04:08.093", "OwnerUserId": "2756719", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "26188323", "Score": "8", "Body": "<p>The detailed conversion rules for the conditional operator are rather complex (you can find the full quote from the standard in <a href=\"https://stackoverflow.com/questions/24706480/why-does-stdistringstream-appear-to-resolve-differently-to-stdifstream-in-th/24706610#24706610\">this answer</a> if you are interested). The short of it is that, when used with objects of class type, it will attempt to convert its second operand to match the type of the third, and its third operand to match the type of the second, but it won't try to convert both to a third class type.</p>\n<p>Since <code>Circle</code> isn't convertible to <code>Rectangle</code> and <code>Rectangle</code> isn't convertible to <code>Circle</code>, the compiler will complain (well, unless the two types define some odd conversion to pointer, scoped enumeration or arithmetic types, in which case \u00a75.16 [expr.cond]/p5 comes into play).</p>\n<p>Note also that your assignment will slice the object, which <a href=\"https://stackoverflow.com/questions/274626/what-is-the-slicing-problem-in-c\">probably isn't a good idea</a>.</p>\n", "LastActivityDate": "2014-10-04T00:23:21.620"}, "26188281": {"CommentCount": "4", "ViewCount": "1860", "PostTypeId": "1", "LastEditorUserId": "3284878", "CreationDate": "2014-10-03T23:56:46.477", "LastActivityDate": "2014-10-04T00:23:21.620", "Title": "Why can't I use the ternary operator here?", "LastEditDate": "2014-10-04T00:03:58.093", "Id": "26188281", "Score": "2", "Body": "<p>This line won't compile:</p>\n<pre><code>Shape shape = (i % 2) ? Circle(5) : Rectangle(5, 5);\n</code></pre>\n<p>(I know it's useless since whatever the expression returns will be reduced to a simple <code>Shape</code>, that's not the point).</p>\n<p>Can't figure out why it won't compile. I'm creating a <code>Shape</code> variable named <code>shape</code> (which I think at this point creates a new <code>Shape</code>), and then I'm assigning this variable the result of an expression. Why doesn't this compile?</p>\n<p>The error:</p>\n<pre><code>no match for ternary operator\n</code></pre>\n<p>What's really weird is that the longer code with exact same meaning <em>does</em> compile and run as expected:</p>\n<pre><code>    Shape shape;\n    if (i % 2)\n        shape = Rectangle(5, 5);\n    else\n        shape = Circle(5);\n</code></pre>\n", "Tags": "<c++><variables><expression><variable-assignment>", "OwnerUserId": "3284878", "AnswerCount": "3"}, "26188341": {"ParentId": "26188281", "CommentCount": "0", "Body": "<p>When type types of the two branches in the conditional operator differ, one needs to be convertible to the other according to 5.16 [expr.cond] paragraph 16:</p>\n<blockquote>\n<p id=\"so_26188281_26188341_0\">Otherwise, if the second and third operand have different types and either has (possibly cv-qualified) class type, or if both are glvalues of the same value category and the same type except for cv-qualification, an attempt is made to convert each of those operands to the type of the other. ...</p>\n</blockquote>\n<p>The other cases referred to don't apply: they are about the types being <code>void</code> or one branch being a <code>throw</code> expression. The omission simply explains how the conversions are attempted and in which cases the conversion is chosen (essentially, if the type of one expression uniquely converts to the other but not the other way around).</p>\n<p>Assuming your <code>Circle</code> or your <code>Rectangle</code> are convertible to <code>Shape</code> you can explicitly convert one or both expressions to <code>Shape</code>.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "26188341", "Score": "2", "CreationDate": "2014-10-04T00:07:00.417", "LastActivityDate": "2014-10-04T00:07:00.417"}, "bq_ids": {"n4140": {"so_26188281_26188341_0": {"section_id": 6169, "quality": 1.0, "length": 29}}, "n3337": {"so_26188281_26188341_0": {"section_id": 5930, "quality": 1.0, "length": 29}}, "n4659": {"so_26188281_26188341_0": {"section_id": 7667, "quality": 0.9655172413793104, "length": 28}}}, "26188321": {"ParentId": "26188281", "CommentCount": "2", "Body": "<p>The second and third operand of the conditional operator have to have a <em>common type</em>, as can be determined with the <code>std::common_type</code> trait. Interestingly perhaps, two classes derived from a common base class do <em>not</em> have that base class as a common type, nor are pointers or references thus related. Further thought quickly shows that indeed such a notion doesn't make sense: two classes can have any number of base classes in common, and there is no way in general to select a unique, preferred base.</p>\n<p>If you want to use derived classes in the conditional operator, you have to cast the types yourself, explicitly.</p>\n<p>A more realistic and sensible example of your code would be something like this:</p>\n<pre><code>Shape const &amp; s = ask_user() ? static_cast&lt;Shape const &amp;&gt;(show_me_a_circle())\n                             : static_cast&lt;Shape const &amp;&gt;(squares_all_the_way());\n\nstd::cout &lt;&lt; \"Your shape is \" &lt;&lt; s.get_colour() &lt;&lt; \".\\n\";\n</code></pre>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "26188321", "Score": "3", "CreationDate": "2014-10-04T00:03:36.047", "LastActivityDate": "2014-10-04T00:03:36.047"}});