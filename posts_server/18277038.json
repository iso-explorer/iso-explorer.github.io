post_cb({"bq_ids": {"n4140": {"so_18277038_18277402_1": {"length": 19, "quality": 0.95, "section_id": 742}}, "n3337": {"so_18277038_18277402_1": {"length": 19, "quality": 0.95, "section_id": 731}}, "n4659": {"so_18277038_18277402_1": {"length": 19, "quality": 0.95, "section_id": 800}}}, "18277038": {"ViewCount": "789", "Body": "<p>I have a set of sets of ints called nets which I'm trying to iterate through to determine if either of the ints to or from have been added to an existing set; if so, I add them to the existing set (this is to keep track of all combinations of shorts on an electrical network).</p>\n<p>However, I CANNOT get the set::insert function to work! I'm able to use (*it).count just fine to determine if either int has already been added to a set, but (*it).insert doesn't work (I always receive the error No matching member function call to 'insert'). However, if I just create a set of ints, setName.insert(to) works fine.</p>\n<p>What's wrong with my code?</p>\n<pre><code>for (std::set&lt;std::set&lt;int&gt;&gt;::iterator it=nets.begin(); it!=nets.end(); ++it) {  \n    if ((*it).count(to) || (*it).count(from)) {\n        currentSet = (*it);\n        (*it).insert(to);\n        (*it).insert(from);\n        addedToExistingSet = true;    \n    }\n}\n</code></pre>\n", "AcceptedAnswerId": "18277402", "Title": "C++: set::insert with iterators and sets of sets", "CreationDate": "2013-08-16T15:32:24.527", "Id": "18277038", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-08-16T15:57:43.803", "Score": "0", "OwnerUserId": "2689932", "Tags": "<c++><containers>", "AnswerCount": "2"}, "18277402": {"Id": "18277402", "PostTypeId": "2", "Body": "<p>As a <code>std::set</code> is an <strong>associative container</strong> that contains a sorted set of unique objects of type <code>T</code>, you cannot modify an object inside it because you would invalidate the <code>set</code>.</p>\n<p>If it was allowed, you'd be allowed to change the items value out from under the container, potentially altering the ordering.</p>\n<p>The standard says :</p>\n<blockquote>\n<p id=\"so_18277038_18277402_0\"><strong>23.2.4 Associative containers [associative.reqmts]</strong></p>\n<p id=\"so_18277038_18277402_1\"><code>iterator</code> of an associative container is of the bidirectional iterator category. <strong>For <em>associative containers</em> where the value type is the same as the key type, both <code>iterator</code> and <code>const_iterator</code> are constant iterators</strong>.</p>\n</blockquote>\n<p>You should consider using another container for the outer one like <code>std::vector</code>.</p>\n", "LastEditorUserId": "1394283", "LastActivityDate": "2013-08-16T15:57:43.803", "Score": "2", "CreationDate": "2013-08-16T15:51:51.997", "ParentId": "18277038", "CommentCount": "0", "OwnerUserId": "1394283", "LastEditDate": "2013-08-16T15:57:43.803"}, "18277266": {"Id": "18277266", "PostTypeId": "2", "Body": "<p>The problem here is that you are trying to modify an object inside a set, which isn't a valid operation as you would invalidate the set.  Is there a reason you need the outer container to be a set?  Could it be a <code>std::vector</code> for example?</p>\n", "LastActivityDate": "2013-08-16T15:43:35.727", "CommentCount": "0", "CreationDate": "2013-08-16T15:43:35.727", "ParentId": "18277038", "Score": "0", "OwnerUserId": "2634887"}});