post_cb({"34613124": {"ParentId": "34611181", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, of course, you have!</p>\n<p><strong>[basic.types] 3.9\\4</strong></p>\n<blockquote>\n<p id=\"so_34611181_34613124_0\">The <em>value representation</em> of an object is the <strong>set of bits</strong> that hold\n  the value of type T.</p>\n</blockquote>\n<p><strong>[basic.fundamental] 3.9.1\\3</strong></p>\n<blockquote>\n<p id=\"so_34611181_34613124_1\">The range of non-negative values of a <em>signed integer</em> type is a\n  subrange of the corresponding <em>unsigned integer</em> type, and the <strong>value\n  representation of each corresponding signed/unsigned type shall be the\n  same</strong>.</p>\n</blockquote>\n<p><strong>[basic.fundamental] 3.9.1\\7</strong></p>\n<blockquote>\n<p id=\"so_34611181_34613124_2\">The representations of integral types shall define values by use of a\n  pure binary numeration system.<sup>50</sup></p>\n<p id=\"so_34611181_34613124_3\"><sup>50)</sup> A positional representation for integers that uses the\n  binary digits 0 and 1, in which the values represented by successive\n  bits are additive, begin with 1, and are multiplied by successive\n  integral power of 2, <strong>except perhaps for the bit with the highest\n  position</strong>. (Adapted from the <em>American National Dictionary for\n  Information Processing Systems</em>.)</p>\n</blockquote>\n<p>But it depends on what are non-sign bits:</p>\n<p><strong>[numeric.limits.members] 18.3.2.4\\9</strong></p>\n<blockquote>\n<p id=\"so_34611181_34613124_4\">For integer types, the number of <strong>non-sign bits</strong> in the representation.</p>\n</blockquote>\n<p>If they implied, that the sign bit must be <strong>only</strong> in the so called <a href=\"https://en.wikipedia.org/wiki/Signed_number_representations#Sign-and-magnitude_method\" rel=\"nofollow\">sign-and-magnitude representation</a>, then you would have these expressions evaluated as <code>true</code>:</p>\n<ul>\n<li><code>bit_count_2&lt;T&gt;{} &gt; bit_count_1&lt;T&gt;{}</code>, and </li>\n<li><code>bit_count_2&lt;T&gt;{} &gt; bit_count_3&lt;T&gt;{}</code>,</li>\n</ul>\n<p>for the signed integer type T represented in the two's or one's complement.\n So, I'd put a <code>static_assert</code> anyway, you know...</p>\n", "OwnerUserId": "5181494", "LastEditorUserId": "5181494", "LastEditDate": "2016-01-05T15:41:09.020", "Id": "34613124", "Score": "2", "CreationDate": "2016-01-05T13:40:28.923", "LastActivityDate": "2016-01-05T15:41:09.020"}, "34611181": {"CommentCount": "2", "ViewCount": "128", "PostTypeId": "1", "LastEditorUserId": "882932", "CreationDate": "2016-01-05T11:57:41.810", "LastActivityDate": "2016-01-05T15:41:09.020", "Title": "Number of value representation bits in a integer, according to the standard?", "AcceptedAnswerId": "34613124", "LastEditDate": "2016-01-05T12:56:22.017", "Id": "34611181", "Score": "5", "Body": "<p>Consider the following helper structs:</p>\n<pre><code>template &lt;class T&gt;\nstruct bit_count_1:\nstd::integral_constant&lt;\n    std::size_t,\n    std::numeric_limits&lt;typename std::make_unsigned&lt;T&gt;::type&gt;::digits\n&gt; {};\n\ntemplate &lt;class T&gt;\nstruct bit_count_2:\nstd::integral_constant&lt;\n    std::size_t,\n    std::numeric_limits&lt;T&gt;::digits + std::is_signed&lt;T&gt;::value\n&gt; {};\n\ntemplate &lt;class T&gt;\nconstexpr std::size_t compute_bit_count() {\n    using type = typename std::make_unsigned&lt;T&gt;::type;\n    constexpr type zero = 0;\n    constexpr type one = 1;\n    constexpr type max = ~zero;\n    type current = max;\n    std::size_t i = 0; \n    while (current) {\n        current &gt;&gt;= one;\n        ++i;\n    }\n    return i;\n}\n\ntemplate &lt;class T&gt;\nstruct bit_count_3:\nstd::integral_constant&lt;\n    std::size_t,\n    compute_bit_count&lt;T&gt;()\n&gt; {};\n</code></pre>\n<p>For every integral type <code>T</code> such that <code>std::is_integral&lt;T&gt;::value</code> is <code>true</code> except <code>bool</code> do I have the guarantee, by the standard, that:</p>\n<ul>\n<li><code>bit_count_1</code>, <code>bit_count_2</code> and <code>bit_count_3</code> have the same value <code>N</code></li>\n<li><code>T x = 1; x &lt;&lt;= (N - 1)</code> is well defined</li>\n<li><code>T x = ~static_cast&lt;T&gt;(0); x &gt;&gt;= (N - 1)</code> is well defined</li>\n</ul>\n<p>I am currently working on a C++ proposal, so I need to be sure whether this is true according to the standard, or not, and for the moment it's a little unclear for me.</p>\n", "Tags": "<c++><standards><language-lawyer><c++14><bit>", "OwnerUserId": "882932", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_34611181_34613124_2": {"section_id": 7216, "quality": 0.8181818181818182, "length": 9}, "so_34611181_34613124_1": {"section_id": 7212, "quality": 0.8421052631578947, "length": 16}, "so_34611181_34613124_3": {"section_id": 7216, "quality": 0.9642857142857143, "length": 27}, "so_34611181_34613124_4": {"section_id": 6727, "quality": 0.8571428571428571, "length": 6}, "so_34611181_34613124_0": {"section_id": 7202, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_34611181_34613124_2": {"section_id": 6960, "quality": 0.8181818181818182, "length": 9}, "so_34611181_34613124_1": {"section_id": 6956, "quality": 0.8421052631578947, "length": 16}, "so_34611181_34613124_3": {"section_id": 6960, "quality": 0.9642857142857143, "length": 27}, "so_34611181_34613124_4": {"section_id": 6482, "quality": 0.8571428571428571, "length": 6}, "so_34611181_34613124_0": {"section_id": 6946, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_34611181_34613124_2": {"section_id": 8725, "quality": 0.8181818181818182, "length": 9}, "so_34611181_34613124_1": {"section_id": 8721, "quality": 0.9473684210526315, "length": 18}, "so_34611181_34613124_3": {"section_id": 8725, "quality": 0.9642857142857143, "length": 27}, "so_34611181_34613124_0": {"section_id": 8711, "quality": 0.7777777777777778, "length": 7}, "so_34611181_34613124_4": {"section_id": 8221, "quality": 0.8571428571428571, "length": 6}}}});