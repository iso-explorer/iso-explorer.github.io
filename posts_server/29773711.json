post_cb({"bq_ids": {"n4140": {"so_29773711_29773975_0": {"length": 13, "quality": 0.5416666666666666, "section_id": 38}}, "n3337": {"so_29773711_29773975_0": {"length": 13, "quality": 0.5416666666666666, "section_id": 35}}, "n4659": {"so_29773711_29773975_0": {"length": 14, "quality": 0.5833333333333334, "section_id": 38}}}, "29773834": {"Id": "29773834", "PostTypeId": "2", "Body": "<p>Because there is no exact match in either case. 5, without qualification, has type int. Your methods declare \"float\" or \"long int\" as argument, and <em>both</em> require conversion. long != int!</p>\n", "LastActivityDate": "2015-04-21T13:37:48.480", "Score": "0", "CreationDate": "2015-04-21T13:37:48.480", "ParentId": "29773711", "CommentCount": "0", "OwnerUserId": "4472848"}, "29773824": {"Id": "29773824", "PostTypeId": "2", "Body": "<p><code>int</code> to <code>long</code> is a conversion. <code>short</code> to <code>int</code> is a promotion. (See [conv.prom] for the full list of integral promotions.)</p>\n<p>Similarly, <code>float</code> to <code>double</code> is the floating point promotion. <code>double</code> to <code>long double</code> is a conversion.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2015-04-21T13:42:19.133", "Score": "8", "CreationDate": "2015-04-21T13:37:02.613", "ParentId": "29773711", "CommentCount": "0", "LastEditDate": "2015-04-21T13:42:19.133", "OwnerUserId": "2756719"}, "29773975": {"Id": "29773975", "PostTypeId": "2", "Body": "<p><code>5</code> is by default of type <code>int</code>. So you have conversions in both cases:</p>\n<ul>\n<li><code>int</code> to <code>long int</code> (aka <code>long</code>)</li>\n<li><code>int</code> to <code>float</code></li>\n</ul>\n<p><strong>1)</strong> <code>long</code> is not compatible with <code>int</code>, because on <a href=\"http://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models\" rel=\"nofollow\">certain data models</a> their size may differ.</p>\n<p><strong>2)</strong> <code>int</code> to <code>float</code> is a conversion defined as \"Floating - integral conversions\":</p>\n<blockquote>\n<p id=\"so_29773711_29773975_0\">Integer or unscoped enumeration type can be converted to prvalue of any floating-point type. If the value can not be represented correctly, it is implementation defined whether the closest higher or the closest lower representable value will be selected.</p>\n</blockquote>\n", "LastActivityDate": "2015-04-21T13:43:31.333", "Score": "1", "CreationDate": "2015-04-21T13:43:31.333", "ParentId": "29773711", "CommentCount": "0", "OwnerUserId": "2812864"}, "29773711": {"ViewCount": "133", "Body": "<p>In this code:</p>\n<pre><code>void f(float f, long int i) { cout &lt;&lt; \"1\" &lt;&lt; endl; }\nvoid f(float f, float d) { cout &lt;&lt; \"2\" &lt;&lt; endl; }\n\nint main() {\n\n   f(5.0f, 5);\n\n}\n</code></pre>\n<p>there's an ambiguity. <a href=\"http://coliru.stacked-crooked.com/a/6f59c8479280168a\" rel=\"nofollow\">Check it out!</a>. However, the second argument is a signed integer. Binding an <code>int</code> to a <code>long int</code> parameter requieres a promotion, but to <code>float</code>, a conversion.</p>\n<p>Since the first argument is an exact match regarding both overloads, it doesn't count. But regarding the second parameter, its rank on the first overload (promotion) is better than the rank on the second (conversion).</p>\n<p>Why is there a resolution ambiguity, instead of choosing the first overload?</p>\n", "AcceptedAnswerId": "29773824", "Title": "C++ overload ambiguity: conversion versus promotion with primitive types", "CreationDate": "2015-04-21T13:32:43.143", "Id": "29773711", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-04-21T13:43:31.333", "Score": "4", "OwnerUserId": "1794803", "Tags": "<c++><type-conversion><overloading><type-promotion>", "AnswerCount": "3"}});